<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiunianjun.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第一章 简介线程的作用 这一段写得很好，非常易懂地概括了什么是“多线程把异步转化为同步”：把异步中的不同操作分解为一个个独立的同类型操作，然后只需实现这些相较简单的同类型操作，再异步地把它们调度起来就行。线程正是把复杂的异步工作流分解成了一组简单的同步工作流。 线程无处不在如果一个模块在代码中引入了并发性，那么它所有的代码路径【调用链】都得是并发的。   最后一句话很关键，“把线程安全性封装在共享">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程实战">
<meta property="og:url" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="修年">
<meta property="og:description" content="第一章 简介线程的作用 这一段写得很好，非常易懂地概括了什么是“多线程把异步转化为同步”：把异步中的不同操作分解为一个个独立的同类型操作，然后只需实现这些相较简单的同类型操作，再异步地把它们调度起来就行。线程正是把复杂的异步工作流分解成了一组简单的同步工作流。 线程无处不在如果一个模块在代码中引入了并发性，那么它所有的代码路径【调用链】都得是并发的。   最后一句话很关键，“把线程安全性封装在共享">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102195038586.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/wps1.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/wps2.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/wps3.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/wps4.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/wps5.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102200122078.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102200220498.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102200229901.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102200300955.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102200408861.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102200450178.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102201019332.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102201348670.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/wps6.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/wps7.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/wps8.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102201926491.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102201940603.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102202043701.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102202253296.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102202335091.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102204155544.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102202729768.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102203034529.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102203228798.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102203331822.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102203636560.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102203915238.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102203748800.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102203950728.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102204031620.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102204225493.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102220922809.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102221015006.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105163155450.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105163232378.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105163609582.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105163846509.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YyX6bi94oCZ,size_20,color_FFFFFF,t_70,g_se,x_16.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105164337363.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105164403871.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105164419485.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105164525354.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105164615006.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105164639635.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105164739481-1667638065032-4.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105164903200.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105165043425.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105165120398.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105165208197.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105165414826.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105165453198.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105165544977.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YyX6bi94oCZ,size_20,color_FFFFFF,t_70,g_se,x_16-1667638524177-6.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105171553395.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105170154847.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105170451407.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105170516201.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105165638152.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105171257946.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105194322515.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105194351358.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105194432263.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105194443414.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105194459170.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105194530237.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105194808800.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105195101889.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105195710718.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105200359583.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221105201404889.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106160450642.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106160533344.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106160651709.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106160841188.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106160956574.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106161052333.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106161424469.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106161152939.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106161113990.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106161352744.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106163700136.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106150158599.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106171312783.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0NDUzMDE=,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221106165903124.png">
<meta property="article:published_time" content="2022-11-06T09:17:14.000Z">
<meta property="article:modified_time" content="2022-11-06T09:17:42.292Z">
<meta property="article:author" content="修年">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage/hexo/blog/source_posts/Java并发编程实战/image-20221102195038586.png">

<link rel="canonical" href="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java并发编程实战 | 修年</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">修年</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiunianjun.github.io/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="修年">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修年">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发编程实战
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-06 17:17:14 / 修改时间：17:17:42" itemprop="dateCreated datePublished" datetime="2022-11-06T17:17:14+08:00">2022-11-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h1><h2 id="线程的作用"><a href="#线程的作用" class="headerlink" title="线程的作用"></a>线程的作用</h2><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102195038586.png" alt="image-20221102195038586"></p>
<p>这一段写得很好，非常易懂地概括了什么是“多线程把异步转化为同步”：把异步中的不同操作分解为一个个独立的同类型操作，然后只需实现这些相较简单的同类型操作，再异步地把它们调度起来就行。<strong>线程正是把复杂的异步工作流分解成了一组简单的同步工作流</strong>。</p>
<h2 id="线程无处不在"><a href="#线程无处不在" class="headerlink" title="线程无处不在"></a>线程无处不在</h2><p>如果一个模块在代码中引入了并发性，那么它所有的代码路径【调用链】都得是并发的。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\wps1.jpg" alt="img"> </p>
<p>最后一句话很关键，“把线程安全性封装在共享对象内部”</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\wps2.jpg" alt="img"> </p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\wps3.jpg" alt="img"> </p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\wps4.jpg" alt="img"> </p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\wps5.jpg" alt="img"> </p>
<p>这个不同于上面的方法：将共享对象包装为线程安全的。它是要求了这些共享对象仅能在事件线程中运行，这样来保证线程安全性。</p>
<h1 id="第二章-线程安全性"><a href="#第二章-线程安全性" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h1><p>**<u>线程安全的核心就是对状态的访问和操作进行管理</u>**，特别是对那些共享（shared）的、可变（mutable）的状态。关于本句话，其中几点将在下面一一细说：</p>
<ol>
<li><p>状态</p>
<p>状态是<strong>指存储在状态变量里的数据</strong>，如成员变量、静态域等等等。对象的状态还可能包括其他依赖对象的域，如HashMap的状态包括Map.Entry的状态。</p>
</li>
<li><p>共享和可变</p>
<p>共享意味着变量可以由多个线程同时访问，可变意味着变量的值在生命周期可发生变化</p>
</li>
<li><p>是否需要线程安全</p>
<p><strong>取决于它是否被多个线程访问</strong>。比如说，如果一个局部变量仅在某个函数体中同时只被一个线程访问，那么它就不需要线程安全，不需要同步机制。</p>
</li>
</ol>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102200122078.png" alt="image-20221102200122078"></p>
<h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102200220498.png" alt="image-20221102200220498"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102200229901.png" alt="image-20221102200229901"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102200300955.png" alt="image-20221102200300955"></p>
<p>注意，<strong>线程安全不会违背不变性和后验条件</strong>，这句话在后面会用到。</p>
<h3 id="无状态对象一定是线程安全的"><a href="#无状态对象一定是线程安全的" class="headerlink" title="无状态对象一定是线程安全的"></a>无状态对象一定是线程安全的</h3><p>在此举例一个无状态线程：</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102200408861.png" alt="image-20221102200408861"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatelessFactorize</span> <span class="keyword">implements</span>  <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req,ServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102200450178.png" alt="image-20221102200450178"></p>
<p><strong>无状态对象一定是线程安全的</strong></p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><p>我们可以在无状态对象的基础上为它增加一个域：</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102201019332.png" alt="image-20221102201019332"></p>
<p>这是线程不安全的，因为++count包含了三个动作：<strong>读取—修改—写入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov reg,count</span><br><span class="line">add reg,1</span><br><span class="line">mov count,reg</span><br></pre></td></tr></table></figure>

<p>它并不具有原子性。</p>
<p>在并发编程中，这种由于时序原因产生错误的情况叫做“<strong>竞态条件</strong>”。</p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102201348670.png" alt="image-20221102201348670"></p>
<p>竞态条件有两种常见的类型。两种竞态条件的本质其实都是“<strong>基于对象之前的状态来定义对象状态的转换</strong>”。对于读取-修改-写入，是先copy原值，然后对原值+1，再写回，这是基于对象之前的状态来定义对象状态的转换；对于先检查后执行，很显然就是判断原值然后再转换到下一个状态，这就不必说了。</p>
<h4 id="读取-修改-写入"><a href="#读取-修改-写入" class="headerlink" title="读取-修改-写入"></a>读取-修改-写入</h4><p>如上引例</p>
<h4 id="先检查后执行"><a href="#先检查后执行" class="headerlink" title="先检查后执行"></a>先检查后执行</h4><p>实例：懒加载，延迟初始化中的竞态条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyInitRace</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExpensiveObject</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ExpensiveObject <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">ExpensiveObject</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="竞态条件与数据竞争差别"><a href="#竞态条件与数据竞争差别" class="headerlink" title="竞态条件与数据竞争差别"></a>竞态条件与数据竞争差别</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\wps6.jpg" alt="img"></p>
<p>这书里讲得云里雾里的，百度了一下： </p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\wps7.jpg" alt="img"> </p>
<p>比如说书给例子，线程向共享对象读写数据，线程是操作对象A，共享对象是被操作对象B。则：</p>
<p>竞态条件：在乎的是被线程操控的共享对象的结果是否正确</p>
<p>数据竞争：在乎的是操作共享对象后，线程的结果是否正确。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\wps8.jpg" alt="img"> </p>
<p>确实，书里对数据竞争强调的是一个读一个写，对竞态条件更像是两个同时写 </p>
<h3 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102201926491.png" alt="image-20221102201926491"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102201940603.png" alt="image-20221102201940603"></p>
<p>我们可以用一个线程安全类来解决前面的Count请求的需求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingFactorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span>&#123; <span class="keyword">return</span> count.get(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(SevletRequest req,ServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102202043701.png" alt="image-20221102202043701"></p>
<h2 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h2><h3 id="线程安全分析法与为什么要加锁"><a href="#线程安全分析法与为什么要加锁" class="headerlink" title="线程安全分析法与为什么要加锁"></a>线程安全分析法与为什么要加锁</h3><p>上面说到，当对象内仅有<u>一个状态</u>时，可以<strong>通过使用线程安全类来保障原子性</strong>。但当对象里存在<u>多个状态</u>时，就必须<strong>用锁来进行线程同步</strong>，而非简单地用多个线程安全类。</p>
<p>还是以上面的实例来解释。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102202253296.png" alt="image-20221102202253296"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeCachingFactorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger&gt; lastNumber = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger[]&gt; lastFactors = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req,ServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此处产生了竞态条件。</span></span><br><span class="line"><span class="comment">        如果一个变量在此之后，return之前修改了lastFactors，就会寄</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (i.equals(lastNumber.get())) encodeIntoResponse(resp,lastFactors.get());</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            BigInteger[] factors = factor(i);</span><br><span class="line">            <span class="comment">//本该需要瞬间一起完成的两个动作之间有时间间隔，不具原子性</span></span><br><span class="line">            lastNumber.set(i);</span><br><span class="line">            lastFactors.set(factors);</span><br><span class="line">            encodeIntoResponse(resp,factors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102202335091.png" alt="image-20221102202335091"></p>
<p>这段论述非常精彩，昭示了两个道理：1.分析线程安全性的时候，可以从“不变性条件不被破坏”开始考虑，首先考虑<strong>不变性条件</strong>应该是什么。2.在不变性条件涉及的多个变量彼此不独立，因而这些变量需要<strong>同时同步更新</strong>，上面那个例子就是因为不变性约束条件中的两个不独立变量没有同时同步更新。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102204155544.png" alt="image-20221102204155544"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102202729768.png" alt="image-20221102202729768"></p>
<p>确实，非常重要的一点就是<strong>在两个需要连续同时修改的变量之间有了并行的时间间隔，导致此期间并行的线程的不变性被破坏</strong>。</p>
<h3 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102203034529.png" alt="image-20221102203034529"></p>
<p>同步代码块包含两部分，锁的引用和保护的代码段。关键字synchronized修饰的方法就是一段同步代码段，其锁对象为当前实例【非静态方法】或者是当前class的实例【静态方法】。</p>
<blockquote>
<p>这个具体的“锁”是什么以前是真不知道。已知的是所有Object都有wait和什么什么notify方法。不过想想也确实。所有线程争抢着访问一个对象的某个同步方法段，这不正跟所有线程争抢着一个锁是差不多意思的吗？“锁”的定义其实是很宽泛的</p>
</blockquote>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102203228798.png" alt="image-20221102203228798"></p>
<p>java的内置锁<strong>并非无饥饿</strong>的。当线程B永远不释放锁，A会一直等待下去。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102203331822.png" alt="image-20221102203331822"></p>
<p>我们可以用synchronized来解决上面的计数器问题，即直接给service方法设为synchronized。当然这种方法性能很糟糕，因为它极大降低了并发度。</p>
<h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102203636560.png" alt="image-20221102203636560"></p>
<p>其中关于粒度的理解：</p>
<p>不是“每一次调用获取一次锁，该锁属于该此调用”，而是“每个线程调用时获取一次锁，该锁属于该线程”</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102203915238.png" alt="image-20221102203915238"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102203748800.png" alt="image-20221102203748800"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingWidget</span> <span class="keyword">extends</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(toString()+<span class="string">&quot;:calling doSomething.&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上述代码，创建了一个LoggingWidget实例，然后调用该实例的dosmething方法，就会获取到该实例的锁。如果不允许重入，那么在做super.doSomething时，该实例的锁【注意，是同一个实例】已经被占用还未释放，因此产生死锁。<strong>有重入就可以避免此问题</strong>。</p>
<h2 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h2><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102203950728.png" alt="image-20221102203950728"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102204031620.png" alt="image-20221102204031620"></p>
<p>但这很考验人的记性。一旦你在某个地方忘了同步了就会寄。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102204225493.png" alt="image-20221102204225493"></p>
<h2 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h2><p>上面那个直接对service方法进行synchronized的改善方法粒度太粗了，可以试试如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedFactorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span> (<span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> BigInteger lastNumber;</span><br><span class="line">    <span class="meta">@GuardedBy</span> (<span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line">    <span class="meta">@GuardedBy</span> (<span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> <span class="type">long</span> hits;</span><br><span class="line">    <span class="meta">@GuardedBy</span> (<span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> <span class="type">long</span> cacheHits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">getHits</span><span class="params">()</span>&#123;<span class="keyword">return</span> hits;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">double</span> <span class="title function_">getCacheHitRatio</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)cacheHits/(<span class="type">double</span>) hits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req,ServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            ++hits;</span><br><span class="line">            <span class="keyword">if</span> (i.equals(lastNumber))&#123;</span><br><span class="line">                ++cacheHits;</span><br><span class="line">                factors = lastFactors.clone();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//局部变量无需同步保护</span></span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="literal">null</span>)&#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                lastNumber = i;</span><br><span class="line">                lastFactors = factors.clone();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102220922809.png" alt="image-20221102220922809"></p>
<p>毕竟因数分解的时候无需同步保护，因为这时候参与运算的都是局部变量。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221102221015006.png" alt="image-20221102221015006"></p>
<h1 id="第三章-对象的共享"><a href="#第三章-对象的共享" class="headerlink" title="第三章 对象的共享"></a>第三章 对象的共享</h1><p>上一章讲述了，线程安全的本质就是对共享和可变状态进行管理，以及介绍了用锁来保护状态。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105163155450.png" alt="image-20221105163155450"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105163232378.png" alt="image-20221105163232378"></p>
<p>所以本章在上面的<u>原子性</u>【序列不变性】的基础上，引入了“<strong>同步</strong>”的新的注意点：<u>内存可见性</u>。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="引例——可见性的定义"><a href="#引例——可见性的定义" class="headerlink" title="引例——可见性的定义"></a>引例——可见性的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!ready)&#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">        number=<span class="number">42</span>;</span><br><span class="line">        ready=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105163609582.png" alt="image-20221105163609582"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105163846509.png" alt="image-20221105163846509"></p>
<blockquote>
<p>关于此程序显示出的对于内存可见性的理解，可以看这篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_55161603/article/details/122488932">多线程(六):并发编程的三大特性之可见性</a></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YyX6bi94oCZ,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>其实原因非常显而易见：主线程改了之后不会立刻把变量刷新到主存【可能默认是在ret时刷新，或者定时刷新，前者会导致相互等待的死锁，后者也会产生性能问题】，导致主线程的那个修改的flag变量对t1线程是**<u>不可见</u>**的，因此t1会继续循环等待。</p>
</blockquote>
<h3 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105164337363.png" alt="image-20221105164337363"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105164403871.png" alt="image-20221105164403871"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105164419485.png" alt="image-20221105164419485"></p>
<h3 id="最低安全性"><a href="#最低安全性" class="headerlink" title="最低安全性"></a>最低安全性</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105164525354.png" alt="image-20221105164525354"></p>
<p>注意，<strong>最低安全性不适用于非volatile类型的64位数据。</strong></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105164615006.png" alt="image-20221105164615006"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105164639635.png" alt="image-20221105164639635"></p>
<h3 id="加锁与可见性"><a href="#加锁与可见性" class="headerlink" title="加锁与可见性"></a>加锁与可见性</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105164739481-1667638065032-4.png" alt="image-20221105164739481"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105164903200.png" alt="image-20221105164903200"></p>
<p>要实现这种操作，我们可以设想一下关于内存可见性这一块内置锁的实现原理：<u>lock时绑定指定变量，unlock时再刷新这个/些绑定变量的内存</u>。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105165043425.png" alt="image-20221105165043425"></p>
<p>所以说得有锁，并且锁还得是对的。</p>
<p>看着看着有种always语句块的感觉了2333</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105165120398.png" alt="image-20221105165120398"></p>
<h3 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h3><h4 id="Volatile保证内存可见性"><a href="#Volatile保证内存可见性" class="headerlink" title="Volatile保证内存可见性"></a>Volatile保证内存可见性</h4><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105165208197.png" alt="image-20221105165208197">到其他线程。【我想大概就是一改变了，就马上刷新内存中的旧值，然后也许通过什么嗅探检测到值变化，通知所有线程改变自己持有的旧值。】</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105165414826.png" alt="image-20221105165414826"></p>
<p><u>注意不放在寄存器里或者线程的私有栈里</u></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105165453198.png" alt="image-20221105165453198"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105165544977.png" alt="image-20221105165544977"></p>
<blockquote>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YyX6bi94oCZ,size_20,color_FFFFFF,t_70,g_se,x_16-1667638524177-6.png" alt="img"></p>
</blockquote>
<h4 id="Volatile不保证原子性"><a href="#Volatile不保证原子性" class="headerlink" title="Volatile不保证原子性"></a>Volatile不保证原子性</h4><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105171553395.png" alt="image-20221105171553395"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46190347/article/details/109908724">volatile为什么不能保证原子性？</a>   </p>
<p>但这个有争议：</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105170154847.png" alt="image-20221105170154847"></p>
<ul>
<li>在多处理器下，为了保证各个处理器的缓存是一致的，就会<strong>实现缓存一致性协议</strong>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，<strong>会重新从系统内存中把数据读到处理器缓存里</strong>。</li>
</ul>
<p>也就是说，</p>
<p>如果线程B在+1前知道数据无效了，就会重新载入数据然后+1然后载入内存，结果正确；</p>
<p>如果线程B在+1后才知道数据无效，虽然会重新载入数据，数据为A修改后的新数据，但是此时指令无法回退，因而只能继续执行下一条指令：写回内存，B写回内存的是A修改后的新数据，因而结果错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">大致过程：</span><br><span class="line">a:mov reg 1</span><br><span class="line">b:mov reg 1</span><br><span class="line">a:add reg 1</span><br><span class="line">b:add reg 1</span><br><span class="line">a:mov reg mem</span><br><span class="line">然后b线程得到通知，重新载入数据:mov reg mem</span><br><span class="line">但是指令无法回退：mov reg mem</span><br><span class="line">因而结果是A修改后的值被写入了两遍。</span><br></pre></td></tr></table></figure>

<p>所以其实<strong>volatile仅确保单次读写的瞬时线程安全</strong>。<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105170451407.png" alt="image-20221105170451407"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105170516201.png" alt="image-20221105170516201"></p>
<p>以下是别人的理解扩展：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/keeya/p/9255136.html">对volatile不具有原子性的理解</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/391996453?page=1">volatile 无法保证原子性一个简单示例的疑问</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析 </a></p>
</blockquote>
<h4 id="Volatile的使用方法"><a href="#Volatile的使用方法" class="headerlink" title="Volatile的使用方法"></a>Volatile的使用方法</h4><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105165638152.png" alt="image-20221105165638152"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105171257946.png" alt="image-20221105171257946"></p>
<p>下面给出一个volatile的典型用法：检查某个状态标记以判断是否退出循环。【也就是上文那个例子】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> asleep;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">	<span class="keyword">while</span>(!asleep)	countingSheep();</span><br></pre></td></tr></table></figure>



<h2 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h2><h3 id="发布与逸出的概念"><a href="#发布与逸出的概念" class="headerlink" title="发布与逸出的概念"></a>发布与逸出的概念</h3><h4 id="通俗地解释发布和逸出"><a href="#通俗地解释发布和逸出" class="headerlink" title="通俗地解释发布和逸出"></a>通俗地解释发布和逸出</h4><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105194322515.png" alt="image-20221105194322515"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105194351358.png" alt="image-20221105194351358"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105194432263.png" alt="image-20221105194432263"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105194443414.png" alt="image-20221105194443414"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105194459170.png" alt="image-20221105194459170"></p>
<p>这个“逸出作用域”的表述非常不错。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105194530237.png" alt="image-20221105194530237"></p>
<h4 id="什么时候会发生发布和逸出"><a href="#什么时候会发生发布和逸出" class="headerlink" title="什么时候会发生发布和逸出"></a>什么时候会发生发布和逸出</h4><h5 id="外部方法"><a href="#外部方法" class="headerlink" title="外部方法"></a>外部方法</h5><p><u>当把一个对象传递给某个外部方法，就相当于发布了这个对象</u>。</p>
<p>外部方法：<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105194808800.png" alt="image-20221105194808800"></p>
<h5 id="发布内部的类实例"><a href="#发布内部的类实例" class="headerlink" title="发布内部的类实例"></a>发布内部的类实例</h5><p>“this escape”</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105195101889.png" alt="image-20221105195101889"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">(EventSource source)</span>&#123;</span><br><span class="line">        id = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//发布</span></span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="comment">//内部类</span></span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">EventListener</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span>&#123;</span><br><span class="line">                    <span class="comment">//doSomething(e);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        name = <span class="string">&quot;escape&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34348050/article/details/114174525">java this 逸出_Java并发编程——this引用逸出(“this” Escape)</a></p>
<p>并发编程实践中，this引用逃逸(“this”escape)是指对象还没有构造完成，它的this引用就被发布出去了。</p>
<p>ThisEscape在构造函数中引入了一个内部类EventListener，而内部类会自动的持有其外部类(这里是ThisEscape)的this引用。source.registerListener会将内部类发布出去，从而ThisEscape.this引用也随着内部类被发布了出去。但此时ThisEscape对象还没有构造完成 —— id已被赋值为1，但name还没被赋值，仍然为null。这样一来，就有些线程持有不完整实例，不确定性太大了</p>
</blockquote>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105195710718.png" alt="image-20221105195710718"></p>
<p>也就是说，如果是单线程情况下，这样做是没问题的，毕竟最后都会构造完整。但多线程情况下，这俩有时间间隔，因此会产生问题，并且不能靠简单地把这句发布对象的语句放在构造函数最后一行。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105200359583.png" alt="image-20221105200359583"></p>
<p><u><strong>这段话非常值得注意</strong></u></p>
<p>所以说上面那个例子的正确代码：</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221105201404889.png" alt="image-20221105201404889"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SafeListener</span><span class="params">()</span>&#123;</span><br><span class="line">        listener = <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span>&#123;</span><br><span class="line">                <span class="comment">//doSomething(e);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title function_">newInstance</span><span class="params">(EventSource source)</span>&#123;</span><br><span class="line">        <span class="type">SafeListener</span> <span class="variable">safe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SafeListener</span>();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><h3 id="线程封闭是什么"><a href="#线程封闭是什么" class="headerlink" title="线程封闭是什么"></a>线程封闭是什么</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106160450642.png" alt="image-20221106160450642"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106160533344.png" alt="image-20221106160533344"></p>
<p>线程封闭一般有三种方法，这三种方法的规范性是逐级递增的。</p>
<h3 id="Ad-hoc线程封闭"><a href="#Ad-hoc线程封闭" class="headerlink" title="Ad-hoc线程封闭"></a>Ad-hoc线程封闭</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106160651709.png" alt="image-20221106160651709"></p>
<blockquote>
<p>这里，书写得非常地抽象。通过查阅资料可得解释得更通俗的：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iteye_2159/article/details/82549680">Ad-hoc线程封闭</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9039503/example-of-ad-hoc-thread-confinement-in-java">Example of ad hoc thread confinement in Java</a></p>
<p>总之其实精华就这一句话：<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106160841188.png" alt="image-20221106160841188"></p>
<p>并且都是人为约束，并且一般可能会用volatile来控制单线程写这种情况下的同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don&#x27;t modify this from any other thread than Thread X.</span></span><br><span class="line"><span class="comment">// So use it read-only for those other threads.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> someNumber;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106160956574.png" alt="image-20221106160956574"></p>
<p>也就是我们前面说的，局部变量只能在该线程内访问，除非逸出了，否则是非常安全的。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106161052333.png" alt="image-20221106161052333"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106161424469.png" alt="image-20221106161424469"></p>
<h4 id="对于基本类型"><a href="#对于基本类型" class="headerlink" title="对于基本类型"></a>对于基本类型</h4><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106161152939.png" alt="image-20221106161152939"></p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106161113990.png" alt="image-20221106161113990">意思就是说，java没有指针，获取不了这些不是对象的基本类型的引用，因而这些基本类型不可能通过调用外部方法之类的逸出【调用外部方法仅仅是取得它们的一份copy而非本身】，所以这些基本类型的局部变量始终封闭在线程内。</p>
<h4 id="对于引用类型"><a href="#对于引用类型" class="headerlink" title="对于引用类型"></a>对于引用类型</h4><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106161352744.png" alt="image-20221106161352744"></p>
<p>因而需要格外注意逸出问题</p>
<p>下面给出对基本类型和引用类型栈封闭的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span>&#123;</span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    SortedSet&lt;Animal&gt; animals;</span><br><span class="line">    <span class="comment">//基本类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numPairs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">candidate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要详细写好注释↓</span></span><br><span class="line">    <span class="comment">//animals被封闭在方法中，不要使它们逸出！</span></span><br><span class="line">    animals = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Animal&gt;(<span class="keyword">new</span> <span class="title class_">SpeciesGenderComparator</span>());</span><br><span class="line">    animals.addAll(candidates);</span><br><span class="line">    <span class="keyword">for</span> (Animal a : animals)&#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate == <span class="literal">null</span> || !candidate.isPotentialMate(a))</span><br><span class="line">                candidate = a;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ark.load(<span class="keyword">new</span> <span class="title class_">AnimalPair</span>(candidate,a));</span><br><span class="line">            ++numPairs;</span><br><span class="line">            candidate = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;<span class="type">char</span>[]&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numPairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010445301/article/details/111322569">史上最全ThreadLocal 详解（一）</a></p>
</blockquote>
<h4 id="简介和应用实例"><a href="#简介和应用实例" class="headerlink" title="简介和应用实例"></a>简介和应用实例</h4><p>上面介绍了使用局部变量来实现线程封闭的方法，也就是栈封闭。它只要合理地控制在调用方法时不发生逸出，就可以实现线程安全。</p>
<p>当有多个线程都需要同一类对象【比如Connection对象、ThreadID】，并且要求每个线程内的该对象是不一样的，并且该对象需要在多个方法中访问，栈封闭的方法就显得有些麻烦和不够优雅：需要在每个线程内都创建一个不同的对象实例，并且在调用方法的时候，都把该对象实例作为参数传进去。</p>
<p>这时候就需要ThreadLocal类了。</p>
<p>ThreadLocal类会给每个线程分配一个对象，并且仅需使用get方法，就能自动地把线程中的对象给弄出来。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106163700136.png" alt="image-20221106163700136"></p>
<p>以ThreadID为例：</p>
<p>For example, the class below generates unique identifiers local to each thread. A thread’s id is assigned the first time it invokes ThreadId.get() and remains unchanged on subsequent calls.下面代码保证每个线程首次调用ThreadId.get方法后可以分配到一个不重ID，并且ID一旦确定，之后再调用get方法得到的ID是不会改变的。它这相当于维护了一个共有的计数器局部变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadId</span> &#123;</span><br><span class="line">    <span class="comment">// Atomic integer containing the next thread ID to be assigned</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Thread local variable containing each thread&#x27;s ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nextId.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Returns the current thread&#x27;s unique ID, assigning it if necessary</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadId.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个想获取自身ThreadID的线程，在所有想用到ID的方法中，只需：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">AtomicInteger</span> <span class="variable">myID</span> <span class="operator">=</span> ThreadID.get();</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而不用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">myID</span> <span class="operator">=</span> getID();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method</span><span class="params">(AtomicInteger myID)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样大大简化了实现。</p>
<p>再比如：</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106150158599.png" alt="image-20221106150158599"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> Connection <span class="title function_">initialValue</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106171312783.png" alt="image-20221106171312783"></p>
<p>关于这个的大概代码猜想：</p>
<p>这样一来，在一个线程中使用toString，就仅需造一个buf【这个是ThreadLocal封闭】，而不用每次调用都造一个【这个是栈封闭】了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;<span class="type">char</span>[]&gt; buf</span><br><span class="line"> 	= <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;<span class="type">char</span>[]&gt;()&#123;</span><br><span class="line"> 		<span class="meta">@Override</span></span><br><span class="line"> 		<span class="keyword">public</span> <span class="type">char</span>[] initialValue()&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">12</span>];</span><br><span class="line">         &#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="comment">//使用buf</span></span><br><span class="line"> <span class="type">char</span>[] buffer = buf.get();</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><h5 id="大致结构"><a href="#大致结构" class="headerlink" title="大致结构"></a>大致结构</h5><p>我们可以初步猜想，ThreadLocal大概是通过一个map实现的，里面存储着&lt;Thread,value&gt;这样的键值对，每次就能通过Thread来取出对应的value了。Java低版本确实是这么做的。但Java的高版本对此进行了优化。</p>
<p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0NDUzMDE=,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>从本来的：ThreadLocalMap&lt;Thread, value&gt; ∈ ThreadLocal</p>
<p>变成了：    ThreadLocalMap&lt;ThreadLocal, value&gt; ∈ Thread</p>
<p>并且其中的ThreadLocal这个key是以弱引用【WeakReference】的方式实现的。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_49684062/article/details/124875810">ThreadLocal探究</a></p>
<p>这样的结构演进有什么好处<br>在旧版的ThreadLocal中，所有线程都将本地变量存在同一个ThreadLocalMap中，当并发量比较高的时候，ThreadLocalMap中的数据量会很大，而新版的ThreadLocalMap是属于线程的，也就是每个线程都操作属于自己的ThreadLocalMap，那么map中存储的变量就只有自己所存入的，数据量大大减少。</p>
<p>还有一个好处，旧版的ThreadLocalMap属于ThreadLocal，当Thread实例被销毁时ThreadLocalMap里该线程的数据<u>不会被同时销毁</u>【这也许就带来了危险性】，而新版ThreadLocalMap属于线程，<u>线程被销毁时，ThreadLocalMap也随之销毁</u>。</p>
</blockquote>
<h5 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h5><blockquote>
<p>This class provides thread-local variables.线程局部变量，也就是我们说的线程封闭手法。</p>
<p>These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. 每个线程都有它自己的、独立初始化的该变量的副本。</p>
<p>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).它一般用于私有静态字段，whose 状态和线程关系密切。</p>
<p>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible.</p>
<p>After a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).最后会被垃圾回收</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    它这个初始化方法非常聪明且独特。</span></span><br><span class="line"><span class="comment">    一般使用它的时候是直接new然后重载一个匿名内部类的，</span></span><br><span class="line"><span class="comment">    于是就直接在建立匿名内部类时override此方法，在里面构造初始化的对象，</span></span><br><span class="line"><span class="comment">    且该方法仅在get调用的时候才会顺带调用</span></span><br><span class="line"><span class="comment">    有一种lazy的思想在里面。</span></span><br><span class="line"><span class="comment">    Normally, this method is invoked at most once per thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Creates a thread local variable.</span></span><br><span class="line">    <span class="comment">//The initial value of the variable is determined by Supplier的get方法.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="title function_">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//也就是说，每个线程都有个ThreadLocal的map成员变量</span></span><br><span class="line">        <span class="comment">//里面装的是&lt;ThreadLocal变量，该变量在该线程的值&gt;这样的键值对</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//得到线程里存储的ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//&lt;ThreadLocal, value&gt;</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map==null【还没有线程局部变量】或者e==null【还没有该线程局部变量】</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">return</span> map != <span class="literal">null</span> &amp;&amp; map.getEntry(<span class="built_in">this</span>) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取初始化值</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//传入空map的第一个结点</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">            TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">            m.remove(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> ThreadLocalMap <span class="title function_">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T <span class="title function_">childValue</span><span class="params">(T parentValue)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line"></span><br><span class="line">        SuppliedThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier) &#123;</span><br><span class="line">            <span class="built_in">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ThreadLocalMap is a customized hash map suitable only for maintaining thread local values.</span></span><br><span class="line"><span class="comment">    To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.key【ThreadLocal】是弱引用的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Note that null keys (i.e. entry.get() == null) mean that the key is no longer referenced, so the entry can be expunged from table. Such entries are referred to as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">   		意思就是说陈旧条目【stale entry】指的是key为空的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">//The value associated with this ThreadLocal.</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//The initial capacity -- MUST be a power of two.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//The next size value at which to resize.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set the resize threshold to maintain at worst a 2/3 load factor.</span></span><br><span class="line">        <span class="comment">//默认情况下，装载因子为2/3</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">            threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使i增加，并且让增加后的结果模len。也就是(++i)%len。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//也就是(--i)%len。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Construct a new map initially containing (firstKey, firstValue). </span></span><br><span class="line">        <span class="comment">//ThreadLocalMaps are constructed lazily,</span></span><br><span class="line">        <span class="comment">//so we only create one when we have at least one entry to put in it.</span></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">            <span class="comment">//依旧是HashMap里面经典的掩码操作，key的hashcode作为entry在table里的序号</span></span><br><span class="line">            <span class="comment">//与hashmap的差别就在于，hashmap的桶table一个里面可以存放多个结点，</span></span><br><span class="line">            <span class="comment">//但这里的ThreadLocal的hash显然是不冲突的，因而只能存放一个结点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">            Entry[] parentTable = parentMap.table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">            setThreshold(len);</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[len];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> parentTable[j];</span><br><span class="line">                <span class="comment">//有对应结点</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                    <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                        <span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (table[h] != <span class="literal">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        table[h] = c;</span><br><span class="line">                        size++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">                 e != <span class="literal">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">                 e != <span class="literal">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">            <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">            <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">            <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">                 i = prevIndex(i, len))</span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">            <span class="comment">// occurs first</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">                <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">                <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">                <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">                <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">                <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">                <span class="comment">// first still present in the run.</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">            tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">            tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                    e.value = <span class="literal">null</span>;</span><br><span class="line">                    tab[i] = <span class="literal">null</span>;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                        tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                        <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                        <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">                    n = len;</span><br><span class="line">                    removed = <span class="literal">true</span>;</span><br><span class="line">                    i = expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">            expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">            Entry[] oldTab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">            Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                        e.value = <span class="literal">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                            h = nextIndex(h, newLen);</span><br><span class="line">                        newTab[h] = e;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setThreshold(newLen);</span><br><span class="line">            size = count;</span><br><span class="line">            table = newTab;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">                    expungeStaleEntry(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li><h6 id="哈希方法和解决哈希冲突"><a href="#哈希方法和解决哈希冲突" class="headerlink" title="哈希方法和解决哈希冲突"></a>哈希方法和解决哈希冲突</h6><p><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/aWorkStorage\hexo\blog\source_posts\Java并发编程实战\image-20221106165903124.png" alt="image-20221106165903124"></p>
<p>存在哈希冲突的话，大概是采用的线性探测方法。</p>
</li>
<li><h6 id="解决内存泄漏"><a href="#解决内存泄漏" class="headerlink" title="解决内存泄漏"></a>解决内存泄漏</h6><p>关于其remove方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">	<span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">		m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m.remove</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//线性探测</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">                 e != <span class="literal">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>两篇文章都有解释</p>
<blockquote>
<p> remove方法，直接将ThrealLocal 对应的值从当前相差Thread中的ThreadLocalMap中删除。为什么要删除，这涉及到内存泄露的问题。</p>
<p> 实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p>
<p> 所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p>
<p> ThreadLocal其实是与线程绑定的一个变量，如此就会出现一个问题：如果没有将ThreadLocal内的变量删除（remove）或替换，它的生命周期将会与线程共存。通常线程池中对线程管理都是采用线程复用的方法，在线程池中线程很难结束甚至于永远不会结束，这将意味着线程持续的时间将不可预测，甚至与JVM的生命周期一致。举个例字，如果ThreadLocal中直接或间接包装了集合类或复杂对象，每次在同一个ThreadLocal中取出对象后，再对内容做操作，那么内部的集合类和复杂对象所占用的空间可能会开始持续膨胀。<br> ————————————————<br> 版权声明：本文为CSDN博主「倔强的不服」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010445301/article/details/111322569">https://blog.csdn.net/u010445301/article/details/111322569</a></p>
</blockquote>
<blockquote>
<p>ThreadLocal内存泄漏问题的解析。<br>前面我们说到它虽然线程安全，但是它存在一个问题那就是内存泄漏。</p>
<p>首先我们要明白为什么会内存泄漏，前面也说了ThreaLocal是一个弱引用，什么是弱引用就是当它为null时候，就会被垃圾回收机制给带走，重点就是，如果我们的ThreadLocal突然为null，然后就被回收了，但此时我们的ThreadLocalMap它的生命周期是和Thread相同的，简单理解就是，裤子没了，兜还在，兜里面还有我们的数据，这就造成了内存泄漏。</p>
<p>如何解决那：我们必须在使用完ThreadLocal后，执行remove()方法，避免内存溢出。<br>————————————————<br>版权声明：本文为CSDN博主「某刘姓男子i的码农客栈」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20783497/article/details/107980858">https://blog.csdn.net/qq_20783497/article/details/107980858</a></p>
</blockquote>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/22/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A2%E3%80%90Map%E9%83%A8%E5%88%86%E3%80%91/" rel="prev" title="阅读JDK容器部分源码的心得体会2【Map部分】">
      <i class="fa fa-chevron-left"></i> 阅读JDK容器部分源码的心得体会2【Map部分】
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">第一章 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">线程的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8"><span class="nav-number">1.2.</span> <span class="nav-text">线程无处不在</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">第二章 线程安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">2.1.</span> <span class="nav-text">什么是线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="nav-number">2.1.2.</span> <span class="nav-text">无状态对象一定是线程安全的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E4%BE%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">引例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.2.2.</span> <span class="nav-text">竞态条件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96-%E4%BF%AE%E6%94%B9-%E5%86%99%E5%85%A5"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">读取-修改-写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E6%A3%80%E6%9F%A5%E5%90%8E%E6%89%A7%E8%A1%8C"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">先检查后执行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E5%B7%AE%E5%88%AB"><span class="nav-number">2.2.3.</span> <span class="nav-text">竞态条件与数据竞争差别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.4.</span> <span class="nav-text">复合操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">2.3.</span> <span class="nav-text">加锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E6%B3%95%E4%B8%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E9%94%81"><span class="nav-number">2.3.1.</span> <span class="nav-text">线程安全分析法与为什么要加锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E9%94%81"><span class="nav-number">2.3.2.</span> <span class="nav-text">内置锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%85%A5"><span class="nav-number">2.3.3.</span> <span class="nav-text">重入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E9%94%81%E6%9D%A5%E4%BF%9D%E6%8A%A4%E7%8A%B6%E6%80%81"><span class="nav-number">2.4.</span> <span class="nav-text">用锁来保护状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BB%E8%B7%83%E6%80%A7%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="nav-number">2.5.</span> <span class="nav-text">活跃性与性能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="nav-number">3.</span> <span class="nav-text">第三章 对象的共享</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text">可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E4%BE%8B%E2%80%94%E2%80%94%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">引例——可见性的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B1%E6%95%88%E6%95%B0%E6%8D%AE"><span class="nav-number">3.1.2.</span> <span class="nav-text">失效数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%8E%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">3.1.3.</span> <span class="nav-text">最低安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">3.1.4.</span> <span class="nav-text">加锁与可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.1.5.</span> <span class="nav-text">Volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Volatile%E4%BF%9D%E8%AF%81%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">Volatile保证内存可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">3.1.5.2.</span> <span class="nav-text">Volatile不保证原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.5.3.</span> <span class="nav-text">Volatile的使用方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E9%80%B8%E5%87%BA"><span class="nav-number">3.2.</span> <span class="nav-text">发布与逸出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E9%80%B8%E5%87%BA%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">3.2.1.</span> <span class="nav-text">发布与逸出的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E4%BF%97%E5%9C%B0%E8%A7%A3%E9%87%8A%E5%8F%91%E5%B8%83%E5%92%8C%E9%80%B8%E5%87%BA"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">通俗地解释发布和逸出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E5%8F%91%E5%B8%83%E5%92%8C%E9%80%B8%E5%87%BA"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">什么时候会发生发布和逸出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.2.1.</span> <span class="nav-text">外部方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E5%86%85%E9%83%A8%E7%9A%84%E7%B1%BB%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.2.1.2.2.</span> <span class="nav-text">发布内部的类实例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD"><span class="nav-number">3.3.</span> <span class="nav-text">线程封闭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.3.1.</span> <span class="nav-text">线程封闭是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ad-hoc%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD"><span class="nav-number">3.3.2.</span> <span class="nav-text">Ad-hoc线程封闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%B0%81%E9%97%AD"><span class="nav-number">3.3.3.</span> <span class="nav-text">栈封闭</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">对于基本类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">对于引用类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E7%B1%BB"><span class="nav-number">3.3.4.</span> <span class="nav-text">ThreadLocal类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B%E5%92%8C%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">简介和应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%A7%E8%87%B4%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.4.2.1.</span> <span class="nav-text">大致结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB"><span class="nav-number">3.3.4.2.2.</span> <span class="nav-text">源码阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E6%96%B9%E6%B3%95%E5%92%8C%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="nav-number">3.3.4.2.2.1.</span> <span class="nav-text">哈希方法和解决哈希冲突</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">3.3.4.2.2.2.</span> <span class="nav-text">解决内存泄漏</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">修年</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">修年</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
