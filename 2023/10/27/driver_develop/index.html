<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="修年">





<title>驱动开发小记 | 修年</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiunian&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiunian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc" style="right: -4em;">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">驱动开发小记</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">修年</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 27, 2023&nbsp;&nbsp;20:24:15</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>此为<a target="_blank" rel="noopener" href="https://github.com/lazyparser/weloveinterns/blob/master/open-internships.md#bj71-rt-thread-%E7%A4%BE%E5%8C%BA%E5%AE%9E%E4%B9%A0%E7%94%9F-3%E4%B8%AA%E5%90%8D%E9%A2%9D">PLCT Lab BJ71</a>实习内容，我的工作是为RT-Thread完善Milk-v Duo开发板支持。</p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><p><a href="https://xiunianjun.github.io/2023/10/19/open-source-9.19-10.19/#:~:text=%E7%AC%94%E4%BB%A3%E7%A0%81%E8%B4%9F%E8%B4%A3%E3%80%82-,gpio%20driver,-pr%EF%BC%9A">感受</a>之前已经详细记录过了，在此便不再赘述。这里只写一些开发流程和最终代码框架展示。</p>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="10-13—概述"><a href="#10-13—概述" class="headerlink" title="10.13—概述"></a>10.13—概述</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>首先了解一下gpio是什么。</p>
<p>芯片上的引脚一般分为 4 类：电源、时钟、控制与 I/O，I/O 口在使用模式上又分为 General Purpose Input Output（通用输入 / 输出），简称 GPIO，与功能复用 I/O（如 SPI/I2C/UART 等）。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56694518/article/details/131207367">https://blog.csdn.net/m0_56694518/article/details/131207367</a></p>
<p>GPIO是英文<strong>General Purpose Input/Output</strong>的缩写，中文翻译为通用输入/输出。它是一种在数字电子系统中常见的接口类型，用于与外部设备进行通信和控制。</p>
<p>GPIO接口可以作为输入或输出引脚使用。作为输入引脚时，GPIO可以接收来自外部设备的电信号，并将其转换为数字信号，供系统内部使用。作为输出引脚时，GPIO可以将数字信号发送到外部设备，从而实现对其的控制。</p>
<ol>
<li><p>引脚：GPIO接口通常由一组引脚组成，每个引脚都可以用作输入或输出。每个引脚都有一个唯一的标识符，如GPIO0、GPIO1等。</p>
</li>
<li><p>输入模式：当GPIO引脚配置为输入模式时，它可以接收外部设备发送的电信号。通常，输入引脚可以读取高电平（1）或低电平（0）状态，或者在某些系统中可以读取模拟信号。</p>
</li>
<li><p>输出模式：当GPIO引脚配置为输出模式时，它可以向外部设备发送数字信号。输出引脚可以设置为高电平（1）或低电平（0），以控制连接的设备的状态。</p>
</li>
<li><p>状态和电平：GPIO引脚的状态表示当前引脚的输入或输出电平。高电平通常表示逻辑1，低电平表示逻辑0。在某些系统中，还可以使用其他状态，如浮空、上拉和下拉等。</p>
</li>
<li><p>控制寄存器：<strong>为了配置和控制GPIO引脚的功能，通常需要通过写入特定的控制寄存器来设置引脚的模式、状态和电平。这些寄存器的具体配置取决于所使用的硬件平台和操作系统。</strong>【这个估计就是我们驱动要干的】</p>
</li>
</ol>
</blockquote>
<p>也就是意思就是，这个gpio相当于一个接口，能够把系统的信号传给硬件，也能把硬件信号传给系统。所以有时候我们可以通过读写其寄存器来与硬件交互。比如， GPIO每个引脚连接着一个led，那么我们通过读写gpio的控制寄存器，控制每个引脚输出1/0，就可以控制led灯亮or灭。</p>
<blockquote>
<p>GPIO的实际应用非常广泛，以下是一些常见的示例：</p>
<ol>
<li><p>控制LED：将GPIO引脚配置为输出模式，可以通过设置引脚的高低电平状态来<strong>控制</strong>LED的亮灭。</p>
</li>
<li><p>按钮输入：将GPIO引脚配置为输入模式，可以连接按钮或开关，并通过读取引脚的电平状态来<strong>检测</strong>按钮是否被按下或开关是否打开。</p>
</li>
<li><p>传感器接口：通过GPIO引脚，可以连接各种传感器，如温度传感器、湿度传感器、光照传感器等。传感器的<strong>输出</strong>信号可以通过读取GPIO引脚的状态来获取。</p>
</li>
<li><p>驱动电机：通过GPIO引脚，可以连接电机驱动器，并通过设置引脚的高低电平状态来<strong>控制</strong>电机的运行方向和速度。</p>
</li>
<li><p>与外部设备通信：通过GPIO引脚，可以与其他外部设备进行通信，如显示器、LCD屏幕、数码管等。通过设置引脚的状态和电平，可以<strong>发送数据或控制命令</strong>。</p>
</li>
<li><p>脉冲宽度调制（PWM）输出：一些GPIO引脚支持PWM功能，可以生成模拟信号，用于<strong>控制</strong>电机速度、调节LED亮度等需要模拟输出的应用。</p>
</li>
<li><p><strong>扩展IO功能：通过使用扩展芯片或GPIO扩展板，可以增加系统的GPIO引脚数量，从而实现更多外部设备的控制和通信。</strong></p>
</li>
</ol>
</blockquote>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><blockquote>
<p><strong>4 个 32 位 配 置 寄 存 器</strong></p>
<ol>
<li><p>GPIOx_MODER 模式寄存器</p>
<p>用于配置GPIO引脚的模式（<strong>输入或输出</strong>）。<u>每个引脚通常使用两个位表示模式</u>，例如00表示输入模式，01表示输出模式。</p>
</li>
<li><p>GPIOx_OTYPER 输出模式寄存器</p>
<p>用于配置GPIO引脚的输出类型。<u>每个引脚通常使用一个位表示输出类型</u>，例如0表示推挽输出，1表示开漏输出。</p>
</li>
<li><p>GPIOx_ OSPEEDR 输出速度寄存器</p>
<p>用于配置GPIO引脚的输出速度。<u>每个引脚通常使用两个位表示输出速度</u>，例如00表示低速，11表示高速。</p>
</li>
<li><p>GPIOx_PUPDR 上拉下拉寄存器</p>
<p>用于配置GPIO引脚的上拉或下拉电阻。<u>每个引脚通常使用两个位表示上拉/下拉配置</u>，例如00表示无上拉/下拉，01表示上拉，10表示下拉。</p>
</li>
</ol>
<p><strong>2 个 32 位数据寄存器</strong><br>GPIOx_IDR 输入数据寄存器<br>GPIOx_ODR 输出数据寄存器</p>
<p>每个位对应一个引脚，读取/写入该位。</p>
<p><strong>1个 32 位置位 / 复位寄存器</strong><br>GPIOx_BSRR 置位 / 复位寄存器</p>
<p>用于通过设置或复位位来控制GPIO引脚的输出电平。每个引脚通常使用两个位，一个位用于置位（设置为1），另一个位用于复位（设置为0）。</p>
<p><strong>2 个 32 位复用功能寄存器</strong><br>GPIOx_AFRH<br>GPIOx_AFRL</p>
<p>用于配置GPIO引脚的复用功能，例如将引脚用作特定的外设功能（如UART、SPI等）。这些寄存器通常将32位分为两个部分，每个部分对应一组引脚。</p>
</blockquote>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/612333717?utm_id=0">https://zhuanlan.zhihu.com/p/612333717?utm_id=0</a></p>
</blockquote>
<p><img src="/2023/10/27/driver_develop/v2-9ece20d4c5fb58bd9c9736a14e952403_1440w.webp" alt="v2-9ece20d4c5fb58bd9c9736a14e952403_1440w"></p>
<p>原来上下拉是这个意思啊，就是缺省值呗。</p>
<p>一般来说，开漏输出连接上拉输入或浮空输入的外部元件，推挽输出连接下拉输入的外部元件。</p>
<p>当引脚具有复用功能时，它可以在不同的工作模式下切换为不同的功能，而无需切换整个 GPIO 模式。</p>
<h4 id="找到测试程序"><a href="#找到测试程序" class="headerlink" title="找到测试程序"></a>找到测试程序</h4><p>感觉其实思路还是比较清晰。看这个：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://milkv.io/zh/docs/duo/application-development/wiringx">https://milkv.io/zh/docs/duo/application-development/wiringx</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/milkv-duo/duo-examples/blob/main/README-zh.md">https://github.com/milkv-duo/duo-examples/blob/main/README-zh.md</a></p>
</blockquote>
<p>也即我最后gpio的效果就是能够运行它给的这个blink example就行。等下回去试下用linux和rtt试试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> DUO_LED = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    rt_pin_mode(DUO_LED, PIN_MODE_OUTPUT);</span><br><span class="line">    rt_pin_write(DUO_LED, PIN_LOW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123; <span class="comment">// 闪烁十次</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;Duo LED GPIO (wiringX) %d: High\n&quot;</span>, DUO_LED);</span><br><span class="line">        rt_pin_write(DUO_LED, PIN_HIGH);</span><br><span class="line">        rt_thread_delay(RT_TICK_PER_SECOND);</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Duo LED GPIO (wiringX) %d: Low\n&quot;</span>, DUO_LED);</span><br><span class="line">        rt_pin_write(DUO_LED, PIN_LOW);</span><br><span class="line">        rt_thread_delay(RT_TICK_PER_SECOND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之明天试着开始写吧，我也不知道怎么办了该。可以先问下老师确认led是哪个。我看文档写的GPIOC24但是压根没那东西。</p>
<h3 id="10-14—找到型号"><a href="#10-14—找到型号" class="headerlink" title="10.14—找到型号"></a>10.14—找到型号</h3><p>感觉可以从相同型号的gpio入手。查了下compatible，这东西好像是什么海思研发的什么the synopsys DW gpio。</p>
<blockquote>
<p>/home/xiunian/rt-thread/milkv-duo-buildroot-sdk/linux_5.10/drivers/gpio/gpio-dwapb.c</p>
<p><a target="_blank" rel="noopener" href="https://lkml.org/lkml/2020/8/22/19">https://lkml.org/lkml/2020/8/22/19</a> commit patch</p>
<p><a target="_blank" rel="noopener" href="https://www.elecfans.com/d/2184124.html">Milk-V Duo开发板免费体验 GPIO分析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_49457347/article/details/126146947">DesignWare_APB_GPIO模块DUT&amp;Testbench仿真</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42703045/article/details/127778250">RK3399之8250串口驱动</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41696915/article/details/132173191">linux驱动 内核层适配485驱动控制引脚</a></p>
</blockquote>
<p>我现在发现了milkv的gpio型号是dwapb，找到了它对应的驱动手册【<code>DW_apb_gpio_databook</code> 浅看了下，里面至少有介绍寄存器是在干什么】，还有linux【<code>drivers/gpio/gpio-dwapb.c</code>  <code>drivers/gpio/gpio-pl061.c</code>】和rtt【<code>bsp/ft2004/libraries/bsp/ft_gpio/ft_gpio.c</code>】同一型号的驱动代码，我准备对照着这几个参考弄下</p>
<p>然后各个回调的介绍可以看<code>documentation/device/pin/pin.md</code>。</p>
<p>总之，不就是看寄存器都是啥东西，然后对应实现read write嘛！概念上是不难的，好好研究，相信可以！</p>
<p>接下来的思路就是，看下那几个寄存器具体的description，理解下两个参考的代码，就可以慢慢开始写了。测试可能需要再花点心思因为毕竟那个还跑步起来。。。总之方向算是比较明确了（至少比前几天明确）加油捏。</p>
<h3 id="10-15—寄存器了解"><a href="#10-15—寄存器了解" class="headerlink" title="10.15—寄存器了解"></a>10.15—寄存器了解</h3><p>这东西甚至是一个bit一个bit控制的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTA_DR		0x00 <span class="comment">//A 组端口输出寄存器</span></span></span><br><span class="line">写入该寄存器的值独立控制端口A中对应数据位的方向。<span class="number">0</span>是input，<span class="number">1</span>是output</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTA_DDR	0x04 <span class="comment">//A 组端口方向控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTB_DR		0x0c <span class="comment">//B 组端口输出寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTB_DDR	0x10 <span class="comment">//B 组端口方向控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTC_DR		0x18 <span class="comment">//C 组端口输出寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTC_DDR	0x1c <span class="comment">//C 组端口方向控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTD_DR		0x24 <span class="comment">//D 组端口输出寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTD_DDR	0x28 <span class="comment">//D 组端口方向控制寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 这个东西可以用来控制每个bit的开关中断</span><br><span class="line"><span class="number">2.</span> 默认关中断</span><br><span class="line"><span class="number">3.</span> Output时关中断</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTEN		    0x30 <span class="comment">//A 组端口中断使能寄存器</span></span></span><br><span class="line">mask为<span class="number">1</span>表示屏蔽</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTMASK		0x34 <span class="comment">//A 组端口中断屏蔽寄存器</span></span></span><br><span class="line">控制是电平敏感中断还是边缘敏感</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTTYPE_LEVEL	0x38 <span class="comment">//A 组端口中断等级寄存器</span></span></span><br><span class="line">极性</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INT_POLARITY	0x3c <span class="comment">//A 组端口中断极性寄存器</span></span></span><br><span class="line">只读</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTSTATUS		0x40 <span class="comment">//A 组端口中断状态寄存器</span></span></span><br><span class="line">是否需要消抖【是不是很熟悉hhh】</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PORTA_DEBOUNCE	0x48 <span class="comment">//A 组端口防反跳配置寄存器</span></span></span><br><span class="line">清除A/所有中断</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PORTA_EOI		0x4c <span class="comment">//A 组端口中断清除寄存器</span></span></span><br><span class="line"></span><br><span class="line">只读，表示A端口连接的数据信号（也即input信号）</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_EXT_PORTA		0x50 <span class="comment">//A 组端口输入寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_EXT_PORTB		0x54 <span class="comment">//B 组端口输入寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_EXT_PORTC		0x58 <span class="comment">//C 组端口输入寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_EXT_PORTD		0x5c <span class="comment">//D 组端口输入寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DWAPB_DRIVER_NAME	<span class="string">&quot;gpio-dwapb&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DWAPB_MAX_PORTS		4</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 步长。可以看到如它所言，确实GPIO_EXT_PORT每个差4，GPIO_SWPORTA_DR和GPIO_SWPORTA_DDR每个差12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_EXT_PORT_STRIDE	0x04 <span class="comment">/* register stride 32 bits */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORT_DR_STRIDE	0x0c <span class="comment">/* register stride 3*32 bits */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORT_DDR_STRIDE	0x0c <span class="comment">/* register stride 3*32 bits */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_REG_OFFSET_V2	1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTMASK_V2		0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTTYPE_LEVEL_V2	0x34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INT_POLARITY_V2	0x38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTSTATUS_V2	0x3c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PORTA_EOI_V2	0x40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DWAPB_NR_CLOCKS		2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DWAPB_GPIO_BASE     0x03020000</span></span><br></pre></td></tr></table></figure>

<p>难道说，我有一个猜想，就是这个实际表示是说GPIO Port A/C的第16/17、9/10位吗。。。。</p>
<p><img src="/2023/10/27/driver_develop/image-20231027203332238.png" alt="image-20231027203332238"></p>
<p>所以现在很需要这个pin和port的转换。。。</p>
<p>一个是内核传过来的pin是什么数，还有它上面那个是不是端口和位的意思，这两点需要弄清楚</p>
<p>总之先向来是确认下我的想法：那个图的灰色块和引脚号是同一个东西，GPIOA17这样的字符表示GPIO的A端口寄存器的第16个bit。</p>
<p>如果是这样的话，那么思路就很自然了。我们可以通过图中引脚和GPIO这种的分布，从而得知当前是要写入什么端口什么寄存器，这样就能编写代码了。Good。</p>
<h3 id="10-17—整亮led"><a href="#10-17—整亮led" class="headerlink" title="10.17—整亮led"></a>10.17—整亮led</h3><p>也许可以搜一下schematic该怎么看，说不定就能知道哪位是引脚号了。</p>
<p>现在先假设GPIO C 24表示GPIO C端口的第24个bit，也即 (1&lt;&lt;23)吧。所以我们在读取和写入的时候，都是先读出原来的值，然后再把对应位设为1or0。但是为啥qemu是一字节一字节写。。。算了相信自己，总之先试试</p>
<blockquote>
<p>然后就去研究了下linux中的gpio……发现了其内部映射。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~# cat /sys/class/gpio/gpiochip</span><br><span class="line">gpiochip352/  gpiochip384/  gpiochip416/  gpiochip448/  gpiochip480/</span><br></pre></td></tr></table></figure>

<p>384是GPIOD，416是C，448是B，480是A，每个间距32。而LED对应的是GPIO C 24，所以号是416+24 = 440。</p>
<p>416+24 = 440，也就是说，GPIOC24是port C的第24号，也即第25位。</p>
<blockquote>
<p>然后慢慢整理问题……</p>
</blockquote>
<p>整理一下目前的问题。</p>
<p>首先，我是不是想错了？？？</p>
<p>按照刚刚在Linux下看到的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ <span class="built_in">cat</span> /sys/class/gpio/gpiochip</span><br><span class="line">gpiochip352/  gpiochip384/  gpiochip416/  gpiochip448/  gpiochip480/</span><br></pre></td></tr></table></figure>

<p>五个gpio，bank name分别为porte、d、c、b、a。那么问题来了，这个port跟我们在dw_apb手册里看到的gpio的abcd四个port是一个概念吗？？</p>
<p>已知，dwapb gpio有ABCD四个Port，因而有四组寄存器。有一点值得注意，到底是一个字节控制一个设备，还是一个bit？</p>
<p>那么我感觉的是，板上有5个gpio，每个gpio都各自有4个port和4K地址空间，每个port都有这样一堆寄存器：</p>
<p><img src="/2023/10/27/driver_develop/image-20231027203540506.png" alt="image-20231027203540506"></p>
<p>而GPIOC24的意思就是，它是第四个gpio？port夺少？说实话我真的很迷惑。。。</p>
<p>而且我那个写入为什么一点效果没有。。。好痛苦我的天</p>
<p>好，刚刚终于成功把led整亮了。所以是这样的，它那个GPIOABCD并不是一个GPIO的Port ABCD的意思，应该就是纯纯有多个GPIO芯片。然后GPIOC24的意思就是第三块GPIO的A组寄存器第32位，为什么是A不是别的我也不大懂，反正我看了Linux的驱动代码，好像一般也是只用A组端口。</p>
<h3 id="10-18-19—中断"><a href="#10-18-19—中断" class="headerlink" title="10.18/19—中断"></a>10.18/19—中断</h3><p>很好，目前已经基本完成了数据的读写这部分，接下来要做的就是中断了，中断还是先看看数据手册在做。中断的话，决定先研究下wiringX的那个example，然后来看看中断怎么进行有效性验证。</p>
<p>很好，把测试程序搬了过来，还有学习了下qemu的架构也搬过来了，现在剩下的任务就是看寄存器了</p>
<p>目前是这样，<code>dwapb_pin_attach_irq</code>和<code>dwapb_pin_detach_irq</code>负责注册回调函数，<code>dwapb_pin_irq_enable</code>负责开关中断。然后，我们通过<code>rt_hw_interrupt_install(DWAPB_GPIOE_IRQNUM, rt_hw_gpio_isr, &amp;gpio_idx, &quot;gpio&quot;);</code>注册中断函数，这样一来每次DWAPB_GPIOE_IRQNUM中断时就会触发该函数，从而执行<code>rt_hw_gpio_isr</code>中遍历所有hdr并执行一遍的流程了。</p>
<p>整理一下它目前需要有哪些寄存器。首先是<code>rt_hw_gpio_isr</code>，需要有一个pending功能；然后是<code>dwapb_pin_attach_irq</code>，需要能设置是电平/边缘触发以及触发的极性；最后是<code>dwapb_pin_irq_enable</code>，需要有个能开关中断的寄存器。</p>
<p>目前是这样，理论上，我通过rt_pin_irq_enable向INTEN写入数据，这b对应的GPIO引脚就会产生一个中断，然后将中断传递给CPU，CPU通过其中断号从而调用中断处理函数，然后就吊我们在it_install中安装的那个回调。然而不知怎的没调。我觉得原因可能两个，一个寄存器看错了，另一个安装没装好。明天对照Linux源码看下吧。</p>
<p>应该不是，还是得靠外界输入才能触发中断。明天问问老师怎么做。</p>
<p>新进展，发现C9C10互连，然后C10间隔输出就行23333这样就可以触发中断，perfect。</p>
<p>不过我目前的问题似乎是，触发了中断之后，不知道为什么没有进入pending处理，导致中断一直未处理从而寄。</p>
<p>牛逼，成了！！！明天改下码风，多写几个测试，应该就结了。好像目前是both有点问题。明天把这个修下。</p>
<p><img src="/2023/10/27/driver_develop/image-20231027203706048.png" alt="image-20231027203706048"></p>
<p>BOTH_EDGE有点问题，好像那啥玩意没效果，依然保持着上次设置的lowedge。现在去学习下linux的both edge怎么写的。</p>
<p>很好，bug已除。</p>
<h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><p>GPIO实际上就是一个单纯的在板子和外设之间搬运字节的东西，所以本质上只需做好寄存器配置，以及引脚映射即可。接下来将从几个方面拆解我的代码。</p>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>在rtt中，提供了一系列回调函数用于实现gpio：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_pin_ops</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 设置gpio的模式（读/写）</span></span><br><span class="line">    <span class="type">void</span> (*pin_mode)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin, <span class="type">rt_uint8_t</span> mode);</span><br><span class="line">    <span class="comment">// 读写gpio</span></span><br><span class="line">    <span class="type">void</span> (*pin_write)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin, <span class="type">rt_uint8_t</span> value);</span><br><span class="line">    <span class="type">rt_int8_t</span>  (*pin_read)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin);</span><br><span class="line">    <span class="comment">// rtt特有中断回调，mode可以设置为电平/边缘触发，以及触发极性</span></span><br><span class="line">    <span class="type">rt_err_t</span> (*pin_attach_irq)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin,</span><br><span class="line">            <span class="type">rt_uint8_t</span> mode, <span class="type">void</span> (*hdr)(<span class="type">void</span> *args), <span class="type">void</span> *args);</span><br><span class="line">    <span class="type">rt_err_t</span> (*pin_detach_irq)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin);</span><br><span class="line">    <span class="type">rt_err_t</span> (*pin_irq_enable)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin, <span class="type">rt_uint8_t</span> enabled);</span><br><span class="line">    <span class="comment">// 引脚映射</span></span><br><span class="line">    <span class="type">rt_base_t</span> (*pin_get)(<span class="type">const</span> <span class="type">char</span> *name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>milkv上有ABCDE五个gpio组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gpio@<span class="number">03020000</span> &#123;</span><br><span class="line">        bank-name = <span class="string">&quot;porta&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio@<span class="number">03021000</span> &#123;</span><br><span class="line">        bank-name = <span class="string">&quot;portb&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio@<span class="number">03022000</span> &#123;</span><br><span class="line">        bank-name = <span class="string">&quot;portc&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio@<span class="number">03023000</span> &#123;</span><br><span class="line">        bank-name = <span class="string">&quot;portd&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio@<span class="number">05021000</span> &#123;</span><br><span class="line">        bank-name = <span class="string">&quot;porte&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是，在实现中，这五个gpio组件会被注册为同一个设备，而不是像uart那样有多少个就注册多少个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rt_device_pin_register(<span class="string">&quot;gpio&quot;</span>, &amp;_dwapb_ops, RT_NULL);</span><br></pre></td></tr></table></figure>

<h3 id="外界交互"><a href="#外界交互" class="headerlink" title="外界交互"></a>外界交互</h3><p>应用程序会通过引脚名，使用<code>rt_pin_get</code>获取驱动内部自定义的引脚号，然后就可以通过引脚号对其进行模式设置和读写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> DUO_LED = rt_pin_get(<span class="string">&quot;C24&quot;</span>);</span><br><span class="line">rt_pin_mode(DUO_LED, PIN_MODE_OUTPUT);</span><br><span class="line">rt_pin_write(DUO_LED, PIN_LOW);</span><br></pre></td></tr></table></figure>

<h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>这坨宏我是从linux里搬过来的。各个寄存器的含义可以详见data book，在此不多赘述。</p>
<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>在rtt中，外设地址也是统一编址到内存地址空间的。由其它gpio实现可知，当开启<code>RT_USING_LWP</code>（轻量级进程支持）时，外设地址不再是一一映射，需要我们手动在init中调用<code>ioremap</code>进行映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_LWP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_IOREMAP_GPIO_DEVICE(no)     \</span></span><br><span class="line"><span class="meta">    rt_ioremap((void *)(DWAPB_GPIOA_BASE + (no) * DWAPB_GPIO_SIZE), DWAPB_GPIO_SIZE);</span></span><br><span class="line"></span><br><span class="line">    dwapb_gpio_base = (<span class="type">rt_size_t</span>)BSP_IOREMAP_GPIO_DEVICE(<span class="number">0</span>);</span><br><span class="line">    BSP_IOREMAP_GPIO_DEVICE(<span class="number">1</span>);</span><br><span class="line">    BSP_IOREMAP_GPIO_DEVICE(<span class="number">2</span>);</span><br><span class="line">    BSP_IOREMAP_GPIO_DEVICE(<span class="number">3</span>);</span><br><span class="line">    dwapb_gpio_base_e = (<span class="type">rt_size_t</span>)rt_ioremap((<span class="type">void</span> *)DWAPB_GPIOE_BASE, DWAPB_GPIO_SIZE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后，之后就可以在各个方法中借助这两个函数传入寄存器地址直接进行读写了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rt_inline <span class="type">rt_uint32_t</span> <span class="title function_">dwapb_read32</span><span class="params">(<span class="type">rt_ubase_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> HWREG32(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rt_inline <span class="type">void</span> <span class="title function_">dwapb_write32</span><span class="params">(<span class="type">rt_ubase_t</span> addr, <span class="type">rt_uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    HWREG32(addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWREG32(x)          (*((volatile rt_uint32_t *)(x)))</span></span><br></pre></td></tr></table></figure>

<h3 id="引脚映射"><a href="#引脚映射" class="headerlink" title="引脚映射"></a>引脚映射</h3><p>摸索了半天，最终还是猜测这个引脚映射规定应该是自己决定的，于是我就从别的bsp那边把规则搬了过来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// port &amp;&amp; no -&gt; pin</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_NUM(port, no)   (((((port) &amp; 0xFu) &lt;&lt; 8) | ((no) &amp; 0xFFu)))</span></span><br><span class="line"><span class="comment">// pin -&gt; port</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_PORT(pin)       ((uint8_t)(((pin) &gt;&gt; 8) &amp; 0xFu))</span></span><br><span class="line"><span class="comment">// pin -&gt; no</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_NO(pin)         ((uint8_t)((pin) &amp; 0xFFu))</span></span><br></pre></td></tr></table></figure>

<p>例如，“C24”就可转化为<code>(((((&#39;C&#39; - &#39;A&#39;) &amp; 0xFu) &lt;&lt; 8) | ((24) &amp; 0xFFu)))</code>。</p>
<p>根据此规则实现<code>get_pin</code>回调即可。具体板子上哪个引脚是哪个port，详见milkv的schematic book。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h4 id="回调执行"><a href="#回调执行" class="headerlink" title="回调执行"></a>回调执行</h4><p>rtt提供了很好用的中断回调。参考别的bsp以及以前的经验，很容易知道<code>attach_irq</code>和<code>detach_irq</code>就是注册和注销回调函数。那么，回调是什么时候被调用的呢？查阅其他bsp，也可得知它这是采取了一个非常巧妙的委托：在rtt给的<code>rt_hw_interrupt_install(DWAPB_GPIOE_IRQNUM, rt_hw_gpio_isr, RT_NULL, &quot;gpio&quot;);</code>注册的<code>rt_hw_gpio_isr</code>中做即可。这个层层外包的思想让我不禁想起Linux的调度类机制和用户态调度框架的实现原理，实在是牛逼至极。</p>
<p>为了记录所有回调签名，我们需要为每个gpio组件整一个数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dwapb_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*(hdr[DWAPB_GPIO_NR]))(<span class="type">void</span> *args);</span><br><span class="line">    <span class="type">void</span> *args[DWAPB_GPIO_NR];</span><br><span class="line">    <span class="type">rt_uint8_t</span> is_both_edge[DWAPB_GPIO_NR];</span><br><span class="line">&#125; _dwapb_events[DWAPB_GPIO_PORT_NR];</span><br></pre></td></tr></table></figure>

<p>在<code>rt_hw_gpio_isr</code>中：</p>
<ol>
<li>根据硬件寄存器判断是否发生中断</li>
<li>调用相应回调</li>
<li>清除中断位表明完成中断处理</li>
</ol>
<p>即可。</p>
<h4 id="both-edge实现"><a href="#both-edge实现" class="headerlink" title="both-edge实现"></a>both-edge实现</h4><p>这个是抄自linux。本质逻辑就是先设个上升沿触发，然后在<code>rt_hw_gpio_isr</code>执行完回调后再改成反方向也即下降沿触发，以此类推。不得不说确实帅。</p>
<h1 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h1><p>Wait todo…</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/intern/"># intern</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/11/18/compilation_principle/">编译原理</a>
            
            
            <a class="next" rel="next" href="/2023/10/19/open-source-9.19-10.19/">开源的第一个月</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 修年 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>