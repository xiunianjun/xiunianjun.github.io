<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="修年">





<title>Traps and system calls | 修年</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiunian&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiunian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc" style="right: -4em;">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Traps and system calls</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">修年</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">一月 10, 2023&nbsp;&nbsp;20:25:29</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Traps-and-system-calls"><a href="#Traps-and-system-calls" class="headerlink" title="Traps and system calls"></a>Traps and system calls</h1><p>traps=系统调用+异常+中断。本章着重讲traps概述以及traps中的系统调用。</p>
<p>对trap的处理包含四个部分：硬件处理、中断向量、trap handler、对应的处理函数</p>
<h2 id="RISC-V-trap-machinery"><a href="#RISC-V-trap-machinery" class="headerlink" title="RISC-V trap machinery"></a>RISC-V trap machinery</h2><blockquote>
<p><img src="/2023/01/10/xv6/image-20230618162437636.png" alt="image-20230618162437636"></p>
<p><img src="/2023/01/10/xv6/image-20230618162500928-1687077103154-2.png" alt="image-20230618162500928"></p>
<p>在RISC-V中，异常通常是由于程序执行过程中的错误或非预期事件而引起的，包括<strong>故障（faults）、陷阱（traps）和中止（aborts）</strong>。中断（interrupts）则是由外部事件触发的，例如定时器到期、外部设备请求等。中断是异步事件，与当前正在执行的指令无关，因此会在任何时候发生。</p>
<p>xv6是基于RISC-V架构的。因此，发生异常的时候，就会跳转到统一的kernel trap，然后再在里面通过读取scause来进行相应处理。</p>
<p>发生中断的处理方式就和x86差不多了，都是通过中断向量实现的。</p>
</blockquote>
<h3 id="control-register"><a href="#control-register" class="headerlink" title="control register"></a>control register</h3><p>risc-v为trap提供了一组寄存器：</p>
<ol>
<li><p>stvec</p>
<p>trap handler的入口地址</p>
</li>
<li><p>sepc</p>
<p>原程序PC</p>
</li>
<li><p>scause</p>
<p>中断号</p>
</li>
<li><p>sscratch</p>
<p>TRAPFRAME地址</p>
</li>
<li><p>sstatus</p>
<p>是否允许中断，以及中断来自内核态还是用户态</p>
</li>
</ol>
<blockquote>
<p>The above registers relate to traps <strong>handled in supervisor mode</strong>, and they cannot be read or written in user mode. </p>
<p>There is an equivalent set of control registers for traps handled <strong>in machine mode</strong>; xv6 uses them <strong>only</strong> for the special case of <u>timer interrupts</u>.</p>
</blockquote>
<p>每个CPU都有自己的一套这样的控制寄存器。</p>
<h3 id="硬件处理步骤"><a href="#硬件处理步骤" class="headerlink" title="硬件处理步骤"></a>硬件处理步骤</h3><p>时钟中断、device interrupt以及关中断的情况下，不会做以下步骤。</p>
<blockquote>
<p>\1. If the trap is a device interrupt, and the sstatus SIE bit is clear, <strong>don’t</strong> do any of the following.</p>
<p>\2. Disable interrupts by clearing SIE.关中断</p>
<p>\3. Copy the pc to sepc.保存PC</p>
<p>\4. Save the current mode (user or supervisor) in the SPP bit in sstatus.保存mode</p>
<p>\5. Set scause to reflflect the trap’s cause.保存中断号</p>
<p>\6. Set the mode to supervisor.切换到内核态</p>
<p>\7. Copy stvec to the pc.将trap handler写入pc，开始执行trap handler【uservec or kernelvec？】</p>
</blockquote>
<p>切换到内核页表、切换内核栈、保存寄存器现场这些工作交给操作系统完成。</p>
<h2 id="Traps-from-user-space"><a href="#Traps-from-user-space" class="headerlink" title="Traps from user space"></a>Traps from user space</h2><p>从用户态来的trap会经历怎么样的过程？</p>
<p>前面说到，下面需要进行页表的切换，页表的切换必然是接下来要做的指令的某个环节。那么为了让页表切换之后，CPU还知道要从哪里取指执行，<strong>就要让某段物理内存在内核空间和用户空间的虚拟地址一样</strong>。这样，不论页表是用户的还是内核的，都可以通过同样的虚拟地址访问到该段存放指令的物理内存从而继续执行。</p>
<p>这段虚拟地址就是<strong>trampoline</strong>。它在内核页表和用户页表都位于MAXVA的位置。</p>
<blockquote>
<p>我感觉这段大概可以这么理解：</p>
<p>通过查看代码，可知trampoline段实际上存储的是trampoline.S中的数据，也即uservec和userret的汇编代码，也即<strong>执行切换页表我们实际上就是在执行trampoline里的代码</strong>。trampoline的存在，就可以使得每个页表的这部分都是这两个的代码，这样一来切换页表也就不影响指令流的执行。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/p3.png" alt="p3"></p>
<p>stevc存储的正是trampoline段中的uservec。</p>
<h3 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h3><p>sscratch里面存的是trapframe的值。</p>
<p>trapframe存在于用户空间中，并且每个进程的trapframe所处位置固定是在trampoline下方。</p>
<p><img src="/2023/01/10/xv6/image-20230111203357767.png" alt="image-20230111203357767"></p>
<p>首先将寄存器的值都存入trapframe中；然后，再从trapframe中读取内核栈指针、当前CPUid，下一步要跳转的usertrap的地址，以及内核页表。最后，uservec切换到内核页表，并且jmp到usertrap。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#in kernel/trampoline.S</span><br><span class="line">	.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process&#x27;s p-&gt;trapframe is</span><br><span class="line">        # mapped into user space, at TRAPFRAME.</span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">		# swap a0 and sscratch</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        # ...</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">		# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        # 完成了内核栈的切换</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        # 这里完成了页表的切换</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：trampoline和trapframe有一些相通点。</p>
<p>trampoline为了保障某段物理内存的虚拟地址在内核栈和用户栈中不变，做出的努力是，在内核栈和用户栈都分配同一位置的PTE。</p>
<p>trapframe用于保护现场、用户态向内核态传递参数等等，做出的努力是，在用户栈分配同一位置的PTE，在内核态的局部变量中保存了自己的物理地址。</p>
<p>这两个说实话有点容易混起来，因为我想了半天trampoline可不可以用类似trapframe一样的方法，结论是不行。因为你trampoline的作用是维持指令序列依然不变，不会突然没掉；而trapframe段是用来存储数据而非执行的，对其的控制也是需要指令的。如果trampoline使用第二种方法，指令流就会断掉，更别说别的了。</p>
</blockquote>
<h3 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h3><p>作用是得到trap发生的原因，并且执行对应的处理程序，然后返回结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  <span class="comment">//首先把trap handler切换到kernel的，这样一来如果在kernel中发生trap就会由kernel的handler处理</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在当前进程中再次保存用户程序的原PC，防止之后sepc被覆盖</span></span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//根据cause号不同处理</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="comment">//注意，在此处开启了中断</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用syscall处理</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行对应的处理函数"><a href="#执行对应的处理函数" class="headerlink" title="执行对应的处理函数"></a>执行对应的处理函数</h3><p>比如说system call会修改trapframe中的a0为返回的结果，会获取trapframe中的各个参数。这个“保护现场“感觉是非常微妙的，它兼顾了保护现场和传递参数两个作用</p>
<h3 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h3><p>回到用户态。之前陷入内核态对stvec、satp、sp、hartid、trap handler都做了适应内核态的改变，因而这里就需要改回原来适应用户态的样子，然后返回用户态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关中断</span></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置trapframe</span></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">		# 切换为用户页表</span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        # ...</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h2 id="Code-calling-system-calls"><a href="#Code-calling-system-calls" class="headerlink" title="Code: calling system calls"></a>Code: calling system calls</h2><blockquote>
<p>Chapter 2 ended with initcode.S invoking the exec system call (user/initcode.S:11). Let’s look at how the user call makes its way to the exec system call’s implementation in the kernel.要讲如何从用户态找到exec的代码了。</p>
</blockquote>
<h2 id="Code-system-call-arguments"><a href="#Code-system-call-arguments" class="headerlink" title="Code: system call arguments"></a>Code: system call arguments</h2><p>讲的是系统调用时，是如何把用户态传递的地址转化为内核态地址的。</p>
<p>这个部分可以看看hit实验的实验3 6.7，讲得很详细，而且流程是差不多的。linux0.11的<code>get_fs_byte()</code>就相当于xv6的<code>copyinstr</code>。</p>
<h2 id="Traps-from-kernel-space"><a href="#Traps-from-kernel-space" class="headerlink" title="Traps from kernel space"></a>Traps from kernel space</h2><h3 id="kernelvec"><a href="#kernelvec" class="headerlink" title="kernelvec"></a>kernelvec</h3><p>不同于用户态还得先潜入内核再潜出内核，内核的trap可简单多了，省去了切来切去各种东西的步骤，只需当做一个普通的函数调用就行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># in kernel/kernelvec.S</span><br><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        // make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        // save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)</span><br><span class="line">		# ...</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">	// call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        // restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        # ...</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        // return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h3 id="kerneltrap"><a href="#kerneltrap" class="headerlink" title="kerneltrap"></a>kerneltrap</h3><blockquote>
<p>kerneltrap is prepared for two types of traps: device interrrupts and exceptions. </p>
<p>It calls devintr (kernel/trap.c:177) to check for and handle the <strong>former</strong>. If the trap isn’t a device interrupt, it must be an exception, and that is always a fatal error if it occurs in the xv6 kernel; the kernel calls panic and stops executing.</p>
<p>If kerneltrap was called due to a timer interrupt, and a process’s kernel thread is running (rather than a scheduler thread), kerneltrap calls yield to give other threads a chance to run.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c</span></span><br><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在此处的devintr对不同的设备进行不同的处理方式</span></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Page-fault-exceptions"><a href="#Page-fault-exceptions" class="headerlink" title="Page-fault exceptions"></a>Page-fault exceptions</h2><p>似乎xv6是没有这个缺页exception的。这里主要讲解了三个可以利用缺页中断实现的优化：COW fork、lazy allocation、paging from disk。还提及了automatically extending stacks 以及memory-mapped fifiles。</p>
<h2 id="Lab：Trap"><a href="#Lab：Trap" class="headerlink" title="Lab：Trap"></a>Lab：Trap</h2><blockquote>
<p>This lab explores how system calls are implemented using traps. You will first do a warm-up exercises with stacks and then you will implement an example of user-level trap handling.</p>
</blockquote>
<h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><h4 id="题目和答案"><a href="#题目和答案" class="headerlink" title="题目和答案"></a>题目和答案</h4><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53111905/article/details/120996446">Lab4: traps</a></p>
<p>There is a file <code>user/call.c</code> in your xv6 repo. make fs.img compiles it and also produces a readable assembly version of the program in <code>user/call.asm</code>.</p>
<p>Read the code in call.asm for the functions <code>g</code>, <code>f</code>, and <code>main</code>. Here are some questions that you should answer:</p>
</blockquote>
<ol>
<li><p>a2</p>
</li>
<li><p>被inline掉了</p>
</li>
<li><p>0x64A</p>
<p><img src="/2023/01/10/xv6/image-20230111224927837.png" alt="image-20230111224927837"></p>
<p>auipc的作用是把立即数左移12位，低12位补0，和pc相加赋给指定寄存器。这里立即数是0，指定寄存器是ra，即ra=pc=0x30=48。jalr作用是跳转到立即数+指定寄存器处并且把ra的值置为下一条指令。因此jalr会跳转1562+48=1594=0x64A处，观察汇编代码可知确实在000000000000064a处。</p>
</li>
<li><p>0x38</p>
</li>
<li><blockquote>
<p>Run the following code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>What is the output? <a target="_blank" rel="noopener" href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the RISC-V is <strong>little-endian</strong>. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<p><img src="/2023/01/10/xv6/format,png.png" alt="format,png"></p>
</blockquote>
</li>
<li><p>取决于寄存器a2（第3个参数）的值。</p>
</li>
</ol>
<h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><blockquote>
<p>For debugging it is often useful to have a backtrace: a list of the function calls on the stack above the point at which the error occurred.</p>
<p><img src="/2023/01/10/xv6/image-20230111232323444.png" alt="image-20230111232323444"></p>
<p>The compiler puts in each stack frame a frame pointer that holds the address of the caller’s frame pointer. Your <code>backtrace</code> should use these frame pointers to walk up the stack and print the saved return address in each stack frame.</p>
</blockquote>
<blockquote>
<p>Some hints:</p>
<ul>
<li><p>Add the prototype for backtrace to <code>kernel/defs.h</code> so that you can invoke <code>backtrace</code> in <code>sys_sleep</code>.</p>
</li>
<li><p>The GCC compiler stores the frame pointer of the currently executing function in the register s0. Add the following function to kernel/riscv.h:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and call this function in backtrace to read the current frame pointer. This function uses in-line assembly to read s0.</p>
</li>
<li><p>These <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">lecture notes</a> have a picture of the layout of stack frames. Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.</p>
</li>
<li><p>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. You can compute the top and bottom address of the stack page by using <code>PGROUNDDOWN(fp)</code> and <code>PGROUNDUP(fp)</code> (see <code>kernel/riscv.h</code>. These number are helpful for <code>backtrace</code> to terminate its loop.</p>
</li>
</ul>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>我超，这题真的是那怎能只叫一个拷打……</p>
<h5 id="存储在s0中的栈帧指针"><a href="#存储在s0中的栈帧指针" class="headerlink" title="存储在s0中的栈帧指针"></a>存储在s0中的栈帧指针</h5><p>这个应该是risc-v的约定成俗的特性。我搜了一下risc-v的栈帧指针保存在哪个寄存器，看到了这样一篇文章：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dai_xiangjun/article/details/126541174">risc-v 栈分析</a></p>
<p><img src="/2023/01/10/xv6/image-20230112012358601.png" alt="image-20230112012358601"></p>
</blockquote>
<p>这个信息没有放在题干提示，是在考察信息检索能力吗（</p>
<h5 id="栈的结构与栈帧的理解"><a href="#栈的结构与栈帧的理解" class="headerlink" title="栈的结构与栈帧的理解"></a>栈的结构与栈帧的理解</h5><p><img src="/2023/01/10/xv6/image-20230112010749756.png" alt="image-20230112010749756"></p>
<p>这是来自hint的栈结构。整个栈存储在一页中，由高地址向低地址增长。栈帧代表了一次函数调用，其中会存储如函数名、函数参数、局部变量等等信息。有几次函数调用就有几个栈帧，栈由栈帧组成。</p>
<p>s0中存储的栈帧指针fp指向的是栈帧的最高地址，如图fp所示。</p>
<blockquote>
<p>我理解错了栈帧的定义，都怪我基础不大牢固也不认真思考【悲】我一开始以为stack frame指的是一个栈，也即一页空间【我知道栈帧这个中文名词，但遇到英语就短路了】。老师画的这个图也被我理解为多个栈，也即多页拼在一起，要打印的Return Address处于页的最顶部。我就在这个思路上一去不复返了，压根没有意识到一个进程只有一个栈【大悲】然后顺带脑补把r_fp()也曲解了，以为它的意思是读取当前栈【非常自然地认为有很多个栈←】的下一个栈的最低地址【因为栈换掉了，所以s0也会变成父亲的栈的地址】。于是就写出了这样的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">   uint64 kstack = PGROUNDUP((uint64)(myproc()-&gt;kstack)+<span class="number">1</span>);</span><br><span class="line">   uint64 nstack = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>((nstack=(uint64)r_fp())!=<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*((uint64*)(kstack<span class="number">-8</span>)));</span><br><span class="line">         kstack = nstack;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果最后死循环了。去看了别人的代码发现他们写的结构就跟我完全不一样。琢磨着画着图，最后找了stack frame的定义，才恍然大悟（</p>
</blockquote>
<h5 id="思路形成"><a href="#思路形成" class="headerlink" title="思路形成"></a>思路形成</h5><p>我们只需遍历栈中所有栈帧，打印每个栈帧的Return Address部分就行。通过r_fp()获取第一个栈帧的位置，其他栈帧的位置由Prev.Frame获取。循环的界限是PGROUNDUP(r_fp())，因为栈只有一页的空间。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  uint64 <span class="built_in">stack</span> = r_fp();</span><br><span class="line">  uint64 nstack = <span class="number">0</span>;</span><br><span class="line">  uint64 top = PGROUNDUP(<span class="built_in">stack</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">stack</span>!=top)&#123;</span><br><span class="line">    nstack=*((uint64*)(<span class="built_in">stack</span><span class="number">-16</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*((uint64*)(<span class="built_in">stack</span><span class="number">-8</span>)));</span><br><span class="line">    <span class="built_in">stack</span> = nstack;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><blockquote>
<p>In this exercise you’ll add a feature to xv6 that <u>periodically alerts a process as it uses CPU time</u>. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. </p>
<p>More generally, you’ll be implementing a primitive form of user-level interrupt/fault handlers; you could use something similar to handle page faults in the application, for example. </p>
<p>You should add a new <code>sigalarm(interval, handler)</code> system call. If an application calls <code>sigalarm(n, fn)</code>, then after every <code>n</code> “ticks” of CPU time that the program consumes, the kernel should cause application function <code>fn</code> to be called. When <code>fn</code> returns, the application should resume where it left off.</p>
</blockquote>
<p>感觉从alarm中可以窥见信号的实现思路：</p>
<p><img src="/2023/01/10/xv6/image-20231218164244526.png" alt="image-20231218164244526"></p>
<p>而alarm的机理感觉也有点类似。用户先通过sigalarm注册定时函数，内核在时钟中断的时候对该标记位进行检查，然后去do_signal回到用户态执行用户的signal handler，再通过sigreturn回到用户模式。sigalarm相当于一个信号注册函数，sigreturn也就是上图的sigreturn。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h5><p>思路：sigalarm需要在用户程序在用户态运行的情况下，监测到用户程序已经运行了n个时间片，然后发出中断请求。我们会新设置一个中断类型alarm。kerneltrap接收到sigalarm的中断请求，检测到中断类型为alarm，就会在处理的时候调用fn。fn调用完就自然而然利用中断恢复到原来的现场了。所以要做的可以分为两部分。但问题是，如何让sigalarm在用户程序运行的同时监测n个时间片呢？难道得fork一个新的进程吗？然后父进程返回，子进程执行类似sleep里面那样的监测，直到时间片到了，就发送一个中断请求，让父进程停止，执行完fn回来之后就exit。</p>
<h5 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h5><p>可以看到，初见思路很多地方跟最后是不一样的。其中错得最离谱的，也是比较隐坑很容易因为想不明白就寄了的，是handler是个用户态的函数（。你不可能在内核态中调用fn，然后fn执行完后再自然而然地通过中断机制返回，因为你想要执行fn就必须进入用户态。这一点是需要一开始明确的。</p>
<p>明确了这一点后，让人更加不知道该怎么办了。那就一步步跟着指导书的脚步来思考吧。</p>
<h6 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h6><p>首先，明确你需要实现什么。你需要实现两个系统调用，一个是sigalarm，一个是sigreturn。结合提示，可知实验设计者给我们的思路是，通过sigalarm设置定时函数，通过sigalarm(0,0)取消定时函数。每次时钟中断检测当前定时时间是否达到，若已达到，则跳到定时函数执行。定时函数执行完后，需要借助sigreturn，才能正确返回时钟中断前的程序点。</p>
<h6 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h6><p>这又可拆解为几个要点：</p>
<ol>
<li>如何实现“定时”？</li>
<li>时钟中断在内核态的usertrap被检测。怎么从usertrap出来跳到定时函数而非原程序执行点？</li>
<li>执行完定时函数后，怎么样才能回到原程序执行点？</li>
</ol>
<h6 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a>part 3</h6><p>一个个来说，首先是如何实现定时。这个很简单。参照sys_sleep的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  backtrace();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，我们可以用ticks表示当前系统滴答数。这样，我们就可以在proc域里维护一个变量lasttick，记录上一次执行handler时的滴答数。每次在时钟中断时检测，所以需要写在<code>kernel/trap.c</code>中的<code>usertrap</code>中。</p>
<h6 id="part-4"><a href="#part-4" class="headerlink" title="part 4"></a>part 4</h6><p>然后，是怎么从usertrap出来跳到指定程序结束点。在书中，我们知道，sepc寄存器保存了中断前原程序的下一个执行点，sepc的备份存储在了proc域中的栈帧中。当中断返回时（在usertrapret中），会从栈帧中的epc字段读取sepc的备份赋值给sepc，再由sret帮助我们跳转到原程序点。因而，如果想要改变跳转点，我们只需要修改<code>p-&gt;trapframe-&gt;epc</code>就行。</p>
<h6 id="part-5"><a href="#part-5" class="headerlink" title="part 5"></a>part 5</h6><p>最后，是如何从periodic回到原程序执行点。</p>
<p><img src="/2023/01/10/xv6/image-20230113002057893.png" alt="image-20230113002057893"></p>
<p>这是每次进行时钟中断时的栈情况和执行代码链：t1-&gt;trampoline-&gt;usertrap-&gt;handler。</p>
<p>再然后，handler调用了sigreturn，用户栈中就会产生sigreturn的栈帧：</p>
<p><img src="/2023/01/10/xv6/image-20230113002434093.png" alt="image-20230113002434093"></p>
<p>此时，如果sigreturn执行完，就会在这样的情况下执行handler的ret指令：</p>
<p><img src="/2023/01/10/xv6/image-20230113002542335.png" alt="image-20230113002542335"></p>
<p>ret指令会把栈帧弄走，也就是说会直接回到某个错误的地方去。这显然不大合适。所以，我们要做的，就是在sigreturn之后，<u>不执行handler的ret指令，也不执行sigreturn的ret指令，而是直接恢复到时钟中断前的上下文</u>。时钟中断前的上下文，会因在handler中调用sigreturn系统调用，而被<strong>覆盖</strong>，因而，我们就需要记录时钟中断前的上下文，也即在proc域中保存trapframe的一份拷贝savedtrap，每次时钟中断都更新一次savedtrap，然后在sigreturn调用的时候将proc原本的trapframe替换为savedtrap即可。这样一来，就完成了这道题。</p>
<h5 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h5><p>这题目确实最终代码看起来完全不难，但是非常地拷打。。。。我前前后后修修补补差不多一共花了五个小时之久。</p>
<p>计时怎么计，以及使用trapframe-&gt;epc来跳转这两点还是很容易想到的【话虽如此，其实也很曲折】。主要难点还是在怎么恢复现场。怎么说呢，我花了这么久做实验，但是实际笔记却写不出个鬼来，足以看出其复杂程度。</p>
<p>我主要还是思维固化了点，一直在想，怎么确保它正确返回现场。我一开始以为proc域保存一个寄存器状态，且只用在一开始设置定时函数也即sigalarm的时候保存一次就行了，并且认为其是epc。然而实际操作后发现usertrap崩了，并且epc中存储的并不是程序被时钟中断的地方，而是各种神奇的地方，具体我也忘了，反正不能行。我印象最深刻的是有一次停在了usys.S中的sigreturn的最后一个ret处。我就在想，也许是栈出了问题。于是我就想着直接在sigreturn的时候把epc指向栈帧中的return address，直接回到原执行段。我百度了一下，确实有这么个寄存器ra，存储着return address。于是我就把proc域的状态换成了ra，依然仅保存一次，最后发现还是不行，程序在test0之后就异常终止了，main也回不去，十分古怪，十分匪夷所思。我实在没忍住，百度了一下大家怎么做的，发现大家压根没有我这样的二选一的烦恼，是直接保存整个栈帧。而且也不是仅保存一次，而是每次时钟中断触发都保存一次。我觉得十分奇怪震惊，但此时已是差不多晚饭时间，我就先去吃了个饭（）</p>
<p>回来之后，我细细画了图【向正确思路part5中的那样】，发现我原来那个只保存两者之一，且都只保存一次的方式，确实完全不能行。但是，我发现两个一起保存，并且每次时钟中断保存的方法，似乎能行，而且，比保存一整个栈帧要聪明得多。于是我就去试了，发现还是不行。我再细想了一遍，发现，如果想回去原程序的现场，除了ra和epc，还有一个很重要的东西需要保存，那就是——用户栈指针sp！</p>
<p>也就是说，<strong>只需保存ra、epc、sp，就可以保证回到正确的时钟中断前的位置</strong>：</p>
<p><img src="/2023/01/10/xv6/image-20230113005100895.png" alt="image-20230113005100895"></p>
<p>此为handler中sigreturn执行完要返回时的状态。</p>
<p>当处在handler中时，sp的值为sigreturn处的栈帧。执行系统调用时，proc域中的上下文被覆盖，也即时钟中断前的上下文被覆盖。如果此时不对栈帧中的sp进行恢复，仅恢复ra和epc，在从sigreturn返回到epc对应处也即t1，t1执行ret想回到main的时候，就会回不去，而是回到了sigreturn要回的位置，也即handler的位置，然后不知不觉就寄了。所以，就需要防止sp被覆盖。因而，再保存一个状态sp，就可以保障回到正确的地方了。测试出来，kernel确实不再会panic了。</p>
<p>但是由于运行时很多除这三个以外的寄存器都被改过了，回是回得去，接下来干的活就不一定对了。因此为了保险以及通用性以及便利性来看，还是像别人那样直接保存栈帧比较ok。</p>
<p>还有一件事，就是上述错误中经常会出现的一个输出结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usertrap:unexpected cause scause = <span class="number">0x0c</span></span><br></pre></td></tr></table></figure>

<p>我留意了一下是什么意思。网上搜索得，scause=12，说明这是一个instruction page fault，而这个缺页错误说明了什么？：</p>
<p><img src="/2023/01/10/xv6/image-20230113012355740.png" alt="image-20230113012355740"></p>
<p>这样，一切都明朗了。出现了scause=0x0c的意思就是说pc里的值不恰当，也就是说上面错误的方法都会跳转到错误的地方去。</p>
<h2 id="Lab：xv6-lazy-page-allocation"><a href="#Lab：xv6-lazy-page-allocation" class="headerlink" title="Lab：xv6 lazy page allocation"></a>Lab：xv6 lazy page allocation</h2><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_53157173/article/details/131349366">https://blog.csdn.net/m0_53157173/article/details/131349366</a></p>
</blockquote>
<blockquote>
<p>来自书本：</p>
<p>Another widely-used feature is called <em>lazy allocation</em>, which has two parts:</p>
<ol>
<li>First, when an application calls sbrk, the kernel grows the address space, but marks the new addresses as not valid in the page table. </li>
<li>Second, on a page fault on one of those new addresses, the kernel allocates physical memory and maps it into the page table. </li>
</ol>
<p>The kernel allocates memory only when the application actually uses it. </p>
</blockquote>
<h3 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk()"></a>Eliminate allocation from sbrk()</h3><blockquote>
<p>Your first task is to delete page allocation from the sbrk(n).</p>
<p>The sbrk(n) system call grows the process’s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process’s size (myproc()-&gt;sz) by n and return the old size. It should not allocate memory – so you should delete the call to growproc() (but you still need to increase the process’s size!).</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> sz = myproc()-&gt;sz;</span><br><span class="line">  addr = sz;</span><br><span class="line">  myproc()-&gt;sz = sz + n;</span><br><span class="line">  <span class="comment">//if(growproc(n) &lt; 0)</span></span><br><span class="line">  <span class="comment">//  return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h3><blockquote>
<p>Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. </p>
<p>You should add your code just before the <code>printf</code> call that produced the “usertrap(): …” message. Modify <strong>whatever</strong> other xv6 kernel code you need to in order to get <code>echo hi</code> to work.</p>
</blockquote>
<h4 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>首先，要知道缺页中断的scause为13或15.【论我怎么知道的：被以前的实验逼出来的hhh】然后，要写在if条件的第二个分支。在该分支内，我们需要先获取出问题的地方的虚拟地址的值，然后申请新的一页，再map到当前页表中。</p>
<h5 id="一个难以察觉的错误"><a href="#一个难以察觉的错误" class="headerlink" title="一个难以察觉的错误"></a>一个难以察觉的错误</h5><h6 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h6><p>思路是很简单的，就是有小细节需要格外注意。</p>
<p>trap.c在<code>mappages</code>时，一定不能直接传入va，必须传入<code>PGROUNDDOWN(va)</code>。如果直接传入va，会爆出如下错误：</p>
<p><img src="/2023/01/10/xv6/image-20230116154004538.png" alt="image-20230116154004538"></p>
<p>但是，查看<code>mappages</code>的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，它在里面已经对va进行了处理了，使它变成了page-align的a变量。那么为什么，我们还要在外面再对va处理一次呢？</p>
<p>其实问题不是出在<code>mappages</code>中的a变量上，而是出现在<code>mappages</code>中的last变量上。比如，令va=PGSIZE+200，则a=PGSIZE，last=2*PGSIZE。这样一来，在下面的循环中，除了添加了刚刚申请的那页的映射以外，我们还多添加了新的一页，其物理地址为mem+PGSIZE。</p>
<p>这十分地危险！假设你要申请的va为proc-&gt;size的最后一页，那么，经过本次缺页中断之后，你事实上申请了两页，两页的地址分别为va和va+PGSIZE。而va+PGSIZE大于proc-&gt;size。也就是说，地址溢出了！</p>
<p>这会导致<strong>页表释放</strong>的时候出问题。以下是页表释放的路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">    uvmunmap(pagetable, <span class="number">0</span>, PGROUNDUP(sz)/PGSIZE, <span class="number">1</span>);</span><br><span class="line">  freewalk(pagetable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap walk: %p\n&quot;</span>,a);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap: %p\n&quot;</span>,a);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap OK: %p\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freewalk要求在uvmunmap中已经释放完所有的叶子结点。而由于uvmunmap中释放结点的va是从0递增到proc-&gt;size的，也因而，前面的那个大于proc-&gt;size的那页虽然还在页表中存在，但是不会被uvmunmap释放！这也就导致，接下来调用freewalk的时候，会发现该页的叶子结点仍然存在，从而导致<code>freewalk: leaf</code>。</p>
<p>可以结合uvmunmap和trap.c中的调试语句看下图的过程，可以看到非常清晰明了，0x14000这一页并没有在uvmunmap中释放！</p>
<p>trap.c中的调试语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap: %p,+PGSIZE = %p\n&quot;</span>,PGROUNDDOWN(va),PGROUNDDOWN(va)+PGSIZE);</span><br><span class="line">   <span class="keyword">if</span>(mappages(p-&gt;pagetable,va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">     kfree(mem);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>图：</p>
<p><img src="/2023/01/10/xv6/image-20230116165910356.png" alt="image-20230116165910356"></p>
<h6 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h6><p>看到<code>freewalk: leaf</code>这一错误，很容易联想到跟页表的释放有关。并且加上PGGROUNDDOWN就没问题，不加上才有问题，也很容易联想到跟mappages中多申请的那一页有关。但是具体是什么关系，这一点想要想到对我来说还是非常曲折的。</p>
<p>我一开始，以为是因为多申请的那一页（下面简称为B页好了）很有可能是其他进程在使用的，然后其他进程在echo进程释放页表前释放了页表，从而导致B页已经free了，这样一来<code>uvmunmap</code>说不定就能监测到对应物理页已经free，然后爆出panic。我一开始认为<code>uvmunmap</code>的这句话是用来监测物理页是否free的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">   <span class="comment">//panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>然后顺理成章地，这边条件==0成立，然后continue，然后直到freewalk才发现该pte未释放。</p>
<p>但是，我仔细过脑子想了想，发现，就算物理页已经free了，但是，*pte依然存在，PTE_V也依然为1，这个条件是不成立的。也就是说，B页不会continue，而是会继续下面的正常释放的流程。也就是说，B页是可以正常释放的，我们的“B页已经free导致uvmunmap释放失败”的推论是错误的。</p>
<p>但究竟是为什么呢？肯定跟B页有关系，但是又不是这种关系，这让我十分地苦恼且烦躁，于是我就去打了会儿游戏。边玩的时候突然注意到一件非常可疑的事情。</p>
<p><img src="/2023/01/10/xv6/image-20230116154004538.png" alt="image-20230116154004538"></p>
<p>这是发生错误时退出的截图。有一个点引起了我的注意，就是echo hi并没有打印hi在console上。也就是说，这个panic是在echo执行前产生的！那么这个执行前是在哪呢？答案就是在exec中！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in exec.c</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  <span class="comment">// 这里！！！！！</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure>

<p>可以看到，这里调用了<code>proc_freetable</code>，从而跟freewalk有了联系。</p>
<p>但是，如果我们还坚持是因为B页错的，就需要找到一个可能会产生B页的地方，也就是验证shell准备执行echo命令，fork出一个子进程之后，又在exec free页表前，已经调用过sbrk函数，并且已经触发过缺页中断。这个验证其实很简单，只需要找sbrk在哪被调用过，哪边使用过heap内存【也即哪边涉及了指针赋值】就行了。</p>
<p>通过全局搜索，可知sbrk在<code>user/umalloc.c</code>下的<code>malloc()</code>被使用过，而在<code>user/sh.c</code>中，fork子进程之后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">  runcmd(parsecmd(buf));</span><br></pre></td></tr></table></figure>

<p>这其中的<code>parsecmd()</code>中malloc被使用过，并且发生了指针赋值！！也就是说，“是因为B页错的”这个结论是对的。</p>
<p>虽然这一段debug没有改变我们要证明“是B页在释放内存中出错的”的这个目的，但是确实带给了我很多这种执行时申请内存的知识，并且也让我突然想起了可以用printf debug。于是，我就去做了上面那个在trap.c中和uvmunmap中printf的调试语句，最终成功发现了结论。</p>
<p>实在是太艰苦了（）这告诉我们以后千万千万要注意，是否需要用到PGGROUNDDOWN。</p>
<h5 id="一个漏掉未考虑的细节"><a href="#一个漏掉未考虑的细节" class="headerlink" title="一个漏掉未考虑的细节"></a>一个漏掉未考虑的细节</h5><p>摘自<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_53157173/article/details/131349366">https://blog.csdn.net/m0_53157173/article/details/131349366</a></p>
<p><img src="/2023/01/10/xv6/image-20231209011856305.png" alt="image-20231209011856305"></p>
<p><img src="/2023/01/10/xv6/image-20231209011932500.png" alt="image-20231209011932500"></p>
<p>不过我以前好像是有考虑到这个的，但是我是这么做的：</p>
<p><img src="/2023/01/10/xv6/image-20231209015238219.png" alt="image-20231209015238219"></p>
<p>也就是相当于把它在addr parse的那段代码移进了walkaddr中。但是这样是不行的，查找可知argaddr的应用范围可比walkaddr广得多……</p>
<p>而为什么我下面的COW也是修改了walkaddr，而非修改argaddr，就可以达到同样的效果呢？这是因为cow只需对在内核中写用户页这种情况进行特殊处理，而这只有一个情况，也即只在copyout中发生。因而，我们只需修改walkaddr，就可以完全防范该情况了。</p>
<h3 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h3><blockquote>
<p>We’ve supplied you with <code>lazytests</code>, an xv6 user program that tests some specific situations that may stress your lazy memory allocator. Modify your kernel code so that all of both <code>lazytests</code> and <code>usertests</code> pass.</p>
</blockquote>
<h4 id="感想-3"><a href="#感想-3" class="headerlink" title="感想"></a>感想</h4><h5 id="一个绷不住的错误"><a href="#一个绷不住的错误" class="headerlink" title="一个绷不住的错误"></a>一个绷不住的错误</h5><p>其实很简单，按照提示一步步做就行了。为什么我做得那么久那么崩溃呢？知道原因后我都笑嘻了。</p>
<p>在第一步修改<code>sys_sbrk()</code>的时候，我一下子没多想，使用了一句<code>int sz = myproc()-&gt;sz</code>，其实本来应该使用uint64的，使用int会溢出。这个伏笔就一直隐含到这里，然后大坑了我一笔。</p>
<p>一开始是发现<code>lazytests</code>的第二个，也就是oom过不去。我想了很久，也去网上找了别人的代码一步步对比下来看了，没有发现特别大的问题。于是我就在walk和sys_sbrk分别留下了调试信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in walk()</span></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;walk:va=%p,p-&gt;sz=%p,MAXVA=%p,pgva=%p\n&quot;</span>,va,myproc()-&gt;sz,MAXVA,PGROUNDDOWN(va));</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in sys_sbrk()</span></span><br><span class="line">  <span class="keyword">if</span>(n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    uint64 tmp = n + sz;</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; MAXVA || n + sz &lt; n)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    myproc()-&gt;sz = tmp;</span><br><span class="line">    <span class="comment">//printf(&quot;haha sb!sz=%p,n=%p\n&quot;,myproc()-&gt;sz,n);</span></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>然后发现了这样的输出：</p>
<p><img src="/2023/01/10/xv6/image-20230116225124363.png" alt="image-20230116225124363"></p>
<p>可以看到，最后一次sz发生了数值溢出。</p>
<p>但是，此时我并没有悔改。我反而认为，“原本代码就是这么写的”。也就是说，我认为<code>int sz</code>是它原本内核代码给的。。。。。。在这样的情况下，我选择加上这样的条件判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tmp &gt; MAXVA || ((tmp &gt;&gt; <span class="number">31</span>)&amp; <span class="number">1</span>) == <span class="number">1</span>)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>之后确实没有溢出了，但是test fail了。此时我想，为什么非要用int而不用uint64呢？一阵令人不寒而栗的预感袭来，我连忙去看了<code>proc.h</code>里的sz的定义，发现，sz原本就应该是uint64类型的，是我错辣【悲】</p>
<p>只能说起到一种很好的教训。主要是这种问题实在没有想过自己会犯</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><blockquote>
<ul>
<li>Handle the parent-to-child memory copy in fork() correctly.</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in vm.c uvmcopy()</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Handle negative sbrk() arguments.</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  uint64 sz = myproc()-&gt;sz;</span><br><span class="line">  addr = sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    uint64 tmp = n + sz;</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; MAXVA || n + sz &lt; n)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    myproc()-&gt;sz = tmp;</span><br><span class="line">    <span class="comment">//printf(&quot;haha sb!sz=%p,n=%p\n&quot;,myproc()-&gt;sz,n);</span></span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n + sz &gt; <span class="number">0</span>)</span><br><span class="line">      myproc()-&gt;sz = uvmdealloc(myproc()-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//if(growproc(n) &lt; 0)</span></span><br><span class="line">  <span class="comment">//  return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</p>
</li>
<li><p>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</p>
</li>
<li><p>Handle faults on the invalid page below the user stack.</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">13</span> || scause == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= p-&gt;sz ||  va &lt; PGROUNDUP(p-&gt;trapframe-&gt;sp) ||PGROUNDDOWN(va) &gt;= MAXVA)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;va=%p stack=%p\n&quot;,va,PGROUNDUP(r_sp()));</span></span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">char</span>* mem = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(mem != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">//printf(&quot;trap: %d %p\n&quot;,p-&gt;pid,PGROUNDDOWN(va));</span></span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">          kfree(mem);</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li>
</ul>
<p>我认为这里要是引起一个缺页中断可能会更酷，可能可以像lazytests里面这么做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *i, *prev_end, *new_end;</span><br><span class="line"></span><br><span class="line">prev_end = sbrk(REGION_SZ);</span><br><span class="line">new_end = prev_end + REGION_SZ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里触发了多次缺页中断</span></span><br><span class="line"><span class="keyword">for</span> (i = prev_end + PGSIZE; i &lt; new_end; i += PGSIZE * PGSIZE)</span><br><span class="line">  *(<span class="type">char</span> **)i = i;</span><br></pre></td></tr></table></figure>

<p>之后有机会再试试233</p>
<p>【试了一下，发现是可以的。在COW fork的  <code>感想—一些错误和思考—在内核态中引发并处理缺页中断</code>  这部分内容中详细说明了具体要怎么做。】</p>
</blockquote>
<h2 id="Lab-Copy-on-Write-Fork-for-xv6"><a href="#Lab-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab: Copy-on-Write Fork for xv6"></a>Lab: Copy-on-Write Fork for xv6</h2><blockquote>
<p>Parent and child can safely share phyical memory using copy-on-write fork, driven by page faults. </p>
<p>RISC-V has <u>three different kinds of page fault</u>: <strong>load</strong> page faults (when a load instruction cannot translate its virtual address), <strong>store</strong> page faults (when a store instruction cannot translate its virtual address), and <strong>instruction</strong> page faults (when the address for an instruction doesn’t translate). </p>
<p>The <strong>basic plan</strong> in COW fork is for the parent and child to initially share all physical pages, but to map them <strong>read-only</strong>. Thus, when the child or parent executes a store instruction, the RISC-V CPU raises a page-fault exception. In response to this exception, the kernel makes a copy of the page that contains the faulted address. It maps one copy read/write in the child’s address space and the other copy read/write in the parent’s address space. After updating the page tables, the kernel resumes the faulting process at the instruction that caused the fault.</p>
<p>PS【这个很重要】: COW fork() makes freeing of the physical pages that implement user memory a little trickier. A given physical page may be referred to by multiple processes’ page tables, and should be freed only when the last reference disappears.</p>
</blockquote>
<h3 id="感想-4"><a href="#感想-4" class="headerlink" title="感想"></a>感想</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>思路还是很直观的。</p>
<p>我们只需要在fork的时候，标记父子进程的所有PTE都为read-only，然后之后就会遇到不同scause的缺页中断，针对特定的scause，新建物理页面，拷贝物理页面，然后重新设置映射即可。而对于其提出的需要标记某页是否能够释放，则需要统计每页的ref数，当ref==1的时候才可以释放。</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><h5 id="总分析"><a href="#总分析" class="headerlink" title="总分析"></a>总分析</h5><p>其实可以把任务简单拆分为三部分。第一部分是实现基本的cow fork的逻辑，第二部分是引用计数释放内存，第三部分是解决copyin/copyout时在内核态发生的缺页中断。我认为本实验的难点事实上在第二部分【悲】我可能有大于3/4的时间都花在第二部分上了吧。</p>
<p>第一部分是实现cow fork的基本逻辑，也就是修改fork中对页表的拷贝以及在usertrap中添加对缺页中断的处理，这很直观，没什么好说的。</p>
<p>第三部分要么跟上面的lazy allocation一样，在<code>kernel/vm.c walkaddr()</code>中把缺页中断搬过去，要么向我在<code>主要难点与错误—在内核态中引发并处理缺页中断</code>这一部分那样做。</p>
<p>我们分析这一部分主要讲的是我认为最难的地方，也就是第二部分。其实第二部分的思路也很直观：创建一个数组，index为所有能用的内存的<code>address/PGSIZE</code>，用来记录引用数；然后在每次增加引用时，对应元素++；每次减少引用时，对应元素–。</p>
<p>虽然思路很简单很直观，但是实现起来非常地非常地非常地考验细节（我就非常不擅长这一点）。下面，我就先阐述一下<strong>第二部分的这个方法</strong>需要分割为哪几部分，其他我遇到的印象较深的bug和对一些地方的思考，都放在了下一部分，也即<code>主要难点与错误</code>。</p>
<h5 id="引用数实现分析"><a href="#引用数实现分析" class="headerlink" title="引用数实现分析"></a>引用数实现分析</h5><blockquote>
<p>创建一个数组，index为所有能用的内存的<code>address/PGSIZE</code>，用来记录引用数；然后在每次增加引用时，对应元素++；每次减少引用时，对应元素–。</p>
</blockquote>
<h6 id="数组的大小和数据类型"><a href="#数组的大小和数据类型" class="headerlink" title="数组的大小和数据类型"></a>数组的大小和数据类型</h6><p>由<code>kernel/kalloc.c</code>中的<code>kinit()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="comment">// freerange用来把参数地址范围内的物理页加入freelist中</span></span><br><span class="line">  <span class="comment">// end是内核的结束地址</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，事实上，我们整个程序，包括用户和内核，能用的内存空间为0~PHYSTOP。因而，我们事实上只需要建一个<code>PHYSTOP/PGSIZE</code>这么大的数组就行。我算了一下大概是2^19次方。</p>
<p>然后，我感觉这种小系统应该不会有过多的对某一页的重复引用，因而，为了节省空间，我将数据类型定为了char。最好还是别定成uchar，因为这东西要是0–的话会溢出变为255，很可怕。</p>
<h6 id="什么时候增减引用"><a href="#什么时候增减引用" class="headerlink" title="什么时候增减引用"></a>什么时候增减引用</h6><blockquote>
<p>我认为这里是非常考验细节和头脑清晰度的，也就是我卡了很久最后也没弄出来的部分【悲】</p>
</blockquote>
<p>可以分为三种情况来讲。我们的引用计数必须完美适应这三种情况：</p>
<ol>
<li><p>不经由页表，通过kalloc和kfree直接使用物理页</p>
<p>这就要求我们在kalloc的时候置引用数为1，然后kfree的时候对引用数先-1，再判断是否归零。</p>
</li>
<li><p>经由页表，但与cow fork无关</p>
<p>增加页表项：mappages-&gt;kalloc，因而满足要求1即可。</p>
<p>删除页表项：uvmunmap。当do_free==1时，满足要求1即可。</p>
</li>
<li><p>经由页表，与cow fork有关</p>
<p>copy父进程页表时：在cowcopy中，每增加一次子进程的映射，就需要增加一次引用数</p>
<p>在用户态/内核态发生缺页中断：发生缺页中断后，对原来物理页的引用数需要-1【我就是漏了这一点……】</p>
<p>删除页表项：uvmunmap。当do_free==0时，当对应页表项有COW标记，则减少引用数</p>
</li>
</ol>
<p>所以，我们需要在三个文件进行修改：</p>
<ol>
<li><p>kalloc.c</p>
<p>增加数组定义，在kalloc和kfree中增加引用数修改</p>
</li>
<li><p>vm.c</p>
<p>在cowcopy和uvmunmap中增加引用数修改</p>
</li>
<li><p>trap.c</p>
<p>在usertrap的缺页中断中增加引用计数修改</p>
</li>
</ol>
<h6 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h6><blockquote>
<p>这里我也没想到【悲】</p>
</blockquote>
<p>由于我们的pages数组会在多个文件、多个进程间使用，所以它必须在被锁保护的区域中被使用。</p>
<h4 id="主要难点与错误"><a href="#主要难点与错误" class="headerlink" title="主要难点与错误"></a>主要难点与错误</h4><h5 id="scause-2"><a href="#scause-2" class="headerlink" title="scause=2"></a>scause=2</h5><p><img src="/2023/01/10/xv6/image-20230117161404719.png" alt="image-20230117161404719"></p>
<p>这个发生在我还没有实现第二部分的时候。搜索了一下，scause=2为<code>Illegal instruction</code>，而且sepc的这个1004的值也非常诡异。这应该是因为fork子进程释放了指令段内存，导致主进程执行错误</p>
<h5 id="kernel无法启动"><a href="#kernel无法启动" class="headerlink" title="kernel无法启动"></a>kernel无法启动</h5><p>在kinit中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;pages_lock,<span class="string">&quot;pages&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(pages, <span class="number">0</span>, (<span class="number">2</span>&lt;&lt;<span class="number">19</span>));</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会通过freerange初始化freelist。在freerange中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会对每一项进行一次kfree。因而，我们需要在kfree前先增加一次引用，要不然会寄。</p>
<h5 id="在缺页中断时减少对物理页的引用数"><a href="#在缺页中断时减少对物理页的引用数" class="headerlink" title="在缺页中断时减少对物理页的引用数"></a>在缺页中断时减少对物理页的引用数</h5><p><img src="/2023/01/10/xv6/image-20230117213903706.png" alt="image-20230117213903706"></p>
<p>注意此处不能直接让pages[pa/PGSIZE]–，一定要借助kfree。当此进程为引用pa的最后一个进程的时候，如果仅减少引用数，就会造成内存泄漏。kfree可以既减少引用数，又在适当的时候对物理页释放，可谓一举两得。kfree的这个双重作用思想也在uvmunmap中体现了。</p>
<h5 id="在内核态中引发并处理缺页中断"><a href="#在内核态中引发并处理缺页中断" class="headerlink" title="在内核态中引发并处理缺页中断"></a>在内核态中引发并处理缺页中断</h5><blockquote>
<p>Modify copyout() to use the same scheme as page faults when it encounters a COW page.</p>
</blockquote>
<p>我们所做的第一第二部分仅仅是完成了对来自用户态的缺页中断的完美处理，还尚未处理来自内核态的缺页中断。因而，这个修改copyin和copyout的点实际上就是要我们处理内核态的缺页中断。</p>
<p>这次实验跟上次的lazy allocation一样，都可以直接在walkaddr进行特殊处理，并且差不多要把usertrap的全部代码挪过来【具体见lazy allocation的代码】。不过，我想出了另一个流氓的方法（也就是说其实原理感觉是不大对233）。我选择直接在kernel引发一个访问用户页面的缺页中断，然后在kerneltrap中处理这个中断，就像usertrap一样。</p>
<p>但由于在<code>walkaddr</code>中发生的中断处于内核状态下，所以就进不了usertrap。我们应该在kerneltrap中再次添加和usertrap一样的中断处理。我们会像这样引发一个中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">    *(<span class="type">char</span>*)va = <span class="number">1</span>;<span class="comment">// 此处不能用pa哦</span></span><br></pre></td></tr></table></figure>

<p>然后在kerneltrap中这样处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 只要写入引起的缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line">    uint flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sepc += <span class="number">4</span>;</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">            memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">            <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">            *pte = PA2PTE(mem);</span><br><span class="line">            kfree((<span class="type">void</span>*)pa);</span><br><span class="line">            <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">            flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">            *pte = ((*pte) | flags);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br></pre></td></tr></table></figure>

<p>但是，这样做是不行的。</p>
<blockquote>
<p>会在这里卡住，会无限次不断进入kerneltrap。</p>
<p><img src="/2023/01/10/xv6/image-20230117235028133.png" alt="image-20230117235028133"></p>
</blockquote>
<p>造成这个的原因，经过一番曲折的debug之后，我发现，只要像usertrap中的syscall分支一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重点是这里</span></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>加上这句话就行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sepc += <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>所以，结果就非常显而易见了，是因为一直卡在这句话执行不下去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">char</span>*)va = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这是因为缺页中断会返回到原代码句中执行，所以就会继续回到这句话。而我们知道，此时正处于内核态，并没有开启地址映射，所以此处其实是非法地址越界了。但是我们的目的确实已经达到了（因为va通过stval寄存器被传递到了kerneltrap），所以我们这里只需跳过这句即可。</p>
<p>这也是为什么说我这个方法虽然实现了，但本质上其实非常流氓，不算是kerneltrap。</p>
<blockquote>
<p>Update：验收的时候跟学长说了一下这个点，学长表示不算流氓，反而在内核（至少内核赛）中算是一个比较通用的手法hh没想到还误打误撞上了</p>
<p>它带来的好处是，当地址不合法的时候可以减少开销。</p>
<p>具体来说，内核中一般会将地址空间分为多个vma，因而检查地址越界无需像xv6那样简单查页表，只需查地址是否在对应的vma中即可。所以，直接把这东西转到一个硬件的缺页中断中实现，事实上确实是减少了地址非法时的开销。</p>
</blockquote>
<p>除了这一点外，还有一点很重要的是，由于<code>walkaddr</code>是需要返回一个pa的，因而我们需要手动再把pa在缺页中断后更新一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pa = PTE2PA(*pte);</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">    *(<span class="type">char</span>*)va = <span class="number">1</span>;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pa;</span><br></pre></td></tr></table></figure>

<p>总之，做了这<strong>两个</strong>关键步骤后，也能启动了，也能过cowtest了。所以下面的代码也就贴上了这里的版本。</p>
<h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>本次实验耗时经典五小时（包含笔记时间就是六个半小时了hhh），算是平均水平。很遗憾也很难受的一点是，我的错误最终还是没有自己想出来，而是参考了别人的代码才改对的。思路很简单，但是细节也依然非常多非常坑，还是得再加把劲。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>我们只需要在fork的时候，标记父子进程的所有PTE都为read-only，然后之后就会遇到不同scause的缺页中断，针对特定的scause，新建物理页面，拷贝物理页面，然后重新设置映射即可。而对于其提出的需要标记某页是否能够释放，则需要统计每页的ref数，当ref==1的时候才可以释放。</p>
<h4 id="定义COW标记"><a href="#定义COW标记" class="headerlink" title="定义COW标记"></a>定义COW标记</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) </span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 5)</span></span><br></pre></td></tr></table></figure>

<h4 id="引用数组初始化"><a href="#引用数组初始化" class="headerlink" title="引用数组初始化"></a>引用数组初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/kalloc.c</span></span><br><span class="line"><span class="type">char</span> pages[(<span class="number">2</span>&lt;&lt;<span class="number">19</span>)];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">pages_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;pages_lock,<span class="string">&quot;pages&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(pages, <span class="number">0</span>, (<span class="number">2</span>&lt;&lt;<span class="number">19</span>));</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    pages[(uint64)p/PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="申请和释放页时增删引用"><a href="#申请和释放页时增删引用" class="headerlink" title="申请和释放页时增删引用"></a>申请和释放页时增删引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    acquire(&amp;pages_lock);</span><br><span class="line">    <span class="comment">// 在这</span></span><br><span class="line">    pages[(uint64)r/PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;pages_lock);</span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP || pages[(uint64)pa/PGSIZE] &lt;= <span class="number">0</span> )</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  <span class="comment">// 每次kfree都会减少引用</span></span><br><span class="line">  pages[(uint64)pa/PGSIZE]--;</span><br><span class="line">  <span class="comment">// 说明此时页面还被其他东西引用着，不能释放</span></span><br><span class="line">  <span class="keyword">if</span>(pages[((uint64)pa)/PGSIZE] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pages_lock);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改fork时对页表的复制操作，并标记引用数增加"><a href="#修改fork时对页表的复制操作，并标记引用数增加" class="headerlink" title="修改fork时对页表的复制操作，并标记引用数增加"></a>修改fork时对页表的复制操作，并标记引用数增加</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/proc.c fork()</span></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(cowcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// in kernel/vm.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cowcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;cowcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;cowcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// 去除flag中的PTE_W，并且给父子的都安上没有PTE_W的flag</span></span><br><span class="line">    flags = (flags &amp; (~PTE_W));</span><br><span class="line">    flags = (flags | PTE_COW);</span><br><span class="line">    *pte = ((*pte) &amp; (~PTE_W));</span><br><span class="line">    *pte = ((*pte) | PTE_COW);</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记物理页的引用数增加</span></span><br><span class="line">    acquire(&amp;pages_lock);</span><br><span class="line">    pages[pa/PGSIZE]++;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> err:</span><br><span class="line">  <span class="comment">// 失败了不能释放物理内存</span></span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理缺页中断，标记引用数减少"><a href="#处理缺页中断，标记引用数减少" class="headerlink" title="处理缺页中断，标记引用数减少"></a>处理缺页中断，标记引用数减少</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  <span class="comment">// 只要求写入引起的缺页中断</span></span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">      flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span>* mem;</span><br><span class="line">      <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">          memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">          <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">          *pte = PA2PTE(mem);</span><br><span class="line">          <span class="comment">// 减少引用，引用归零时释放</span></span><br><span class="line">          kfree((<span class="type">void</span>*)pa);</span><br><span class="line">          <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">          flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">          *pte = ((*pte) | flags);</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uvmunmap时减少引用数"><a href="#uvmunmap时减少引用数" class="headerlink" title="uvmunmap时减少引用数"></a>uvmunmap时减少引用数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint64 pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      acquire(&amp;pages_lock);</span><br><span class="line">      <span class="keyword">if</span>(((*pte) &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">          pages[pa/PGSIZE]--;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;pages_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改walkaddr"><a href="#修改walkaddr" class="headerlink" title="修改walkaddr"></a>修改walkaddr</h4><h5 id="在walkaddr中触发缺页中断"><a href="#在walkaddr中触发缺页中断" class="headerlink" title="在walkaddr中触发缺页中断"></a>在walkaddr中触发缺页中断</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="comment">// 在这里</span></span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 触发缺页中断</span></span><br><span class="line">      *(<span class="type">char</span>*)va = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 更新pa值</span></span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在kerneltrap内补上对缺页中断的处理"><a href="#在kerneltrap内补上对缺页中断的处理" class="headerlink" title="在kerneltrap内补上对缺页中断的处理"></a>在kerneltrap内补上对缺页中断的处理</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 只要写入引起的缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line">    uint flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注意，这个很重要！！！！！</span></span><br><span class="line">        sepc += <span class="number">4</span>;</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line">                                 </span><br><span class="line">        <span class="type">char</span>* mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">            memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">            <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">            *pte = PA2PTE(mem);</span><br><span class="line">            kfree((<span class="type">void</span>*)pa);</span><br><span class="line">            <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">            flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">            *pte = ((*pte) | flags);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/01/10/xv6$chap6/">Locking</a>
            
            
            <a class="next" rel="next" href="/2023/01/10/xv6/">xv6</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 修年 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>