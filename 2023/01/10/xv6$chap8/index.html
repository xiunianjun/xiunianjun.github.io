<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat.png">
  <link rel="mask-icon" href="/images/cat.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiunianjun.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="File system 来到指导书最高点！太美丽了xv6。哎呀那不文件系统吗（ 这里是自底向上讲起的。之后可以看看hit网课的自顶向下。     Overview  The disk layer reads and writes blocks on an virtio hard drive.  The buffer cache layer caches disk blocks and synchr">
<meta property="og:type" content="article">
<meta property="og:title" content="File system">
<meta property="og:url" content="https://xiunianjun.github.io/2023/01/10/xv6$chap8/index.html">
<meta property="og:site_name" content="修年">
<meta property="og:description" content="File system 来到指导书最高点！太美丽了xv6。哎呀那不文件系统吗（ 这里是自底向上讲起的。之后可以看看hit网课的自顶向下。     Overview  The disk layer reads and writes blocks on an virtio hard drive.  The buffer cache layer caches disk blocks and synchr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121160555370.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121160641718.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121162324747.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124151719288.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121162324747.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230123212753931.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230123234919055.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121162324747.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124153309132.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124163025094.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124173241241.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124232433793.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230125173143735.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230125162542807.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230125165612112.png">
<meta property="article:published_time" content="2023-01-10T12:25:29.000Z">
<meta property="article:modified_time" content="2023-02-26T06:31:30.980Z">
<meta property="article:author" content="修年">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121160555370.png">

<link rel="canonical" href="https://xiunianjun.github.io/2023/01/10/xv6$chap8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>File system | 修年</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
	
		<script type="text/javascript" 
		color="244,180,180" opacity='0.5' zIndex="-2" count="80"
		src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
	

  <div class="container use-motion">
    <div class="headband"></div>
<a target="_blank" rel="noopener" href="https://github.com/xiunianjun" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">修年</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiunianjun.github.io/2023/01/10/xv6$chap8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="修年">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修年">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          File system
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-10 20:25:29" itemprop="dateCreated datePublished" datetime="2023-01-10T20:25:29+08:00">2023-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 14:31:30" itemprop="dateModified" datetime="2023-02-26T14:31:30+08:00">2023-02-26</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h1><blockquote>
<p>来到指导书最高点！太美丽了xv6。哎呀那不文件系统吗（</p>
<p>这里是自底向上讲起的。之后可以看看hit网课的自顶向下。</p>
</blockquote>
<blockquote>
<p><img src="/2023/01/10/xv6/image-20230121160555370.png" alt="image-20230121160555370"></p>
</blockquote>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="/2023/01/10/xv6/image-20230121160641718.png" alt="image-20230121160641718"></p>
<blockquote>
<p>The disk layer reads and writes blocks on an virtio hard drive. </p>
<p>The buffer cache layer <strong>caches</strong> disk blocks and <strong>synchronizes</strong> access to them, making sure that only one kernel process at a time can modify the data stored in any particular block. </p>
<p>The logging layer allows higher layers to <strong>wrap updates</strong> to several blocks in a <em>transaction</em>, and ensures that the blocks are updated atomically in the face of crashes (i.e., all of them are updated or none). 【日志记录层允许更高层将更新包装到一个<em>事务</em>中的多个块，并确保在崩溃时以原子方式更新块（即，所有块都更新或不更新）。可以类比一下数据库的那个概念。】</p>
<p>The inode layer provides individual files, each represented as an <em>inode</em> with a unique i-number and some blocks holding the file’s data. </p>
<p>The directory layer implements each directory as a <strong>special kind of inode</strong> whose content is a sequence of directory entries, each of which contains a file’s name and i-number. </p>
<p>The pathname layer provides hierarchical path names like /usr/rtm/xv6/fs.c, and resolves them with <strong>recursive</strong> lookup. </p>
<p>The file descriptor layer <strong>abstracts</strong> many Unix resources (e.g., pipes, devices, fifiles, etc.) using the file system interface, simplifying the lives of application programmers.</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<blockquote>
<p>The file system must have a plan for where it stores inodes and content blocks on the disk. To do so, xv6 divides the disk into several sections, as Figure 8.2 shows.</p>
<p>The file system does not use block 0 (it holds the boot sector). </p>
<p>Block 1 is called the <strong>superblock</strong>; it contains <strong>metadata</strong> about the file system (the file system size in blocks, the number of data blocks, the number of inodes, and the number of blocks in the log). The superblock is filled in by a separate program, called <code>mkfs</code>, which builds an <strong>initial</strong> file system.</p>
<p>Blocks starting at 2 hold the log. </p>
<p>After the log are the inodes, with multiple inodes per block. </p>
<p>After those come bitmap blocks tracking which data blocks are in use. 【应该是用来标识每个块是否空闲的吧】</p>
<p>The remaining blocks are data blocks; each is either marked free in the bitmap block, or holds content for a file or directory【要么空闲要么是文件或目录】. </p>
</blockquote>
<h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><blockquote>
<p>The buffer cache has two jobs: </p>
<ol>
<li><strong>synchronize</strong> access to disk blocks to ensure that only one copy of a block is in memory and that only one kernel thread at a time uses that copy; </li>
<li><strong>cache</strong> <u>popular blocks</u> so that they don’t need to be re-read from the slow disk. </li>
</ol>
<p>The code is in <code>bio.c</code>.</p>
<p>Buffer cache中保存磁盘块的缓冲区数量固定，这意味着如果文件系统请求还未存放在缓存中的块，Buffer cache必须回收当前保存其他块内容的缓冲区。Buffer cache为新块回收最近使用最少的缓冲区。这样做的原因是认为最近使用最少的缓冲区是最不可能近期再次使用的缓冲区。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230124151719288.png" alt="image-20230124151719288"></p>
<h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?缓冲区是否包含块的副本</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?缓冲区内容是否已交给磁盘</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这应该代表着一个磁盘块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<p>大概buf数组里存储着所有buf的内容。buf本身通过最近使用排序的双向链表连接，head是链表的头。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called by main.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  <span class="comment">// 把b插在head之后</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上层接口"><a href="#上层接口" class="headerlink" title="上层接口"></a>上层接口</h3><blockquote>
<p>The main interface exported by the buffer cache consists of <code>bread</code> and <code>bwrite</code>.</p>
<p>The buffer cache uses a per-buffer sleep-lock to ensure concurrent security.</p>
</blockquote>
<h4 id="bread"><a href="#bread" class="headerlink" title="bread"></a>bread</h4><blockquote>
<p><code>bread</code> obtains a buf containing a copy of a block which can be read or modified in memory.</p>
<p>依据给定设备号和给定扇区号寻找cache的buf。返回的buf是locked的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a locked buf with the contents of the indicated block.</span></span><br><span class="line"><span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取buf块</span></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line">    <span class="comment">// 说明cache未命中，需要从磁盘读入</span></span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bwrite"><a href="#bwrite" class="headerlink" title="bwrite"></a>bwrite</h4><blockquote>
<p>writes a modified buffer to the appropriate block on the disk</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 必须持有b的锁</span></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  <span class="comment">// 写入磁盘</span></span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="brelse"><a href="#brelse" class="headerlink" title="brelse"></a>brelse</h4><blockquote>
<p> A kernel thread must release a buffer by calling brelse when it is done with it.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    <span class="comment">// 移动到头结点和头结点的下一个结点之间的位置</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><h4 id="bget"><a href="#bget" class="headerlink" title="bget"></a>bget</h4><p>用于获取cache中是否存在block。如果不存在，则新申请一个buf，并把该buf以上锁状态返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="comment">// 这个循环条件很有意思，充分用到了双向链表的特性</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      <span class="comment">// 引用数增加</span></span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      <span class="comment">// 锁定</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="comment">// 从尾部开始遍历，确实就是最少使用的了</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="comment">// 如果该buf空闲</span></span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      <span class="comment">// 仅是新建了一个buf，还未从磁盘读取对应磁盘块的副本，因而设valid为0以供上层函数调用处理</span></span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      <span class="comment">// 锁定</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cache不够用了</span></span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Logging-layer"><a href="#Logging-layer" class="headerlink" title="Logging layer"></a>Logging layer</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>Xv6通过简单的日志记录形式解决了文件系统操作期间的崩溃问题。</p>
<p>xv6系统调用不会直接写入磁盘上的文件系统数据结构。相反，它会在磁盘上的<em>log</em>（日志）中放置它希望进行的所有磁盘写入的描述。一旦系统调用记录了它的所有写入操作，它就会向磁盘写入一条特殊的<em>commit</em>（提交）记录，表明日志包含一个完整的操作。此时，系统调用将写操作复制到磁盘上的文件系统数据结构。完成这些写入后，系统调用将擦除磁盘上的日志。</p>
</blockquote>
<blockquote>
<p>如果系统崩溃并重新启动，则在运行任何进程之前，文件系统代码将按如下方式从崩溃中恢复：</p>
<p>如果日志标记为包含完整操作，则恢复代码会将写操作复制到磁盘文件系统中它们所属的位置，然后擦除日志。如果日志没有标记为包含完整操作，则恢复代码将忽略该日志，然后擦除日志。</p>
</blockquote>
<p>这就保证了原子性。</p>
<h3 id="Log-design"><a href="#Log-design" class="headerlink" title="Log design"></a>Log design</h3><p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<p>superblock记录了log的存储位置。</p>
<blockquote>
<p>它由一个头块（header block）和一系列更新块的副本（logged block）组成。</p>
<p>头块包含一个扇区号（sector）数组（每个logged block对应一个扇区号）以及日志块的计数。</p>
<p>磁盘上的头块中的计数为零表示日志中没有事务，为非零表示日志包含一个完整的已提交事务，并具有指定数量的logged block。</p>
<p>在事务提交（commit）时Xv6才向头块写入数据，在此之前不会写入。在将logged blocks复制到文件系统后，头块的计数将被设置为零。</p>
<p>因此，事务中途崩溃将导致日志头块中的计数为零；提交后的崩溃将导致非零计数。</p>
</blockquote>
<blockquote>
<p>为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写入累积到一个事务中。因此，单个提交可能涉及多个完整系统调用的写入。为了避免在事务之间拆分系统调用，日志系统仅在没有文件系统调用进行时提交。</p>
<p>同时提交多个事务的想法称为组提交（group commit）。组提交减少了磁盘操作的数量，因为成本固定的一次提交分摊了多个操作。组提交还同时为磁盘系统提供更多并发写操作，可能允许磁盘在一个磁盘旋转时间内写入所有这些操作。Xv6的virtio驱动程序不支持这种批处理，但是Xv6的文件系统设计允许这样做。</p>
<p>【这感觉实现得也还挺简略的】</p>
</blockquote>
<blockquote>
<p>Xv6在磁盘上留出固定的空间来保存日志。事务中系统调用写入的块总数必须可容纳于该空间。这导致两个后果：</p>
<ol>
<li><p>任何单个系统调用都不允许写入超过日志空间的不同块。</p>
<p>【这段话我一个字没看懂】</p>
<p>这对于大多数系统调用来说都不是问题，但其中两个可能会写入许多块：<code>write</code>和<code>unlink</code>。一个大文件的<code>write</code>可以写入多个数据块和多个位图块以及一个inode块；<code>unlink</code>大文件可能会写入许多位图块和inode。Xv6的<code>write</code>系统调用将大的写入分解为适合日志的多个较小的写入，<code>unlink</code>不会导致此问题，因为实际上Xv6文件系统只使用一个位图块。</p>
</li>
<li><p>日志空间有限的另一个后果是，除非确定系统调用的写入将可容纳于日志中剩余的空间，否则日志系统无法允许启动系统调用。</p>
</li>
</ol>
</blockquote>
<h3 id="Code-logging"><a href="#Code-logging" class="headerlink" title="Code: logging"></a>Code: logging</h3><blockquote>
<p>log的原理是这样的：</p>
<p>在每个系统调用的开始调用<code>begin_op</code>表示事务开始，然后之后新申请一块block，也即把该block的内容读入内存，并且把该block的blockno记录到log的header中。此后程序正常修改在内存中的block，磁盘中的block保持不变。最后commit的时候遍历log header中的blockno，一块块地把内存中的block写入日志和磁盘中。</p>
<p>如果程序在commit前崩溃，则内存消失，同时磁盘也不会写入；如果在commit后崩溃，那也无事发生。</p>
<p>在每次启动的时候，都会执行log的初始化，届时可以顺便恢复数据。</p>
<p>完美实现了日志的功能。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230123212753931.png" alt="image-20230123212753931"></p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Contents of the header block, used for both the on-disk header block</span></span><br><span class="line"><span class="comment">// and to keep track in memory of logged block# before commit.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="comment">// 扇区号也即blockno的数组</span></span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表log磁盘块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> start;<span class="comment">// log磁盘块的开始。start开始的第一块为log header，之后皆为写入的block</span></span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// how many FS sys calls are executing.</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// in commit(), please wait.</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h4><h5 id="begin-op"><a href="#begin-op" class="headerlink" title="begin_op()"></a>begin_op()</h5><blockquote>
<p><code>begin_op</code>等待直到日志系统当前未处于提交中，并且直到有足够的未被占用的日志空间来保存此调用的写入。</p>
<p><code>log.outstanding</code>统计<strong>预定了日志空间</strong>的系统调用数；为此保留的总空间为<code>log.outstanding</code>乘以<code>MAXOPBLOCKS</code>（10）。递增<code>log.outstanding</code>会预定空间并防止在此系统调用期间发生提交（if的第二个分支）。代码保守地假设每个系统调用最多可以写入<code>MAXOPBLOCKS</code>（10）个不同的块。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the start of each FS system call.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">begin_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 正在提交则等待日志空闲</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;</span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="comment">// 日志空间不足则等待空间充足</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">// this op might exhaust log space此操作可能会耗尽日志空间; wait for commit.</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="log-write"><a href="#log-write" class="headerlink" title="log_write"></a>log_write</h5><blockquote>
<p><code>log_write</code>充当<code>bwrite</code>的代理。它将块的扇区号记录在内存中，在磁盘上的日志中预定一个槽位，并调用<code>bpin</code>将缓存固定在block cache中，以防止block cache将其逐出【具体原理就是让refcnt++，这样就不会被当成空闲block用掉了】。</p>
<p>为啥要防止换出呢？换出不是就正好自动写入磁盘了吗？这里一是为了保障前面提到的原子性，防止换入换出导致的单一写入磁盘；二是换出自动写入的是磁盘对应位而不一定是日志所在的blocks。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">log_write</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log</span></span><br><span class="line">  <span class="comment">// 30</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="comment">// log_write会注意到在单个事务中多次写入一个块的情况，并在日志中为该块分配相同的槽位。</span></span><br><span class="line">  <span class="comment">// 这种优化通常称为合并（absorption）</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorbtion</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里还是挺巧妙的。</span></span><br><span class="line">  <span class="comment">// 如果存在log.lh.block[i] == b-&gt;blockno的情况，执行此句话也无妨</span></span><br><span class="line">  <span class="comment">// 如果不存在，则给log新增一块，填入log.lh.block[log.lh.n]的位置，再++log.lh.n</span></span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log?</span></span><br><span class="line">    bpin(b);</span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="end-op"><a href="#end-op" class="headerlink" title="end_op"></a>end_op</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the end of each FS system call.</span></span><br><span class="line"><span class="comment">// 如果这是最后一层outstanding就会执行commit操作</span></span><br><span class="line"><span class="comment">// commits if this was the last outstanding operation.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// begin_op() may be waiting for log space,</span></span><br><span class="line">    <span class="comment">// and decrementing log.outstanding has decreased</span></span><br><span class="line">    <span class="comment">// the amount of reserved space.</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    <span class="comment">// call commit w/o holding locks, since not allowed</span></span><br><span class="line">    <span class="comment">// to sleep with locks.</span></span><br><span class="line">    commit();</span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// cache -&gt; log block</span></span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    <span class="comment">// head(in stack/heap) -&gt; log block</span></span><br><span class="line">    <span class="comment">// 此可以说为commit完成的标志。</span></span><br><span class="line">    <span class="comment">// 因为无论接下来是否崩溃，数据最终都会被写入disk，不同在于是在recover时还是接下来写入</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    <span class="comment">// log block -&gt; real position</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 擦除</span></span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="write-log"><a href="#write-log" class="headerlink" title="write_log"></a>write_log</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy modified blocks from cache to log.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">    brelse(from);<span class="comment">// 此处的brelse呼应了外界调用的bread</span></span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="write-head"><a href="#write-head" class="headerlink" title="write_head"></a>write_head</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write in-memory log header to disk.</span></span><br><span class="line"><span class="comment">// 这是事务提交的标志</span></span><br><span class="line"><span class="comment">// This is the true point at which the</span></span><br><span class="line"><span class="comment">// current transaction commits.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf);</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="install-trans"><a href="#install-trans" class="headerlink" title="install_trans"></a>install_trans</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy committed blocks from log to their home location</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">install_trans</span><span class="params">(<span class="type">int</span> recovering)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// read log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// read dst</span></span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="comment">// copy block to dst</span></span><br><span class="line">    bwrite(dbuf);  <span class="comment">// write dst to disk</span></span><br><span class="line">    <span class="keyword">if</span>(recovering == <span class="number">0</span>)</span><br><span class="line">      bunpin(dbuf);<span class="comment">// 如果不是在recover的过程中</span></span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="恢复与初始化"><a href="#恢复与初始化" class="headerlink" title="恢复与初始化"></a>恢复与初始化</h4><p>上面介绍了log的一次事务提交的流程。接下来介绍它是怎么恢复的。</p>
<blockquote>
<p><code>recover_from_log</code>是由<code>initlog</code>调用的，而它又是在第一个用户进程运行之前的引导期间由<code>fsinit</code>调用的。</p>
</blockquote>
<h5 id="第一个进程运行之前"><a href="#第一个进程运行之前" class="headerlink" title="第一个进程运行之前"></a>第一个进程运行之前</h5><p>由前面scheduler一章的知识可知，每个进程被初次调度的时候会先来执行<code>forkret</code>。这时候就做了log的恢复工作。</p>
<p>注释解释了为什么不选择在<code>main.c</code>中初始化，而选择在此处初始化。确实，它需要调用sleep，如果在main.c中调用sleep感觉会乱套（）毕竟那时候scheduler线程尚未被初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A fork child&#x27;s very first scheduling by scheduler()</span></span><br><span class="line"><span class="comment">// will swtch to forkret.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// static变量仅会被初始化一次</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Still holding p-&gt;lock from scheduler.</span></span><br><span class="line">  release(&amp;myproc()-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是第一个进程</span></span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    <span class="comment">// File system initialization must be run in the context of a</span></span><br><span class="line">    <span class="comment">// regular process (e.g., because it calls sleep), and thus cannot</span></span><br><span class="line">    <span class="comment">// be run from main().</span></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    fsinit(ROOTDEV);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fsinit"><a href="#fsinit" class="headerlink" title="fsinit"></a>fsinit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init fs</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fsinit</span><span class="params">(<span class="type">int</span> dev)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  initlog(dev, &amp;sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="initlog"><a href="#initlog" class="headerlink" title="initlog"></a>initlog</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlog</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> logheader) &gt;= BSIZE)</span><br><span class="line">    panic(<span class="string">&quot;initlog: too big logheader&quot;</span>);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;<span class="built_in">log</span>.lock, <span class="string">&quot;log&quot;</span>);</span><br><span class="line">  <span class="comment">// 从super block中获取必要参数</span></span><br><span class="line">  <span class="built_in">log</span>.start = sb-&gt;logstart;</span><br><span class="line">  <span class="built_in">log</span>.size = sb-&gt;nlog;</span><br><span class="line">  <span class="built_in">log</span>.dev = dev;</span><br><span class="line">  recover_from_log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="recover-from-log"><a href="#recover-from-log" class="headerlink" title="recover_from_log"></a>recover_from_log</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 读取head</span></span><br><span class="line">  read_head();</span><br><span class="line">  <span class="comment">// 注意，commit中会把header写入log block，而这里从log block读出header</span></span><br><span class="line">  <span class="comment">// 也就是说，如果header的n不为零，那么说明已经commit了，但可能未写入，重复写入保障安全</span></span><br><span class="line">  <span class="comment">// 如果header的n为零，说明未commit，在install_trans的逻辑中会什么也不做</span></span><br><span class="line">  <span class="comment">// 两种情况完美满足</span></span><br><span class="line">  install_trans(<span class="number">1</span>); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 擦除</span></span><br><span class="line">  write_head(); <span class="comment">// clear the log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Block-allocator"><a href="#Code-Block-allocator" class="headerlink" title="Code: Block allocator"></a>Code: Block allocator</h2><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>说实话没怎么懂，也不大清楚它有什么用，先大概推测一下：</p>
<p>之前的bread和bwrite这些，就是你给一个设备号和扇区号，它就帮你加载进内存cache。你如果要用的话，肯定还是使用地址方便。所以block allocator的作用之一就是给bread和bwrite加一层封装，将获取的block封装为地址返回，你可以直接操纵这个地址，<strong>而无需知道下层的细节。</strong></p>
<p>这个过程要注意的有两点：</p>
<ol>
<li><p>封装返回的地址具体是什么，怎么工作的</p>
<p>封装返回的地址实质上是buffer cache中的buf的data字段的地址【差不多】。之后的上层应用在该地址上写入，也即写入了buf，最后会通过log层真正写入磁盘。</p>
</li>
<li><p>结合bcache的LRU，详细谈谈工作机制</p>
<p>我们可以看到，在balloc中有这么一段逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> b + bi;</span><br></pre></td></tr></table></figure>

<p>看到的第一反应就是，我们需求的那块buf是bp，但是这里先是bread了一次，又是brelse了一次，这样bp的refcnt不就为0，很容易被替换掉了吗？</p>
<p>会有这个反应，一定程度上是因为没有很好地理解LRU。事实上，正是它可能被替换掉，才满足了LRU的条件。因为它可能被替掉才能说明它可能是最近最少使用的。</p>
</li>
</ol>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><blockquote>
<p>文件和目录内容存储在磁盘块中，磁盘块必须从空闲池中分配。xv6的块分配器在磁盘上维护一个空闲位图，每一位代表一个块。0表示对应的块是空闲的；1表示它正在使用中。</p>
<p>引导扇区、超级块、日志块、inode块和位图块的比特位是由程序<code>mkfs</code>初始化设置的：</p>
<p><img src="/2023/01/10/xv6/image-20230123234919055.png" alt="image-20230123234919055"></p>
</blockquote>
<h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3><p>类似于memory allocator，块分配器也提供了两个函数：<code>bfree</code>和<code>balloc</code>。</p>
<h4 id="balloc"><a href="#balloc" class="headerlink" title="balloc"></a>balloc</h4><blockquote>
<p><code>Balloc</code>从块0到<code>sb.size</code>（文件系统中的块数）遍历每个块。它查找位图中位为零的空闲块。如果<code>balloc</code>找到这样一个块，它将更新位图并返回该块。</p>
<p>为了提高效率，循环被分成两部分。外部循环读取位图中的每个块。内部循环检查单个位图块中的所有BPB位。由于任何一个位图块在buffer cache中一次只允许一个进程使用【<code> bread(dev, BBLOCK(b, sb))</code>会返回一个上锁的block，<code>bread</code>和<code>brelse</code>隐含的独占使用避免了显式锁定的需要】，因此，如果两个进程同时尝试分配一个块也是并发安全的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a zeroed disk block.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">balloc</span><span class="params">(uint dev)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> b, bi, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  bp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(b = <span class="number">0</span>; b &lt; sb.size; b += BPB)&#123;</span><br><span class="line">    bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">    <span class="keyword">for</span>(bi = <span class="number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;</span><br><span class="line">      m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)&#123;  <span class="comment">// Is block free?</span></span><br><span class="line">        bp-&gt;data[bi/<span class="number">8</span>] |= m;  <span class="comment">// Mark block in use.</span></span><br><span class="line">        log_write(bp);</span><br><span class="line">        brelse(bp);</span><br><span class="line">        bzero(dev, b + bi);</span><br><span class="line">        <span class="keyword">return</span> b + bi;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;balloc: out of blocks&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bfree"><a href="#bfree" class="headerlink" title="bfree"></a>bfree</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a disk block.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="type">int</span> bi, m;</span><br><span class="line"></span><br><span class="line">  bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">  bi = b % BPB;</span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">  bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Inode-layer"><a href="#Inode-layer" class="headerlink" title="Inode layer"></a>Inode layer</h2><h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><blockquote>
<p>术语inode（即索引结点）可以具有两种相关含义之一。它可能是指包含文件大小和数据块编号列表的磁盘上的数据结构【on-disk inode】。或者“inode”可能指内存中的inode【in-memory inode】，它包含磁盘上inode的副本以及内核中所需的额外信息。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<h4 id="on-disk-inode"><a href="#on-disk-inode" class="headerlink" title="on-disk inode"></a>on-disk inode</h4><blockquote>
<p>The on-disk inodes are packed into a contiguous area of disk called the inode blocks. </p>
<p>Every inode is the <strong>same size,</strong> so it is easy, given a number n, to find the nth inode on the disk. In fact, this number n, called the <strong>inode number</strong> or <strong>i-number</strong>, is how inodes are <strong>identifified</strong> in the implementation.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in fs.h</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 为0表示free</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="comment">//  The nlink field counts the number of directory entries that refer to this inode,</span></span><br><span class="line">  <span class="comment">//  in order to recognize when the on-disk inode and its data blocks should be freed.</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="in-memory-inode"><a href="#in-memory-inode" class="headerlink" title="in-memory inode"></a>in-memory inode</h4><blockquote>
<p>The kernel keeps the set of active inodes in memory.</p>
<p>The kernel stores an inode in memory <strong>only</strong> if there are C pointers referring to that inode.当且仅当ref==0才会从内核中释放。</p>
<p>如果nlinks==0就会从物理block中释放。</p>
<p>The <code>iget</code> and <code>iput</code> functions acquire and release pointers to an inode, modifying the reference count.【相当于buffer cache的<code>balloc</code>和<code>bfree</code>】Pointers to an inode can come from file descriptors, current working directories, and transient kernel code such as exec.</p>
<p><code>iget</code>返回的<code>struct inode</code>可能没有任何有用的内容。为了确保它保存磁盘inode的副本，代码必须调用<code>ilock</code>。这将锁定inode（以便没有其他进程可以对其进行<code>ilock</code>），并从磁盘读取尚未读取的inode。<code>iunlock</code>释放inode上的锁。将inode指针的获取与锁定分离有助于在某些情况下避免死锁，例如在目录查找期间。多个进程可以持有指向<code>iget</code>返回的inode的C指针，但一次只能有一个进程锁定inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];<span class="comment">// 存储着inode数据的blocks的地址，从balloc中获取</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Code-inode"><a href="#Code-inode" class="headerlink" title="Code: inode"></a>Code: inode</h3><blockquote>
<p>主要是在讲inode layer这一层的方法，以及给上层提供的接口。</p>
</blockquote>
<h4 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h4><p><img src="/2023/01/10/xv6/image-20230124153309132.png" alt="image-20230124153309132"></p>
<h4 id="底层接口"><a href="#底层接口" class="headerlink" title="底层接口"></a>底层接口</h4><blockquote>
<p><code>iget</code> <code>iput</code> </p>
</blockquote>
<h5 id="iget"><a href="#iget" class="headerlink" title="iget"></a>iget</h5><p>逻辑还是跟buffer cache非常相似的，不过可以看出这个的数据结构简单许多，也不用实现LRU。</p>
<blockquote>
<p>A struct inode pointer returned by iget() is <strong>guaranteed to be valid</strong> until the corresponding call to iput()： the inode <u>won’t be deleted</u>, and the memory referred to by the pointer <u>won’t be re-used</u> for a different inode. 【通过ref++实现。】</p>
<p>不同于buffer cache的<code>bget</code>，<code>iget()</code>提供对inode的非独占访问，因此可以有许多指向同一inode的指针。文件系统代码的许多部分都依赖于<code>iget()</code>的这种行为，既可以保存对inode的长期引用（如打开的文件和当前目录），也可以防止争用，同时避免操纵多个inode（如路径名查找）的代码产生死锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the inode with number inum on device dev</span></span><br><span class="line"><span class="comment">// and return the in-memory copy. Does not lock</span></span><br><span class="line"><span class="comment">// the inode and does not read it from disk.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">iget</span><span class="params">(uint dev, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the inode already cached?</span></span><br><span class="line">  empty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ip = &amp;icache.inode[<span class="number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">      ip-&gt;ref++;</span><br><span class="line">      release(&amp;icache.lock);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于不用实现LRU，所以只需一次循环记录即可。</span></span><br><span class="line">    <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// Remember empty slot.</span></span><br><span class="line">      empty = ip;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recycle an inode cache entry.</span></span><br><span class="line">  <span class="keyword">if</span>(empty == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;iget: no inodes&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ip = empty;</span><br><span class="line">  ip-&gt;dev = dev;</span><br><span class="line">  ip-&gt;inum = inum;</span><br><span class="line">  ip-&gt;ref = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// does not read from disk</span></span><br><span class="line">  ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="iput"><a href="#iput" class="headerlink" title="iput"></a>iput</h5><blockquote>
<p><code>iput()</code>可以写入磁盘。这意味着任何使用文件系统的系统调用都可能写入磁盘，因为系统调用可能是最后一个引用该文件的系统调用。即使像<code>read()</code>这样看起来是只读的调用，也可能最终调用<code>iput()</code>。这反过来意味着，即使是只读系统调用，如果它们使用文件系统，也必须在事务中进行包装。</p>
<p><code>iput()</code>和崩溃之间存在一种具有挑战性的交互。<code>iput()</code>不会在文件的链接计数降至零时立即截断文件，因为某些进程可能仍在内存中保留对inode的引用：进程可能仍在读取和写入该文件，因为它已成功打开该文件。但是，如果在最后一个进程关闭该文件的文件描述符之前发生崩溃，则该文件将被标记为已在磁盘上分配，但没有目录项指向它。如果不做任何处理措施的话，这块磁盘就再也用不了了。</p>
<p>文件系统以两种方式之一处理这种情况。简单的解决方案用于恢复时：重新启动后，文件系统会扫描整个文件系统，以查找标记为已分配但没有指向它们的目录项的文件。如果存在任何此类文件，接下来可以将其释放。</p>
<p>第二种解决方案不需要扫描文件系统。在此解决方案中，文件系统在磁盘（例如在超级块中）上记录链接计数降至零但引用计数不为零的文件的i-number。如果文件系统在其引用计数达到0时删除该文件，则会通过从列表中删除该inode来更新磁盘列表。重新启动时，文件系统将释放列表中的所有文件。</p>
<p>Xv6没有实现这两种解决方案，这意味着inode可能被标记为已在磁盘上分配，即使它们不再使用。这意味着随着时间的推移，xv6可能会面临磁盘空间不足的风险。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Drop a reference to an in-memory inode.</span></span><br><span class="line"><span class="comment">// If that was the last reference, the inode cache entry can</span></span><br><span class="line"><span class="comment">// be recycled.【refvnt==0 可以回收】</span></span><br><span class="line"><span class="comment">// 注意这个回收过程无需特别处理，只需自然--refcnt就行，不用像buffer cache那么烦</span></span><br><span class="line"><span class="comment">// If that was the last reference and the inode has no links</span></span><br><span class="line"><span class="comment">// to it, free the inode (and its content) on disk.【nlinks==0 copy和本体都得扔掉】</span></span><br><span class="line"><span class="comment">// All calls to iput() must be inside a transaction in</span></span><br><span class="line"><span class="comment">// case it has to free the inode.任何需要iput的地方都需要包裹在事务内，因为它可能会释放inode</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;ref == <span class="number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// inode has no links and no other references: truncate and free.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ip-&gt;ref == 1 means no other process can have ip locked,</span></span><br><span class="line">    <span class="comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span></span><br><span class="line">    acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    release(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终调用bfree，会标记bitmap，完全释放block</span></span><br><span class="line">    itrunc(ip);</span><br><span class="line">    ip-&gt;type = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/*iupdate:</span></span><br><span class="line"><span class="comment">    // Copy a modified in-memory inode to disk.</span></span><br><span class="line"><span class="comment">    // Must be called after every change to an ip-&gt;xxx field</span></span><br><span class="line"><span class="comment">	// that lives on disk, since i-node cache is write-through.</span></span><br><span class="line"><span class="comment">	write-through:</span></span><br><span class="line"><span class="comment">	CPU向cache写入数据时，同时向memory(后端存储)也写一份，使cache和memory的数据保持一致。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 这里修改的type是dinode也有的字段，所以需要update一下。</span></span><br><span class="line">    <span class="comment">// 下面的valid是dinode没有的字段，所以随便改，无需update</span></span><br><span class="line">    iupdate(ip);</span><br><span class="line">    ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    releasesleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;icache.lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;ref--;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上层接口-1"><a href="#上层接口-1" class="headerlink" title="上层接口"></a>上层接口</h4><h5 id="获取和释放inode"><a href="#获取和释放inode" class="headerlink" title="获取和释放inode"></a>获取和释放inode</h5><h6 id="ialloc"><a href="#ialloc" class="headerlink" title="ialloc"></a>ialloc</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate an inode on device dev.</span></span><br><span class="line"><span class="comment">// Mark it as allocated by  giving it type type.</span></span><br><span class="line"><span class="comment">// Returns an unlocked but allocated and referenced inode.</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">ialloc</span><span class="params">(uint dev, <span class="type">short</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;</span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// a free inode通过type判断是否free</span></span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));<span class="comment">// zerod</span></span><br><span class="line">      dip-&gt;type = type;</span><br><span class="line">      log_write(bp);   <span class="comment">// mark it allocated on the disk</span></span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;ialloc: no inodes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="inode的锁保护"><a href="#inode的锁保护" class="headerlink" title="inode的锁保护"></a>inode的锁保护</h5><p>前面说到，inode的设计使得有多个指针同时指向一个inode成为了可能。因而，修改使用inode的时候就要对其进行独占访问。使用<code>ialloc</code>获取和用<code>ifree</code>释放的inode必须被保护在<code>ilock</code>和<code>iunlock</code>区域中。</p>
<h6 id="ilock"><a href="#ilock" class="headerlink" title="ilock"></a>ilock</h6><p><code>ilock</code>既可以实现对inode的独占访问，同时也可以给未初始化的inode进行初始化工作。</p>
<blockquote>
<p><code>iget</code>返回的<code>struct inode</code>可能没有任何有用的内容。为了确保它保存磁盘inode的副本，代码必须调用<code>ilock</code>。这将锁定inode（以便没有其他进程可以对其进行<code>ilock</code>），并从磁盘读取尚未读取的inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock the given inode and reads the inode from disk if necessary.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ilock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;ilock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 通过inode索引号和superblock算出扇区号</span></span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    <span class="comment">// 填充ip</span></span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">    ip-&gt;major = dip-&gt;major;</span><br><span class="line">    ip-&gt;minor = dip-&gt;minor;</span><br><span class="line">    ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="iunlock"><a href="#iunlock" class="headerlink" title="iunlock"></a>iunlock</h6><blockquote>
<p><code>iunlock</code>释放inode上的锁。</p>
<p>将inode指针的获取与锁定分离有助于在某些情况下避免死锁，例如在目录查找期间。多个进程可以持有指向<code>iget</code>返回的inode的C指针，但一次只能有一个进程锁定inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock the given inode.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iunlock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;iunlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Code-inode-content"><a href="#Code-inode-content" class="headerlink" title="Code: inode content"></a>Code: inode content</h3><h4 id="Overview-2"><a href="#Overview-2" class="headerlink" title="Overview"></a>Overview</h4><blockquote>
<p>主要讲的是inode本身存储数据的结构</p>
</blockquote>
<blockquote>
<p>磁盘上的inode结构体<code>struct dinode</code>包含一个<code>size</code>和一个块号数组（见图8.3），数组内罗列着存储着该inode数据的块号。</p>
<p>前面的<code>NDIRECT</code>个数据块被列在数组中的前<code>NDIRECT</code>个元素中；这些块称为直接块（direct blocks）。接下来的<code>NINDIRECT</code>个数据块不在inode中列出，而是在称为间接块（indirect block）的数据块中列出。<code>addrs</code>数组中的最后一个元素给出了间接块的地址。</p>
<p>因此，可以从inode中列出的块加载文件的前12 kB（<code>NDIRECT x BSIZE</code>）字节，而只有在查阅间接块后才能加载下一个256 kB（<code>NINDIRECT x BSIZE</code>）字节。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/10/xv6/image-20230124163025094.png" alt="image-20230124163025094"></p>
<h4 id="bmap"><a href="#bmap" class="headerlink" title="bmap"></a>bmap</h4><blockquote>
<p>函数<code>bmap</code>负责封装这个寻找数据块的过程，以便实现我们将很快看到的如<code>readi</code>和<code>writei</code>这样的更高级例程。</p>
<p><code>bmap(struct inode *ip, uint bn)</code>返回inode<code>ip</code>的第<code>bn</code>个数据块的磁盘块号。如果<code>ip</code>还没有这样的块，<code>bmap</code>会分配一个。</p>
<p><code>Bmap</code>使<code>readi</code>和<code>writei</code>很容易获取inode的数据。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inode content</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The content (data) associated with each inode is stored</span></span><br><span class="line"><span class="comment">// in blocks on the disk. The first NDIRECT block numbers</span></span><br><span class="line"><span class="comment">// are listed in ip-&gt;addrs[].  The next NINDIRECT blocks are</span></span><br><span class="line"><span class="comment">// listed in block ip-&gt;addrs[NDIRECT].</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip.</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果为direct block</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 如果为indirect block</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 如果没有，会分配一个</span></span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="itrunc"><a href="#itrunc" class="headerlink" title="itrunc"></a>itrunc</h4><blockquote>
<p><code>itrunc</code>释放文件的块，将inode的<code>size</code>重置为零。</p>
<p><code>Itrunc</code>首先释放直接块，然后释放间接块中列出的块，最后释放间接块本身。</p>
</blockquote>
<h4 id="readi"><a href="#readi" class="headerlink" title="readi"></a>readi</h4><blockquote>
<p><code>readi</code>和<code>writei</code>都是从检查<code>ip-&gt;type == T_DEV</code>开始的。这种情况处理的是数据不在文件系统中的特殊设备；我们将在文件描述符层返回到这种情况。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read data from inode.数据大小为n，从off开始，读到dst处</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="comment">// If user_dst==1, then dst is a user virtual address;</span></span><br><span class="line"><span class="comment">// otherwise, dst is a kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">readi</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; ip-&gt;size)</span><br><span class="line">    n = ip-&gt;size - off;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主循环处理文件的每个块，将数据从缓冲区复制到dst</span></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      tot = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="writei"><a href="#writei" class="headerlink" title="writei"></a>writei</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write data to inode.</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="comment">// If user_src==1, then src is a user virtual address;</span></span><br><span class="line"><span class="comment">// otherwise, src is a kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">writei</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_src, uint64 src, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// writei会自动增长文件，除非达到文件的最大大小</span></span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; MAXFILE*BSIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      n = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(off &gt; ip-&gt;size)</span><br><span class="line">      <span class="comment">// 说明扩大了文件大小，需要修改</span></span><br><span class="line">      ip-&gt;size = off;</span><br><span class="line">    <span class="comment">// write the i-node back to disk even if the size didn&#x27;t change</span></span><br><span class="line">    <span class="comment">// because the loop above might have called bmap() and added a new</span></span><br><span class="line">    <span class="comment">// block to ip-&gt;addrs[].</span></span><br><span class="line">    iupdate(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stati"><a href="#stati" class="headerlink" title="stati"></a>stati</h4><blockquote>
<p>函数<code>stati</code>将inode元数据复制到<code>stat</code>结构体中，该结构通过<code>stat</code>系统调用向用户程序公开。</p>
</blockquote>
<p>在<code>defs.h</code>中可看到inode结构体是private的，而stat是public的。</p>
<h2 id="Directory-layer"><a href="#Directory-layer" class="headerlink" title="Directory layer"></a>Directory layer</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>目录的内部实现很像文件。其inode的<code>type</code>为<code>T_DIR</code>，其数据是directory entries的集合。</p>
<p>每个entry都是一个<code>struct dirent</code>。</p>
</blockquote>
<p><strong>也就是说这一层其实本质上是一个大小一定的map</strong>，该map自身也存放在inode中，大小为inode的大小，每个表项entry<strong>映射了目录名和文件inode</strong>。所以接下来介绍的函数我们完全可以从hashmap增删改查的角度去理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;<span class="comment">// 如果为0，说明该entry free</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/10/xv6/image-20230124173241241.png" alt="image-20230124173241241"></p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><h4 id="dirlookup"><a href="#dirlookup" class="headerlink" title="dirlookup"></a>dirlookup</h4><blockquote>
<p>函数<code>dirlookup</code>在directory中搜索具有给定名称的entry。</p>
<p>它返回的指向enrty.inum相应的inode是非独占的【通过iget获取】，也即无锁状态。它还会把<code>*poff</code>设置为所需的entry的字节偏移量。</p>
<p>为什么要返回未锁定的inode？是因为调用者已锁定<code>dp</code>，因此，如果对<code>.</code>进行查找，则在返回之前尝试锁定inode将导致重新锁定<code>dp</code>并产生死锁【确实】(还有更复杂的死锁场景，涉及多个进程和<code>..</code>，父目录的别名。<code>.</code>不是唯一的问题。）</p>
<p>所以锁定交给caller来做。caller可以解锁<code>dp</code>，然后锁定该函数返回的<code>ip</code>，确保它一次只持有一个锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look for a directory entry in a directory.</span></span><br><span class="line"><span class="comment">// If found, set *poff to byte offset of entry.</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">dirlookup</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint *poff)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint off, inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;type != T_DIR)</span><br><span class="line">    panic(<span class="string">&quot;dirlookup not DIR&quot;</span>);</span><br><span class="line">  <span class="comment">// new level of abstraction,可以把directory的inode看作一个表文件，每个表项都是一个entry</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="comment">// 从directory中获取entry，也即从inode中获取数据</span></span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlookup read&quot;</span>);</span><br><span class="line">    <span class="comment">// free</span></span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(namecmp(name, de.name) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// entry matches path element</span></span><br><span class="line">      <span class="keyword">if</span>(poff)</span><br><span class="line">        *poff = off;</span><br><span class="line">      inum = de.inum;</span><br><span class="line">      <span class="keyword">return</span> iget(dp-&gt;dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dirlink"><a href="#dirlink" class="headerlink" title="dirlink"></a>dirlink</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write a new directory entry (name, inum) into the directory dp.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dirlink</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that name is not present.</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Look for an empty dirent.</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlink read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没找到空闲的则调用writei自动增长inode，添加新表项</span></span><br><span class="line">  <span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">  de.inum = inum;</span><br><span class="line">  <span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">    panic(<span class="string">&quot;dirlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pathname-layer"><a href="#Pathname-layer" class="headerlink" title="Pathname layer"></a>Pathname layer</h2><blockquote>
<p>Path name lookup involves a succession of calls to dirlookup, one for each path component.</p>
</blockquote>
<h3 id="namei和nameiparent"><a href="#namei和nameiparent" class="headerlink" title="namei和nameiparent"></a>namei和nameiparent</h3><blockquote>
<p>Namei (kernel/fs.c:661) evaluates path and returns the corresponding inode.</p>
<p>函数<code>nameiparent</code>是一个变体：它在最后一个元素之前停止，返回父目录的inode并将最后一个元素复制到<code>name</code>中。两者都调用通用函数<code>namex</code>来完成实际工作。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">0</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">1</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="namex"><a href="#namex" class="headerlink" title="namex"></a>namex</h3><blockquote>
<p><code>Namex</code>首先决定路径解析的开始位置。</p>
<p>如果路径以“ / ”开始，则从根目录开始解析；否则，从当前目录开始。</p>
<p>然后，它使用<code>skipelem</code>依次考察路径的每个元素。循环的每次迭代都必须在当前索引结点<code>ip</code>中查找<code>name</code>。</p>
<p>迭代首先给<code>ip</code>上锁并检查它是否是一个目录。如果不是，则查找失败。</p>
<p>如果caller是<code>nameiparent</code>，并且这是最后一个路径元素，则根据<code>nameiparent</code>的定义，循环会提前停止；最后一个路径元素已经复制到<code>name</code>中【在上一轮循坏中做了这件事】，因此<code>namex</code>只需返回解锁的<code>ip</code>。</p>
<p>最后，循环将使用<code>dirlookup</code>查找路径元素，并通过设置<code>ip = next</code>为下一次迭代做准备。当循环用完路径元素时，它返回<code>ip</code>。</p>
<p>注：</p>
<ol>
<li>在每次迭代中锁定<code>ip</code>是必要的，不是因为<code>ip-&gt;type</code>可以被更改，而是因为在<code>ilock</code>运行之前，<code>ip-&gt;type</code>不能保证已从磁盘加载，所以得用到ilock保证一定会被加载的这个性质。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up and return the inode for a path name.</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes.</span></span><br><span class="line"><span class="comment">// Must be called inside a transaction since it calls iput().</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用skipelem依次考察路径的每个元素</span></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early.</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>namex</code>过程可能需要很长时间才能完成：它可能涉及多个磁盘操作来读取路径名中所遍历目录的索引节点和目录块（如果它们不在buffer cache中）。</p>
<p>Xv6 is carefully designed，如果一个内核线程对<code>namex</code>的调用在磁盘I/O上阻塞，另一个查找不同路径名的内核线程可以同时进行。<code>Namex</code> locks each directory in the path <strong>separately</strong> so that lookups in different directories can proceed in parallel.锁细粒度化</p>
<p>This concurrency introduces some challenges. For example, while one kernel thread is looking up a pathname another kernel thread may be changing the directory tree by unlinking a directory. A potential risk is that a lookup may be searching a directory that has been deleted by another kernel thread and its blocks have been re-used for another directory or file.一个潜在的风险是，查找可能正在搜索已被另一个内核线程删除且其块已被重新用于另一个目录或文件的目录。</p>
<p>Xv6避免了这种竞争，也就是说，你查到的inode保证暂时不会被释放，里面的内容还是真的，而不会被重新利用从而导致里面的内容变样。</p>
<p>例如，在<code>namex</code>中执行<code>dirlookup</code>时，lookup线程持有目录上的锁，<code>dirlookup</code>返回使用<code>iget</code>获得的inode。<code>Iget</code>增加索引节点的引用计数。只有在从<code>dirlookup</code>接收inode之后，<code>namex</code>才会释放目录上的锁。现在，另一个线程可以从目录中取消inode的链接，但是xv6还不会删除inode，<u>因为inode的引用计数仍然大于零</u>。</p>
<p>另一个风险是死锁。例如，查找“<code>.</code>”时，<code>next</code>指向与<code>ip</code>相同的inode【确实】。在释放<code>ip</code>上的锁之前锁定<code>next</code>将导致死锁【为什么？？？难道不是会由于在acquire时已经持有锁，从而爆<code>panic(&quot;acquire&quot;)</code>吗？】。为了避免这种死锁，<code>namex</code>在获得下一个目录的锁之前解锁该目录。这里我们再次看到为什么<code>iget</code>和<code>ilock</code>之间的分离很重要。</p>
</blockquote>
<h2 id="File-descriptor-layer"><a href="#File-descriptor-layer" class="headerlink" title="File descriptor layer"></a>File descriptor layer</h2><blockquote>
<p>Unix的一个很酷的方面是，Unix中的大多数资源都表示为文件，包括控制台、管道等设备，当然还有真实文件。文件描述符层是实现这种一致性的层。</p>
</blockquote>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>Xv6为每个进程提供了自己的打开文件表或文件描述符。每个打开的文件都由一个<code>struct file</code>表示，它是inode或管道的封装，加上一个I/O偏移量。</p>
<p>每次调用<code>open</code>都会创建一个新的打开文件（一个新的<code>struct file</code>）：如果多个进程独立地打开同一个文件，那么不同的实例将具有不同的I/O偏移量。</p>
<p>另一方面，单个打开的文件（同一个<code>struct file</code>）可以多次出现在一个进程的文件表中，也可以出现在多个进程的文件表中。如果一个进程使用<code>open</code>打开文件，然后使用<code>dup</code>创建别名，或使用<code>fork</code>与子进程共享，就会发生这种情况。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;</span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ftable"><a href="#ftable" class="headerlink" title="ftable"></a>ftable</h3><blockquote>
<p>所有在系统中打开的文件都会被放入global file table<code>ftable</code>中。</p>
<p><code>ftable</code>具有分配文件（<code>filealloc</code>）、创建重复引用（<code>filedup</code>）、释放引用（<code>fileclose</code>）以及读取和写入数据（<code>fileread</code>和<code>filewrite</code>）的函数。</p>
<p>前三个都很常规，跟之前的xxalloc、xxfree的思路是一样的。</p>
<p>函数<code>filestat</code>、<code>fileread</code>和<code>filewrite</code>实现对文件的<code>stat</code>、<code>read</code>和<code>write</code>操作。</p>
</blockquote>
<h4 id="filealloc"><a href="#filealloc" class="headerlink" title="filealloc"></a>filealloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filealloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">      f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">      release(&amp;ftable.lock);</span><br><span class="line">      <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="filedup"><a href="#filedup" class="headerlink" title="filedup"></a>filedup</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increment ref count for file f.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filedup</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;filedup&quot;</span>);</span><br><span class="line">  f-&gt;ref++;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fileclose"><a href="#fileclose" class="headerlink" title="fileclose"></a>fileclose</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;fileclose&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ff = *f;</span><br><span class="line">  f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">  f-&gt;type = FD_NONE;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line">    pipeclose(ff.pipe, ff.writable);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line">    begin_op();</span><br><span class="line">    iput(ff.ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="filestat"><a href="#filestat" class="headerlink" title="filestat"></a>filestat</h4><blockquote>
<p>Filestat只允许在inode上操作并且调用了<code>stati</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅允许文件/设备执行</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fileread"><a href="#fileread" class="headerlink" title="fileread"></a>fileread</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read from file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 首先检查是否可读</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>((r = readi(f-&gt;ip, <span class="number">1</span>, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 移动文件指针偏移量</span></span><br><span class="line">      f-&gt;off += r;</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    panic(<span class="string">&quot;fileread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-System-calls"><a href="#Code-System-calls" class="headerlink" title="Code: System calls"></a>Code: System calls</h2><blockquote>
<p>通过使用底层提供的函数，大多数系统调用的实现都很简单（请参阅***kernel/sysfile.c***）。有几个调用值得仔细看看。</p>
<p>以下介绍的函数都在<code>kernel/sysfile.c</code>中。</p>
</blockquote>
<h3 id="sys-link"><a href="#sys-link" class="headerlink" title="sys_link"></a>sys_link</h3><p>这个函数的功能是给文件old加上一个链接，这个链接存在于文件new的父目录。感觉也就相当于把文件从old复制到new处了。具体实现逻辑就是要给该文件所在目录添加一个entry，name=新名字，inode=该文件的inode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the path new as a link to the same inode as old.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>, *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, old, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, new, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先先增加nlink</span></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">// 通过path找到ip结点</span></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(old)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="comment">// directory不能被link</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DIR)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;nlink++;</span><br><span class="line">  <span class="comment">// 修改一次字段就需要update一次</span></span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后再在目录中登记新的entry</span></span><br><span class="line">  <span class="comment">// 找到new的parent，也即new所在目录</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(new, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  ilock(dp);</span><br><span class="line">  <span class="comment">// 在目录中添加一个entry，名字为给定的新名字，inode依旧为原来的inode</span></span><br><span class="line">  <span class="comment">// new的父目录必须存在并且与现有inode位于同一设备上</span></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  iput(ip);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;nlink--;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><blockquote>
<p>它是三个文件创建系统调用的泛化：带有<code>O_CREATE</code>标志的<code>open</code>生成一个新的普通文件，<code>mkdir</code>生成一个新目录，<code>mkdev</code>生成一个新的设备文件。</p>
</blockquote>
<p>创建一个新的inode结点，结点名包含在<code>path</code>内。返回一个<strong>锁定的</strong>inode。</p>
<p>由于使用了<code>iupdate</code>等，所以该函数只能在事务中被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">create</span><span class="params">(<span class="type">char</span> *path, <span class="type">short</span> type, <span class="type">short</span> major, <span class="type">short</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">dp</span>;</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取结点父目录</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(path, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ilock(dp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 说明文件已存在</span></span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))</span><br><span class="line">      <span class="comment">// 说明此时caller为open（type == T_FILE），open调用create只能是用于创建文件</span></span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;create: ialloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;major = major;</span><br><span class="line">  ip-&gt;minor = minor;</span><br><span class="line">  ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type == T_DIR)&#123;  <span class="comment">// Create . and .. entries.</span></span><br><span class="line">    dp-&gt;nlink++;  <span class="comment">// for &quot;..&quot;</span></span><br><span class="line">    iupdate(dp);</span><br><span class="line">    <span class="comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span></span><br><span class="line">    <span class="comment">// 所以其实.和..本质上是link</span></span><br><span class="line">    <span class="keyword">if</span>(dirlink(ip, <span class="string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="number">0</span> || dirlink(ip, <span class="string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;create dots&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;create: dirlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">  iunlockput(dp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-mkdir"><a href="#sys-mkdir" class="headerlink" title="sys_mkdir"></a>sys_mkdir</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, path, MAXPATH) &lt; <span class="number">0</span> || (ip = create(path, T_DIR, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-open"><a href="#sys-open" class="headerlink" title="sys_open"></a>sys_open</h3><blockquote>
<p><code>Sys_open</code>是最复杂的，因为创建一个新文件只是它能做的一小部分。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> fd, omode;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;omode) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建失败</span></span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 文件不存在</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create返回一个锁定的inode，但namei不锁定，因此sys_open必须锁定inode本身。</span></span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="comment">// 非文件，为目录并且非只读</span></span><br><span class="line">    <span class="comment">// 所以说想要open一个目录的话只能以只读模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取file结构体和文件描述符。</span></span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">      fileclose(f);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有其他进程可以访问部分初始化的文件，因为它仅位于当前进程的表中，因而这里可以不用上锁</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class="line">    f-&gt;type = FD_DEVICE;</span><br><span class="line">    f-&gt;major = ip-&gt;major;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    f-&gt;type = FD_INODE;</span><br><span class="line">    f-&gt;off = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;ip = ip;</span><br><span class="line">  f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class="line">  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果使用了这个标志,调用 open 函数打开文件的时候会将文件原本的内容全部丢弃,文件大小变为 0。</span></span><br><span class="line">  <span class="keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;</span><br><span class="line">    itrunc(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-pipe"><a href="#sys-pipe" class="headerlink" title="sys_pipe"></a>sys_pipe</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fdarray; <span class="comment">// user pointer to array of two integers用来接收pipe两端的文件描述符</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">rf</span>, *<span class="title">wf</span>;</span></span><br><span class="line">  <span class="type">int</span> fd0, fd1;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;fdarray) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(pipealloc(&amp;rf, &amp;wf) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  fd0 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>((fd0 = fdalloc(rf)) &lt; <span class="number">0</span> || (fd1 = fdalloc(wf)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd0 &gt;= <span class="number">0</span>)</span><br><span class="line">      p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line">    fileclose(rf);</span><br><span class="line">    fileclose(wf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, fdarray, (<span class="type">char</span>*)&amp;fd0, <span class="keyword">sizeof</span>(fd0)) &lt; <span class="number">0</span> ||</span><br><span class="line">     copyout(p-&gt;pagetable, fdarray+<span class="keyword">sizeof</span>(fd0), (<span class="type">char</span> *)&amp;fd1, <span class="keyword">sizeof</span>(fd1)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line">    p-&gt;ofile[fd1] = <span class="number">0</span>;</span><br><span class="line">    fileclose(rf);</span><br><span class="line">    fileclose(wf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>实际操作系统中的buffer cache比xv6复杂得多，但它有两个相同的用途：缓存和同步对磁盘的访问。</p>
<p>与UNIX V6一样，Xv6的buffer cache使用简单的最近最少使用（LRU）替换策略；有许多更复杂的策略可以实现，每种策略都适用于某些工作场景，而不适用于其他工作场景。更高效的LRU缓存将消除链表，而改为使用哈希表进行查找，并使用堆进行LRU替换【跟我们在lock中实现的一样，再多个堆优化】。现代buffer cache通常与虚拟内存系统集成，以支持内存映射文件。</p>
<p>Xv6的日志系统效率低下。提交不能与文件系统调用同时发生。系统记录整个块，即使一个块中只有几个字节被更改。它执行同步日志写入，每次写入一个块，每个块可能需要整个磁盘旋转时间。真正的日志系统解决了所有这些问题。</p>
<p>文件系统布局中最低效的部分是目录，它要求在每次查找期间对所有磁盘块进行线性扫描【确实】。当目录只有几个磁盘块时，这是合理的，但对于包含许多文件的目录来说，开销巨大。Microsoft Windows的NTFS、Mac OS X的HFS和Solaris的ZFS（仅举几例）将目录实现为磁盘上块的平衡树。这很复杂，但可以保证目录查找在对数时间内完成（即时间复杂度为O(logn)）。</p>
<p>Xv6对于磁盘故障的解决很初级：如果磁盘操作失败，Xv6就会调用<code>panic</code>。这是否合理取决于硬件：如果操作系统位于使用冗余屏蔽磁盘故障的特殊硬件之上，那么操作系统可能很少看到故障，因此<code>panic</code>是可以的。另一方面，使用普通磁盘的操作系统应该预料到会出现故障，并能更优雅地处理它们，这样一个文件中的块丢失不会影响文件系统其余部分的使用。</p>
<p>Xv6要求文件系统安装在单个磁盘设备上，且大小不变。随着大型数据库和多媒体文件对存储的要求越来越高，操作系统正在开发各种方法来消除“每个文件系统一个磁盘”的瓶颈。基本方法是将<strong>多个物理磁盘组合成一个逻辑磁盘</strong>。RAID等硬件解决方案仍然是最流行的，但当前的趋势是在软件中尽可能多地实现这种逻辑。这些软件实现通常<strong>允许通过动态添加或删除磁盘来扩展或缩小逻辑设备</strong>等丰富功能。当然，一个能够动态增长或收缩的存储层需要一个能够做到这一点的文件系统：xv6使用的固定大小的inode块阵列在这样的环境中无法正常工作。<strong>将磁盘管理与文件系统分离可能是最干净的设计</strong>，但两者之间复杂的接口导致了一些系统（如Sun的ZFS）将它们结合起来。</p>
<p>Xv6的文件系统缺少现代文件系统的许多其他功能；例如，它缺乏对快照和增量备份的支持。</p>
<p>现代Unix系统允许使用与磁盘存储相同的系统调用访问多种资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口，如<code>/proc</code>。不同于xv6中<code>fileread</code>和<code>filewrite</code>的<code>if</code>语句，这些系统通常为每个打开的文件提供一个<strong>函数指针表</strong>【确实有印象】，每个操作一个，并通过函数指针来援引inode的调用实现。网络文件系统和用户级文件系统提供了将这些调用转换为网络RPC并在返回之前等待响应的函数。</p>
<p>（注：Linux 内核提供了一种通过<code>/proc</code>文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。）</p>
</blockquote>
<h2 id="Lab-file-system"><a href="#Lab-file-system" class="headerlink" title="Lab: file system"></a>Lab: file system</h2><blockquote>
<p>In this lab you will add large files【大文件支持】 and symbolic links【软链接】 to the xv6 file system.</p>
<p>不过做完这个实验，给我的一种感觉就是磁盘管理和内存管理真的有很多相似之处，不过也许它们所代表的思想也很普遍。</p>
</blockquote>
<h3 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h3><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><h5 id="Overview-3"><a href="#Overview-3" class="headerlink" title="Overview"></a>Overview</h5><blockquote>
<p>In this assignment you’ll increase the maximum size of an xv6 file. </p>
<p>Currently xv6 files are limited to 268 blocks, or 268*BSIZE bytes (BSIZE is 1024 in xv6). This limit comes from the fact that an xv6 inode contains 12 “direct” block numbers and one “singly-indirect” block number, which refers to a block that holds up to 256 more block numbers, for a total of 12+256=268 blocks.</p>
<p>You’ll change the xv6 file system code to support a <strong>“doubly-indirect” block</strong> in each inode, containing 256 addresses of singly-indirect blocks, each of which can contain up to 256 addresses of data blocks. The result will be that a file will be able to consist of up to 65803 blocks, or 256*256+256+11 blocks (11 instead of 12, because <strong>we will sacrifice one of the direct block numbers for the double-indirect block</strong>).</p>
</blockquote>
<h5 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h5><blockquote>
<p>If at any point during the lab you find yourself having to rebuild the file system from scratch, you can run <code>make clean</code> which forces make to rebuild fs.img.</p>
</blockquote>
<h5 id="What-to-Look-At"><a href="#What-to-Look-At" class="headerlink" title="What to Look At"></a>What to Look At</h5><p>意思就是要我们去看一眼fs.h，bmap，以及了解一下逻辑地址bn如何转化为blockno。这个我是知道的。</p>
<h5 id="Your-Job"><a href="#Your-Job" class="headerlink" title="Your Job"></a>Your Job</h5><blockquote>
<p>Modify <code>bmap()</code> so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. </p>
<p>You’ll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you’re not allowed to change the size of an on-disk inode. </p>
<p>The first 11 elements of <code>ip-&gt;addrs[]</code> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when <code>bigfile</code> writes 65803 blocks and <code>usertests</code> runs successfully.</p>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>意外地很简单（）在此不多做赘述，直接上代码。</p>
<p>唯一要注意的一点就是记得在<code>itrunc</code>中free掉</p>
<p><img src="/2023/01/10/xv6/image-20230124232433793.png" alt="image-20230124232433793"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="修改定义"><a href="#修改定义" class="headerlink" title="修改定义"></a>修改定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in fs.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDOUBLEINDIRECT ((BSIZE/sizeof(uint))*(BSIZE/sizeof(uint)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NDOUBLEINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="修改bmap"><a href="#修改bmap" class="headerlink" title="修改bmap()"></a>修改bmap()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in fs.c</span></span><br><span class="line"><span class="comment">// 调试用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// CODE HERE</span></span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDOUBLEINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// 调试用</span></span><br><span class="line">    <span class="keyword">if</span>(bn/<span class="number">10000</span> &gt; cnt)&#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;double_indirect:%d\n&quot;</span>,bn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一层</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="comment">// 第二层</span></span><br><span class="line">    bp = bread(ip-&gt;dev,addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[(bn &gt;&gt; <span class="number">8</span>)]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[(bn &gt;&gt; <span class="number">8</span>)] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="comment">// 第三层</span></span><br><span class="line">    bp = bread(ip-&gt;dev,addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[(bn &amp; <span class="number">0x00FF</span>)]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[(bn &amp; <span class="number">0x00FF</span>)] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改itrunc"><a href="#修改itrunc" class="headerlink" title="修改itrunc"></a>修改itrunc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents).</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CODE HERE</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="number">1</span>])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="comment">// 双层循环。这里其实不应该用NINDIRECT这个宏定义的，因为意义其实不大一样。</span></span><br><span class="line">    <span class="comment">// 但是由于数值一样，这里就先凑合着用了</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">tmp_bp</span> =</span> bread(ip-&gt;dev,a[j]);</span><br><span class="line">        uint* tmp_a = (uint*)tmp_bp-&gt;data;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; NINDIRECT; k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(tmp_a[k])</span><br><span class="line">            bfree(ip-&gt;dev,tmp_a[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(tmp_bp);</span><br><span class="line">        bfree(ip-&gt;dev,a[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h3><blockquote>
<p>In this exercise you will add symbolic links to xv6. </p>
<p>Symbolic links (or <strong>soft links</strong>) refer to a linked file by pathname; when a symbolic link is opened, the kernel follows the link to the referred file. </p>
<p>Symbolic links resembles hard links, <u>but hard links are restricted to pointing to file on the same disk</u>, while symbolic links can cross disk devices. </p>
<p>Although xv6 doesn’t support multiple devices, implementing this system call is a good exercise to understand how pathname lookup works.</p>
<p>You will implement the <code>symlink(char *target, char *path)</code> system call, which creates a new symbolic link at path that refers to file named by target. For further information, see the man page symlink. To test, add symlinktest to the Makefile and run it. </p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40179091/article/details/125306898">linux：硬链接和软链接</a></p>
<p>硬链接不会创建新的物理文件，但是会使得当前物理文件的引用数加1。当硬链接产生的文件存在时，删除源文件，不会清除实际的物理文件，即对于硬链接“生成的新文件”不会产生任何影响。</p>
<p>软链接就更像一个指针，只是指向实际物理文件位置，当源文件移动或者删除时，软链接就会失效。</p>
<p>【所以说，意思就是软链接不会让inode-&gt;ulinks++的意思？】</p>
</blockquote>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><p>这个实验比上个实验稍难一些，但也确实只是moderate的水平，其复杂程度主要来源于对文件系统的理解，还有如何判断环，以及对锁的获取和释放的应用。我做这个实验居然是没看提示的【非常骄傲&lt;-】，让我有一种自己水平上升了的感觉hhh</p>
<h5 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h5><p>本实验要求实现软链接。首先需要实现创建软链接：写一个系统调用 <code>symlink(char *target, char *path)</code> 用于创建一个指向target的在path的软链接；然后需要实现打开软链接进行自动的跳转：在<code>sys_open</code>中添加对文件类型为软链接的特殊处理。</p>
<h5 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h5><p>我的初见思路是觉得可以完全参照<code>sys_link</code>来写。但其实还是很不一样的。</p>
<p><code>sys_link</code>的逻辑：</p>
<ol>
<li>获取old的inode</li>
<li>获取new所在目录的inode，称为dp</li>
<li>在dp中添加一项entry指向old</li>
</ol>
<p><code>sys_symlink</code>的逻辑：</p>
<ol>
<li><p>通过path创建一个新的inode，作为软链接的文件</p>
<p>这里选择新建inode，而不是像link那样做，主要还是为了能遵从<code>symlinktest</code>给的接口使用方法（朴实无华的理由）。而且这么做也很方便，符合“一切皆文件”的思想，也能简单化对其在<code>open</code>中的处理。</p>
</li>
<li><p>在inode中填入target的地址</p>
<p>我们可以把软链接视为文件，文件内容是其target的path。</p>
</li>
</ol>
<p>可以说是毫不相干，所以还是直接自起炉灶比较好。</p>
<h5 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h5><p>其实没什么好说的，虽然debug过程挺久，但是靠常规的printf追踪就都可以看出来是哪里错了。下面我说说一个我印象比较深刻的吧。</p>
<p><code>symlinktest</code>中有一个检测点是，软链接不能成环，也即b-&gt;a-&gt;b是非法的。于是，我就选择了用快慢指针来检测环形链表这个思想，用来看是否出现环。</p>
<p>在<code>symlinktest</code>的另一个检测点中：</p>
<p><img src="/2023/01/10/xv6/image-20230125173143735.png" alt="image-20230125173143735"></p>
<p>我出现了如下错误：</p>
<p><img src="/2023/01/10/xv6/image-20230125162542807.png" alt="image-20230125162542807"></p>
<p>此时的结构是1[27]-&gt;2[28]-&gt;3[29]-&gt;4，[]内为inode的inum。</p>
<p>快慢指针的实现方式是当cnt为奇数的时候，慢指针才会移动。而上图中，cnt==0时，两个指针的值都发生了变化，这就非常诡异。</p>
<p>这其实是因为slow指针所指向的那个inode被释放了，然后又被fast指针的下一个inode捡过来用了，从而导致值覆盖。</p>
<p>为什么会被释放呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 快指针移动</span></span><br><span class="line">      readi(ip,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 在这里！！！</span></span><br><span class="line">      ilockput(ip);</span><br></pre></td></tr></table></figure>

<p>在这里，我错误地调用了<code>ilockput</code>，从而使inode的ref–，使得它在下一次fast指针调用<code>namei</code>，<code>namei</code>调用<code>iget</code>时，该inode被当做free inode使用，于是就这么寄了。</p>
<p>所以我们需要把<code>ilockput</code>的调用换成<code>ilock</code>，这样一来就能防止inode被free。至于什么时候再iput？我想还是交给操作系统启动时的清理工作来做吧23333【开摆】</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p><img src="/2023/01/10/xv6/image-20230125165612112.png" alt="image-20230125165612112"></p>
<h5 id="添加定义"><a href="#添加定义" class="headerlink" title="添加定义"></a>添加定义</h5><h6 id="fcntl-c"><a href="#fcntl-c" class="headerlink" title="fcntl.c"></a>fcntl.c</h6><p>open参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 意为只用获取软链接文件本身，而不用顺着软链接去找它的target文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_NOFOLLOW 0x100</span></span><br></pre></td></tr></table></figure>

<h6 id="stat-h"><a href="#stat-h" class="headerlink" title="stat.h"></a>stat.h</h6><p>文件类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYMLINK  4   <span class="comment">// symbol links</span></span></span><br></pre></td></tr></table></figure>

<h5 id="添加sys-symlink系统调用"><a href="#添加sys-symlink系统调用" class="headerlink" title="添加sys_symlink系统调用"></a>添加sys_symlink系统调用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in sysfile.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建软链接结点</span></span><br><span class="line">  ip = create(path,T_SYMLINK,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//printf(&quot;symlink:before writei,inum = %d\n&quot;,ip-&gt;inum);</span></span><br><span class="line">  <span class="comment">// 此处可以防止住一些并发错误</span></span><br><span class="line">  <span class="keyword">if</span>(ip ==<span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向软链接结点文件内写入其所指向的路径</span></span><br><span class="line">  writei(ip,<span class="number">0</span>,(uint64)target,<span class="number">0</span>,MAXPATH);</span><br><span class="line">  <span class="comment">//printf(&quot;symlink:after writei\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 软链接不需要让nlink++</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 记得要释放在create()中申请的锁</span></span><br><span class="line">  iunlockput(ip);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改open"><a href="#修改open" class="headerlink" title="修改open"></a>修改open</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 软链接不可能是以O_CREATE的形式创建的</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改从这里开始</span></span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="comment">// ip为快指针，slow为慢指针</span></span><br><span class="line">    uint cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">slow</span> =</span> ip;</span><br><span class="line">    <span class="comment">// 可能有多重链接，因而需要持续跳转</span></span><br><span class="line">    <span class="keyword">while</span>(ip-&gt;type == T_SYMLINK)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;slow = %d,fast = %d,cnt = %d\n&quot;,slow-&gt;inum,ip-&gt;inum,cnt);</span></span><br><span class="line">      <span class="comment">// 其实这个只需要检测一次就够了。但为了编码方便，仍然把它保留在while循环中</span></span><br><span class="line">      <span class="keyword">if</span>(omode &amp; O_NOFOLLOW)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 检测到cycle</span></span><br><span class="line">        <span class="keyword">if</span>(slow == ip &amp;&amp; cnt!=<span class="number">0</span>)&#123;</span><br><span class="line">          iunlockput(ip);</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快指针移动</span></span><br><span class="line">        readi(ip,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">        <span class="comment">// 此处不能用iunlockput()，具体原因见 感想-一些错误</span></span><br><span class="line">        iunlock(ip);</span><br><span class="line">        <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ilock(ip);</span><br><span class="line">        <span class="comment">// 慢指针移动</span></span><br><span class="line">        <span class="comment">// 注意，我慢指针移动的时候没有锁保护，因为用锁太麻烦了（）其实还是用锁比较合适</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="comment">//printf(&quot;%d\n&quot;,cnt);</span></span><br><span class="line">          readi(slow,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">          <span class="keyword">if</span>((slow = namei(path) )== <span class="number">0</span>)&#123;</span><br><span class="line">            end_op();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当跳出循环时，此时的ip必定是锁住的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab-mmap"><a href="#Lab-mmap" class="headerlink" title="Lab mmap"></a>Lab mmap</h2><blockquote>
<p>The <code>mmap</code> and <code>munmap</code> system calls allow UNIX programs to exert detailed control over their address spaces. </p>
<p>They can be used to:</p>
<ol>
<li>share memory among processes</li>
<li>map files into process address spaces</li>
<li>as part of user-level page fault schemes such as the garbage-collection algorithms discussed in lecture. </li>
</ol>
<p>In this lab you’ll add <code>mmap</code> and <code>munmap</code> to xv6, <strong>focusing on memory-mapped files</strong>.</p>
<p>mmap是系统调用，在用户态被使用。我们这次实验仅实现mmap功能的子集，也即memory-mapped files。</p>
</blockquote>
<blockquote>
<p>declaration for <code>mmap</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">     <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>参数</p>
<ol>
<li><p><code>addr</code> is always zero.</p>
<p>You can assume that <code>addr</code> will always be zero, meaning that the kernel should decide the <strong>virtual address</strong> at which to map the file.【<code>addr</code>由kernel决定，因而用户态只需传入0即可】</p>
</li>
<li><p><code>length</code> is the number of bytes to map</p>
<p>Might not be the same as the file’s length.</p>
</li>
<li><p><code>prot</code> indicates whether the memory should be mapped readable, writeable, and/or executable.</p>
<p>you can assume that <code>prot</code> is <code>PROT_READ</code> or <code>PROT_WRITE</code> or both. </p>
</li>
<li><p><code>flags</code> has two values.</p>
<ol>
<li><p><code>MAP_SHARED</code></p>
<p>meaning that modifications to the mapped memory <strong>should be written back to the file</strong>, </p>
<p>如果标记为此，则当且仅当file本身权限为RW或者WRITABLE的时候，prot才可以标记为PROT_WRITE</p>
</li>
<li><p><code>MAP_PRIVATE</code></p>
<p>meaning that they should not. </p>
<p>如果标记为此，则无论file本身权限如何，prot都可以标记为PROT_WRITE</p>
</li>
</ol>
</li>
<li><p>You can assume <code>offset</code> is zero (it’s the starting point in the file at which to map)</p>
</li>
</ol>
</li>
<li><p>return</p>
<p><code>mmap</code> returns that kernel-decided address, or 0xffffffffffffffff if it fails.</p>
</li>
</ol>
<p>如果两个进程同时对某个文件进行memory map，那么这两个进程可以不共享物理页面。</p>
</blockquote>
<blockquote>
<p><code>munmap(addr, length)</code> should remove mmap mappings in the indicated address range. </p>
<p>If the process has modified the memory and has it mapped <code>MAP_SHARED</code>, <strong>the modifications should first be written to the file</strong>. 【如果两个进程的修改发生冲突了怎么办？】</p>
<p>An <code>munmap</code> call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region).</p>
</blockquote>
<h3 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h3><p>这个实验做得我……怎么说，感觉非常地难受吧。虽然我认为我这次做得挺不错的，因为我没有怎么看hints，我的代码差不多全都是我自己想出来的，没有依赖保姆级教学，我认为是一个很好的进步。不过，正因为我没有看hints，导致我的想法比起答案来思路非常地奇诡，导致我第一次错误想法写了一天，看了hints后决心痛改前非，结果第二次错误想法又写了一天emmm</p>
<p>下面的第一个代码版本虽然可以过掉mmaptest，但<strong>确实还是有一个很致命的bug</strong>，并且<strong>lazy也没有lazy到位</strong>，最后的版本离正确思路还有偏差，<strong>也就是下面放的第一个代码版本是错误的，</strong>但我认为它也不是完全没有亮点。第二个版本才是经过改正的正确版本，但写得着实有点潦草。</p>
<p>笔记整理得也有点匆忙，毕竟我真的话比较多而且心里很烦。总之，先记录我的全部思路过程，至于价值如何，先不管了2333</p>
<h4 id="初见思路-1"><a href="#初见思路-1" class="headerlink" title="初见思路"></a>初见思路</h4><p>所以说，我们要做的，就是实现一个系统调用mmap，在mmap中，应该首先申请几页用来放file的内容，并且在页表中填入该项，然后再返回该项的虚拟地址。然后在munmap中，再将该file页内容写入file。</p>
<p>也就是说，直接在mmap把文件的全部内容写入内存，然后各进程读写自己的那块内容块，最后在munmap的时候把修改内容写入文件然后释放该内存块就行了</p>
<h5 id="问题：在哪里放置file的内容"><a href="#问题：在哪里放置file的内容" class="headerlink" title="问题：在哪里放置file的内容"></a>问题：在哪里放置file的内容</h5><p>题目要求<code>the kernel should decide the **virtual address** at which to map the file.</code>也就是说，在我们的<code>mmap</code>中，需要决定我们要讲文件内容放在哪里。那要放在哪呢……</p>
<p>我第一反应很奇葩：扫描页表，找到空闲页。但我自己也知道这样不可行，文件内容不止一页，这种零零散散存储需要的数据结构实现起来太麻烦了。</p>
<p>那怎么办？可以在heap内分配。那么到底怎么样才能在heap里分配？你该怎么知道heap哪里开始是空闲的，哪里是用过的，不还是得扫描页表吗？【思维大僵化】</p>
<p>其实……道理很简单。我们之间把<code>proc-&gt;sz</code>作为mapped-file的起始地址就好了。相信看到这里，你也明白这是什么原理了。能想到这个，我感觉确实很不容易。</p>
<h4 id="正确思路-1"><a href="#正确思路-1" class="headerlink" title="正确思路"></a>正确思路</h4><p>初见思路虽然简单，但是很粗暴，如果文件很大，宝贵的内存空间就会被我们浪费。所以我们借用lazy allocation的思想，先建立memory-file的映射，再在缺页中断中通过文件读写申请内存空间，把文件内容读入内存。</p>
<p>问题就在于如何“先建立memory-file的映射”。在lazy allocation中，我们是先填好所有的对应页表项，仅是不申请对应的物理内存，也即占着XX不XX。在这次实验中，我们也是这么做，只不过新增了一个难点，那就是<strong>如何管理这些页</strong>。因为lazy allocation页与页之间没有比较紧密的关系，但是在mmap中页却可以被所属文件这个关键字划分。因而，我们需要一个数据结构，来给页分门别类地组织在一起，并且记录它们的meta data比如说所属文件之类的，这也就是hints里的VMA结构，也即我的filemap结构。</p>
<p>我们可以将这样的数据结构池化，并且存储在proc域中，以避免对象的重复创建。</p>
<blockquote>
<p>我的lazy法与别人不大一样……我没有想得像他们那么完美。我的做法是，在需要读某个地址的文件内容时，直接确保这个地址前面的所有文件内容都读了进来。也即在filemap中维护一个okva，表明va<del>okva这段内存已经读入，之后就仅需再读入okva</del>need_va这段地址就行。这样虽然lazy了，但没完全lazy。</p>
<p>我认为这不能体现lazy的思想……因为一读读一坨，还是很占空间啊。</p>
</blockquote>
<p>因而，我们需要做的就是：</p>
<ol>
<li><p>在mmap中将信息填入该数据结构</p>
<ol>
<li>依据传入的长度扩容proc，原sz作为mapped-file起始地址va</li>
<li>从对象池中寻找到一个空闲的filemap，对其填写信息</li>
<li>返回1所得的va</li>
</ol>
<p>在我的代码中，还针对proc-&gt;sz不满足page-align做出了对策：先把文件的<code>PGROUNDUP(sz)-sz</code>这部分的信息读入，并且更新okva，这样一来，之后在usertrap中，就可以从okva开始一页页地分配地址，做到自然地page-align了。</p>
<blockquote>
<p>为什么要对不满足page-align的情况进行处理？</p>
<p>这是因为，growproc的时候一次性扩充一页，但proc-&gt;sz却可以不满足page-align，也就是说，proc-&gt;sz所处的这一页已经被分配了。</p>
<p>在我们的lazy思路中，我们如果不预先读入文件页，是只能等待用户陷入缺页中断的情况下才能读入文件内容。</p>
<p>但是，proc-&gt;sz这一页已经被分配了。因而，在用户态读取这一页地址的时候，<strong>并不会发生缺页中断</strong>。因而，就会发生文件内容未读入，用户读到脏数据的情况。</p>
<p>其实还有一种更简单的办法可以强制page-align，那就是，直接让起始地址为<code>PGROUNDUP(proc-&gt;sz)</code>……至于为什么我不用这个，而要写这么多麻烦的东西呢？答案是我没想到。（）</p>
</blockquote>
</li>
<li><p>在usertrap增加对缺页中断的处理</p>
<ol>
<li>依据va找到对应filemap</li>
<li>根据对应filemap的信息，使用<code>readi</code>（正确）<code>fileread</code>（错误）读取文件内容并存入物理内存</li>
</ol>
</li>
<li><p>在munmap中进行释放</p>
<ol>
<li>根据标记写入文件页，并且释放对应物理内存</li>
<li>修改filemap结构的参数，并且在其失效的时候放回对象池</li>
</ol>
</li>
<li><p>修改fork和exit</p>
<ol>
<li><p>exit</p>
<p>手动释放map-file域</p>
<blockquote>
<p>为什么不能把这些合并到<code>wait</code>中调用的<code>freepagetable</code>进行释放呢？</p>
<p>因为<code>freepagetable</code>只会释放对应的物理页，没有达到<code>munmap</code>减少文件引用等功能。</p>
</blockquote>
</li>
<li><p>fork</p>
<p>手动复制filemap池</p>
</li>
</ol>
</li>
</ol>
<h4 id="我的错误思路们"><a href="#我的错误思路们" class="headerlink" title="我的错误思路们"></a>我的错误思路们</h4><h5 id="第一次错误思路"><a href="#第一次错误思路" class="headerlink" title="第一次错误思路"></a>第一次错误思路</h5><p>上面说到：</p>
<blockquote>
<p>问题就在于如何“先建立memory-file的映射”。在lazy allocation中，我们是先填好所有的对应页表项，仅是不申请对应的物理内存，也即占着XX不XX。在这次实验中，我们也是这么做，只不过新增了一个难点，那就是<strong>如何管理这些页</strong>。因为lazy allocation页与页之间没有比较紧密的关系，但是在mmap中页却可以被所属文件这个关键字划分。因而，我们需要一个数据结构，来给页分门别类地组织在一起，并且记录它们的meta data比如说所属文件之类的，这也就是hints里的VMA结构，也即我的filemap结构。</p>
</blockquote>
<p>官方给出的答案是在proc域里的pool。我……额……是把这些信息，存入在页中（真是自找麻烦呀）</p>
<p>具体来说，就是，我在<code>mmap</code>的时候给每个文件申请一页，然后在页的开头填上和filemap结构相差无几的那些参数，再加上一个next指针，表示下一个文件页的地址。页的剩下部分就用来存储数据。总的就是一个链表结构。</p>
<p>这个思路其实很不错，比起上面的直接在proc内存的尾巴扩容，这个空间利用率应该更大，并且不仅能节省物理内存，还能节省虚拟地址空间，实现了lazy上加lazy。</p>
<p>但问题是……我<strong>为什么非要傻瓜式操纵内存，在页的开头填入参数数据</strong>，而不是把这种页抽象为一个个node，最终形成一个十字链表的形式（差不多的意思，鱼骨状），组织进proc域，这样不挺好的吗……唔，有时候我头脑昏迷程度让我自己都感到十分震惊。归根结底，还是想得太少就动手了，失策。</p>
<p>总之放上代码。我没有实现next指针，仅假设文件内容不超过一页。也就是这一页开头在mmap中填meta data，其余部分在usertrap中填入文件内容。【这个分开的点也让我迷惑至极……】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERRORADDR 0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="keyword">struct</span> file* file,uint64 offset)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">// 获取va,也即真正的address</span></span><br><span class="line">    uint64 va = p-&gt;sz;</span><br><span class="line">    <span class="keyword">if</span>(growproc(PGSIZE) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    <span class="type">char</span>* mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 保存信息：file指针、prot（这就是傻瓜式操纵内存的典范）</span></span><br><span class="line">    uint64* pointer = (uint64*)mem;</span><br><span class="line">    *pointer = (uint64)file;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)prot;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)length;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)flags;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)offset;</span><br><span class="line">    pointer++;</span><br><span class="line">    filedup(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(p-&gt;pagetable, va+PGSIZE, PGSIZE, (uint64)mem, PTE_M|PTE_X|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return start of free memory</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)(va + (uint64)pointer - (uint64)mem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64* pa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, (uint64)address, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span> ||(*pte &amp; PTE_M) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// the start is where the params save</span></span><br><span class="line">    pa = (uint64*)(PGROUNDDOWN(PTE2PA(*pte)));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span> =</span> (<span class="keyword">struct</span> file*)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> prot = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> flags = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flags == MAP_SHARED&amp;&amp;(prot&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 需要更新写内容</span></span><br><span class="line">        filewrite(file,(uint64)address,length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后释放内存</span></span><br><span class="line">    uvmunmap(p-&gt;pagetable, PGROUNDDOWN((uint64)address), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64* pa;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span> ||(*pte &amp; PTE_M) == <span class="number">0</span>)</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the start is where the params save</span></span><br><span class="line">    pa = (uint64*)(PGROUNDDOWN(PTE2PA(*pte)));</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span> =</span> (<span class="keyword">struct</span> file*)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> prot = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">size_t</span> length = (<span class="type">size_t</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((prot&amp;PROT_READ) != <span class="number">0</span>)&#123;</span><br><span class="line">      fileread(file,va,length);</span><br><span class="line">      flags |= PTE_R;</span><br><span class="line">      <span class="keyword">if</span>((prot&amp;PROT_WRITE) != <span class="number">0</span>)    flags |= PTE_W;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)     p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      *pte = ((*pte) | flags);</span><br><span class="line">    &#125; <span class="keyword">else</span>  p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="为什么下面的代码是错的"><a href="#为什么下面的代码是错的" class="headerlink" title="为什么下面的代码是错的"></a>为什么下面的代码是错的</h5><p>正如开头所说的那样，我并没有完美做好这次实验，下面代码有一个致命的bug。</p>
<p>先说说致命bug是什么。</p>
<p>我的filemap结构体其实隐藏了两个具有“offset”这一含义的状态。一个是filemap里面的成员变量offset，另一个是filemap里面的成员变量file的成员变量off：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">filemap</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span><span class="comment">//文件</span></span><br><span class="line">  uint64 offset;<span class="comment">//va相对于file开头的offset</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// in file.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在我的代码里，它们被赋予了不同的含义。</p>
<p><code>filemap-&gt;file-&gt;off</code>被用于<code>trap.c</code>中，表示的是当前未读入文件内容的起始位置（实际上也就是<code>okva-va</code>的值），用于自然地使用<code>fileread</code>进行文件读入。</p>
<blockquote>
<p>比如说，这次读入PGSIZE，那么off就会在<code>fileread</code>中自增PGSIZE。下次调用<code>fileread</code>就可以直接从下一个位置读入了，这样使代码更加简洁</p>
</blockquote>
<p><code>filemap-&gt;offset</code>被用于<code>munmap</code>中。<code>filewrite</code>同<code>fileread</code>一样，都是从<code>file-&gt;off</code>处开始取数据。<code>munmap</code>所需要取数据的起始位置和<code>trap.c</code>中需要取数据的起始位置肯定不一样，</p>
<blockquote>
<p>想想它们的功能。<code>trap.c</code>的off需要始终指向有效内存段的末尾，但<code>munmap</code>由于要对特定内存段进行写入文件操作，因而off要求可以随机指向。</p>
</blockquote>
<p>因而，我们可以将当前va对应的文件位置记录在offset中。届时，我们只需要从<code>p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va</code>取数据就行。</p>
<p>上述两个变量相辅相成，看上去似乎能够完美无缺地实现我们的功能。但是，实际上，不行。为什么呢？因为它们的file指针，<code>filemap-&gt;file</code>，如果被两个mmap区域同时使用的话，就会出问题。</p>
<p>可以来看看<code>mmaptest.c</code>中的这一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  makefile(f);</span><br><span class="line">  <span class="keyword">if</span> ((fd = open(f, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">  unlink(f);</span><br><span class="line">  <span class="type">char</span> *p1 = mmap(<span class="number">0</span>, PGSIZE*<span class="number">2</span>, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">  <span class="type">char</span> *p2 = mmap(<span class="number">0</span>, PGSIZE*<span class="number">2</span>, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// read just 2nd page.</span></span><br><span class="line">  <span class="keyword">if</span>(*(p1+PGSIZE) != <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    err(<span class="string">&quot;fork mismatch (1)&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    err(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// v1是用来触发缺页中断的函数</span></span><br><span class="line">    _v1(p1);</span><br><span class="line">    munmap(p1, PGSIZE); <span class="comment">// just the first page</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// tell the parent that the mapping looks OK.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> status = <span class="number">-1</span>;</span><br><span class="line">  wait(&amp;status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(status != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork_test failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check that the parent&#x27;s mappings are still there.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;before v1,p1 = %d\n&quot;</span>,(uint64)p1);</span><br><span class="line">  _v1(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;after v1,p1 = %d\n&quot;</span>,(uint64)p1);</span><br><span class="line">  _v1(p2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fork_test OK\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">fork_test starting</span></span><br><span class="line"><span class="comment">trap:map a page at 53248,okva = 53248</span></span><br><span class="line"><span class="comment">trap:mem[0]=65,off = 4096,size = 6144</span></span><br><span class="line"><span class="comment">trap:map a page at 57344,okva = 53248</span></span><br><span class="line"><span class="comment">trap:mem[0]=65,off = 6144,size = 6144</span></span><br><span class="line"><span class="comment">before v1,p1 = 53248</span></span><br><span class="line"><span class="comment">after v1,p1 = 53248</span></span><br><span class="line"><span class="comment">trap:map a page at 61440,okva = 61440</span></span><br><span class="line"><span class="comment">trap:mem[0]=0,off = 6144,size = 6144</span></span><br><span class="line"><span class="comment">mismatch at 0, wanted &#x27;A&#x27;, got 0x0</span></span><br><span class="line"><span class="comment">mmaptest: fork_test failed: v1 mismatch (1), pid=3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in trap.c</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap:map a page at %d,okva = %d\n&quot;</span>,start_va,p-&gt;filemaps[i].okva);</span><br><span class="line"></span><br><span class="line">fileread(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap:mem[0]=%d,off = %d,size = %d\n&quot;</span>,</span><br><span class="line">       mem[<span class="number">0</span>],p-&gt;filemaps[i].file-&gt;off,p-&gt;filemaps[i].file-&gt;ip-&gt;size);</span><br></pre></td></tr></table></figure>

<p>这段代码因为共用fd，导致file指针被两个mmap区域同时使用。</p>
<blockquote>
<p>共用fd，为什么file指针也一起共用了？</p>
<p>可以追踪一下它们的生命周期：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in sys_open()</span></span><br><span class="line"><span class="comment">// 获取file结构体和文件描述符。</span></span><br><span class="line"><span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in sysfile.c</span></span><br><span class="line"><span class="comment">// Allocate a file descriptor for the given file.</span></span><br><span class="line"><span class="comment">// Takes over file reference from caller on success.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fdalloc</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line">   p-&gt;ofile[fd] = f;</span><br><span class="line">   <span class="keyword">return</span> fd;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它实际上是有一个文件描述符表，key为fd，value为file指针。因而，同一张表，fd相同，file指针相同。</p>
<p>注：父子进程，同样的fd，file指针也是相同的</p>
<p><strong>fork出来的父子进程同一个句柄对同一个文件的偏移量是相同的</strong>，这个原理应该是因为，父子进程共享的是文件句柄这个结构体对象本身，也就是拷贝的时候是浅拷贝而不是深拷贝。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in fork()</span></span><br><span class="line"><span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">   np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后的<code>check that the parent&#39;s mappings are still there.</code>环节中，<code>_v1(p1)</code>执行时并没有陷入trap，这是正常的。不正常的是<code>_v1(p2)</code>的执行结果。它陷入了trap，但是却因<code>file-&gt;off == file size</code>，导致被判定为已全部读入文件，事实上却是并没有读入文件。</p>
<p>为什么会这样呢？</p>
<p>这是因为p1和p2共用同一个fd，也就共用了同一个file指针。共用了一个file指针，那么p1和p2面对的<code>file-&gt;off</code>相同。上面说到，<code>file-&gt;off</code>用于控制文件映射。那么，当p1完成了对文件的映射，p1的off指针如果不加重置，就会永远停留在file size处。这样一来，当p2想要使用同样的file指针进行文件映射时，就会出问题。</p>
<p>这个问题的一个解决方法是每次<code>mmap</code>都深拷贝一个船新file结构体。但是这样的话，<code>file</code>域里的<code>ref</code>变量就失去了它的意义，并且file对象池应该也很快就会爆满，非常不符合设计方案。</p>
<p>这个问题的完美解，是不要赋予<code>file-&gt;off</code>这个意义，而是使用<code>readi</code>替代<code>fileread</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileread(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span><br><span class="line">readi(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span><br></pre></td></tr></table></figure>

<p>这样做的好处是，我们可以实时计算offset（前面提到，其恰恰等于okva-va），而不用把这个东西用file的off来表示。</p>
<blockquote>
<p>也确实，我之所以弯弯绕绕那么曲折，是因为只想到了<code>fileread</code>这个函数，压根没注意到还有一个<code>readi</code>……</p>
</blockquote>
<p>我在下面的代码仅做了一个能够通过测试，但是上面的<strong>bug依然存在</strong>的功利性折中代码。我是这么实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在`mmap`的时候初始化`file-&gt;off`</span></span><br><span class="line">p-&gt;filemaps[i].file-&gt;off = offset;</span><br><span class="line"><span class="comment">// 在`munmap`的时候清零`file-&gt;off`</span></span><br><span class="line">p-&gt;filemaps[i].file-&gt;off = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>因而，结论是，一步错步步错，一个错误需要更多的错误来弥补，最后还是错的（悲）</p>
<h5 id="如何把下面的错误思路改成正确思路"><a href="#如何把下面的错误思路改成正确思路" class="headerlink" title="如何把下面的错误思路改成正确思路"></a>如何把下面的错误思路改成正确思路</h5><p>可以做以下几点：</p>
<ol>
<li><p>正确地lazy</p>
<p>每次trap仅分配一页。</p>
</li>
<li><p>改用readi函数，修改<code>file-&gt;off</code>的语义</p>
</li>
</ol>
<p>这样一来，大概就可以完美地正确了。</p>
<h4 id="其他的一些小细节"><a href="#其他的一些小细节" class="headerlink" title="其他的一些小细节"></a>其他的一些小细节</h4><h5 id="file指针的生命周期"><a href="#file指针的生命周期" class="headerlink" title="file指针的生命周期"></a>file指针的生命周期</h5><p>在数据结构中存储file指针至关重要。但仔细想一想，file指针的生命周期似乎长到过分：从sys_mmap被调用，一直到usertrap处理缺页中断，最后到munmap释放，我们要求file指针的值需要保持稳定不变。</p>
<p>这么长的生命周期，它真的可以做到吗？毕竟file指针归根到底只是一个局部变量，在syscall mmap结束之后，它还有效吗？答案是有效的，这个有效性由<code>mmap</code>实现中对ref的增加来实现保障。</p>
<p>在用户态中关闭一个文件，需要使用syscall<code>close(int fd)</code>。不妨来看看<code>close</code>的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/sysfile.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argfd(<span class="number">0</span>, &amp;fd, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 一个进程打开的文件都会放入一个以fd为index的文件表里，</span></span><br><span class="line"><span class="comment">// 在xv6中，这个文件表便是`myproc()-&gt;ofile`。</span></span><br><span class="line"><span class="comment">// 可以看到，关闭一个文件首先需要把它移出文件表</span></span><br><span class="line">myproc()-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 对file指针关闭的主要操作</span></span><br><span class="line">fileclose(f);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in kernel/file.c</span></span><br><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;ftable.lock);</span><br><span class="line"><span class="comment">// 若ref数&lt;0，就会直接return</span></span><br><span class="line"><span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> release(&amp;ftable.lock);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放file</span></span><br><span class="line"><span class="comment">// close不会显式地释放file指针，只会释放file指针所指向的文件，让file指针失效。</span></span><br><span class="line">ff = *f;</span><br><span class="line">f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">f-&gt;type = FD_NONE;</span><br><span class="line">release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line"> pipeclose(ff.pipe, ff.writable);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line"> begin_op();</span><br><span class="line"> iput(ff.ip);</span><br><span class="line"> end_op();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当ref数&gt;1时，file指针就不会失效。</p>
<p>这就是为什么我们还需要在mmap中让file的ref数++。</p>
<h5 id="缺页中断蕴含的设计思想"><a href="#缺页中断蕴含的设计思想" class="headerlink" title="缺页中断蕴含的设计思想"></a>缺页中断蕴含的设计思想</h5><p>如果只存入file指针，用户态要如何对对应的文件进行读写呢？</p>
<p>我们可以自然想到也许需要设计一个函数，让用户在想要对这块内存读写的时候调用这个函数即可。但是，这样的方法使得用户对内存不能自然地读写，还需要使用我们新设计的这个函数，这显然十分地不美观。所以，我们需要找到一个方法，让上层的用户可以<strong>统一</strong>地读取任何的内存块，包括memory-mapped file内存块，而<strong>隐藏</strong>memory-mapped file与其他内存块读写方式不同的这些复杂细节。经历过前面几次实验的你看到这里一定能想到，有一个更加优美更加符合设计规范的方法，那就是：<strong>缺页中断</strong>！</p>
<blockquote>
<p>没做这个实验之前就知道mmap需要借助缺页中断来实现了，但实际自己的第一印象是觉得并不需要缺页中断，直到分析到这里才恍然大悟。</p>
<p>“让上层的用户可以<strong>统一</strong>地读取任何的内存块，而<strong>隐藏</strong>不同类型的内存块读写方式不同的这些复杂细节”</p>
<p>仔细想想，前面几个关于缺页中断的实验，比如说cow fork，lazy allocation，事实上都是基于这个思想。它们并不是不能与缺页中断分离，只是有了缺页中断，它们的实现更加简洁，更加优美。</p>
<p>再次感慨os的博大精深。小小一个缺页中断，原理那么简单，居然集中了这么多设计思想，不禁叹服。</p>
</blockquote>
<h5 id="正确答案的munmap中如果遇到未映射的页怎么办"><a href="#正确答案的munmap中如果遇到未映射的页怎么办" class="headerlink" title="正确答案的munmap中如果遇到未映射的页怎么办"></a>正确答案的munmap中如果遇到未映射的页怎么办</h5><p>在正确答案的munmap中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line"><span class="keyword">while</span>(start_va &lt; bounder)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">    <span class="comment">//写回</span></span><br><span class="line">    filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">  &#125;</span><br><span class="line">  uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">  start_va += PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果map类型为<code>MAP_SHARED</code>，并且该页尚未映射，会怎么样呢？</p>
<p>追踪filewrite的路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file.c</span></span><br><span class="line">	  begin_op();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line"><span class="comment">// in fs.c</span></span><br><span class="line">    <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line"><span class="comment">// in vm.c copyin()</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><code>copyin</code>最终会在<code>    if(pa0 == 0)  return -1;</code>这里终结，但<code>writei</code>并不会在接收到-1的时候爆出panic或者是引发缺页中断，而只会把它当做文件结尾，默默地返回。</p>
<p>并且，在<code>munmap</code>中是一页一页地释放，而不是直接传参length全部释放，这一点也很重要。因为我们的lazy allocation很可能导致<code>va~va+length</code>这一区间内只是部分页被映射，部分页没有。如果直接传参length释放，那么在遇到第一页未被映射的时候，<code>filewrite</code>就会终止，该页之后的页就没有被写回文件的机会了。</p>
<p>所以结论是，在正确实现的<code>munmap</code>中遇到未映射的页会自动跳过，什么也不会发生。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in param.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFILEMAP 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">filemap</span>&#123;</span></span><br><span class="line">  uint isused;<span class="comment">//对象池思想。该filemap是否正在被使用</span></span><br><span class="line">  uint64 va;<span class="comment">//该文件的起始内存页地址</span></span><br><span class="line">  uint64 okva;<span class="comment">//该文件的起始未被读入部分对应的内存地址</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span><span class="comment">//文件</span></span><br><span class="line">  <span class="type">size_t</span> length;<span class="comment">//需要映射到内存的长度</span></span><br><span class="line">  <span class="type">int</span> flags;<span class="comment">//MAP_SHARED OR MAP_PRIVATE</span></span><br><span class="line">  <span class="type">int</span> prot;<span class="comment">//PROT_READ OR PROT_WRITE</span></span><br><span class="line">  uint64 offset;<span class="comment">//va相对于file开头的offset</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">filemap</span> <span class="title">filemaps</span>[<span class="title">NFILEMAP</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>具体系统调用注册过程略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length,prot,flags,offset;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>,&amp;length) &lt; <span class="number">0</span> || argint(<span class="number">2</span>,&amp;prot) &lt; <span class="number">0</span> || argint(<span class="number">3</span>,&amp;flags) &lt; <span class="number">0</span> || argfd(<span class="number">4</span>,<span class="number">0</span>,&amp;file) ||argint(<span class="number">5</span>,&amp;offset) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> (uint64)mmap((<span class="type">void</span>*)addr,(<span class="type">size_t</span>)length,prot,flags,file,(uint)offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERRORADDR 0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射file从offset开始长度为length的内容到内存中，返回内存中的文件内容起始地址</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="keyword">struct</span> file* file,uint64 offset)</span>&#123;</span><br><span class="line">    <span class="comment">// mmap的prot权限必须与file的权限对应，不能file只读但是mmap却可写且shared</span></span><br><span class="line">    <span class="keyword">if</span>((prot&amp;PROT_WRITE) != <span class="number">0</span>&amp;&amp;flags == MAP_SHARED &amp;&amp;file-&gt;writable == <span class="number">0</span>)       </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到filemap池中第一个空闲的filemap</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!p-&gt;filemaps[i].isused)&#123;</span><br><span class="line">        <span class="comment">// 获取va,也即真正的address</span></span><br><span class="line">        va = p-&gt;sz;</span><br><span class="line">        p-&gt;sz += length;</span><br><span class="line">        <span class="comment">// 其实这里用一个memcpy会更加优雅，可惜我忘记了（）</span></span><br><span class="line">        p-&gt;filemaps[i].isused = <span class="number">1</span>;</span><br><span class="line">        p-&gt;filemaps[i].va = va;</span><br><span class="line">        p-&gt;filemaps[i].okva = va;</span><br><span class="line">        p-&gt;filemaps[i].length = length;</span><br><span class="line">        p-&gt;filemaps[i].prot = prot;</span><br><span class="line">        p-&gt;filemaps[i].flags = flags;</span><br><span class="line">        p-&gt;filemaps[i].file = file;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = offset;</span><br><span class="line">        p-&gt;filemaps[i].offset = offset;</span><br><span class="line">        <span class="comment">// 增加文件引用数</span></span><br><span class="line">        filedup(file);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(va == <span class="number">0</span>)  <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    <span class="comment">// return start of free memory</span></span><br><span class="line">    uint64 start_va = PGROUNDUP(va);</span><br><span class="line">    <span class="comment">// 先读入处于proc已申请的内存页区域（也即没有内存对齐情况下）</span></span><br><span class="line">    uint64 off = start_va - va;</span><br><span class="line">    <span class="keyword">if</span>(off &lt; PGSIZE)&#123;</span><br><span class="line">        fileread(file,va,off);</span><br><span class="line">        file-&gt;off += off;</span><br><span class="line">        p-&gt;filemaps[i].okva = va+off;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)va;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h4><h5 id="错的"><a href="#错的" class="headerlink" title="错的"></a>错的</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">   uint64 va = r_stval();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">       <span class="comment">// 找到va对应的filemap</span></span><br><span class="line">     <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;va&gt;=p-&gt;filemaps[i].va </span><br><span class="line">        &amp;&amp; va&lt;p-&gt;filemaps[i].va+p-&gt;filemaps[i].length)&#123;</span><br><span class="line">       <span class="comment">// 说明本来就不应该写</span></span><br><span class="line">       <span class="keyword">if</span>(r_scause() == <span class="number">15</span> &amp;&amp; ((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) == <span class="number">0</span>)&#123;</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//说明地址不在文件范围内</span></span><br><span class="line">       <span class="keyword">if</span>(p-&gt;filemaps[i].va+p-&gt;filemaps[i].file-&gt;ip-&gt;size &lt;= va)&#123;</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 能进到这里来的都是产生了缺页中断，也就是说va对应文件数据不存在</span></span><br><span class="line">       <span class="comment">// 我们需要维护一个okva，表示从filemaps.va到okva这段地址已经加载了文件</span></span><br><span class="line">       <span class="comment">// 这样一来，我们这里就只需加载okva~va地址对应的文件了</span></span><br><span class="line">       <span class="comment">// file结构体自带的off成员会由于fileread而自动增长到对应位置，所以文件可以自然地读写</span></span><br><span class="line">       uint64 start_va = p-&gt;filemaps[i].okva;<span class="comment">// okva一定是page-align的</span></span><br><span class="line">       <span class="comment">// 加载文件内容</span></span><br><span class="line">       <span class="keyword">while</span>(start_va &lt;= va)&#123;</span><br><span class="line">         <span class="type">char</span>* mem = kalloc();</span><br><span class="line">         <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">           p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">         <span class="type">int</span> flag = PTE_X|PTE_R|PTE_U;</span><br><span class="line">         <span class="keyword">if</span>(((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">           flag |= PTE_W;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(mappages(p-&gt;pagetable, start_va, PGSIZE, (uint64)mem, flag) != <span class="number">0</span>)&#123;</span><br><span class="line">           p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">           kfree(mem);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 读入文件内容</span></span><br><span class="line">         fileread(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">         start_va += PGSIZE;</span><br><span class="line">       &#125;</span><br><span class="line">       p-&gt;filemaps[i].okva = start_va;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="对的"><a href="#对的" class="headerlink" title="对的"></a>对的</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;va&gt;=p-&gt;filemaps[i].va &amp;&amp; va&lt;p-&gt;filemaps[i].va+p-&gt;filemaps[i].length)&#123;</span><br><span class="line">      <span class="keyword">if</span>(r_scause() == <span class="number">15</span> &amp;&amp; ((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 说明本来就不应该写</span></span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].va+p-&gt;filemaps[i].file-&gt;ip-&gt;size &lt;= va)&#123;</span><br><span class="line">        <span class="comment">//说明地址不在文件范围内</span></span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      uint64 start_va = PGROUNDDOWN(va);</span><br><span class="line">        <span class="type">char</span>* mem = kalloc();</span><br><span class="line">        <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="type">int</span> flag = PTE_X|PTE_R|PTE_U;</span><br><span class="line">        <span class="keyword">if</span>(((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">         flag |= PTE_W;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable, start_va, PGSIZE, (uint64)mem, flag) != <span class="number">0</span>)&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">          kfree(mem);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readi(p-&gt;filemaps[i].file-&gt;ip,<span class="number">0</span>,(uint64)mem,va-p-&gt;filemaps[i].va+p-&gt;filemaps[i].offset,PGSIZE);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h4><h5 id="错的-1"><a href="#错的-1" class="headerlink" title="错的"></a>错的</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">min</span><span class="params">(uint64 a,uint64 b)</span>&#123;<span class="keyword">return</span> a&gt;b?b:a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放文件映射以address为起始地址，length为长度这个范围内的内存地址空间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = (uint64)address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到对应的filemap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;p-&gt;filemaps[i].va&lt;=va&amp;&amp;p-&gt;filemaps[i].va+length&gt;va)&#123;</span><br><span class="line">        <span class="comment">// 开始释放的内存地址</span></span><br><span class="line">        uint64 start_va;</span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)</span><br><span class="line">            start_va = PGROUNDUP(p-&gt;filemaps[i].va);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start_va = PGROUNDDOWN(va);</span><br><span class="line">        <span class="comment">// 结束释放的内存地址</span></span><br><span class="line">        uint64 bounder = p-&gt;filemaps[i].va + min(p-&gt;filemaps[i].file-&gt;ip-&gt;size,length);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//file的off在trap中用于表示文件已加载的位置</span></span><br><span class="line">        <span class="comment">//在这里需要用off进行filewrite，所以需要对原本在usertrap用于记录加载位置的off进行手动保存</span></span><br><span class="line">        uint64 tmp_off = p-&gt;filemaps[i].file-&gt;off;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line">        <span class="keyword">while</span>(start_va &lt; bounder &amp;&amp; start_va &lt; p-&gt;filemaps[i].okva)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">            <span class="comment">//写回</span></span><br><span class="line">            filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">          &#125;</span><br><span class="line">          uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">          start_va += PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改filemap结构体的起始地址va和长度，offset也要变，因为他记录va对应的是文件哪个位置</span></span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)&#123;</span><br><span class="line">          <span class="comment">//释放的是头几页</span></span><br><span class="line">          p-&gt;filemaps[i].offset += length;</span><br><span class="line">          p-&gt;filemaps[i].va = va+length;</span><br><span class="line">          p-&gt;filemaps[i].length -= length;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//释放的是尾几页</span></span><br><span class="line">          p-&gt;filemaps[i].length -= p-&gt;filemaps[i].length - va;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = tmp_off;</span><br><span class="line">        <span class="comment">// 检验map的合理性</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;filemaps[i].length == <span class="number">0</span> || p-&gt;filemaps[i].va &gt;= p-&gt;filemaps[i].va+length</span><br><span class="line">                        || p-&gt;filemaps[i].file-&gt;off &gt; p-&gt;filemaps[i].file-&gt;ip-&gt;size)&#123;</span><br><span class="line">          p-&gt;filemaps[i].isused = <span class="number">0</span>;<span class="comment">//释放</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 注意！！！！这句话对我的错误代码来说非常重要</span></span><br><span class="line">          p-&gt;filemaps[i].file-&gt;off = <span class="number">0</span>;</span><br><span class="line">          fileclose(p-&gt;filemaps[i].file);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对的-1"><a href="#对的-1" class="headerlink" title="对的"></a>对的</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">min</span><span class="params">(uint64 a,uint64 b)</span>&#123;<span class="keyword">return</span> a&gt;b?b:a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = (uint64)address;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;p-&gt;filemaps[i].va&lt;=va&amp;&amp;p-&gt;filemaps[i].va+length&gt;va)&#123;</span><br><span class="line">        uint64 start_va;</span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)</span><br><span class="line">                start_va = PGROUNDUP(p-&gt;filemaps[i].va);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                start_va = PGROUNDDOWN(va);</span><br><span class="line">        uint64 bounder = p-&gt;filemaps[i].va + min(p-&gt;filemaps[i].file-&gt;ip-&gt;size,length);</span><br><span class="line">        <span class="comment">//在这里需要用off进行读写，所以需要对原本的加载处off手动保存</span></span><br><span class="line">        uint64 tmp_off = p-&gt;filemaps[i].file-&gt;off;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line">        <span class="keyword">while</span>(start_va &lt; bounder)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">            <span class="comment">//写回</span></span><br><span class="line">            filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">          &#125;</span><br><span class="line">          uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">          start_va += PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改filemap结构体的起始地址va和长度，offset也要变，因为他记录va对应的是文件哪个位置</span></span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)&#123;</span><br><span class="line">          <span class="comment">//释放的是头几页</span></span><br><span class="line">          p-&gt;filemaps[i].offset += length;</span><br><span class="line">          p-&gt;filemaps[i].va = va+length;</span><br><span class="line">          p-&gt;filemaps[i].length -= length;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//释放的是尾几页</span></span><br><span class="line">          p-&gt;filemaps[i].length -= p-&gt;filemaps[i].length - va;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检验map的合理性</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;filemaps[i].length == <span class="number">0</span> || p-&gt;filemaps[i].va &gt;= p-&gt;filemaps[i].va+length</span><br><span class="line">                        || p-&gt;filemaps[i].file-&gt;off &gt; p-&gt;filemaps[i].file-&gt;ip-&gt;size)&#123;</span><br><span class="line">          p-&gt;filemaps[i].isused = <span class="number">0</span>;<span class="comment">//释放</span></span><br><span class="line">          fileclose(p-&gt;filemaps[i].file);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = tmp_off;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exit和fork"><a href="#exit和fork" class="headerlink" title="exit和fork"></a>exit和fork</h4><h5 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭map-file</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;filemaps[i].isused)&#123;</span><br><span class="line">    munmap((<span class="type">void</span>*)(p-&gt;filemaps[i].va),p-&gt;filemaps[i].length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">  np-&gt;filemaps[i].isused = p-&gt;filemaps[i].isused;</span><br><span class="line">  np-&gt;filemaps[i].va = p-&gt;filemaps[i].va;</span><br><span class="line">  np-&gt;filemaps[i].okva = p-&gt;filemaps[i].okva;</span><br><span class="line">  np-&gt;filemaps[i].file = p-&gt;filemaps[i].file;</span><br><span class="line">  np-&gt;filemaps[i].length = p-&gt;filemaps[i].length;</span><br><span class="line">  np-&gt;filemaps[i].flags = p-&gt;filemaps[i].flags;</span><br><span class="line">  np-&gt;filemaps[i].offset = p-&gt;filemaps[i].offset;</span><br><span class="line">  np-&gt;filemaps[i].prot = p-&gt;filemaps[i].prot;</span><br><span class="line">  <span class="keyword">if</span>(np-&gt;filemaps[i].file)</span><br><span class="line">    filedup(np-&gt;filemaps[i].file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改uvmcopy和uvmunmap"><a href="#修改uvmcopy和uvmunmap" class="headerlink" title="修改uvmcopy和uvmunmap"></a>修改uvmcopy和uvmunmap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in uvmunmap()</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      *pte = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// in uvmcopy()</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

		<div>
		  
			<div>
    
        <div style="text-align:center;color: #f7cdcd;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
		  
		</div>

      <footer class="post-footer">

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#File-system"><span class="nav-number">1.</span> <span class="nav-text">File system</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Overview"><span class="nav-number">1.1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-cache"><span class="nav-number">1.2.</span> <span class="nav-text">Buffer cache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">数据结构定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.3.</span> <span class="nav-text">上层接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bread"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">bread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bwrite"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">bwrite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#brelse"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">brelse</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82"><span class="nav-number">1.2.4.</span> <span class="nav-text">具体细节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bget"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">bget</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Logging-layer"><span class="nav-number">1.3.</span> <span class="nav-text">Logging layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Log-design"><span class="nav-number">1.3.2.</span> <span class="nav-text">Log design</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code-logging"><span class="nav-number">1.3.3.</span> <span class="nav-text">Code: logging</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">关键函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#begin-op"><span class="nav-number">1.3.3.2.1.</span> <span class="nav-text">begin_op()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#log-write"><span class="nav-number">1.3.3.2.2.</span> <span class="nav-text">log_write</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#end-op"><span class="nav-number">1.3.3.2.3.</span> <span class="nav-text">end_op</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#commit"><span class="nav-number">1.3.3.2.4.</span> <span class="nav-text">commit</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#write-log"><span class="nav-number">1.3.3.2.4.1.</span> <span class="nav-text">write_log</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#write-head"><span class="nav-number">1.3.3.2.4.2.</span> <span class="nav-text">write_head</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#install-trans"><span class="nav-number">1.3.3.2.4.3.</span> <span class="nav-text">install_trans</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">恢复与初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E4%B9%8B%E5%89%8D"><span class="nav-number">1.3.3.3.1.</span> <span class="nav-text">第一个进程运行之前</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fsinit"><span class="nav-number">1.3.3.3.2.</span> <span class="nav-text">fsinit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#initlog"><span class="nav-number">1.3.3.3.3.</span> <span class="nav-text">initlog</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#recover-from-log"><span class="nav-number">1.3.3.3.4.</span> <span class="nav-text">recover_from_log</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Block-allocator"><span class="nav-number">1.4.</span> <span class="nav-text">Code: Block allocator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3"><span class="nav-number">1.4.1.</span> <span class="nav-text">个人理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitmap"><span class="nav-number">1.4.2.</span> <span class="nav-text">bitmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#allocator"><span class="nav-number">1.4.3.</span> <span class="nav-text">allocator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#balloc"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">balloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bfree"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">bfree</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inode-layer"><span class="nav-number">1.5.</span> <span class="nav-text">Inode layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#inode"><span class="nav-number">1.5.1.</span> <span class="nav-text">inode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#on-disk-inode"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">on-disk inode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#in-memory-inode"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">in-memory inode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code-inode"><span class="nav-number">1.5.2.</span> <span class="nav-text">Code: inode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Overview-1"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">底层接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#iget"><span class="nav-number">1.5.2.2.1.</span> <span class="nav-text">iget</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iput"><span class="nav-number">1.5.2.2.2.</span> <span class="nav-text">iput</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E5%B1%82%E6%8E%A5%E5%8F%A3-1"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">上层接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BEinode"><span class="nav-number">1.5.2.3.1.</span> <span class="nav-text">获取和释放inode</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ialloc"><span class="nav-number">1.5.2.3.1.1.</span> <span class="nav-text">ialloc</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#inode%E7%9A%84%E9%94%81%E4%BF%9D%E6%8A%A4"><span class="nav-number">1.5.2.3.2.</span> <span class="nav-text">inode的锁保护</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ilock"><span class="nav-number">1.5.2.3.2.1.</span> <span class="nav-text">ilock</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#iunlock"><span class="nav-number">1.5.2.3.2.2.</span> <span class="nav-text">iunlock</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code-inode-content"><span class="nav-number">1.5.3.</span> <span class="nav-text">Code: inode content</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Overview-2"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bmap"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">bmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#itrunc"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">itrunc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readi"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">readi</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writei"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">writei</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stati"><span class="nav-number">1.5.3.6.</span> <span class="nav-text">stati</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Directory-layer"><span class="nav-number">1.6.</span> <span class="nav-text">Directory layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">1.6.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.2.</span> <span class="nav-text">相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dirlookup"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">dirlookup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dirlink"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">dirlink</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pathname-layer"><span class="nav-number">1.7.</span> <span class="nav-text">Pathname layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#namei%E5%92%8Cnameiparent"><span class="nav-number">1.7.1.</span> <span class="nav-text">namei和nameiparent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#namex"><span class="nav-number">1.7.2.</span> <span class="nav-text">namex</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File-descriptor-layer"><span class="nav-number">1.8.</span> <span class="nav-text">File descriptor layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="nav-number">1.8.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ftable"><span class="nav-number">1.8.2.</span> <span class="nav-text">ftable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#filealloc"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">filealloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filedup"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">filedup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fileclose"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">fileclose</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filestat"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">filestat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fileread"><span class="nav-number">1.8.2.5.</span> <span class="nav-text">fileread</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-System-calls"><span class="nav-number">1.9.</span> <span class="nav-text">Code: System calls</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-link"><span class="nav-number">1.9.1.</span> <span class="nav-text">sys_link</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#create"><span class="nav-number">1.9.2.</span> <span class="nav-text">create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-mkdir"><span class="nav-number">1.9.3.</span> <span class="nav-text">sys_mkdir</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-open"><span class="nav-number">1.9.4.</span> <span class="nav-text">sys_open</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-pipe"><span class="nav-number">1.9.5.</span> <span class="nav-text">sys_pipe</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world"><span class="nav-number">1.10.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-file-system"><span class="nav-number">1.11.</span> <span class="nav-text">Lab: file system</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Large-files"><span class="nav-number">1.11.1.</span> <span class="nav-text">Large files</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">实验内容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Overview-3"><span class="nav-number">1.11.1.1.1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Preliminaries"><span class="nav-number">1.11.1.1.2.</span> <span class="nav-text">Preliminaries</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#What-to-Look-At"><span class="nav-number">1.11.1.1.3.</span> <span class="nav-text">What to Look At</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Your-Job"><span class="nav-number">1.11.1.1.4.</span> <span class="nav-text">Your Job</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">1.11.1.3.1.</span> <span class="nav-text">修改定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9bmap"><span class="nav-number">1.11.1.3.2.</span> <span class="nav-text">修改bmap()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9itrunc"><span class="nav-number">1.11.1.3.3.</span> <span class="nav-text">修改itrunc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbolic-links"><span class="nav-number">1.11.2.</span> <span class="nav-text">Symbolic links</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-1"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF"><span class="nav-number">1.11.2.1.1.</span> <span class="nav-text">正确思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E8%A7%81%E6%80%9D%E8%B7%AF"><span class="nav-number">1.11.2.1.2.</span> <span class="nav-text">初见思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF"><span class="nav-number">1.11.2.1.3.</span> <span class="nav-text">一些错误</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%AE%9A%E4%B9%89"><span class="nav-number">1.11.2.2.1.</span> <span class="nav-text">添加定义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#fcntl-c"><span class="nav-number">1.11.2.2.1.1.</span> <span class="nav-text">fcntl.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#stat-h"><span class="nav-number">1.11.2.2.1.2.</span> <span class="nav-text">stat.h</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0sys-symlink%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.11.2.2.2.</span> <span class="nav-text">添加sys_symlink系统调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9open"><span class="nav-number">1.11.2.2.3.</span> <span class="nav-text">修改open</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-mmap"><span class="nav-number">1.12.</span> <span class="nav-text">Lab mmap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-2"><span class="nav-number">1.12.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E8%A7%81%E6%80%9D%E8%B7%AF-1"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">初见思路</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9C%A8%E5%93%AA%E9%87%8C%E6%94%BE%E7%BD%AEfile%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">1.12.1.1.1.</span> <span class="nav-text">问题：在哪里放置file的内容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF-1"><span class="nav-number">1.12.1.2.</span> <span class="nav-text">正确思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E7%9A%84%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF%E4%BB%AC"><span class="nav-number">1.12.1.3.</span> <span class="nav-text">我的错误思路们</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF"><span class="nav-number">1.12.1.3.1.</span> <span class="nav-text">第一次错误思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E9%94%99%E7%9A%84"><span class="nav-number">1.12.1.3.2.</span> <span class="nav-text">为什么下面的代码是错的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%8B%E9%9D%A2%E7%9A%84%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF%E6%94%B9%E6%88%90%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF"><span class="nav-number">1.12.1.3.3.</span> <span class="nav-text">如何把下面的错误思路改成正确思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%BB%86%E8%8A%82"><span class="nav-number">1.12.1.4.</span> <span class="nav-text">其他的一些小细节</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#file%E6%8C%87%E9%92%88%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.12.1.4.1.</span> <span class="nav-text">file指针的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E8%95%B4%E5%90%AB%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="nav-number">1.12.1.4.2.</span> <span class="nav-text">缺页中断蕴含的设计思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E7%AD%94%E6%A1%88%E7%9A%84munmap%E4%B8%AD%E5%A6%82%E6%9E%9C%E9%81%87%E5%88%B0%E6%9C%AA%E6%98%A0%E5%B0%84%E7%9A%84%E9%A1%B5%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.12.1.4.3.</span> <span class="nav-text">正确答案的munmap中如果遇到未映射的页怎么办</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">1.12.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap"><span class="nav-number">1.12.2.2.</span> <span class="nav-text">mmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#usertrap"><span class="nav-number">1.12.2.3.</span> <span class="nav-text">usertrap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E7%9A%84"><span class="nav-number">1.12.2.3.1.</span> <span class="nav-text">错的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E7%9A%84"><span class="nav-number">1.12.2.3.2.</span> <span class="nav-text">对的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#munmap"><span class="nav-number">1.12.2.4.</span> <span class="nav-text">munmap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E7%9A%84-1"><span class="nav-number">1.12.2.4.1.</span> <span class="nav-text">错的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E7%9A%84-1"><span class="nav-number">1.12.2.4.2.</span> <span class="nav-text">对的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exit%E5%92%8Cfork"><span class="nav-number">1.12.2.5.</span> <span class="nav-text">exit和fork</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#exit"><span class="nav-number">1.12.2.5.1.</span> <span class="nav-text">exit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fork"><span class="nav-number">1.12.2.5.2.</span> <span class="nav-text">fork</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9uvmcopy%E5%92%8Cuvmunmap"><span class="nav-number">1.12.2.6.</span> <span class="nav-text">修改uvmcopy和uvmunmap</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="修年"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">修年</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:nniferyy@gmail.com" title="E-Mail → mailto:nniferyy@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">修年</span>
</div>


<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("10/04/2022 17:38:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  



  <script type="text/javascript" src="/js/clicklove.js"></script>
</body>
</html>
