<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat.png">
  <link rel="mask-icon" href="/images/cat.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiunianjun.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="SchedulingCode: Context switchingxv6中，每个CPU中的scheduler都有一个专用的线程。这里线程的概念是，有自己的栈，有自己的寄存器状态。 当发生时钟中断时，当前进程调用yield，yield再通过swtch切换到scheduler线程。scheduler线程会通过swtch跳转到另外一个进程去执行。当另外一个进程发生时钟中断，又会通过yield回到sche">
<meta property="og:type" content="article">
<meta property="og:title" content="Scheduling">
<meta property="og:url" content="https://xiunianjun.github.io/2023/01/10/xv6$chap7/index.html">
<meta property="og:site_name" content="修年">
<meta property="og:description" content="SchedulingCode: Context switchingxv6中，每个CPU中的scheduler都有一个专用的线程。这里线程的概念是，有自己的栈，有自己的寄存器状态。 当发生时钟中断时，当前进程调用yield，yield再通过swtch切换到scheduler线程。scheduler线程会通过swtch跳转到另外一个进程去执行。当另外一个进程发生时钟中断，又会通过yield回到sche">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230118221757367.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120150659730.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120150715925.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120151051989.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120151353712.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120151807102.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120151820455.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120232149776.png">
<meta property="article:published_time" content="2023-01-10T12:25:29.000Z">
<meta property="article:modified_time" content="2023-08-29T12:01:50.454Z">
<meta property="article:author" content="修年">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230118221757367.png">

<link rel="canonical" href="https://xiunianjun.github.io/2023/01/10/xv6$chap7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Scheduling | 修年</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
	
		<script type="text/javascript" 
		color="244,180,180" opacity='0.5' zIndex="-2" count="80"
		src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
	

  <div class="container use-motion">
    <div class="headband"></div>
<a target="_blank" rel="noopener" href="https://github.com/xiunianjun" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">修年</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiunianjun.github.io/2023/01/10/xv6$chap7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="修年">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修年">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Scheduling
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-10 20:25:29" itemprop="dateCreated datePublished" datetime="2023-01-10T20:25:29+08:00">2023-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-29 20:01:50" itemprop="dateModified" datetime="2023-08-29T20:01:50+08:00">2023-08-29</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><h2 id="Code-Context-switching"><a href="#Code-Context-switching" class="headerlink" title="Code: Context switching"></a>Code: Context switching</h2><p>xv6中，每个CPU中的scheduler都有一个专用的线程。这里线程的概念是，有自己的栈，有自己的寄存器状态。</p>
<p>当发生时钟中断时，当前进程调用yield，yield再通过swtch切换到scheduler线程。scheduler线程会通过swtch跳转到另外一个进程去执行。当另外一个进程发生时钟中断，又会通过yield回到scheduler，scheduler再调度原进程继续执行，如此周而复始。</p>
<blockquote>
<p>Linux的调度原理也差不多类似这样。每个CPU都有一个调度类为SCHED_CLASS_IDLE的IDLE进程，IDLE进程体大概就是间歇不断地执行__schedule()函数，CPU空闲时就会不断执行IDLE线程。</p>
<p>而当有新的任务产生时（或任务被唤醒。可以从此看出task new和task wakeup的共通点，可以联想到竞赛中对该消息的处理方法），它首先通过调度类对应的select_cpu选择一个合适的（可以被抢占&amp;&amp;在该task对应的cpumask中）的cpu，迁移到cpu对应的rq；目标cpu通过IDLE进程体或者中断返回时检查到了NEED_SCHEDULE标记位，从而调用schedule函数pick新任务，然后进行context_switch切换到目标线程。如此周而复始。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230118221757367.png" alt="image-20230118221757367"></p>
<p>下面就来讲讲这个所谓的“线程”以及xv6的上下文切换是怎么实现的。</p>
<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>上下文切换的操作对象是上下文，因而首先了解一下上下文的结构。各种寄存器的状态即是上下文context。xv6中的context定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上下文切换需要修改栈和pc，context中确实有sp寄存器，但是没有pc寄存器，这主要还是因为当swtch返回时，会回到ra所指向的地方，所以仅保存ra就足够了。</p>
<h3 id="swtch"><a href="#swtch" class="headerlink" title="swtch"></a>swtch</h3><p>上下文的切换是通过swtch实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>            <span class="title function_">swtch</span><span class="params">(<span class="keyword">struct</span> context*, <span class="keyword">struct</span> context*)</span>;</span><br></pre></td></tr></table></figure>

<p>swtch会把当前进程的上下文保存在第一个context中，再切换到第二个context保存的上下文，具体实现就是写读保存寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># in kernel/swtch.S</span><br><span class="line"># a0和a1分别保存着两个参数的值，也即第一个context的地址和第二个context的地址</span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        sd s1, 24(a0)</span><br><span class="line">        # ...</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ld s1, 24(a1)</span><br><span class="line">        # ...</span><br><span class="line">        ld 11, 104(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><p>在sleep、yield和wakeup中，都会通过sched中的swtch进入scheduler线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get()) <span class="comment">// 当持有锁时一定为关中断状态</span></span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena;</span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpu中存储着的是scheduler线程的context。因而，这样就可以保存当前进程的context，读取scheduler线程的context，然后转换到scheduler的context执行了。</p>
<blockquote>
<p>可以发现这里是有个很完美的组合技的。由sched()保存context到process结构体中，再由scheduler()读取process对应的context回归到sched()继续执行，我感觉调度设计这点真是帅的一匹。</p>
</blockquote>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过swtch进入scheduler线程后，会继续执行scheduler中swtch的下一个指令，完成下一次调度。</p>
<h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><p>以上是书本的介绍内容。看到这想必会有很多疑惑，至少有以下两点：</p>
<ol>
<li>为什么cpu-&gt;context会存储着scheduler的上下文？这是什么时候，又是怎么初始化的？</li>
<li>为什么从sched中swtch会来到scheduler中swtch的下一句？</li>
</ol>
<p>先从第一点入手。实际上，这个初始化的工作，是在操作系统启动时的<code>main.c</code>中完成的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这之前，创建了第一个进程proc。在这里，每个cpu都调用了scheduler。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个cpu都在scheduler线程的<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context);</code>中，将当前的context，<strong>也即scheduler的context</strong>存入了<code>mycpu()-&gt;context</code>。随后，CPU中的某个去执行下一个进程，其他的就在scheduler线程的<strong>无限循环中等待</strong>，直到有别的进程产生。</p>
<p>去执行进程的CPU通过swtch切换上下文，切到了另一个进程中，此时在swtch中保存的ra是scheduler线程的swtch的下一句（因为scheduler-&gt;swtch也是个函数调用的过程）。会切到另一个进程的sched的下一句【因为它正是从那边swtch过来的】，或者是那个进程开始执行的地方【下面会提到是forkret】。另一个进程通过sched切换回来的时候，就正会切到ra所指向的位置，也即切到scheduler中的swtch后面。</p>
<p>这样一来，两个问题就都得到了解答。</p>
<p><strong>从这，我们也能知道xv6是如何让CPU运转的：scheduler线程是CPU的IDLE状态。无事的时候在scheduler中等待，并且一直监测是否有进程需要执行。有的话，则去执行该进程；该进程又会通过sched切换回scheduler线程，继续等待。这样一来，就完成了进程管理的基本的自动机图像。</strong></p>
<h2 id="Code-Scheduling"><a href="#Code-Scheduling" class="headerlink" title="Code: Scheduling"></a>Code: Scheduling</h2><h3 id="sched前要做的事"><a href="#sched前要做的事" class="headerlink" title="sched前要做的事"></a>sched前要做的事</h3><blockquote>
<p> A process that wants to give up the CPU must do three things:</p>
<ol>
<li>acquire its own process lock p-&gt;lock, release any other locks it is holding</li>
<li>update its own state (p-&gt;state)</li>
<li>call sched</li>
</ol>
<p> <code>yield</code> (kernel/proc.c:515) follows this convention, as do <code>sleep</code> and <code>exit</code>.</p>
<p> <code>sched</code> double-checks those conditions (kernel/proc.c:499-504) and then an implication of those conditions:  since a lock is held, interrupts should be disabled.</p>
</blockquote>
<h3 id="sched与scheduler"><a href="#sched与scheduler" class="headerlink" title="sched与scheduler"></a>sched与scheduler</h3><p>在上面的描述我们可以看到，<code>sched</code>和<code>scheduler</code>联系非常密切，他们俩通过<code>swtch</code>相互切来切去，并且一直都只在这几行切来切去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in scheduler()</span></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// in sched()</span></span><br><span class="line">swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">mycpu()-&gt;intena = intena;</span><br></pre></td></tr></table></figure>

<p>在两个线程之间进行这种样式化切换的过程有时被称为协程（coroutines）。</p>
<blockquote>
<p>存在一种情况使得调度程序对<code>swtch</code>的调用没有以<code>sched</code>结束。一个新进程第一次被调度时，它从<code>forkret</code>（<strong>kernel/proc.c</strong>:527）开始。<code>Forkret</code>是为了释放<code>p-&gt;lock</code>而包装的，要不然，新进程可以从<code>usertrapret</code>开始。</p>
</blockquote>
<h3 id="p-gt-lock保证了并发安全性"><a href="#p-gt-lock保证了并发安全性" class="headerlink" title="p-&gt;lock保证了并发安全性"></a>p-&gt;lock保证了并发安全性</h3><blockquote>
<p>考虑调度代码结构的一种方法是，它为每个进程强制维持一个不变性条件的集合，并在这些不变性条件不成立时持有<code>p-&gt;lock</code>。</p>
<p>其中一个不变性条件是：如果进程是<code>RUNNING</code>状态，计时器中断的<code>yield</code>必须能够安全地从进程中切换出去；这意味着CPU寄存器必须保存进程的寄存器值（即<code>swtch</code>没有将它们移动到<code>context</code>中），并且<code>c-&gt;proc</code>必须指向进程。另一个不变性条件是：如果进程是<code>RUNNABLE</code>状态，空闲CPU的调度程序必须安全地运行它；这意味着<code>p-&gt;context</code>必须保存进程的寄存器（即，它们实际上不在实际寄存器中），没有CPU在进程的内核栈上执行，并且没有CPU的<code>c-&gt;proc</code>引用进程。</p>
<p><u>维护上述不变性条件是xv6经常在一个线程中获取p-&gt;lock并在另一个线程中释放它的原因</u>，在保持<code>p-&gt;lock</code>时，这些属性通常不成立。</p>
<p>例如在<code>yield</code>中获取并在<code>scheduler</code>中释放。一旦<code>yield</code>开始修改一个<code>RUNNING</code>进程的状态为<code>RUNNABLE</code>，锁必须保持被持有状态，直到不变量恢复：最早的正确释放点是<code>scheduler</code>（在其自身栈上运行）清除<code>c-&gt;proc</code>之后。类似地，一旦<code>scheduler</code>开始将<code>RUNNABLE</code>进程转换为<code>RUNNING</code>，在内核线程完全运行之前（在<code>swtch</code>之后，例如在<code>yield</code>中）绝不能释放锁。</p>
<p><code>p-&gt;lock</code>还保护其他东西：<code>exit</code>和<code>wait</code>之间的相互作用，避免丢失<code>wakeup</code>的机制（参见第7.5节），以及避免一个进程退出和其他进程读写其状态之间的争用（例如，<code>exit</code>系统调用查看<code>p-&gt;pid</code>并设置<code>p-&gt;killed</code>(<strong>kernel/proc.c</strong>:611)）。为了清晰起见，也许为了性能起见，有必要考虑一下<code>p-&gt;lock</code>的不同功能是否可以拆分。</p>
</blockquote>
<p>p-&gt;lock在每次scheduler开始的时候获取，swtch到p进程的时候在yield等调用完sched的地方释放。而调用yield时获取的锁，又会在scheduler中释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Give up the CPU for one scheduling round.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);<span class="comment">// 该锁会在scheduler中释放</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  sched();</span><br><span class="line">  release(&amp;p-&gt;lock);<span class="comment">// 该锁释放的是scheduler中得到的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/proc.c scheduler()</span></span><br><span class="line">	  acquire(&amp;p-&gt;lock);<span class="comment">// 该锁会在yield等地被释放</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">      release(&amp;p-&gt;lock);<span class="comment">// 该锁会释放yield等地中获得的锁</span></span><br></pre></td></tr></table></figure>

<p>不得不说，这结构实在是太精妙了。这中间的如此多的复杂过程，就这样成功地被锁保护了起来。</p>
<h2 id="Code-mycpu-and-myproc"><a href="#Code-mycpu-and-myproc" class="headerlink" title="Code: mycpu and myproc"></a>Code: mycpu and myproc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mycpu是通过获取当前cpuid来获取cpu结构的。当前使用的cpuid约定俗成地存在了tp寄存器里。为了让mycpu有效工作，必须确保tp寄存器始终存放的是当前cpu的hartid。</p>
<p>首先是在操作系统初始化的时候要把cpuid存入tp寄存器。RISC-V规定，mhartid也即cpuid的存放点只能在machine mode被读取。因而这项工作得在<code>start.c</code>中完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/start.c </span></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"><span class="comment">// in kernel/riscv.h</span></span><br><span class="line"><span class="comment">// which hart (core) is this?</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_mhartid</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, mhartid&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内核态中，编译器被设置为保证不会以其他方式使用tp寄存器。因而初始化之后，内核态中每个CPU的tp寄存器就始终存放着自己的cpuid。</p>
<p>但这在用户进程是不成立的。因而必须在用户进程进入陷阱的时候做一些工作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># in kernel/trampoline.S uservec</span><br><span class="line">sd tp, 64(a0)</span><br><span class="line"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">ld tp, 32(a0)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须在trampoline保存用户态中使用的tp值，以及内核态中对应的hartid。</p>
<p>最后再在返回用户态的时候恢复用户态的tp值以及更新trampoline的tp值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c usertrapret()</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># in trampoline.S userret</span><br><span class="line">ld tp, 64(a0)</span><br></pre></td></tr></table></figure>

<p>注意，更新trampoline的tp值这一步很重要。因为如果在用户态发生的是时钟中断，就会引起yield，可能造成CPU的切换。这时候就需要在返回用户态的时候修改一下trapframe中的tp为当前CPU的tp。这样一来才能保证，在本次时钟中断结束，以及到下一次时钟中断修改CPU这一期间，trapframe中的tp寄存器以及内核态中的tp寄存器都是正确的。</p>
<p>通过<code>mycpu()</code>获取cpuid其实是非常脆弱的。因为你可能获取完cpuid，进程就被切到别的CPU去执行了，这就会有一个先检查后执行的竞态条件，具有并发安全隐患。因而，xv6要求使用<code>mycpu()</code>返回值的这段代码需要关中断，这样就可以避免时钟中断造成的进程切换了。比如说像<code>myproc()</code>这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the current struct proc *, or zero if none.</span></span><br><span class="line"><span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，不同于<code>mycpu()</code>，使用<code>myproc()</code>的返回值不需要进行开关中断保护。因为当前进程的指针不论处于哪个CPU都是不变的。</p>
<h2 id="Sleep-and-wakeup"><a href="#Sleep-and-wakeup" class="headerlink" title="Sleep and wakeup"></a>Sleep and wakeup</h2><p>前面我们已经介绍了进程隔离性的基本图像，接下来要讲xv6是如何让进程之间互动的。xv6使用的是经典的<em>sleep and wakeup</em>，也叫<em>序列协调（sequence coordination）</em>或<em>条件同步机制（conditional synchronization mechanisms</em>。下面，将从最基本的自旋锁实现信号量开始，来逐步讲解xv6的<em>sleep and wakeup</em>机制。</p>
<h3 id="自旋锁实现信号量"><a href="#自旋锁实现信号量" class="headerlink" title="自旋锁实现信号量"></a>自旋锁实现信号量</h3><p><img src="/2023/01/10/xv6/image-20230120150659730.png" alt="image-20230120150659730"></p>
<p><img src="/2023/01/10/xv6/image-20230120150715925.png" alt="image-20230120150715925"></p>
<p>缺点就是自旋太久了，因而我们需要在等待的时候调用yield，直到资源生产出来之后再继续执行。</p>
<h3 id="不安全的sleep-and-wakeup"><a href="#不安全的sleep-and-wakeup" class="headerlink" title="不安全的sleep and wakeup"></a>不安全的sleep and wakeup</h3><blockquote>
<p>Let’s imagine a pair of calls, sleep and wakeup, that work as follows:</p>
<ol>
<li><p><code>sleep(chan)</code></p>
<p>Sleeps on the arbitrary value chan, called the <em>wait channel</em>. Sleep puts the calling process to sleep, releasing the CPU for other work.  </p>
</li>
<li><p><code>wakeup(chan)</code></p>
<p>Wakes <strong>all</strong> processes sleeping on chan (if any), causing their sleep calls to return. If no processes are waiting on chan, wakeup does nothing.</p>
</li>
</ol>
</blockquote>
<p>这样一来，信号量实现就可修改为这样了：</p>
<p><img src="/2023/01/10/xv6/image-20230120151051989.png" alt="image-20230120151051989"></p>
<p>但是，我们可以注意到，在212-213行这里产生了一个先检查后执行的竞态条件。</p>
<blockquote>
<p>如果消费者进程执行到212-213中间，此时生产者进程已经调用结束，也就是说wakeup并没有唤醒任何消费者进程。消费者进程就会一直在sleep中没人唤醒，除非生产者进程再执行一次。这样就会造成<em>lost wake-up</em> 这个问题。</p>
</blockquote>
<p>所以，我们可以选择把这个竞态条件也放入s-&gt;lock这个锁区域保护。</p>
<p><img src="/2023/01/10/xv6/image-20230120151353712.png" alt="image-20230120151353712"></p>
<p>但是这样一来又会产生死锁问题。因而，我们可以尝试着修改sleep和wakeup的接口定义。</p>
<h3 id="sleep-and-wakeup"><a href="#sleep-and-wakeup" class="headerlink" title="sleep and wakeup"></a>sleep and wakeup</h3><blockquote>
<p>We’ll fix the preceding scheme by changing sleep’s interface: </p>
<p>The caller must pass the <em>condition lock</em> to sleep so it can <strong>release the lock</strong> after the calling process is marked as asleep and waiting on the sleep channel. The lock will force a concurrent V to wait until P has finished putting itself to sleep, so that the wakeup will find the sleeping consumer and wake it up. Once the consumer is awake again sleep <strong>reacquires the lock</strong> before returning. </p>
<p>也即在sleep中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sleep(s,&amp;s-&gt;lock)&#123;</span><br><span class="line"> <span class="comment">// do something</span></span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">	<span class="comment">//wait until wakeup</span></span><br><span class="line"> acquire(&amp;s-&gt;lock);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样一来，信号量就可以完美实现了：</p>
<p><img src="/2023/01/10/xv6/image-20230120151807102.png" alt="image-20230120151807102"></p>
<p><img src="/2023/01/10/xv6/image-20230120151820455.png" alt="image-20230120151820455"></p>
<blockquote>
<p>注：严格地说，<code>wakeup</code>只需跟在<code>acquire</code>之后就足够了（也就是说，可以在<code>release</code>之后调用<code>wakeup</code>）</p>
<p>【想了一下，有一说一确实，放在release前后都不影响】</p>
</blockquote>
<blockquote>
<p>原始Unix内核的<code>sleep</code>只是禁用了中断，这就足够了，因为Unix运行在单CPU系统上。因为xv6在多处理器上运行，所以它为<code>sleep</code>添加了一个显式锁。</p>
</blockquote>
<h2 id="Code-Sleep-and-wakeup"><a href="#Code-Sleep-and-wakeup" class="headerlink" title="Code: Sleep and wakeup"></a>Code: Sleep and wakeup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Atomically release lock and sleep on chan.</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    <span class="comment">// 获取进程锁，释放外部锁</span></span><br><span class="line">    <span class="comment">// 此进程锁将在scheduler线程中释放</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    release(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line">  <span class="comment">// 到这里来，说明已经被wakeup且被调度了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    <span class="comment">//释放进程锁，获取外部锁</span></span><br><span class="line">    <span class="comment">// 此进程锁是在scheduler中获取到的</span></span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    acquire(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果lk为p-&gt;lock，那么<strong>lk依然会在scheduler线程中被暂时释放</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到，关于<code>chan</code>这一变量的取值是非常任意的，仅需取一个约定俗成的值就OK。这里取为了信号量的地址，同时满足了逻辑需求和语义需求。</p>
<blockquote>
<p>Callers of sleep and wakeup can use any mutually convenient number as the channel. Xv6 often uses the address of a kernel data structure involved in the waiting.</p>
</blockquote>
<p>这里也解释了为什么需要while循环</p>
<blockquote>
<p>有时，多个进程在同一个通道上睡眠；例如，多个进程读取同一个管道。一个单独的<code>wakeup</code>调用就能把他们全部唤醒。其中一个将首先运行并获取与<code>sleep</code>一同调用的锁，并且（在管道例子中）读取在管道中等待的任何数据。尽管被唤醒，其他进程将发现没有要读取的数据。从他们的角度来看，醒来是“虚假的”，他们必须再次睡眠。因此，在检查条件的循环中总是调用<code>sleep</code>。</p>
</blockquote>
<h2 id="Code-Pipes"><a href="#Code-Pipes" class="headerlink" title="Code: Pipes"></a>Code: Pipes</h2><p>pipes很显然就是生产者消费者模式的一个例证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">  uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">  uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">  <span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">  <span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">piperead</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="comment">//DOC: pipe-empty并且依然有进程在写</span></span><br><span class="line">    <span class="keyword">if</span>(pr-&gt;killed)&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待直到pipe不为空</span></span><br><span class="line">    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="comment">//DOC: piperead-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">//DOC: piperead-copy</span></span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];</span><br><span class="line">    <span class="keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒写入管道的进程</span></span><br><span class="line">  wakeup(&amp;pi-&gt;nwrite);  <span class="comment">//DOC: piperead-wakeup</span></span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipewrite</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123;  <span class="comment">//DOC: pipewrite-full管道满则阻塞</span></span><br><span class="line">      <span class="keyword">if</span>(pi-&gt;readopen == <span class="number">0</span> || pr-&gt;killed)&#123;</span><br><span class="line">        release(&amp;pi-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 唤醒读取管道的进程</span></span><br><span class="line">      wakeup(&amp;pi-&gt;nread);</span><br><span class="line">      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;pi-&gt;nread);</span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非常有意思且巧妙的点，就是<strong>读写管道等待在不同的chan上</strong>，这与上面信号量的例子是不一样的。想想也确实，如果使用同一个管道的话，当唤醒的时候，就会把不论是读还是写的全部进程都唤醒过来，这对性能显然损失较大。</p>
<blockquote>
<p>The pipe code uses separate sleep channels for reader and writer (pi-&gt;nread and pi-&gt;nwrite); this might make the system more effificient in the unlikely event that there are lots of readers and writers waiting for the same pipe.</p>
</blockquote>
<h2 id="Code-Wait-exit-and-kill"><a href="#Code-Wait-exit-and-kill" class="headerlink" title="Code: Wait, exit, and kill"></a>Code: Wait, exit, and kill</h2><h3 id="exit和wait"><a href="#exit和wait" class="headerlink" title="exit和wait"></a>exit和wait</h3><blockquote>
<p><code>Sleep</code>和<code>wakeup</code>可用于多种等待。第一章介绍的一个有趣的例子是子进程<code>exit</code>和父进程<code>wait</code>之间的交互。</p>
<p>xv6记录子进程终止直到<code>wait</code>观察到它的方式是让<code>exit</code>将调用方置于<code>ZOMBIE</code>状态，在那里它一直保持到父进程的<code>wait</code>注意到它，将子进程的状态更改为<code>UNUSED</code>，复制子进程的<code>exit</code>状态码，释放子进程，并将子进程ID返回给父进程。</p>
<p>如果父进程在子进程之前退出，则父进程将子进程交给<code>init</code>进程，<code>init</code>进程将永久调用<code>wait</code>；因此，每个子进程退出后都有一个父进程进行清理。</p>
</blockquote>
<p>又是一个生产者消费者模式。只不过此时的chan是父进程，资源是僵尸子进程【草】。由于涉及到进程间的调度切换，因而实现稍微复杂了点。</p>
<p>为什么需要涉及到进程间的调度呢？子进程设置完僵尸状态后，直接通过函数ret不行吗？答案是不行，因为ret的话就会去到不知道哪的地方【大概率会变成scause=2的情况】，所以这里子进程想要退出，就得做几件事，一是依靠父进程，让父进程杀死子进程，二是把自己设置为一个特殊的状态，使得自己不会被调度从而执行ret指令出错，三是尽快让父进程杀死自己越快越好。综合上述三个原因，exit最终在调度方面的实现方式，就变成了，子进程设置自己为ZOMBIE态-&gt;启用调度-&gt;父进程杀死ZOMBIE态的子进程。这期间不变性条件的防护，就得依赖于锁，以及sleep和wakeup了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// we need the parent&#x27;s lock in order to wake it up from wait().</span></span><br><span class="line">  <span class="comment">// the parent-then-child rule says we have to lock it first.</span></span><br><span class="line">  <span class="comment">// 整个xv6都必须遵守相同的顺序（父级，然后是子级）不论是锁定还是释放，都是先父再子</span></span><br><span class="line">  acquire(&amp;original_parent-&gt;lock);</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give any children to init.</span></span><br><span class="line">  <span class="comment">// 把自己的所有孩子都托付给init进程</span></span><br><span class="line">  <span class="comment">// init进程就是在操作系统启动时</span></span><br><span class="line">  reparent(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parent might be sleeping in wait().</span></span><br><span class="line">  <span class="comment">// 唤醒wait中的父进程</span></span><br><span class="line">  <span class="comment">// 这里看上去很诡异，明明子进程状态还未完全，怎么就唤醒父亲了呢？但其实很安全。</span></span><br><span class="line">  <span class="comment">// 此时子进程仍持有父进程的锁，如果有别的CPU中断进入scheduler线程，到父进程那时会卡在aquire</span></span><br><span class="line">  <span class="comment">// 直到子进程完成后续工作后父进程才能被真正唤醒执行</span></span><br><span class="line">  wakeup1(original_parent);</span><br><span class="line"></span><br><span class="line">  p-&gt;xstate = status;</span><br><span class="line">  <span class="comment">// 设为ZOMBIE态</span></span><br><span class="line">  p-&gt;state = ZOMBIE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成后续工作，解除父进程的锁</span></span><br><span class="line">  release(&amp;original_parent-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Jump into the scheduler, never to return.</span></span><br><span class="line">  <span class="comment">// 子进程会在父进程中被释放，所以永远不会回来</span></span><br><span class="line">  sched();</span><br><span class="line">  panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">wait</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hold p-&gt;lock for the whole time to avoid lost</span></span><br><span class="line">  <span class="comment">// wakeups from a child&#x27;s exit().</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;</span><br><span class="line">      <span class="comment">// this code uses np-&gt;parent without holding np-&gt;lock.</span></span><br><span class="line">      <span class="comment">// acquiring the lock first would cause a deadlock,</span></span><br><span class="line">      <span class="comment">// since np might be an ancestor, and we already hold p-&gt;lock.</span></span><br><span class="line">      <span class="comment">// 下面的第一点其实一句话就可以搞定：</span></span><br><span class="line">      <span class="comment">// 【它违反了先获取父亲锁，再获取子锁的xv6代码规定】</span></span><br><span class="line">      <span class="comment">// 1.要是在这句话之前acquire的话，acquire到你爸，你爸这时候也刚好执行到这句话</span></span><br><span class="line">      <span class="comment">// 那么就会造成你在自旋【此时你爸在wait一开始就得到了锁】，</span></span><br><span class="line">      <span class="comment">// 你爸也在自旋【你也在wait一开始得到了锁】,这样就造成了死锁</span></span><br><span class="line">      <span class="comment">// 2.并且由于np-&gt;parent只有parent才能改，所以数据是否过时是没关系的</span></span><br><span class="line">      <span class="comment">// 因为如果不是你儿子，数据过时与否都知道不是你儿子</span></span><br><span class="line">      <span class="comment">// 如果是你儿子，那数据压根就不会过时</span></span><br><span class="line">      <span class="keyword">if</span>(np-&gt;parent == p)&#123;</span><br><span class="line">        <span class="comment">// np-&gt;parent can&#x27;t change between the check and the acquire()</span></span><br><span class="line">        <span class="comment">// because only the parent changes it, and we&#x27;re the parent.</span></span><br><span class="line">        acquire(&amp;np-&gt;lock);</span><br><span class="line">        havekids = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(np-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          <span class="comment">// Found one.</span></span><br><span class="line">          pid = np-&gt;pid;</span><br><span class="line">          <span class="comment">// 传递返回参数</span></span><br><span class="line">          <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;np-&gt;xstate,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(np-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            release(&amp;np-&gt;lock);</span><br><span class="line">            release(&amp;p-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          freeproc(np);</span><br><span class="line">          release(&amp;np-&gt;lock);</span><br><span class="line">          release(&amp;p-&gt;lock);</span><br><span class="line">          <span class="keyword">return</span> pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don&#x27;t have any children.</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || p-&gt;killed)&#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for a child to exit.</span></span><br><span class="line">    <span class="comment">// 暂时释放p锁，等待子进程获取退出</span></span><br><span class="line">    sleep(p, &amp;p-&gt;lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中值得注意的几个点：</p>
<ol>
<li><p><code>wait</code>中的<code>sleep</code>中释放的条件锁是等待进程的<code>p-&gt;lock</code>，这是上面提到的特例。</p>
</li>
<li><p>exit会将自己的所有子进程交付给一直在等待着的init进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">    <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">    wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">      <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这里！！</span></span><br><span class="line">      <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子进程退出，就会通过init的wait释放它们。然后init释放完它们后进入第三个if分支，继续进行循环。</p>
</li>
<li><p>wakeup1</p>
<blockquote>
<p>Exit calls a specialized wakeup function, wakeup1, that wakes up only the parent, and only if it is sleeping in wait.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up p if it is sleeping in wait(); used by exit().</span></span><br><span class="line"><span class="comment">// Caller must hold p-&gt;lock.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup1</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;wakeup1&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;chan == p &amp;&amp; p-&gt;state == SLEEPING) &#123;</span><br><span class="line">    p-&gt;state = RUNNABLE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>kill其实做得很温和。它只是会把想鲨的进程的p-&gt;killed设置为1，然后如果该进程sleeping，则唤醒它。最后的死亡以及销毁由进程自己来做。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kill the process with the given pid.</span></span><br><span class="line"><span class="comment">// The victim won&#x27;t exit until it tries to go</span></span><br><span class="line"><span class="comment">// to kernel space (see usertrap() in trap.c).</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid == pid)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING)&#123;</span><br><span class="line">        <span class="comment">// Wake process from sleep().</span></span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// in trap.c usertrap()</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>可能这里有一个疑问：调用完exit后，进程会变成ZOMBIE态。谁最终把它释放了呢？其实答案很简单，只有两种：init进程或者是创建它的父进程。</p>
<p>如果创建它的父进程处于wait中，那么是由父进程把它销毁的，这没什么好说的。但如果创建它的父进程不在wait呢？那么父进程最后也是会调用exit的。父进程调用完exit后，会将其所有子进程过继给init进程。所以，ZOMBIE进程最终还是会迟早被init进程杀死的。</p>
<p>由这里，可以窥见xv6进程管理的进一步的冰山一角：</p>
<p>init进程是所有进程的根系进程。它一直处于wait的死循环中，因而可以将需要被杀死的进程杀死。</p>
<p>可见，wait和exit，实际上就构筑了进程的生命周期的最后一环。</p>
<p>这种巧妙地将进程生命周期这个大事<strong>完全托付给了wait和exit这两个函数</strong>的这种结构，实在是非常精妙，太牛了吧。</p>
<blockquote>
<p>一些XV6的<code>sleep</code>循环不检查<code>p-&gt;killed</code>，因为代码在应该是原子操作的多步系统调用的中间。virtio驱动程序（*<strong>kernel/virtio_disk.c*</strong>:242）就是一个例子：它不检查<code>p-&gt;killed</code>，因为一个磁盘操作可能是文件系统保持正确状态所需的一组写入操作之一。等待磁盘I/O时被杀死的进程将不会退出，直到它完成当前系统调用并且<code>usertrap</code>看到<code>killed</code>标志</p>
</blockquote>
<blockquote>
<p>Xv6对<code>kill</code>的支持并不完全令人满意：有一些<code>sleep</code>循环可能应该检查<code>p-&gt;killed</code>。一个相关的问题是，即使对于检查<code>p-&gt;killed</code>的<code>sleep</code>循环，<code>sleep</code>和<code>kill</code>之间也存在竞争；后者可能会设置<code>p-&gt;killed</code>，并试图在受害者的循环检查<code>p-&gt;killed</code>之后但在调用<code>sleep</code>之前尝试唤醒受害者。如果出现此问题，受害者将不会注意到<code>p-&gt;killed</code>，直到其等待的条件发生。这可能比正常情况要晚一点（例如，当virtio驱动程序返回受害者正在等待的磁盘块时）或永远不会发生（例如，如果受害者正在等待来自控制台的输入，但用户没有键入任何输入）。</p>
</blockquote>
<p>是的，所以这个kill的实现其实是相当玄学的。</p>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>xv6调度器实现了一个简单的调度策略：它依次运行每个进程。这一策略被称为轮询调度（round robin）。真实的操作系统实施更复杂的策略，例如，允许进程具有优先级。</p>
</blockquote>
<p>我记得linux0.11用的是时间片轮转+优先级队列完美融合的方法，是真的很牛逼</p>
<blockquote>
<p>复杂的策略可能会导致意外的交互，例如优先级反转（priority inversion）和航队（convoys）。当低优先级进程和高优先级进程共享一个锁时，可能会发生优先级反转，当低优先级进程持有该锁时，可能会阻止高优先级进程前进。当许多高优先级进程正在等待一个获得共享锁的低优先级进程时，可能会形成一个长的等待进程航队；一旦航队形成，它可以持续很长时间。为了避免此类问题，在复杂的调度器中需要额外的机制。</p>
</blockquote>
<blockquote>
<p>在<code>wakeup</code>中扫描整个进程列表以查找具有匹配<code>chan</code>的进程效率低下。一个更好的解决方案是用一个数据结构替换<code>sleep</code>和<code>wakeup</code>中的<code>chan</code>，该数据结构包含在该结构上休眠的进程列表，例如Linux的等待队列。</p>
</blockquote>
<p>是的，linux的那个wakeup真的很牛，我现在都还记得当初学到那的时候的震撼。</p>
<blockquote>
<p><code>wakeup</code>的实现会唤醒在特定通道上等待的所有进程，可能有许多进程在等待该特定通道。操作系统将安排所有这些进程，它们将竞相检查睡眠条件。进程的这种行为有时被称为<strong>惊群效应</strong>（thundering herd），最好避免。</p>
<p>大多数条件变量都有两个用于唤醒的原语：<code>signal</code>用于唤醒一个进程；<code>broadcast</code>用于唤醒所有等待进程。</p>
</blockquote>
<blockquote>
<p>一个实际的操作系统将在固定时间内使用空闲列表找到自由的<code>proc</code>结构体，而不是<code>allocproc</code>中的线性时间搜索；xv6使用线性扫描是为了简单起见。</p>
</blockquote>
<h2 id="Lab-Multithreading"><a href="#Lab-Multithreading" class="headerlink" title="Lab: Multithreading"></a>Lab: Multithreading</h2><blockquote>
<p>You will implement switching between threads in a user-level threads package, use multiple threads to speed up a program, and implement a barrier.</p>
</blockquote>
<p>这个introduction看起来还是非常激动人心的，很早就想了解到底线程是怎么实现的了。不过做完发现思想还是很简单的，就是只用切换上下文和栈就行。可以看看提供给的代码。</p>
<h3 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h3><blockquote>
<p>In this exercise you will design the <strong>context switch</strong> mechanism for a user-level threading system, and then implement it. </p>
<p>To get you started, your xv6 has two files <code>user/uthread.c</code> and <code>user/uthread_switch.S</code>, and a rule in the Makefile to build a uthread program. </p>
<p><code>uthread.c</code> contains most of a user-level threading package, and code for three simple test threads. The threading package is missing some of the code to create a thread and to switch between threads.</p>
<p>You will need to add code to <code>thread_create()</code> and <code>thread_schedule()</code> in <code>user/uthread.c</code>, and <code>thread_switch</code> in <code>user/uthread_switch.S</code>. </p>
<p>One goal is ensure that when <code>thread_schedule()</code> runs a given thread for the first time, the thread executes the function passed to <code>thread_create()</code>, on its <strong>own stack.</strong> </p>
<p>Another goal is to ensure that <code>thread_switch</code> saves the registers of the thread being switched away from, restores the registers of the thread being switched to, and returns to the point in the latter thread’s instructions where it last left off. You will have to decide where to save/restore registers; modifying <code>struct thread</code> to hold registers is a good plan. </p>
<p>You’ll need to add a call to <code>thread_switch</code> in <code>thread_schedule</code>; you can pass whatever arguments you need to <code>thread_switch</code>, but the intent is to switch from thread <code>t</code> to <code>next_thread</code>.</p>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>看了一遍它这里面写的题目还是有点抽象的，需要结合着给的代码看，那样就清晰多了。</p>
<p>首先，要补全的地方有这几个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. in thread_schedule()</span></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 2. in thread_create()</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. in uthread_switch.S</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * save the old thread&#x27;s registers,</span></span><br><span class="line"><span class="comment">         * restore the new thread&#x27;s registers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        .globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">        <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">        ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure>

<p>这几个函数到时候会被如此调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  a_started = b_started = c_started = <span class="number">0</span>;</span><br><span class="line">  a_n = b_n = c_n = <span class="number">0</span>;</span><br><span class="line">  thread_init();</span><br><span class="line">  thread_create(thread_a);</span><br><span class="line">  thread_create(thread_b);</span><br><span class="line">  thread_create(thread_c);</span><br><span class="line">  thread_schedule();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们在第一个地方要做的，就是要填入swtch的签名。第二个地方要做的，就是要想办法让该线程一被启动就去执行参数的函数指针。第三个地方要做的，就是要完成上下文的切换。</p>
<p>所以思路其实是很直观的。我们可以模仿进程管理中用来表示上下文的context，在<code>thread_create</code>的时候把里面的ra设置为参数的函数指针入口，sp修改为thread结构体中的栈地址。swtch函数则完全把<code>kernel/swtch.S</code>超过来就行。</p>
<blockquote>
<p>在这个思路中，我们是怎么做到栈的切换的呢？</p>
<p>每个线程在<code>thread_create</code>的时候，都将自己的context中的sp修改为自己的栈地址。这样一来，在它们被调度的时候，switch会自然而然地从context中读取sp作为之后运行的sp，这样就实现了栈的切换。</p>
</blockquote>
<h5 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h5><p>我觉得其他方面都不难，最坑最细节的【也是我完全没有想到的……】就是这里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改sp为栈顶</span></span><br><span class="line">t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br></pre></td></tr></table></figure>

<p>需要注意，栈顶并不是<code>t-&gt;stack</code>。</p>
<p>通过测试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0062f</span>eb8</span><br><span class="line"><span class="number">0062f</span>ebc</span><br><span class="line"><span class="number">0062f</span>ec0</span><br><span class="line"><span class="number">0062f</span>ec4</span><br><span class="line"><span class="number">0062f</span>ec8</span><br></pre></td></tr></table></figure>

<p>栈是向下增长的，因而，栈顶确实应该是数组的末尾……</p>
<p>这里完全没有想到，还是吃了基础的亏啊。</p>
<blockquote>
<p>如果这里将<code>t-&gt;stack</code>作为sp，那么运行时会出现非常诡异的现象（打印的是abc三个的<code>thread-&gt;state</code>）：</p>
<p><img src="/2023/01/10/xv6/image-20230120232149776.png" alt="image-20230120232149776"></p>
<p>仅有c【经测试，是仅有最后一个启动的线程】在执行，而ab的state都不是理想中的2，而是很奇怪的值。我确实有想过栈溢出问题，但是马上被我否定了。我完全没有想到是那样错的【悲】</p>
</blockquote>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="增加context结构体定义，修改thread结构体"><a href="#增加context结构体定义，修改thread结构体" class="headerlink" title="增加context结构体定义，修改thread结构体"></a>增加context结构体定义，修改thread结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-create"><a href="#修改thread-create" class="headerlink" title="修改thread_create"></a>修改thread_create</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">// 将当前上下文保存入context</span></span><br><span class="line">  thread_switch((uint64)(&amp;(t-&gt;context)),(uint64)(&amp;(t-&gt;context)));</span><br><span class="line">  <span class="comment">// 修改sp为栈顶</span></span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">  <span class="comment">// 修改ra为参数的函数指针入口</span></span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-schedule"><a href="#修改thread-schedule" class="headerlink" title="修改thread_schedule"></a>修改thread_schedule</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">  next_thread-&gt;state = RUNNING;</span><br><span class="line">  t = current_thread;</span><br><span class="line">  current_thread = next_thread;</span><br><span class="line">  <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">   * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">   * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  thread_switch((uint64)(&amp;(t-&gt;context)),(uint64)(&amp;(current_thread-&gt;context)));</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-switch"><a href="#修改thread-switch" class="headerlink" title="修改thread_switch"></a>修改thread_switch</h5><p>全部照搬<code>kernel/swtch.S</code>，没什么好说的</p>
<h3 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h3><p>一步步细粒度化，最后，每个桶用单独一把锁，仅在调用insert处加锁就行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> locks[NBUCKET];<span class="comment">// 在main中初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><blockquote>
<p>In this assignment you’ll implement a <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Barrier_(computer_science)">barrier</a>: a point in an application at which all participating threads must wait until all other participating threads reach that point too.</p>
</blockquote>
<p>直接上代码，还是比较简单的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">   pthread_mutex_lock(&amp;(bstate.barrier_mutex));</span><br><span class="line">   bstate.nthread++;</span><br><span class="line">   <span class="keyword">while</span>(bstate.nthread &lt; nthread)&#123;</span><br><span class="line">    pthread_cond_wait(&amp;(bstate.barrier_cond), &amp;(bstate.barrier_mutex));</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 此部分仅一个线程会进入</span></span><br><span class="line">   pthread_cond_broadcast(&amp;(bstate.barrier_cond));</span><br><span class="line">   bstate.nthread = <span class="number">0</span>;</span><br><span class="line">   bstate.round++;</span><br><span class="line">end:</span><br><span class="line">   pthread_mutex_unlock(&amp;(bstate.barrier_mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

		<div>
		  
			<div>
    
        <div style="text-align:center;color: #f7cdcd;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
		  
		</div>

      <footer class="post-footer">

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Scheduling"><span class="nav-number">1.</span> <span class="nav-text">Scheduling</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Context-switching"><span class="nav-number">1.1.</span> <span class="nav-text">Code: Context switching</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#context"><span class="nav-number">1.1.1.</span> <span class="nav-text">context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swtch"><span class="nav-number">1.1.2.</span> <span class="nav-text">swtch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sched"><span class="nav-number">1.1.3.</span> <span class="nav-text">sched</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scheduler"><span class="nav-number">1.1.4.</span> <span class="nav-text">scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85"><span class="nav-number">1.1.5.</span> <span class="nav-text">一些补充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Scheduling"><span class="nav-number">1.2.</span> <span class="nav-text">Code: Scheduling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sched%E5%89%8D%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">sched前要做的事</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sched%E4%B8%8Escheduler"><span class="nav-number">1.2.2.</span> <span class="nav-text">sched与scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#p-gt-lock%E4%BF%9D%E8%AF%81%E4%BA%86%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">1.2.3.</span> <span class="nav-text">p-&gt;lock保证了并发安全性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-mycpu-and-myproc"><span class="nav-number">1.3.</span> <span class="nav-text">Code: mycpu and myproc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sleep-and-wakeup"><span class="nav-number">1.4.</span> <span class="nav-text">Sleep and wakeup</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">自旋锁实现信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84sleep-and-wakeup"><span class="nav-number">1.4.2.</span> <span class="nav-text">不安全的sleep and wakeup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-and-wakeup"><span class="nav-number">1.4.3.</span> <span class="nav-text">sleep and wakeup</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Sleep-and-wakeup"><span class="nav-number">1.5.</span> <span class="nav-text">Code: Sleep and wakeup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Pipes"><span class="nav-number">1.6.</span> <span class="nav-text">Code: Pipes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Wait-exit-and-kill"><span class="nav-number">1.7.</span> <span class="nav-text">Code: Wait, exit, and kill</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exit%E5%92%8Cwait"><span class="nav-number">1.7.1.</span> <span class="nav-text">exit和wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kill"><span class="nav-number">1.7.2.</span> <span class="nav-text">kill</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world"><span class="nav-number">1.8.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-Multithreading"><span class="nav-number">1.9.</span> <span class="nav-text">Lab: Multithreading</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Uthread-switching-between-threads"><span class="nav-number">1.9.1.</span> <span class="nav-text">Uthread: switching between threads</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">1.9.1.1.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9D%91"><span class="nav-number">1.9.1.1.2.</span> <span class="nav-text">坑</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0context%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%EF%BC%8C%E4%BF%AE%E6%94%B9thread%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.9.1.2.1.</span> <span class="nav-text">增加context结构体定义，修改thread结构体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9thread-create"><span class="nav-number">1.9.1.2.2.</span> <span class="nav-text">修改thread_create</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9thread-schedule"><span class="nav-number">1.9.1.2.3.</span> <span class="nav-text">修改thread_schedule</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9thread-switch"><span class="nav-number">1.9.1.2.4.</span> <span class="nav-text">修改thread_switch</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-threads"><span class="nav-number">1.9.2.</span> <span class="nav-text">Using threads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Barrier"><span class="nav-number">1.9.3.</span> <span class="nav-text">Barrier</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="修年"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">修年</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:nniferyy@gmail.com" title="E-Mail → mailto:nniferyy@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
    <br>
      <span class="links-of-author-item">
          QQ: 1776527992
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">修年</span>
</div>


<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("10/04/2022 17:38:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  



  <script type="text/javascript" src="/js/clicklove.js"></script>
</body>
</html>
