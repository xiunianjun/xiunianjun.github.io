<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="修年">





<title>其他的对实验未涉及的思考 | 修年</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiunian&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiunian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc" style="right: -4em;">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">其他的对实验未涉及的思考</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">修年</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">一月 10, 2023&nbsp;&nbsp;20:25:29</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="其他的对实验未涉及的思考"><a href="#其他的对实验未涉及的思考" class="headerlink" title="其他的对实验未涉及的思考"></a>其他的对实验未涉及的思考</h1><h2 id="由mkfs引发的对虚拟机的学习"><a href="#由mkfs引发的对虚拟机的学习" class="headerlink" title="由mkfs引发的对虚拟机的学习"></a>由mkfs引发的对虚拟机的学习</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247489645&idx=5&sn=a6ad41806effb6bc8ff4815f4eab968a&chksm=fbb29193ccc51885348ce6dfb81661ecc17cd271bf6fb79a78a656b49d4eccaa9de7606c01cc&scene=27">懂了！VMware/KVM/Docker原来是这么回事儿</a>这篇文章对虚拟化、虚拟机技术讲解很到位，写得通俗易懂，非常值得一看</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24123210/answer/2852910075">KVM 的「基于内核的虚拟机」是什么意思？</a>这篇文章对QEMU-KVM架构进行了详细的介绍。还有这篇文章对应的知乎问题下面的高赞回答有机会也可以去看看。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hbuxiaofei/article/details/113556046">QEMU/KVM原理概述</a>这篇文章前面的原理和上面那个差不多，后面有使用kvm做一个精简内核的实例，有兴趣/有精力/有需要可以看看。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23924713/article/details/126080325">MIT6.S081操作系统实验——操作系统是如何在qemu虚拟机中启动的？</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mumu3w/article/details/54173069">xv6分析–mkfs源代码注释</a></p>
</blockquote>
<p>以前只是知道，xv6是运行在qemu提供的虚拟环境之上的。qemu是什么，怎么虚拟的，虚拟机和宿主机是怎么交互的，这些一概不通。今天心血来潮想研究下qemu，虚拟机啥的到底是什么玩意，虽然看得有些猪脑过载，但还是写下一些个人的整理。</p>
<h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>在了解qemu之前，可以先了解一下虚拟化的思想。</p>
<h5 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h5><blockquote>
<p>虚拟化的主要思想是，通过分层将底层的复杂、难用的资源虚拟抽象成简单、易用的资源，<strong>提供给上层</strong>使用。</p>
<p>本质上，计算机的发展过程也是虚拟化不断发展的过程，底层的资源或者通过<strong>空间的分割</strong>，或者通过<strong>时间的分割</strong>，将下层的资源通过一种简单易用的方式转换成另一种资源，提供给上层使用。</p>
<p>虚拟化可分为以下几方面：</p>
<ol>
<li><strong>CPU抽象</strong>：机器码、汇编语言到C语言、再到高级语言的不断虚拟的过程</li>
<li><strong>存储抽象</strong>：操作系统通过文件和目录抽象</li>
<li><strong>网络抽象</strong>：TCP/IP协议栈模型将网卡设备中传递的二进制数据，经过网络层、传输层的抽象后，为应用程序提供了便捷的网络包处理接口，而无需关心底层的IP路由、分片等细节</li>
<li><strong>进程抽象</strong>：操作系统通过进程抽象为不同的应用程序提供了安全隔离的执行环境，并且有着独立的CPU和内存等资源</li>
</ol>
</blockquote>
<p>虚拟化的思想实际上就是我以前一直称为“抽象”的思想，以接口的形式逐层向上服务。</p>
<h5 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h5><blockquote>
<p>虚拟机的核心能力在于<strong>提供一个执行环境</strong>（隐藏底层细节），并在其中完成用户的指定任务。</p>
</blockquote>
<blockquote>
<p>虚拟机有多种不同的<strong>形式</strong>，包括提供指令执行环境的进程、模拟器和高级语言虚拟机，或者是提供一个完整的系统环境的系统虚拟机。</p>
</blockquote>
<h6 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h6><p>进程实际上就是一种虚拟机。</p>
<blockquote>
<p>进程可以看作是一组<strong>资源的集合</strong>，有自己<strong>独立</strong>的进程地址空间以及<strong>独立</strong>的CPU和寄存器，执行程序员编写的指令，完成一定的任务。</p>
<p>操作系统可以创建多个进程，每一个进程都可以看成一个<strong>独立的虚拟机</strong>，它们在执行指令、访问内存的时候并不会相互影响影响。</p>
</blockquote>
<h6 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h6><h6 id="高级语言虚拟机"><a href="#高级语言虚拟机" class="headerlink" title="高级语言虚拟机"></a>高级语言虚拟机</h6><h6 id="系统虚拟机"><a href="#系统虚拟机" class="headerlink" title="系统虚拟机"></a>系统虚拟机</h6><blockquote>
<p>通过<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">系统虚拟化技术</a>，能够在<strong>单个的宿主机硬件平台上运行多个虚拟机</strong>，每个虚拟机都有着完整的虚拟机硬件，如虚拟的CPU、内存、虚拟的外设等，并且虚拟机之间能够实现完整的隔离。</p>
<p>在系统虚拟化中，管理全局物理资源的软件叫作<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%91%E6%8E%A7%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">虚拟机监控器</a>（Virtual Machine Monitor，VMM），<u>VMM之于虚拟机就如同操作系统之于进程</u>，VMM利用时分复用或者空分复用的办法将硬件资源在各个虚拟机之间进行分配。</p>
</blockquote>
<h5 id="qemu-1"><a href="#qemu-1" class="headerlink" title="qemu"></a>qemu</h5><p>可以看到，qemu就是一种虚拟机。它可以模拟虚拟机硬件，为操作系统提供虚拟硬件环境，从而能够让不同的操作系统能够在不同主机硬件上执行。</p>
<h4 id="qemu-kvm架构"><a href="#qemu-kvm架构" class="headerlink" title="qemu-kvm架构"></a>qemu-kvm架构</h4><h5 id="诞生的原因"><a href="#诞生的原因" class="headerlink" title="诞生的原因"></a>诞生的原因</h5><blockquote>
<p>其对于虚拟化技术的优化，以及发展的前因后果，具体可以看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247489645&idx=5&sn=a6ad41806effb6bc8ff4815f4eab968a&chksm=fbb29193ccc51885348ce6dfb81661ecc17cd271bf6fb79a78a656b49d4eccaa9de7606c01cc&scene=27">懂了！VMware/KVM/Docker原来是这么回事儿</a>这篇文章。</p>
<p>概括来讲，大致有以下几个要点：</p>
</blockquote>
<h6 id="两种虚拟化方案"><a href="#两种虚拟化方案" class="headerlink" title="两种虚拟化方案"></a>两种虚拟化方案</h6><p><img src="/2023/01/10/xv6/640.png" alt="640"></p>
<p><img src="/2023/01/10/xv6/640-1676793944101-7.png" alt="640-1676793944101-7"></p>
<h6 id="实现上述的虚拟化方案"><a href="#实现上述的虚拟化方案" class="headerlink" title="实现上述的虚拟化方案"></a>实现上述的虚拟化方案</h6><p>一个典型的做法是——<code>陷阱 &amp; 模拟</code>技术</p>
<p>什么意思？<strong>简单来说就是正常情况下直接把虚拟机中的代码指令放到物理的CPU上去执行，一旦执行到一些敏感指令，就触发异常，控制流程交给VMM，由VMM来进行对应的处理，以此来营造出一个虚拟的计算机环境。</strong></p>
<h6 id="x86架构的问题"><a href="#x86架构的问题" class="headerlink" title="x86架构的问题"></a>x86架构的问题</h6><p>x86架构使得上述做法用不了了。因为它引入了四种权限</p>
<p><img src="/2023/01/10/xv6/image-20230219160725978.png" alt="image-20230219160725978"></p>
<h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h6><ol>
<li><p>全虚拟化</p>
<p>VMware的二进制翻译技术、QEMU的模拟指令集</p>
</li>
<li><p>半虚拟化</p>
</li>
<li><p>硬件辅助虚拟化</p>
<p>硬件辅助虚拟化细节较为复杂，简单来说，新一代CPU在原先的Ring0-Ring3四种工作状态之下，再引入了一个叫工作模式的概念，有<code>VMX root operation</code>和<code>VMX non-root operation</code>两种模式，每种模式都具有完整的Ring0-Ring3四种工作状态，前者是VMM运行的模式，后者是虚拟机中的OS运行的模式。</p>
<p>qemu-kvm架构正是借助于此实现的。</p>
</li>
</ol>
<h6 id="kvm"><a href="#kvm" class="headerlink" title="kvm"></a>kvm</h6><p>kvm就是借助硬件辅助虚拟化诞生的。可以把kvm看作是一堆系统调用。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.redhat.com/zh/topics/virtualization/what-is-KVM">什么是 KVM？</a></p>
<p>KVM本身是一个<strong>内核模块</strong>，它导出了一系列的<strong>接口</strong>到用户空间，用户态程序可以使用这些接口创建虚拟机。</p>
<p>具体而言，KVM 可帮助您将 Linux 转变为<a target="_blank" rel="noopener" href="https://www.redhat.com/zh/topics/virtualization/what-is-a-hypervisor">虚拟机监控程序</a>，使主机计算机能够运行多个隔离的虚拟环境，即虚拟客户机或虚拟机（VM）。【也即，虚拟机—进程，KVM—操作系统】</p>
</blockquote>
<blockquote>
<p>在虚拟化底层技术上，<u>KVM和VMware后续版本一样</u>，都是基于<strong>硬件辅助虚拟化</strong>实现。不同的是VMware作为独立的第三方软件可以安装在Linux、Windows、MacOS等多种不同的操作系统之上，而KVM作为一项虚拟化技术已经<strong>集成</strong>到Linux内核之中，可以认为Linux内核本身就是一个HyperVisor，这也是KVM名字的含义，因此该技术只能在Linux服务器上使用。</p>
</blockquote>
<h6 id="qemu-kvm"><a href="#qemu-kvm" class="headerlink" title="qemu-kvm"></a>qemu-kvm</h6><p>KVM本身基于硬件辅助虚拟化，仅仅实现CPU和内存的虚拟化，但一台计算机不仅仅有CPU和内存，还需要各种各样的I/O设备，不过KVM不负责这些。这个时候，QEMU就和KVM搭上了线，经过改造后的QEMU，负责外部设备的虚拟，KVM负责底层执行引擎和内存的虚拟，两者彼此互补，成为新一代云计算虚拟化方案的宠儿。</p>
<h5 id="qemu-kvm总体架构"><a href="#qemu-kvm总体架构" class="headerlink" title="qemu-kvm总体架构"></a>qemu-kvm总体架构</h5><p>KVM只负责最核心的<strong>CPU虚拟化和内存虚拟化</strong>部分；QEMU作为其用户态组件，负责完成<strong>大量外设的模拟</strong>。</p>
<p><img src="/2023/01/10/xv6/v2-249a3f162de88198bbe415110fc71c7f_1440w.jpg" alt="v2-249a3f162de88198bbe415110fc71c7f_1440w"></p>
<h6 id="VMX-root和VMX-non-root"><a href="#VMX-root和VMX-non-root" class="headerlink" title="VMX root和VMX non root"></a>VMX root和VMX non root</h6><blockquote>
<p>VMX root是宿主机模式，此时CPU在运行包括QEMU在内的普通进程和宿主机的操作系统内核；</p>
<p>VMX non-root是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">虚拟机模式</a>，此时CPU在运行虚拟机中的用户程序和操作系统代码。</p>
</blockquote>
<p>也就是说，虚拟机的程序，包括用户程序和内核程序，都运行在non-root模式。宿主机的所有程序，包括用户程序【包括qemu】和内核程序【包括kvm】，都运行在root模式。</p>
<h6 id="qemu层（左上）"><a href="#qemu层（左上）" class="headerlink" title="qemu层（左上）"></a>qemu层（左上）</h6><p>上面说到，qemu负责的是大量外设的模拟。它具体要做以下几件事：</p>
<blockquote>
<p>初始化虚拟机：</p>
<ol>
<li><p>创建模拟的芯片组</p>
</li>
<li><p>创建<strong>CPU线程</strong>来表示虚拟机的CPU</p>
<p>QEMU在初始化虚拟机的CPU线程时，首先设置好相应的虚拟CPU寄存器的值，然后调用KVM的接口将虚拟机运行起来，这样CPU线程就会被调度在物理CPU上执行虚拟机的代码。</p>
</li>
<li><p><strong>在QEMU的虚拟地址空间中分配空间作为虚拟机的物理地址</strong></p>
</li>
<li><p>根据用户在命令行<strong>指定的设备</strong>为虚拟机创建对应的虚拟设备【如各种IO设备】</p>
</li>
</ol>
<p>虚拟机运行时：</p>
<ol>
<li><p>监听多种事件</p>
<p>包括虚拟机对设备的I/O访问、用户对虚拟机管理界面、虚拟设备对应的宿主机上的一些I/O事件（比如虚拟机网络数据的接收）等</p>
</li>
<li><p>调用函数处理</p>
</li>
</ol>
</blockquote>
<p>可以看到，qemu确实利用了宿主机的各种资源，提供了一个很完美的硬件环境。其资源对应关系为：</p>
<p>虚拟机的CPU——宿主机的一个线程</p>
<p>虚拟机的物理地址——qemu在宿主机的虚拟地址</p>
<p>虚拟机对硬件设备的访问 —→ 对qemu的访问 </p>
<h6 id="kvm层（下方）"><a href="#kvm层（下方）" class="headerlink" title="kvm层（下方）"></a>kvm层（下方）</h6><p>它大概做了两件事：</p>
<ol>
<li><p>给qemu提供运行时的参数</p>
<p>通过“/dev/kvm”设备，比如CPU个数、内存布局、运行等。</p>
</li>
<li><p>截获VM Exit事件【下面会讲，用来完成虚拟机和硬件环境的交互】并进行处理。</p>
</li>
</ol>
<h6 id="虚拟机层（右上）"><a href="#虚拟机层（右上）" class="headerlink" title="虚拟机层（右上）"></a>虚拟机层（右上）</h6><ol>
<li><p>CPU——QEMU进程中的一个线程</p>
<p>通过QEMU和KVM的相互协作，虚拟机的线程会被宿主机操作系统正常调度，<strong>直接执行虚拟机中的代码</strong></p>
</li>
<li><p>物理地址——QEMU进程中的虚拟地址</p>
</li>
<li><p>设备——QEMU实现</p>
<p>在运行过程中，虚拟机操作系统通过设备的I/O端口（Port IO、PIO）或者MMIO（Memory Mapped I/O）进行交互，<strong>KVM会截获这个请求</strong>【也即VM Exit，下面会讲】，大多数时候KVM会将请求分发到用户空间的QEMU进程中，由<strong>QEMU处理</strong>这些I/O请求</p>
</li>
</ol>
<h5 id="虚拟机在QEMU-KVM架构的执行方法"><a href="#虚拟机在QEMU-KVM架构的执行方法" class="headerlink" title="虚拟机在QEMU-KVM架构的执行方法"></a>虚拟机在QEMU-KVM架构的执行方法</h5><h6 id="状态管理虚拟化"><a href="#状态管理虚拟化" class="headerlink" title="状态管理虚拟化"></a>状态管理虚拟化</h6><p>虚拟机肯定是会与它的硬件环境进行交互的，它的硬件环境也就是QEMU—KVM。</p>
<p>虚拟机的用户程序和内核程序都是直接由宿主机的操作系统正常调度，我们可以将其看作虚拟态。QEMU—KVM可以看作是宿主机的进程，我们可以将其看作宿主态。因而，当虚拟机一些事情希望由QEMU—KVM来做，我们就需要从虚拟态转移到宿主态。</p>
<p>听起来有没有感觉很耳熟？是的，“从用户态陷入内核态”，跟这个的原理是一样的。</p>
<p>因而，虚拟机与硬件环境交互，实际上是虚拟态和宿主态状态的转换，如下图：</p>
<p><img src="/2023/01/10/xv6/v2-9377a260d034d2904b1807d3fe53dcd9_1440w.jpg" alt="v2-9377a260d034d2904b1807d3fe53dcd9_1440w"></p>
<p><strong>VM Exit</strong></p>
<p>当虚拟机中的代码是敏感指令或者说满足了一定的退出条件时，CPU会从虚拟态退出到KVM，这叫作VM Exit。</p>
<p>这就像在用户态执行指令陷入内核一样。</p>
<p>VM Exit首先陷入到KVM中进行处理，如果KVM无法处理，比如说虚拟机写了设备的寄存器地址，那么KVM会将这个写操作分派到QEMU中进行处理。</p>
<p><strong>VM Entry</strong></p>
<p>当KVM或者QEMU处好了退出事件之后，又可以将CPU置于虚拟态以运行虚拟机代码，这叫作VM Entry。</p>
<h6 id="内存管理虚拟化"><a href="#内存管理虚拟化" class="headerlink" title="内存管理虚拟化"></a>内存管理虚拟化</h6><blockquote>
<p>QEMU在初始化的时候会通过<code>mmap</code>分配虚拟内存空间作为虚拟机的物理内存，【感觉思路打开，物理内存与文件对应了起来】QEMU在不断更新内存布局的过程中会持续调用KVM接口通知内核KVM模块虚拟机的内存分布。</p>
</blockquote>
<p>虚拟机在运行过程中，首先需要将虚拟机的虚拟地址（Guest Virtual Address，GVA）转换成虚拟机的物理地址（Guest Physical Address，GPA），然后将虚拟机的物理地址转换成宿主机的虚拟地址（Host Virtual Address，HVA），最终转换成宿主机的物理地址（Host Physical Address，HPA）。</p>
<p>整个寻址过程由硬件实现，具体实现方式为扩展页表（Extended Page Table，EPT）。</p>
<p>在支持EPT的环境中，虚拟机在<strong>第一次访问内存的时候就会陷入到KVM</strong>，KVM会<strong>逐渐建立</strong>起所谓的EPT页面【lazy思想贯穿始终，还是该叫自适应？】。这样虚拟机的虚拟CPU在后面访问虚拟机虚拟内存地址的时候，首先会被转换为虚拟机物理地址，接着会查找EPT页表，然后得到宿主机物理地址。【有种TLB的感觉】</p>
<p><img src="/2023/01/10/xv6/v2-942e1ed598eed3d401d00e4719224d27_1440w.jpg" alt="v2-942e1ed598eed3d401d00e4719224d27_1440w"></p>
<h6 id="外设管理虚拟化"><a href="#外设管理虚拟化" class="headerlink" title="外设管理虚拟化"></a>外设管理虚拟化</h6><p>设备模拟的本质是要为虚拟机提供一个<strong>与物理设备接口完全一致的虚拟接口</strong>。</p>
<p>虚拟机中的操作系统与设备进行的数据交互或者由QEMU和（或）KVM完成，或者由宿主机上对应的后端设备完成。</p>
<p>QEMU在初始化过程中会创建好模拟芯片组和必要的模拟设备，包括南北桥芯片、PCI根总线、ISA根总线等总线系统，以及各种PCI设备、ISA设备等。</p>
<p>外设虚拟化主要有如下几种方式：</p>
<ol>
<li><p>纯软件模拟（完全虚拟化）</p>
<p>QEMU最早的方案，虚拟机内核不用做任何修改，每一次对设备的寄存器读写都会陷入到KVM，进而到QEMU，QEMU再对这些请求进行处理并模拟硬件行为。</p>
<p>软件模拟会导致非常多的QEMU/KVM接入，效率低下。</p>
</li>
<li><p>virtio设备（半虚拟化）</p>
<p>virtio设备是一类特殊的设备，并没有对应的物理设备，所以需要虚拟机内部操作系统安装特殊的virtio驱动。</p>
<p>相比软件模拟，virtio方案提高了虚拟设备的性能。</p>
</li>
<li><p>设备直通</p>
<p>将物理硬件设备直接挂到虚拟机上，虚拟机直接与物理设备交互，尽可能在I/O路径上减少QEMU/KVM的参与。</p>
<p>设备直通经常搭配硬件虚拟化支持技术SRIOV（Single Root I/O Virtualization，单根输入/输出虚拟化）使用，SRIOV能够将单个的物理硬件高效地虚拟出多个虚拟硬件。</p>
</li>
</ol>
<p><img src="/2023/01/10/xv6/v2-555d017ce5b65457f98617a5fdf232af_1440w.jpg" alt="v2-555d017ce5b65457f98617a5fdf232af_1440w"></p>
<h6 id="中断处理虚拟化"><a href="#中断处理虚拟化" class="headerlink" title="中断处理虚拟化"></a>中断处理虚拟化</h6><p>操作系统通过写设备的I/O端口或者MMIO地址来与设备交互，设备通过发送中断来通知操作系统事件。</p>
<p>QEMU/KVM一方面需要完成这项<strong>中断设备的模拟</strong>，另一方面需要模拟<strong>中断的请求处理</strong>。</p>
<blockquote>
<p>QEMU支持单CPU的Intel 8259中断控制器以及SMP的I/O APIC（I/O Advanced Programmable Interrupt Controller）和LAPIC（Local Advanced Programmable Interrupt Controller）中断控制器。在这种方式下，虚拟外设通过QEMU向虚拟机注入中断，需要先陷入到KVM，然后由KVM向虚拟机注入中断，这是一个非常费时的操作。</p>
<p>为了提高虚拟机的效率，KVM自己也实现了中断控制器Intel 8259、I/O APIC以及LAPIC。用户可以有选择地让QEMU或者KVM模拟全部中断控制器，也可以让QEMU模拟Intel 8259中断控制器和I/O APIC，让KVM模拟LAPIC。</p>
</blockquote>
<h4 id="xv6的全启动运行过程梳理"><a href="#xv6的全启动运行过程梳理" class="headerlink" title="xv6的全启动运行过程梳理"></a>xv6的全启动运行过程梳理</h4><p>介绍完上述的qemu虚拟化，接下来就可以对xv6的全启动进行一个梳理了。</p>
<p>首先，在宿主机执行<code>make qemu</code>。</p>
<p>在<code>Makefile</code>中可以看到：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">qemu: $K/kernel fs.img</span></span><br><span class="line">        <span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span></span><br><span class="line">QEMU = qemu-system-riscv64</span><br></pre></td></tr></table></figure>

<p>在log中可以看到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">mkfs/mkfs fs.img README user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie user/_mmaptest</span><br><span class="line">...</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>具体的<code>Makefile</code>相关内容我不大了解，但结合输出，我想大概是先通过<code>riscv64-linux-gnu-gcc</code>编译链接完所有文件，然后再执行<code>mkfs</code>产生<code>fs.img</code>镜像（<code>mkfs</code>后面那些东西应该是文件参数，对应于源码中的读取可执行程序进磁盘的部分），最后再运行<code>qemu-system-riscv64</code>开始对虚拟机进行boot。</p>
<p>boot直至启动后的所有代码，都是通过QEMU-KVM架构处理，直接运行在宿主机的CPU上的。其余的各种管理，可以详见小标题<code>虚拟机在QEMU-KVM架构的执行方法</code>。</p>
<h4 id="mkfs的作用及源码解读"><a href="#mkfs的作用及源码解读" class="headerlink" title="mkfs的作用及源码解读"></a>mkfs的作用及源码解读</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>上面的知识表明，<strong>操作系统的启动在于文件系统初始化之后</strong>，这是因为操作系统本身的启动代码，放在磁盘映像<code>fs.img</code>中，而<code>fs.img</code>正是由文件系统初始化时弄出来的。也就是说，<strong>文件系统是操作系统的爸爸</strong>。【我以前一直以为是反过来的】</p>
<p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<blockquote>
<p>图中的boot块就是操作系统的引导扇区。</p>
</blockquote>
<p>而<code>mkfs</code>的作用，正是把宿主机提供的<strong>虚拟地址空间作为虚拟磁盘</strong>，把虚拟地址空间划分为如上图所示的地址结构。<strong>它是运行在宿主机当中的</strong>。有了<code>mkfs</code>，才能有我们的虚拟机。</p>
<h5 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mumu3w/article/details/54173069">xv6分析–mkfs源代码注释</a></p>
<p>yysy这个就写得很好了。</p>
<h2 id="user-mem-allocator"><a href="#user-mem-allocator" class="headerlink" title="user mem-allocator"></a>user mem-allocator</h2><blockquote>
<p>linux的堆管理</p>
<p>那么malloc到底是怎么实现的呢？不是每次要申请内存就调一下系统调用，而是程序向操作系统申请⼀块适当⼤⼩的堆空间，然后由程序⾃⼰管理这块空间，⽽具体来讲，管理着堆空间分配的往往是程序的<strong>运⾏库</strong>。</p>
<p>也就是说，malloc本质上是以运行库而非系统调用形式出现的。它里面用到的是<strong>sbrk和mmap</strong>这两个系统调用来进货。</p>
<p>glibc的malloc函数是这样处理⽤户的空间请求的：对于⼩于128KB的请求来说，它会在现有的堆空间⾥⾯，按照堆分配算法为它分配⼀块空间并返回；对于⼤于128KB的请求来说，它会使⽤mmap()函数为它分配⼀块匿名空间，然后在这个匿名空间中为⽤户分配空间。</p>
</blockquote>
<p>在内核态中，我们使用<code>kalloc</code>和<code>kfree</code>来申请和释放内存页。在用户态中，我们使用<code>malloc</code>和<code>free</code>来对动态内存进行管理。【也就是说这个实现的是<strong>堆管理</strong>】</p>
<p>内核中的最小单位只能是页，但user mem-allocator对外提供的申请内存服务的<strong>最小单位不是页</strong>，而是<code>sizeof(Header)</code>。因而，这就需要我们的user mem-allocator进行数据结构的管理，来统一这二者的实现。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><p>user mem-allocator的数据结构是<strong>环形链表</strong>，起始结点为一个空数据载体。</p>
<p><img src="/2023/01/10/xv6/image-20230316140158908.png" alt="image-20230316140158908"></p>
<p><img src="/2023/01/10/xv6/image-20230316140450988.png" alt="image-20230316140450988"></p>
<h4 id="地址从低到高"><a href="#地址从低到高" class="headerlink" title="地址从低到高"></a>地址从低到高</h4><p>链表的头结点的存储地址/所代表的内存地址的地址数值最小，并且其余结点按遍历顺序地址递增。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>user mem-allocator由三个主要函数组成，分别是<code>morecore</code>、<code>malloc</code>和<code>free</code>。一个一个地来说未免有点不符合正常人的思路，所以我接下来会以用户初次调用<code>malloc</code>为例，来整理user mem-allocator的具体实现。</p>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>当用户初次调用<code>malloc</code>，此时freep仍为空指针，因而会进入如下分支：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((prevp = freep) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// 空闲mem为空的情况</span></span><br><span class="line">  base.s.ptr = freep = prevp = &amp;base;</span><br><span class="line">  base.s.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即初始化为这种情况：</p>
<p><img src="/2023/01/10/xv6/image-20230316143711888.png" alt="image-20230316143711888"></p>
<p>随后，由于<code>prevp-&gt;ptr == freep</code>，故而会在循环中进入该分支：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(p == freep) <span class="comment">// 一般情况下，此处表明已经完整遍历了一遍环形链表，因为prev的初值是freep，而我们是从prev-&gt;next开始遍历的</span></span><br><span class="line">    <span class="keyword">if</span>((p = morecore(nunits)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>morecore</code>。</p>
<h4 id="morecore"><a href="#morecore" class="headerlink" title="morecore"></a>morecore</h4><p>进入<code>morecore</code>后，首先会对堆内存进行扩容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nu &lt; <span class="number">4096</span>)</span><br><span class="line">  nu = <span class="number">4096</span>;</span><br><span class="line">p = sbrk(nu * <span class="keyword">sizeof</span>(Header));</span><br><span class="line"><span class="keyword">if</span>(p == (<span class="type">char</span>*)<span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>其中，nu表示要申请的内存单元数，一个内存单元为<code>sizeof(Header)</code>，因而nu在<code>malloc</code>中计算如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nunits = (nbytes + <span class="keyword">sizeof</span>(Header) - <span class="number">1</span>)/<span class="keyword">sizeof</span>(Header) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>为了满足内核以一页为最小内存单位的需求，以及避免过多陷入内核态，它每次会申请至少4096*内存单元的堆空间。</p>
<p>对堆内存进行扩容完之后，<code>morecore</code>会手动调用一次<code>free</code>，将新申请到的内存加入数据结构中。【此处类似于在<code>knit</code>中调用<code>kfree</code>的原理】</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ap)</span>&#123;</span><br><span class="line">  Header *bp, *p;</span><br><span class="line"></span><br><span class="line">  bp = (Header*)ap - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)</span><br><span class="line">    <span class="keyword">if</span>(p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr))</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>由于此时<code>freep == freep-&gt;str == base</code>，并且我们在<code>morecore</code>中新申请的内存空间<code>ap</code>满足<code>ap &gt; base</code>，故而会跳出循环。</p>
<blockquote>
<p>为什么<code>ap &gt; base</code>呢？</p>
<p>别忘了我们扩容的原理。我们是以<code>proc-&gt;size</code>为起始地址扩容的。ap处在扩容内存中，因而ap&gt;旧size；base处在扩容前内存内，因而base&lt;=旧size。故而有ap&gt;base。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bp + bp-&gt;s.size == p-&gt;s.ptr)&#123;</span><br><span class="line">  bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;</span><br><span class="line">  bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  bp-&gt;s.ptr = p-&gt;s.ptr;</span><br><span class="line"><span class="keyword">if</span>(p + p-&gt;s.size == bp)&#123;</span><br><span class="line">  p-&gt;s.size += bp-&gt;s.size;</span><br><span class="line">  p-&gt;s.ptr = bp-&gt;s.ptr;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  p-&gt;s.ptr = bp;</span><br><span class="line">freep = p;</span><br></pre></td></tr></table></figure>

<p>跳出循环后，我们会进入第一个if的第二个分支，以及第二个if的第二个分支。经过这些指针操作后，此时我们的数据结构如下图所示：</p>
<p><img src="/2023/01/10/xv6/image-20230316145733160.png" alt="image-20230316145733160"></p>
<p>也即形成了一个两节点的环形链表。</p>
<h4 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h4><p>经历完上述调用后，我们回到<code>malloc</code>的循环中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(p == freep)</span><br><span class="line">    <span class="keyword">if</span>((p = morecore(nunits)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由<code>morecore</code>的返回值可知，此时我们的p应该指向freep。本轮循环结束后执行<code> p = p-&gt;s.ptr</code>，此时我们的p指向了我们刚在<code>morecore</code>中扩容出来的那一大段内存。</p>
<p><img src="/2023/01/10/xv6/image-20230316150327569.png" alt="image-20230316150327569"></p>
<p>在下一轮循环中，由于我们刚刚通过<code>morecore</code>申请了至少<code>nunits</code>的空间，因而我们将进入该分支：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;s.size &gt;= nunits)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;s.size == nunits)</span><br><span class="line">    <span class="comment">// 如果与所需的内存刚好相等，那就直接返回该小单元就行</span></span><br><span class="line">    prevp-&gt;s.ptr = p-&gt;s.ptr;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不等的话就只划分出一小部分</span></span><br><span class="line">    <span class="comment">// 一次划出几个header单元</span></span><br><span class="line">    p-&gt;s.size -= nunits;</span><br><span class="line">    p += p-&gt;s.size;</span><br><span class="line">    p-&gt;s.size = nunits;</span><br><span class="line">  &#125;</span><br><span class="line">  freep = prevp;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)(p + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>nunits &gt;= 4096</code>，也即<code>p-&gt;s.size == nunits</code>，p所指向的地址恰好就是我们接下来会用的地址。因而，我们就将这部分内存空间从我们的freelist中剔除，在之后返回p的地址即可。</p>
<p>当<code>nunits &lt; 4096</code>，也即<code>p-&gt;s.size != nunits</code>，说明p所指向的这块内存空间比我们需要的大，那么我们就仅将该段内存空间切割出需要的那一小部分，再把p指向那一小部分开头的地方，返回p地址即可，如图所示。</p>
<p><img src="/2023/01/10/xv6/image-20230316150846709.png" alt="image-20230316150846709"></p>
<p>这样一来，我们就成功给用户它所需要的内存空间了。</p>
<h4 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h4><p>进行malloc之后，用户还需要调用free来手动释放内存，防止内存泄漏。</p>
<p><img src="/2023/01/10/xv6/image-20230316151116462.png" alt="image-20230316151116462"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)</span><br><span class="line">  <span class="keyword">if</span>(p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr))</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>由于<code>ap &gt; base</code>且<code>ap &gt; 旧p-&gt;size = base-&gt;ptr</code>且<code>base &lt; base-&gt;ptr</code>，故而首先会进行一轮循环。再然后，由于<code>p = 旧p-&gt;size</code>，并且<code>p &gt; p-&gt;ptr = base</code>，并且<code>ap &gt; 旧size</code>，故而跳出循环。</p>
<blockquote>
<p>此处循环中，循环语句内部的这个循环实际上是对遍历到环形链表尾部，即将从头开始遍历，这个边界情况的处理。比较符合逻辑的还是循环语句内的那个条件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bp + bp-&gt;s.size == p-&gt;s.ptr)&#123;</span><br><span class="line">  bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;</span><br><span class="line">  bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  bp-&gt;s.ptr = p-&gt;s.ptr;</span><br><span class="line"><span class="keyword">if</span>(p + p-&gt;s.size == bp)&#123;</span><br><span class="line">  p-&gt;s.size += bp-&gt;s.size;</span><br><span class="line">  p-&gt;s.ptr = bp-&gt;s.ptr;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  p-&gt;s.ptr = bp;</span><br><span class="line">freep = p;</span><br></pre></td></tr></table></figure>

<p>此时会进入第二个if的第一个分支。具体情况看图就行，不多bb。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要就是这个数据结构用得很巧妙但也很复杂。它吸取了内核态中分配内存使用一个freelist的特点，同时又巧妙地利用了内存地址有序的特点，从而实现碎片内存管理。我的建议是多画图。</p>
<p>还有其实有一点我不是很理解。我觉得<code>freep</code>这个变量的用意非常不明，它似乎并不是指代整个freelist的头，因为它在很多个地方都诡异地赋值了一次。我想，它也许始终指向上一次被alloc/被free的内存的前一个吧。。。我猜测这样设计是为了蕴含一些LRU的思想。不大明白。</p>
<h2 id="m-s-u权限切换"><a href="#m-s-u权限切换" class="headerlink" title="m-s-u权限切换"></a>m-s-u权限切换</h2><p>由os知识可知，机器态、内核态、用户态分别有三种不同的操作权限。xv6是如何对权限切换进行管理的呢？</p>
<p>这部分知识我在正文的一个小地方记录了下来，详见 <a href="https://xiunianjun.github.io/2023/01/10/xv6$chap2/#:~:text=%E5%85%A8%E9%83%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E3%80%82-,%E6%84%9F%E6%83%B3,-%E6%88%91%E7%9A%84%E7%96%91%E7%82%B9%E6%9C%89%E4%B8%89">chapter2 - Code: starting xv6 and the fifirst process - xv6 - 感想</a> 的第二点。</p>
<h2 id="Lock实验的评测机制"><a href="#Lock实验的评测机制" class="headerlink" title="Lock实验的评测机制"></a>Lock实验的评测机制</h2><p>在xv6该次实验中，为了实现评测可视化，引入了statistics机制对结果进行评估。下面，我将通过源码简单介绍其实现机制。</p>
<p>来讲讲这玩意是怎么实现用户态读取锁争用次数的。我们从<code>statistics</code>函数可看出，它的本质是通过读取“文件”，来从内核中读取争用次数的相关数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">statistics</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> sz)</span> &#123;</span><br><span class="line">  fd = open(<span class="string">&quot;statistics&quot;</span>, O_RDONLY);</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> ((n = read(fd, buf+i, sz-i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么安装以前所学的内容，我们很容易联系到这玩意应该并不是个文件，而是类似于proc文件系统那样的虚拟文件。它应该会在open、read中根据其特有的文件类型进行转发。在<code>init.c</code>中，我们可以看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    mknod(<span class="string">&quot;statistics&quot;</span>, STATS, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这玩意的文件结点实际上是在创建console时整的，并且其有一个特殊的文件类型“STATS”。我们可以进一步追溯到kernel中的<code>main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(LAB_PGTBL) || defined(LAB_LOCK)</span></span><br><span class="line">    statsinit();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">statsinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;stats.lock, <span class="string">&quot;stats&quot;</span>);</span><br><span class="line"></span><br><span class="line">  devsw[STATS].read = statsread;</span><br><span class="line">  devsw[STATS].write = statswrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它给这个<code>STATS</code>文件类型注册了这两个函数。当我们调用read和write时，实际上就是在调用这俩玩意。我们可以看下这两个handler都干了啥。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSZ 4096</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> buf[BUFSZ];</span><br><span class="line">  <span class="type">int</span> sz;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">&#125; stats;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">statsread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  acquire(&amp;stats.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(stats.sz == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_LOCK</span></span><br><span class="line">    stats.sz = statslock(stats.buf, BUFSZ); <span class="comment">// 把信息copy进自己的缓冲区里</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  m = stats.sz - stats.off;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果有新东西，就copy到用户缓冲区里</span></span><br><span class="line">    <span class="keyword">if</span>(m &gt; n)	m  = n;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, stats.buf+stats.off, m) != <span class="number">-1</span>) &#123;</span><br><span class="line">      stats.off += m;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    m = <span class="number">-1</span>;</span><br><span class="line">    stats.sz = <span class="number">0</span>;</span><br><span class="line">    stats.off = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;stats.lock);</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">statswrite</span><span class="params">(<span class="type">int</span> user_src, uint64 src, <span class="type">int</span> n)</span> &#123; <span class="comment">// WARNING: READ ONLY!!!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其本质就是把<code>statslock</code>返回的东西copy到用户空间了。我们来结合最后的输出效果看看<code>statslock</code>的具体实现：</p>
<p><img src="/2023/01/10/xv6/image-20231024232632816.png" alt="image-20231024232632816"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">statslock</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> sz)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;lock_locks);</span><br><span class="line">  n = <span class="built_in">snprintf</span>(buf, sz, <span class="string">&quot;--- lock kmem/bcache stats\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NLOCK; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(locks[i] == <span class="number">0</span>)	<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(locks[i]-&gt;name, <span class="string">&quot;bcache&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;bcache&quot;</span>)) == <span class="number">0</span> ||</span><br><span class="line">       <span class="built_in">strncmp</span>(locks[i]-&gt;name, <span class="string">&quot;kmem&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;kmem&quot;</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">      tot += locks[i]-&gt;nts; <span class="comment">// 记入-&gt;nts计数</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        snprint_lock: lock: %s: #fetch-and-add %d #acquire() %d\n</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      n += snprint_lock(buf +n, sz-n, locks[i]);</span><br><span class="line">      found += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Require at least two locks name after kmem/bcache.</span></span><br><span class="line">  <span class="keyword">if</span> (found &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    tot = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 简单粗暴地计算前五多争用的进程</span></span><br><span class="line">  n += <span class="built_in">snprintf</span>(buf+n, sz-n, <span class="string">&quot;--- top 5 contended locks:\n&quot;</span>);</span><br><span class="line">  <span class="type">int</span> last = <span class="number">100000000</span>;</span><br><span class="line">  <span class="comment">// stupid way to compute top 5 contended locks</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; <span class="number">5</span>; t++) &#123;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NLOCK; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(locks[i] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span>(locks[i]-&gt;nts &gt; locks[top]-&gt;nts &amp;&amp; locks[i]-&gt;nts &lt; last) &#123;</span><br><span class="line">        top = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      snprint_lock: lock: %s: #fetch-and-add %d #acquire() %d\n</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    n += snprint_lock(buf+n, sz-n, locks[top]);</span><br><span class="line">    last = locks[top]-&gt;nts;</span><br><span class="line">  &#125;</span><br><span class="line">  n += <span class="built_in">snprintf</span>(buf+n, sz-n, <span class="string">&quot;tot= %d\n&quot;</span>, tot);</span><br><span class="line">  release(&amp;lock_locks);  </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其争用本质计算是通过<code>spinlock::nts</code>字段记录。我们来看看这玩意的引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_LOCK</span></span><br><span class="line">  lk-&gt;nts = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_LOCK</span></span><br><span class="line">    __sync_fetch_and_add(&amp;(lk-&gt;nts), <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   ;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很好，逻辑很简单，就是记录acquire时等待的次数，非常简单粗暴（（（</p>
<p>总的来说这个思路还是挺酷的，而且这个“一切皆文件”的思想再次震撼了我，一个小小的xv6确实能做到那么多。</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/01/10/xv6/">xv6</a>
            
            
            <a class="next" rel="next" href="/2023/01/10/xv6$chap8/">File system</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 修年 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>