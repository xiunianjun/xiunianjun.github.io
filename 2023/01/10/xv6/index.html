<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiunianjun.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="部分地方的翻译和表格来源参考：xv6指导书翻译 实验官网：6.S081 记得结合书本的笔记阅读，这里只记录了一点看心情觉得想记就记的东西以及实验感想。  Operating system interface本节大概是在讲操作系统的接口问题，系统调用占了很大一部分。    系统调用 描述    int fork() 创建一个进程，返回子进程的PID   int exit(int status) 终">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6">
<meta property="og:url" content="https://xiunianjun.github.io/2023/01/10/xv6/index.html">
<meta property="og:site_name" content="修年">
<meta property="og:description" content="部分地方的翻译和表格来源参考：xv6指导书翻译 实验官网：6.S081 记得结合书本的笔记阅读，这里只记录了一点看心情觉得想记就记的东西以及实验感想。  Operating system interface本节大概是在讲操作系统的接口问题，系统调用占了很大一部分。    系统调用 描述    int fork() 创建一个进程，返回子进程的PID   int exit(int status) 终">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230105153458808.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230105164146100.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230105162505574.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230105170701334.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230105171327076.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230105172110475.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230105173019159.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230105173820813.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230105173845317.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230105174832400.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230106172133338.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230109234930690.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230107232802540.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230107233741922.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230108011824655.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230108012316631.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230108013156116.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230108013849664.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230109153937459.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230109151346780.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1eXVhbmRl,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/p3.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230109222917346.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230109225700837.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230109234930690.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230110010651653.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/v2-0c2603da4c8102e46ae390a0d0b1191d_1440w.webp">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230110225359361.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230110231020570.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111000329475.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111004330079.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111004500827.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/p3.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111203357767.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111224927837.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/format,png.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111232323444.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230112012358601.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230112010749756.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230113002057893.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230113002434093.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230113002542335.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230113005100895.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230113012355740.png">
<meta property="article:published_time" content="2023-01-10T12:25:29.000Z">
<meta property="article:modified_time" content="2023-01-14T06:46:56.001Z">
<meta property="article:author" content="修年">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230105153458808.png">

<link rel="canonical" href="https://xiunianjun.github.io/2023/01/10/xv6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>xv6 | 修年</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">修年</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiunianjun.github.io/2023/01/10/xv6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="修年">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修年">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          xv6
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-10 20:25:29" itemprop="dateCreated datePublished" datetime="2023-01-10T20:25:29+08:00">2023-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-14 14:46:56" itemprop="dateModified" datetime="2023-01-14T14:46:56+08:00">2023-01-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>部分地方的翻译和表格来源参考：<a target="_blank" rel="noopener" href="http://xv6.dgs.zone/">xv6指导书翻译</a></p>
<p>实验官网：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/tools.html">6.S081</a></p>
<p>记得结合书本的笔记阅读，这里只记录了一点看心情觉得想记就记的东西以及实验感想。</p>
</blockquote>
<h1 id="Operating-system-interface"><a href="#Operating-system-interface" class="headerlink" title="Operating system interface"></a>Operating system interface</h1><p>本节大概是在讲操作系统的接口问题，系统调用占了很大一部分。</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>int fork()</code></td>
<td>创建一个进程，返回子进程的PID</td>
</tr>
<tr>
<td><code>int exit(int status)</code></td>
<td>终止当前进程，并将状态报告给wait()函数。无返回</td>
</tr>
<tr>
<td><code>int wait(int *status)</code></td>
<td>等待一个子进程退出; 将退出状态存入*status; 返回子进程PID。</td>
</tr>
<tr>
<td><code>int kill(int pid)</code></td>
<td>终止对应PID的进程，返回0，或返回-1表示错误</td>
</tr>
<tr>
<td><code>int getpid()</code></td>
<td>返回当前进程的PID</td>
</tr>
<tr>
<td><code>int sleep(int n)</code></td>
<td>暂停n个时钟节拍</td>
</tr>
<tr>
<td><code>int exec(char *file, char *argv[])</code></td>
<td>加载一个文件并使用参数执行它; 只有在出错时才返回</td>
</tr>
<tr>
<td><code>char *sbrk(int n)</code></td>
<td>按n 字节增长进程的内存。返回新内存的开始</td>
</tr>
<tr>
<td><code>int open(char *file, int flags)</code></td>
<td>打开一个文件；flags表示read/write；返回一个fd（文件描述符）</td>
</tr>
<tr>
<td><code>int write(int fd, char *buf, int n)</code></td>
<td>从buf 写n 个字节到文件描述符fd; 返回n</td>
</tr>
<tr>
<td><code>int read(int fd, char *buf, int n)</code></td>
<td>将n 个字节读入buf；返回读取的字节数；如果文件结束，返回0</td>
</tr>
<tr>
<td><code>int close(int fd)</code></td>
<td>释放打开的文件fd</td>
</tr>
<tr>
<td><code>int dup(int fd)</code></td>
<td>返回一个新的文件描述符，指向与fd 相同的文件</td>
</tr>
<tr>
<td><code>int pipe(int p[])</code></td>
<td>创建一个管道，把read/write文件描述符放在p[0]和p[1]中</td>
</tr>
<tr>
<td><code>int chdir(char *dir)</code></td>
<td>改变当前的工作目录</td>
</tr>
<tr>
<td><code>int mkdir(char *dir)</code></td>
<td>创建一个新目录</td>
</tr>
<tr>
<td><code>int mknod(char *file, int, int)</code></td>
<td>创建一个设备文件</td>
</tr>
<tr>
<td><code>int fstat(int fd, struct stat *st)</code></td>
<td>将打开文件fd的信息放入*st</td>
</tr>
<tr>
<td><code>int stat(char *file, struct stat *st)</code></td>
<td>将指定名称的文件信息放入*st</td>
</tr>
<tr>
<td><code>int link(char *file1, char *file2)</code></td>
<td>为文件file1创建另一个名称(file2)</td>
</tr>
<tr>
<td><code>int unlink(char *file)</code></td>
<td>删除一个文件</td>
</tr>
</tbody></table>
<p> 表1.2：xv6系统调用（除非另外声明，这些系统调用返回0表示无误，返回-1表示出错）</p>
<h2 id="Process-and-memory"><a href="#Process-and-memory" class="headerlink" title="Process and memory"></a>Process and memory</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child&#x27;s pid = %d\n&quot;</span>,pid);</span><br><span class="line">    pid = wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done.\n&quot;</span>,pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child : exiting\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个利用fork的返回值对于父子进程来说不同这一特点进行编写的例程。其中比较不熟的还是wait(0)这一句的用法。这点具体可以看书中笔记和上面的系统调用表。</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>exec是一个系统调用，它跟exe文件被执行的原理密切相关。当程序调用exec，就会跳转到exec参数文件去执行，原程序exec下面的指令都不再被执行，除非exec因错误而退出。</p>
<h3 id="exec与fork"><a href="#exec与fork" class="headerlink" title="exec与fork"></a>exec与fork</h3><p>由shell的源码中main函数这一段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read and run input commands.</span></span><br><span class="line"><span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">    <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">    runcmd(parsecmd(buf));</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(cmd-&gt;type)&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> EXEC:</span><br><span class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</span><br><span class="line">    exec(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;exec %s failed\n&quot;</span>, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到shell其实本质上就是这样的架构架构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(读到了command&amp;&amp;fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        exec(command);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;失败信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即父进程创建出子进程来执行command，并且父进程等待子进程执行完再继续等待输入。</p>
<p>可以看到，fork和exec的使用是非常紧密的，联合使用也是非常顺理成章的。那么，如果干从fork的exec的对于内存管理的原理来讲，就会不免产生一点问题。</p>
<blockquote>
<p>问题描述：</p>
<p>fork的内存原理，实质上是开辟一片新的与父进程等大的内存空间，然后把父进程的数据都copy一份进这个新内存空间。exec的原理是用一片可以容纳得下文件指令及其所需空间的内存空间去替代调用进程原有的那片内存空间。</p>
<p>可以看到，如果fork和exec接连使用，理论上其实是会产生一点浪费的，fork创建子进程复制完了一片内存空间，这片新复制的内存空间又马上被扔掉了，取而代之的用的是exec的内存空间。</p>
</blockquote>
<p>为了解决这个问题，kernel使用了copy-on-write技术优化。</p>
<h2 id="I-O-and-File-descriptors"><a href="#I-O-and-File-descriptors" class="headerlink" title="I/O and File descriptors"></a>I/O and File descriptors</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>句柄就是一个int值，它代表了一个由内核管理的，可以被进程读写的对象.</p>
<blockquote>
<p>A process may obtain a fifile descriptor by opening a <strong>file</strong>, <strong>directory</strong>, or <strong>device</strong>, or by creating a <strong>pipe</strong>, or by <strong>duplicating</strong> an existing descriptor.</p>
</blockquote>
<p>每个进程的其三个句柄有默认值：</p>
<blockquote>
<p>By convention, a process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error). </p>
</blockquote>
<p>句柄0对应着standard input，1对应着standard output，2对应着standard error。</p>
<h3 id="read、write"><a href="#read、write" class="headerlink" title="read、write"></a>read、write</h3><p>read和write的参数都是句柄，buf，读/写长度。都会导致文件指针的移动。使用如下例程【类似cat的原理】：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    n = read(<span class="number">0</span>);<span class="comment">//从标准输入读</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(write(<span class="number">1</span>,buf,n) != n)&#123;<span class="comment">//向标准输出写</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>close函数释放了一个句柄，以后它释放掉的这个句柄就可以被用来表示别的文件了。</p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p>open函数会给参数的file分配一个句柄。这个句柄通常是目前空闲的句柄中值最小的那个。</p>
<h3 id="重定向的实现"><a href="#重定向的实现" class="headerlink" title="重定向的实现"></a>重定向的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argc[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>,argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xv6的重定向实现跟这个原理差不多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> REDIR:</span><br><span class="line">  rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">  close(rcmd-&gt;fd);</span><br><span class="line">  <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;open %s failed\n&quot;</span>, rcmd-&gt;file);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  runcmd(rcmd-&gt;cmd);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="共享偏移量"><a href="#共享偏移量" class="headerlink" title="共享偏移量"></a>共享偏移量</h3><p>fork出来的父子进程同一个句柄对同一个文件的偏移量是相同的，这个原理应该是因为，父子进程共享的是文件句柄这个结构体对象本身，也就是拷贝的时候是浅拷贝而不是深拷贝。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	wait(<span class="number">0</span>);</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p><code>dup</code>系统调用复制一个现有的文件描述符，返回一个引用自同一个底层I/O对象的新文件描述符。</p>
<p>dup和open一样，都是会占用一个新的句柄的，而且都是优先分配数值小的。比如说fd = dup(3)，得到fd=4，那么结果就是句柄3和句柄4指向同一个文件，并且偏移量一样。</p>
<p>dup可以让这样的指令变得可以实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个指令的意思是，先把stderr的结果重定向到stdout，再把stdout的结果重定向到tmp1中。</p>
<p>关于2&gt;&amp;1的解释，可以看这个 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38500662/article/details/84973518">shell中的”2&gt;&amp;1”是什么意思？</a></p>
</blockquote>
<p>这个的实现就要用到dup了。我们会fork一个子进程，在子进程里面close(2)，然后再dup(1)。这样一来，我们就成功实现了句柄1和2指向同一个文件</p>
<h2 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>int pipe(int p[]) 创建一个管道，把read/write文件描述符放在p[0]和p[1]中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span>* argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>],<span class="string">&quot;hello world\n&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成了父进程-pipe-子进程的一个重定向。</p>
<p>pipe是阻塞的生产者消费者模式。对管道的read，在没有数据输入时会阻塞，直到读到数据，或者所有的write方向都被关闭。示例代码中，如果不使用pipe就需要显示close(p[0]) close(p[1])，正是为了防止没有数据输入时write方向不为0导致死锁的情况出现。</p>
<h3 id="实现管道命令"><a href="#实现管道命令" class="headerlink" title="实现管道命令"></a>实现管道命令</h3><p>管道命令的实现正是通过pipe。</p>
<p>执行原理就是，创建两个子进程分别执行左右两侧的句子，然后左侧子进程的out重定向到pip的write，右侧子进程的in重定向到pip的read。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">case</span> PIPE:</span><br><span class="line">   pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">   <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">     panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line"><span class="comment">//左</span></span><br><span class="line">   <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">     close(<span class="number">1</span>);</span><br><span class="line">     dup(p[<span class="number">1</span>]);</span><br><span class="line">     close(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">1</span>]);</span><br><span class="line">     runcmd(pcmd-&gt;left);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//右</span></span><br><span class="line">   <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">     close(<span class="number">0</span>);</span><br><span class="line">     dup(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">1</span>]);</span><br><span class="line">     runcmd(pcmd-&gt;right);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中</span></span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line">   close(p[<span class="number">1</span>]);</span><br><span class="line">   <span class="comment">//wait</span></span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">   wait(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这实际上是二叉树的左右中递归过程。</p>
<blockquote>
<p>附：对于管道命令的解读</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat a.txt | echo</span><br></pre></td></tr></table></figure>

<p>我的本意是觉得，这意思就是把cat a.txt的输出连到echo的输入，这个命令结果跟cat a.txt是没什么差的。但具体执行出来发现最后的结果却是跟：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo</span><br></pre></td></tr></table></figure>

<p>这个指令的效果是一样的，也就是cat a.txt的output，即echo的input完全被丢弃了。</p>
<p>我想这是因为，echo这个命令的执行过程并没有用到stdin，仅仅用到了参数，也就是说管道read端的接入对它并没有什么影响。</p>
<p>这也是为啥</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 10 | echo hi</span><br></pre></td></tr></table></figure>

<p>这个命令最后的结果是，秒速出hi，然后等待10s后结束，了。由于echo的输出与stdin没有关系，所以，echo不会阻塞读入stdin，等待管道关闭，而是会即刻输出hi。</p>
</blockquote>
<p>管道实际上就相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo hello world | wc</span><br><span class="line">echo hello world &gt; /tmp/xyz; wc &lt; /tmp/xyz</span><br></pre></td></tr></table></figure>

<p>在这种情况下，管道相比临时文件至少有四个优势</p>
<ul>
<li>首先，不用删文件</li>
<li>其次，管道可以任意传递长的数据流</li>
<li>第三，管道允许一定程度上的并行</li>
<li>第四，如果实现进程间通讯，管道的块读写比文件的非块语义更有效率。</li>
</ul>
<h2 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h2><p>inode：代表文件本体，包括文件类型、文件长度、文件内容在磁盘位置、文件的链接数</p>
<p>link：指向文件的链接，一个文件可以有多个link，link内包含文件名和对inode的引用</p>
<p>当链接数=0，且句柄数=0，文件的磁盘空间和inode索引就会被释放</p>
<h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><h3 id="虚拟机准备"><a href="#虚拟机准备" class="headerlink" title="虚拟机准备"></a>虚拟机准备</h3><h4 id="vmware"><a href="#vmware" class="headerlink" title="vmware"></a>vmware</h4><p>使用的是rcore给的盘：</p>
<p>D:\aWorkStorage\etc\ubuntu\oslab.vmdk</p>
<p>过程还是几经波折的。在这里记录下我踩的坑和解决办法吧。</p>
<h5 id="账号密码"><a href="#账号密码" class="headerlink" title="账号密码"></a>账号密码</h5><blockquote>
<p>账号：oslab</p>
<p>密码：oslab</p>
</blockquote>
<h5 id="怎么使用vmdk文件"><a href="#怎么使用vmdk文件" class="headerlink" title="怎么使用vmdk文件"></a>怎么使用vmdk文件</h5><p><a target="_blank" rel="noopener" href="http://t.zoukankan.com/lxml-p-13879978.html">新建虚拟机（.vmdk）导入Vmware</a></p>
<p>看这个就够了。</p>
<h4 id="阿里云服务器-XShell"><a href="#阿里云服务器-XShell" class="headerlink" title="阿里云服务器+XShell"></a>阿里云服务器+XShell</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45851575/article/details/122987929">手把手系列–Xshell连接阿里云服务器</a></p>
<h4 id="ubuntu系统忘记密码了怎么办"><a href="#ubuntu系统忘记密码了怎么办" class="headerlink" title="ubuntu系统忘记密码了怎么办"></a>ubuntu系统忘记密码了怎么办</h4><p>需要进入grub模式修改密码。</p>
<h5 id="如何进入grub模式"><a href="#如何进入grub模式" class="headerlink" title="如何进入grub模式"></a>如何进入grub模式</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44488927/article/details/125793756">VMware虚拟机忘记Linux用户登陆密码，重置密码解决办法</a></p>
<p>尤其注意需要在重新启动的那次才能按E，而且按的是shift+E大写E。</p>
<h5 id="进入grub模式后按什么"><a href="#进入grub模式后按什么" class="headerlink" title="进入grub模式后按什么"></a>进入grub模式后按什么</h5><p>先按个advance-recovery mod，接下来按这个操作：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liranke/article/details/25203927">操作系统实践-在Ubuntu recovery模式下找回密码</a></p>
<p>就ok了。</p>
<h4 id="连不了网"><a href="#连不了网" class="headerlink" title="连不了网"></a>连不了网</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiesunliu3215/article/details/125021892">Ubuntu连接不了网络的解决方法（第二种亲测可行)</a></p>
<h3 id="配置实验环境"><a href="#配置实验环境" class="headerlink" title="配置实验环境"></a>配置实验环境</h3><blockquote>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_25356929/article/details/113747023">xv6环境搭建</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/nAJvZNWoJr/">【MIT6.S081/6.828】手把手教你搭建开发环境</a></p>
</blockquote>
<h4 id="下载工具链"><a href="#下载工具链" class="headerlink" title="下载工具链"></a>下载工具链</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span> </span><br></pre></td></tr></table></figure>

<p>测试安装ok：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 --version</span></span><br><span class="line">QEMU emulator version 5.1.0</span><br><span class="line">//下面其中之一正常就行</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-linux-gnu-gcc --version</span></span><br><span class="line">riscv64-linux-gnu-gcc (Debian 10.3.0-8) 10.3.0</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-unknown-elf-gcc --version</span></span><br><span class="line">riscv64-unknown-elf-gcc (GCC) 10.1.0</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-unknown-linux-gnu-gcc --version</span></span><br><span class="line">riscv64-unknown-linux-gnu-gcc (GCC) 10.1.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注，这里出现了一个问题，<code>qemu-system-riscv64 --version</code>打出来发现qemu-system-riscv64 command not found。似乎是我的ubuntu16.04版本太低了【悲】去看了下网上，可以按照这个来做：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_49270962/article/details/118052926">rCore qemu risc-v 实验环境配置</a></p>
</blockquote>
<h4 id="下载编译xv6源码"><a href="#下载编译xv6源码" class="headerlink" title="下载编译xv6源码"></a>下载编译xv6源码</h4><p>随后，进入一个你喜欢的文件夹clone xv6的实验源码，输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> xv6-labs-2020</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout util</span></span><br></pre></td></tr></table></figure>

<p>然后进行编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br></pre></td></tr></table></figure>

<p>如果此处发生错误：<code>unrecognized command line option -mno-relax</code>，则按照此说法 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_25356929/article/details/113747023">xv6环境搭建</a>更新gcc版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install gcc-8-riscv64-linux-gnu</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo update-alternatives --install /usr/bin/riscv64-linux-gnu-gcc riscv64-linux-gnu-gcc /usr/bin/riscv64-linux-gnu-gcc-8 8</span></span><br></pre></td></tr></table></figure>

<p>再执行一次</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br></pre></td></tr></table></figure>

<p>就ok了。</p>
<h4 id="关闭qemu"><a href="#关闭qemu" class="headerlink" title="关闭qemu"></a>关闭qemu</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_67090393/article/details/126975993">qemu退出操作</a></p>
<p>在这里记个强制方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -elf | grep qemu</span><br></pre></td></tr></table></figure>

<img src="/2023/01/10/xv6/image-20230105153458808.png" class>

<p>记住第二个的pid</p>
<p>然后</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 3303</span><br></pre></td></tr></table></figure>

<h4 id="测试gdb是否ok"><a href="#测试gdb是否ok" class="headerlink" title="测试gdb是否ok"></a>测试gdb是否ok</h4><p>见该文章最后一部分</p>
<p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/nAJvZNWoJr/">【MIT6.S081/6.828】手把手教你搭建开发环境</a></p>
<h4 id="自测方法"><a href="#自测方法" class="headerlink" title="自测方法"></a>自测方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make grade</span><br></pre></td></tr></table></figure>

<p>或者如果只想测其中一个，可以：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./grade-lab-util sleep</span><br></pre></td></tr></table></figure>

<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><h4 id="编写sleep-c"><a href="#编写sleep-c" class="headerlink" title="编写sleep.c"></a>编写sleep.c</h4><blockquote>
<p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p>
<img src="/2023/01/10/xv6/image-20230105164146100.png" class>
</blockquote>
<h5 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h5><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><p>注意，他要求我们实现的sleep的参数是<strong>ticks的数量</strong>，不是秒数。我花了半天找时钟周期大小这个参数在哪，找了许久没找到，估计是没考虑到这一点。</p>
<p>比如说，我翻了一下linux0.11的源码，在include/linux/time.h下有这句：</p>
<img src="/2023/01/10/xv6/image-20230105162505574.png" class>

<p>说明了时钟频率大小。在xv6好像没有看到对这个的显式说明。</p>
<h6 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h6><p>感受了一下xv6的系统调用过程，跟linux0.11还是很相像的。</p>
<p>这个好像是lab2的内容，我暂且先在此放下我体会到的感受。</p>
<ol>
<li><p>xv6</p>
<p>首先是从用户态到内核态的切换。</p>
<p>在user/user.h中有各个系统调用外化的函数签名。在用户程序中调用里面的函数签名，就会执行【说实话，我没看懂为什么这里会知道要从user.h跳到usys.S中执行，也许是Makefile里有写？】user/usys.S中对应的汇编代码，比如说这种：</p>
<img src="/2023/01/10/xv6/image-20230105170701334.png" class>

<p>然后这个SYS_close这种，其实是系统调用号宏，被定义在kernel/syscall.h中：</p>
<img src="/2023/01/10/xv6/image-20230105171327076.png" class>

<p><code>li a7,SYS_call</code>就是把SYS_call的值放入a7寄存器，大概就是传参的意思。<code>ecall</code>是从用户态转到内核态的指令。这样一来，就完成了从用户态到内核态的切换。</p>
<p>然后是在内核态的执行。</p>
<p>切换到内核态之后的执行步骤跟linux0.11可以说是完全一样。</p>
<p>首先应该是会去执行kernel/syscall.c中的syscall函数，具体应该是通过ecall引发0x80中断，然后查表得知这个syscall是中断处理函数</p>
<img src="/2023/01/10/xv6/image-20230105172110475.png" class>

<p>可以看到，syscall获取了a7里的参数，然后查了系统调用表</p>
<img src="/2023/01/10/xv6/image-20230105173019159.png" class>

<p>然后去sysproc.c文件下执行相应的sys_xxx函数。这个函数指针用得真是牛逼。</p>
<p>再然后，sys_xxx函数中会从栈中取出调用参数，再跳转到xxx(args)函数中去（这些xxx函数一般在kernel中以单独文件形式出现）。</p>
<p>这样一来，就完成了一次系统调用。</p>
</li>
<li><p>linux0.11</p>
<p>首先是用户态到内核态的切换。</p>
<p>在用户态中比方说调用system call close()，则会调用lib/close.c下的：</p>
<img src="/2023/01/10/xv6/image-20230105173820813.png" class>

<p>展开这个宏之后，是这样的：</p>
<img src="/2023/01/10/xv6/image-20230105173845317.png" class>

<p>具体意思就是把close的系统调用号存入参数寄存器，然后引发0x80中断，进入内核态。</p>
<p>然后是在内核态的执行。</p>
<p>查表会得知sys_call函数是0x80中断的中断处理函数，然后就会根据参数里的系统调用名字去找系统调用表执行</p>
<img src="/2023/01/10/xv6/image-20230105174832400.png" class>

<p>这部分跟xv6差不多，不再赘述</p>
</li>
</ol>
<p>可见，这两个系统在内核态的实现是差不多的，只是在用户态有点稍稍不一样。感觉linux0.11会更加精妙一些。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>附上代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//argc应该指的是arg count，包含了arg[0]（命令名称）</span></span><br><span class="line">  <span class="comment">//如果命令为“sleep”，那么就输出“sleep: missing operand”</span></span><br><span class="line">  <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;sleep:missing operand\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sleep(atoi(argv[i]))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;sleep:there has something wromng.Stop running.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写pingpong程序"><a href="#编写pingpong程序" class="headerlink" title="编写pingpong程序"></a>编写pingpong程序</h4><blockquote>
<p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a <strong>pair of pipes</strong>, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</pid></pid></pid></p>
</blockquote>
<h5 id="体会-1"><a href="#体会-1" class="headerlink" title="体会"></a>体会</h5><p>思路很简单，我之所以写了那么久是因为走了好大的弯路……</p>
<p>题目要求输出格式为”<pid>: received ping”，我的思路固化为：先把pid化成数字，再用字符串拼接串成整个。为了实现我的思路，我就需要额外再写两个工具函数，一个是itoa，一个是strcat。而又由于malloc函数暂待实现，itoa和strcat的实现就仍然不够优雅。折腾了半天终于OK了，结果看到别人是怎么做到这个输出格式的呢？↓</pid></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%d: received ping\n&quot;</span>,getpid());</span><br></pre></td></tr></table></figure>

<p>这下是真的尴尬了23333</p>
<p>但总而言之，自己写了那俩不够优雅的函数还算是有点用【大概】。以下是我的代码</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><h6 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h6><p>这三个函数都在<code>user/ulib.c</code>下。记得要在<code>user/user.h</code>中登记它们的签名。</p>
<p>由于使用不了malloc，所以实现会稍显复杂。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ensure_itoa_capacity</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        num = -num;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itoa</span><span class="params">(<span class="type">int</span> num,<span class="type">char</span>* res)</span>&#123;</span><br><span class="line">    <span class="type">char</span> res_tmp[<span class="built_in">strlen</span>(res)+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp = num;</span><br><span class="line">    <span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        tmp = -tmp;</span><br><span class="line">        res[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">        res_tmp[j++] = tmp%<span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        tmp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=j<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        res[i++] = res_tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">    res[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* s1,<span class="type">const</span> <span class="type">char</span>* s2)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">memcpy</span>(buf,s1,<span class="built_in">strlen</span>(s1));</span><br><span class="line">    <span class="built_in">memcpy</span>(buf+<span class="built_in">strlen</span>(s1),s2,<span class="built_in">strlen</span>(s2)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> byte[<span class="number">1</span>];</span><br><span class="line">    byte[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> p2[<span class="number">2</span>];</span><br><span class="line">    pipe(p1);</span><br><span class="line">    pipe(p2);</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">//接收ping的一个byte</span></span><br><span class="line">	close(p1[<span class="number">1</span>]);</span><br><span class="line">	read(p1[<span class="number">0</span>],byte,<span class="number">1</span>);</span><br><span class="line">	close(p1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造输出字符串并输出</span></span><br><span class="line">	<span class="type">int</span> pid = getpid();</span><br><span class="line">        <span class="type">char</span> pid_str[ensure_itoa_capacity(pid)];</span><br><span class="line">	itoa(pid,pid_str);	</span><br><span class="line">	<span class="type">char</span> meg_str[] = <span class="string">&quot;: received ping\n&quot;</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="built_in">strlen</span>(pid_str)+<span class="built_in">strlen</span>(meg_str)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcat</span>(buf,pid_str,meg_str);		</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="number">1</span>,buf);</span><br><span class="line">	<span class="comment">//fprintf(1,&quot;%d: received ping\n&quot;,getpid());</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//子进程发送pong</span></span><br><span class="line">	close(p2[<span class="number">0</span>]);</span><br><span class="line">	write(p2[<span class="number">1</span>],byte,<span class="number">1</span>);</span><br><span class="line">	close(p2[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	close(p1[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//p1的write端由父进程拿着</span></span><br><span class="line">	write(p1[<span class="number">1</span>],byte,<span class="number">1</span>);</span><br><span class="line">	close(p1[<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">//读取pong</span></span><br><span class="line">	close(p2[<span class="number">1</span>]);</span><br><span class="line">	read(p2[<span class="number">0</span>],byte,<span class="number">1</span>);</span><br><span class="line">	close(p2[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//构造</span></span><br><span class="line">	<span class="type">int</span> pid = getpid();</span><br><span class="line">        <span class="type">char</span> pid_str[ensure_itoa_capacity(pid)];</span><br><span class="line">	itoa(pid,pid_str);	</span><br><span class="line">	<span class="type">char</span> meg_str[] = <span class="string">&quot;: received pong\n&quot;</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="built_in">strlen</span>(pid_str)+<span class="built_in">strlen</span>(meg_str)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcat</span>(buf,pid_str,meg_str);		</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="number">1</span>,buf);</span><br><span class="line">	<span class="comment">//fprintf(1,&quot;%d: received pong\n&quot;,getpid());</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写primes"><a href="#编写primes" class="headerlink" title="编写primes"></a>编写primes</h4><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.ewbang.com/community/article/details/960672708.html">MIT操作系统实验lab1（案例：primes（质数筛选）附代码、详解）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/frost5/article/details/114933307">XV6实验-Lab0 Utilities</a></p>
</blockquote>
<blockquote>
<p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a target="_blank" rel="noopener" href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p>
</blockquote>
<p>其实就是用生产者消费者模式来写素数计算的并发版本，这个我熟</p>
<p>……以上是第一印象。然后我看着超链接文章里的素数筛的图片，以及指导书给的提示：</p>
<blockquote>
<p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p>
<ul>
<li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li>
</ul>
</blockquote>
<p>义无反顾地……使用了35个管道hhhhh</p>
<p>然后不知道为什么不行，也焦头烂额地感觉我思路太离谱了，去看了下发现大家都是只用一个管道……</p>
<p>我也搞了个单管道的出来，但是思路受第一篇的影响非常地串行，也即先筛完再创建子进程。看到</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/frost5/article/details/114933307">XV6实验-Lab0 Utilities</a></p>
<p>这篇文章，才发现还可以那样双管道并行……我虽然也考虑过双管道，但是觉得实现不了【因为我是用循环的思路，如果要双管道的话切换会很麻烦】就没写了，没想到还可以向他那样【他选择的是一个在外部定义的p，和一个作用域更小在每次循环内定义的p1，再加上递归传递参数这个技巧，就可以接连不断递归下去了】，深感佩服。写得是真好，可以去参考学习一下，我懒得改了（</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">	pipe(p);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="type">char</span> buf[<span class="number">3</span>];</span><br><span class="line">			<span class="comment">//读入第一个数字 </span></span><br><span class="line">			read(p[<span class="number">0</span>],buf,<span class="number">3</span>);</span><br><span class="line">			<span class="type">int</span> prime = atoi(buf);</span><br><span class="line">			<span class="keyword">if</span>(prime == <span class="number">36</span>)&#123;</span><br><span class="line">				close(p[<span class="number">0</span>]);</span><br><span class="line">				close(p[<span class="number">1</span>]);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;prime %d\n&quot;</span>,prime);</span><br><span class="line">			<span class="comment">//读入其他数字 </span></span><br><span class="line">			<span class="type">int</span> tmp = atoi(buf);</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">				read(p[<span class="number">0</span>],buf,<span class="number">3</span>);</span><br><span class="line">				tmp = atoi(buf);</span><br><span class="line">                <span class="comment">//输入结束</span></span><br><span class="line">				<span class="keyword">if</span>(tmp == <span class="number">36</span>)&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(tmp%prime!=<span class="number">0</span>)&#123;</span><br><span class="line">					write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//作为标记，标志着输入序列结束</span></span><br><span class="line">			itoa(<span class="number">36</span>,buf);</span><br><span class="line">			write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">			<span class="keyword">if</span>(fork())&#123;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				close(p[<span class="number">0</span>]);</span><br><span class="line">				close(p[<span class="number">1</span>]);</span><br><span class="line">				wait(<span class="number">0</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		close(p[<span class="number">0</span>]);</span><br><span class="line">		<span class="type">char</span> buf[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)&#123;</span><br><span class="line">			itoa(i,buf);</span><br><span class="line">			write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//作为标记，标志着输入序列结束</span></span><br><span class="line">		itoa(<span class="number">36</span>,buf);</span><br><span class="line">		write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">		close(p[<span class="number">1</span>]);</span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写find"><a href="#编写find" class="headerlink" title="编写find"></a>编写find</h4><blockquote>
<p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p>
</blockquote>
<h5 id="初始版"><a href="#初始版" class="headerlink" title="初始版"></a>初始版</h5><p>直接照着ls的模板改，改成递归就ok了。值得注意的是，目录也是一种文件，也可以通过read读取。目录文件的内容就是目录里的所有文件的名字。因而，我们在递归时可以忽略文件，只对目录处理，因为目录中就包含着所有文件名的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取出类似/root/home/a.txt中的a.txt</span></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27;\0&#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path,<span class="type">char</span>* key)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(st.type == T_DIR)&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">	  close(fd);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fmtname(buf),<span class="string">&quot;.&quot;</span>)!=<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(fmtname(buf),<span class="string">&quot;..&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">    	find(buf,key);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fmtname(buf),key) == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;find: have no arg.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="附加题：支持正则表达式"><a href="#附加题：支持正则表达式" class="headerlink" title="附加题：支持正则表达式"></a>附加题：支持正则表达式</h5><p>把user/grep.c里面的匹配函数拿来就行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">matchstar</span><span class="params">(<span class="type">int</span> c, <span class="type">char</span> *re, <span class="type">char</span> *text)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">matchhere</span><span class="params">(<span class="type">char</span> *re, <span class="type">char</span> *text)</span>;</span><br><span class="line"><span class="comment">//正則匹配函數</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">match</span><span class="params">(<span class="type">char</span> *re, <span class="type">char</span> *text)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> matchhere(re+<span class="number">1</span>, text);</span><br><span class="line">  <span class="keyword">do</span>&#123;  <span class="comment">// must look at empty string</span></span><br><span class="line">    <span class="keyword">if</span>(matchhere(re, text))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(*text++ != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchhere: search for re at beginning of text</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">matchhere</span><span class="params">(<span class="type">char</span> *re, <span class="type">char</span> *text)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> matchstar(re[<span class="number">0</span>], re+<span class="number">2</span>, text);</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">&#x27;$&#x27;</span> &amp;&amp; re[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> *text == <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span>(*text!=<span class="string">&#x27;\0&#x27;</span> &amp;&amp; (re[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span> || re[<span class="number">0</span>]==*text))</span><br><span class="line">    <span class="keyword">return</span> matchhere(re+<span class="number">1</span>, text+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchstar: search for c*re at beginning of text</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">matchstar</span><span class="params">(<span class="type">int</span> c, <span class="type">char</span> *re, <span class="type">char</span> *text)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;  <span class="comment">// a * matches zero or more instances</span></span><br><span class="line">    <span class="keyword">if</span>(matchhere(re, text))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(*text!=<span class="string">&#x27;\0&#x27;</span> &amp;&amp; (*text++==c || c==<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出类似/root/home/a.txt中的a.txt</span></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27;\0&#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path,<span class="type">char</span>* key)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(st.type == T_DIR)&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fmtname(buf),<span class="string">&quot;.&quot;</span>)!=<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(fmtname(buf),<span class="string">&quot;..&quot;</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(match(fmtname(buf),key))&#123;</span><br><span class="line">	    	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">      	&#125;</span><br><span class="line"></span><br><span class="line">    	find(buf,key);</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">//if(strcmp(fmtname(buf),key) == 0)&#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;find: have no arg.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写xargs"><a href="#编写xargs" class="headerlink" title="编写xargs"></a>编写xargs</h4><blockquote>
<p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p>
</blockquote>
<h5 id="体会-2"><a href="#体会-2" class="headerlink" title="体会"></a>体会</h5><p>思路还是很直观的，就是从stdin一行一行读入数据，然后把这数据处理成参数，最后调用exec就行。就是中间有很多小细节值得注意。</p>
<p>有一点比较坑的是，main方法的那个argc的计算方法是这样的，不是直接用数组的长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) </span><br></pre></td></tr></table></figure>

<p>可以看到，合格的argv的形式应该是：参1 参2 参3 “\0”，最后一个元素要以”\0”标志结束。</p>
<p>这个应该是编写者约定俗成的。在user/sh.c的parseexec，大概445行左右：</p>
<img src="/2023/01/10/xv6/image-20230106172133338.png" class>

<p>shell处理命令时是会默认把最后一个清零的。</p>
<blockquote>
<p>确实，后面在学内存的时候，用户空间的构成如图所示：</p>
<img src="/2023/01/10/xv6/image-20230109234930690.png" class>

<p>可以看到栈那边，参数列完了之后是会有一个用以terminate的空指针的</p>
</blockquote>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// for(int i=0;i&lt;argc;i++)	fprintf(1,&quot;argv[%d] = %s\n&quot;,i,argv[i]);</span></span><br><span class="line">    <span class="comment">//之所以写得这么曲折，是因为数组是const指针不能变值</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line">    <span class="type">char</span>* buf = buffer; </span><br><span class="line">    <span class="type">char</span>* start = buf;</span><br><span class="line">    <span class="comment">//如果xargs没有参数，就开启复读模式</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="keyword">while</span>((n = read(<span class="number">0</span>,buf,<span class="number">512</span>)))&#123;</span><br><span class="line">	    	write(<span class="number">1</span>,buf,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个必须写在外面，不能定义在下面的if体里，不然出了作用域就会被回收，不能作为参数的一员参与进exec，会变成很可怕的乱码。</span></span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">512</span>];</span><br><span class="line">    <span class="comment">//MAXARG为定义在kernel/param.h下的参数，代表参数最多值</span></span><br><span class="line">    <span class="type">char</span>* new_argv[MAXARG] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    argc--;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++)&#123;</span><br><span class="line">		new_argv[i] = argv[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(read(<span class="number">0</span>,buf,<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="comment">//fprintf(1,&quot;buf[0] is : %c\n&quot;,buf[0]);</span></span><br><span class="line">        <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(tmp,start,buf-start);</span><br><span class="line">            tmp[buf-start] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            new_argv[i++] = tmp;</span><br><span class="line">            argc++;</span><br><span class="line">            buf = start;</span><br><span class="line">           <span class="comment">// fprintf(1,&quot;tmp is :%s\n&quot;,tmp);</span></span><br><span class="line">            <span class="comment">//fprintf(1,&quot;new_argv[i-1] is :%s\n&quot;,new_argv[i-1]);</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            buf ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// fprintf(1,&quot;argc = %d\n&quot;,argc);</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    	exec(new_argv[<span class="number">0</span>],new_argv);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="附加题：改善shell"><a href="#附加题：改善shell" class="headerlink" title="附加题：改善shell"></a>附加题：改善shell</h4><p>看起来又难又多所以我先摸了【润】等之后有时间再回来弄吧</p>
<h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;utils&quot;</span><br></pre></td></tr></table></figure>



<h1 id="Operating-system-oganization"><a href="#Operating-system-oganization" class="headerlink" title="Operating system oganization"></a>Operating system oganization</h1><blockquote>
<p>Before you start coding, read Chapter 2 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev1.pdf">xv6 book</a>, and Sections 4.3 and 4.4 of Chapter 4, and related source files:</p>
<ul>
<li>The user-space code for systems calls is in <code>user/user.h</code> and <code>user/usys.pl</code>.</li>
<li>The kernel-space code is <code>kernel/syscall.h</code>, kernel/syscall.c.</li>
<li>The process-related code is <code>kernel/proc.h</code> and <code>kernel/proc.c</code>.</li>
</ul>
</blockquote>
<p>这章主要是讲了操作系统为了兼顾并发性、隔离性、交互性做出的基本架构。</p>
<h2 id="Kernel-organization"><a href="#Kernel-organization" class="headerlink" title="Kernel organization"></a>Kernel organization</h2><h3 id="宏内核与微内核"><a href="#宏内核与微内核" class="headerlink" title="宏内核与微内核"></a>宏内核与微内核</h3><p>操作系统一个很重要的设计问题就是，哪部分的代码需要run在内核态，哪部分的需要run在用户态。</p>
<p>如果将操作系统所有系统调用统统都在内核态run，这种设计方式就叫宏内核<em>monolithic kernel</em>。</p>
<p>如果仅将系统调用中必要的部分在内核态run，其他部分都在用户态run，并且采取Client/Server这样的异步通信方式，这种设计方式就叫微内核<em>microkernel</em>。</p>
<img src="/2023/01/10/xv6/image-20230107232802540.png" class>

<blockquote>
<p>由于客户/服务器（Client/Server）模式，具有非常多的优点，故在单机<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BE%AE%E5%86%85%E6%A0%B8">微内核</a>操作系统中几乎无一例外地都采用客户/服务器模式，将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B">进程</a>)中实现。</p>
</blockquote>
<p>在微内核中，内核接口由一些用于启动应用程序、发送消息、访问设备硬件等的低级功能组成。这种组织允许内核相对简单，因为大多数操作系统驻留在用户级服务器中。</p>
<p>像大多数Unix操作系统一样，Xv6是作为一个宏内核实现的。因此，xv6内核接口对应于操作系统接口，内核实现了完整的操作系统。</p>
<h3 id="Code-xv6-organization"><a href="#Code-xv6-organization" class="headerlink" title="Code: xv6 organization"></a>Code: xv6 organization</h3><p>XV6的源代码位于<code>kernel</code>子目录中，源代码按照模块化的概念划分为多个文件，图2.2列出了这些文件，模块间的接口都被定义在了<code>def.h</code>（<code>kernel/defs.h</code>）。</p>
<table>
<thead>
<tr>
<th><strong>文件</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>bio.c</strong></td>
<td>文件系统的磁盘块缓存</td>
</tr>
<tr>
<td><strong>console.c</strong></td>
<td>连接到用户的键盘和屏幕</td>
</tr>
<tr>
<td><strong>entry.S</strong></td>
<td>首次启动指令</td>
</tr>
<tr>
<td><strong>exec.c</strong></td>
<td><code>exec()</code>系统调用</td>
</tr>
<tr>
<td><strong>file.c</strong></td>
<td>文件描述符支持</td>
</tr>
<tr>
<td><strong>fs.c</strong></td>
<td>文件系统</td>
</tr>
<tr>
<td><strong>kalloc.c</strong></td>
<td>物理页面分配器</td>
</tr>
<tr>
<td><strong>kernelvec.S</strong></td>
<td>处理来自内核的陷入指令以及计时器中断</td>
</tr>
<tr>
<td><strong>log.c</strong></td>
<td>文件系统日志记录以及崩溃修复</td>
</tr>
<tr>
<td><strong>main.c</strong></td>
<td>在启动过程中控制其他模块初始化</td>
</tr>
<tr>
<td><strong>pipe.c</strong></td>
<td>管道</td>
</tr>
<tr>
<td><strong>plic.c</strong></td>
<td>RISC-V中断控制器</td>
</tr>
<tr>
<td><strong>printf.c</strong></td>
<td>格式化输出到控制台</td>
</tr>
<tr>
<td><strong>proc.c</strong></td>
<td>进程和调度</td>
</tr>
<tr>
<td><strong>sleeplock.c</strong></td>
<td>Locks that yield the CPU</td>
</tr>
<tr>
<td><strong>spinlock.c</strong></td>
<td>Locks that don’t yield the CPU.</td>
</tr>
<tr>
<td><strong>start.c</strong></td>
<td>早期机器模式启动代码</td>
</tr>
<tr>
<td><strong>string.c</strong></td>
<td>字符串和字节数组库</td>
</tr>
<tr>
<td><strong>swtch.c</strong></td>
<td>线程切换</td>
</tr>
<tr>
<td><strong>syscall.c</strong></td>
<td>Dispatch system calls to handling function.</td>
</tr>
<tr>
<td><strong>sysfile.c</strong></td>
<td>文件相关的系统调用</td>
</tr>
<tr>
<td><strong>sysproc.c</strong></td>
<td>进程相关的系统调用</td>
</tr>
<tr>
<td><strong>trampoline.S</strong></td>
<td>用于在用户和内核之间切换的汇编代码</td>
</tr>
<tr>
<td><strong>trap.c</strong></td>
<td>对陷入指令和中断进行处理并返回的C代码</td>
</tr>
<tr>
<td><strong>uart.c</strong></td>
<td>串口控制台设备驱动程序</td>
</tr>
<tr>
<td><strong>virtio_disk.c</strong></td>
<td>磁盘设备驱动程序</td>
</tr>
<tr>
<td><strong>vm.c</strong></td>
<td>管理页表和地址空间</td>
</tr>
</tbody></table>
<p> <strong>图2.2：XV6内核源文件</strong></p>
<h2 id="Process-overview"><a href="#Process-overview" class="headerlink" title="Process overview"></a>Process overview</h2><p>内核用来实现进程的机制包括用户态内核态标志、地址空间和进程的时间切片。</p>
<p>为了帮助加强隔离，进程抽象给程序提供了一种错觉，即它有自己的专用机器。进程为程序提供了一个看起来像是私有内存系统或地址空间的东西，其他进程不能读取或写入。进程还为程序提供了看起来像是自己的CPU来执行程序的指令。</p>
<p>Xv6使用页表（由硬件实现）为每个进程提供自己的地址空间。RISC-V页表将虚拟地址（RISC-V指令操纵的地址）转换（或“映射”）为物理地址（CPU芯片发送到主存储器的地址）。</p>
<p>每个进程也有自己的页表，页表中记录了以虚拟地址0开始的内存区域。</p>
<img src="/2023/01/10/xv6/image-20230107233741922.png" class>

<p>xv6内核为每个进程维护许多状态片段，并将它们聚集到一个<code>proc</code>(*<strong>kernel/proc.h*</strong>:86)结构体中。一个进程最重要的内核状态片段是它的页表、内核栈区和运行状态。我们将使用符号<code>p-&gt;xxx</code>来引用<code>proc</code>结构体的元素；例如，<code>p-&gt;pagetable</code>是一个指向该进程页表的指针。</p>
<blockquote>
<p>这应该相当于pcb表。</p>
</blockquote>
<h2 id="Code-starting-xv6-and-the-fifirst-process"><a href="#Code-starting-xv6-and-the-fifirst-process" class="headerlink" title="Code: starting xv6 and the fifirst process"></a>Code: starting xv6 and the fifirst process</h2><p>看完一遍说实话还乱乱的。。。。我整理整理跟linux的对比学习一下吧。</p>
<h3 id="xv6"><a href="#xv6" class="headerlink" title="xv6"></a>xv6</h3><h4 id="加载操作系统"><a href="#加载操作系统" class="headerlink" title="加载操作系统"></a>加载操作系统</h4><p>当RISC-V电脑开机，首先会run存在ROM里的<code>boot loader</code>，这个<code>boot loader</code>目的是把xv6加载进内存到<code>0x8000 0000</code>，然后跳转到xv6初始化程序。</p>
<blockquote>
<p>The reason it places the kernel at <code>0x80000000</code> rather than <code>0x0</code> is because the address range <code>0x0:0x80000000</code> contains <strong>I/O devices</strong>.</p>
</blockquote>
<h4 id="操作系统初始化"><a href="#操作系统初始化" class="headerlink" title="操作系统初始化"></a>操作系统初始化</h4><h5 id="entry-S配置栈空间"><a href="#entry-S配置栈空间" class="headerlink" title="entry.S配置栈空间"></a>entry.S配置栈空间</h5><p>此时，目前的机器状态是，1.没有开启地址映射，也即虚拟地址=真实物理地址。2.运行在machine mode</p>
<p>xv6会在<code>kernel/entry.S</code>下的这里开始执行，目的是<strong>配置好栈</strong>，以开始C语言代码<code>start.c</code>的执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # 这段主要是在计算栈顶指针sp</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">        # 已经有栈了，就可以开始执行C语言代码了</span><br><span class="line">        # jump to start()</span><br><span class="line">        call start</span><br></pre></td></tr></table></figure>

<p>其中start0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br></pre></td></tr></table></figure>

<h5 id="start-c"><a href="#start-c" class="headerlink" title="start.c"></a>start.c</h5><p>在start.c中，我们的任务是在machine mode下，获取machine mode才能访问到的硬件参数，做在machine mode 下才能做的时钟初始化【 it programs the clock chip to generate timer interrupts】，然后进行machine mode到内核态的切换，最后跳转到main.c进行操作系统的初始化和第一个进程的启动。</p>
<p>而其中，如果想从machine mode切换到内核态，就需要使用<code>mret</code>指令。但是mret指令除了会切换mode之外，还有一个“ret”的作用，并且是从machine mode ret到内核态。</p>
<blockquote>
<p>This instruction( mret ) is most often used to return from a previous call from supervisor mode to machine mode.</p>
</blockquote>
<p>所以，我们实际上可以把最后两步连起来，用mret一个指令就完成。也即，mret指令既完成了从machine mode到内核态的切换，又完成了从start.c到main.c的跳转。</p>
<p>这其实很容易，只需在栈中将调用者（此时应该是entry.S）的地址替换为main.c的地址，并且将调用者的mode改为内核态，这样就ok了。</p>
<blockquote>
<p> it sets the <strong>previous privilege mode</strong> to supervisor in the register mstatus, it sets the <strong>return address</strong> to main by writing main’s address into the register mepc, <strong>disables virtual address translation in supervisor mode</strong> by writing 0 into the page-table register satp, and <strong>delegates all interrupts and exceptions to supervisor mode</strong></p>
<p>后面两点不大明白。为什么为了mret，就还得让内核态跟machine mode一样关闭虚拟地址映射，还得把什么中断和异常委托给内核态【这个委托是完全没搞懂是什么意思】？？</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//修改调用者为内核态</span></span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h5><p>main.c的作用是做很多很多init。其中，它通过<code>userinit();</code>来创建第一个进程，这个第一个进程再由main调用<code>scheduler()</code>来被调度执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//...很多很多init</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    RISC-V的处理器对底层提供了一种特殊的抽象,Hardware Thread,简称为Hart。简单来说,Hart是真实物理CPU(bare metal)提供的一种模拟</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调度执行第一个进程</span></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：关于里面的cpuid，我查了一下，指的是CPU的序列号，用来唯一标识cpu的。我想这个if架构的目的应该跟<code>fork()==0</code>差不多。也就是说，一开始的那个init仅有<code>cpuid==0</code>的CPU执行，其他的CPU就乖乖wait，只有CPU0执行初始化的程序。等到CPU0执行完所有init，才置标记位start=1，然后通过锁<code>__sync_synchronize();</code>开始抢占调度，轮流初始化自己。</p>
</blockquote>
<h5 id="proc-c中的userinit"><a href="#proc-c中的userinit" class="headerlink" title="proc.c中的userinit()"></a>proc.c中的userinit()</h5><p>userinit的作用就是新创建一个进程信息proc，然后开始给第一个程序（initcode）填信息填入proc。这个进程创建完后，在main中的scheduler被调度执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请一页，将initcode的指令和数据放进去</span></span><br><span class="line">  <span class="comment">// allocate one user page and copy initcode&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvmfirst(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为内核态到用户态的转变做准备</span></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Trap Frame是指中断、自陷、异常进入内核后,在堆栈上形成的一种数据结构</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改进程名</span></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个也许是为了能被优先调度</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="initcode-S"><a href="#initcode-S" class="headerlink" title="initcode.S"></a>initcode.S</h5><p>以上程序都位于<code>kernel/</code>下。这个位于<code>user/</code>下。</p>
<p>它调用exec系统调用进入了内核态。当exec完成后，它就跳转到了用户态<code>user/init.c</code>中。【这里估计又用了修改返回地址的trick】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure>

<h5 id="init-c"><a href="#init-c" class="headerlink" title="init.c"></a>init.c</h5><p>在init.c中，创建了console设备文件，打开了012文件描述符，并且fork了一个子进程，开始执行shell。这样一来，操作系统就完成了全部的启动。</p>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><blockquote>
<p>我的疑点有三个：</p>
<ol>
<li>见start.c</li>
<li>是怎么完成从内核态到用户态的切换的？是执行了return就会自动切换吗？userinit中设置了initcode的信息为用户态的，然后就直接能进入用户态，这里感觉有点模糊。</li>
<li>什么时候开启地址映射的？</li>
</ol>
<p>除了这些外，都是很清晰明了的，步骤十分直接且有理由：</p>
<p>加载操作系统——为了能执行C语言需要一个栈，所以得执行造一个的代码，然后再进入C语言zone——做点machine mode才能做的事，然后从machine mode切换到内核态——做点内核态才能做的事，从内核态切换到用户态</p>
</blockquote>
<h3 id="linux0-11"><a href="#linux0-11" class="headerlink" title="linux0.11"></a>linux0.11</h3><p>bootsect -&gt; setup -&gt; head.s -&gt;main.c</p>
<h4 id="加载操作系统-1"><a href="#加载操作系统-1" class="headerlink" title="加载操作系统"></a>加载操作系统</h4><p>系统加电，启动BIOS初始化硬件 -&gt; BIOS从<u>引导扇区</u>将加载程序读入内存 -&gt; 加载程序将操作系统镜像读入内存RAM。</p>
<p>其中，第二三步做进一步的细化。</p>
<h5 id="读入bootsect-s"><a href="#读入bootsect-s" class="headerlink" title="读入bootsect.s"></a>读入bootsect.s</h5><p>加载程序的512个字节被读入到内存从<code>0x7c00</code>开始的一段内存中，并且BIOS设置<code>CS=07c0,ip=0</code>，开始执行加载程序的每一条指令。</p>
<h5 id="bootsect-s"><a href="#bootsect-s" class="headerlink" title="bootsect.s"></a>bootsect.s</h5><p>加载程序的代码为<code>bootsect.s</code>。在<code>bootsect.s</code>中，首先将自身从<code>7c00</code>处移动到了<code>9000</code>处【留下空间放操作系统】，然后分别依次读取磁盘的<u>setup</u>和<u>system</u>模块，最后bootsect将控制权转交给setup。</p>
<h5 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h5><p>setup首先获取操作系统运行的<strong>必要硬件参数</strong>。</p>
<img src="/2023/01/10/xv6/image-20230108011824655.png" class>

<p>再然后，<u>将system代码移到0地址</u>。然后，我们就需要进入system代码块。</p>
<img src="/2023/01/10/xv6/image-20230108012316631.png" class>

<p>最后一句jmpi指令本来应该是要跳到system代码段首0地址处的的，可此处却跳到了80处，这显然不合理。但它写的肯定是没错的。之所以会有这样的矛盾，是因为setup在此之前，还做了一件事情：<strong>改变寻址方式</strong>。jmpi上面的那条mov指令便做了这点。</p>
<p>我们之前的寻址方式一直是<code>cs&lt;&lt;4+ip</code>。但是这东西只能是16位的内存，<u>无法满足寻址需求</u>。故而setup要从16位切换到32位。32位模式也叫保护模式。</p>
<blockquote>
<p>至于怎么切的呢？要注意到一点，改变寻址方式也即改变cs和ip的地址计算方法，也即换一条硬件电路实现。计算机给我们提供了一个简单的方式操纵保护模式的转变，即修改cr0寄存器的内容。</p>
</blockquote>
<p>在保护模式下，寻址方式发生了改变。此时cs不再代表基址，而是表示地址在gdb表<code>global description table</code>中的偏移下标。真正的基址放在表项中。cs被称为selector，从表中取得基址，再和ip加在一起得到地址。</p>
<blockquote>
<p>gdt表的内容由setup初始化</p>
<img src="/2023/01/10/xv6/image-20230108013156116.png" class>
</blockquote>
<p>这样一来，就正确跳到了system模块。</p>
<h4 id="操作系统初始化-1"><a href="#操作系统初始化-1" class="headerlink" title="操作系统初始化"></a>操作系统初始化</h4><h5 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h5><p>跳到system第一个文件，也就是head.s去执行。</p>
<p>head.s也是在保护模式下进行的，是在保护模式下的初始化。</p>
<p>head.s建立了真正的gdt表，然后就要跳转到main.c执行初始化和Shell的启动。此处有汇编语言和C语言的转化，也就是push参数然后push main的地址。</p>
<h5 id="main-c-1"><a href="#main-c-1" class="headerlink" title="main.c"></a>main.c</h5><p>对各种东西的初始化。</p>
<img src="/2023/01/10/xv6/image-20230108013849664.png" class>

<p>最后完成从内核态到用户态的切换。</p>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><blockquote>
<p>linux0.11的启动的具体思路是：</p>
<p>加载操作系统，获取硬件参数，进入保护模式，跳转到操作系统第一行代码——操作系统初始化，切换到用户态</p>
<p>linux0.11相比于xv6更加复杂，上课的时候隐藏了很多实现细节但依旧理解很费劲（。</p>
<p>这两个步骤思路其实都是差不多的，区别在于linux0.11好像没有machine mode这个概念。感觉也不能锐评什么，因为看完了感觉两个都很有道理，两个都一样很难懂（。</p>
<p>不过linux0.11这里进入保护模式后改变寻址方式是因为机器问题（好像是），xv6难道也是因为硬件问题吗？因为一开始的时候操作系统还未进行内存分页页表初始化，所以用不了地址映射？有待学习。</p>
<p>关于保护模式，可以看看这篇文章，今天太晚了先睡了：</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15082498/5527746"><strong>Linux从头学08：Linux 是如何保护内核代码的？【从实模式到保护模式】</strong></a></p>
</blockquote>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><p>现实中，大多数操作系统都会兼顾宏内核与微内核。</p>
<p>大多数操作系统都支持与xv6类似的process进程概念，也有很多系统还支持线程概念。</p>
<h2 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab"></a>Lab</h2><blockquote>
<p>To start the lab, switch to the syscall branch:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout syscall</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><blockquote>
<p>In this assignment you will add a system call tracing feature that may help you when debugging later labs.</p>
<p>You’ll create a new <code>trace</code> system call that will control tracing. It should take <strong>one argument,</strong> an integer “mask”, whose bits specify which system calls to trace. </p>
<p>For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>. You have to modify the xv6 kernel to <strong>print out a line when each system call is about to return</strong>. The line should contain the <strong>process id</strong>, the <strong>name</strong> of the system call and the <strong>return value</strong>; you don’t need to print the system call arguments. </p>
<p>The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p>
</blockquote>
<h4 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h4><p>一开始为了把trace做得封装性良好一些尽量不改别的代码，想了好久好久，最后就只能想出，在syscall.c获取系统调用返回值处加个条件打印，在trace中维护一个map，映射进程pid和进程当前的mask，并且给外界提供查询当前进程是否对某个系统调用有mask作为syscall条件打印的接口。</p>
<p>这个最后还是失败了，失败的点在于不知道要创建多大的数组来作为map映射所有进程，因为pid分配估计是递增的，是会超过最大进程数的，所以pid会是多少是不确定的。还有一点就是fork之后子进程不能自动继承父进程的mask，还得手动调用一下trace，这更加不封装了（。</p>
<p>总之先放上我原来的代码吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/syscall.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* tmp)</span>&#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((*tmp)!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">    buf[i++] = *tmp;</span><br><span class="line">    tmp++;</span><br><span class="line">  &#125;  </span><br><span class="line">  buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getname</span><span class="params">(<span class="type">int</span> callid,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(callid)&#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_fork: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fork&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exit: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exit&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_wait: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;wait&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_pipe: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;pipe&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_read: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;read&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_kill: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;kill&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exec: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exec&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_fstat: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fstat&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_chdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;chdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_dup: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;dup&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getpid: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;getpid&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sbrk: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sbrk&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sleep: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sleep&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_uptime: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;uptime&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_open: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;open&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_write: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;write&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mknod: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mknod&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_unlink: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;unlink&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_link: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;link&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mkdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mkdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_close: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;close&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_trace: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;trace&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    getname(num,buf);</span><br><span class="line">    <span class="comment">// 在此处添加条件打印</span></span><br><span class="line">    <span class="keyword">if</span>(istraced(num))</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;syscall %s -&gt; %d\n&quot;</span>,buf,p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trace.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_mask[NPROC];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    m_mask[p-&gt;pid] = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供给外界查询的接口</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">istraced</span><span class="params">(<span class="type">int</span> callid)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">//printf(&quot;from trace ,pid = %d\n&quot;,p-&gt;pid);</span></span><br><span class="line">    <span class="keyword">if</span>(((m_mask[p-&gt;pid] &gt;&gt; callid) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是按照hints修改后的正确代码。</p>
<h4 id="代码步骤"><a href="#代码步骤" class="headerlink" title="代码步骤"></a>代码步骤</h4><p>实际上，标答跟我的思路差不多，只不过它没有像我一样创建数组作为map，而是在proc结构体里添加了一个属性，这本质上也是利用了map。</p>
<h5 id="在各种文件添加签名"><a href="#在各种文件添加签名" class="headerlink" title="在各种文件添加签名"></a>在各种文件添加签名</h5><h6 id="user-user-h"><a href="#user-user-h" class="headerlink" title="user/user.h"></a>user/user.h</h6><h6 id="user-usys-pl"><a href="#user-usys-pl" class="headerlink" title="user/usys.pl"></a>user/usys.pl</h6><h6 id="syscall-h"><a href="#syscall-h" class="headerlink" title="syscall.h"></a>syscall.h</h6><p>添加系统调用号</p>
<h6 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h6><p>添加系统调用号和sys_trace映射</p>
<h6 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改Makefile</h6><ol>
<li>在第一个OBJS添加trace.o</li>
<li>在UPROGS添加user中的trace</li>
</ol>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><h6 id="修改proc-h"><a href="#修改proc-h" class="headerlink" title="修改proc.h"></a>修改proc.h</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> mask; <span class="comment">//记录trace的mask</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="编写trace-c"><a href="#编写trace-c" class="headerlink" title="编写trace.c"></a>编写trace.c</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;mask = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">istraced</span><span class="params">(<span class="type">int</span> callid)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span>(((p-&gt;mask &gt;&gt; callid) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="修改syscall-c"><a href="#修改syscall-c" class="headerlink" title="修改syscall.c"></a>修改syscall.c</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/syscall.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* tmp)</span>&#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((*tmp)!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">    buf[i++] = *tmp;</span><br><span class="line">    tmp++;</span><br><span class="line">  &#125;  </span><br><span class="line">  buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getname</span><span class="params">(<span class="type">int</span> callid,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(callid)&#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_fork: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fork&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exit: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exit&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_wait: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;wait&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_pipe: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;pipe&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_read: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;read&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_kill: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;kill&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exec: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exec&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_fstat: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fstat&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_chdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;chdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_dup: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;dup&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getpid: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;getpid&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sbrk: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sbrk&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sleep: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sleep&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_uptime: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;uptime&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_open: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;open&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_write: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;write&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mknod: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mknod&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_unlink: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;unlink&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_link: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;link&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mkdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mkdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_close: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;close&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_trace: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;trace&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    getname(num,buf);</span><br><span class="line">    <span class="comment">// 在此处添加条件打印</span></span><br><span class="line">    <span class="keyword">if</span>(istraced(num))</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;syscall %s -&gt; %d\n&quot;</span>,buf,p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="在sysproc-c中添加系统调用"><a href="#在sysproc-c中添加系统调用" class="headerlink" title="在sysproc.c中添加系统调用"></a>在sysproc.c中添加系统调用</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>,&amp;mask)&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  trace(mask);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="在defs-h中添加需要public的函数签名"><a href="#在defs-h中添加需要public的函数签名" class="headerlink" title="在defs.h中添加需要public的函数签名"></a>在defs.h中添加需要public的函数签名</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trace.c</span></span><br><span class="line"><span class="type">int</span>		<span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span>		<span class="title function_">istraced</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="sysinfotest"><a href="#sysinfotest" class="headerlink" title="sysinfotest"></a>sysinfotest</h3><blockquote>
<p>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. </p>
<p>The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). </p>
<p>The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code> field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. </p>
<p>We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysinfo.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> &#123;</span></span><br><span class="line">  uint64 freemem;   <span class="comment">// amount of free memory (bytes)</span></span><br><span class="line">  uint64 nproc;     <span class="comment">// number of process</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="感想-3"><a href="#感想-3" class="headerlink" title="感想"></a>感想</h4><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p>系统调用要做的事情同上。</p>
<p>有一个我在hit实验没想到，在这里<strong>依然没有想到</strong>的点是，参数的指针来自用户空间，所以不能直接对其指向的空间进行写入，需要借助copyout函数。</p>
<p>还有一件事，就是不知道该怎么统计free mem的数量，后来在hints提示下才知道要去kalloc.c中找。【之前只找过了vm.c】这里其实是很后悔提前看了提示的。我应该先去看一下上面关于kernel各个文件用途的笔记，再去继续自己找的，不能太过依赖提示。</p>
<p>还有一点做的不好的地方是，标答是选择了将两个计数函数放在各自的文件中，我是选择直接将成员变量在头文件中extern 公开出来，比如说在proc.h中这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br></pre></td></tr></table></figure>

<p>hints采取了比我封装性更好的操作，这也是非常顺理成章的，我没有想到这样真是有点惭愧（。</p>
<p>总而言之，这个还是挺简单的，就是我很后悔我心浮气躁看了提示，要不然收获会更多。</p>
<h5 id="sysinfo-c"><a href="#sysinfo-c" class="headerlink" title="sysinfo.c"></a>sysinfo.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysinfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo* info)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">res</span>;</span></span><br><span class="line">  res.nproc = countproc();</span><br><span class="line">  res.freemem = countfree();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, (uint64)info,(<span class="type">char</span> *)(&amp;res), <span class="keyword">sizeof</span>(res)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sysproc-c中"><a href="#sysproc-c中" class="headerlink" title="sysproc.c中"></a>sysproc.c中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> sysinfo((<span class="keyword">struct</span> sysinfo*)addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="kalloc-c中"><a href="#kalloc-c中" class="headerlink" title="kalloc.c中"></a>kalloc.c中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用的是链表结构，run代表一页</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="comment">// 指向第一个空闲页</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">countfree</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> npage = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span>* <span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">    npage++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> npage*PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="proc-c中"><a href="#proc-c中" class="headerlink" title="proc.c中"></a>proc.c中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">countproc</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NPROC;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(proc[i].state != UNUSED)&#123;</span><br><span class="line">	  nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nproc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h4><h5 id="trace-plus"><a href="#trace-plus" class="headerlink" title="trace plus"></a>trace plus</h5><blockquote>
<p>Print the system call arguments for traced system calls.</p>
</blockquote>
<p>这个实现起来要说简单也简单，麻烦也麻烦。这里就先摆了【实际上尝试了半小时发现太烦了看别人写的也不大满意就放弃了】</p>
<h5 id="sysinfo-plus"><a href="#sysinfo-plus" class="headerlink" title="sysinfo plus"></a>sysinfo plus</h5><blockquote>
<p>Compute the load average and export it through sysinfo</p>
</blockquote>
<p>说实话没太看懂，不就加个 running process/ncpu就行了吗？</p>
<h1 id="Page-tables"><a href="#Page-tables" class="headerlink" title="Page tables"></a>Page tables</h1><blockquote>
<p>页表学完后，还有一个点就是，xv6有没有实现内存的换入换出呢？</p>
<p>印象中，xv6从操作系统读入，一直到目前写程序，似乎一直都是获得虚拟地址，通过虚拟地址访问物理内存地址，好像从来没有考虑过物理内存和磁盘间的换入换出。</p>
<p>是xv6没有实现这个机制，还是还没讲到呢？此处有待发掘。</p>
</blockquote>
<h2 id="Paging-hardware"><a href="#Paging-hardware" class="headerlink" title="Paging hardware"></a>Paging hardware</h2><h3 id="为什么需要页表"><a href="#为什么需要页表" class="headerlink" title="为什么需要页表"></a>为什么需要页表</h3><p>将主存储器以及各种外设接口卡里面内置的存储器连接起来，就形成了内存地址空间。内存地址空间中的地址是真实的物理地址。RISC-V架构的指令使用的地址是虚拟地址。为了通过指令中的虚拟地址访问到真实的物理内存，需要进行从虚拟地址到物理地址的转换。从虚拟地址到物理地址的转换，就需要通过页表来实现。</p>
<h3 id="页表组成"><a href="#页表组成" class="headerlink" title="页表组成"></a>页表组成</h3><h4 id="页表项"><a href="#页表项" class="headerlink" title="页表项"></a>页表项</h4><p>页表由页表项PTE（Page Table Entries）构成，每个页表项由44位的PPN（Physical Page Number）和一些参数flag组成。</p>
<img src="/2023/01/10/xv6/image-20230109153937459.png" class>

<blockquote>
<p>Each PTE contains flflag bits that tell the paging hardware how the associated virtual address is allowed to be used. <strong>PTE_V</strong> indicates whether the PTE is <u>present</u>: if it is not set, a reference to the page causes an exception (i.e. is not allowed). <strong>PTE_R</strong> controls whether instructions are allowed to <u>read</u> to the page. PTE_W controls whether instructions are allowed to write to the page. <strong>PTE_X</strong> controls whether the CPU may interpret the content of the page <u>as instructions and execute them</u>. <strong>PTE_U</strong> controls whether instructions in <u>user</u> mode are allowed to <u>access</u> the page; if PTE_U is not set, the PTE can be used only in supervisor mode.</p>
<p>这个表项的几个参数定义在kernel/riscv.h中的341行左右。</p>
</blockquote>
<p>虚拟地址有64bit，其中25bits未使用，39bits包含了27位的PTE索引号以及12位的offset。</p>
<p>物理地址有56位，由PPN和offset拼接组成。</p>
<h4 id="单页表和多级页表"><a href="#单页表和多级页表" class="headerlink" title="单页表和多级页表"></a>单页表和多级页表</h4><p>以单页表为例，物理地址形成过程如下图所示。</p>


<p><u>每个页表项PTE索引着一页</u>。因而，每一页的大小为2^12=4096B。单页表中PTE的索引号有2^27个，因而单页表中表项有134217728个，即可以代表134217728页。页表实际上也是以页的形式存储的。因而单页表需要的存储空间为(2^27x7)/2^12=2^15x7=229376页。</p>
<p>RISC-V架构中真实情况是会有三级页表。三级页表结构相比于单级页表结构，会占据更多的<strong>物理存储空间</strong>。</p>
<img src="/2023/01/10/xv6/image-20230109151346780.png" class>

<p><u>每个页表项PTE索引着一页，这一页可能代表着另一个页表，也可能代表着内存中需要的指令和数据</u>。因而，每一页的大小为2^12=4096B。三页表中，一级页表中PTE的索引号有512个，可以代表的物理内存页数有512x515x512=2^27页，即可以代表134217728页。页表实际上也是以页的形式存储的，一个页表有2^9x7个字节，可以存储在1页中。因而三页表需要的存储空间为1+2^9+2^18 = 262657页。</p>
<p>三级页表结构相比于单级页表结构，可以节省更多<strong>内存空间</strong>。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuyuande/article/details/117616433">页表是啥以及为啥多级页表能够节省空间</a></p>
</blockquote>
<p>考虑到这样一个进程：</p>
<img src="/2023/01/10/xv6/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1eXVhbmRl,size_16,color_FFFFFF,t_70.png" class>

<p>进程使用页表时，需要将整个页表读入内存。</p>
<p>如果使用单级页表，尽管一个进程仅使用到页表中的某两项，也需要把整个页表都读入内存，光是页表就占据了2^15x7x4k/2^20 约为1G的内存空间。</p>
<p>如果使用三级页表，一个进程需要用到某两页。假设这两页存储在不同的二级页表中，则只需要读入1+2+2=5页 约为20K的内存空间。</p>
<p>两者相对比，显然用三级页表比单级页表顶多了。三级页表相较于一级页表，多用了13%的物理空间，却可以节省99.998%的空间。</p>
<h3 id="页表使用"><a href="#页表使用" class="headerlink" title="页表使用"></a>页表使用</h3><p>每个进程会保留自己的一份用户级别的页表地址。当轮到自己使用CPU时，会将CPU的satp寄存器更换为自己的页表地址。</p>
<h2 id="Kernel-address-space"><a href="#Kernel-address-space" class="headerlink" title="Kernel address space"></a>Kernel address space</h2><p>介绍了xv6中内核的页表结构。</p>
<blockquote>
<p>这里为了方便，就把三级页表省略了，只留下va和pa的对比</p>
</blockquote>
<p>每个进程都有一个用户级别的页表。xv6给内核提供了一个单独的内核地址空间的页表。其层级映射关系如下：</p>
<img src="/2023/01/10/xv6/p3.png" class>

<p>在kernel/memlayout.h中正记录了这些参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical memory layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu -machine virt is set up like this,</span></span><br><span class="line"><span class="comment">// based on qemu&#x27;s hw/riscv/virt.c:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 00001000 -- boot ROM, provided by qemu</span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT</span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC</span></span><br><span class="line"><span class="comment">// 10000000 -- uart0 </span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk </span></span><br><span class="line"><span class="comment">// 80000000 -- boot ROM jumps here in machine mode</span></span><br><span class="line"><span class="comment">//             -kernel loads the kernel here</span></span><br><span class="line"><span class="comment">// unused RAM after 80000000.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel uses physical memory thus:</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S, then kernel text and data</span></span><br><span class="line"><span class="comment">// end -- start of kernel page allocation area</span></span><br><span class="line"><span class="comment">// PHYSTOP -- end RAM used by the kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// core local interruptor (CLINT), which contains the timer.</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>由图可知，一直从0x0到0x86400000，都是采取的<strong>直接映射</strong>的方式，虚拟地址=物理地址，这段是内核使用的空间。在0x0-0x800000000阶段，物理地址代表着各种IO设备的存储器。</p>
<p>但是注意，在0x86400000（PHYSTOP）以上的地址都不是直接映射，这些非直接映射的层级包含两类：</p>
<ol>
<li><p>trampoline</p>
<blockquote>
<p>It is mapped at the top of the virtual address space; user page tables have this same mapping. </p>
</blockquote>
<p>它有一点很特殊的是，它实际对应的物理内存是0x80000000开始的一段。也就是说，0x80000000开始的这段内存，既被直接映射了，也被trampoline通过虚拟地址映射了。它被映射了两次。</p>
</li>
<li><p>内核栈</p>
<blockquote>
<p>Each process has its own kernel stack, which is mapped high so that below it xv6 can leave an unmapped <em>guard page</em>. The guard page’s PTE is invalid (i.e., <u>PTE_V is not set</u>), so that if the kernel <strong>overflflows</strong> a kernel stack, it will likely cause an exception and the kernel will panic.</p>
<p>guard page可以用来防止内核栈溢出。</p>
</blockquote>
</li>
</ol>
<p>内核使用PTE_R和PTE_X权限映射trampoline和kernel text。这表明这份内存段可以读，可以被当做指令块执行，但不能写。其他的块都是可读可写的，除了guard page被设置为不可访问。</p>
<h2 id="Code-creating-an-address-space"><a href="#Code-creating-an-address-space" class="headerlink" title="Code: creating an address space"></a>Code: creating an address space</h2><h3 id="vm-c"><a href="#vm-c" class="headerlink" title="vm.c"></a>vm.c</h3><p>操作地址空间和页表部分的代码都在<code>kernel/vm.c</code>中。代表页表的数据结构是<code>pagetable_t</code>。</p>
<p>vm.c的主要函数有walk、mappages等。walk用来在三级页表中找到某个虚拟地址表项，或者创建一个新的表项。mappages用来新建一个表项，主要用到了walk函数。</p>
<p>vm.c中，以kvm开头的代表操纵内核页表，以uvm开头的代表操纵进程里的用户页表。</p>
<h4 id="以初始化为例介绍各个函数"><a href="#以初始化为例介绍各个函数" class="headerlink" title="以初始化为例介绍各个函数"></a>以初始化为例介绍各个函数</h4><h5 id="创建页表"><a href="#创建页表" class="headerlink" title="创建页表"></a>创建页表</h5><p>一开始操作系统初始化时，会调用vm.c中的kvminit来创建内核页表。主要就是在以内核地址空间的页表结构在填写页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//内核页表</span></span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line">  <span class="comment">//申请新的一页</span></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//给内核页表初始化表项，结构详见上面的内核地址空间部分</span></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，kvmmap用来在内核页表中添加一个新的表项。其函数形式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现主要逻辑的是mappages函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">//walk函数通过虚拟地址新建一个第三级页表的表项并返回其指针，之后只需要填这个表项即可</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果pte存在并且标记为已使用，说明该虚拟地址映射已经存在</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    <span class="comment">//填写表项：物理地址 flags</span></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//每两个表项间隔PGSIZE个字节</span></span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过虚拟地址获取表项主要是通过walk实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="comment">// 虚拟地址的格式：UNUSED 页表索引 offset，其中页表索引在三级页表中被划分为了三个，分别是</span></span><br><span class="line"><span class="comment">// level0-level2，分别代表了第三级、第二级、第一级页表的索引【具体可见页表组成中的图】</span></span><br><span class="line"><span class="comment">// walk的目的就是要在这三级页表中找到虚拟地址对应的页表项。当alloc!=0时，则要求找不到就新建一个</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// 取出PTE中表示下一级页表地址的字节</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 页表不存在的情况，要么返回0，要么新建一页</span></span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终返回第三级页表的对应表项</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="装上页表"><a href="#装上页表" class="headerlink" title="装上页表"></a>装上页表</h5><p>使用的是kvminithart函数。它将内核页表的root page table的物理地址写入了satp寄存器。从这个函数之后，就<strong>开启了内存映射</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// wait for any previous writes to the page table memory to finish.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line"></span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flush stale entries from the TLB.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中sfence_vma()的用途是强制更新TLB的旧页表，类似于Java volatile的作用。</p>
<blockquote>
<p>附上书里的详细解释：</p>
<img src="/2023/01/10/xv6/image-20230109222917346.png" class>

<p>TLB与页表类似于cache与主存的关系。TLB保存了页表的一部分。</p>
<p>【我怎么感觉怪怪的啊？因为TLB既然是高速缓存，那么读写页表也应该优先从TLB读写。所以说，会陈旧的应该是主存中的页表，而不是TLB中的页表。但是，书里是说，改完页表必须通知TLB更改。也就是说，读写页表不是从TLB读写的，那该是从哪里？是TLB以外的free memory吗？</p>
<p>不过，要是从多CPU的角度思考，说不定他这个意思是某个CPU的TLB变了，需要通知其他所有CPU的TLB也变。虽然不同CPU当前执行的进程是不一样的，使用的页表项不一样，切换进程的时候也会把用户地址空间的页表项flush掉。但是内核地址空间的页表项一般是不会随着进程切换而flush掉的。所以内核页表修改就需要手动多CPU同步。</p>
<p>我认为多CPU角度考虑更加合理，因为它最后说了，xv6会在内核页表init后flush，以及在从内核态切换回用户态的时候flush。这两个（好像）都影响内核页表比较多，所以就需要手动flush一下。】</p>
</blockquote>
<h2 id="Physical-memory-allocation"><a href="#Physical-memory-allocation" class="headerlink" title="Physical memory allocation"></a>Physical memory allocation</h2><p>在内核运行的时候，需要申请很多空间用来存放各种数据。</p>
<blockquote>
<p>The kernel must allocate and free physical memory at run-time for page tables, user memory, kernel stacks, and pipe buffers.</p>
</blockquote>
<p>用的是这段空闲内存：</p>
<img src="/2023/01/10/xv6/image-20230109225700837.png" class>

<blockquote>
<p> It keeps track of which pages are free by threading a <strong>linked list</strong> through the pages themselves.</p>
</blockquote>
<p>kalloc.c中就是这么实现的。</p>
<h2 id="Code-Physical-memory-allocator"><a href="#Code-Physical-memory-allocator" class="headerlink" title="Code: Physical memory allocator"></a>Code: Physical memory allocator</h2><p>内核运行时申请释放空闲物理空间是通过<code>kernel/kalloc.c</code>完成的。它为内核栈、用户进程、页表和管道buffer服务。</p>
<blockquote>
<p>kalloc.c用来在运行时申请分配新的一页，上面的vm.c正是用了kalloc申请一页，要么作为页表，要么作为存储数据的第三级页表指向的物理内存。</p>
</blockquote>
<p>最后应该会在空闲内存内形成这样的结构：</p>
<p>内存分成一页一页的，每页内存中的前几个字节存储着其对应队列中下一块内存的物理地址。不一定是从小地址到大地址顺序连接。</p>
<blockquote>
<p>It store each free page’s run structure in the free page itself, since there’s nothing else stored there. </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical memory allocator, for user processes,</span></span><br><span class="line"><span class="comment">// kernel stacks, page-table pages,</span></span><br><span class="line"><span class="comment">// and pipe buffers. Allocates whole 4096-byte pages.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放在这范围内的物理内存空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也就是上面说的free memory的起始位置</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[]; <span class="comment">// first address after kernel.</span></span><br><span class="line">                   <span class="comment">// defined by kernel.ld.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// run代表的是一页内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表了整个内核空闲的物理空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="comment">// init的时候先清空空闲空间，建立空闲页队列</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="comment">// PGROUNDUP和PGROUNDDOWN是用于将地址四舍五入到PGSIZE</span></span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// pa得是整数页，并且得在内核物理内存范围之间</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 之后将在pa对应的那一页的前几个字节写入next字段</span></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这意思就是在空闲内存的链表队列中新增一块</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Process-address-space"><a href="#Process-address-space" class="headerlink" title="Process address space"></a>Process address space</h2><p>当用户进程叫xv6分配内存时，xv6会用kalloc去取，然后登记在页表上。</p>
<blockquote>
<p>The stack is a single page, and is shown with the initial contents as created by exec. Strings containing the command-line arguments, as well as an array of pointers to them, are at the very top of the stack. Just under that are values that allow a program to start at main as if the function main(argc, argv) had just been called.</p>
</blockquote>
<img src="/2023/01/10/xv6/image-20230109234930690.png" class>

<h2 id="Code-sbrk"><a href="#Code-sbrk" class="headerlink" title="Code: sbrk"></a>Code: sbrk</h2><blockquote>
<p>Sbrk is the <strong>system call</strong> for a process to <strong>shrink or grow</strong> its memory. The system call is implemented by the function growproc (kernel/proc.c:239).</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.注意单位是bytes，grow n+，shrink n-</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// 主要逻辑还是通过vm.c实现</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sz;<span class="comment">//size</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n, PTE_W)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate PTEs and physical memory to grow process from oldsz to</span></span><br><span class="line"><span class="comment">// newsz, which need not be page aligned.不需要页对齐  Returns new size or 0 on error.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// oldsz向上取整</span></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="comment">// 每页alloc</span></span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 说明失败，恢复到原状</span></span><br><span class="line">      <span class="comment">// 这里不用像下面一样kfree是因为这里压根没有alloc成功</span></span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除去junk data</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 放入页表</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 不成功</span></span><br><span class="line">      <span class="comment">// dealloc原理是顺着页表一个个free的。由于mem此处没有成功放入页表，所以就得单独free掉</span></span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-exec"><a href="#Code-exec" class="headerlink" title="Code:exec"></a>Code:exec</h2><blockquote>
<p>Exec is the system call that creates the user part of an address space. It initializes the user part of an address space from a fifile stored in the fifile system.</p>
<p><code>exec</code>是创建地址空间的用户部分的系统调用。它使用一个存储在文件系统中的文件初始化地址空间的用户部分。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s, *last;</span><br><span class="line">  <span class="type">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//开始打开文件的意思吧（</span></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//ip是一个inode</span></span><br><span class="line">  <span class="comment">//打开路径为path的文件</span></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暂时锁住文件，别人不许动</span></span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//之后应该就是把文件读入内存吧</span></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//分配新页表</span></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//elfhd应该指的是可执行文件头</span></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//总之顺利读到了</span></span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="comment">//读到了就给它分配新空间并且填入页表</span></span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在这里解锁</span></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读完文件，开始造一个新的用户栈【fork之后用户栈是不会清空的】</span></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Make the first inaccessible as a stack guard.</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack.</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE, PTE_W)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  <span class="comment">// mark a PTE invalid for user access.造guard page</span></span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  <span class="comment">// sp为栈顶</span></span><br><span class="line">  sp = sz;</span><br><span class="line">  <span class="comment">// 应该指的是栈尾</span></span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始往栈中填入执行参数</span></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//argv来自用户空间，所以需要使用copyout</span></span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//这什么东西</span></span><br><span class="line">    <span class="comment">//exec一次将参数中的一个字符串复制到栈顶，并在ustack中记录指向它们的指针</span></span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//放置空指针</span></span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="type">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//只有成功了才会来到这，才会覆盖掉旧的内存镜像</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="comment">//释放新镜像，不改变旧镜像</span></span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Real-world-1"><a href="#Real-world-1" class="headerlink" title="Real world"></a>Real world</h2><img src="/2023/01/10/xv6/image-20230110010651653.png" class>

<p>xv6内核缺少一个类似<code>malloc</code>可以为小对象提供内存的分配器，这使得内核无法使用需要动态分配的复杂数据结构。【确实，感觉一分配就是一页（】</p>
<p>内存分配是一个长期的热门话题，基本问题是有效使用有限的内存并为将来的未知请求做好准备。今天，人们更关心速度而不是空间效率。此外，一个更复杂的内核可能会分配许多不同大小的小块，而不是（如xv6中）只有4096字节的块；一个真正的内核分配器需要处理小分配和大分配。</p>
<h2 id="Lab-2"><a href="#Lab-2" class="headerlink" title="Lab"></a>Lab</h2><blockquote>
<p>In this lab you will explore page tables and modify them to to speed up certain system calls and to detect which pages have been accessed.</p>
</blockquote>
<h3 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h3><blockquote>
<p>When each process is created, map one read-only page at USYSCALL (a VA defined in <code>memlayout.h</code>). At the start of this page, store a <code>struct usyscall</code> (also defined in <code>memlayout.h</code>), and initialize it to store the PID of the current process. For this lab, <code>ugetpid()</code> has been provided on the userspace side and will automatically use the USYSCALL mapping. You will receive full credit for this part of the lab if the <code>ugetpid</code> test case passes when running <code>pgtbltest</code>.</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/429304672">MIT 6.S081 2021: Lab page tables</a></p>
</blockquote>
<h4 id="感想-4"><a href="#感想-4" class="headerlink" title="感想"></a>感想</h4><h5 id="乌龙"><a href="#乌龙" class="headerlink" title="乌龙"></a>乌龙</h5><p>这里好像是因为实验改版了，我下的是2020年的实验包，在memlayout压根找不到USYSCALL和struct usyscall这俩东西。最后翻了下网上的总算找到了。</p>
<p>我一开始没找到，还以为USYSCALL以及usyscall这两个都得自己写在memlayout里面，想了很久都没想出来USYSCALL的值应该设置为多少。我认为只需满足两个条件即可：1.所处内存段应该是free memory那段，也即自kernel结束（PHYSTOP）到MAXVA这一大块。2.得确保能被用户和内核都能访问到。</p>
<p>前者意为虚拟地址在MAXVA和PHYSTOP之间，后者意为那段内存应该标记为PTE_U。这个范围是很宽泛的，我实在不知道要分配这期间的哪块内存，感觉也不大可能是真的自由度那么大。所以我就偷偷看了hints【悲】，想看它对这个USYSCALL应该写什么值有没有建议。结果发现这东西是实验给我们定的。遂去网上找到了它给的真正的USYSCALL值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户的ugetpid只找到了一个截图：</p>
<img src="/2023/01/10/xv6/v2-0c2603da4c8102e46ae390a0d0b1191d_1440w.webp" class>

<p>恕我愚钝实在不知道该把这段代码放在哪orz于是接下来写的东西就没有自测。</p>
<h5 id="panic-freewalk-leaf"><a href="#panic-freewalk-leaf" class="headerlink" title="panic:freewalk leaf"></a>panic:freewalk leaf</h5><p>一开始写好代码准备启动xv6的时候爆出了这么一个panic，搜了一下得到如下解答：</p>
<blockquote>
<p>来源：<a target="_blank" rel="noopener" href="http://t.zoukankan.com/YuanZiming-p-14270600.html">MIT-6.S081-2020实验（xv6-riscv64）十：mmap</a></p>
<p>这时运行会发现freewalk函数panic：<code>freewalk: leaf</code>，这是因为freewalk希望所有虚拟地址已经被解绑并释放对应的物理空间了，该函数只负责释放页表。</p>
</blockquote>
<p>让我得知freewalk在vm.c下面【吐槽，我一开始还以为是自由自在地走（，看到这个才反应过来是free walk，跟页表有关的】。结合freewalk的代码</p>
<img src="/2023/01/10/xv6/image-20230110225359361.png" class>

<p>可以知道，造成这个panic的原因是需要手动释放页表项。而在这里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c  freeproc()</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>仅仅是释放掉了对应的物理页，<strong>页表项并没有被释放</strong>。</p>
<p>对比了一下别人写的，才发现原来这里也需要修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//添加此句</span></span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，问题就解决了。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>因而，可以看到，如果进程想使用页的话，需要经历以下四步：</p>
<ol>
<li>通过kalloc获取物理页地址（可以通过该地址对页进行读写），并且记录在进程proc结构中（否则之后就获取不了了）</li>
<li>建立mappages映射</li>
<li>释放物理页</li>
<li>释放PTE映射</li>
</ol>
<p>可见12和34都是分别一一对应的。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//有线程池那味了</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Allocate a usyscall page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在USYSCALL写入usyscall结构体</span></span><br><span class="line">  p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a user page table for a given process,</span></span><br><span class="line"><span class="comment">// with no user memory, but with trampoline pages.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 映射USYSCALL</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;usyscall), PTE_R|PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><blockquote>
<p>Which other xv6 system call(s) could be made faster using this shared page? Explain how.</p>
</blockquote>
<p>我觉得如果能在fork的父子进程用shared page共享页表应该会节省很多时间和空间，用个读时写。其他的倒是想不到了。不过这题会不会问的是那些在内核态和用户态穿梭频繁的system call呢？这个的话我就想不出来了。</p>
<h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><blockquote>
<p>write a function that prints the contents of a page table.</p>
<p>Define a function called <code>vmprint()</code>. </p>
<p>It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. </p>
<p>Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process’s page table. </p>
<img src="/2023/01/10/xv6/image-20230110231020570.png" class>

<p>The first line displays the argument to <code>vmprint</code>. After that there is a <strong>line for each PTE</strong>, including PTEs that refer to page-table pages deeper in the tree. Each PTE line is indented by a number of <code>&quot; ..&quot;</code> that indicates its depth in the tree. </p>
<p>Each PTE line shows the PTE <strong>index</strong> in its page-table page, the <strong>pte bits</strong>, and the <strong>physical address extracted from the PTE</strong>. <u>Don’t print PTEs that are not valid</u>. </p>
<p>In the above example, the top-level page-table page has mappings for entries 0 and 255. The next level down for entry 0 has only index 0 mapped, and the bottom-level for that index 0 has entries 0, 1, and 2 mapped.</p>
</blockquote>
<h4 id="感想-5"><a href="#感想-5" class="headerlink" title="感想"></a>感想</h4><img src="/2023/01/10/xv6/image-20230111000329475.png" class>

<p>很可惜，我在上面检索<code>freewalk leaf</code>到底是什么东西的时候，不小心看到了这题需要去参照freewalk这个提示【悲】其实我觉得这点还是需要绕点弯才能想到的，可能直接想到有点难【谁知道呢，世界线已经变动了】。</p>
<p>它这个打印页表其实最主要是考查如何遍历页表，这让人想起了walk这样的东西。但是walk是根据虚拟地址一级级找PTE的，中间很多地方会被跳过。有没有一个过程会在做事的时候遍历整个页表呢？答案是，这个过程就是释放页表的过程。释放页表才会一个个地看是否需要释放。释放页表的函数是freewalk，因而这道题参考freewalk的代码即可。</p>
<p>我觉得从“遍历页表”联想到“释放页表”这点是很巧的。不过也不会很突兀，毕竟学数据结构时就知道释放就需要遍历，逆向思维有点难但问题不大。</p>
<p>其他的就都挺简单的，不多赘述。</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><p>记得在defs.h中添加声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在vm.c下</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint_helper</span><span class="params">(<span class="type">pagetable_t</span> pagetable,<span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;level;j++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>,i,(uint64)pte,(uint64)(PTE2PA(pte)));</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        vmprint_helper((<span class="type">pagetable_t</span>)child,level+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印页表</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// typedef uint64 *pagetable_t;所以pagetable可以以%p形式打印</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>,(uint64)pagetable);</span><br><span class="line">  vmprint_helper(pagetable,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问答题-1"><a href="#问答题-1" class="headerlink" title="问答题"></a>问答题</h4><blockquote>
<p>Explain the output of <code>vmprint</code> in terms of Fig 3-4 from the text. </p>
<p>What does page 0 contain? </p>
<p>What is in page 2? When running in user mode, could the process read/write the memory mapped by page 1? </p>
<p>What does the third to last page contain?</p>
</blockquote>
<p>从上面操作系统的启动来看，进程1应该是在main.c中的userinit()中创建的进程，也是shell的父进程。【确实，经实践可得shell的pid为2】</p>
<p>可以来看一下userint的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请一页，将initcode的指令和数据放进去</span></span><br><span class="line">  <span class="comment">// allocate one user page and copy initcode&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  uvminit的注释：</span></span><br><span class="line"><span class="comment">  	// Load the user initcode into address 0 of pagetable,</span></span><br><span class="line"><span class="comment">	// for the very first process.</span></span><br><span class="line"><span class="comment">	// sz must be less than a page.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为内核态到用户态的转变做准备</span></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Trap Frame是指中断、自陷、异常进入内核后,在堆栈上形成的一种数据结构</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改进程名</span></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个也许是为了能被优先调度</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，page0是initcode的代码和数据，page1和page2用作了进程的栈，其中page1应该是guard page，page2是stack。</p>
<p><strong>不过这里从exec的角度解释其实更通用</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//分配新页表</span></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//elfhd应该指的是可执行文件头</span></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="comment">//总之顺利读到了</span></span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="comment">//读到了就给它分配新空间并且填入页表</span></span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读完文件，开始造一个新的用户栈【fork之后用户栈是不会清空的】</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE, PTE_W)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  <span class="comment">// mark a PTE invalid for user access.造guard page</span></span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  <span class="comment">// sp为栈顶</span></span><br><span class="line">  sp = sz;</span><br><span class="line">  <span class="comment">// 应该指的是栈尾</span></span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page0就填程序。这里重点说明一下为什么page1和page2分别是guard page和stack。</p>
<p>按照它的那个算术关系，stack和guard page的虚拟内存位置关系应该是这样的：</p>
<img src="/2023/01/10/xv6/image-20230111004330079.png" class>

<p>那为什么最后在页表中，变成了page1是gurad page，page2是stack这样上下颠倒了呢？看vm.c中的uvmalloc就能明白。</p>
<img src="/2023/01/10/xv6/image-20230111004500827.png" class>

<p>在253行设置了新映射。可以看到，这里设置映射的顺序是sz-&gt;sz+PGSIZE，也即先设置guard page的映射，再设置stack的映射。所以，这两位才会上下颠倒了。</p>
<h3 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h3><blockquote>
<p>Some garbage collectors (a form of automatic memory management) can benefit from information about <strong>which pages have been accessed (read or write)</strong>. In this part of the lab, you will add a new feature to xv6 that detects and reports this information to userspace by inspecting <strong>the access bits in the RISC-V page table.</strong> The RISC-V hardware page walker marks these bits in the <strong>PTE</strong> whenever it resolves a TLB miss.</p>
</blockquote>
<blockquote>
<p>Your job is to implement <code>pgaccess()</code>, a system call that reports which pages have been accessed. </p>
<p>The system call takes three arguments. First, it takes the <strong>starting virtual address</strong> of the first user page to check. Second, it takes the <strong>number of pages</strong> to check. Finally, it takes a <strong>user address to a buffer to store the results into a bitmask</strong> (a datastructure that uses one bit per page and where the first page corresponds to the least significant bit). </p>
<p>You will receive full credit for this part of the lab if the <code>pgaccess</code> test case passes when running <code>pgtbltest</code>.</p>
</blockquote>
<h4 id="感想-6"><a href="#感想-6" class="headerlink" title="感想"></a>感想</h4><p>实验内容：</p>
<p>实现void pgaccess(uint64 sva,int pgnum,int* bitmask);，一个系统调用。在这里面，我们要做的是，访问从sva到sva+pgnum*PGSIZE这一范围内的虚拟地址对应的PTE，然后查看PTE的标记项是否有PTE_A。有的话则在bitmask对应位标记为1.</p>
<p>应该注意的点：</p>
<p>1.需要进行内核态到用户态的参数传递  2.需要进行系统调用的必要步骤  3.PTE_A需要自己定义</p>
<p>以上是初见。做完了发现，确实就是那么简单，我主要时间花费在下的实验版本不对，折腾来折腾去了可能有一个小时，最后还是选择了直接把测试函数搬过来手工调用。已经换到正确的年份版本了【泪目】</p>
<p>有一点我忽视了，看了提示才知道：</p>
<blockquote>
<p>Be sure to clear <code>PTE_A</code> after checking if it is set. Otherwise, it won’t be possible to determine if the page was accessed since the last time <code>pgaccess()</code> was called (i.e., the bit will be set forever).</p>
</blockquote>
<p>也就是说每次检查到一个，就需要手动清除掉PTE_A标记。</p>
<p>还有一点以前一直没注意到的，<strong>头文件的引用需要注意次序</strong>。比如说要是把spinlock.h放在proc.h后面，就会寄得很彻底。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><p>那些系统调用的登记步骤就先省略了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sva;</span><br><span class="line">  <span class="type">int</span> pgnum;</span><br><span class="line">  uint64 bitmask;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;sva) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;pgnum) &lt; <span class="number">0</span> || argaddr(<span class="number">2</span>, &amp;bitmask) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> pgaccess((<span class="type">void</span>*)sva,pgnum,(<span class="type">void</span>*)bitmask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/pgaccess.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pgaccess</span><span class="params">(<span class="type">void</span>* sva,<span class="type">int</span> pgnum,<span class="type">void</span>* bitmask)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pgnum &gt; <span class="number">32</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pgaccess: range too big.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> kmask = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pgnum;i++)&#123;</span><br><span class="line">        <span class="type">pte_t</span>* pte = walk(p-&gt;pagetable,(uint64)sva+i*PGSIZE,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 映射不存在，或者没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!pte || !(*pte &amp; PTE_A))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        kmask = (kmask | (<span class="number">1</span>&lt;&lt;i));</span><br><span class="line">        *pte = (*pte &amp; (~PTE_A));</span><br><span class="line">    &#125;</span><br><span class="line">    copyout(p-&gt;pagetable,(uint64)bitmask,(<span class="type">char</span>*)(&amp;kmask),<span class="keyword">sizeof</span>(<span class="type">int</span>)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h2><blockquote>
<p>The goal of this section and the next is to allow the kernel to directly dereference user pointers.</p>
</blockquote>
<blockquote>
<p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. </p>
<p>Modify <code>struct proc</code> to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if <code>usertests</code> runs correctly.</p>
</blockquote>
<h4 id="感想-7"><a href="#感想-7" class="headerlink" title="感想"></a>感想</h4><p>这个其实平心而论不难，思路很简单。写着不难是不难，但想明白花费了我很多时间。</p>
<p>它这个要求我们修改kernel，使得每个进程都有一份自己的kernel page。至于要改什么，围绕着proc.c中，参照pagetable的生命周期摁改就行。还有一个地方它也提示了，就是要在swtch之前更换一下satp的值。</p>
<p>接下来，我说说我思考的几个点以及犯错的地方。</p>
<h5 id="为什么要这么干"><a href="#为什么要这么干" class="headerlink" title="为什么要这么干"></a>为什么要这么干</h5><p>看完题目，我的第一印象是，这么干有啥用。。。因为我觉得以前那个所有进程共用内核栈确实很好了，没有必要每个进程配一个后来才发现，这个跟下面那个是连在一起的，目的是<code> allow the kernel to directly dereference user pointers.</code>。所以，我们下面会把用户的pgtbl和这里dump出来的kpgtbl合在一起。</p>
<h5 id="关于myproc"><a href="#关于myproc" class="headerlink" title="关于myproc()"></a>关于myproc()</h5><p>在allocproc中初始化的时候，我一开始是这么写的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c allocproc()</span></span><br><span class="line">perproc_kvminit();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">perproc_kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(p-&gt;kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  pkvmmap(p-&gt;kpgtbl,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样会死得很惨，爆出如下panic：</p>


<p>通过hints的调试贴士</p>
<blockquote>
<p>A missing page table mapping will likely cause the kernel to encounter a page fault. It will print an error that includes <code>sepc=0x00000000XXXXXXXX</code>. You can find out where the fault occurred by searching for <code>XXXXXXXX</code> in <code>kernel/kernel.asm</code>.</p>
</blockquote>
<p>我发现程序在这里绷掉了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br></pre></td></tr></table></figure>

<p>而且显而易见，是系统启动时崩的。</p>
<p>经过了漫长的思考，我震惊地发现了它为什么崩了（）</p>
<p>首先，这段代码语法上是没有问题的。它固然犯了发布未初始化完成的对象这样的并发错误，但是它并不是语法错误。我做了这样的测试样例证明它没有问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">pagetable_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span>&#123;</span></span><br><span class="line">	<span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">processes</span>[<span class="title">MAX</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> proc* <span class="title function_">myproc</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;processes[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminit</span><span class="params">()</span>&#123;</span><br><span class="line">	myproc()-&gt;kpgtbl = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> &amp;processes[<span class="number">0</span>];</span><br><span class="line">	kvminit();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;kpgtbl);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我一路顺着os启动的路径找，也想不出来这能有什么错，因而非常迷茫。</p>
<p>此时我灵光一闪，会不会是myproc()在os刚启动的时候是发挥不了作用的？于是我一路顺着myproc的代码看下去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，mycpu()获得的cpu的proc是怎么得到的呢？</p>
<p>我搜寻了一下os启动代码，发现了cpu的proc得到的路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//...很多很多init</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调度执行第一个进程</span></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完进程后，就进入scheduler进行进程的调度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">        <span class="comment">//在这里！！！！</span></span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>因而，c-&gt;proc是在创建进程的第一次调度后初始化的，也即，myproc只有在执行第一次scheduler之后才可以调用。而！！！</p>
<p>当执行调度前的userinit时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br></pre></td></tr></table></figure>

<p>它进行了allocproc。我们亲爱的allocproc接下来就会调用perproc_kvminit，然后perproc_kvminit中调用myproc。此时尚未调度，因而c-&gt;proc未初始化，myproc返回的是0，也即null。这样一来，<code>myproc()-&gt;kpgtbl</code>就发生了空指针异常，也即scause = 15——写入页错误。</p>
<p>因而，对于myproc()的调用需要慎之又慎。</p>
<h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><p>系统调用时，是如何知道要用的是p中的内核页表而非global内核页表呢？</p>
<p>依然还是从os的启动说起。</p>
<p>当userinit被调度时，全局的内核页表被换成了proc中的内核页表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c scheduler()</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpgtbl));</span><br><span class="line">sfence_vma();</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br></pre></td></tr></table></figure>

<p>但是这样还没有结束。因为我们还得更换trapframe中的内核页表相关的东西：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为啥要更换呢？因为以后系统调用的时候，uservec是从这里读取值来作为内核栈和内核页表的来源的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># in uservec</span><br><span class="line">		# restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        # 完成了内核栈的切换</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">		# 完成了页表的切换</span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br></pre></td></tr></table></figure>

<p>所以，为了以后系统调用能顺利进行，我们需要把栈帧也一起换掉。怎么换呢？我们是否还要在一些地方人工把trapframe的值设置为我们自己的内核栈内核页表？答案是，不用！这些会由其他代码自动完成。</p>
<p>前面说到userinit的进程p被调度，satp换成了我们自己的内核页表。那么，在之后的内核态，satp都将保持我们自己的内核页表。当要返回用户态时，会执行如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in usertrapret</span></span><br><span class="line">  <span class="comment">// 重置trapframe</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br></pre></td></tr></table></figure>

<p>之后返回用户态，以及之后之后的各种中断，就都会一直使用自己的内核页表了。【试了一下，这里如果改成非即时从satp读，而是默认的kernel_pagetable的话，会不知道为啥一直死循环】</p>
<p>不得不说，真是设计精妙啊！！！不过我觉得，要是这里写成kernel_pagetable，然后让我们自己改的话将是薄纱（。当然它应该也不会这么做，也许只是出于无心之举。因为，kernel_pagetable事实上是不对外发布的。它这里这么写热读，最直接的原因还是因为读不到kernel_pagetable。这算是无心插柳柳成荫吗233</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化kpgtbl。由于现在内核栈存在各自的内核页表而非global内核页表中，所以在procinit中的对内核栈的初始化也得放在这：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c allocproc()</span></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p-&gt;kpgtbl = perproc_kvminit();</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">  uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">  pkvmmap(p-&gt;kpgtbl,va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">perproc_kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pt = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(pt, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  pkvmmap(pt,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  pkvmmap(pt,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  pkvmmap(pt,CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  pkvmmap(pt,PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  pkvmmap(pt,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  pkvmmap(pt,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  pkvmmap(pt,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pkvmmap</span><span class="params">(<span class="type">pagetable_t</span> pgtbl,uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当第一个进程开始时，mycpu-&gt;proc = null,所以这里不能调用myproc</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="swtch时切换页表"><a href="#swtch时切换页表" class="headerlink" title="swtch时切换页表"></a>swtch时切换页表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c scheduler()</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpgtbl));</span><br><span class="line">sfence_vma();</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有进程运行时使用全局kernel_pagetable</span></span><br><span class="line">      kvminithart();</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改kvmpa"><a href="#修改kvmpa" class="headerlink" title="修改kvmpa"></a>修改kvmpa</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">kvmpa</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  pte = walk(myproc()-&gt;kpgtbl, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel.proc.c freeproc()</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpgtbl)</span><br><span class="line">    proc_freekpgtbl(p-&gt;kpgtbl,p-&gt;kstack);</span><br><span class="line">  p-&gt;kpgtbl = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freekpgtbl</span><span class="params">(<span class="type">pagetable_t</span> pagetable,uint64 <span class="built_in">stack</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, UART0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, VIRTIO0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, CLINT, <span class="number">0x10000</span>/(uint64)PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, PLIC, <span class="number">0X400000</span>/(uint64)PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, KERNBASE, (uint64)((uint64)etext-KERNBASE)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, (uint64)etext,(PHYSTOP-(uint64)etext)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span></span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, <span class="built_in">stack</span>, <span class="number">1</span>,<span class="number">1</span> );</span><br><span class="line">  uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Traps-and-system-calls"><a href="#Traps-and-system-calls" class="headerlink" title="Traps and system calls"></a>Traps and system calls</h1><p>traps=系统调用+异常+中断。本章着重讲traps概述以及traps中的系统调用。</p>
<p>对trap的处理包含四个部分：硬件处理、中断向量、trap handler、对应的处理函数</p>
<h2 id="RISC-V-trap-machinery"><a href="#RISC-V-trap-machinery" class="headerlink" title="RISC-V trap machinery"></a>RISC-V trap machinery</h2><h3 id="control-register"><a href="#control-register" class="headerlink" title="control register"></a>control register</h3><p>risc-v为trap提供了一组寄存器：</p>
<ol>
<li><p>stvec</p>
<p>trap handler的入口地址</p>
</li>
<li><p>sepc</p>
<p>原程序PC</p>
</li>
<li><p>scause</p>
<p>中断号</p>
</li>
<li><p>sscratch</p>
<p>TRAPFRAME地址</p>
</li>
<li><p>sstatus</p>
<p>是否允许中断，以及中断来自内核态还是用户态</p>
</li>
</ol>
<blockquote>
<p>The above registers relate to traps <strong>handled in supervisor mode</strong>, and they cannot be read or written in user mode. </p>
<p>There is an equivalent set of control registers for traps handled <strong>in machine mode</strong>; xv6 uses them <strong>only</strong> for the special case of <u>timer interrupts</u>.</p>
</blockquote>
<p>每个CPU都有自己的一套这样的控制寄存器。</p>
<h3 id="硬件处理步骤"><a href="#硬件处理步骤" class="headerlink" title="硬件处理步骤"></a>硬件处理步骤</h3><p>时钟中断、device interrupt以及关中断的情况下，不会做以下步骤。</p>
<blockquote>
<p>\1. If the trap is a device interrupt, and the sstatus SIE bit is clear, <strong>don’t</strong> do any of the following.</p>
<p>\2. Disable interrupts by clearing SIE.关中断</p>
<p>\3. Copy the pc to sepc.保存PC</p>
<p>\4. Save the current mode (user or supervisor) in the SPP bit in sstatus.保存mode</p>
<p>\5. Set scause to reflflect the trap’s cause.保存中断号</p>
<p>\6. Set the mode to supervisor.切换到内核态</p>
<p>\7. Copy stvec to the pc.将trap handler写入pc，开始执行trap handler</p>
</blockquote>
<p>切换到内核页表、切换内核栈、保存寄存器现场这些工作交给操作系统完成。</p>
<h2 id="Traps-from-user-space"><a href="#Traps-from-user-space" class="headerlink" title="Traps from user space"></a>Traps from user space</h2><p>从用户态来的trap会经历怎么样的过程？</p>
<p>前面说到，下面需要进行页表的切换，页表的切换必然是接下来要做的指令的某个环节。那么为了让页表切换之后，CPU还知道要从哪里取指执行，<strong>就要让某段物理内存在内核空间和用户空间的虚拟地址一样</strong>。这样，不论页表是用户的还是内核的，都可以通过同样的虚拟地址访问到该段存放指令的物理内存从而继续执行。</p>
<p>这段虚拟地址就是<strong>trampoline</strong>。它在内核页表和用户页表都位于MAXVA的位置。</p>
<img src="/2023/01/10/xv6/p3.png" class>

<p>stevc存储的正是trampoline段中的uservec。</p>
<h3 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h3><p>sscratch里面存的是trapframe的值。</p>
<p>trapframe存在于用户空间中，并且每个进程的trapframe所处位置固定是在trampoline下方。</p>
<img src="/2023/01/10/xv6/image-20230111203357767.png" class>

<p>首先将寄存器的值都存入trapframe中；然后，再从trapframe中读取内核栈指针、当前CPUid，下一步要跳转的usertrap的地址，以及内核页表。最后，uservec切换到内核页表，并且jmp到usertrap。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#in kernel/trampoline.S</span><br><span class="line">	.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process&#x27;s p-&gt;trapframe is</span><br><span class="line">        # mapped into user space, at TRAPFRAME.</span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">		# swap a0 and sscratch</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        # ...</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">		# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        # 完成了内核栈的切换</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        # 这里完成了页表的切换</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：trampoline和trapframe有一些相通点。</p>
<p>trampoline为了保障某段物理内存的虚拟地址在内核栈和用户栈中不变，做出的努力是，在内核栈和用户栈都分配同一位置的PTE。</p>
<p>trapframe用于保护现场、用户态向内核态传递参数等等，做出的努力是，在用户栈分配同一位置的PTE，在内核态的局部变量中保存了自己的物理地址。</p>
<p>这两个说实话有点容易混起来，因为我想了半天trampoline可不可以用类似trapframe一样的方法，结论是不行。因为你trampoline的作用是维持指令序列依然不变，不会突然没掉；而trapframe段是用来存储数据而非执行的，对其的控制也是需要指令的。如果trampoline使用第二种方法，指令流就会断掉，更别说别的了。</p>
</blockquote>
<h3 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h3><p>作用是得到trap发生的原因，并且执行对应的处理程序，然后返回结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  <span class="comment">//首先把trap handler切换到kernel的，这样一来如果在kernel中发生trap就会由kernel的handler处理</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在当前进程中再次保存用户程序的原PC，防止之后sepc被覆盖</span></span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//根据cause号不同处理</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="comment">//注意，在此处开启了中断</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用syscall处理</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行对应的处理函数"><a href="#执行对应的处理函数" class="headerlink" title="执行对应的处理函数"></a>执行对应的处理函数</h3><p>比如说system call会修改trapframe中的a0为返回的结果，会获取trapframe中的各个参数。这个“保护现场“感觉是非常微妙的，它兼顾了保护现场和传递参数两个作用</p>
<h3 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h3><p>回到用户态。之前陷入内核态对stvec、satp、sp、hartid、trap handler都做了适应内核态的改变，因而这里就需要改回原来适应用户态的样子，然后返回用户态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关中断</span></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置trapframe</span></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">		# 切换为用户页表</span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        # ...</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h2 id="Code-calling-system-calls"><a href="#Code-calling-system-calls" class="headerlink" title="Code: calling system calls"></a>Code: calling system calls</h2><blockquote>
<p>Chapter 2 ended with initcode.S invoking the exec system call (user/initcode.S:11). Let’s look at how the user call makes its way to the exec system call’s implementation in the kernel.要讲如何从用户态找到exec的代码了。</p>
</blockquote>
<h2 id="Code-system-call-arguments"><a href="#Code-system-call-arguments" class="headerlink" title="Code: system call arguments"></a>Code: system call arguments</h2><p>讲的是系统调用时，是如何把用户态传递的地址转化为内核态地址的。</p>
<p>这个部分可以看看hit实验的实验3 6.7，讲得很详细，而且流程是差不多的。linux0.11的<code>get_fs_byte()</code>就相当于xv6的<code>copyinstr</code>。</p>
<h2 id="Traps-from-kernel-space"><a href="#Traps-from-kernel-space" class="headerlink" title="Traps from kernel space"></a>Traps from kernel space</h2><h3 id="kernelvec"><a href="#kernelvec" class="headerlink" title="kernelvec"></a>kernelvec</h3><p>不同于用户态还得先潜入内核再潜出内核，内核的trap可简单多了，省去了切来切去各种东西的步骤，只需当做一个普通的函数调用就行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># in kernel/kernelvec.S</span><br><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        // make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        // save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)</span><br><span class="line">		# ...</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">	// call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        // restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        # ...</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        // return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h3 id="kerneltrap"><a href="#kerneltrap" class="headerlink" title="kerneltrap"></a>kerneltrap</h3><blockquote>
<p>kerneltrap is prepared for two types of traps: device interrrupts and exceptions. </p>
<p>It calls devintr (kernel/trap.c:177) to check for and handle the <strong>former</strong>. If the trap isn’t a device interrupt, it must be an exception, and that is always a fatal error if it occurs in the xv6 kernel; the kernel calls panic and stops executing.</p>
<p>If kerneltrap was called due to a timer interrupt, and a process’s kernel thread is running (rather than a scheduler thread), kerneltrap calls yield to give other threads a chance to run.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c</span></span><br><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Page-fault-exceptions"><a href="#Page-fault-exceptions" class="headerlink" title="Page-fault exceptions"></a>Page-fault exceptions</h2><p>似乎xv6是没有这个缺页exception的。这里主要讲解了三个可以利用缺页中断实现的优化：COW fork、lazy allocation、paging from disk。还提及了automatically extending stacks 以及memory-mapped fifiles。</p>
<h2 id="Lab-3"><a href="#Lab-3" class="headerlink" title="Lab"></a>Lab</h2><blockquote>
<p>This lab explores how system calls are implemented using traps. You will first do a warm-up exercises with stacks and then you will implement an example of user-level trap handling.</p>
</blockquote>
<h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>刚刚上去ubuntu突然发现寄了打不开。。。。看了这篇文章找到了恢复方法：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/rdw1246010462/article/details/109632296">ubuntu开机出现started gnome Display manager等错误的方法</a></p>
<p>但是我的<code>apt autoremove --purge snapd</code>指令没有用，好像是因为缺少依赖包，但又没空间下载了。折腾了一下重启发现好了，好了的话那就先凑合着用吧（</p>
<h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><h4 id="题目和答案"><a href="#题目和答案" class="headerlink" title="题目和答案"></a>题目和答案</h4><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53111905/article/details/120996446">Lab4: traps</a></p>
<p>There is a file <code>user/call.c</code> in your xv6 repo. make fs.img compiles it and also produces a readable assembly version of the program in <code>user/call.asm</code>.</p>
<p>Read the code in call.asm for the functions <code>g</code>, <code>f</code>, and <code>main</code>. Here are some questions that you should answer:</p>
</blockquote>
<ol>
<li><p>a2</p>
</li>
<li><p>被inline掉了</p>
</li>
<li><p>0x64A</p>
<img src="/2023/01/10/xv6/image-20230111224927837.png" class>

<p>auipc的作用是把立即数左移12位，低12位补0，和pc相加赋给指定寄存器。这里立即数是0，指定寄存器是ra，即ra=pc=0x30=48。jalr作用是跳转到立即数+指定寄存器处并且把ra的值+8。因此jalr会跳转1562+48=1594=0x64A处，观察汇编代码可知确实在000000000000064a处。</p>
</li>
<li><p>0x38</p>
</li>
<li><blockquote>
<p>Run the following code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>What is the output? <a target="_blank" rel="noopener" href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the RISC-V is <strong>little-endian</strong>. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<img src="/2023/01/10/xv6/format,png.png" class></blockquote>
</li>
<li><p>取决于寄存器a2（第3个参数）的值。</p>
</li>
</ol>
<h4 id="体会-3"><a href="#体会-3" class="headerlink" title="体会"></a>体会</h4><p>我超。。差不多都不会（2345），更可怕的是不会查文档，不知道从哪里看RISC-V指令集的内容，救。果然真的太弱了。</p>
<h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><blockquote>
<p>For debugging it is often useful to have a backtrace: a list of the function calls on the stack above the point at which the error occurred.</p>
<img src="/2023/01/10/xv6/image-20230111232323444.png" class>

<p>The compiler puts in each stack frame a frame pointer that holds the address of the caller’s frame pointer. Your <code>backtrace</code> should use these frame pointers to walk up the stack and print the saved return address in each stack frame.</p>
</blockquote>
<blockquote>
<p>Some hints:</p>
<ul>
<li><p>Add the prototype for backtrace to <code>kernel/defs.h</code> so that you can invoke <code>backtrace</code> in <code>sys_sleep</code>.</p>
</li>
<li><p>The GCC compiler stores the frame pointer of the currently executing function in the register s0. Add the following function to kernel/riscv.h:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and call this function in backtrace to read the current frame pointer. This function uses in-line assembly to read s0.</p>
</li>
<li><p>These <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">lecture notes</a> have a picture of the layout of stack frames. Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.</p>
</li>
<li><p>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. You can compute the top and bottom address of the stack page by using <code>PGROUNDDOWN(fp)</code> and <code>PGROUNDUP(fp)</code> (see <code>kernel/riscv.h</code>. These number are helpful for <code>backtrace</code> to terminate its loop.</p>
</li>
</ul>
</blockquote>
<h4 id="感想-8"><a href="#感想-8" class="headerlink" title="感想"></a>感想</h4><p>我超，这题真的是那怎能只叫一个拷打……</p>
<h5 id="存储在s0中的栈帧指针"><a href="#存储在s0中的栈帧指针" class="headerlink" title="存储在s0中的栈帧指针"></a>存储在s0中的栈帧指针</h5><p>这个应该是risc-v的约定成俗的特性。我搜了一下risc-v的栈帧指针保存在哪个寄存器，看到了这样一篇文章：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dai_xiangjun/article/details/126541174">risc-v 栈分析</a></p>
<img src="/2023/01/10/xv6/image-20230112012358601.png" class>
</blockquote>
<p>这个信息没有放在题干提示，是在考察信息检索能力吗（</p>
<blockquote>
<p>首先，我看完题目就麻了，不知道从何下手。我知道首先得知道栈的结构，比如说<code>The compiler puts in each stack frame a frame pointer that holds the address of the caller&#39;s frame pointer.</code>这句话说的那个pointer到底存在了栈的哪块位置，又存在了哪个寄存器。我看了提示才知道，是存在s0寄存器的。这是怎么看出来的？我完全想不到怎么就拐到s0了。</p>
</blockquote>
<h5 id="栈的结构与栈帧的理解"><a href="#栈的结构与栈帧的理解" class="headerlink" title="栈的结构与栈帧的理解"></a>栈的结构与栈帧的理解</h5><img src="/2023/01/10/xv6/image-20230112010749756.png" class>

<p>这是来自hint的栈结构。整个栈存储在一页中，由高地址向低地址增长。栈帧代表了一次函数调用，其中会存储如函数名、函数参数、局部变量等等信息。有几次函数调用就有几个栈帧，栈由栈帧组成。</p>
<p>s0中存储的栈帧指针fp指向的是栈帧的最高地址，如图fp所示。</p>
<blockquote>
<p>我理解错了栈帧的定义，都怪我基础不大牢固也不认真思考【悲】我一开始以为stack frame指的是一个栈，也即一页空间【我知道栈帧这个中文名词，但遇到英语就短路了】。老师画的这个图也被我理解为多个栈，也即多页拼在一起，要打印的Return Address处于页的最顶部。我就在这个思路上一去不复返了，压根没有意识到一个进程tmd只有一个栈啊！！！【大悲】然后顺带脑补把r_fp()也曲解了，以为它的意思是读取当前栈【非常自然地认为有很多个栈←】的下一个栈的最低地址【因为栈换掉了，所以s0也会变成父亲的栈的地址】。于是就写出了这样的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">      uint64 kstack = PGROUNDUP((uint64)(myproc()-&gt;kstack)+<span class="number">1</span>);</span><br><span class="line">      uint64 nstack = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>((nstack=(uint64)r_fp())!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*((uint64*)(kstack<span class="number">-8</span>)));</span><br><span class="line">            kstack = nstack;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果最后死循环了。去看了别人的代码发现他们写的结构就跟我完全不一样。琢磨着画着图，最后找了stack frame的定义，才恍然大悟（</p>
</blockquote>
<h5 id="思路形成"><a href="#思路形成" class="headerlink" title="思路形成"></a>思路形成</h5><p>我们只需遍历栈中所有栈帧，打印每个栈帧的Return Address部分就行。通过r_fp()获取第一个栈帧的位置，其他栈帧的位置由Prev.Frame获取。循环的界限是PGROUNDUP(r_fp())，因为栈只有一页的空间。</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  uint64 <span class="built_in">stack</span> = r_fp();</span><br><span class="line">  uint64 nstack = <span class="number">0</span>;</span><br><span class="line">  uint64 top = PGROUNDUP(<span class="built_in">stack</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">stack</span>!=top)&#123;</span><br><span class="line">    nstack=*((uint64*)(<span class="built_in">stack</span><span class="number">-16</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*((uint64*)(<span class="built_in">stack</span><span class="number">-8</span>)));</span><br><span class="line">    <span class="built_in">stack</span> = nstack;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><blockquote>
<p>In this exercise you’ll add a feature to xv6 that <u>periodically alerts a process as it uses CPU time</u>. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. </p>
<p>More generally, you’ll be implementing a primitive form of user-level interrupt/fault handlers; you could use something similar to handle page faults in the application, for example. </p>
<p>You should add a new <code>sigalarm(interval, handler)</code> system call. If an application calls <code>sigalarm(n, fn)</code>, then after every <code>n</code> “ticks” of CPU time that the program consumes, the kernel should cause application function <code>fn</code> to be called. When <code>fn</code> returns, the application should resume where it left off.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h5><p>思路：sigalarm需要在用户程序在用户态运行的情况下，监测到用户程序已经运行了n个时间片，然后发出中断请求。我们会新设置一个中断类型alarm。kerneltrap接收到sigalarm的中断请求，检测到中断类型为alarm，就会在处理的时候调用fn。fn调用完就自然而然利用中断恢复到原来的现场了。所以要做的可以分为两部分。但问题是，如何让sigalarm在用户程序运行的同时监测n个时间片呢？难道得fork一个新的进程吗？然后父进程返回，子进程执行类似sleep里面那样的监测，直到时间片到了，就发送一个中断请求，让父进程停止，执行完fn回来之后就exit。</p>
<h5 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h5><p>可以看到，初见思路很多地方跟最后是不一样的。其中错得最离谱的，也是比较隐坑很容易因为想不明白就寄了的，是handler是个用户态的函数（。你不可能在内核态中调用fn，然后fn执行完后再自然而然地通过中断机制返回，因为你想要执行fn就必须进入用户态。这一点是需要一开始明确的。</p>
<p>明确了这一点后，让人更加不知道该怎么办了。那就一步步跟着指导书的脚步来思考吧。</p>
<h6 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h6><p>首先，明确你需要实现什么。你需要实现两个系统调用，一个是sigalarm，一个是sigreturn。它们会被这样调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in user/alarmtest.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  test0();</span><br><span class="line">  test1();</span><br><span class="line">  test2();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">periodic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  count = count + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;alarm!\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 此处调用sigreturn</span></span><br><span class="line">  sigreturn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tests whether the kernel calls</span></span><br><span class="line"><span class="comment">// the alarm handler even a single time.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;test0 start\n&quot;</span>);</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 此处调用sigalarm</span></span><br><span class="line">  sigalarm(<span class="number">2</span>, periodic);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>*<span class="number">500000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((i % <span class="number">1000000</span>) == <span class="number">0</span>)</span><br><span class="line">      write(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此处调用sigalarm</span></span><br><span class="line">  sigalarm(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test0 passed\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ntest0 failed: the kernel never called the alarm handler\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__ ((noinline)) foo(<span class="type">int</span> i, <span class="type">int</span> *j) &#123;</span><br><span class="line">  <span class="keyword">if</span>((i % <span class="number">2500000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    write(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *j += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// tests that the kernel calls the handler multiple times.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// tests that, when the handler returns, it returns to</span></span><br><span class="line"><span class="comment">// the point in the program where the timer interrupt</span></span><br><span class="line"><span class="comment">// occurred, with all registers holding the same values they</span></span><br><span class="line"><span class="comment">// held when the interrupt occurred.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;test1 start\n&quot;</span>);</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  sigalarm(<span class="number">2</span>, periodic);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">500000000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">10</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    foo(i, &amp;j);</span><br><span class="line">  &#125;</span><br><span class="line">  sigalarm(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line">  <span class="keyword">if</span>(count &lt; <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ntest1 failed: too few calls to the handler\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">    <span class="comment">// the loop should have called foo() i times, and foo() should</span></span><br><span class="line">    <span class="comment">// have incremented j once per call, so j should equal i.</span></span><br><span class="line">    <span class="comment">// once possible source of errors is that the handler may</span></span><br><span class="line">    <span class="comment">// return somewhere other than where the timer interrupt</span></span><br><span class="line">    <span class="comment">// occurred; another is that that registers may not be</span></span><br><span class="line">    <span class="comment">// restored correctly, causing i or j or the address ofj</span></span><br><span class="line">    <span class="comment">// to get an incorrect value.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ntest1 failed: foo() executed fewer times than it was called\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1 passed\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再结合提示，可知实验设计者给我们的思路是，通过sigalarm设置定时函数，通过sigalarm(0,0)取消定时函数。每次时钟中断检测当前定时时间是否达到，若已达到，则跳到定时函数执行。定时函数执行完后，需要借助sigreturn，才能正确返回时钟中断前的程序点。</p>
<h6 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h6><p>这又可拆解为几个要点：</p>
<ol>
<li>如何实现“定时”？</li>
<li>时钟中断在内核态的usertrap被检测。怎么从usertrap出来跳到定时函数而非原程序执行点？</li>
<li>执行完定时函数后，怎么样才能回到原程序执行点？</li>
</ol>
<h6 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a>part 3</h6><p>一个个来说，首先是如何实现定时。这个很简单。参照sys_sleep的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  backtrace();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，我们可以用ticks表示当前系统滴答数。这样，我们就可以在proc域里维护一个变量lasttick，记录上一次执行handler时的滴答数。每次在时钟中断时检测，所以需要写在<code>kernel/trap.c</code>中的<code>usertrap</code>中。</p>
<h6 id="part-4"><a href="#part-4" class="headerlink" title="part 4"></a>part 4</h6><p>然后，是怎么从usertrap出来跳到指定程序结束点。在书中，我们知道，sepc寄存器保存了中断前原程序的下一个执行点，sepc的备份存储在了proc域中的栈帧中。当中断返回时（在usertrapret中），会从栈帧中的epc字段读取sepc的备份赋值给sepc，再由sret帮助我们跳转到原程序点。因而，如果想要改变跳转点，我们只需要修改<code>p-&gt;trapframe-&gt;epc</code>就行。</p>
<h6 id="part-5"><a href="#part-5" class="headerlink" title="part 5"></a>part 5</h6><p>最后，是如何从periodic回到原程序执行点。</p>
<img src="/2023/01/10/xv6/image-20230113002057893.png" class>

<p>这是每次进行时钟中断时的栈情况和执行代码链：t1-&gt;trampoline-&gt;usertrap-&gt;handler。</p>
<p>再然后，handler调用了sigreturn，用户栈中就会产生sigreturn的栈帧：</p>
<img src="/2023/01/10/xv6/image-20230113002434093.png" class>

<p>此时，如果sigreturn执行完，就会在这样的情况下执行handler的ret指令：</p>
<img src="/2023/01/10/xv6/image-20230113002542335.png" class>

<p>ret指令会把栈帧弄走，也就是说会直接回到某个错误的地方去。这显然不大合适。所以，我们要做的，就是在sigreturn之后，<u>不执行handler的ret指令，也不执行sigreturn的ret指令，而是直接恢复到时钟中断前的上下文</u>。时钟中断前的上下文，会因在handler中调用sigreturn系统调用，而被<strong>覆盖</strong>，因而，我们就需要记录时钟中断前的上下文，也即在proc域中保存trapframe的一份拷贝savedtrap，每次时钟中断都更新一次savedtrap，然后在sigreturn调用的时候将proc原本的trapframe替换为savedtrap即可。这样一来，就完成了这道题。</p>
<h5 id="感想-9"><a href="#感想-9" class="headerlink" title="感想"></a>感想</h5><p>这题目确实最终代码看起来完全不难，但是非常地拷打。。。。我前前后后修修补补差不多一共花了五个小时之久。</p>
<p>计时怎么计，以及使用trapframe-&gt;epc来跳转这两点还是很容易想到的【话虽如此，其实也很曲折】。主要难点还是在怎么恢复现场。怎么说呢，我花了这么久做实验，但是实际笔记却写不出个鬼来，足以看出其复杂程度。</p>
<p>我主要还是思维固化了点，一直在想，怎么确保它正确返回现场。我一开始以为proc域保存一个寄存器状态，且只用在一开始设置定时函数也即sigalarm的时候保存一次就行了，并且认为其是epc。然而实际操作后发现usertrap崩了，并且epc中存储的并不是程序被时钟中断的地方，而是各种神奇的地方，具体我也忘了，反正不能行。我印象最深刻的是有一次停在了usys.S中的sigreturn的最后一个ret处。我就在想，也许是栈出了问题。于是我就想着直接在sigreturn的时候把epc指向栈帧中的return address，直接回到原执行段。我百度了一下，确实有这么个寄存器ra，存储着return address。于是我就把proc域的状态换成了ra，依然仅保存一次，最后发现还是不行，程序在test0之后就异常终止了，main也回不去，十分古怪，十分匪夷所思。我实在没忍住，百度了一下大家怎么做的，发现大家压根没有我这样的二选一的烦恼，是直接保存整个栈帧。而且也不是仅保存一次，而是每次时钟中断触发都保存一次。我觉得十分奇怪震惊，但此时已是差不多晚饭时间，我就先去吃了个饭（）</p>
<p>回来之后，我细细画了图【向正确思路part5中的那样】，发现我原来那个只保存两者之一，且都只保存一次的方式，确实完全不能行。但是，我发现两个一起保存，并且每次时钟中断保存的方法，似乎能行，而且，比保存一整个栈帧要聪明得多。于是我就去试了，发现还是不行。我再细想了一遍，发现，如果想回去原程序的现场，除了ra和epc，还有一个很重要的东西需要保存，那就是——用户栈指针sp！</p>
<p>也就是说，<strong>只需保存ra、epc、sp，就可以保证回到正确的时钟中断前的位置</strong>：</p>
<img src="/2023/01/10/xv6/image-20230113005100895.png" class>

<p>此为handler中sigreturn执行完要返回时的状态。</p>
<p>当处在handler中时，sp的值为sigreturn处的栈帧。执行系统调用时，proc域中的上下文被覆盖，也即时钟中断前的上下文被覆盖。如果此时不对栈帧中的sp进行恢复，仅恢复ra和epc，在从sigreturn返回到epc对应处也即t1，t1执行ret想回到main的时候，就会回不去，而是回到了sigreturn要回的位置，也即handler的位置，然后不知不觉就寄了。所以，就需要防止sp被覆盖。因而，再保存一个状态sp，就可以保障回到正确的地方了。测试出来，kernel确实不再会panic了。</p>
<p>但是由于运行时很多除这三个以外的寄存器都被改过了，回是回得去，接下来干的活就不一定对了。因此为了保险以及通用性以及便利性来看，还是像别人那样直接保存栈帧比较ok。</p>
<p>还有一件事，就是上述错误中经常会出现的一个输出结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usertrap:unexpected cause scause = <span class="number">0x0c</span></span><br></pre></td></tr></table></figure>

<p>我留意了一下是什么意思。网上搜索得，scause=12，说明这是一个instruction page fault，而这个缺页错误说明了什么？：</p>
<img src="/2023/01/10/xv6/image-20230113012355740.png" class>

<p>这样，一切都明朗了。出现了scause=0x0c的意思就是说pc里的值不恰当，也就是说上面错误的方法都会跳转到错误的地方去。</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><h5 id="sigalarm-c"><a href="#sigalarm-c" class="headerlink" title="sigalarm.c"></a>sigalarm.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> intervel,<span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;interval = intervel;</span><br><span class="line">    p-&gt;handler = handler;</span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    p-&gt;lasttick = ticks;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">if</span>(handler == <span class="number">0</span> &amp;&amp; intervel == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(p-&gt;savetrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sigreturn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    memmove(p-&gt;trapframe,p-&gt;savetrap,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="trap-c"><a href="#trap-c" class="headerlink" title="trap.c"></a>trap.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">    yield();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;interval!=<span class="number">0</span>&amp;&amp;p-&gt;flag!=<span class="number">1</span>)&#123;</span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      uint tmp = ticks-p-&gt;lasttick;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">if</span>(tmp &gt;= p-&gt;interval&amp;&amp;p-&gt;flag!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          memmove(p-&gt;savetrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">          p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;	</span><br><span class="line">          p-&gt;flag=<span class="number">1</span>;</span><br><span class="line">          p-&gt;lasttick = ticks;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/21/JavaWeb/" rel="prev" title="JavaWeb">
      <i class="fa fa-chevron-left"></i> JavaWeb
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Operating-system-interface"><span class="nav-number">1.</span> <span class="nav-text">Operating system interface</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-and-memory"><span class="nav-number">1.1.</span> <span class="nav-text">Process and memory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork"><span class="nav-number">1.1.1.</span> <span class="nav-text">fork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exec"><span class="nav-number">1.1.2.</span> <span class="nav-text">exec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exec%E4%B8%8Efork"><span class="nav-number">1.1.3.</span> <span class="nav-text">exec与fork</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-and-File-descriptors"><span class="nav-number">1.2.</span> <span class="nav-text">I&#x2F;O and File descriptors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.2.1.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read%E3%80%81write"><span class="nav-number">1.2.2.</span> <span class="nav-text">read、write</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close"><span class="nav-number">1.2.3.</span> <span class="nav-text">close</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#open"><span class="nav-number">1.2.4.</span> <span class="nav-text">open</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.5.</span> <span class="nav-text">重定向的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="nav-number">1.2.6.</span> <span class="nav-text">共享偏移量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dup"><span class="nav-number">1.2.7.</span> <span class="nav-text">dup</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pipe"><span class="nav-number">1.3.</span> <span class="nav-text">Pipe</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%AE%A1%E9%81%93%E5%91%BD%E4%BB%A4"><span class="nav-number">1.3.2.</span> <span class="nav-text">实现管道命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File-system"><span class="nav-number">1.4.</span> <span class="nav-text">File system</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab"><span class="nav-number">1.5.</span> <span class="nav-text">Lab</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%87%86%E5%A4%87"><span class="nav-number">1.5.1.</span> <span class="nav-text">虚拟机准备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vmware"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">vmware</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81"><span class="nav-number">1.5.1.1.1.</span> <span class="nav-text">账号密码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8vmdk%E6%96%87%E4%BB%B6"><span class="nav-number">1.5.1.1.2.</span> <span class="nav-text">怎么使用vmdk文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-XShell"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">阿里云服务器+XShell</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ubuntu%E7%B3%BB%E7%BB%9F%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">ubuntu系统忘记密码了怎么办</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5grub%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.1.3.1.</span> <span class="nav-text">如何进入grub模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5grub%E6%A8%A1%E5%BC%8F%E5%90%8E%E6%8C%89%E4%BB%80%E4%B9%88"><span class="nav-number">1.5.1.3.2.</span> <span class="nav-text">进入grub模式后按什么</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E4%B8%8D%E4%BA%86%E7%BD%91"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">连不了网</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">1.5.2.</span> <span class="nav-text">配置实验环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7%E9%93%BE"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">下载工具链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91xv6%E6%BA%90%E7%A0%81"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">下载编译xv6源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%97%ADqemu"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">关闭qemu</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95gdb%E6%98%AF%E5%90%A6ok"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">测试gdb是否ok</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">自测方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="nav-number">1.5.3.</span> <span class="nav-text">实验内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99sleep-c"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">编写sleep.c</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%93%E4%BC%9A"><span class="nav-number">1.5.3.1.1.</span> <span class="nav-text">体会</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.3.1.1.1.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">1.5.3.1.1.2.</span> <span class="nav-text">系统调用过程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.3.1.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99pingpong%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">编写pingpong程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%93%E4%BC%9A-1"><span class="nav-number">1.5.3.2.1.</span> <span class="nav-text">体会</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">1.5.3.2.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.3.2.2.1.</span> <span class="nav-text">工具函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#pingpong"><span class="nav-number">1.5.3.2.2.2.</span> <span class="nav-text">pingpong</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99primes"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">编写primes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99find"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">编写find</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E7%89%88"><span class="nav-number">1.5.3.4.1.</span> <span class="nav-text">初始版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E9%A2%98%EF%BC%9A%E6%94%AF%E6%8C%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.5.3.4.2.</span> <span class="nav-text">附加题：支持正则表达式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99xargs"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">编写xargs</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%93%E4%BC%9A-2"><span class="nav-number">1.5.3.5.1.</span> <span class="nav-text">体会</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">1.5.3.5.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E9%A2%98%EF%BC%9A%E6%94%B9%E5%96%84shell"><span class="nav-number">1.5.3.6.</span> <span class="nav-text">附加题：改善shell</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.4.</span> <span class="nav-text">提交代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Operating-system-oganization"><span class="nav-number">2.</span> <span class="nav-text">Operating system oganization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel-organization"><span class="nav-number">2.1.</span> <span class="nav-text">Kernel organization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E5%86%85%E6%A0%B8%E4%B8%8E%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="nav-number">2.1.1.</span> <span class="nav-text">宏内核与微内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code-xv6-organization"><span class="nav-number">2.1.2.</span> <span class="nav-text">Code: xv6 organization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-overview"><span class="nav-number">2.2.</span> <span class="nav-text">Process overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-starting-xv6-and-the-fifirst-process"><span class="nav-number">2.3.</span> <span class="nav-text">Code: starting xv6 and the fifirst process</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#xv6"><span class="nav-number">2.3.1.</span> <span class="nav-text">xv6</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">加载操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">操作系统初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#entry-S%E9%85%8D%E7%BD%AE%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="nav-number">2.3.1.2.1.</span> <span class="nav-text">entry.S配置栈空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#start-c"><span class="nav-number">2.3.1.2.2.</span> <span class="nav-text">start.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#main-c"><span class="nav-number">2.3.1.2.3.</span> <span class="nav-text">main.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#proc-c%E4%B8%AD%E7%9A%84userinit"><span class="nav-number">2.3.1.2.4.</span> <span class="nav-text">proc.c中的userinit()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#initcode-S"><span class="nav-number">2.3.1.2.5.</span> <span class="nav-text">initcode.S</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#init-c"><span class="nav-number">2.3.1.2.6.</span> <span class="nav-text">init.c</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">感想</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux0-11"><span class="nav-number">2.3.2.</span> <span class="nav-text">linux0.11</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">加载操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%85%A5bootsect-s"><span class="nav-number">2.3.2.1.1.</span> <span class="nav-text">读入bootsect.s</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bootsect-s"><span class="nav-number">2.3.2.1.2.</span> <span class="nav-text">bootsect.s</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setup-s"><span class="nav-number">2.3.2.1.3.</span> <span class="nav-text">setup.s</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">操作系统初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#head-s"><span class="nav-number">2.3.2.2.1.</span> <span class="nav-text">head.s</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#main-c-1"><span class="nav-number">2.3.2.2.2.</span> <span class="nav-text">main.c</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-1"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">感想</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world"><span class="nav-number">2.4.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-1"><span class="nav-number">2.5.</span> <span class="nav-text">Lab</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#trace"><span class="nav-number">2.5.1.</span> <span class="nav-text">trace</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-2"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">代码步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%AD%BE%E5%90%8D"><span class="nav-number">2.5.1.2.1.</span> <span class="nav-text">在各种文件添加签名</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#user-user-h"><span class="nav-number">2.5.1.2.1.1.</span> <span class="nav-text">user&#x2F;user.h</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#user-usys-pl"><span class="nav-number">2.5.1.2.1.2.</span> <span class="nav-text">user&#x2F;usys.pl</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#syscall-h"><span class="nav-number">2.5.1.2.1.3.</span> <span class="nav-text">syscall.h</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#syscall-c"><span class="nav-number">2.5.1.2.1.4.</span> <span class="nav-text">syscall.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9Makefile"><span class="nav-number">2.5.1.2.1.5.</span> <span class="nav-text">修改Makefile</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="nav-number">2.5.1.2.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9proc-h"><span class="nav-number">2.5.1.2.2.1.</span> <span class="nav-text">修改proc.h</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BC%96%E5%86%99trace-c"><span class="nav-number">2.5.1.2.2.2.</span> <span class="nav-text">编写trace.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9syscall-c"><span class="nav-number">2.5.1.2.2.3.</span> <span class="nav-text">修改syscall.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%A8sysproc-c%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.5.1.2.2.4.</span> <span class="nav-text">在sysproc.c中添加系统调用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%A8defs-h%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9C%80%E8%A6%81public%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><span class="nav-number">2.5.1.2.2.5.</span> <span class="nav-text">在defs.h中添加需要public的函数签名</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sysinfotest"><span class="nav-number">2.5.2.</span> <span class="nav-text">sysinfotest</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-3"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sysinfo-c"><span class="nav-number">2.5.2.2.1.</span> <span class="nav-text">sysinfo.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sysproc-c%E4%B8%AD"><span class="nav-number">2.5.2.2.2.</span> <span class="nav-text">sysproc.c中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kalloc-c%E4%B8%AD"><span class="nav-number">2.5.2.2.3.</span> <span class="nav-text">kalloc.c中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#proc-c%E4%B8%AD"><span class="nav-number">2.5.2.2.4.</span> <span class="nav-text">proc.c中</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E9%A2%98"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">附加题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#trace-plus"><span class="nav-number">2.5.2.3.1.</span> <span class="nav-text">trace plus</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sysinfo-plus"><span class="nav-number">2.5.2.3.2.</span> <span class="nav-text">sysinfo plus</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Page-tables"><span class="nav-number">3.</span> <span class="nav-text">Page tables</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Paging-hardware"><span class="nav-number">3.1.</span> <span class="nav-text">Paging hardware</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.1.1.</span> <span class="nav-text">为什么需要页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%BB%84%E6%88%90"><span class="nav-number">3.1.2.</span> <span class="nav-text">页表组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">页表项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%A1%B5%E8%A1%A8%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">单页表和多级页表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.3.</span> <span class="nav-text">页表使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel-address-space"><span class="nav-number">3.2.</span> <span class="nav-text">Kernel address space</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-creating-an-address-space"><span class="nav-number">3.3.</span> <span class="nav-text">Code: creating an address space</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vm-c"><span class="nav-number">3.3.1.</span> <span class="nav-text">vm.c</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA%E4%BE%8B%E4%BB%8B%E7%BB%8D%E5%90%84%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">以初始化为例介绍各个函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.3.1.1.1.</span> <span class="nav-text">创建页表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A3%85%E4%B8%8A%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.3.1.1.2.</span> <span class="nav-text">装上页表</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Physical-memory-allocation"><span class="nav-number">3.4.</span> <span class="nav-text">Physical memory allocation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Physical-memory-allocator"><span class="nav-number">3.5.</span> <span class="nav-text">Code: Physical memory allocator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-address-space"><span class="nav-number">3.6.</span> <span class="nav-text">Process address space</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-sbrk"><span class="nav-number">3.7.</span> <span class="nav-text">Code: sbrk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-exec"><span class="nav-number">3.8.</span> <span class="nav-text">Code:exec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world-1"><span class="nav-number">3.9.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-2"><span class="nav-number">3.10.</span> <span class="nav-text">Lab</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Speed-up-system-calls"><span class="nav-number">3.10.1.</span> <span class="nav-text">Speed up system calls</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-4"><span class="nav-number">3.10.1.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%8C%E9%BE%99"><span class="nav-number">3.10.1.1.1.</span> <span class="nav-text">乌龙</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#panic-freewalk-leaf"><span class="nav-number">3.10.1.1.2.</span> <span class="nav-text">panic:freewalk leaf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.10.1.1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="nav-number">3.10.1.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E7%AD%94%E9%A2%98"><span class="nav-number">3.10.1.3.</span> <span class="nav-text">问答题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Print-a-page-table"><span class="nav-number">3.10.2.</span> <span class="nav-text">Print a page table</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-5"><span class="nav-number">3.10.2.1.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="nav-number">3.10.2.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E7%AD%94%E9%A2%98-1"><span class="nav-number">3.10.2.3.</span> <span class="nav-text">问答题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Detecting-which-pages-have-been-accessed"><span class="nav-number">3.10.3.</span> <span class="nav-text">Detecting which pages have been accessed</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-6"><span class="nav-number">3.10.3.1.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="nav-number">3.10.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A-kernel-page-table-per-process"><span class="nav-number">3.11.</span> <span class="nav-text">A kernel page table per process</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-7"><span class="nav-number">3.11.0.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%B9%B2"><span class="nav-number">3.11.0.1.1.</span> <span class="nav-text">为什么要这么干</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Emyproc"><span class="nav-number">3.11.0.1.2.</span> <span class="nav-text">关于myproc()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">3.11.0.1.3.</span> <span class="nav-text">系统调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="nav-number">3.11.0.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.11.0.2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#swtch%E6%97%B6%E5%88%87%E6%8D%A2%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.11.0.2.2.</span> <span class="nav-text">swtch时切换页表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9kvmpa"><span class="nav-number">3.11.0.2.3.</span> <span class="nav-text">修改kvmpa</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8A%E6%94%BE"><span class="nav-number">3.11.0.2.4.</span> <span class="nav-text">释放</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Traps-and-system-calls"><span class="nav-number">4.</span> <span class="nav-text">Traps and system calls</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RISC-V-trap-machinery"><span class="nav-number">4.1.</span> <span class="nav-text">RISC-V trap machinery</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#control-register"><span class="nav-number">4.1.1.</span> <span class="nav-text">control register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.1.2.</span> <span class="nav-text">硬件处理步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traps-from-user-space"><span class="nav-number">4.2.</span> <span class="nav-text">Traps from user space</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#uservec"><span class="nav-number">4.2.1.</span> <span class="nav-text">uservec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usertrap"><span class="nav-number">4.2.2.</span> <span class="nav-text">usertrap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.3.</span> <span class="nav-text">执行对应的处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usertrapret"><span class="nav-number">4.2.4.</span> <span class="nav-text">usertrapret</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#userret"><span class="nav-number">4.2.5.</span> <span class="nav-text">userret</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-calling-system-calls"><span class="nav-number">4.3.</span> <span class="nav-text">Code: calling system calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-system-call-arguments"><span class="nav-number">4.4.</span> <span class="nav-text">Code: system call arguments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traps-from-kernel-space"><span class="nav-number">4.5.</span> <span class="nav-text">Traps from kernel space</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kernelvec"><span class="nav-number">4.5.1.</span> <span class="nav-text">kernelvec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kerneltrap"><span class="nav-number">4.5.2.</span> <span class="nav-text">kerneltrap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-fault-exceptions"><span class="nav-number">4.6.</span> <span class="nav-text">Page-fault exceptions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-3"><span class="nav-number">4.7.</span> <span class="nav-text">Lab</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%8F%92%E6%9B%B2"><span class="nav-number">4.7.1.</span> <span class="nav-text">小插曲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RISC-V-assembly"><span class="nav-number">4.7.2.</span> <span class="nav-text">RISC-V assembly</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88"><span class="nav-number">4.7.2.1.</span> <span class="nav-text">题目和答案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%93%E4%BC%9A-3"><span class="nav-number">4.7.2.2.</span> <span class="nav-text">体会</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Backtrace"><span class="nav-number">4.7.3.</span> <span class="nav-text">Backtrace</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-8"><span class="nav-number">4.7.3.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%9C%A8s0%E4%B8%AD%E7%9A%84%E6%A0%88%E5%B8%A7%E6%8C%87%E9%92%88"><span class="nav-number">4.7.3.1.1.</span> <span class="nav-text">存储在s0中的栈帧指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E6%A0%88%E5%B8%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">4.7.3.1.2.</span> <span class="nav-text">栈的结构与栈帧的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%E5%BD%A2%E6%88%90"><span class="nav-number">4.7.3.1.3.</span> <span class="nav-text">思路形成</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="nav-number">4.7.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Alarm"><span class="nav-number">4.7.4.</span> <span class="nav-text">Alarm</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">4.7.4.1.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E8%A7%81%E6%80%9D%E8%B7%AF"><span class="nav-number">4.7.4.1.1.</span> <span class="nav-text">初见思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF"><span class="nav-number">4.7.4.1.2.</span> <span class="nav-text">正确思路</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#part-1"><span class="nav-number">4.7.4.1.2.1.</span> <span class="nav-text">part 1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#part-2"><span class="nav-number">4.7.4.1.2.2.</span> <span class="nav-text">part 2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#part-3"><span class="nav-number">4.7.4.1.2.3.</span> <span class="nav-text">part 3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#part-4"><span class="nav-number">4.7.4.1.2.4.</span> <span class="nav-text">part 4</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#part-5"><span class="nav-number">4.7.4.1.2.5.</span> <span class="nav-text">part 5</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-9"><span class="nav-number">4.7.4.1.3.</span> <span class="nav-text">感想</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="nav-number">4.7.4.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sigalarm-c"><span class="nav-number">4.7.4.2.1.</span> <span class="nav-text">sigalarm.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#trap-c"><span class="nav-number">4.7.4.2.2.</span> <span class="nav-text">trap.c</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">修年</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">修年</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
