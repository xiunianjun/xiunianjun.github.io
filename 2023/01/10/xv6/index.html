<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiunianjun.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="【推荐点击文章小标题，进入带书签的详情页阅读】 部分地方的翻译和表格来源参考：xv6指导书翻译 实验官网：6.S081 记得结合书本的笔记阅读，这里只记录了一点看心情觉得想记就记的东西以及实验感想。 笔记的结构【以第一章Operating system interface为例】：   Operating system interfacechapt1 Operating system oganiz">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6">
<meta property="og:url" content="https://xiunianjun.github.io/2023/01/10/xv6/index.html">
<meta property="og:site_name" content="修年">
<meta property="og:description" content="【推荐点击文章小标题，进入带书签的详情页阅读】 部分地方的翻译和表格来源参考：xv6指导书翻译 实验官网：6.S081 记得结合书本的笔记阅读，这里只记录了一点看心情觉得想记就记的东西以及实验感想。 笔记的结构【以第一章Operating system interface为例】：   Operating system interfacechapt1 Operating system oganiz">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124235649128.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230107232802540.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230107233741922.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121162324747.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230108011824655.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230108012316631.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230108013156116.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230108013849664.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230109153937459.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230109151346780.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1eXVhbmRl,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/p3.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230109222917346.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/v2-e15454bf032baa4dc088b6e41ed4f4a4_1440w.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230109225700837.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230109234930690.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230110010651653.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/v2-0c2603da4c8102e46ae390a0d0b1191d_1440w.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230110225359361.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230110231020570.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111000329475.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111004330079.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111004500827.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230114011100370.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/p3.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111203357767.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111224927837.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/format,png.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230111232323444.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230112012358601.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230112010749756.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230113002057893.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230113002434093.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230113002542335.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230113005100895.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230113012355740.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230116154004538.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230116165910356.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230116154004538.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230116225124363.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230117161404719.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230117213903706.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230117235028133.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230118003118745.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230115160523827.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230115170107044.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230220234406239.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230115231857670.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230115231457971.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230122163938601.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230123172138766.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230123174332113.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230123174620818.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230123174921100.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230123170805666.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230118221757367.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120150659730.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120150715925.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120151051989.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120151353712.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120151807102.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120151820455.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230120232149776.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121160555370.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121160641718.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121162324747.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124151719288.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121162324747.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230123212753931.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230123234919055.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121162324747.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124153309132.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124163025094.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124173241241.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124232433793.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230125173143735.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230125162542807.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230125165612112.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/640.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/640-1676793944101-7.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230219160725978.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/v2-249a3f162de88198bbe415110fc71c7f_1440w.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/v2-9377a260d034d2904b1807d3fe53dcd9_1440w.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/v2-942e1ed598eed3d401d00e4719224d27_1440w.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/v2-555d017ce5b65457f98617a5fdf232af_1440w.jpg">
<meta property="og:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230121162324747.png">
<meta property="article:published_time" content="2023-01-10T12:25:29.000Z">
<meta property="article:modified_time" content="2023-02-26T04:27:46.691Z">
<meta property="article:author" content="修年">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiunianjun.github.io/2023/01/10/xv6/image-20230124235649128.png">

<link rel="canonical" href="https://xiunianjun.github.io/2023/01/10/xv6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>xv6 | 修年</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">修年</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiunianjun.github.io/2023/01/10/xv6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="修年">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修年">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          xv6
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-10 20:25:29" itemprop="dateCreated datePublished" datetime="2023-01-10T20:25:29+08:00">2023-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 12:27:46" itemprop="dateModified" datetime="2023-02-26T12:27:46+08:00">2023-02-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>【推荐点击文章小标题，进入带书签的详情页阅读】</p>
<p>部分地方的翻译和表格来源参考：<a target="_blank" rel="noopener" href="http://xv6.dgs.zone/">xv6指导书翻译</a></p>
<p>实验官网：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/tools.html">6.S081</a></p>
<p>记得结合书本的笔记阅读，这里只记录了一点看心情觉得想记就记的东西以及实验感想。</p>
<p>笔记的结构【以第一章Operating system interface为例】：</p>
<img src="/2023/01/10/xv6/image-20230124235649128.png" class>
</blockquote>
<h1 id="Operating-system-interface"><a href="#Operating-system-interface" class="headerlink" title="Operating system interface"></a>Operating system interface</h1><p><a href="https://xiunianjun.github.io/2023/01/10/xv6_chap1">chapt1</a></p>
<h1 id="Operating-system-oganization"><a href="#Operating-system-oganization" class="headerlink" title="Operating system oganization"></a>Operating system oganization</h1><blockquote>
<p>Before you start coding, read Chapter 2 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev1.pdf">xv6 book</a>, and Sections 4.3 and 4.4 of Chapter 4, and related source files:</p>
<ul>
<li>The user-space code for systems calls is in <code>user/user.h</code> and <code>user/usys.pl</code>.</li>
<li>The kernel-space code is <code>kernel/syscall.h</code>, kernel/syscall.c.</li>
<li>The process-related code is <code>kernel/proc.h</code> and <code>kernel/proc.c</code>.</li>
</ul>
</blockquote>
<p>这章主要是讲了操作系统为了兼顾并发性、隔离性、交互性做出的基本架构。</p>
<h2 id="Kernel-organization"><a href="#Kernel-organization" class="headerlink" title="Kernel organization"></a>Kernel organization</h2><h3 id="宏内核与微内核"><a href="#宏内核与微内核" class="headerlink" title="宏内核与微内核"></a>宏内核与微内核</h3><p>操作系统一个很重要的设计问题就是，哪部分的代码需要run在内核态，哪部分的需要run在用户态。</p>
<p>如果将操作系统所有系统调用统统都在内核态run，这种设计方式就叫宏内核<em>monolithic kernel</em>。</p>
<p>如果仅将系统调用中必要的部分在内核态run，其他部分都在用户态run，并且采取Client/Server这样的异步通信方式，这种设计方式就叫微内核<em>microkernel</em>。</p>
<img src="/2023/01/10/xv6/image-20230107232802540.png" class>

<blockquote>
<p>由于客户/服务器（Client/Server）模式，具有非常多的优点，故在单机<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BE%AE%E5%86%85%E6%A0%B8">微内核</a>操作系统中几乎无一例外地都采用客户/服务器模式，将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B">进程</a>)中实现。</p>
</blockquote>
<p>在微内核中，内核接口由一些用于启动应用程序、发送消息、访问设备硬件等的低级功能组成。这种组织允许内核相对简单，因为大多数操作系统驻留在用户级服务器中。</p>
<p>像大多数Unix操作系统一样，Xv6是作为一个宏内核实现的。因此，xv6内核接口对应于操作系统接口，内核实现了完整的操作系统。</p>
<h3 id="Code-xv6-organization"><a href="#Code-xv6-organization" class="headerlink" title="Code: xv6 organization"></a>Code: xv6 organization</h3><p>XV6的源代码位于<code>kernel</code>子目录中，源代码按照模块化的概念划分为多个文件，图2.2列出了这些文件，模块间的接口都被定义在了<code>def.h</code>（<code>kernel/defs.h</code>）。</p>
<table>
<thead>
<tr>
<th><strong>文件</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>bio.c</strong></td>
<td>文件系统的磁盘块缓存</td>
</tr>
<tr>
<td><strong>console.c</strong></td>
<td>连接到用户的键盘和屏幕</td>
</tr>
<tr>
<td><strong>entry.S</strong></td>
<td>首次启动指令</td>
</tr>
<tr>
<td><strong>exec.c</strong></td>
<td><code>exec()</code>系统调用</td>
</tr>
<tr>
<td><strong>file.c</strong></td>
<td>文件描述符支持</td>
</tr>
<tr>
<td><strong>fs.c</strong></td>
<td>文件系统</td>
</tr>
<tr>
<td><strong>kalloc.c</strong></td>
<td>物理页面分配器</td>
</tr>
<tr>
<td><strong>kernelvec.S</strong></td>
<td>处理来自内核的陷入指令以及计时器中断</td>
</tr>
<tr>
<td><strong>log.c</strong></td>
<td>文件系统日志记录以及崩溃修复</td>
</tr>
<tr>
<td><strong>main.c</strong></td>
<td>在启动过程中控制其他模块初始化</td>
</tr>
<tr>
<td><strong>pipe.c</strong></td>
<td>管道</td>
</tr>
<tr>
<td><strong>plic.c</strong></td>
<td>RISC-V中断控制器</td>
</tr>
<tr>
<td><strong>printf.c</strong></td>
<td>格式化输出到控制台</td>
</tr>
<tr>
<td><strong>proc.c</strong></td>
<td>进程和调度</td>
</tr>
<tr>
<td><strong>sleeplock.c</strong></td>
<td>Locks that yield the CPU</td>
</tr>
<tr>
<td><strong>spinlock.c</strong></td>
<td>Locks that don’t yield the CPU.</td>
</tr>
<tr>
<td><strong>start.c</strong></td>
<td>早期机器模式启动代码</td>
</tr>
<tr>
<td><strong>string.c</strong></td>
<td>字符串和字节数组库</td>
</tr>
<tr>
<td><strong>swtch.c</strong></td>
<td>线程切换</td>
</tr>
<tr>
<td><strong>syscall.c</strong></td>
<td>Dispatch system calls to handling function.</td>
</tr>
<tr>
<td><strong>sysfile.c</strong></td>
<td>文件相关的系统调用</td>
</tr>
<tr>
<td><strong>sysproc.c</strong></td>
<td>进程相关的系统调用</td>
</tr>
<tr>
<td><strong>trampoline.S</strong></td>
<td>用于在用户和内核之间切换的汇编代码</td>
</tr>
<tr>
<td><strong>trap.c</strong></td>
<td>对陷入指令和中断进行处理并返回的C代码</td>
</tr>
<tr>
<td><strong>uart.c</strong></td>
<td>串口控制台设备驱动程序</td>
</tr>
<tr>
<td><strong>virtio_disk.c</strong></td>
<td>磁盘设备驱动程序</td>
</tr>
<tr>
<td><strong>vm.c</strong></td>
<td>管理页表和地址空间</td>
</tr>
</tbody></table>
<p> <strong>图2.2：XV6内核源文件</strong></p>
<h2 id="Process-overview"><a href="#Process-overview" class="headerlink" title="Process overview"></a>Process overview</h2><p>内核用来实现进程的机制包括用户态内核态标志、地址空间和进程的时间切片。</p>
<p>为了帮助加强隔离，进程抽象给程序提供了一种错觉，即它有自己的专用机器。进程为程序提供了一个看起来像是私有内存系统或地址空间的东西，其他进程不能读取或写入。进程还为程序提供了看起来像是自己的CPU来执行程序的指令。</p>
<p>Xv6使用页表（由硬件实现）为每个进程提供自己的地址空间。RISC-V页表将虚拟地址（RISC-V指令操纵的地址）转换（或“映射”）为物理地址（CPU芯片发送到主存储器的地址）。</p>
<p>每个进程也有自己的页表，页表中记录了以虚拟地址0开始的内存区域。</p>
<img src="/2023/01/10/xv6/image-20230107233741922.png" class>

<p>xv6内核为每个进程维护许多状态片段，并将它们聚集到一个<code>proc</code>(*<strong>kernel/proc.h*</strong>:86)结构体中。一个进程最重要的内核状态片段是它的页表、内核栈区和运行状态。我们将使用符号<code>p-&gt;xxx</code>来引用<code>proc</code>结构体的元素；例如，<code>p-&gt;pagetable</code>是一个指向该进程页表的指针。</p>
<blockquote>
<p>这应该相当于pcb表。</p>
</blockquote>
<h2 id="Code-starting-xv6-and-the-fifirst-process"><a href="#Code-starting-xv6-and-the-fifirst-process" class="headerlink" title="Code: starting xv6 and the fifirst process"></a>Code: starting xv6 and the fifirst process</h2><p>看完一遍说实话还乱乱的。。。。我整理整理跟linux的对比学习一下吧。</p>
<h3 id="xv6"><a href="#xv6" class="headerlink" title="xv6"></a>xv6</h3><h4 id="加载操作系统"><a href="#加载操作系统" class="headerlink" title="加载操作系统"></a>加载操作系统</h4><p>系统加电，启动BIOS初始化硬件 -&gt; BIOS从<u>引导扇区</u>将加载程序读入内存 -&gt; 加载程序将操作系统镜像读入内存RAM。</p>
<blockquote>
<p>这个过程由qemu模拟。</p>
<p>首先会通过<code>mkfs</code>造出操作系统镜像。然后由qemu将引导扇区，也即下面的filesys这图里的第0块：</p>
<img src="/2023/01/10/xv6/image-20230121162324747.png" class>

<p>读入到主存中，然后开始执行引导扇区的程序，下同。</p>
</blockquote>
<p><code>boot loader</code>目的是把xv6加载进内存到<code>0x8000 0000</code>，然后跳转到xv6初始化程序。</p>
<blockquote>
<p>The reason it places the kernel at <code>0x80000000</code> rather than <code>0x0</code> is because the address range <code>0x0:0x80000000</code> contains <strong>I/O devices</strong>.</p>
</blockquote>
<h4 id="操作系统初始化"><a href="#操作系统初始化" class="headerlink" title="操作系统初始化"></a>操作系统初始化</h4><h5 id="entry-S配置栈空间"><a href="#entry-S配置栈空间" class="headerlink" title="entry.S配置栈空间"></a>entry.S配置栈空间</h5><p>此时，目前的机器状态是，1.没有开启地址映射，也即虚拟地址=真实物理地址。2.运行在machine mode</p>
<p>xv6会在<code>kernel/entry.S</code>下的这里开始执行，目的是<strong>配置好栈</strong>，以开始C语言代码<code>start.c</code>的执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # 这段主要是在计算栈顶指针sp</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">        # 已经有栈了，就可以开始执行C语言代码了</span><br><span class="line">        # jump to start()</span><br><span class="line">        call start</span><br></pre></td></tr></table></figure>

<p>其中start0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br></pre></td></tr></table></figure>

<h5 id="start-c"><a href="#start-c" class="headerlink" title="start.c"></a>start.c</h5><p>在start.c中，我们的任务是在machine mode下，获取machine mode才能访问到的硬件参数，做在machine mode 下才能做的时钟初始化【 it programs the clock chip to generate timer interrupts】，然后进行machine mode到内核态的切换，最后跳转到main.c进行操作系统的初始化和第一个进程的启动。</p>
<p>而其中，如果想从machine mode切换到内核态，就需要使用<code>mret</code>指令。但是mret指令除了会切换mode之外，还有一个“ret”的作用，并且是从machine mode ret到内核态。</p>
<blockquote>
<p>This instruction( mret ) is most often used to return from a previous call from supervisor mode to machine mode.</p>
</blockquote>
<p>所以，我们实际上可以把最后两步连起来，用mret一个指令就完成。也即，mret指令既完成了从machine mode到内核态的切换，又完成了从start.c到main.c的跳转。</p>
<p>这其实很容易，只需在栈中将调用者（此时应该是entry.S）的地址替换为main.c的地址，并且将调用者的mode改为内核态，这样就ok了。</p>
<blockquote>
<p> it sets the <strong>previous privilege mode</strong> to supervisor in the register mstatus, it sets the <strong>return address</strong> to main by writing main’s address into the register mepc, <strong>disables virtual address translation in supervisor mode</strong> by writing 0 into the page-table register satp, and <strong>delegates all interrupts and exceptions to supervisor mode</strong></p>
<p>后面两点不大明白。为什么为了mret，就还得让内核态跟machine mode一样关闭虚拟地址映射，还得把什么中断和异常委托给内核态【这个委托是完全没搞懂是什么意思】？？</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//修改调用者为内核态</span></span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h5><p>main.c的作用是做很多很多init。其中，它通过<code>userinit();</code>来创建第一个进程，这个第一个进程再由main调用<code>scheduler()</code>来被调度执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//...很多很多init</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    RISC-V的处理器对底层提供了一种特殊的抽象,Hardware Thread,简称为Hart。简单来说,Hart是真实物理CPU(bare metal)提供的一种模拟</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用第一个scheduler，完成对scheduler线程的初始化，并且调度去执行第一个进程</span></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：关于里面的cpuid，我查了一下，指的是CPU的序列号，用来唯一标识cpu的。我想这个if架构的目的应该跟<code>fork()==0</code>差不多。也就是说，一开始的那个init仅有<code>cpuid==0</code>的CPU执行，其他的CPU就乖乖wait，只有CPU0执行初始化的程序。等到CPU0执行完所有init，才置标记位start=1，然后通过锁<code>__sync_synchronize();</code>开始抢占调度，轮流初始化自己。</p>
</blockquote>
<h5 id="proc-c中的userinit"><a href="#proc-c中的userinit" class="headerlink" title="proc.c中的userinit()"></a>proc.c中的userinit()</h5><p>userinit的作用就是新创建一个进程信息proc，然后开始给第一个程序（initcode）填信息填入proc。这个进程创建完后，在main中的scheduler被调度执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请一页，将initcode的指令和数据放进去</span></span><br><span class="line">  <span class="comment">// allocate one user page and copy initcode&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvmfirst(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为内核态到用户态的转变做准备</span></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Trap Frame是指中断、自陷、异常进入内核后,在堆栈上形成的一种数据结构</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改进程名</span></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个也许是为了能被优先调度</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="initcode-S"><a href="#initcode-S" class="headerlink" title="initcode.S"></a>initcode.S</h5><p>以上程序都位于<code>kernel/</code>下。这个位于<code>user/</code>下。</p>
<p>它调用exec系统调用进入了内核态。当exec完成后，它就跳转到了用户态<code>user/init.c</code>中。【这里估计又用了修改返回地址的trick】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure>

<h5 id="init-c"><a href="#init-c" class="headerlink" title="init.c"></a>init.c</h5><p>在init.c中，创建了console设备文件，打开了012文件描述符，并且fork了一个子进程，开始执行shell。这样一来，操作系统就完成了全部的启动。</p>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><blockquote>
<p>我的疑点有三个：</p>
<ol>
<li>见start.c</li>
<li>是怎么完成从内核态到用户态的切换的？是执行了return就会自动切换吗？userinit中设置了initcode的信息为用户态的，然后就直接能进入用户态，这里感觉有点模糊。</li>
<li>什么时候开启地址映射的？</li>
</ol>
<p>除了这些外，都是很清晰明了的，步骤十分直接且有理由：</p>
<p>加载操作系统——为了能执行C语言需要一个栈，所以得执行造一个的代码，然后再进入C语言zone——做点machine mode才能做的事，然后从machine mode切换到内核态——做点内核态才能做的事，从内核态切换到用户态</p>
</blockquote>
<h3 id="linux0-11"><a href="#linux0-11" class="headerlink" title="linux0.11"></a>linux0.11</h3><p>bootsect -&gt; setup -&gt; head.s -&gt;main.c</p>
<h4 id="加载操作系统-1"><a href="#加载操作系统-1" class="headerlink" title="加载操作系统"></a>加载操作系统</h4><p>系统加电，启动BIOS初始化硬件 -&gt; BIOS从<u>引导扇区</u>将加载程序读入内存 -&gt; 加载程序将操作系统镜像读入内存RAM。</p>
<p>其中，第二三步做进一步的细化。</p>
<h5 id="读入bootsect-s"><a href="#读入bootsect-s" class="headerlink" title="读入bootsect.s"></a>读入bootsect.s</h5><p>加载程序的512个字节被读入到内存从<code>0x7c00</code>开始的一段内存中，并且BIOS设置<code>CS=07c0,ip=0</code>，开始执行加载程序的每一条指令。</p>
<h5 id="bootsect-s"><a href="#bootsect-s" class="headerlink" title="bootsect.s"></a>bootsect.s</h5><p>加载程序的代码为<code>bootsect.s</code>。在<code>bootsect.s</code>中，首先将自身从<code>7c00</code>处移动到了<code>9000</code>处【留下空间放操作系统】，然后分别依次读取磁盘的<u>setup</u>和<u>system</u>模块，最后bootsect将控制权转交给setup。</p>
<h5 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h5><p>setup首先获取操作系统运行的<strong>必要硬件参数</strong>。</p>
<img src="/2023/01/10/xv6/image-20230108011824655.png" class>

<p>再然后，<u>将system代码移到0地址</u>。然后，我们就需要进入system代码块。</p>
<img src="/2023/01/10/xv6/image-20230108012316631.png" class>

<p>最后一句jmpi指令本来应该是要跳到system代码段首0地址处的的，可此处却跳到了80处，这显然不合理。但它写的肯定是没错的。之所以会有这样的矛盾，是因为setup在此之前，还做了一件事情：<strong>改变寻址方式</strong>。jmpi上面的那条mov指令便做了这点。</p>
<p>我们之前的寻址方式一直是<code>cs&lt;&lt;4+ip</code>。但是这东西只能是16位的内存，<u>无法满足寻址需求</u>。故而setup要从16位切换到32位。32位模式也叫保护模式。</p>
<blockquote>
<p>至于怎么切的呢？要注意到一点，改变寻址方式也即改变cs和ip的地址计算方法，也即换一条硬件电路实现。计算机给我们提供了一个简单的方式操纵保护模式的转变，即修改cr0寄存器的内容。</p>
</blockquote>
<p>在保护模式下，寻址方式发生了改变。此时cs不再代表基址，而是表示地址在gdb表<code>global description table</code>中的偏移下标。真正的基址放在表项中。cs被称为selector，从表中取得基址，再和ip加在一起得到地址。</p>
<blockquote>
<p>gdt表的内容由setup初始化</p>
<img src="/2023/01/10/xv6/image-20230108013156116.png" class>
</blockquote>
<p>这样一来，就正确跳到了system模块。</p>
<h4 id="操作系统初始化-1"><a href="#操作系统初始化-1" class="headerlink" title="操作系统初始化"></a>操作系统初始化</h4><h5 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h5><p>跳到system第一个文件，也就是head.s去执行。</p>
<p>head.s也是在保护模式下进行的，是在保护模式下的初始化。</p>
<p>head.s建立了真正的gdt表，然后就要跳转到main.c执行初始化和Shell的启动。此处有汇编语言和C语言的转化，也就是push参数然后push main的地址。</p>
<h5 id="main-c-1"><a href="#main-c-1" class="headerlink" title="main.c"></a>main.c</h5><p>对各种东西的初始化。</p>
<img src="/2023/01/10/xv6/image-20230108013849664.png" class>

<p>最后完成从内核态到用户态的切换。</p>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><blockquote>
<p>linux0.11的启动的具体思路是：</p>
<p>加载操作系统，获取硬件参数，进入保护模式，跳转到操作系统第一行代码——操作系统初始化，切换到用户态</p>
<p>linux0.11相比于xv6更加复杂，上课的时候隐藏了很多实现细节但依旧理解很费劲（。</p>
<p>这两个步骤思路其实都是差不多的，区别在于linux0.11好像没有machine mode这个概念。感觉也不能锐评什么，因为看完了感觉两个都很有道理，两个都一样很难懂（。</p>
<p>不过linux0.11这里进入保护模式后改变寻址方式是因为机器问题（好像是），xv6难道也是因为硬件问题吗？因为一开始的时候操作系统还未进行内存分页页表初始化，所以用不了地址映射？有待学习。</p>
<p>关于保护模式，可以看看这篇文章，今天太晚了先睡了：</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15082498/5527746"><strong>Linux从头学08：Linux 是如何保护内核代码的？【从实模式到保护模式】</strong></a></p>
</blockquote>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><p>现实中，大多数操作系统都会兼顾宏内核与微内核。</p>
<p>大多数操作系统都支持与xv6类似的process进程概念，也有很多系统还支持线程概念。</p>
<h2 id="Lab-system-calls"><a href="#Lab-system-calls" class="headerlink" title="Lab system calls"></a>Lab system calls</h2><blockquote>
<p>To start the lab, switch to the syscall branch:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout syscall</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><blockquote>
<p>In this assignment you will add a system call tracing feature that may help you when debugging later labs.</p>
<p>You’ll create a new <code>trace</code> system call that will control tracing. It should take <strong>one argument,</strong> an integer “mask”, whose bits specify which system calls to trace. </p>
<p>For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>. You have to modify the xv6 kernel to <strong>print out a line when each system call is about to return</strong>. The line should contain the <strong>process id</strong>, the <strong>name</strong> of the system call and the <strong>return value</strong>; you don’t need to print the system call arguments. </p>
<p>The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p>
</blockquote>
<h4 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h4><p>一开始为了把trace做得封装性良好一些尽量不改别的代码，想了好久好久，最后就只能想出，在syscall.c获取系统调用返回值处加个条件打印，在trace中维护一个map，映射进程pid和进程当前的mask，并且给外界提供查询当前进程是否对某个系统调用有mask作为syscall条件打印的接口。</p>
<p>这个最后还是失败了，失败的点在于不知道要创建多大的数组来作为map映射所有进程，因为pid分配估计是递增的，是会超过最大进程数的，所以pid会是多少是不确定的。还有一点就是fork之后子进程不能自动继承父进程的mask，还得手动调用一下trace，这更加不封装了（。</p>
<p>总之先放上我原来的代码吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/syscall.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* tmp)</span>&#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((*tmp)!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">    buf[i++] = *tmp;</span><br><span class="line">    tmp++;</span><br><span class="line">  &#125;  </span><br><span class="line">  buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getname</span><span class="params">(<span class="type">int</span> callid,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(callid)&#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_fork: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fork&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exit: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exit&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_wait: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;wait&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_pipe: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;pipe&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_read: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;read&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_kill: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;kill&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exec: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exec&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_fstat: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fstat&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_chdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;chdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_dup: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;dup&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getpid: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;getpid&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sbrk: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sbrk&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sleep: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sleep&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_uptime: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;uptime&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_open: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;open&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_write: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;write&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mknod: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mknod&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_unlink: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;unlink&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_link: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;link&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mkdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mkdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_close: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;close&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_trace: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;trace&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    getname(num,buf);</span><br><span class="line">    <span class="comment">// 在此处添加条件打印</span></span><br><span class="line">    <span class="keyword">if</span>(istraced(num))</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;syscall %s -&gt; %d\n&quot;</span>,buf,p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trace.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_mask[NPROC];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    m_mask[p-&gt;pid] = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供给外界查询的接口</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">istraced</span><span class="params">(<span class="type">int</span> callid)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">//printf(&quot;from trace ,pid = %d\n&quot;,p-&gt;pid);</span></span><br><span class="line">    <span class="keyword">if</span>(((m_mask[p-&gt;pid] &gt;&gt; callid) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是按照hints修改后的正确代码。</p>
<h4 id="代码步骤"><a href="#代码步骤" class="headerlink" title="代码步骤"></a>代码步骤</h4><p>实际上，标答跟我的思路差不多，只不过它没有像我一样创建数组作为map，而是在proc结构体里添加了一个属性，这本质上也是利用了map。</p>
<h5 id="在各种文件添加签名"><a href="#在各种文件添加签名" class="headerlink" title="在各种文件添加签名"></a>在各种文件添加签名</h5><h6 id="user-user-h"><a href="#user-user-h" class="headerlink" title="user/user.h"></a>user/user.h</h6><h6 id="user-usys-pl"><a href="#user-usys-pl" class="headerlink" title="user/usys.pl"></a>user/usys.pl</h6><h6 id="syscall-h"><a href="#syscall-h" class="headerlink" title="syscall.h"></a>syscall.h</h6><p>添加系统调用号</p>
<h6 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h6><p>添加系统调用号和sys_trace映射</p>
<h6 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改Makefile</h6><ol>
<li>在第一个OBJS添加trace.o</li>
<li>在UPROGS添加user中的trace</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><h6 id="修改proc-h"><a href="#修改proc-h" class="headerlink" title="修改proc.h"></a>修改proc.h</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> mask; <span class="comment">//记录trace的mask</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="编写trace-c"><a href="#编写trace-c" class="headerlink" title="编写trace.c"></a>编写trace.c</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;mask = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">istraced</span><span class="params">(<span class="type">int</span> callid)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span>(((p-&gt;mask &gt;&gt; callid) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="修改syscall-c"><a href="#修改syscall-c" class="headerlink" title="修改syscall.c"></a>修改syscall.c</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/syscall.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* tmp)</span>&#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((*tmp)!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">    buf[i++] = *tmp;</span><br><span class="line">    tmp++;</span><br><span class="line">  &#125;  </span><br><span class="line">  buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getname</span><span class="params">(<span class="type">int</span> callid,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(callid)&#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_fork: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fork&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exit: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exit&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_wait: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;wait&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_pipe: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;pipe&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_read: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;read&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_kill: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;kill&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exec: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exec&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_fstat: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fstat&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_chdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;chdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_dup: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;dup&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getpid: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;getpid&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sbrk: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sbrk&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sleep: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sleep&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_uptime: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;uptime&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_open: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;open&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_write: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;write&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mknod: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mknod&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_unlink: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;unlink&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_link: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;link&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mkdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mkdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_close: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;close&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_trace: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;trace&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    getname(num,buf);</span><br><span class="line">    <span class="comment">// 在此处添加条件打印</span></span><br><span class="line">    <span class="keyword">if</span>(istraced(num))</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;syscall %s -&gt; %d\n&quot;</span>,buf,p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="在sysproc-c中添加系统调用"><a href="#在sysproc-c中添加系统调用" class="headerlink" title="在sysproc.c中添加系统调用"></a>在sysproc.c中添加系统调用</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>,&amp;mask)&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  trace(mask);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="在defs-h中添加需要public的函数签名"><a href="#在defs-h中添加需要public的函数签名" class="headerlink" title="在defs.h中添加需要public的函数签名"></a>在defs.h中添加需要public的函数签名</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trace.c</span></span><br><span class="line"><span class="type">int</span>		<span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span>		<span class="title function_">istraced</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="sysinfotest"><a href="#sysinfotest" class="headerlink" title="sysinfotest"></a>sysinfotest</h3><blockquote>
<p>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. </p>
<p>The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). </p>
<p>The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code> field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. </p>
<p>We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysinfo.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> &#123;</span></span><br><span class="line">  uint64 freemem;   <span class="comment">// amount of free memory (bytes)</span></span><br><span class="line">  uint64 nproc;     <span class="comment">// number of process</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="感想-3"><a href="#感想-3" class="headerlink" title="感想"></a>感想</h4><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>系统调用要做的事情同上。</p>
<p>有一个我在hit实验没想到，在这里<strong>依然没有想到</strong>的点是，参数的指针来自用户空间，所以不能直接对其指向的空间进行写入，需要借助copyout函数。</p>
<p>还有一件事，就是不知道该怎么统计free mem的数量，后来在hints提示下才知道要去kalloc.c中找。【之前只找过了vm.c】这里其实是很后悔提前看了提示的。我应该先去看一下上面关于kernel各个文件用途的笔记，再去继续自己找的，不能太过依赖提示。</p>
<p>还有一点做的不好的地方是，标答是选择了将两个计数函数放在各自的文件中，我是选择直接将成员变量在头文件中extern 公开出来，比如说在proc.h中这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br></pre></td></tr></table></figure>

<p>hints采取了比我封装性更好的操作，这也是非常顺理成章的，我没有想到这样真是有点惭愧（。</p>
<p>总而言之，这个还是挺简单的，就是我很后悔我心浮气躁看了提示，要不然收获会更多。</p>
<h5 id="sysinfo-c"><a href="#sysinfo-c" class="headerlink" title="sysinfo.c"></a>sysinfo.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysinfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo* info)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">res</span>;</span></span><br><span class="line">  res.nproc = countproc();</span><br><span class="line">  res.freemem = countfree();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, (uint64)info,(<span class="type">char</span> *)(&amp;res), <span class="keyword">sizeof</span>(res)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sysproc-c中"><a href="#sysproc-c中" class="headerlink" title="sysproc.c中"></a>sysproc.c中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> sysinfo((<span class="keyword">struct</span> sysinfo*)addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="kalloc-c中"><a href="#kalloc-c中" class="headerlink" title="kalloc.c中"></a>kalloc.c中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用的是链表结构，run代表一页</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="comment">// 指向第一个空闲页</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">countfree</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> npage = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span>* <span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">    npage++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> npage*PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="proc-c中"><a href="#proc-c中" class="headerlink" title="proc.c中"></a>proc.c中</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">countproc</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NPROC;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(proc[i].state != UNUSED)&#123;</span><br><span class="line">	  nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nproc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h4><h5 id="trace-plus"><a href="#trace-plus" class="headerlink" title="trace plus"></a>trace plus</h5><blockquote>
<p>Print the system call arguments for traced system calls.</p>
</blockquote>
<p>这个实现起来要说简单也简单，麻烦也麻烦。这里就先摆了【实际上尝试了半小时发现太烦了看别人写的也不大满意就放弃了】</p>
<h5 id="sysinfo-plus"><a href="#sysinfo-plus" class="headerlink" title="sysinfo plus"></a>sysinfo plus</h5><blockquote>
<p>Compute the load average and export it through sysinfo</p>
</blockquote>
<p>说实话没太看懂，不就加个 running process/ncpu就行了吗？</p>
<h1 id="Page-tables"><a href="#Page-tables" class="headerlink" title="Page tables"></a>Page tables</h1><blockquote>
<p>页表学完后，还有一个点就是，xv6有没有实现内存的换入换出呢？</p>
<p>印象中，xv6从操作系统读入，一直到目前写程序，似乎一直都是获得虚拟地址，通过虚拟地址访问物理内存地址，好像从来没有考虑过物理内存和磁盘间的换入换出。</p>
<p>是xv6没有实现这个机制，还是还没讲到呢？此处有待发掘。</p>
</blockquote>
<h2 id="Paging-hardware"><a href="#Paging-hardware" class="headerlink" title="Paging hardware"></a>Paging hardware</h2><h3 id="为什么需要页表"><a href="#为什么需要页表" class="headerlink" title="为什么需要页表"></a>为什么需要页表</h3><p>将主存储器以及各种外设接口卡里面内置的存储器连接起来，就形成了内存地址空间。内存地址空间中的地址是真实的物理地址。RISC-V架构的指令使用的地址是虚拟地址。为了通过指令中的虚拟地址访问到真实的物理内存，需要进行从虚拟地址到物理地址的转换。从虚拟地址到物理地址的转换，就需要通过页表来实现。</p>
<h3 id="页表组成"><a href="#页表组成" class="headerlink" title="页表组成"></a>页表组成</h3><h4 id="页表项"><a href="#页表项" class="headerlink" title="页表项"></a>页表项</h4><p>页表由页表项PTE（Page Table Entries）构成，每个页表项由44位的PPN（Physical Page Number）和一些参数flag组成。</p>
<img src="/2023/01/10/xv6/image-20230109153937459.png" class>

<blockquote>
<p>Each PTE contains flflag bits that tell the paging hardware how the associated virtual address is allowed to be used. <strong>PTE_V</strong> indicates whether the PTE is <u>present</u>: if it is not set, a reference to the page causes an exception (i.e. is not allowed). <strong>PTE_R</strong> controls whether instructions are allowed to <u>read</u> to the page. PTE_W controls whether instructions are allowed to write to the page. <strong>PTE_X</strong> controls whether the CPU may interpret the content of the page <u>as instructions and execute them</u>. <strong>PTE_U</strong> controls whether instructions in <u>user</u> mode are allowed to <u>access</u> the page; if PTE_U is not set, the PTE can be used only in supervisor mode.</p>
<p>这个表项的几个参数定义在kernel/riscv.h中的341行左右。</p>
</blockquote>
<p>虚拟地址有64bit，其中25bits未使用，39bits包含了27位的PTE索引号以及12位的offset。</p>
<p>物理地址有56位，由PPN和offset拼接组成。</p>
<h4 id="单页表和多级页表"><a href="#单页表和多级页表" class="headerlink" title="单页表和多级页表"></a>单页表和多级页表</h4><p>以单页表为例，物理地址形成过程如下图所示。</p>


<p><u>每个页表项PTE索引着一页</u>。因而，每一页的大小为2^12=4096B。单页表中PTE的索引号有2^27个，因而单页表中表项有134217728个，即可以代表134217728页。页表实际上也是以页的形式存储的。因而单页表需要的存储空间为(2^27x7)/2^12=2^15x7=229376页。</p>
<p>RISC-V架构中真实情况是会有三级页表。三级页表结构相比于单级页表结构，会占据更多的<strong>物理存储空间</strong>。</p>
<img src="/2023/01/10/xv6/image-20230109151346780.png" class>

<p><u>每个页表项PTE索引着一页，这一页可能代表着另一个页表，也可能代表着内存中需要的指令和数据</u>。因而，每一页的大小为2^12=4096B。三页表中，一级页表中PTE的索引号有512个，可以代表的物理内存页数有512x515x512=2^27页，即可以代表134217728页。页表实际上也是以页的形式存储的，一个页表有2^9x7个字节，可以存储在1页中。因而三页表需要的存储空间为1+2^9+2^18 = 262657页。</p>
<p>三级页表结构相比于单级页表结构，可以节省更多<strong>内存空间</strong>。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuyuande/article/details/117616433">页表是啥以及为啥多级页表能够节省空间</a></p>
</blockquote>
<p>考虑到这样一个进程：</p>
<img src="/2023/01/10/xv6/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1eXVhbmRl,size_16,color_FFFFFF,t_70.png" class>

<p>进程使用页表时，需要将整个页表读入内存。</p>
<p>如果使用单级页表，尽管一个进程仅使用到页表中的某两项，也需要把整个页表都读入内存，光是页表就占据了2^15x7x4k/2^20 约为1G的内存空间。</p>
<p>如果使用三级页表，一个进程需要用到某两页。假设这两页存储在不同的二级页表中，则只需要读入1+2+2=5页 约为20K的内存空间。</p>
<p>两者相对比，显然用三级页表比单级页表顶多了。三级页表相较于一级页表，多用了13%的物理空间，却可以节省99.998%的空间。</p>
<h3 id="页表使用"><a href="#页表使用" class="headerlink" title="页表使用"></a>页表使用</h3><p>每个进程会保留自己的一份用户级别的页表地址。当轮到自己使用CPU时，会将CPU的satp寄存器更换为自己的页表地址。</p>
<h2 id="Kernel-address-space"><a href="#Kernel-address-space" class="headerlink" title="Kernel address space"></a>Kernel address space</h2><p>介绍了xv6中内核的页表结构。</p>
<blockquote>
<p>这里为了方便，就把三级页表省略了，只留下va和pa的对比</p>
</blockquote>
<p>每个进程都有一个用户级别的页表。xv6给内核提供了一个单独的内核地址空间的页表。其层级映射关系如下：</p>
<img src="/2023/01/10/xv6/p3.png" class>

<p>在kernel/memlayout.h中正记录了这些参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical memory layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu -machine virt is set up like this,</span></span><br><span class="line"><span class="comment">// based on qemu&#x27;s hw/riscv/virt.c:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 00001000 -- boot ROM, provided by qemu</span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT</span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC</span></span><br><span class="line"><span class="comment">// 10000000 -- uart0 </span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk </span></span><br><span class="line"><span class="comment">// 80000000 -- boot ROM jumps here in machine mode</span></span><br><span class="line"><span class="comment">//             -kernel loads the kernel here</span></span><br><span class="line"><span class="comment">// unused RAM after 80000000.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel uses physical memory thus:</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S, then kernel text and data</span></span><br><span class="line"><span class="comment">// end -- start of kernel page allocation area</span></span><br><span class="line"><span class="comment">// PHYSTOP -- end RAM used by the kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// core local interruptor (CLINT), which contains the timer.</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>由图可知，一直从0x0到0x86400000，都是采取的<strong>直接映射</strong>的方式，虚拟地址=物理地址，这段是内核使用的空间。在0x0-0x800000000阶段，物理地址代表着各种IO设备的存储器。</p>
<p>但是注意，在0x86400000（PHYSTOP）以上的地址都不是直接映射，这些非直接映射的层级包含两类：</p>
<ol>
<li><p>trampoline</p>
<blockquote>
<p>It is mapped at the top of the virtual address space; user page tables have this same mapping. </p>
</blockquote>
<p>它有一点很特殊的是，它实际对应的物理内存是0x80000000开始的一段。也就是说，0x80000000开始的这段内存，既被直接映射了，也被trampoline通过虚拟地址映射了。它被映射了两次。</p>
</li>
<li><p>内核栈</p>
<blockquote>
<p>Each process has its own kernel stack, which is mapped high so that below it xv6 can leave an unmapped <em>guard page</em>. The guard page’s PTE is invalid (i.e., <u>PTE_V is not set</u>), so that if the kernel <strong>overflflows</strong> a kernel stack, it will likely cause an exception and the kernel will panic.</p>
<p>guard page可以用来防止内核栈溢出。</p>
</blockquote>
</li>
</ol>
<p>内核使用PTE_R和PTE_X权限映射trampoline和kernel text。这表明这份内存段可以读，可以被当做指令块执行，但不能写。其他的块都是可读可写的，除了guard page被设置为不可访问。</p>
<h2 id="Code-creating-an-address-space"><a href="#Code-creating-an-address-space" class="headerlink" title="Code: creating an address space"></a>Code: creating an address space</h2><h3 id="vm-c"><a href="#vm-c" class="headerlink" title="vm.c"></a>vm.c</h3><p>操作地址空间和页表部分的代码都在<code>kernel/vm.c</code>中。代表页表的数据结构是<code>pagetable_t</code>。</p>
<p>vm.c的主要函数有walk、mappages等。walk用来在三级页表中找到某个虚拟地址表项，或者创建一个新的表项。mappages用来新建一个表项，主要用到了walk函数。</p>
<p>vm.c中，以kvm开头的代表操纵内核页表，以uvm开头的代表操纵进程里的用户页表。</p>
<h4 id="以初始化为例介绍各个函数"><a href="#以初始化为例介绍各个函数" class="headerlink" title="以初始化为例介绍各个函数"></a>以初始化为例介绍各个函数</h4><h5 id="创建页表"><a href="#创建页表" class="headerlink" title="创建页表"></a>创建页表</h5><p>一开始操作系统初始化时，会调用vm.c中的kvminit来创建内核页表。主要就是在以内核地址空间的页表结构在填写页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//内核页表</span></span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line">  <span class="comment">//申请新的一页</span></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//给内核页表初始化表项，结构详见上面的内核地址空间部分</span></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，kvmmap用来在内核页表中添加一个新的表项。其函数形式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现主要逻辑的是mappages函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">//walk函数通过虚拟地址新建一个第三级页表的表项并返回其指针，之后只需要填这个表项即可</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果pte存在并且标记为已使用，说明该虚拟地址映射已经存在</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    <span class="comment">//填写表项：物理地址 flags</span></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//每两个表项间隔PGSIZE个字节</span></span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过虚拟地址获取表项主要是通过walk实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="comment">// 虚拟地址的格式：UNUSED 页表索引 offset，其中页表索引在三级页表中被划分为了三个，分别是</span></span><br><span class="line"><span class="comment">// level0-level2，分别代表了第三级、第二级、第一级页表的索引【具体可见页表组成中的图】</span></span><br><span class="line"><span class="comment">// walk的目的就是要在这三级页表中找到虚拟地址对应的页表项。当alloc!=0时，则要求找不到就新建一个</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// 取出PTE中表示下一级页表地址的字节</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 页表不存在的情况，要么返回0，要么新建一页</span></span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终返回第三级页表的对应表项</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="装上页表"><a href="#装上页表" class="headerlink" title="装上页表"></a>装上页表</h5><p>使用的是kvminithart函数。它将内核页表的root page table的物理地址写入了satp寄存器。从这个函数之后，就<strong>开启了内存映射</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// wait for any previous writes to the page table memory to finish.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line"></span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flush stale entries from the TLB.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中sfence_vma()的用途是强制更新TLB的旧页表，类似于Java volatile的作用。</p>
<h6 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h6><p>附上书里的详细解释：</p>
<img src="/2023/01/10/xv6/image-20230109222917346.png" class>

<p>TLB与页表类似于cache与主存的关系。TLB保存了页表的一部分。</p>
<h6 id="我的错误想法"><a href="#我的错误想法" class="headerlink" title="我的错误想法"></a>我的错误想法</h6><p>我怎么感觉怪怪的啊？因为TLB既然是高速缓存，那么读写页表也应该优先从TLB读写【注：应该就是从这里开始错的hhh写应该是直接写入页表】。所以说，会陈旧的应该是主存中的页表，而不是TLB中的页表。但是，书里是说，改完页表必须通知TLB更改。也就是说，读写页表不是从TLB读写的，那该是从哪里？是TLB以外的free memory吗？</p>
<p>不过，要是从多CPU的角度思考，说不定他这个意思是某个CPU的TLB变了，需要通知其他所有CPU的TLB也变。虽然不同CPU当前执行的进程是不一样的，使用的页表项不一样，切换进程的时候也会把用户地址空间的页表项flush掉。但是内核地址空间的页表项一般是不会随着进程切换而flush掉的。所以内核页表修改就需要手动多CPU同步。</p>
<p>我认为多CPU角度考虑更加合理，因为它最后说了，xv6会在内核页表init后flush，以及在从内核态切换回用户态的时候flush。这两个（好像）都影响内核页表比较多，所以就需要手动flush一下。</p>
<h6 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h6><p>之后学了缺页异常后，可以发现这里其实是没问题的。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq">计算机体系结构 – 虚拟内存</a></p>
<img src="/2023/01/10/xv6/v2-e15454bf032baa4dc088b6e41ed4f4a4_1440w.jpg" class>

<p>页表的管理（创建、更新、删除等）是由操作系统负责的。地址转换时，页表检索是由硬件内存管理单元（Memory Management Unit, MMU）负责的。MMU通常由两部分构成：表查找单元（Table Walk Unit, TWU）和转换旁路缓冲（Translation Lookaside Buffer, TLB）[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_2">2]</a>。TWU负责链式的访问PDE、PTE，完成上述的查表过程。</p>
<p>应用多级页表之后，想要完成一次地址转换，需要访问多级目录和页表，这么多次的内存访问会严重降低性能。</p>
<p>为了优化地址转换速度，人们在MMU中增加了一块高速cache，专门用来缓存虚拟地址到物理地址的映射，这块cache就是TLB[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_7">7]</a>[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_8">8]</a>。MMU在做地址转换的时候，会先检索TLB，如果命中则直接返回对应的物理地址，如果不命中则会调用TWU查找页表。</p>
<p>TLB中缓存的是虚拟地址到物理地址映射。然而，多级页表的查找是一个链式的过程，对于在虚拟地址空间中连续的两个页，它们的各级目录项可能都是一样的，只有最后一级页号不一样。查找完第一个虚拟页之后，我们可以将相同的前级目录项都缓存起来。查找第二个虚拟页时，可以直接使用缓存好的前几级目录项，节省查找时间。这种缓存叫做Page Structure Cache[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_9">9]</a>。</p>
<p>而当TLB和MMU中都没有该物理页，就会发生缺页异常。但是<strong>操作系统仅会对页表更新</strong>，而不会被TLB更新。故而，TBL中数据可能陈旧，需要手动flush。</p>
<h2 id="Physical-memory-allocation"><a href="#Physical-memory-allocation" class="headerlink" title="Physical memory allocation"></a>Physical memory allocation</h2><p>在内核运行的时候，需要申请很多空间用来存放各种数据。</p>
<blockquote>
<p>The kernel must allocate and free physical memory at run-time for page tables, user memory, kernel stacks, and pipe buffers.</p>
</blockquote>
<p>用的是这段空闲内存：</p>
<img src="/2023/01/10/xv6/image-20230109225700837.png" class>

<blockquote>
<p> It keeps track of which pages are free by threading a <strong>linked list</strong> through the pages themselves.</p>
</blockquote>
<p>kalloc.c中就是这么实现的。</p>
<h2 id="Code-Physical-memory-allocator"><a href="#Code-Physical-memory-allocator" class="headerlink" title="Code: Physical memory allocator"></a>Code: Physical memory allocator</h2><p>内核运行时申请释放空闲物理空间是通过<code>kernel/kalloc.c</code>完成的。它为内核栈、用户进程、页表和管道buffer服务。</p>
<blockquote>
<p>kalloc.c用来在运行时申请分配新的一页，上面的vm.c正是用了kalloc申请一页，要么作为页表，要么作为存储数据的第三级页表指向的物理内存。</p>
</blockquote>
<p>最后应该会在空闲内存内形成这样的结构：</p>
<p>内存分成一页一页的，每页内存中的前几个字节存储着其对应队列中下一块内存的物理地址。不一定是从小地址到大地址顺序连接。</p>
<blockquote>
<p>It store each free page’s run structure in the free page itself, since there’s nothing else stored there. </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical memory allocator, for user processes,</span></span><br><span class="line"><span class="comment">// kernel stacks, page-table pages,</span></span><br><span class="line"><span class="comment">// and pipe buffers. Allocates whole 4096-byte pages.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放在这范围内的物理内存空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也就是上面说的free memory的起始位置</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[]; <span class="comment">// first address after kernel.</span></span><br><span class="line">                   <span class="comment">// defined by kernel.ld.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// run代表的是一页内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表了整个内核空闲的物理空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="comment">// init的时候先清空空闲空间，建立空闲页队列</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="comment">// PGROUNDUP和PGROUNDDOWN是用于将地址四舍五入到PGSIZE</span></span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// pa得是整数页，并且得在内核物理内存范围之间</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 之后将在pa对应的那一页的前几个字节写入next字段</span></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这意思就是在空闲内存的链表队列中新增一块</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Process-address-space"><a href="#Process-address-space" class="headerlink" title="Process address space"></a>Process address space</h2><p>当用户进程叫xv6分配内存时，xv6会用kalloc去取，然后登记在页表上。</p>
<blockquote>
<p>The stack is a single page, and is shown with the initial contents as created by exec. Strings containing the command-line arguments, as well as an array of pointers to them, are at the very top of the stack. Just under that are values that allow a program to start at main as if the function main(argc, argv) had just been called.</p>
</blockquote>
<img src="/2023/01/10/xv6/image-20230109234930690.png" class>

<h2 id="Code-sbrk"><a href="#Code-sbrk" class="headerlink" title="Code: sbrk"></a>Code: sbrk</h2><blockquote>
<p>Sbrk is the <strong>system call</strong> for a process to <strong>shrink or grow</strong> its memory. The system call is implemented by the function growproc (kernel/proc.c:239).</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.注意单位是bytes，grow n+，shrink n-</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// 主要逻辑还是通过vm.c实现</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sz;<span class="comment">//size</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n, PTE_W)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate PTEs and physical memory to grow process from oldsz to</span></span><br><span class="line"><span class="comment">// newsz, which need not be page aligned.不需要页对齐  Returns new size or 0 on error.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// oldsz向上取整</span></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="comment">// 每页alloc</span></span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 说明失败，恢复到原状</span></span><br><span class="line">      <span class="comment">// 这里不用像下面一样kfree是因为这里压根没有alloc成功</span></span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除去junk data</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 放入页表</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 不成功</span></span><br><span class="line">      <span class="comment">// dealloc原理是顺着页表一个个free的。由于mem此处没有成功放入页表，所以就得单独free掉</span></span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-exec"><a href="#Code-exec" class="headerlink" title="Code:exec"></a>Code:exec</h2><blockquote>
<p>Exec is the system call that creates the user part of an address space. It initializes the user part of an address space from a fifile stored in the fifile system.</p>
<p><code>exec</code>是创建地址空间的用户部分的系统调用。它使用一个存储在文件系统中的文件初始化地址空间的用户部分。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s, *last;</span><br><span class="line">  <span class="type">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//开始打开文件的意思吧（</span></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//ip是一个inode</span></span><br><span class="line">  <span class="comment">//打开路径为path的文件</span></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暂时锁住文件，别人不许动</span></span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//之后应该就是把文件读入内存吧</span></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//分配新页表</span></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//elfhd应该指的是可执行文件头</span></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//总之顺利读到了</span></span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="comment">//读到了就给它分配新空间并且填入页表</span></span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在这里解锁</span></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读完文件，开始造一个新的用户栈【fork之后用户栈是不会清空的】</span></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Make the first inaccessible as a stack guard.</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack.</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE, PTE_W)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  <span class="comment">// mark a PTE invalid for user access.造guard page</span></span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  <span class="comment">// sp为栈顶</span></span><br><span class="line">  sp = sz;</span><br><span class="line">  <span class="comment">// 应该指的是栈尾</span></span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始往栈中填入执行参数</span></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//argv来自用户空间，所以需要使用copyout</span></span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//这什么东西</span></span><br><span class="line">    <span class="comment">//exec一次将参数中的一个字符串复制到栈顶，并在ustack中记录指向它们的指针</span></span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//放置空指针</span></span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="type">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//只有成功了才会来到这，才会覆盖掉旧的内存镜像</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="comment">//释放新镜像，不改变旧镜像</span></span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Real-world-1"><a href="#Real-world-1" class="headerlink" title="Real world"></a>Real world</h2><img src="/2023/01/10/xv6/image-20230110010651653.png" class>

<p>xv6内核缺少一个类似<code>malloc</code>可以为小对象提供内存的分配器，这使得内核无法使用需要动态分配的复杂数据结构。【确实，感觉一分配就是一页（】</p>
<p>内存分配是一个长期的热门话题，基本问题是有效使用有限的内存并为将来的未知请求做好准备。今天，人们更关心速度而不是空间效率。此外，一个更复杂的内核可能会分配许多不同大小的小块，而不是（如xv6中）只有4096字节的块；一个真正的内核分配器需要处理小分配和大分配。</p>
<h2 id="Lab：Pagetable"><a href="#Lab：Pagetable" class="headerlink" title="Lab：Pagetable"></a>Lab：Pagetable</h2><blockquote>
<p>In this lab you will explore page tables and modify them to to speed up certain system calls and to detect which pages have been accessed.</p>
</blockquote>
<h3 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h3><blockquote>
<p>When each process is created, map one read-only page at USYSCALL (a VA defined in <code>memlayout.h</code>). At the start of this page, store a <code>struct usyscall</code> (also defined in <code>memlayout.h</code>), and initialize it to store the PID of the current process. For this lab, <code>ugetpid()</code> has been provided on the userspace side and will automatically use the USYSCALL mapping. You will receive full credit for this part of the lab if the <code>ugetpid</code> test case passes when running <code>pgtbltest</code>.</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/429304672">MIT 6.S081 2021: Lab page tables</a></p>
</blockquote>
<h4 id="感想-4"><a href="#感想-4" class="headerlink" title="感想"></a>感想</h4><h5 id="乌龙"><a href="#乌龙" class="headerlink" title="乌龙"></a>乌龙</h5><p>这里好像是因为实验改版了，我下的是2020年的实验包，在memlayout压根找不到USYSCALL和struct usyscall这俩东西。最后翻了下网上的总算找到了。</p>
<p>我一开始没找到，还以为USYSCALL以及usyscall这两个都得自己写在memlayout里面，想了很久都没想出来USYSCALL的值应该设置为多少。我认为只需满足两个条件即可：1.所处内存段应该是free memory那段，也即自kernel结束（PHYSTOP）到MAXVA这一大块。2.得确保能被用户和内核都能访问到。</p>
<p>前者意为虚拟地址在MAXVA和PHYSTOP之间，后者意为那段内存应该标记为PTE_U。这个范围是很宽泛的，我实在不知道要分配这期间的哪块内存，感觉也不大可能是真的自由度那么大。所以我就偷偷看了hints【悲】，想看它对这个USYSCALL应该写什么值有没有建议。结果发现这东西是实验给我们定的。遂去网上找到了它给的真正的USYSCALL值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户的ugetpid只找到了一个截图：</p>
<img src="/2023/01/10/xv6/v2-0c2603da4c8102e46ae390a0d0b1191d_1440w.jpg" class>

<p>恕我愚钝实在不知道该把这段代码放在哪orz于是接下来写的东西就没有自测。</p>
<h5 id="panic-freewalk-leaf"><a href="#panic-freewalk-leaf" class="headerlink" title="panic:freewalk leaf"></a>panic:freewalk leaf</h5><p>一开始写好代码准备启动xv6的时候爆出了这么一个panic，搜了一下得到如下解答：</p>
<blockquote>
<p>来源：<a target="_blank" rel="noopener" href="http://t.zoukankan.com/YuanZiming-p-14270600.html">MIT-6.S081-2020实验（xv6-riscv64）十：mmap</a></p>
<p>这时运行会发现freewalk函数panic：<code>freewalk: leaf</code>，这是因为freewalk希望所有虚拟地址已经被解绑并释放对应的物理空间了，该函数只负责释放页表。</p>
</blockquote>
<p>让我得知freewalk在vm.c下面【吐槽，我一开始还以为是自由自在地走（，看到这个才反应过来是free walk，跟页表有关的】。结合freewalk的代码</p>
<img src="/2023/01/10/xv6/image-20230110225359361.png" class>

<p>可以知道，造成这个panic的原因是需要手动释放页表项。而在这里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c  freeproc()</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>仅仅是释放掉了对应的物理页，<strong>页表项并没有被释放</strong>。</p>
<p>对比了一下别人写的，才发现原来这里也需要修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//添加此句</span></span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，问题就解决了。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>因而，可以看到，如果进程想使用页的话，需要经历以下四步：</p>
<ol>
<li>通过kalloc获取物理页地址（可以通过该地址对页进行读写），并且记录在进程proc结构中（否则之后就获取不了了）</li>
<li>建立mappages映射</li>
<li>释放物理页</li>
<li>释放PTE映射</li>
</ol>
<p>可见12和34都是分别一一对应的。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//有线程池那味了</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Allocate a usyscall page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在USYSCALL写入usyscall结构体</span></span><br><span class="line">  p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a user page table for a given process,</span></span><br><span class="line"><span class="comment">// with no user memory, but with trampoline pages.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 映射USYSCALL</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;usyscall), PTE_R|PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><blockquote>
<p>Which other xv6 system call(s) could be made faster using this shared page? Explain how.</p>
</blockquote>
<p>我觉得如果能在fork的父子进程用shared page共享页表应该会节省很多时间和空间，用个读时写。其他的倒是想不到了。不过这题会不会问的是那些在内核态和用户态穿梭频繁的system call呢？这个的话我就想不出来了。</p>
<h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><blockquote>
<p>write a function that prints the contents of a page table.</p>
<p>Define a function called <code>vmprint()</code>. </p>
<p>It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. </p>
<p>Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process’s page table. </p>
<img src="/2023/01/10/xv6/image-20230110231020570.png" class>

<p>The first line displays the argument to <code>vmprint</code>. After that there is a <strong>line for each PTE</strong>, including PTEs that refer to page-table pages deeper in the tree. Each PTE line is indented by a number of <code>&quot; ..&quot;</code> that indicates its depth in the tree. </p>
<p>Each PTE line shows the PTE <strong>index</strong> in its page-table page, the <strong>pte bits</strong>, and the <strong>physical address extracted from the PTE</strong>. <u>Don’t print PTEs that are not valid</u>. </p>
<p>In the above example, the top-level page-table page has mappings for entries 0 and 255. The next level down for entry 0 has only index 0 mapped, and the bottom-level for that index 0 has entries 0, 1, and 2 mapped.</p>
</blockquote>
<h4 id="感想-5"><a href="#感想-5" class="headerlink" title="感想"></a>感想</h4><img src="/2023/01/10/xv6/image-20230111000329475.png" class>

<p>很可惜，我在上面检索<code>freewalk leaf</code>到底是什么东西的时候，不小心看到了这题需要去参照freewalk这个提示【悲】其实我觉得这点还是需要绕点弯才能想到的，可能直接想到有点难【谁知道呢，世界线已经变动了】。</p>
<p>它这个打印页表其实最主要是考查如何遍历页表，这让人想起了walk这样的东西。但是walk是根据虚拟地址一级级找PTE的，中间很多地方会被跳过。有没有一个过程会在做事的时候遍历整个页表呢？答案是，这个过程就是释放页表的过程。释放页表才会一个个地看是否需要释放。释放页表的函数是freewalk，因而这道题参考freewalk的代码即可。</p>
<p>我觉得从“遍历页表”联想到“释放页表”这点是很巧的。不过也不会很突兀，毕竟学数据结构时就知道释放就需要遍历，逆向思维有点难但问题不大。</p>
<p>其他的就都挺简单的，不多赘述。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p>记得在defs.h中添加声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在vm.c下</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint_helper</span><span class="params">(<span class="type">pagetable_t</span> pagetable,<span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;level;j++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>,i,(uint64)pte,(uint64)(PTE2PA(pte)));</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        vmprint_helper((<span class="type">pagetable_t</span>)child,level+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印页表</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// typedef uint64 *pagetable_t;所以pagetable可以以%p形式打印</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>,(uint64)pagetable);</span><br><span class="line">  vmprint_helper(pagetable,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问答题-1"><a href="#问答题-1" class="headerlink" title="问答题"></a>问答题</h4><blockquote>
<p>Explain the output of <code>vmprint</code> in terms of Fig 3-4 from the text. </p>
<p>What does page 0 contain? </p>
<p>What is in page 2? When running in user mode, could the process read/write the memory mapped by page 1? </p>
<p>What does the third to last page contain?</p>
</blockquote>
<p>从上面操作系统的启动来看，进程1应该是在main.c中的userinit()中创建的进程，也是shell的父进程。【确实，经实践可得shell的pid为2】</p>
<p>可以来看一下userint的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请一页，将initcode的指令和数据放进去</span></span><br><span class="line">  <span class="comment">// allocate one user page and copy initcode&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  uvminit的注释：</span></span><br><span class="line"><span class="comment">  	// Load the user initcode into address 0 of pagetable,</span></span><br><span class="line"><span class="comment">	// for the very first process.</span></span><br><span class="line"><span class="comment">	// sz must be less than a page.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为内核态到用户态的转变做准备</span></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Trap Frame是指中断、自陷、异常进入内核后,在堆栈上形成的一种数据结构</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改进程名</span></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个也许是为了能被优先调度</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，page0是initcode的代码和数据，page1和page2用作了进程的栈，其中page1应该是guard page，page2是stack。</p>
<p><strong>不过这里从exec的角度解释其实更通用</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//分配新页表</span></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//elfhd应该指的是可执行文件头</span></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="comment">//总之顺利读到了</span></span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="comment">//读到了就给它分配新空间并且填入页表</span></span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读完文件，开始造一个新的用户栈【fork之后用户栈是不会清空的】</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE, PTE_W)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  <span class="comment">// mark a PTE invalid for user access.造guard page</span></span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  <span class="comment">// sp为栈顶</span></span><br><span class="line">  sp = sz;</span><br><span class="line">  <span class="comment">// 应该指的是栈尾</span></span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page0就填程序。这里重点说明一下为什么page1和page2分别是guard page和stack。</p>
<p>按照它的那个算术关系，stack和guard page的虚拟内存位置关系应该是这样的：</p>
<img src="/2023/01/10/xv6/image-20230111004330079.png" class>

<p>那为什么最后在页表中，变成了page1是gurad page，page2是stack这样上下颠倒了呢？看vm.c中的uvmalloc就能明白。</p>
<img src="/2023/01/10/xv6/image-20230111004500827.png" class>

<p>在253行设置了新映射。可以看到，这里设置映射的顺序是sz-&gt;sz+PGSIZE，也即先设置guard page的映射，再设置stack的映射。所以，这两位才会上下颠倒了。</p>
<h3 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h3><blockquote>
<p>Some garbage collectors (a form of automatic memory management) can benefit from information about <strong>which pages have been accessed (read or write)</strong>. In this part of the lab, you will add a new feature to xv6 that detects and reports this information to userspace by inspecting <strong>the access bits in the RISC-V page table.</strong> The RISC-V hardware page walker marks these bits in the <strong>PTE</strong> whenever it resolves a TLB miss.</p>
</blockquote>
<blockquote>
<p>Your job is to implement <code>pgaccess()</code>, a system call that reports which pages have been accessed. </p>
<p>The system call takes three arguments. First, it takes the <strong>starting virtual address</strong> of the first user page to check. Second, it takes the <strong>number of pages</strong> to check. Finally, it takes a <strong>user address to a buffer to store the results into a bitmask</strong> (a datastructure that uses one bit per page and where the first page corresponds to the least significant bit). </p>
<p>You will receive full credit for this part of the lab if the <code>pgaccess</code> test case passes when running <code>pgtbltest</code>.</p>
</blockquote>
<h4 id="感想-6"><a href="#感想-6" class="headerlink" title="感想"></a>感想</h4><p>实验内容：</p>
<p>实现void pgaccess(uint64 sva,int pgnum,int* bitmask);，一个系统调用。在这里面，我们要做的是，访问从sva到sva+pgnum*PGSIZE这一范围内的虚拟地址对应的PTE，然后查看PTE的标记项是否有PTE_A。有的话则在bitmask对应位标记为1.</p>
<p>应该注意的点：</p>
<p>1.需要进行内核态到用户态的参数传递  2.需要进行系统调用的必要步骤  3.PTE_A需要自己定义</p>
<p>以上是初见。做完了发现，确实就是那么简单，我主要时间花费在下的实验版本不对，折腾来折腾去了可能有一个小时，最后还是选择了直接把测试函数搬过来手工调用。已经换到正确的年份版本了【泪目】</p>
<p>有一点我忽视了，看了提示才知道：</p>
<blockquote>
<p>Be sure to clear <code>PTE_A</code> after checking if it is set. Otherwise, it won’t be possible to determine if the page was accessed since the last time <code>pgaccess()</code> was called (i.e., the bit will be set forever).</p>
</blockquote>
<p>也就是说每次检查到一个，就需要手动清除掉PTE_A标记。</p>
<p>还有一点以前一直没注意到的，<strong>头文件的引用需要注意次序</strong>。比如说要是把spinlock.h放在proc.h后面，就会寄得很彻底。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p>那些系统调用的登记步骤就先省略了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sva;</span><br><span class="line">  <span class="type">int</span> pgnum;</span><br><span class="line">  uint64 bitmask;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;sva) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;pgnum) &lt; <span class="number">0</span> || argaddr(<span class="number">2</span>, &amp;bitmask) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> pgaccess((<span class="type">void</span>*)sva,pgnum,(<span class="type">void</span>*)bitmask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/pgaccess.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pgaccess</span><span class="params">(<span class="type">void</span>* sva,<span class="type">int</span> pgnum,<span class="type">void</span>* bitmask)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pgnum &gt; <span class="number">32</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pgaccess: range too big.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> kmask = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pgnum;i++)&#123;</span><br><span class="line">        <span class="type">pte_t</span>* pte = walk(p-&gt;pagetable,(uint64)sva+i*PGSIZE,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 映射不存在，或者没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!pte || !(*pte &amp; PTE_A))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        kmask = (kmask | (<span class="number">1</span>&lt;&lt;i));</span><br><span class="line">        *pte = (*pte &amp; (~PTE_A));</span><br><span class="line">    &#125;</span><br><span class="line">    copyout(p-&gt;pagetable,(uint64)bitmask,(<span class="type">char</span>*)(&amp;kmask),<span class="keyword">sizeof</span>(<span class="type">int</span>)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h3><blockquote>
<p>The goal of this section and the next is to allow the kernel to directly dereference user pointers.</p>
</blockquote>
<blockquote>
<p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. </p>
<p>Modify <code>struct proc</code> to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if <code>usertests</code> runs correctly.</p>
</blockquote>
<h4 id="感想-7"><a href="#感想-7" class="headerlink" title="感想"></a>感想</h4><p>这个其实平心而论不难，思路很简单。写着不难是不难，但想明白花费了我很多时间。</p>
<p>它这个要求我们修改kernel，使得每个进程都有一份自己的kernel page。至于要改什么，围绕着proc.c中，参照pagetable的生命周期摁改就行。还有一个地方它也提示了，就是要在swtch之前更换一下satp的值。</p>
<p>接下来，我说说我思考的几个点以及犯错的地方。</p>
<h5 id="为什么要这么干"><a href="#为什么要这么干" class="headerlink" title="为什么要这么干"></a>为什么要这么干</h5><p>看完题目，我的第一印象是，这么干有啥用。。。因为我觉得以前那个所有进程共用内核栈确实很好了，没有必要每个进程配一个后来才发现，这个跟下面那个是连在一起的，目的是<code> allow the kernel to directly dereference user pointers.</code>。所以，我们下面会把用户的pgtbl和这里dump出来的kpgtbl合在一起。</p>
<h5 id="关于myproc"><a href="#关于myproc" class="headerlink" title="关于myproc()"></a>关于myproc()</h5><p>在allocproc中初始化的时候，我一开始是这么写的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c allocproc()</span></span><br><span class="line">perproc_kvminit();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">perproc_kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(p-&gt;kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  pkvmmap(p-&gt;kpgtbl,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样会死得很惨，爆出如下panic：</p>
<img src="/2023/01/10/xv6/image-20230114011100370.png" class>

<p>通过hints的调试贴士</p>
<blockquote>
<p>A missing page table mapping will likely cause the kernel to encounter a page fault. It will print an error that includes <code>sepc=0x00000000XXXXXXXX</code>. You can find out where the fault occurred by searching for <code>XXXXXXXX</code> in <code>kernel/kernel.asm</code>.</p>
</blockquote>
<p>我发现程序在这里绷掉了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br></pre></td></tr></table></figure>

<p>而且显而易见，是系统启动时崩的。</p>
<p>经过了漫长的思考，我震惊地发现了它为什么崩了（）</p>
<p>首先，这段代码语法上是没有问题的。它固然犯了发布未初始化完成的对象这样的并发错误【我有罪】，也破坏了proc的封装性【proc中的很多私有属性本来应该作用域仅在proc.c中的。此处为了能让vm.c访问到proc中的属性，不得不给vm.c添上了proc.h的头文件】，但是它<u>并不是语法错误</u>，还是能用的。我做了这样的测试样例证明它没有问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">pagetable_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span>&#123;</span></span><br><span class="line">	<span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">processes</span>[<span class="title">MAX</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> proc* <span class="title function_">myproc</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;processes[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminit</span><span class="params">()</span>&#123;</span><br><span class="line">	myproc()-&gt;kpgtbl = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> &amp;processes[<span class="number">0</span>];</span><br><span class="line">	kvminit();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;kpgtbl);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我一路顺着os启动的路径找，也想不出来这能有什么错，因而非常迷茫。</p>
<p>此时我灵光一闪，会不会是myproc()在os刚启动的时候是发挥不了作用的？于是我一路顺着myproc的代码看下去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，mycpu()获得的cpu的proc是怎么得到的呢？</p>
<p>我搜寻了一下os启动代码，发现了cpu的proc得到的路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//...很多很多init</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调度执行第一个进程</span></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完进程后，就进入scheduler进行进程的调度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">        <span class="comment">//在这里！！！！</span></span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>因而，c-&gt;proc是在创建进程的第一次调度后初始化的，也即，myproc只有在执行第一次scheduler之后才可以调用。而！！！</p>
<p>当执行调度前的userinit时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br></pre></td></tr></table></figure>

<p>它进行了allocproc。我们亲爱的allocproc接下来就会调用perproc_kvminit，然后perproc_kvminit中调用myproc。此时尚未进行初次调度，因而c-&gt;proc未初始化，myproc返回的是0，也即null。这样一来，<code>myproc()-&gt;kpgtbl</code>就发生了空指针异常，也即scause = 15——写入页错误。</p>
<p>因而，对于myproc()的调用需要慎之又慎。</p>
<h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><p>系统调用时，是如何知道要用的是p中的内核页表而非global内核页表呢？</p>
<p>依然还是从os的启动说起。</p>
<p>在main.c中，kvminithart开启了页表，此时的页表为全局的内核页表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当userinit被调度时，全局的内核页表被换成了proc中的内核页表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c scheduler()</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpgtbl));</span><br><span class="line">sfence_vma();</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br></pre></td></tr></table></figure>

<p>但是这样还没有结束。因为我们除了得更换目前的页表，还得更换trapframe中的内核页表相关的东西：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为啥还要更换trapframe中的呢？因为以后系统调用的时候，uservec是从这里读取值来作为内核栈和内核页表的来源的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># in uservec</span><br><span class="line">		# restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        # 完成了内核栈的切换</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">		# 完成了页表的切换</span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br></pre></td></tr></table></figure>

<p>所以，为了以后系统调用能顺利自发进行，我们需要把栈帧也一起换掉。怎么换呢？我们是否还要在一些地方人工把trapframe的值设置为我们自己的内核栈内核页表？答案是，不用！这些会由其他代码自动完成。</p>
<p>前面说到userinit的进程p被调度，<strong>satp换成了我们自己的内核页表</strong>。那么，在之后的内核态，satp都将保持我们自己的内核页表。当要返回用户态时，会执行如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in usertrapret</span></span><br><span class="line">  <span class="comment">// 重置trapframe</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br></pre></td></tr></table></figure>

<p>satp内的值为我们自己的内核页表，而非全局页表。因而这样栈帧中的页表就会被自然而然地写入为进程的内核页表。之后返回用户态，以及之后之后的各种中断，就都会一直使用自己的内核页表了。【试了一下，这里如果改成非即时从satp读，而是默认的kernel_pagetable的话，会一直死循环】</p>
<p>不得不说，真是设计精妙啊！！！不过我觉得，要是这里写成kernel_pagetable，然后让我们自己改的话将是薄纱（。当然它应该也不会这么做，因为，kernel_pagetable事实上是不对外发布的。它这里这么写热读，最直接的原因还是因为读不到kernel_pagetable。这算是无心插柳柳成荫吗233</p>
<h5 id="释放页表但不释放物理内存"><a href="#释放页表但不释放物理内存" class="headerlink" title="释放页表但不释放物理内存"></a>释放页表但不释放物理内存</h5><p>其实答案就在它给的<code>proc_freepagetable</code>里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uvmfree</code>遍历页表，对每个存在的页表项，都试图找到其物理内存，并且释放物理内存和表项。如果页表项存在，但页表项对应的物理内存不存在，就会抛出<code>freewalk leaf</code>的异常。</p>
<p><code>uvmunmap</code>会释放掉参数给的va的页表项，最后一个参数表示释放or不释放。</p>
<p>在这里，使用这两个的组合技，就可以达到不释放<code>TRAMPOLINE</code>和<code>TRAPFRAME</code>的物理内存，又不会让uvmfree出错的效果。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化kpgtbl。由于现在内核栈存在各自的内核页表而非global内核页表中，所以在procinit中的对内核栈的初始化也得放在这：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c allocproc()</span></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p-&gt;kpgtbl = perproc_kvminit();</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">  uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">  pkvmmap(p-&gt;kpgtbl,va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">perproc_kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pt = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(pt, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  pkvmmap(pt,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  pkvmmap(pt,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  pkvmmap(pt,CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  pkvmmap(pt,PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  pkvmmap(pt,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  pkvmmap(pt,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  pkvmmap(pt,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pkvmmap</span><span class="params">(<span class="type">pagetable_t</span> pgtbl,uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当第一个进程开始时，mycpu-&gt;proc = null,所以这里不能调用myproc</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="swtch时切换页表"><a href="#swtch时切换页表" class="headerlink" title="swtch时切换页表"></a>swtch时切换页表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c scheduler()</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpgtbl));</span><br><span class="line">sfence_vma();</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有进程运行时使用全局kernel_pagetable</span></span><br><span class="line">      kvminithart();</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改kvmpa"><a href="#修改kvmpa" class="headerlink" title="修改kvmpa"></a>修改kvmpa</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">kvmpa</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  pte = walk(myproc()-&gt;kpgtbl, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel.proc.c freeproc()</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpgtbl)</span><br><span class="line">    proc_freekpgtbl(p-&gt;kpgtbl,p-&gt;kstack);</span><br><span class="line">  p-&gt;kpgtbl = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freekpgtbl</span><span class="params">(<span class="type">pagetable_t</span> pagetable,uint64 <span class="built_in">stack</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, UART0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, VIRTIO0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, CLINT, <span class="number">0x10000</span>/(uint64)PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, PLIC, <span class="number">0X400000</span>/(uint64)PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, KERNBASE, (uint64)((uint64)etext-KERNBASE)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, (uint64)etext,(PHYSTOP-(uint64)etext)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span></span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, <span class="built_in">stack</span>, <span class="number">1</span>,<span class="number">1</span> );</span><br><span class="line">  uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin/copyinstr</code></h3><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41822154/article/details/124898399">6.S081学习记录-lab3</a></p>
</blockquote>
<blockquote>
<p>The kernel’s <code>copyin</code> function reads memory pointed to by user pointers. It does this by translating them to physical addresses, which the kernel can directly dereference. It performs this translation by walking the process page-table in software. Your job in this part of the lab is to add user mappings to each process’s kernel page table (created in the previous section) that allow <code>copyin</code> (and the related string function <code>copyinstr</code>) to directly dereference user pointers.</p>
</blockquote>
<blockquote>
<p>Replace the body of <code>copyin</code> in <code>kernel/vm.c</code> with a call to <code>copyin_new</code> (defined in <code>kernel/vmcopyin.c</code>); do the same for <code>copyinstr</code> and <code>copyinstr_new</code>. Add mappings for user addresses to each process’s kernel page table so that <code>copyin_new</code> and <code>copyinstr_new</code> work.</p>
</blockquote>
<h4 id="感想-8"><a href="#感想-8" class="headerlink" title="感想"></a>感想</h4><p>这题很直观的思路是，在每个user pagetable添加映射的地方也添加kpgtbl的映射。但问题是，“每个user pagetable添加映射的地方”都是哪？</p>
<h5 id="误入幻想"><a href="#误入幻想" class="headerlink" title="误入幻想"></a>误入幻想</h5><p>我一开始想着偷偷懒，直接在proc.c和vm.c中每个操纵pagetable的地方都加上对kpgtbl的操纵。但很快我就给搞晕了。这时候，我心中萌生一计【PS：下面说的最后都没成功】：我直接快进到把proc结构中的pagetable属性给删了，然后每个出现p-&gt;pagetable的地方，都用p-&gt;kpgtbl代替，直接让两表合为一表，然后之后make的时候哪里报错改哪里，这不就一劳永逸地把所有出现pagetable的地方都改为kpgtbl了嘛。我振奋地去试了一下，将所有地方出现的pagetable都替换成了kpgtbl，把proc.c中的<code>proc_pagetable()</code>和<code>proc_freepagetable()</code>的出现的地方都换成了<code>perproc_kvminit()</code>以及<code>proc_freekpgtbl()</code>，还做了一个小细节，就是在userinit中调用的uvminit中，我把这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvminit</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uchar *src, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sz &gt;= PGSIZE)</span><br><span class="line">    panic(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">  mem = kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  mappages(pagetable, <span class="number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);</span><br><span class="line">  memmove(mem, src, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>换成了这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvminit</span><span class="params">(<span class="keyword">struct</span> proc* p, uchar *src, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sz &gt;= PGSIZE)</span><br><span class="line">    panic(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">  mem = kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  mappages(p-&gt;kpgtbl, <span class="number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);</span><br><span class="line">  memmove(mem, src, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在启动的时候，卡在了初次调度切换不到initcode这边，没有调用exec。没有panic，似乎只在死循环。我也实在想不出是什么原因，最后把代码删了【悲】想想我应该用git保存一下改前改后的。这下实在是难受了，我的想法也暂时没有机会实践了。等到明年大三说不定还得再交一次这玩意，到时候再探究探究吧hhh</p>
<h5 id="走上正途"><a href="#走上正途" class="headerlink" title="走上正途"></a>走上正途</h5><p>发现这个最后没成还改了半天的我最后非常沮丧地去看了hints【又一心浮气躁耐心不足的表现，但确实绷不住了】，发现它居然说只用修改三个地方：fork、exec以及sbrk。</p>
<p>我把kernel/下的每个文件都搜了一遍，发现确实，只有这三个，以及proc.c，vm.c，涉及到对页表项的增删。而在用户态中，想要对进程的内存进行管理，似乎只能通过系统调用sbrk。而proc.c和vm.c中确实没什么好改的。因为里面增加的映射，都是trapframe、trampoline、inicode这种不会一般在copyin中用到的虚拟地址。所以，要改的地方，确确实实，<u>只有fork、exec以及sbrk</u>。</p>
<blockquote>
<p> Xv6 applications ask the kernel for heap memory using the sbrk() system call. </p>
</blockquote>
<p>很悲伤，我的初见思路是错误的（）</p>
<p>而这三个地方的共同点，就是都会对页表进行大量的copy。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in proc.c fork()</span></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in exec.c</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in syscall.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//in proc.c growproc()</span></span><br><span class="line">uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>所以，我们要做的事情很简单：写一个坐收渔翁之利的函数，内容为把一个页表的所有内容复制到另一个页表。然后再在这几个地方调用这个函数即可。</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><blockquote>
<p>注意：由于我写得实在是太烦了，已经思考不下去了。为了<strong>放过我自己</strong>，我写了个虽然能过得去测试但是其实毛病重重的代码。垃圾点为以下几点：</p>
<ol>
<li><p>需要去掉freewalk中的panic</p>
<p>我的kvmcopy的实现是，user pagetable（下面简称up）和tp的相同虚拟地址共用同一页物理内存。也就是说，页表不一样，但所指向的物理内存是同一个。这样设计的目的是为了能够让tp及时用到up的更新后的数据。</p>
<p>这会导致啥呢？在进程释放时，需要一起调用<code>proc_freepagetable</code>和<code>proc_freekpgtbl</code>。<code>proc_freepagetable</code>调用完后，所指向的那堆物理内存已经寄完了，如果再调用<code>proc_freekpgtbl</code>，显然，就会发生页表未释放但页表对应内存已经释放的问题，freewalk就会panic。因此，我简单粗暴地直接把freewalk的panic删掉了【抖】也许有别的解决方法，但我真是烦得不想想了放过我吧（</p>
</li>
<li><p>好像暂时没有第二点了（）</p>
</li>
</ol>
</blockquote>
<h5 id="渔翁之利函数"><a href="#渔翁之利函数" class="headerlink" title="渔翁之利函数"></a>渔翁之利函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="comment">// 效仿的是vm.c中的uvmcopy</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kvmcopy</span><span class="params">(<span class="type">pagetable_t</span> up, <span class="type">pagetable_t</span> kp, uint64 sz)</span></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123; </span><br><span class="line">    <span class="keyword">if</span>((pte = walk(up, i, <span class="number">0</span>)) == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(walk(kp,i,<span class="number">0</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果up不存在此项，kp存在，就直接删了</span></span><br><span class="line">            uvmunmap(kp,i,PGSIZE,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// 注意去除PTE_U，否则内核态无法访问</span></span><br><span class="line">    flags = (flags &amp; (~PTE_U));</span><br><span class="line">    <span class="keyword">if</span>(mappages(kp, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(kp, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改fork、exec、sbrk"><a href="#修改fork、exec、sbrk" class="headerlink" title="修改fork、exec、sbrk"></a>修改fork、exec、sbrk</h5><h6 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c fork()</span></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(kvmcopy(np-&gt;pagetable, np-&gt;kpgtbl, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h6 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in exec.c</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line"></span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添上此句</span></span><br><span class="line">  kvmcopy(p-&gt;pagetable, p-&gt;kpgtbl, p-&gt;sz);</span><br></pre></td></tr></table></figure>

<h6 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a>sbrk</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(addr+n &gt;= PLIC)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c</span></span><br><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="comment">// 加这个</span></span><br><span class="line">  kvmcopy(p-&gt;pagetable, p-&gt;kpgtbl, p-&gt;sz);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="userinit"><a href="#userinit" class="headerlink" title="userinit"></a>userinit</h5><blockquote>
<p>这一步不能忽视，因为内核启动的时候就需要用到copyinstr。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c userinit()</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  <span class="comment">// 加这个！</span></span><br><span class="line">  kvmcopy(p-&gt;pagetable, p-&gt;kpgtbl, p-&gt;sz);</span><br></pre></td></tr></table></figure>

<h5 id="删掉freewalk的panic（我特有的缺点）"><a href="#删掉freewalk的panic（我特有的缺点）" class="headerlink" title="删掉freewalk的panic（我特有的缺点）"></a>删掉freewalk的panic（我特有的缺点）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in vm.c freewalk()    </span></span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="comment">//panic(&quot;freewalk: leaf&quot;);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Traps-and-system-calls"><a href="#Traps-and-system-calls" class="headerlink" title="Traps and system calls"></a>Traps and system calls</h1><p>traps=系统调用+异常+中断。本章着重讲traps概述以及traps中的系统调用。</p>
<p>对trap的处理包含四个部分：硬件处理、中断向量、trap handler、对应的处理函数</p>
<h2 id="RISC-V-trap-machinery"><a href="#RISC-V-trap-machinery" class="headerlink" title="RISC-V trap machinery"></a>RISC-V trap machinery</h2><h3 id="control-register"><a href="#control-register" class="headerlink" title="control register"></a>control register</h3><p>risc-v为trap提供了一组寄存器：</p>
<ol>
<li><p>stvec</p>
<p>trap handler的入口地址</p>
</li>
<li><p>sepc</p>
<p>原程序PC</p>
</li>
<li><p>scause</p>
<p>中断号</p>
</li>
<li><p>sscratch</p>
<p>TRAPFRAME地址</p>
</li>
<li><p>sstatus</p>
<p>是否允许中断，以及中断来自内核态还是用户态</p>
</li>
</ol>
<blockquote>
<p>The above registers relate to traps <strong>handled in supervisor mode</strong>, and they cannot be read or written in user mode. </p>
<p>There is an equivalent set of control registers for traps handled <strong>in machine mode</strong>; xv6 uses them <strong>only</strong> for the special case of <u>timer interrupts</u>.</p>
</blockquote>
<p>每个CPU都有自己的一套这样的控制寄存器。</p>
<h3 id="硬件处理步骤"><a href="#硬件处理步骤" class="headerlink" title="硬件处理步骤"></a>硬件处理步骤</h3><p>时钟中断、device interrupt以及关中断的情况下，不会做以下步骤。</p>
<blockquote>
<p>\1. If the trap is a device interrupt, and the sstatus SIE bit is clear, <strong>don’t</strong> do any of the following.</p>
<p>\2. Disable interrupts by clearing SIE.关中断</p>
<p>\3. Copy the pc to sepc.保存PC</p>
<p>\4. Save the current mode (user or supervisor) in the SPP bit in sstatus.保存mode</p>
<p>\5. Set scause to reflflect the trap’s cause.保存中断号</p>
<p>\6. Set the mode to supervisor.切换到内核态</p>
<p>\7. Copy stvec to the pc.将trap handler写入pc，开始执行trap handler</p>
</blockquote>
<p>切换到内核页表、切换内核栈、保存寄存器现场这些工作交给操作系统完成。</p>
<h2 id="Traps-from-user-space"><a href="#Traps-from-user-space" class="headerlink" title="Traps from user space"></a>Traps from user space</h2><p>从用户态来的trap会经历怎么样的过程？</p>
<p>前面说到，下面需要进行页表的切换，页表的切换必然是接下来要做的指令的某个环节。那么为了让页表切换之后，CPU还知道要从哪里取指执行，<strong>就要让某段物理内存在内核空间和用户空间的虚拟地址一样</strong>。这样，不论页表是用户的还是内核的，都可以通过同样的虚拟地址访问到该段存放指令的物理内存从而继续执行。</p>
<p>这段虚拟地址就是<strong>trampoline</strong>。它在内核页表和用户页表都位于MAXVA的位置。</p>
<img src="/2023/01/10/xv6/p3.png" class>

<p>stevc存储的正是trampoline段中的uservec。</p>
<h3 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h3><p>sscratch里面存的是trapframe的值。</p>
<p>trapframe存在于用户空间中，并且每个进程的trapframe所处位置固定是在trampoline下方。</p>
<img src="/2023/01/10/xv6/image-20230111203357767.png" class>

<p>首先将寄存器的值都存入trapframe中；然后，再从trapframe中读取内核栈指针、当前CPUid，下一步要跳转的usertrap的地址，以及内核页表。最后，uservec切换到内核页表，并且jmp到usertrap。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#in kernel/trampoline.S</span><br><span class="line">	.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process&#x27;s p-&gt;trapframe is</span><br><span class="line">        # mapped into user space, at TRAPFRAME.</span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">		# swap a0 and sscratch</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        # ...</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">		# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        # 完成了内核栈的切换</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        # 这里完成了页表的切换</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：trampoline和trapframe有一些相通点。</p>
<p>trampoline为了保障某段物理内存的虚拟地址在内核栈和用户栈中不变，做出的努力是，在内核栈和用户栈都分配同一位置的PTE。</p>
<p>trapframe用于保护现场、用户态向内核态传递参数等等，做出的努力是，在用户栈分配同一位置的PTE，在内核态的局部变量中保存了自己的物理地址。</p>
<p>这两个说实话有点容易混起来，因为我想了半天trampoline可不可以用类似trapframe一样的方法，结论是不行。因为你trampoline的作用是维持指令序列依然不变，不会突然没掉；而trapframe段是用来存储数据而非执行的，对其的控制也是需要指令的。如果trampoline使用第二种方法，指令流就会断掉，更别说别的了。</p>
</blockquote>
<h3 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h3><p>作用是得到trap发生的原因，并且执行对应的处理程序，然后返回结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  <span class="comment">//首先把trap handler切换到kernel的，这样一来如果在kernel中发生trap就会由kernel的handler处理</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在当前进程中再次保存用户程序的原PC，防止之后sepc被覆盖</span></span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//根据cause号不同处理</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="comment">//注意，在此处开启了中断</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用syscall处理</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行对应的处理函数"><a href="#执行对应的处理函数" class="headerlink" title="执行对应的处理函数"></a>执行对应的处理函数</h3><p>比如说system call会修改trapframe中的a0为返回的结果，会获取trapframe中的各个参数。这个“保护现场“感觉是非常微妙的，它兼顾了保护现场和传递参数两个作用</p>
<h3 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h3><p>回到用户态。之前陷入内核态对stvec、satp、sp、hartid、trap handler都做了适应内核态的改变，因而这里就需要改回原来适应用户态的样子，然后返回用户态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关中断</span></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置trapframe</span></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">		# 切换为用户页表</span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        # ...</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h2 id="Code-calling-system-calls"><a href="#Code-calling-system-calls" class="headerlink" title="Code: calling system calls"></a>Code: calling system calls</h2><blockquote>
<p>Chapter 2 ended with initcode.S invoking the exec system call (user/initcode.S:11). Let’s look at how the user call makes its way to the exec system call’s implementation in the kernel.要讲如何从用户态找到exec的代码了。</p>
</blockquote>
<h2 id="Code-system-call-arguments"><a href="#Code-system-call-arguments" class="headerlink" title="Code: system call arguments"></a>Code: system call arguments</h2><p>讲的是系统调用时，是如何把用户态传递的地址转化为内核态地址的。</p>
<p>这个部分可以看看hit实验的实验3 6.7，讲得很详细，而且流程是差不多的。linux0.11的<code>get_fs_byte()</code>就相当于xv6的<code>copyinstr</code>。</p>
<h2 id="Traps-from-kernel-space"><a href="#Traps-from-kernel-space" class="headerlink" title="Traps from kernel space"></a>Traps from kernel space</h2><h3 id="kernelvec"><a href="#kernelvec" class="headerlink" title="kernelvec"></a>kernelvec</h3><p>不同于用户态还得先潜入内核再潜出内核，内核的trap可简单多了，省去了切来切去各种东西的步骤，只需当做一个普通的函数调用就行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># in kernel/kernelvec.S</span><br><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        // make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        // save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)</span><br><span class="line">		# ...</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">	// call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        // restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        # ...</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        // return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h3 id="kerneltrap"><a href="#kerneltrap" class="headerlink" title="kerneltrap"></a>kerneltrap</h3><blockquote>
<p>kerneltrap is prepared for two types of traps: device interrrupts and exceptions. </p>
<p>It calls devintr (kernel/trap.c:177) to check for and handle the <strong>former</strong>. If the trap isn’t a device interrupt, it must be an exception, and that is always a fatal error if it occurs in the xv6 kernel; the kernel calls panic and stops executing.</p>
<p>If kerneltrap was called due to a timer interrupt, and a process’s kernel thread is running (rather than a scheduler thread), kerneltrap calls yield to give other threads a chance to run.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c</span></span><br><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在此处的devintr对不同的设备进行不同的处理方式</span></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Page-fault-exceptions"><a href="#Page-fault-exceptions" class="headerlink" title="Page-fault exceptions"></a>Page-fault exceptions</h2><p>似乎xv6是没有这个缺页exception的。这里主要讲解了三个可以利用缺页中断实现的优化：COW fork、lazy allocation、paging from disk。还提及了automatically extending stacks 以及memory-mapped fifiles。</p>
<h2 id="Lab：Trap"><a href="#Lab：Trap" class="headerlink" title="Lab：Trap"></a>Lab：Trap</h2><blockquote>
<p>This lab explores how system calls are implemented using traps. You will first do a warm-up exercises with stacks and then you will implement an example of user-level trap handling.</p>
</blockquote>
<h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>刚刚上去ubuntu突然发现寄了打不开。。。。看了这篇文章找到了恢复方法：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/rdw1246010462/article/details/109632296">ubuntu开机出现started gnome Display manager等错误的方法</a></p>
<p>但是我的<code>apt autoremove --purge snapd</code>指令没有用，好像是因为缺少依赖包，但又没空间下载了。折腾了一下重启发现好了，好了的话那就先凑合着用吧（</p>
<h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><h4 id="题目和答案"><a href="#题目和答案" class="headerlink" title="题目和答案"></a>题目和答案</h4><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53111905/article/details/120996446">Lab4: traps</a></p>
<p>There is a file <code>user/call.c</code> in your xv6 repo. make fs.img compiles it and also produces a readable assembly version of the program in <code>user/call.asm</code>.</p>
<p>Read the code in call.asm for the functions <code>g</code>, <code>f</code>, and <code>main</code>. Here are some questions that you should answer:</p>
</blockquote>
<ol>
<li><p>a2</p>
</li>
<li><p>被inline掉了</p>
</li>
<li><p>0x64A</p>
<img src="/2023/01/10/xv6/image-20230111224927837.png" class>

<p>auipc的作用是把立即数左移12位，低12位补0，和pc相加赋给指定寄存器。这里立即数是0，指定寄存器是ra，即ra=pc=0x30=48。jalr作用是跳转到立即数+指定寄存器处并且把ra的值+8。因此jalr会跳转1562+48=1594=0x64A处，观察汇编代码可知确实在000000000000064a处。</p>
</li>
<li><p>0x38</p>
</li>
<li><blockquote>
<p>Run the following code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>What is the output? <a target="_blank" rel="noopener" href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the RISC-V is <strong>little-endian</strong>. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<img src="/2023/01/10/xv6/format,png.png" class></blockquote>
</li>
<li><p>取决于寄存器a2（第3个参数）的值。</p>
</li>
</ol>
<h4 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h4><p>我超。。差不多都不会（2345），更可怕的是不会查文档，不知道从哪里看RISC-V指令集的内容，救。果然真的太弱了。</p>
<h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><blockquote>
<p>For debugging it is often useful to have a backtrace: a list of the function calls on the stack above the point at which the error occurred.</p>
<img src="/2023/01/10/xv6/image-20230111232323444.png" class>

<p>The compiler puts in each stack frame a frame pointer that holds the address of the caller’s frame pointer. Your <code>backtrace</code> should use these frame pointers to walk up the stack and print the saved return address in each stack frame.</p>
</blockquote>
<blockquote>
<p>Some hints:</p>
<ul>
<li><p>Add the prototype for backtrace to <code>kernel/defs.h</code> so that you can invoke <code>backtrace</code> in <code>sys_sleep</code>.</p>
</li>
<li><p>The GCC compiler stores the frame pointer of the currently executing function in the register s0. Add the following function to kernel/riscv.h:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and call this function in backtrace to read the current frame pointer. This function uses in-line assembly to read s0.</p>
</li>
<li><p>These <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">lecture notes</a> have a picture of the layout of stack frames. Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.</p>
</li>
<li><p>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. You can compute the top and bottom address of the stack page by using <code>PGROUNDDOWN(fp)</code> and <code>PGROUNDUP(fp)</code> (see <code>kernel/riscv.h</code>. These number are helpful for <code>backtrace</code> to terminate its loop.</p>
</li>
</ul>
</blockquote>
<h4 id="感想-9"><a href="#感想-9" class="headerlink" title="感想"></a>感想</h4><p>我超，这题真的是那怎能只叫一个拷打……</p>
<h5 id="存储在s0中的栈帧指针"><a href="#存储在s0中的栈帧指针" class="headerlink" title="存储在s0中的栈帧指针"></a>存储在s0中的栈帧指针</h5><p>这个应该是risc-v的约定成俗的特性。我搜了一下risc-v的栈帧指针保存在哪个寄存器，看到了这样一篇文章：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dai_xiangjun/article/details/126541174">risc-v 栈分析</a></p>
<img src="/2023/01/10/xv6/image-20230112012358601.png" class>
</blockquote>
<p>这个信息没有放在题干提示，是在考察信息检索能力吗（</p>
<blockquote>
<p>首先，我看完题目就麻了，不知道从何下手。我知道首先得知道栈的结构，比如说<code>The compiler puts in each stack frame a frame pointer that holds the address of the caller&#39;s frame pointer.</code>这句话说的那个pointer到底存在了栈的哪块位置，又存在了哪个寄存器。我看了提示才知道，是存在s0寄存器的。这是怎么看出来的？我完全想不到怎么就拐到s0了。</p>
</blockquote>
<h5 id="栈的结构与栈帧的理解"><a href="#栈的结构与栈帧的理解" class="headerlink" title="栈的结构与栈帧的理解"></a>栈的结构与栈帧的理解</h5><img src="/2023/01/10/xv6/image-20230112010749756.png" class>

<p>这是来自hint的栈结构。整个栈存储在一页中，由高地址向低地址增长。栈帧代表了一次函数调用，其中会存储如函数名、函数参数、局部变量等等信息。有几次函数调用就有几个栈帧，栈由栈帧组成。</p>
<p>s0中存储的栈帧指针fp指向的是栈帧的最高地址，如图fp所示。</p>
<blockquote>
<p>我理解错了栈帧的定义，都怪我基础不大牢固也不认真思考【悲】我一开始以为stack frame指的是一个栈，也即一页空间【我知道栈帧这个中文名词，但遇到英语就短路了】。老师画的这个图也被我理解为多个栈，也即多页拼在一起，要打印的Return Address处于页的最顶部。我就在这个思路上一去不复返了，压根没有意识到一个进程tmd只有一个栈啊！！！【大悲】然后顺带脑补把r_fp()也曲解了，以为它的意思是读取当前栈【非常自然地认为有很多个栈←】的下一个栈的最低地址【因为栈换掉了，所以s0也会变成父亲的栈的地址】。于是就写出了这样的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">      uint64 kstack = PGROUNDUP((uint64)(myproc()-&gt;kstack)+<span class="number">1</span>);</span><br><span class="line">      uint64 nstack = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>((nstack=(uint64)r_fp())!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*((uint64*)(kstack<span class="number">-8</span>)));</span><br><span class="line">            kstack = nstack;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果最后死循环了。去看了别人的代码发现他们写的结构就跟我完全不一样。琢磨着画着图，最后找了stack frame的定义，才恍然大悟（</p>
</blockquote>
<h5 id="思路形成"><a href="#思路形成" class="headerlink" title="思路形成"></a>思路形成</h5><p>我们只需遍历栈中所有栈帧，打印每个栈帧的Return Address部分就行。通过r_fp()获取第一个栈帧的位置，其他栈帧的位置由Prev.Frame获取。循环的界限是PGROUNDUP(r_fp())，因为栈只有一页的空间。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  uint64 <span class="built_in">stack</span> = r_fp();</span><br><span class="line">  uint64 nstack = <span class="number">0</span>;</span><br><span class="line">  uint64 top = PGROUNDUP(<span class="built_in">stack</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">stack</span>!=top)&#123;</span><br><span class="line">    nstack=*((uint64*)(<span class="built_in">stack</span><span class="number">-16</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*((uint64*)(<span class="built_in">stack</span><span class="number">-8</span>)));</span><br><span class="line">    <span class="built_in">stack</span> = nstack;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><blockquote>
<p>In this exercise you’ll add a feature to xv6 that <u>periodically alerts a process as it uses CPU time</u>. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. </p>
<p>More generally, you’ll be implementing a primitive form of user-level interrupt/fault handlers; you could use something similar to handle page faults in the application, for example. </p>
<p>You should add a new <code>sigalarm(interval, handler)</code> system call. If an application calls <code>sigalarm(n, fn)</code>, then after every <code>n</code> “ticks” of CPU time that the program consumes, the kernel should cause application function <code>fn</code> to be called. When <code>fn</code> returns, the application should resume where it left off.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h5><p>思路：sigalarm需要在用户程序在用户态运行的情况下，监测到用户程序已经运行了n个时间片，然后发出中断请求。我们会新设置一个中断类型alarm。kerneltrap接收到sigalarm的中断请求，检测到中断类型为alarm，就会在处理的时候调用fn。fn调用完就自然而然利用中断恢复到原来的现场了。所以要做的可以分为两部分。但问题是，如何让sigalarm在用户程序运行的同时监测n个时间片呢？难道得fork一个新的进程吗？然后父进程返回，子进程执行类似sleep里面那样的监测，直到时间片到了，就发送一个中断请求，让父进程停止，执行完fn回来之后就exit。</p>
<h5 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h5><p>可以看到，初见思路很多地方跟最后是不一样的。其中错得最离谱的，也是比较隐坑很容易因为想不明白就寄了的，是handler是个用户态的函数（。你不可能在内核态中调用fn，然后fn执行完后再自然而然地通过中断机制返回，因为你想要执行fn就必须进入用户态。这一点是需要一开始明确的。</p>
<p>明确了这一点后，让人更加不知道该怎么办了。那就一步步跟着指导书的脚步来思考吧。</p>
<h6 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h6><p>首先，明确你需要实现什么。你需要实现两个系统调用，一个是sigalarm，一个是sigreturn。它们会被这样调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in user/alarmtest.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  test0();</span><br><span class="line">  test1();</span><br><span class="line">  test2();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">periodic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  count = count + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;alarm!\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 此处调用sigreturn</span></span><br><span class="line">  sigreturn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tests whether the kernel calls</span></span><br><span class="line"><span class="comment">// the alarm handler even a single time.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;test0 start\n&quot;</span>);</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 此处调用sigalarm</span></span><br><span class="line">  sigalarm(<span class="number">2</span>, periodic);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>*<span class="number">500000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((i % <span class="number">1000000</span>) == <span class="number">0</span>)</span><br><span class="line">      write(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此处调用sigalarm</span></span><br><span class="line">  sigalarm(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test0 passed\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ntest0 failed: the kernel never called the alarm handler\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__ ((noinline)) foo(<span class="type">int</span> i, <span class="type">int</span> *j) &#123;</span><br><span class="line">  <span class="keyword">if</span>((i % <span class="number">2500000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    write(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *j += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// tests that the kernel calls the handler multiple times.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// tests that, when the handler returns, it returns to</span></span><br><span class="line"><span class="comment">// the point in the program where the timer interrupt</span></span><br><span class="line"><span class="comment">// occurred, with all registers holding the same values they</span></span><br><span class="line"><span class="comment">// held when the interrupt occurred.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;test1 start\n&quot;</span>);</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  sigalarm(<span class="number">2</span>, periodic);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">500000000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">10</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    foo(i, &amp;j);</span><br><span class="line">  &#125;</span><br><span class="line">  sigalarm(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line">  <span class="keyword">if</span>(count &lt; <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ntest1 failed: too few calls to the handler\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">    <span class="comment">// the loop should have called foo() i times, and foo() should</span></span><br><span class="line">    <span class="comment">// have incremented j once per call, so j should equal i.</span></span><br><span class="line">    <span class="comment">// once possible source of errors is that the handler may</span></span><br><span class="line">    <span class="comment">// return somewhere other than where the timer interrupt</span></span><br><span class="line">    <span class="comment">// occurred; another is that that registers may not be</span></span><br><span class="line">    <span class="comment">// restored correctly, causing i or j or the address ofj</span></span><br><span class="line">    <span class="comment">// to get an incorrect value.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ntest1 failed: foo() executed fewer times than it was called\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1 passed\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再结合提示，可知实验设计者给我们的思路是，通过sigalarm设置定时函数，通过sigalarm(0,0)取消定时函数。每次时钟中断检测当前定时时间是否达到，若已达到，则跳到定时函数执行。定时函数执行完后，需要借助sigreturn，才能正确返回时钟中断前的程序点。</p>
<h6 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h6><p>这又可拆解为几个要点：</p>
<ol>
<li>如何实现“定时”？</li>
<li>时钟中断在内核态的usertrap被检测。怎么从usertrap出来跳到定时函数而非原程序执行点？</li>
<li>执行完定时函数后，怎么样才能回到原程序执行点？</li>
</ol>
<h6 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a>part 3</h6><p>一个个来说，首先是如何实现定时。这个很简单。参照sys_sleep的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  backtrace();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，我们可以用ticks表示当前系统滴答数。这样，我们就可以在proc域里维护一个变量lasttick，记录上一次执行handler时的滴答数。每次在时钟中断时检测，所以需要写在<code>kernel/trap.c</code>中的<code>usertrap</code>中。</p>
<h6 id="part-4"><a href="#part-4" class="headerlink" title="part 4"></a>part 4</h6><p>然后，是怎么从usertrap出来跳到指定程序结束点。在书中，我们知道，sepc寄存器保存了中断前原程序的下一个执行点，sepc的备份存储在了proc域中的栈帧中。当中断返回时（在usertrapret中），会从栈帧中的epc字段读取sepc的备份赋值给sepc，再由sret帮助我们跳转到原程序点。因而，如果想要改变跳转点，我们只需要修改<code>p-&gt;trapframe-&gt;epc</code>就行。</p>
<h6 id="part-5"><a href="#part-5" class="headerlink" title="part 5"></a>part 5</h6><p>最后，是如何从periodic回到原程序执行点。</p>
<img src="/2023/01/10/xv6/image-20230113002057893.png" class>

<p>这是每次进行时钟中断时的栈情况和执行代码链：t1-&gt;trampoline-&gt;usertrap-&gt;handler。</p>
<p>再然后，handler调用了sigreturn，用户栈中就会产生sigreturn的栈帧：</p>
<img src="/2023/01/10/xv6/image-20230113002434093.png" class>

<p>此时，如果sigreturn执行完，就会在这样的情况下执行handler的ret指令：</p>
<img src="/2023/01/10/xv6/image-20230113002542335.png" class>

<p>ret指令会把栈帧弄走，也就是说会直接回到某个错误的地方去。这显然不大合适。所以，我们要做的，就是在sigreturn之后，<u>不执行handler的ret指令，也不执行sigreturn的ret指令，而是直接恢复到时钟中断前的上下文</u>。时钟中断前的上下文，会因在handler中调用sigreturn系统调用，而被<strong>覆盖</strong>，因而，我们就需要记录时钟中断前的上下文，也即在proc域中保存trapframe的一份拷贝savedtrap，每次时钟中断都更新一次savedtrap，然后在sigreturn调用的时候将proc原本的trapframe替换为savedtrap即可。这样一来，就完成了这道题。</p>
<h5 id="感想-10"><a href="#感想-10" class="headerlink" title="感想"></a>感想</h5><p>这题目确实最终代码看起来完全不难，但是非常地拷打。。。。我前前后后修修补补差不多一共花了五个小时之久。</p>
<p>计时怎么计，以及使用trapframe-&gt;epc来跳转这两点还是很容易想到的【话虽如此，其实也很曲折】。主要难点还是在怎么恢复现场。怎么说呢，我花了这么久做实验，但是实际笔记却写不出个鬼来，足以看出其复杂程度。</p>
<p>我主要还是思维固化了点，一直在想，怎么确保它正确返回现场。我一开始以为proc域保存一个寄存器状态，且只用在一开始设置定时函数也即sigalarm的时候保存一次就行了，并且认为其是epc。然而实际操作后发现usertrap崩了，并且epc中存储的并不是程序被时钟中断的地方，而是各种神奇的地方，具体我也忘了，反正不能行。我印象最深刻的是有一次停在了usys.S中的sigreturn的最后一个ret处。我就在想，也许是栈出了问题。于是我就想着直接在sigreturn的时候把epc指向栈帧中的return address，直接回到原执行段。我百度了一下，确实有这么个寄存器ra，存储着return address。于是我就把proc域的状态换成了ra，依然仅保存一次，最后发现还是不行，程序在test0之后就异常终止了，main也回不去，十分古怪，十分匪夷所思。我实在没忍住，百度了一下大家怎么做的，发现大家压根没有我这样的二选一的烦恼，是直接保存整个栈帧。而且也不是仅保存一次，而是每次时钟中断触发都保存一次。我觉得十分奇怪震惊，但此时已是差不多晚饭时间，我就先去吃了个饭（）</p>
<p>回来之后，我细细画了图【向正确思路part5中的那样】，发现我原来那个只保存两者之一，且都只保存一次的方式，确实完全不能行。但是，我发现两个一起保存，并且每次时钟中断保存的方法，似乎能行，而且，比保存一整个栈帧要聪明得多。于是我就去试了，发现还是不行。我再细想了一遍，发现，如果想回去原程序的现场，除了ra和epc，还有一个很重要的东西需要保存，那就是——用户栈指针sp！</p>
<p>也就是说，<strong>只需保存ra、epc、sp，就可以保证回到正确的时钟中断前的位置</strong>：</p>
<img src="/2023/01/10/xv6/image-20230113005100895.png" class>

<p>此为handler中sigreturn执行完要返回时的状态。</p>
<p>当处在handler中时，sp的值为sigreturn处的栈帧。执行系统调用时，proc域中的上下文被覆盖，也即时钟中断前的上下文被覆盖。如果此时不对栈帧中的sp进行恢复，仅恢复ra和epc，在从sigreturn返回到epc对应处也即t1，t1执行ret想回到main的时候，就会回不去，而是回到了sigreturn要回的位置，也即handler的位置，然后不知不觉就寄了。所以，就需要防止sp被覆盖。因而，再保存一个状态sp，就可以保障回到正确的地方了。测试出来，kernel确实不再会panic了。</p>
<p>但是由于运行时很多除这三个以外的寄存器都被改过了，回是回得去，接下来干的活就不一定对了。因此为了保险以及通用性以及便利性来看，还是像别人那样直接保存栈帧比较ok。</p>
<p>还有一件事，就是上述错误中经常会出现的一个输出结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usertrap:unexpected cause scause = <span class="number">0x0c</span></span><br></pre></td></tr></table></figure>

<p>我留意了一下是什么意思。网上搜索得，scause=12，说明这是一个instruction page fault，而这个缺页错误说明了什么？：</p>
<img src="/2023/01/10/xv6/image-20230113012355740.png" class>

<p>这样，一切都明朗了。出现了scause=0x0c的意思就是说pc里的值不恰当，也就是说上面错误的方法都会跳转到错误的地方去。</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><h5 id="sigalarm-c"><a href="#sigalarm-c" class="headerlink" title="sigalarm.c"></a>sigalarm.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> intervel,<span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;interval = intervel;</span><br><span class="line">    p-&gt;handler = handler;</span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    p-&gt;lasttick = ticks;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">if</span>(handler == <span class="number">0</span> &amp;&amp; intervel == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(p-&gt;savetrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sigreturn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    memmove(p-&gt;trapframe,p-&gt;savetrap,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="trap-c"><a href="#trap-c" class="headerlink" title="trap.c"></a>trap.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">    yield();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;interval!=<span class="number">0</span>&amp;&amp;p-&gt;flag!=<span class="number">1</span>)&#123;</span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      uint tmp = ticks-p-&gt;lasttick;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">if</span>(tmp &gt;= p-&gt;interval&amp;&amp;p-&gt;flag!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          memmove(p-&gt;savetrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">          p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;	</span><br><span class="line">          p-&gt;flag=<span class="number">1</span>;</span><br><span class="line">          p-&gt;lasttick = ticks;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab：xv6-lazy-page-allocation"><a href="#Lab：xv6-lazy-page-allocation" class="headerlink" title="Lab：xv6 lazy page allocation"></a>Lab：xv6 lazy page allocation</h2><blockquote>
<p>来自书本：</p>
<p>Another widely-used feature is called <em>lazy allocation</em>, which has two parts:</p>
<ol>
<li>First, when an application calls sbrk, the kernel grows the address space, but marks the new addresses as not valid in the page table. </li>
<li>Second, on a page fault on one of those new addresses, the kernel allocates physical memory and maps it into the page table. </li>
</ol>
<p>The kernel allocates memory only when the application actually uses it. </p>
</blockquote>
<h3 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk()"></a>Eliminate allocation from sbrk()</h3><blockquote>
<p>Your first task is to delete page allocation from the sbrk(n).</p>
<p>The sbrk(n) system call grows the process’s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process’s size (myproc()-&gt;sz) by n and return the old size. It should not allocate memory – so you should delete the call to growproc() (but you still need to increase the process’s size!).</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> sz = myproc()-&gt;sz;</span><br><span class="line">  addr = sz;</span><br><span class="line">  myproc()-&gt;sz = sz + n;</span><br><span class="line">  <span class="comment">//if(growproc(n) &lt; 0)</span></span><br><span class="line">  <span class="comment">//  return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h3><blockquote>
<p>Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. </p>
<p>You should add your code just before the <code>printf</code> call that produced the “usertrap(): …” message. Modify <strong>whatever</strong> other xv6 kernel code you need to in order to get <code>echo hi</code> to work.【不择手段地前进！&lt;- 既视感】</p>
</blockquote>
<h4 id="感想-11"><a href="#感想-11" class="headerlink" title="感想"></a>感想</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>首先，要知道缺页中断的scause为13或15.【论我怎么知道的：被以前的实验逼出来的hhh】然后，要写在if条件的第二个分支。在该分支内，我们需要先获取出问题的地方的虚拟地址的值，然后申请新的一页，再map到当前页表中。</p>
<h5 id="一个难以察觉的错误"><a href="#一个难以察觉的错误" class="headerlink" title="一个难以察觉的错误"></a>一个难以察觉的错误</h5><p>思路是很简单的，就是有小细节需要格外注意。</p>
<p>trap.c在<code>mappages</code>时，一定不能直接传入va，必须传入<code>PGROUNDDOWN(va)</code>。如果直接传入va，会爆出如下错误：</p>
<img src="/2023/01/10/xv6/image-20230116154004538.png" class>

<p>但是，查看<code>mappages</code>的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，它在里面已经对va进行了处理了，使它变成了page-align的a变量。那么为什么，我们还要在外面再对va处理一次呢？</p>
<p>其实问题不是出在<code>mappages</code>中的a变量上，而是出现在<code>mappages</code>中的last变量上。比如，令va=PGSIZE+200，则a=PGSIZE，last=2*PGSIZE。这样一来，在下面的循环中，除了添加了刚刚申请的那页的映射以外，我们还多添加了新的一页，其物理地址为mem+PGSIZE。</p>
<p>这十分地危险！假设你要申请的va为proc-&gt;size的最后一页，那么，经过本次缺页中断之后，你事实上申请了两页，两页的地址分别为va和va+PGSIZE。而va+PGSIZE大于proc-&gt;size。也就是说，地址溢出了！</p>
<p>这会导致<strong>页表释放</strong>的时候出问题。以下是页表释放的路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">    uvmunmap(pagetable, <span class="number">0</span>, PGROUNDUP(sz)/PGSIZE, <span class="number">1</span>);</span><br><span class="line">  freewalk(pagetable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap walk: %p\n&quot;</span>,a);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap: %p\n&quot;</span>,a);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap OK: %p\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freewalk要求在uvmunmap中已经释放完所有的叶子结点。而由于uvmunmap中释放结点的va是从0递增到proc-&gt;size的，也因而，前面的那个大于proc-&gt;size的那页虽然还在页表中存在，但是不会被uvmunmap释放！这也就导致，接下来调用freewalk的时候，会发现该页的叶子结点仍然存在，从而导致<code>freewalk: leaf</code>。</p>
<p>可以结合uvmunmap和trap.c中的调试语句看下图的过程，可以看到非常清晰明了，0x14000这一页并没有在uvmunmap中释放！</p>
<p>trap.c中的调试语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap: %p,+PGSIZE = %p\n&quot;</span>,PGROUNDDOWN(va),PGROUNDDOWN(va)+PGSIZE);</span><br><span class="line">   <span class="keyword">if</span>(mappages(p-&gt;pagetable,va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">     kfree(mem);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>图：</p>
<img src="/2023/01/10/xv6/image-20230116165910356.png" class>

<h5 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h5><p>看到<code>freewalk: leaf</code>这一错误，很容易联想到跟页表的释放有关。并且加上PGGROUNDDOWN就没问题，不加上才有问题，也很容易联想到跟mappages中多申请的那一页有关。但是具体是什么关系，这一点想要想到对我来说还是非常曲折的。</p>
<p>我一开始，以为是因为多申请的那一页（下面简称为B页好了）很有可能是其他进程在使用的，然后其他进程在echo进程释放页表前释放了页表，从而导致B页已经free了，这样一来<code>uvmunmap</code>说不定就能监测到对应物理页已经free，然后爆出panic。我一开始认为<code>uvmunmap</code>的这句话是用来监测物理页是否free的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">   <span class="comment">//panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>然后顺理成章地，这边条件==0成立，然后continue，然后直到freewalk才发现该pte未释放。</p>
<p>但是，我仔细过脑子想了想，发现，就算物理页已经free了，但是，*pte依然存在，PTE_V也依然为1，这个条件是不成立的。也就是说，B页不会continue，而是会继续下面的正常释放的流程。也就是说，B页是可以正常释放的，我们的“B页已经free导致uvmunmap释放失败”的推论是错误的。</p>
<p>但究竟是为什么呢？肯定跟B页有关系，但是又不是这种关系，这让我十分地苦恼且烦躁，于是我就去打了会儿游戏。边玩的时候突然注意到一件非常可疑的事情。</p>
<img src="/2023/01/10/xv6/image-20230116154004538.png" class>

<p>这是发生错误时退出的截图。有一个点引起了我的注意，就是echo hi并没有打印hi在console上。也就是说，这个panic是在echo执行前产生的！那么这个执行前是在哪呢？答案就是在exec中！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in exec.c</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  <span class="comment">// 这里！！！！！</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure>

<p>可以看到，这里调用了<code>proc_freetable</code>，从而跟freewalk有了联系。</p>
<p>但是，如果我们还坚持是因为B页错的，就需要找到一个可能会产生B页的地方，也就是验证shell准备执行echo命令，fork出一个子进程之后，又在exec free页表前，已经调用过sbrk函数，并且已经触发过缺页中断。这个验证其实很简单，只需要找sbrk在哪被调用过，哪边使用过heap内存【也即哪边涉及了指针赋值】就行了。</p>
<p>通过全局搜索，可知sbrk在<code>user/umalloc.c</code>下的<code>malloc()</code>被使用过，而在<code>user/sh.c</code>中，fork子进程之后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">  runcmd(parsecmd(buf));</span><br></pre></td></tr></table></figure>

<p>这其中的<code>parsecmd()</code>中malloc被使用过，并且发生了指针赋值！！也就是说，“是因为B页错的”这个结论是对的。</p>
<p>虽然这一段debug没有改变我们要证明“是B页在释放内存中出错的”的这个目的，但是确实带给了我很多这种执行时申请内存的知识，并且也让我突然想起了可以用printf debug。于是，我就去做了上面那个在trap.c中和uvmunmap中printf的调试语句，最终成功发现了结论。</p>
<p>实在是太艰苦了（）这告诉我们以后千万千万要注意，是否需要用到PGGROUNDDOWN。</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><h5 id="trap-c-1"><a href="#trap-c-1" class="headerlink" title="trap.c"></a>trap.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c usertrap()</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">13</span> || scause == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="type">char</span>* mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U|PTE_V) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h5 id="vm-c-1"><a href="#vm-c-1" class="headerlink" title="vm.c"></a>vm.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/vm.c uvmunmap()</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmunmap: not mapped&quot;);</span></span><br></pre></td></tr></table></figure>

<h3 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h3><blockquote>
<p>We’ve supplied you with <code>lazytests</code>, an xv6 user program that tests some specific situations that may stress your lazy memory allocator. Modify your kernel code so that all of both <code>lazytests</code> and <code>usertests</code> pass.</p>
</blockquote>
<h4 id="感想-12"><a href="#感想-12" class="headerlink" title="感想"></a>感想</h4><h5 id="一个绷不住的错误"><a href="#一个绷不住的错误" class="headerlink" title="一个绷不住的错误"></a>一个绷不住的错误</h5><p>其实很简单，按照提示一步步做就行了。为什么我做得那么久那么崩溃呢？知道原因后我都笑嘻了。</p>
<p>在第一步修改<code>sys_sbrk()</code>的时候，我一下子没多想，使用了一句<code>int sz = myproc()-&gt;sz</code>，其实本来应该使用uint64的，使用int会溢出。这个伏笔就一直隐含到这里，然后大坑了我一笔。</p>
<p>一开始是发现<code>lazytests</code>的第二个，也就是oom过不去。我想了很久，也去网上找了别人的代码一步步对比下来看了，没有发现特别大的问题。于是我就在walk和sys_sbrk分别留下了调试信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in walk()</span></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;walk:va=%p,p-&gt;sz=%p,MAXVA=%p,pgva=%p\n&quot;</span>,va,myproc()-&gt;sz,MAXVA,PGROUNDDOWN(va));</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in sys_sbrk()</span></span><br><span class="line">  <span class="keyword">if</span>(n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    uint64 tmp = n + sz;</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; MAXVA || n + sz &lt; n)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    myproc()-&gt;sz = tmp;</span><br><span class="line">    <span class="comment">//printf(&quot;haha sb!sz=%p,n=%p\n&quot;,myproc()-&gt;sz,n);</span></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>然后发现了这样的输出：</p>
<img src="/2023/01/10/xv6/image-20230116225124363.png" class>

<p>可以看到，最后一次sz发生了数值溢出。</p>
<p>但是，此时我并没有悔改。我反而认为，“原本代码就是这么写的”。也就是说，我认为<code>int sz</code>是它原本内核代码给的。。。。。。在这样的情况下，我选择加上这样的条件判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tmp &gt; MAXVA || ((tmp &gt;&gt; <span class="number">31</span>)&amp; <span class="number">1</span>) == <span class="number">1</span>)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>之后确实没有溢出了，但是test fail了。此时我想，为什么非要用int而不用uint64呢？一阵令人不寒而栗的预感袭来，我连忙去看了<code>proc.h</code>里的sz的定义，发现，sz原本就应该是uint64类型的，是我错辣【悲】</p>
<p>只能说起到一种很好的教训。主要是这种问题实在没有想过自己会犯</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><blockquote>
<ul>
<li>Handle the parent-to-child memory copy in fork() correctly.</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in vm.c uvmcopy()</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Handle negative sbrk() arguments.</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  uint64 sz = myproc()-&gt;sz;</span><br><span class="line">  addr = sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    uint64 tmp = n + sz;</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; MAXVA || n + sz &lt; n)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    myproc()-&gt;sz = tmp;</span><br><span class="line">    <span class="comment">//printf(&quot;haha sb!sz=%p,n=%p\n&quot;,myproc()-&gt;sz,n);</span></span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n + sz &gt; <span class="number">0</span>)</span><br><span class="line">      myproc()-&gt;sz = uvmdealloc(myproc()-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//if(growproc(n) &lt; 0)</span></span><br><span class="line">  <span class="comment">//  return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</p>
</li>
<li><p>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</p>
</li>
<li><p>Handle faults on the invalid page below the user stack.</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">13</span> || scause == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= p-&gt;sz ||  va &lt; PGROUNDUP(p-&gt;trapframe-&gt;sp) ||PGROUNDDOWN(va) &gt;= MAXVA)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;va=%p stack=%p\n&quot;,va,PGROUNDUP(r_sp()));</span></span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">char</span>* mem = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(mem != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">//printf(&quot;trap: %d %p\n&quot;,p-&gt;pid,PGROUNDDOWN(va));</span></span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">          kfree(mem);</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li>
</ul>
<p>我认为这里要是引起一个缺页中断可能会更酷，可能可以像lazytests里面这么做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *i, *prev_end, *new_end;</span><br><span class="line"></span><br><span class="line">prev_end = sbrk(REGION_SZ);</span><br><span class="line">new_end = prev_end + REGION_SZ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里触发了多次缺页中断</span></span><br><span class="line"><span class="keyword">for</span> (i = prev_end + PGSIZE; i &lt; new_end; i += PGSIZE * PGSIZE)</span><br><span class="line">  *(<span class="type">char</span> **)i = i;</span><br></pre></td></tr></table></figure>

<p>之后有机会再试试233</p>
<p>【试了一下，发现是可以的。在COW fork的  <code>感想—一些错误和思考—在内核态中引发并处理缺页中断</code>  这部分内容中详细说明了具体要怎么做。】</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 缺页中断</span></span><br><span class="line">    <span class="keyword">if</span>(va &gt;= p-&gt;sz ||  va &lt; PGROUNDUP(p-&gt;trapframe-&gt;sp) ||PGROUNDDOWN(va) &gt;= MAXVA)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;va=%p stack=%p\n&quot;,va,PGROUNDUP(r_sp()));</span></span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">char</span>* mem = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(mem != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">//printf(&quot;trap: %d %p\n&quot;,p-&gt;pid,PGROUNDDOWN(va));</span></span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">          kfree(mem);</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab-Copy-on-Write-Fork-for-xv6"><a href="#Lab-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab: Copy-on-Write Fork for xv6"></a>Lab: Copy-on-Write Fork for xv6</h2><blockquote>
<p>Parent and child can safely share phyical memory using copy-on-write fork, driven by page faults. </p>
<p>RISC-V has <u>three different kinds of page fault</u>: <strong>load</strong> page faults (when a load instruction cannot translate its virtual address), <strong>store</strong> page faults (when a store instruction cannot translate its virtual address), and <strong>instruction</strong> page faults (when the address for an instruction doesn’t translate). </p>
<p>The <strong>basic plan</strong> in COW fork is for the parent and child to initially share all physical pages, but to map them <strong>read-only</strong>. Thus, when the child or parent executes a store instruction, the RISC-V CPU raises a page-fault exception. In response to this exception, the kernel makes a copy of the page that contains the faulted address. It maps one copy read/write in the child’s address space and the other copy read/write in the parent’s address space. After updating the page tables, the kernel resumes the faulting process at the instruction that caused the fault.</p>
<p>PS【这个很重要】: COW fork() makes freeing of the physical pages that implement user memory a little trickier. A given physical page may be referred to by multiple processes’ page tables, and should be freed only when the last reference disappears.</p>
</blockquote>
<h3 id="感想-13"><a href="#感想-13" class="headerlink" title="感想"></a>感想</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>思路还是很直观的。</p>
<p>我们只需要在fork的时候，标记父子进程的所有PTE都为read-only，然后之后就会遇到不同scause的缺页中断，针对特定的scause，新建物理页面，拷贝物理页面，然后重新设置映射即可。而对于其提出的需要标记某页是否能够释放，则需要统计每页的ref数，当ref==1的时候才可以释放。</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><h5 id="总分析"><a href="#总分析" class="headerlink" title="总分析"></a>总分析</h5><p>其实可以把任务简单拆分为三部分。第一部分是实现基本的cow fork的逻辑，第二部分是引用计数释放内存，第三部分是解决copyin/copyout时在内核态发生的缺页中断。我认为本实验的难点事实上在第二部分【悲】我可能有大于3/4的时间都花在第二部分上了吧。</p>
<p>第一部分是实现cow fork的基本逻辑，也就是修改fork中对页表的拷贝以及在usertrap中添加对缺页中断的处理，这很直观，没什么好说的。</p>
<p>第三部分要么跟上面的lazy allocation一样，在<code>kernel/vm.c walkaddr()</code>中把缺页中断搬过去，要么向我在<code>主要难点与错误—在内核态中引发并处理缺页中断</code>这一部分那样做。</p>
<p>我们分析这一部分主要讲的是我认为最难的地方，也就是第二部分。其实第二部分的思路也很直观：创建一个数组，index为所有能用的内存的<code>address/PGSIZE</code>，用来记录引用数；然后在每次增加引用时，对应元素++；每次减少引用时，对应元素–。</p>
<p>虽然思路很简单很直观，但是实现起来非常地非常地非常地考验细节（我就非常不擅长这一点）。下面，我就先阐述一下<strong>第二部分的这个方法</strong>需要分割为哪几部分，其他我遇到的印象较深的bug和对一些地方的思考，都放在了下一部分，也即<code>主要难点与错误</code>。</p>
<h5 id="引用数实现分析"><a href="#引用数实现分析" class="headerlink" title="引用数实现分析"></a>引用数实现分析</h5><blockquote>
<p>创建一个数组，index为所有能用的内存的<code>address/PGSIZE</code>，用来记录引用数；然后在每次增加引用时，对应元素++；每次减少引用时，对应元素–。</p>
</blockquote>
<h6 id="数组的大小和数据类型"><a href="#数组的大小和数据类型" class="headerlink" title="数组的大小和数据类型"></a>数组的大小和数据类型</h6><p>由<code>kernel/kalloc.c</code>中的<code>kinit()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="comment">// freerange用来把参数地址范围内的物理页加入freelist中</span></span><br><span class="line">  <span class="comment">// end是内核的结束地址</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，事实上，我们整个程序，包括用户和内核，能用的内存空间为0~PHYSTOP。因而，我们事实上只需要建一个<code>PHYSTOP/PGSIZE</code>这么大的数组就行。我算了一下大概是2^19次方。</p>
<p>然后，我感觉这种小系统应该不会有过多的对某一页的重复引用，因而，为了节省空间，我将数据类型定为了char。最好还是别定成uchar，因为这东西要是0–的话会溢出变为255，很可怕。</p>
<h6 id="什么时候增减引用"><a href="#什么时候增减引用" class="headerlink" title="什么时候增减引用"></a>什么时候增减引用</h6><blockquote>
<p>我认为这里是非常考验细节和头脑清晰度的，也就是我卡了很久最后也没弄出来的部分【悲】</p>
</blockquote>
<p>可以分为三种情况来讲。我们的引用计数必须完美适应这三种情况：</p>
<ol>
<li><p>不经由页表，通过kalloc和kfree直接使用物理页</p>
<p>这就要求我们在kalloc的时候置引用数为1，然后kfree的时候对引用数先-1，再判断是否归零。</p>
</li>
<li><p>经由页表，但与cow fork无关</p>
<p>增加页表项：mappages-&gt;kalloc，因而满足要求1即可。</p>
<p>删除页表项：uvmunmap。当do_free==1时，满足要求1即可。</p>
</li>
<li><p>经由页表，与cow fork有关</p>
<p>copy父进程页表时：在cowcopy中，每增加一次子进程的映射，就需要增加一次引用数</p>
<p>在用户态/内核态发生缺页中断：发生缺页中断后，对原来物理页的引用数需要-1【我就是漏了这一点……】</p>
<p>删除页表项：uvmunmap。当do_free==0时，当对应页表项有COW标记，则减少引用数</p>
</li>
</ol>
<p>所以，我们需要在三个文件进行修改：</p>
<ol>
<li><p>kalloc.c</p>
<p>增加数组定义，在kalloc和kfree中增加引用数修改</p>
</li>
<li><p>vm.c</p>
<p>在cowcopy和uvmunmap中增加引用数修改</p>
</li>
<li><p>trap.c</p>
<p>在usertrap的缺页中断中增加引用计数修改</p>
</li>
</ol>
<h6 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h6><blockquote>
<p>这里我也没想到【悲】</p>
</blockquote>
<p>由于我们的pages数组会在多个文件、多个进程间使用，所以它必须在被锁保护的区域中被使用。</p>
<h4 id="主要难点与错误"><a href="#主要难点与错误" class="headerlink" title="主要难点与错误"></a>主要难点与错误</h4><h5 id="scause-2"><a href="#scause-2" class="headerlink" title="scause=2"></a>scause=2</h5><img src="/2023/01/10/xv6/image-20230117161404719.png" class>

<p>这个发生在我还没有实现第二部分的时候。搜索了一下，scause=2为<code>Illegal instruction</code>，而且sepc的这个1004的值也非常诡异。这应该是因为fork子进程释放了指令段内存，导致主进程执行错误</p>
<h5 id="kernel无法启动"><a href="#kernel无法启动" class="headerlink" title="kernel无法启动"></a>kernel无法启动</h5><p>在kinit中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;pages_lock,<span class="string">&quot;pages&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(pages, <span class="number">0</span>, (<span class="number">2</span>&lt;&lt;<span class="number">19</span>));</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会通过freerange初始化freelist。在freerange中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会对每一项进行一次kfree。因而，我们需要在kfree前先增加一次引用，要不然会寄。</p>
<h5 id="在缺页中断时减少对物理页的引用数"><a href="#在缺页中断时减少对物理页的引用数" class="headerlink" title="在缺页中断时减少对物理页的引用数"></a>在缺页中断时减少对物理页的引用数</h5><img src="/2023/01/10/xv6/image-20230117213903706.png" class>

<p>注意此处不能直接让pages[pa/PGSIZE]–，一定要借助kfree。当此进程为引用pa的最后一个进程的时候，如果仅减少引用数，就会造成内存泄漏。kfree可以既减少引用数，又在适当的时候对物理页释放，可谓一举两得。kfree的这个双重作用思想也在uvmunmap中体现了。</p>
<h5 id="在内核态中引发并处理缺页中断"><a href="#在内核态中引发并处理缺页中断" class="headerlink" title="在内核态中引发并处理缺页中断"></a>在内核态中引发并处理缺页中断</h5><blockquote>
<p>Modify copyout() to use the same scheme as page faults when it encounters a COW page.</p>
</blockquote>
<p>我们所做的第一第二部分仅仅是完成了对来自用户态的缺页中断的完美处理，还尚未处理来自内核态的缺页中断。因而，这个修改copyin和copyout的点实际上就是要我们处理内核态的缺页中断。</p>
<p>这次实验跟上次的lazy allocation一样，都可以直接在walkaddr进行特殊处理，并且差不多要把usertrap的全部代码挪过来【具体见lazy allocation的代码】，我认为这样做非常不优雅。于是，我选择直接引发一个缺页中断，然后处理这个中断，就像usertrap一样。</p>
<p>但由于在<code>walkaddr</code>中发生的中断处于内核状态下，所以就进不了usertrap。我们应该在kerneltrap中再次添加和usertrap一样的中断处理。我们会像这样引发一个中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">    *(<span class="type">char</span>*)va = <span class="number">1</span>;<span class="comment">// 此处不能用pa哦</span></span><br></pre></td></tr></table></figure>

<p>然后在kerneltrap中这样处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 只要写入引起的缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line">    uint flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sepc += <span class="number">4</span>;</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">            memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">            <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">            *pte = PA2PTE(mem);</span><br><span class="line">            kfree((<span class="type">void</span>*)pa);</span><br><span class="line">            <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">            flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">            *pte = ((*pte) | flags);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br></pre></td></tr></table></figure>

<p>但是，这样做是不行的。</p>
<blockquote>
<p>会在这里卡住，会无限次不断进入kerneltrap。</p>
<img src="/2023/01/10/xv6/image-20230117235028133.png" class>
</blockquote>
<p>造成这个的原因，经过一番曲折的debug之后，我发现，只要像usertrap中的syscall分支一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重点是这里</span></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>加上这句话就行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sepc += <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>所以，结果就非常显而易见了，是因为一直卡在这句话执行不下去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">char</span>*)va = <span class="number">1</span>;<span class="comment">// 此处不能用pa哦</span></span><br></pre></td></tr></table></figure>

<p>而为什么会卡在这呢？答案是我也不明白，调了很久还是不知道问题在哪。我注意到了很奇怪的一点放在块引用里了。</p>
<blockquote>
<p>经过调试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %p %p\n&quot;</span>,pages[pa/PGSIZE],pa,mem);</span><br></pre></td></tr></table></figure>

<img src="/2023/01/10/xv6/image-20230118003118745.png" class>
</blockquote>
<p>除了这一点外，还有一点很重要的是，由于<code>walkaddr</code>是需要返回一个pa的，因而我们需要手动再把pa在缺页中断后更新一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pa = PTE2PA(*pte);</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">    *(<span class="type">char</span>*)va = <span class="number">1</span>;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pa;</span><br></pre></td></tr></table></figure>

<p>总之，做了这<strong>两个</strong>关键步骤后，也能启动了，也能过cowtest了。所以下面的代码也就贴上了这里的版本。</p>
<h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>本次实验耗时经典五小时（包含笔记时间就是六个半小时了hhh），算是平均水平。很遗憾也很难受的一点是，我的错误最终还是没有自己想出来，而是参考了别人的代码才改对的。思路很简单，但是细节也依然非常多非常坑，还是得再加把劲。</p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><p>我们只需要在fork的时候，标记父子进程的所有PTE都为read-only，然后之后就会遇到不同scause的缺页中断，针对特定的scause，新建物理页面，拷贝物理页面，然后重新设置映射即可。而对于其提出的需要标记某页是否能够释放，则需要统计每页的ref数，当ref==1的时候才可以释放。</p>
<h4 id="定义COW标记"><a href="#定义COW标记" class="headerlink" title="定义COW标记"></a>定义COW标记</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) </span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 5)</span></span><br></pre></td></tr></table></figure>

<h4 id="引用数组初始化"><a href="#引用数组初始化" class="headerlink" title="引用数组初始化"></a>引用数组初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/kalloc.c</span></span><br><span class="line"><span class="type">char</span> pages[(<span class="number">2</span>&lt;&lt;<span class="number">19</span>)];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">pages_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;pages_lock,<span class="string">&quot;pages&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(pages, <span class="number">0</span>, (<span class="number">2</span>&lt;&lt;<span class="number">19</span>));</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    pages[(uint64)p/PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="申请和释放页时增删引用"><a href="#申请和释放页时增删引用" class="headerlink" title="申请和释放页时增删引用"></a>申请和释放页时增删引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    acquire(&amp;pages_lock);</span><br><span class="line">    <span class="comment">// 在这</span></span><br><span class="line">    pages[(uint64)r/PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;pages_lock);</span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP || pages[(uint64)pa/PGSIZE] &lt;= <span class="number">0</span> )</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  <span class="comment">// 每次kfree都会减少引用</span></span><br><span class="line">  pages[(uint64)pa/PGSIZE]--;</span><br><span class="line">  <span class="comment">// 说明此时页面还被其他东西引用着，不能释放</span></span><br><span class="line">  <span class="keyword">if</span>(pages[((uint64)pa)/PGSIZE] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pages_lock);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改fork时对页表的复制操作，并标记引用数增加"><a href="#修改fork时对页表的复制操作，并标记引用数增加" class="headerlink" title="修改fork时对页表的复制操作，并标记引用数增加"></a>修改fork时对页表的复制操作，并标记引用数增加</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/proc.c fork()</span></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(cowcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// in kernel/vm.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cowcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;cowcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;cowcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// 去除flag中的PTE_W，并且给父子的都安上没有PTE_W的flag</span></span><br><span class="line">    flags = (flags &amp; (~PTE_W));</span><br><span class="line">    flags = (flags | PTE_COW);</span><br><span class="line">    *pte = ((*pte) &amp; (~PTE_W));</span><br><span class="line">    *pte = ((*pte) | PTE_COW);</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记物理页的引用数增加</span></span><br><span class="line">    acquire(&amp;pages_lock);</span><br><span class="line">    pages[pa/PGSIZE]++;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> err:</span><br><span class="line">  <span class="comment">// 失败了不能释放物理内存</span></span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理缺页中断，标记引用数减少"><a href="#处理缺页中断，标记引用数减少" class="headerlink" title="处理缺页中断，标记引用数减少"></a>处理缺页中断，标记引用数减少</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  <span class="comment">// 只要求写入引起的缺页中断</span></span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">      flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span>* mem;</span><br><span class="line">      <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">          memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">          <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">          *pte = PA2PTE(mem);</span><br><span class="line">          <span class="comment">// 减少引用，引用归零时释放</span></span><br><span class="line">          kfree((<span class="type">void</span>*)pa);</span><br><span class="line">          <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">          flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">          *pte = ((*pte) | flags);</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uvmunmap时减少引用数"><a href="#uvmunmap时减少引用数" class="headerlink" title="uvmunmap时减少引用数"></a>uvmunmap时减少引用数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint64 pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      acquire(&amp;pages_lock);</span><br><span class="line">      <span class="keyword">if</span>(((*pte) &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">          pages[pa/PGSIZE]--;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;pages_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改walkaddr"><a href="#修改walkaddr" class="headerlink" title="修改walkaddr"></a>修改walkaddr</h4><h5 id="在walkaddr中触发缺页中断"><a href="#在walkaddr中触发缺页中断" class="headerlink" title="在walkaddr中触发缺页中断"></a>在walkaddr中触发缺页中断</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="comment">// 在这里</span></span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 触发缺页中断</span></span><br><span class="line">      *(<span class="type">char</span>*)va = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 更新pa值</span></span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在kerneltrap内补上对缺页中断的处理"><a href="#在kerneltrap内补上对缺页中断的处理" class="headerlink" title="在kerneltrap内补上对缺页中断的处理"></a>在kerneltrap内补上对缺页中断的处理</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 只要写入引起的缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line">    uint flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注意，这个很重要！！！！！</span></span><br><span class="line">        sepc += <span class="number">4</span>;</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line">                                 </span><br><span class="line">        <span class="type">char</span>* mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">            memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">            <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">            *pte = PA2PTE(mem);</span><br><span class="line">            kfree((<span class="type">void</span>*)pa);</span><br><span class="line">            <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">            flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">            *pte = ((*pte) | flags);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Interrupts-and-device-drivers"><a href="#Interrupts-and-device-drivers" class="headerlink" title="Interrupts and device drivers"></a>Interrupts and device drivers</h1><blockquote>
<p>A <em>driver</em> is the code in an operating system that manages a particular device: </p>
<ol>
<li><strong>configures</strong> the device hardware</li>
<li>tells the device to perform <strong>operations</strong></li>
<li>handles the resulting <strong>interrupts</strong></li>
<li><strong>interacts</strong> with <strong>processes</strong> that may be waiting for I/O from the device</li>
</ol>
<p>Driver code can be tricky because a driver executes <strong>concurrently</strong> with the device that it manages. </p>
<p>In addition, the driver must understand the device’s <strong>hardware interface</strong>, which can be complex and poorly documented.</p>
</blockquote>
<p>如果devices需要让操作系统对某些事情做出响应，就要采取中断的方法。在<code>kerneltrap</code>中，内核响应中断，并且根据设备类型来决定中断处理函数。</p>
<blockquote>
<img src="/2023/01/10/xv6/image-20230115160523827.png" class>

<p>这段对设备中断的概述总结得非常到位</p>
<p>也就是说，一个device driver可以分为两部分实现，一部分是接收请求，然后开启read/write；另一部分是接收中断，这个中断有可能是设备完成IO，也可能是设备需要IO，它会通知设备具体怎么做，它也会唤醒恰当的进程。</p>
</blockquote>
<h2 id="Code-Console-input"><a href="#Code-Console-input" class="headerlink" title="Code: Console input"></a>Code: Console input</h2><p>console driver是driver structure的一个实现案例。</p>
<h3 id="上层逻辑"><a href="#上层逻辑" class="headerlink" title="上层逻辑"></a>上层逻辑</h3><p>shell获取用户输入console的信息是通过系统调用<code>read()</code>实现的。read通过文件描述符，最终转向<code>consoleread()</code>来实现具体的逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file.c fileread()</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);<span class="comment">// 在这里转向console</span></span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">// in console.c consoleinit()</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, <span class="string">&quot;cons&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uartinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里完成devsw的初始化</span></span><br><span class="line">  <span class="comment">// connect read and write system calls</span></span><br><span class="line">  <span class="comment">// to consoleread and consolewrite.</span></span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对console的读写事实上是对cons结构体里buf的读写。这个buf则是由底层逻辑管理的。<code>consoleread()</code>每次读取buf中的一行，当未读满一行且无字符输入时会阻塞，直到底层逻辑将字符放入buf。读满了一行后，<code>consoleread</code>将该行copy进用户空间，随后返回<code>read</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/console.c </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_BUF_SIZE 128</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> buf[INPUT_BUF_SIZE];</span><br><span class="line">  uint r;  <span class="comment">// Read index</span></span><br><span class="line">  uint w;  <span class="comment">// Write index</span></span><br><span class="line">  uint e;  <span class="comment">// Edit index</span></span><br><span class="line">&#125; cons;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user read()s from the console go here.</span></span><br><span class="line"><span class="comment">// copy (up to) a whole input line to dst.</span></span><br><span class="line"><span class="comment">// user_dist indicates whether dst is a user</span></span><br><span class="line"><span class="comment">// or kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint target;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">  target = n;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// wait until interrupt handler has put some</span></span><br><span class="line">    <span class="comment">// input into cons.buffer.</span></span><br><span class="line">    <span class="comment">// read和write的index一样，说明此时没有数据输入，阻塞</span></span><br><span class="line">    <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">      <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">        release(&amp;cons.lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 产生数据输入，接收数据</span></span><br><span class="line">    c = cons.buf[cons.r++ % INPUT_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == C(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file</span></span><br><span class="line">      <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">        <span class="comment">// Save ^D for next time, to make sure</span></span><br><span class="line">        <span class="comment">// caller gets a 0-byte result.</span></span><br><span class="line">        <span class="comment">// 这样下一次也能访问到eof</span></span><br><span class="line">        cons.r--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line">    cbuf = c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    dst++;</span><br><span class="line">    --n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">      <span class="comment">// the user-level read().</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="底层逻辑"><a href="#底层逻辑" class="headerlink" title="底层逻辑"></a>底层逻辑</h3><p>底层逻辑维护了与上层逻辑交互的buf。</p>
<p>console接收数据对buf的读，是通过中断来实现的。</p>
<p>当用户输入字符，UART硬件检测到读，会向操作系统发送中断。中断在<code>kerneltrap()</code>中被接收处理，然后通过<code>devintr()</code>对该中断分门别类地进行转发。console的转发路径为devintr-&gt;uartintr-&gt;consoleintr。</p>
<h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4><p> UART的全称是Universal Asynchronous Receiver and Transmitter，即异步发送和接收。它的软件上的表示形式是<em>a set of memory-mapped control registers</em>。CPU通过物理地址与这些寄存器交互，也即它们跟RAM是同一个地址空间。在xv6中，UART的地址空间从<code>UART0</code>(0x1000 0000)开始。这些寄存器地址关于<code>UART0</code>的偏移量定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the UART control registers.</span></span><br><span class="line"><span class="comment">// some have different meanings for read vs write.</span></span><br><span class="line"><span class="comment">// see http://byterunner.com/16550.html</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RHR 0                 <span class="comment">// 接收寄存器receive holding register (for input bytes)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THR 0                 <span class="comment">// 发送寄存器transmit holding register (for output bytes)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER 1                 <span class="comment">// 开关中断寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_RX_ENABLE (1&lt;&lt;0)  <span class="comment">// 如果该位被设置，则在接收寄存器有数据，即想向外界发送数据时，UART会搓出一个中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_TX_ENABLE (1&lt;&lt;1)  <span class="comment">// 如果该位被设置，则在发送寄存器有数据，即外界向硬件发送数据时，UART会搓出一个中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR 2                 <span class="comment">// FIFO control register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_ENABLE (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_CLEAR (3&lt;&lt;1) <span class="comment">// clear the content of the two FIFOs</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR 3                 <span class="comment">// line control register</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5                 <span class="comment">// line status register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="comment">// input is waiting to be read from RHR</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="comment">// THR can accept another character to send</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<img src="/2023/01/10/xv6/image-20230115170107044.png" class>

<p>例如，LSR寄存器包含指示输入字符是否正在等待软件读取的位。这些字符（如果有的话）可用于从RHR寄存器读取。每次读取一个字符，UART硬件都会从等待字符的内部FIFO寄存器中删除它，并在FIFO为空时清除LSR中的“就绪”位。UART传输硬件在很大程度上独立于接收硬件；如果软件向THR写入一个字节，则UART传输该字节。</p>
</blockquote>
<h4 id="kerneltrap-1"><a href="#kerneltrap-1" class="headerlink" title="kerneltrap"></a>kerneltrap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kerneltrap()</span></span><br><span class="line">  <span class="comment">// 在此处的devintr对不同的设备进行不同的处理方式</span></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="devintr"><a href="#devintr" class="headerlink" title="devintr"></a>devintr</h4><p>devintr处在<code>trap.c</code>中，作用是对中断归类，然后分门别类地转发到下一层级的handler。</p>
<blockquote>
<p>注：</p>
<ol>
<li><p>外中断和内中断</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Cheatscat/article/details/77869600">外部中断和内部中断详解</a></p>
<p>根据中断源的不同，可以把中断分为硬件中断和软件中断两大类，而硬件中断又可以分为外部中断和内部中断两类。</p>
<p>外部中断一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可以屏蔽的中断，也就是说，利用中断控制器<strong>可以屏蔽</strong>这些外部设备的中断请求。</p>
<p>内部中断是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断是<strong>不可屏蔽</strong>的中断。</p>
<p> 软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序。例如：ROM BIOS中的各种外部设备管理中断服务程序（键盘管理中断、显示器管理中断、打印机管理 中断等，）以及DOS的系统功能调用（INT 21H）等都是软件中断。【比如说系统调用之类的】</p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt,</span></span><br><span class="line"><span class="comment">// and handle it.</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt,</span></span><br><span class="line"><span class="comment">// 1 if other device,</span></span><br><span class="line"><span class="comment">// 0 if not recognized.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取scause，辨析中断类型</span></span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果来自外中断（在这里应该只指device interrupt）</span></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// irq indicates which device interrupted.</span></span><br><span class="line">    <span class="comment">// 通过PLIC硬件获取中断设备信息</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别转发</span></span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断处理完成了，可以再次开启中断</span></span><br><span class="line">    <span class="comment">// the PLIC allows each device to raise at most one</span></span><br><span class="line">    <span class="comment">// interrupt at a time; tell the PLIC the device is</span></span><br><span class="line">    <span class="comment">// now allowed to interrupt again.</span></span><br><span class="line">    <span class="keyword">if</span>(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 来自时钟中断</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uartintr"><a href="#uartintr" class="headerlink" title="uartintr"></a>uartintr</h4><p>这代码其实乍一看是看不懂的，这是因为uartintr不止负责读中断。它还负责另一个中断（发送区空余中断），下面会细说。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle a uart interrupt, raised because input has</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or</span></span><br><span class="line"><span class="comment">// both. called from devintr().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="comment">// return -1 if none is waiting,说明读完了</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 每读入一个字符就转交给console</span></span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters.</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="consoleintr"><a href="#consoleintr" class="headerlink" title="consoleintr"></a>consoleintr</h4><p>向buf中放入字符c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;P&#x27;</span>)</span>:  <span class="comment">// Print process list.</span></span><br><span class="line">      <span class="comment">// ...一堆特殊情况处理...</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="title function_">if</span><span class="params">(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)</span>&#123;</span><br><span class="line">          c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// echo back to the user.</span></span><br><span class="line">          consputc(c);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">          cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;</span><br><span class="line">            <span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line">            <span class="comment">// has arrived.</span></span><br><span class="line">            <span class="comment">// 中断处理并不会做很多事情，只是会与缓冲区交互</span></span><br><span class="line">            <span class="comment">// 涉及到复杂的事情，比如说将数据拷贝到用户空间</span></span><br><span class="line">            <span class="comment">//就唤醒上层逻辑来做</span></span><br><span class="line">            cons.w = cons.e;</span><br><span class="line">            wakeup(&amp;cons.r);</span><br><span class="line">          &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Console-output"><a href="#Code-Console-output" class="headerlink" title="Code: Console output"></a>Code: Console output</h2><p>外部通过write这个系统调用来对console写。</p>
<h3 id="uartputc"><a href="#uartputc" class="headerlink" title="uartputc"></a>uartputc</h3><p>最先到达这里。</p>
<p>uart内置了一个缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> uart_tx_buf[UART_TX_BUF_SIZE];</span><br></pre></td></tr></table></figure>

<p>用户仅需通过uartputc对buf进行写入即可，具体的buf数据向UART转移由uartputc通过调用uartstart实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a character to the output buffer and tell the</span></span><br><span class="line"><span class="comment">// UART to start sending if it isn&#x27;t already.</span></span><br><span class="line"><span class="comment">// blocks if the output buffer is full.缓冲区满则阻塞</span></span><br><span class="line"><span class="comment">// because it may block, it can&#x27;t be called</span></span><br><span class="line"><span class="comment">// from interrupts; it&#x27;s only suitable for use</span></span><br><span class="line"><span class="comment">// by write().这段话很有意思，说它由于会阻塞所以最好别在中断的时候用。</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 阻塞</span></span><br><span class="line">  <span class="keyword">while</span>(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE)&#123;</span><br><span class="line">    <span class="comment">// buffer is full.</span></span><br><span class="line">    <span class="comment">// wait for uartstart() to open up space in the buffer.</span></span><br><span class="line">    sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;</span><br><span class="line">  uart_tx_w += <span class="number">1</span>;</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uartstart"><a href="#uartstart" class="headerlink" title="uartstart"></a>uartstart</h3><p>uartstart的作用是从缓冲区取数据向UART硬件发送。不阻塞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if the UART is idle, and a character is waiting</span></span><br><span class="line"><span class="comment">// in the transmit buffer, send it.</span></span><br><span class="line"><span class="comment">// caller must hold uart_tx_lock.</span></span><br><span class="line"><span class="comment">// called from both the top- and bottom-half.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartstart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the UART transmit holding register is full,</span></span><br><span class="line">      <span class="comment">// so we cannot give it another byte.</span></span><br><span class="line">      <span class="comment">// it will interrupt when it&#x27;s ready for a new byte.</span></span><br><span class="line">      <span class="comment">// 当缓冲区满没有选择阻塞，而是先结束</span></span><br><span class="line">      <span class="comment">// 当UART硬件准备好继续接收的时候，UART会发送transmit complete中断，到时候会再继续从buf读取</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个字符一个字符写</span></span><br><span class="line">    <span class="type">int</span> c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];</span><br><span class="line">    uart_tx_r += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maybe uartputc() is waiting for space in the buffer.</span></span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    </span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当传输过程非常流畅，UART硬件没有阻塞时，以上的代码就能完美阐述发送的过程。但是当UART硬件的transmit阻塞时，过程就会有许多改动。</p>
<h3 id="transmit-complete-interrupt"><a href="#transmit-complete-interrupt" class="headerlink" title="transmit complete interrupt"></a>transmit complete interrupt</h3><p>在<code>uartstart</code>中，当UART硬件的transmit满，<code>uartstart</code>就直接return了。</p>
<p>当UART硬件的transmit空，就会发送transmit complete中断。中断在kerneltrap被接收，经过devintr转发，最终来到了uartintr：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle a uart interrupt, raised because input has</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or</span></span><br><span class="line"><span class="comment">// both. called from devintr().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters.</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，第一个while循环会直接退出，因为压根没有get到字符。所以，这时候，就会去执行uartstart，然后继续读未完成读取的缓冲区。</p>
<p>等到所有都读完了，最后一次发送transmit complete中断时，会在uartstart进入该分支：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">  <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就不会再发送transmit中断了。</p>
<p>感觉这点是真的牛逼。uartintr这个函数完美兼顾了两种情况【这也归功于uartstart做得很健壮】：1. 外部输入数据到console，2. 接收数据未结束，继续接收</p>
<h2 id="Concurrency-in-drivers"><a href="#Concurrency-in-drivers" class="headerlink" title="Concurrency in drivers"></a>Concurrency in drivers</h2><p>用户进程与设备之间的读写交流，比如说上面的console，重点依靠于<code>uart_tx_buf</code>和<code>cons.buf</code>这两个的正确性。因而，就需要保障它们的并发安全。在上面的代码中，使用到这两个的地方都被锁保护着。</p>
<p>在kernel中还需要格外注意的一点并发是，一个进程A在等待来自设备的中断，但此时另一个进程B在运行。这时候设备发出中断信号，CPU转入中断处理程序处理中断。此时，中断处理程序的执行不应该涉及到当前被中断进程的代码。例如，中断处理程序不能安全地使用当前进程的页表调用<code>copyout</code>（页表正是跟当前进程息息相关的）。中断处理程序通常做相对较少的工作（例如，只需将输入数据复制到缓冲区），并唤醒上半部分代码来完成其余工作。</p>
<h2 id="Timer-interrupts"><a href="#Timer-interrupts" class="headerlink" title="Timer interrupts"></a>Timer interrupts</h2><blockquote>
<p>Xv6 uses timer interrupts to maintain its clock and to enable it to switch among compute-bound processes; the <strong>yield</strong> calls in usertrap and kerneltrap cause this switching.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c usertrap()</span></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c kerneltrap()</span></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RISC-V requires that timer interrupts be taken in machine mode, not supervisor mode. As a result, xv6 handles timer interrupts completely separately from the trap mechanism laid out above.</p>
</blockquote>
<p>xv6启动时调用过<code>start.c</code>。<code>start.c</code>处于机器态，并准备向内核态过渡。<code>start.c</code>中就对时钟进行了初始化<code>timeinit()</code>。要做的有以下几件事：</p>
<ol>
<li>program the <strong>CLINT</strong> hardware (core-local interruptor) to generate an interrupt after a certain delay. </li>
<li>set up a <strong>scratch</strong> area  to help the timer interrupt handler save registers and the address of the CLINT registers</li>
<li>start sets mtvec to timervec and <strong>enables</strong> timer interrupts.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrange to receive timer interrupts.</span></span><br><span class="line"><span class="comment">// they will arrive in machine mode at</span></span><br><span class="line"><span class="comment">// at timervec in kernelvec.S,</span></span><br><span class="line"><span class="comment">// which turns them into software interrupts for</span></span><br><span class="line"><span class="comment">// devintr() in trap.c.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">timerinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// each CPU has a separate source of timer interrupts.</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask the CLINT for a timer interrupt.</span></span><br><span class="line">  <span class="type">int</span> interval = <span class="number">1000000</span>; <span class="comment">// cycles; about 1/10th second in qemu.</span></span><br><span class="line">  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare information in scratch[] for timervec.</span></span><br><span class="line">  <span class="comment">// scratch[0..2] : space for timervec to save registers.</span></span><br><span class="line">  <span class="comment">// scratch[3] : address of CLINT MTIMECMP register.</span></span><br><span class="line">  <span class="comment">// scratch[4] : desired interval (in cycles) between timer interrupts.</span></span><br><span class="line">  uint64 *scratch = &amp;timer_scratch[id][<span class="number">0</span>];</span><br><span class="line">  scratch[<span class="number">3</span>] = CLINT_MTIMECMP(id);</span><br><span class="line">  scratch[<span class="number">4</span>] = interval;</span><br><span class="line">  w_mscratch((uint64)scratch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the machine-mode trap handler.</span></span><br><span class="line">  w_mtvec((uint64)timervec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode interrupts.</span></span><br><span class="line">  w_mstatus(r_mstatus() | MSTATUS_MIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode timer interrupts.</span></span><br><span class="line">  w_mie(r_mie() | MIE_MTIE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>计时器中断处理程序必须保证不干扰中断的内核代码。基本策略是处理程序要求RISC-V发出“软件中断”并立即返回。RISC-V用普通陷阱机制将软件中断传递给内核，并允许内核禁用它们。处理由定时器中断产生的软件中断的代码可以在<code>devintr</code> (<strong>kernel/trap.c</strong>:204)中看到：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c devintr()</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">    <span class="comment">// forwarded by timervec in kernelvec.S.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只看其中一个CPU的时钟中断计数的意思吗？确实，要是好几个一起来加倍了非常不合理</span></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>w_sip(r_sip() &amp; ~2);</code>就对应着“RISC-V用普通陷阱机制将软件中断传递给内核”。【应该吧个人理解】</p>
<blockquote>
<p>来源：<a target="_blank" rel="noopener" href="https://www.bookstack.cn/books/rCore_tutorial_doc">rCore 手册（rCore tutorial doc）</a></p>
<p><strong>riscv 中的中断寄存器</strong></p>
<p>S 态的中断寄存器主要有 <strong>sie</strong>（Supervisor Interrupt Enable，监管中断使能）, <strong>sip</strong> （Supervisor Interrupt Pending，监管中断待处理）两个，其中 s 表示 S 态，i 表示中断， e/p 表示 enable (使能)/ pending (提交申请)。 处理的中断分为三种：</p>
<ol>
<li>SI(Software Interrupt)，软件中断</li>
<li>TI(Timer Interrupt)，时钟中断</li>
<li>EI(External Interrupt)，外部中断</li>
</ol>
<p>比如 <code>sie</code> 有一个 <code>STIE</code> 位， 对应 <code>sip</code> 有一个 <code>STIP</code> 位，与时钟中断 TI 有关。当硬件决定触发时钟中断时，会将 <code>STIP</code> 设置为 1，当一条指令执行完毕后，如果发现 <code>STIP</code> 为 1，此时如果时钟中断使能，即 <code>sie</code> 的 <code>STIE</code> 位也为 1 ，就会进入 S 态时钟中断的处理程序。</p>
<p>可能SSIP跟这里的STIP差不多吧，都是时钟中断的标志。如果把SSIP clear掉，那么则说明不是时钟中断了，而是软中断了。</p>
</blockquote>
<h2 id="Real-world-2"><a href="#Real-world-2" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>UART驱动程序读取UART控制寄存器，一次检索一字节的数据；因为软件驱动数据移动，这种模式被称为程序I/O（<strong>Programmed I/O</strong>）。程序I/O很简单，但速度太慢，无法在高数据速率下使用。需要高速移动大量数据的设备通常使用直接内存访问（<strong>DMA</strong>）。DMA设备硬件直接将传入数据写入内存，并从内存中读取传出数据。现代磁盘和网络设备使用DMA。DMA设备的驱动程序将在RAM中准备数据，然后使用对控制寄存器的单次写入来告诉设备处理准备好的数据。</p>
<p>当一个设备在不可预知的时间需要注意时，中断是有意义的，而且不是太频繁。但是中断有很高的CPU开销。因此，如网络和磁盘控制器的高速设备，使用一些技巧减少中断需求。一个技巧是对整批传入或传出的请求发出单个中断。另一个技巧是驱动程序完全禁用中断，并定期检查设备是否需要注意。这种技术被称为轮询（<strong>polling</strong>）。如果设备执行操作非常快，轮询是有意义的，但是如果设备大部分空闲，轮询会浪费CPU时间。一些驱动程序根据当前设备负载在轮询和中断之间动态切换。</p>
<p>UART驱动程序首先将传入的数据复制到内核中的缓冲区，然后复制到用户空间。这在低数据速率下是可行的，但是这种双重复制会显著降低快速生成或消耗数据的设备的性能。一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常带有DMA。</p>
</blockquote>
<h2 id="Lab-networking"><a href="#Lab-networking" class="headerlink" title="Lab: networking"></a>Lab: networking</h2><blockquote>
<p>In this lab you will write an xv6 device driver for a network interface card (NIC).</p>
<p>这个概述光是听起来就让人觉得热血沸腾。网络的本质其实就是IO设备，这一点我一直觉得很牛逼，而现在我居然要亲手实现网络……That’s very cool.</p>
</blockquote>
<blockquote>
<p>On this emulated LAN, xv6 (the “guest”) has an IP address of 10.0.2.15. </p>
<p>Qemu also arranges for the computer running qemu to appear on the LAN with IP address 10.0.2.2. </p>
<p>When xv6 uses the E1000 to send a packet to 10.0.2.2, qemu delivers the packet to the appropriate application on the (real) computer on which you’re running qemu (the “host”).</p>
</blockquote>
<blockquote>
<p>We’ve added some files to the xv6 repository for this lab. </p>
<p>The file <code>kernel/e1000.c</code> contains <strong>initialization</strong> code for the E1000 as well as empty functions for transmitting and receiving packets, which <strong>you’ll fill in</strong>. </p>
<p><code>kernel/e1000_dev.h</code> contains definitions for registers and flag bits defined by the E1000 and described in the Intel E1000 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">Software Developer’s Manual</a>. </p>
<p><code>kernel/net.c</code> and <code>kernel/net.h</code> contain a simple network stack that implements the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Protocol">IP</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>, and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP</a> protocols. </p>
<p>These files also contain code for a flexible data structure to hold packets, called an <code>mbuf</code>. </p>
<p>Finally, <code>kernel/pci.c</code> contains code that searches for an E1000 card on the PCI bus when xv6 boots.</p>
</blockquote>
<blockquote>
<p>Your job：</p>
<p>Your job is to complete <code>e1000_transmit()</code> and <code>e1000_recv()</code>, both in <code>kernel/e1000.c</code>, so that the driver can transmit and receive packets. You are done when <code>make grade</code> says your solution passes all the tests. </p>
</blockquote>
<h3 id="感想-14"><a href="#感想-14" class="headerlink" title="感想"></a>感想</h3><p>说实话，一开始看题的时候真是感觉非常地哈人……但其实文档看着看着，心中也逐渐有了个大概，最后再结合下指导书的提示【当然不是后面那些保姆级的Hints】，最后写的也就八九不离十了。总体上来说，我觉得这次实验的代码还是很简单的，它主要难在<strong>探究过程</strong>，也就是从一开始什么也不懂，然后去阅读硬件设备的文档，结合代码尝试去理解，最后一步步写出来的过程。本次实验耗时六小时，我觉得肯定有不少于一半，甚至可能达到2/3的时间都耗费在理解上。这种从零开始探究的过程给了我很大的收获，同时也稍微提高了我面对挫折的能力。</p>
<p>这个实验确实设计得很有教育意义。除了我上面说的它锻炼了我的能力以外，它其实还具有比较深刻的<strong>工业意义</strong>。在看书的时候，书中这么写道：</p>
<blockquote>
<p>In addition, the driver must understand the device’s <strong>hardware interface</strong>, which can be complex and poorly documented.</p>
</blockquote>
<p>本次实验正是上述描述的简化版：E1000的文档很详细，并且我们只用掌握一部分它的功能就行了。但虽然简化了，其探究过程的内在逻辑还是不会改变的。</p>
<p>总之，我很喜欢这次实验的设计。我的评价是牛逼。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="正确思路-1"><a href="#正确思路-1" class="headerlink" title="正确思路"></a>正确思路</h4><p>Hints写得很详细，不做赘述了。主要就是明确一下数据结构的问题：</p>
<ol>
<li><p>rx_ring和tx_ring是两个分开的队列</p>
<p>它们只是结构一模一样，都是阴影部分表示software持有，白色部分表示硬件持有。</p>
<p>因而，对于rx来说，白色部分表示需要传给协议栈的包，因而我们需要把白色部分转化为阴影部分；对于tx来说，白色部分表示网卡将要发送的包，因而我们需要把阴影部分转化为白色部分。</p>
<img src="/2023/01/10/xv6/image-20230220234406239.png" class></li>
<li><p>rx_mbufs和tx_mbufs</p>
<p>一开始不知道这俩是啥，后来才意识到，这俩和第1点的那俩其实是下标一一对应的关系。也就是说rx_ring[i]这个descriptor接收到的数据存在rx_mbufs[i]，tx_ring[i]要发送的数据存在tx_mbufs[i]。知道了这个之后，代码就简单了。</p>
<blockquote>
<p>忏悔：我一开始真没反应过来。计网我记得是有一模一样的结构的，看来算是白做了2333</p>
</blockquote>
</li>
</ol>
<h4 id="个人的推理过程"><a href="#个人的推理过程" class="headerlink" title="个人的推理过程"></a>个人的推理过程</h4><p>一开始就先懵懵懂懂地看指导书，直到看到这句话：</p>
<blockquote>
<p>Browse the E1000 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">Software Developer’s Manual</a>. </p>
</blockquote>
<p>然后我这时连自己要干什么都迷迷糊糊，但姑且还是按他下面说的，准备先浏览第二章了。然而，我发现要我看我也还是看不懂啊，所以我就直接放弃了。【<strong>经验1：看不懂就算了，别死磕了</strong>】</p>
<p>我放弃了第二章后，就再次从头开始细细看了一遍这句话之前的指导书，也结合了一下它给的代码。这次总算是差不多弄懂这次要做什么了：</p>
<p>实现<strong>driver</strong>的两个函数，从而实现对网卡进行数据的取出和送入。数据是eth frame。数据取出后要通过<code>net_rx</code>传递给上层协议栈。数据是<code>mbuf</code>类型的。</p>
<p>所以我们只需实现协议栈最底下的部分，也即从网卡读写数据，其他一些别的东西比如协议栈什么的都已经写好了。</p>
<p>但是那些什么<code>rx_ring</code>，还有各种奇奇怪怪的寄存器，我都看不懂，所以我就去看第三章了。初次略过一遍感觉还是一脸懵逼不知道干什么，但我带着“我们要做的是driver”这样的想法，在第二遍细看的时候有意区分开什么是网卡硬件帮我们做的，什么是我们的driver软件需要做的（<strong>经验2：明确要做什么。我们需要做的是软件部分，它的文档一般会说Software should XXX，密切关注这部分就行</strong>），就差不多有了点实现的雏形：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> recv:</span><br><span class="line">  <span class="comment">// 通过net_rx，网络包可以发送到udp顶层.</span></span><br><span class="line">  <span class="comment">// 所以说，我们在这里的目的就是，通过与硬件网卡e1000进行交互，</span></span><br><span class="line">  <span class="comment">// 取出e1000所接收到的数据包，检查数据的完整性，然后再把数据封装进mbuf结构体中，再通过net_rx传到上层</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出数据包</span></span><br><span class="line">  <span class="comment">// 数据包存储在网卡的缓冲区中</span></span><br><span class="line">  <span class="comment">// 一是获取网卡缓冲区长度的长度</span></span><br><span class="line">  <span class="comment">// 网卡缓冲区长度存储在RCTL.BSIZE &amp; RCTL.BSEX中</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *RCTL.BSEX = 0b:</span></span><br><span class="line"><span class="comment">00b = 2048 Bytes.</span></span><br><span class="line"><span class="comment">01b = 1024 Bytes.</span></span><br><span class="line"><span class="comment">10b = 512 Bytes.</span></span><br><span class="line"><span class="comment">1b1 = 256 Bytes.</span></span><br><span class="line"><span class="comment">RCTL.BSEX = 1b:</span></span><br><span class="line"><span class="comment">00b = Reserved; software should not program this value.</span></span><br><span class="line"><span class="comment">01b = 16384 Bytes.</span></span><br><span class="line"><span class="comment">10b = 8192 Bytes.</span></span><br><span class="line"><span class="comment">11b = 4096 Bytes</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="comment">// 二是获取数据包存放在哪个地址</span></span><br><span class="line">  <span class="comment">// 数据包的buffer cache的地址存储在descriptor的字段中</span></span><br><span class="line">  <span class="comment">// 必须读取多个descriptor以确定跨越多个接收缓冲区的数据包的完整长度。</span></span><br><span class="line">  <span class="comment">// 那么我们要读取的这些descriptor存放在哪呢？</span></span><br><span class="line">  <span class="comment">// 看文档，似乎差不多意思是这些descriptor被以环形队列的形式组织在一起，也许正是</span></span><br><span class="line">  <span class="comment">// 本文件内的rx_ring这个数组。</span></span><br><span class="line">  <span class="comment">// 当有descriptor到达e1000，e1000就会把它从host memory中取出来，存入到descriptor ring</span></span><br><span class="line">  <span class="comment">// 也即我们rx_ring数组</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 所以我们要做的，就是遍历rx_ring数组，如果rx_ring数组中的元素是used的，那么表明它就是数据包的一部分</span></span><br><span class="line">  <span class="comment">// 也即它地址所指向的buf里存放的是数据包的一部分数据</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// 那么我们怎么知道这个rx_ring的元素有没有used，以及它是第几个呢?</span></span><br><span class="line">  <span class="comment">// 检查descriptor有没有used：status字段不为全0则为used</span></span><br><span class="line">  <span class="comment">// 并且硬件要求，我们在发现这个descriptor的status不为0，并且用完这个descriptor之后，需要将</span></span><br><span class="line">  <span class="comment">// 其status字段置零，以供硬件使用</span></span><br><span class="line">  <span class="comment">// Status information indicates whether the descriptor has been used and whether the referenced </span></span><br><span class="line">  <span class="comment">// buffer is the last one for the packet.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 三是获取数据包的数据</span></span><br><span class="line">  <span class="comment">// 我们需要获取decriptor的该字段，然后再从这个地址读取数据包数据</span></span><br><span class="line">  <span class="comment">// 网卡和内存统一编址，这个数据实际上就是网卡的buffer</span></span><br><span class="line">  <span class="comment">// 我们应该直接通过read这个系统调用就可以对其进行读写了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// check数据包</span></span><br><span class="line">  <span class="comment">// 检查RDESC.ERRORS位，如果包发生了错误，再检查，如果发现RCTL.SBP、RCTL.UPE/MPE都被标记，</span></span><br><span class="line">  <span class="comment">// 就接收这个包，否则直接丢弃</span></span><br></pre></td></tr></table></figure>

<p>可以看到，跟正确思路虽然很多细节理解上有点问题，但是大体框架还是大差不差。然后再阅读指导书：</p>
<blockquote>
<p>When the E1000 receives each packet from the ethernet, <strong>it first DMAs the packet to the mbuf pointed to by the next RX (receive) ring descriptor, and then generates an interrupt</strong>. 【这句话可得知，<code>descriptor</code>们存放在代码中的<code>rx_ring</code>中。】</p>
<p>Your <code>e1000_recv()</code> code must <strong>scan</strong> the RX ring and <strong>deliver each</strong> new packet’s mbuf to the network stack (in <code>net.c</code>) by calling <code>net_rx()</code>. You will then need to <strong>allocate</strong> a new mbuf and place it into the descriptor, so that when the E1000 reaches that point in the RX ring again it finds a fresh buffer into which to DMA a new packet.</p>
</blockquote>
<p>就差不多是正确思路了。<code>transmit</code>的实现也是同理</p>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><blockquote>
<p>以下代码不知道为什么过不了test，我跟别人的逻辑一模一样也还是不行emmm</p>
<p>它的问题是，不会接收到外界的返ping，导致进程一直等待网卡IO，所以kerneltrap一直触发不了，无法正常网卡读写，从而导致<code>fileread</code>会一直处于sleep等待状态，整个系统就沉睡了【】我感觉应该是<code>transmit</code>没发成功。</p>
<p>等以后有精力再来看看吧。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> <span class="title">tx</span> =</span> tx_ring[regs[E1000_TDT]];</span><br><span class="line">  <span class="keyword">if</span>((tx.status &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(tx_mbufs[regs[E1000_TDT]] != <span class="number">0</span>)    mbuffree(tx_mbufs[regs[E1000_TDT]]);</span><br><span class="line">  tx.addr = (uint64) m-&gt;head;</span><br><span class="line">  tx.length = m-&gt;len;</span><br><span class="line">  tx.status |= <span class="number">1</span>;<span class="comment">// EOP</span></span><br><span class="line">  tx.cmd |= <span class="number">1</span>;<span class="comment">//EOP</span></span><br><span class="line">  tx.cmd |= <span class="number">8</span>;<span class="comment">//RS</span></span><br><span class="line">  tx_mbufs[regs[E1000_TDT]] = m;</span><br><span class="line">  regs[E1000_TDT] = (regs[E1000_TDT]+<span class="number">1</span>)%TX_RING_SIZE;</span><br><span class="line">  <span class="comment">// printf(&quot;send successful!\n&quot;);</span></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;go into e1000_recv\n&quot;</span>);</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//while(regs[E1000_RDT]!=regs[E1000_RDH])&#123;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;go into while\n&quot;</span>);</span><br><span class="line">    regs[E1000_RDT] = (regs[E1000_RDT] + <span class="number">1</span>)%RX_RING_SIZE;</span><br><span class="line">    <span class="type">int</span> i=regs[E1000_RDT];</span><br><span class="line">    <span class="keyword">if</span>(rx_ring[i].status != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 包含所需数据包</span></span><br><span class="line">      <span class="comment">// 检查是否发生了错误</span></span><br><span class="line">      <span class="comment">//if((rx_ring[i].status &amp; 1) !=0 &amp;&amp; (rx_ring[i].status &amp; 2) != 0)&#123;</span></span><br><span class="line">  <span class="comment">//      // error字段有效</span></span><br><span class="line">  <span class="comment">//    if(rx_ring[i].errors != 0)&#123;</span></span><br><span class="line">          <span class="comment">// 发生错误，直接丢弃</span></span><br><span class="line">  <span class="comment">//      goto end;</span></span><br><span class="line">  <span class="comment">//    &#125;</span></span><br><span class="line">      <span class="keyword">if</span>((rx_ring[i].status &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">      release(&amp;e1000_lock);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将地址对应数据包发送</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>* <span class="title">m</span> =</span> rx_mbufs[i];</span><br><span class="line">      m-&gt;len = rx_ring[i].length;</span><br><span class="line">      net_rx(m);</span><br><span class="line">    rx_ring[i].status = <span class="number">0</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>* <span class="title">mbuf</span> =</span> mbufalloc(MBUF_DEFAULT_HEADROOM);</span><br><span class="line">      rx_ring[i].addr = (uint64) mbuf-&gt;head;</span><br><span class="line">      rx_mbufs[i] = mbuf;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h1><p>很多概念在看Java并发的时候都学习过，这些重复的地方就不做赘述了。</p>
<h2 id="Code-spinlock"><a href="#Code-spinlock" class="headerlink" title="Code: spinlock"></a>Code: spinlock</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenwh_cn/article/details/117227454">spinlock 使用介绍</a></p>
<p>一、spinlock 简介<br>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，不断尝试获取锁，直到获取到锁才会退出循环</p>
<p>二、自旋锁与互斥锁的区别<br>自旋锁与互斥锁类似，它们都是为了解决对某项资源的互斥使用，在任何时刻最多只能有一个线程获得锁<br>对于互斥锁，如果资源已经被占用，调用者将进入睡眠状态<br>对于自旋锁，如果资源已经被占用，调用者就一直循环在那里，看是否自旋锁的保持者已经释放了锁</p>
<p>三、自旋锁的优缺点<br>自旋锁不会发生进程切换，不会使进程进入阻塞状态，减少了不必要的上下文切换，执行速度快。非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换，影响性能<br>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程长时间循环等待消耗CPU，造成CPU使用率极高</p>
</blockquote>
<h3 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>大概是这么个原理：</p>
<img src="/2023/01/10/xv6/image-20230115231857670.png" class>

<p>当然这有竞态条件。xv6用的是CPU提供的amoswap原子指令来消除竞态条件的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/spinlock.c</span></span><br><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 关中断</span></span><br><span class="line">  <span class="comment">// xv6允许禁止中断。但是由于xv6是一个多核系统,单个core被禁止中断并不会影响其他core。</span></span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// holding(): Check whether this cpu is holding the lock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="comment">// amoswap: 交换a5和(s1)的值，返回(s1)原来的值</span></span><br><span class="line">  <span class="comment">// 也即是如图所示的竞态条件的原子指令</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sync-synchronize"><a href="#sync-synchronize" class="headerlink" title="__sync_synchronize();"></a>__sync_synchronize();</h4><p>代码里的官方注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line"><span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line"><span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line"><span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br></pre></td></tr></table></figure>

<p>这个注释其实没太看明白。我去翻了一下asm代码，发现这句话正如它最后一句所说的被翻译成fence指令：</p>
<img src="/2023/01/10/xv6/image-20230115231457971.png" class>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/139797515">处理器中的存储系统（一）：RISC-V的FENCE、FENCE.I指令</a></p>
<p>顾名思义,FENCE指令犹如一道屏障,把前面的存储操作和后面的存储操作隔离开来,前面的决不能到后面再执行,后面的决不能先于FENCE前的指令执行。</p>
</blockquote>
<p>这个就好明白多了。</p>
<p>这样一来，acquire和release的两个fence就形成了两道屏障：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">acquire();</span><br><span class="line">l-&gt;nexy = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">release();</span><br></pre></td></tr></table></figure>

<p>中间那部分的指令可以重排，但是中间的指令就绝不会跑到临界区外。</p>
<h4 id="push-off和pop-off"><a href="#push-off和pop-off" class="headerlink" title="push_off和pop_off"></a>push_off和pop_off</h4><blockquote>
<p>当CPU未持有自旋锁时，xv6重新启用中断；它必须做一些记录来处理嵌套的临界区域。<code>acquire</code>调用<code>push_off</code> (*<strong>kernel/spinlock.c*</strong>:89) 并且<code>release</code>调用<code>pop_off</code> (*<strong>kernel/spinlock.c*</strong>:100)来跟踪当前CPU上锁的嵌套级别。当计数达到零时，<code>pop_off</code>恢复最外层临界区域开始时存在的中断使能状态。<code>intr_off</code>和<code>intr_on</code>函数执行RISC-V指令分别用来禁用和启用中断。</p>
</blockquote>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/spinlock.c</span></span><br><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开中断</span></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Using-locks"><a href="#Code-Using-locks" class="headerlink" title="Code: Using locks"></a>Code: Using locks</h2><blockquote>
<p>作为粗粒度锁的一个例子，xv6的<strong>kalloc.c</strong>有一个由单个锁保护的空闲列表。如果不同CPU上的多个进程试图同时分配页面，每个进程在获得锁之前将必须在<code>acquire</code>中自旋等待。自旋会降低性能，因为它只是无用的等待。如果对锁的争夺浪费了很大一部分CPU时间，也许可以通过改变内存分配的设计来提高性能，使其拥有<strong>多个空闲列表</strong>，每个列表都有自己的锁，以允许真正的并行分配。【很棒的思路】</p>
<p>作为细粒度锁的一个例子，xv6<u>对每个文件都有一个单独的锁</u>，这样操作不同文件的进程通常可以不需等待彼此的锁而继续进行。文件锁的粒度可以进一步细化，以允许进程同时写入同一个文件的不同区域。最终的锁粒度决策需要由性能测试和复杂性考量来驱动。</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>锁</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>bcache.lock</code></td>
<td>保护块缓冲区缓存项（block buffer cache entries）的分配</td>
</tr>
<tr>
<td><code>cons.lock</code></td>
<td>串行化对控制台硬件的访问，避免混合输出</td>
</tr>
<tr>
<td><code>ftable.lock</code></td>
<td>串行化文件表中文件结构体的分配</td>
</tr>
<tr>
<td><code>icache.lock</code></td>
<td>保护索引结点缓存项（inode cache entries）的分配</td>
</tr>
<tr>
<td><code>vdisk_lock</code></td>
<td>串行化对磁盘硬件和DMA描述符队列的访问</td>
</tr>
<tr>
<td><code>kmem.lock</code></td>
<td>串行化内存分配</td>
</tr>
<tr>
<td><code>log.lock</code></td>
<td>串行化事务日志操作</td>
</tr>
<tr>
<td>管道的<code>pi-&gt;lock</code></td>
<td>串行化每个管道的操作</td>
</tr>
<tr>
<td><code>pid_lock</code></td>
<td>串行化next_pid的增量</td>
</tr>
<tr>
<td>进程的<code>p-&gt;lock</code></td>
<td>串行化进程状态的改变</td>
</tr>
<tr>
<td><code>tickslock</code></td>
<td>串行化时钟计数操作</td>
</tr>
<tr>
<td>索引结点的 <code>ip-&gt;lock</code></td>
<td>串行化索引结点及其内容的操作</td>
</tr>
<tr>
<td>缓冲区的<code>b-&gt;lock</code></td>
<td>串行化每个块缓冲区的操作</td>
</tr>
</tbody></table>
<p> Figure 6.3: Locks in xv6</p>
<h2 id="Deadlock-and-lock-ordering"><a href="#Deadlock-and-lock-ordering" class="headerlink" title="Deadlock and lock ordering"></a>Deadlock and lock ordering</h2><blockquote>
<p>如果在内核中执行的代码路径必须同时持有数个锁，那么所有代码路径以相同的顺序获取这些锁是很重要的。如果它们不这样做，就有死锁的风险。假设xv6中的两个代码路径需要锁A和B，但是代码路径1按照先A后B的顺序获取锁，另一个路径按照先B后A的顺序获取锁。为了避免这种死锁，<strong>所有代码路径必须以相同的顺序获取锁</strong>。全局锁获取顺序的需求意味着锁实际上是每个<strong>函数规范</strong>的一部分：调用者必须以一种使锁按照约定顺序被获取的方式调用函数。</p>
<p>由于<code>sleep</code>的工作方式（见第7章），Xv6有许多包含每个进程的锁（每个<code>struct proc</code>中的锁）在内的长度为2的锁顺序链。例如，<code>consoleintr</code> (*<strong>kernel/console.c*</strong>:138)是处理键入字符的中断例程。当换行符到达时，任何等待控制台输入的进程都应该被唤醒。为此，<code>consoleintr</code>在调用<code>wakeup</code>时持有<code>cons.lock</code>，<code>wakeup</code>获取等待进程的锁以唤醒它。因此，全局避免死锁的锁顺序包括必须在任何进程锁之前获取<code>cons.lock</code>的规则。【这段不怎么能看懂，学完第七章再回来看看】</p>
<p>文件系统代码包含xv6最长的锁链。例如，创建一个文件需要同时持有目录上的锁、新文件inode上的锁、磁盘块缓冲区上的锁、磁盘驱动程序的<code>vdisk_lock</code>和调用进程的<code>p-&gt;lock</code>。为了避免死锁，文件系统代码总是按照前一句中提到的顺序获取锁。</p>
</blockquote>
<h2 id="Locks-and-interrupt-handlers"><a href="#Locks-and-interrupt-handlers" class="headerlink" title="Locks and interrupt handlers"></a>Locks and interrupt handlers</h2><blockquote>
<p> Xv6 is more conservative: when a CPU acquires any lock, xv6 always <strong>disables interrupts</strong> on that CPU. Interrupts may still occur on other CPUs, so an interrupt’s acquire can wait for a thread to release a spinlock; just not on the same CPU.看来是通过开关中断来保护临界区的</p>
<p><code>acquire</code>调用<code>push_off</code> (*<strong>kernel/spinlock.c*</strong>:89) 并且<code>release</code>调用<code>pop_off</code> (*<strong>kernel/spinlock.c*</strong>:100)来跟踪当前CPU上锁的嵌套级别。当计数达到零时，<code>pop_off</code>恢复最外层临界区域开始时存在的中断使能状态。<code>intr_off</code>和<code>intr_on</code>函数执行RISC-V指令分别用来禁用和启用中断。</p>
<p>严格的在设置<code>lk-&gt;locked</code> (<em>kernel/spinlock.c</em>:28)之前让<code>acquire</code>调用<code>push_off</code>是很重要的。如果两者颠倒，会存在一个既持有锁又启用了中断的短暂窗口期，不幸的话定时器中断会使系统死锁。同样，只有在释放锁之后，<code>release</code>才调用<code>pop_off</code>也是很重要的(*<strong>kernel/spinlock.c*</strong>:66)。</p>
</blockquote>
<h3 id="一个解决了一半的疑问"><a href="#一个解决了一半的疑问" class="headerlink" title="一个解决了一半的疑问"></a>一个解决了一半的疑问</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>Xv6更保守：当CPU获取任何锁时，xv6总是禁用该CPU上的中断。中断仍然可能发生在其他CPU上，此时中断的<code>acquire</code>可以等待线程释放自旋锁；由于不在同一CPU上，不会造成死锁。</p>
<p>进展：似乎书中说到，“sleep atomically yields the CPU and releases the spinlock”。等了解完sleep，也即读完第七章之后再来看看。</p>
</blockquote>
<p>在处理时钟中断的trap.c中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c devintr()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 这里！！</span></span><br><span class="line">    <span class="comment">// in kernel/trap.c devintr()</span></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见只有CPU0才会进入clockintr【因为要求cpuid==0】，锁住ticks引起ticks递增。</p>
<p>而当sys_sleep获得锁之后，其结束循环的条件是ticks - ticks0 &lt; n:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我认为，这会导致死锁情况。假设计算机为多CPU，且从零开始依次递增编号。对该死锁情况的讨论，可以分为以下两类：</p>
<ol>
<li><p>sys_sleep在CPU2（或者其他编号非零的CPU）运行，且先获取了tickslock的锁。这时候，ticks将会停止增长，sys_sleep结束循环的条件将无法结束。</p>
<p>理由：对于CPU0，它可以进入clockintr的代码段，但是由于锁已经被获取，所以就只能一直在那边死锁等待；对于其他CPU来说，压根执行不了那段增加ticks的代码段，所以ticks压根不会增加。这样一来，CPU2进程等待ticks增加，从而获取结束循环的条件；CPU0等待CPU2进程结束，从而使得ticks增加，就造成了死锁。</p>
</li>
<li><p>sys_sleep在CPU0运行，且先获取了tickslock的锁。这时候，ticks将会停止增长，sys_sleep结束循环的条件将无法结束。</p>
<p>理由：由于xv6会在获取锁和释放锁期间关闭中断，因而CPU0无法进行时钟中断而发生进程的切换，只能一直在sys_sleep中等待，所以ticks更不可能增加，造成了死锁。</p>
</li>
</ol>
<p>暂时没有很充分的理由反驳这两点。。。</p>
<h4 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h4><p>学习完下一章的内容后可知，<code>sleep(&amp;ticks, &amp;tickslock);</code>会释放掉tickslock的锁，这样CPU0就可以进入<code>clockintr</code>增加ticks了。</p>
<p>再详细梳理一次，这里的具体机制是这样的：</p>
<p>可以把ticks看做信号量，<code>sys_sleep</code>为消费者，<code>clockintr</code>为生产者。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in sys_sleep()</span></span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  <span class="keyword">while</span>(ticks &lt; 某个数字)&#123;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这是非常典型的生产者消费者模型。生产者每生产一次ticks，就会唤醒消费者，让消费者检查条件。如果条件错误，则继续sleep等待消费者下一次唤醒，如此循环往复。</p>
<p>只不过，还有一个小疑点，就是<code>clockintr</code>这段只有CPU0可以执行这一点是否为真依然存疑。如果确实只有CPU0可以执行的话，假若<code>sys_sleep</code>在CPU0上执行，那么还是依然会造成死锁。所以我猜想是不是CPU0是无法关中断的？也就是说CPU0是一个后盾一般的保护角色？或者是别的CPU也能进入本段代码？如果别的CPU也能进，那是怎么实现的？因为很明显这段代码确实只有CPU0可以进入。</p>
<h2 id="Sleep-locks"><a href="#Sleep-locks" class="headerlink" title="Sleep locks"></a>Sleep locks</h2><p>关于sleep lock的由来和优点，书里描述得很详细，简单来说就是：</p>
<blockquote>
<p>Thus we’d like a type of lock that yields the CPU while waiting to acquire, and allows yields (and interrupts) while the lock is held.</p>
<p>因为等待会浪费CPU时间，所以自旋锁最适合短的临界区域；睡眠锁对于冗长的操作效果很好。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="comment">// 等待</span></span><br><span class="line">  <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">    <span class="comment">// sleep atomically yields the CPU and releases the spinlock</span></span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 占用</span></span><br><span class="line">  lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">  lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 到时候可以留意一下wakeup是会唤醒一个还是多个</span></span><br><span class="line">  wakeup(lk);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点值得注意：</p>
<blockquote>
<p>Because sleep-locks leave interrupts enabled, they cannot be used in interrupt handlers. Because acquiresleep may yield the CPU, sleep-locks cannot be used inside spinlock critical sections (though spinlocks can be used inside sleep-lock critical sections).</p>
</blockquote>
<p>这实际上是因为自旋锁内不能sleep，因而也就不能使用sleep lock。</p>
<p>为什么不能sleep？我猜测应该是因为sleep中会释放自旋锁然后再调度别的进程。此时，临界区就不受保护了很危险，不符合spinlock在临界区结束才能释放的规范。</p>
<p>在查阅别人的说法的时候，我还看到了这个讨论：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44175439/article/details/119963732">中断中为什么不能sleep | Linux内核</a>的评论区</p>
<p>在中断服务程序中，无法sleep的原因应该是sleep后，调度程序将CPU窃走，由于调度的基本单位是线程（中断服务程序不是线程），因此中断服务程序无法再被调度回来，即中断程序中sleep后的部分永远无法得到执行。</p>
</blockquote>
<h2 id="Real-world-3"><a href="#Real-world-3" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>大多数操作系统都支持POSIX线程（Pthread），它允许一个用户进程在不同的CPU上同时运行几个线程。Pthread支持用户级锁（user-level locks）、障碍（barriers）等。支持Pthread需要操作系统的支持。例如，如果一个Pthread在系统调用中阻塞，同一进程的另一个Pthread应当能够在该CPU上运行。另一个例子是，如果一个线程改变了其进程的地址空间（例如，映射或取消映射内存），内核必须安排运行同一进程下的线程的其他CPU更新其硬件页表，以反映地址空间的变化。</p>
</blockquote>
<h2 id="Lab-locks"><a href="#Lab-locks" class="headerlink" title="Lab: locks"></a>Lab: locks</h2><blockquote>
<p>In this lab you’ll gain experience in re-designing code to increase parallelism. You’ll do this for the xv6 <strong>memory allocator</strong> and <strong>block cache</strong>.</p>
</blockquote>
<h3 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h3><blockquote>
<p>The program <code>user/kalloctest</code> stresses xv6’s memory allocator: three processes grow and shrink their address spaces, resulting in many calls to <code>kalloc</code> and <code>kfree</code>. <code>kalloc</code> and <code>kfree</code> obtain <code>kmem.lock</code>. kalloctest prints (as “#fetch-and-add”) the number of loop iterations in <code>acquire</code> due to attempts to acquire a lock that another core already holds, for the <code>kmem</code> lock and a few other locks. The number of loop iterations in <code>acquire</code> is a rough measure of lock contention. </p>
<p>To remove lock contention, you will have to redesign the memory allocator to avoid a single lock and list. 也就是说要把kalloc中的整个列表上锁，修改为每个CPU有自己的列表The basic idea is to maintain a free list per CPU, each list with its own lock. Allocations and frees on different CPUs can run in parallel, because each CPU will operate on a different list. The main challenge will be to deal with the case in which one CPU’s free list is empty, but another CPU’s list has free memory; in that case, the one CPU must “steal” part of the other CPU’s free list. Stealing may introduce lock contention, but that will hopefully be infrequent.主要挑战将是处理一个 CPU 的空闲列表为空，但另一个 CPU 的列表有空闲内存的情况； 在这种情况下，一个 CPU 必须“窃取”另一个 CPU 的空闲列表的一部分。</p>
<p>Your job is to implement per-CPU freelists, and stealing when a CPU’s free list is empty. </p>
<p>You must give all of your locks names that start with “kmem”. That is, you should call <code>initlock</code> for each of your locks, and pass a name that starts with “kmem”. </p>
<p>Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run <code>usertests sbrkmuch</code>. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ.</p>
</blockquote>
<h4 id="感想-15"><a href="#感想-15" class="headerlink" title="感想"></a>感想</h4><p>总之，意思就是kalloc里面本来是多核CPU共用一个空闲页list，现在要做的就是给每一核的CPU独立分配一个空闲页list。我觉得可以分为如下几步来做：</p>
<ol>
<li><p>定义list数组以及对应的锁</p>
<p>cpu的数量是一定的；cpuid可以用来作为数组下标索引</p>
</li>
<li><p>在init时初始化锁，在freelist的时候把空闲页均分给CPU</p>
</li>
<li><p>当kalloc和kfree的时候，获取当前cpuid上锁</p>
</li>
<li><p>当一个CPU的内存不够的时候，去向另一个CPU窃取。窃取之前，首先应该获取另一个CPU的锁。</p>
</li>
</ol>
<p>以上是初见思路。正确思路确实跟上面的一样，编码过程也比较简单，没有很恶心的细节和奇奇怪怪的bug，没什么好说的。</p>
<p>第二步中，hints是推荐把所有空闲页都分给CPU0。</p>
<p>第四步的时候我是一次窃取一页。我看到一个一次窃取多页的做法，我觉得很有想法，在这里附上链接：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/524460096">MIT6.S081 lab8 locks</a></p>
</blockquote>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">kmem_locks</span>[<span class="title">NCPU</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelists</span>[<span class="title">NCPU</span>];</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p>由于kinit仅会由一个cpu执行一次【详情见main.c】，故而我这里在kinit的做法是由一个CPU初始化所有CPU，而没有选择去修改main.c从而使每个CPU都执行一次kinit。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++)&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="number">6</span>,<span class="string">&quot;kmem%d&quot;</span>,i);</span><br><span class="line">    initlock(&amp;kmem.kmem_locks[i], buf);</span><br><span class="line">  &#125;</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多带一个参数表示cpuid，仅在kinit的freerange中使用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree_init</span><span class="params">(<span class="type">void</span> *pa,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  r-&gt;next = kmem.freelists[i];</span><br><span class="line">  kmem.freelists[i] = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 把空闲内存页均分给每个CPU</span></span><br><span class="line">  uint64 sz = ((uint64)pa_end - (uint64)pa_start)/NCPU;</span><br><span class="line">  uint64 tmp = PGROUNDDOWN(sz) + (uint64)p;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)tmp; p += PGSIZE)</span><br><span class="line">      kfree_init(p,i);</span><br><span class="line">    tmp += PGROUNDDOWN(sz);</span><br><span class="line">    <span class="keyword">if</span>(i == NCPU<span class="number">-2</span>)&#123;</span><br><span class="line">      tmp = (uint64)pa_end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a>kfree</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">  <span class="comment">// 在这</span></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  r-&gt;next = kmem.freelists[id];</span><br><span class="line">  kmem.freelists[id] = r;</span><br><span class="line">  release(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="kalloc"><a href="#kalloc" class="headerlink" title="kalloc"></a>kalloc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  r = kmem.freelists[id];</span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    kmem.freelists[id] = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果无空闲页，则窃取</span></span><br><span class="line">  <span class="keyword">if</span>(!r)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=NCPU<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      acquire(&amp;kmem.kmem_locks[i]);</span><br><span class="line">      r = kmem.freelists[i];</span><br><span class="line">      <span class="keyword">if</span>(r)&#123;</span><br><span class="line">        kmem.freelists[i] = r-&gt;next;</span><br><span class="line">        release(&amp;kmem.kmem_locks[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;kmem.kmem_locks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h3><p>buffer cache的结构其实跟kalloc的内存分配结构有一定的类似之处，都是采用链表管理，但是buffer cache的实现相较于kalloc更为复杂。</p>
<blockquote>
<p>Reducing contention in the block cache is more tricky than for kalloc, because bcache buffers are truly shared among processes (and thus CPUs). </p>
<p>For kalloc, one could eliminate most contention by giving each CPU its own allocator; that won’t work for the block cache. </p>
<p>We suggest you look up block numbers in the cache with a hash table that has a lock per hash bucket.</p>
</blockquote>
<h4 id="感想-16"><a href="#感想-16" class="headerlink" title="感想"></a>感想</h4><h5 id="初见思路-1"><a href="#初见思路-1" class="headerlink" title="初见思路"></a>初见思路</h5><p>我想我们可以这么实现：</p>
<p>首先有一个双向链表，接收着所有空闲无设备分配的buf。然后再有多个双向链表桶，以设备号为索引值。</p>
<p>设备号数量，也即hash table的大小定义在<code>kernel/param.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEV         10 </span></span><br></pre></td></tr></table></figure>

<p>在<code>bget</code>中，第一个循环仅需在设备链表中查找即可，第二个循环需要先看设备链表是否有空闲的对象，如果没有，则去接收所有空闲无设备分配的那个双向链表中窃取一个对象。</p>
<p>在<code>brelse</code>中，则把要释放的buf对象添加在head中即可。</p>
<p>因而，我们要做以下几件事：</p>
<ol>
<li><p>修改bcache的定义</p>
<p>添加数量为设备号的head数组，以及对应的锁</p>
</li>
<li><p>初始化bcache</p>
</li>
<li><p>添加工具函数：将一个buf加入一个双向链表；从一个双向链表中得到一个buf</p>
</li>
<li><p>写<code>bget</code>和<code>brelse</code></p>
</li>
</ol>
<p>看起来确实好像可以实现的样子，但是这个问题在于，这么做就直接破坏了LRU的这个规则。所以还是不能这么写的。但总之先把我的代码放上来。</p>
<p>以下代码是不能正常运行的。比如说在执行<code>ls</code>命令时，会发生如下错误：</p>
<img src="/2023/01/10/xv6/image-20230122163938601.png" class>

<p>会打印出一些乱七八糟的东西，并且这些东西似乎是固定的，每次都会发生，看来应该不是多进程的问题，而是代码有哪里出现逻辑错误了。不过注意到会产生“stopforking”、“bigarg-ok”，这两个似乎是在usertest中的两个文件名，很奇怪。</p>
<p>很遗憾我暂时没有精力debug了。姑且先把错误代码放在这里吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">dev_heads</span>[<span class="title">NDEV</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">dev_locks</span>[<span class="title">NDEV</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NDEV;i++)&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="number">9</span>,<span class="string">&quot;bcache%02d&quot;</span>,i);</span><br><span class="line">    initlock(&amp;(bcache.dev_locks[i]), buf);</span><br><span class="line">    bcache.dev_heads[i].prev = &amp;(bcache.dev_heads[i]);</span><br><span class="line">    bcache.dev_heads[i].next = &amp;(bcache.dev_heads[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始时，每一个桶内都有一个buf结点</span></span><br><span class="line">  b = bcache.buf;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NDEV;i++)&#123;</span><br><span class="line">    b-&gt;next = bcache.dev_heads[i].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.dev_heads[i];</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.dev_heads[i].next-&gt;prev = b;</span><br><span class="line">    bcache.dev_heads[i].next = b;</span><br><span class="line">    b++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uint dev = b-&gt;dev;</span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;(bcache.dev_locks[dev]));</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line"></span><br><span class="line">    acquire(&amp;bcache.lock);</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">    release(&amp;bcache.lock);</span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">    release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;(bcache.dev_locks[dev]));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.dev_heads[dev].next; b != &amp;(bcache.dev_heads[dev]); b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在head中找</span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.head.prev; b != &amp;(bcache.head); b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="正确思路-2"><a href="#正确思路-2" class="headerlink" title="正确思路"></a>正确思路</h5><p>首先，大家似乎都是用<code>blockno</code>来hash的，这点就跟我的原始思路不一样了（。其实也很对，因为每个设备的使用频率是不平均的，用<code>blockno</code>来hash比用<code>dev</code>来hash其实会让访问次数更加平均。</p>
<p>然后就是怎么保证LRU依然OK。hints的做法是使用时间戳。我们可以在<code>brelse</code>的时候记录时间戳字段，在<code>bget</code>缺块的时候遍历hash table，找出对应timestamp最小的block即可。</p>
<p>历经了几小时的debug，代码最终正确。正确版本在下面的代码模块处。</p>
<h5 id="debug过程-1"><a href="#debug过程-1" class="headerlink" title="debug过程"></a>debug过程</h5><p>coding过程其实很短暂，毕竟思路很直观。我一开始是按初见思路写的代码，然后再从初见思路改到正确思路，这个过程，给我埋下了极大的安全隐患【悲】</p>
<p>其实几个小时下来，很多细节都已经忘记了，接下来就说点印象比较深的吧。</p>
<p>首先，我使用了正确思路以来，依然出现了跟初见思路一样的错误，也即xv6正常boot，但是执行ls命令会有错误。但是，当我<code>make clean</code>之后再次<code>make qemu</code>，错误改变了，变成了xv6 boot失败，并且爆出错误<code>panic:ilock:no type</code>。</p>
<blockquote>
<p>注：关于此处的make clean，有两点需要解释。一是为什么会做出make clean的行为，二是这个变化的原理是什么。</p>
<p>此处突然做出make clean的行为，是因为参照了该文章：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/524460096">MIT6.S081 lab8 locks</a></p>
<img src="/2023/01/10/xv6/image-20230123172138766.png" class>

<p>没想到我make clean之后反而就变成了他这样的问题23333也是感觉蛮惊讶的</p>
<p>这个的原理说实话我不大清楚。猜想可能是make qemu的某段访问磁盘初始化之类的代码只会执行一次，只有make clean之后才会让其执行第二次。所以我们手动完全boot了一遍操作系统，才会导致这个错误爆出来，否则，操作系统就会使用原本的正确boot版本启动，之后再执行命令就当然是错误的了。</p>
<p>我想知乎文章里也应该是这个原因。操作系统本来使用的是错误版本，make clean后才会重新使用正确版本。</p>
<p>我之后写对了又尝试了一下，觉得我的猜想应该是对的。我的执行路线：</p>
<ol>
<li>make qemu，得到正确结果</li>
<li>将<code>bio.c</code>改回错误版本</li>
<li>再次make qemu，发现xv6正常boot，但是执行ls命令会出以上同样的错误</li>
<li>make clean，然后make qemu，爆出<code>panic:ilock: no type</code></li>
</ol>
<p>挺完美地符合了我的猜想。</p>
<p>【来自之后的学习：</p>
<p>in lab file system：</p>
<p>mkfs 程序创建 xv6 文件系统磁盘映像并确定文件系统总共有多少个块； 这个大小由 kernel/param.h 中的 FSSIZE 控制。 您会看到本实验存储库中的 FSSIZE 设置为 200,000 个块。 您应该在 make 输出中看到 mkfs/mkfs 的以下输出：<br>nmeta 70 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 25) blocks 199930 total 200000<br>这一行描述了 mkfs/mkfs 构建的文件系统：它有 70 个元数据块（用于描述文件系统的块）和 199,930 个数据块，共计 200,000 个块。<br><strong>如果在实验期间的任何时候您发现自己必须从头开始重建文件系统，您可以运行 make clean 来强制 make 重建 fs.img</strong>。</p>
<p>可以看到，我们上面就是做了强制重构fs.img。】</p>
</blockquote>
<p>我想来想去不知道这个错到底怎么爆的，看了下<code>ilock()</code>对应报错点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in fs.c ilock()</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;ilock begin.\n&quot;);</span></span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//print_buf();</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;bp-&gt;blockno = %d, bp-&gt;refcnt = %d\n&quot;</span>,bp-&gt;blockno,bp-&gt;refcnt);</span><br><span class="line">      panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可知大概就是，ip的type为0这个非法数值就报错了，而ip的type来源于dip，dip又指向了bp的data，bp也就是我们在<code>bio.c</code>一直在打交道的buf结构体。所以说，其实问题是出在了buf上，我们的<code>bread</code>返回的是一个错误的buf。</p>
<p>那么，究竟是buf的哪里出错了呢？这个问题想了我很久很久很久，依然没想出来。我一直认为是我的hashtable+双向链表这个数据结构哪里写错了，反反复复看了三四遍，其他地方的逻辑也反反复复研究了好几遍，依然没有结论。当然此过程也抓出了很多bug，但抓完bug后报错仍在，非常坚挺。</p>
<p>快要放弃的时候，我发现了错误。这很大一部分归功于我用于调试的这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印出hashtable的所有结点</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_buf</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;**********************\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cnt = %d,dec = %d\n&quot;</span>,cnt,dec);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NBUCKET;i++)&#123;</span><br><span class="line">  <span class="type">int</span> should = !holding(&amp;(bcache.dev_locks[i]));</span><br><span class="line">   <span class="keyword">if</span>(should)</span><br><span class="line">     acquire(&amp;(bcache.dev_locks[i]));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">   <span class="type">int</span> tmp_cnt = <span class="number">0</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">b</span>;</span></span><br><span class="line">   <span class="keyword">for</span>(b = bcache.dev_heads[i].next; b != &amp;(bcache.dev_heads[i]); b = b-&gt;next)&#123;</span><br><span class="line">   <span class="comment">//for(b = bcache.dev_heads[i].prev; b != &amp;(bcache.dev_heads[i]); b = b-&gt;prev)&#123;</span></span><br><span class="line">     tmp_cnt++;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;b.refcnt = %d,b.dev = %d,b.blockno = %d\n&quot;</span>,b-&gt;refcnt,b-&gt;dev,b-&gt;blockno);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d:total:%d\n&quot;</span>,i,tmp_cnt);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(should)</span><br><span class="line">     release(&amp;(bcache.dev_locks[i]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在<code>ilock()</code>的panic前面调用了这个函数，并且打印了出问题的buf的blockno：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)&#123;</span><br><span class="line">  print_buf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bp-&gt;blockno = %d, bp-&gt;refcnt = %d\n&quot;</span>,bp-&gt;blockno,bp-&gt;refcnt);</span><br><span class="line">  panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/01/10/xv6/image-20230123174332113.png" class>

<p>可以看到，出问题的这里blockno=33，而在桶7中，首先有两个blockno==33的结点，这已经违反了不变性条件；其次有一个refcnt==1的结点，那个是所需结点，但我们却没有找到那个结点，反而去新申请了一个结点。这显然非常地古怪。</p>
<p>于是随后，我就在<code>bio.c</code>的<code>bget()</code>中添加了这么几句话：</p>
<img src="/2023/01/10/xv6/image-20230123174620818.png" class>

<p>最终结果是会打印出两个blockno==0的结点，但是blockno==33的结点没有访问到。</p>
<p>这就很奇怪了。<code>print_buf</code>中以及<code>bget</code>的这个地方，都是遍历hashtable的某个双向链表，但是，为什么<code>print_buf</code>可以访问到，但是<code>bget</code>不行呢？</p>
<p>我首先对比出来的，是<code>print_buf</code>是逆序遍历，而<code>bget</code>是顺序遍历，所以我就又猜想是因为我的数据结构写错了，然而又看了一遍发现并不是。</p>
<p>这时候，可能我的视力恢复了吧，我猛然发现：：</p>
<img src="/2023/01/10/xv6/image-20230123174921100.png" class>

<p>我超，这里是不是应该用hash。。。。。改完这处之后，果然就非常顺利地pass了所有测试【悲】</p>
<p>可以看到伏笔回收了。我是在旧思路代码基础上改过来的。旧思路代码是用dev作为index的，这个for循环忘记改了。因而，就这样，就这么寄了，看了我三四个小时【悲】</p>
<p>不过这倒是可以解释得通所有的错误了。之所以<code>ilock</code>中buf出错，没有正确找到已经映射在cache中的buf而是自己新建了一个，是因为，我压根就没有在正确的桶里找，而是在别的桶中找，这样自然就找不到了，就会自己新建一个，然后就寄了。</p>
<p>这个故事告诉我们，还是得谨慎写代码（）以及，我在旧代码基础上改的时候，其实可以用更聪明的替换方法：修改dev的变量名为hash-&gt;把参数里的dev变量名改为dev。这样就不会出错了。很遗憾，我并没有想到，只是很急很急地手动一个个改了，之后也没有检查，才发生如此错误。忏悔。</p>
<p>本次bug虽然很sb，但确实让我在debug过程中收获了些许，至少毅力变强了（）途中无数次想要放弃，还好我坚持了下来，才能看到如此感动的OK一片：</p>
<img src="/2023/01/10/xv6/image-20230123170805666.png" class>

<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><h5 id="定义数据结构"><a href="#定义数据结构" class="headerlink" title="定义数据结构"></a>定义数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBUCKET 13</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">dev_heads</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">dev_locks</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span> =</span> bcache.buf;</span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 一开始先均分</span></span><br><span class="line">  uint64 tmp = NBUF/NBUCKET;</span><br><span class="line">  uint64 t = tmp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NBUCKET;i++)&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="number">9</span>,<span class="string">&quot;bcache%02d&quot;</span>,i);</span><br><span class="line">    initlock(&amp;(bcache.dev_locks[i]), buf);</span><br><span class="line">    bcache.dev_heads[i].prev = &amp;(bcache.dev_heads[i]);</span><br><span class="line">    bcache.dev_heads[i].next = &amp;(bcache.dev_heads[i]);</span><br><span class="line">    <span class="keyword">if</span>(i == NBUCKET<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(;b&lt;bcache.buf+NBUF;b++)&#123;</span><br><span class="line">        b-&gt;timestamp = ticks;</span><br><span class="line">        b-&gt;next = bcache.dev_heads[i].next;</span><br><span class="line">        b-&gt;prev = &amp;bcache.dev_heads[i];</span><br><span class="line">        initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">        bcache.dev_heads[i].next-&gt;prev = b;</span><br><span class="line">        bcache.dev_heads[i].next = b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(;b&lt;bcache.buf+t;b++)&#123;</span><br><span class="line">        b-&gt;timestamp = ticks;</span><br><span class="line">        b-&gt;next = bcache.dev_heads[i].next;</span><br><span class="line">        b-&gt;prev = &amp;bcache.dev_heads[i];</span><br><span class="line">        initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">        bcache.dev_heads[i].next-&gt;prev = b;</span><br><span class="line">        bcache.dev_heads[i].next = b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      t += tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="bget"><a href="#bget" class="headerlink" title="bget"></a>bget</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint hash = blockno%<span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;(bcache.dev_locks[hash]));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.dev_heads[hash].next; b != &amp;(bcache.dev_heads[hash]); b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;blockno == blockno&amp;&amp;b-&gt;dev == dev)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      b-&gt;timestamp = ticks;</span><br><span class="line">      release(&amp;(bcache.dev_locks[hash]));</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;(bcache.dev_locks[hash]));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历hash table，找到LRU，也即时间戳最小的且refcnt小于0的那一项</span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  uint min_time = <span class="number">4294967295</span>;<span class="comment">// uint的最大值。此处不能使用(uint)(-1)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">goal</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NBUCKET;i++)&#123;</span><br><span class="line">   uint time = <span class="number">0</span>;</span><br><span class="line">   acquire(&amp;(bcache.dev_locks[i]));</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.dev_heads[i].prev; b != &amp;(bcache.dev_heads[i]); b = b-&gt;prev)&#123;</span><br><span class="line">     <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">       time = b-&gt;timestamp;</span><br><span class="line">       <span class="keyword">if</span>(time &lt; min_time)&#123;</span><br><span class="line">         min_time = time;</span><br><span class="line">         goal = b;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;(bcache.dev_locks[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// hashtable中存在着空闲buf</span></span><br><span class="line">  <span class="keyword">if</span>(goal != <span class="number">0</span>)&#123;</span><br><span class="line">      goal-&gt;dev = dev;</span><br><span class="line">      goal-&gt;blockno = blockno;</span><br><span class="line">      goal-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      goal-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将goal从其所在双向链表中移除</span></span><br><span class="line">      goal-&gt;prev-&gt;next = goal-&gt;next;</span><br><span class="line">      goal-&gt;next-&gt;prev = goal-&gt;prev;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在新双向链表中添加goal</span></span><br><span class="line">      goal-&gt;prev = &amp;(bcache.dev_heads[hash]);</span><br><span class="line">      goal-&gt;next = bcache.dev_heads[hash].next;</span><br><span class="line"></span><br><span class="line">      bcache.dev_heads[hash].next-&gt;prev = goal;</span><br><span class="line">      bcache.dev_heads[hash].next = goal;</span><br><span class="line"></span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;goal-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> goal;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="brelse"><a href="#brelse" class="headerlink" title="brelse"></a>brelse</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uint hash = b-&gt;blockno%NBUCKET;</span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;(bcache.dev_locks[hash]));</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  b-&gt;timestamp = ticks;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>)&#123;</span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line"></span><br><span class="line">    b-&gt;next = bcache.dev_heads[hash].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.dev_heads[hash];</span><br><span class="line">    bcache.dev_heads[hash].next-&gt;prev = b;</span><br><span class="line">    bcache.dev_heads[hash].next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;(bcache.dev_locks[hash]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改bunpin和bpin"><a href="#修改bunpin和bpin" class="headerlink" title="修改bunpin和bpin"></a>修改bunpin和bpin</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  uint hash = b-&gt;blockno%NBUCKET;</span><br><span class="line">  acquire(&amp;bcache.dev_locks[hash]);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.dev_locks[hash]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bunpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  uint hash = b-&gt;blockno%NBUCKET;</span><br><span class="line">  acquire(&amp;bcache.dev_locks[hash]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.dev_locks[hash]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><h2 id="Code-Context-switching"><a href="#Code-Context-switching" class="headerlink" title="Code: Context switching"></a>Code: Context switching</h2><p>xv6中，每个CPU中的scheduler都有一个专用的线程。这里线程的概念是，有自己的栈，有自己的寄存器状态。</p>
<p>当发生时钟中断时，当前进程调用yield，yield再通过swtch切换到scheduler线程。scheduler线程会通过swtch跳转到另外一个进程去执行。当另外一个进程发生时钟中断，又会通过yield回到scheduler，scheduler再调度原进程继续执行，如此周而复始。</p>
<img src="/2023/01/10/xv6/image-20230118221757367.png" class>

<p>下面就来讲讲这个所谓的“线程”以及xv6的上下文切换是怎么实现的。</p>
<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>上下文切换的操作对象是上下文，因而首先了解一下上下文的结构。各种寄存器的状态即是上下文context。xv6中的context定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上下文切换需要修改栈和pc，context中确实有sp寄存器，但是没有pc寄存器，这主要还是因为当swtch返回时，会回到ra所指向的地方，所以仅保存ra就足够了。</p>
<h3 id="swtch"><a href="#swtch" class="headerlink" title="swtch"></a>swtch</h3><p>上下文的切换是通过swtch实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>            <span class="title function_">swtch</span><span class="params">(<span class="keyword">struct</span> context*, <span class="keyword">struct</span> context*)</span>;</span><br></pre></td></tr></table></figure>

<p>swtch会把当前进程的上下文保存在第一个context中，再切换到第二个context保存的上下文，具体实现就是写读保存寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># in kernel/swtch.S</span><br><span class="line"># a0和a1分别保存着两个参数的值，也即第一个context的地址和第二个context的地址</span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        sd s1, 24(a0)</span><br><span class="line">        # ...</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ld s1, 24(a1)</span><br><span class="line">        # ...</span><br><span class="line">        ld 11, 104(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><p>在sleep、yield和wakeup中，都会通过sched中的swtch进入scheduler线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena;</span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpu中存储着的是scheduler线程的context。因而，这样就可以保存当前进程的context，读取scheduler线程的context，然后转换到scheduler的context执行了。</p>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过swtch进入scheduler线程后，会继续执行scheduler中swtch的下一个指令，完成下一次调度。</p>
<h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><p>以上是书本的介绍内容。看到这想必会有很多疑惑，至少有以下两点：</p>
<ol>
<li>为什么cpu-&gt;context会存储着scheduler的上下文？这是什么时候，又是怎么初始化的？</li>
<li>为什么从sched中swtch会来到scheduler中swtch的下一句？</li>
</ol>
<p>先从第一点入手。实际上，这个初始化的工作，是在操作系统启动时的<code>main.c</code>中完成的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这之前，创建了第一个进程proc。在这里，每个cpu都调用了scheduler。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个cpu都在scheduler线程的<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context);</code>中，将当前的context，<strong>也即scheduler的context</strong>存入了<code>mycpu()-&gt;context</code>。随后，CPU中的某个去执行下一个进程，其他的就在scheduler线程的<strong>无限循环中等待</strong>，直到有别的进程产生。</p>
<p>去执行进程的CPU通过swtch切换上下文，切到了另一个进程中，此时在swtch中保存的ra是scheduler线程的swtch的下一句（因为scheduler-&gt;swtch也是个函数调用的过程）。会切到另一个进程的sched的下一句【因为它正是从那边swtch过来的】，或者是那个进程开始执行的地方【下面会提到是forkret】。另一个进程通过sched切换回来的时候，就正会切到ra所指向的位置，也即切到scheduler中的swtch后面。</p>
<p>这样一来，两个问题就都得到了解答。</p>
<p><strong>从这，我们也能知道xv6是如何让CPU运转的：scheduler线程是CPU的IDLE状态。无事的时候在scheduler中等待，并且一直监测是否有进程需要执行。有的话，则去执行该进程；该进程又会通过sched切换回scheduler线程，继续等待。这样一来，就完成了进程管理的基本的自动机图像。</strong></p>
<h2 id="Code-Scheduling"><a href="#Code-Scheduling" class="headerlink" title="Code: Scheduling"></a>Code: Scheduling</h2><h3 id="sched前要做的事"><a href="#sched前要做的事" class="headerlink" title="sched前要做的事"></a>sched前要做的事</h3><blockquote>
<p> A process that wants to give up the CPU must do three things:</p>
<ol>
<li>acquire its own process lock p-&gt;lock, release any other locks it is holding</li>
<li>update its own state (p-&gt;state)</li>
<li>call sched</li>
</ol>
<p><code>yield</code> (kernel/proc.c:515) follows this convention, as do <code>sleep</code> and <code>exit</code>.</p>
<p><code>sched</code> double-checks those conditions (kernel/proc.c:499-504) and then an implication of those conditions:  since a lock is held, interrupts should be disabled.</p>
</blockquote>
<h3 id="sched与scheduler"><a href="#sched与scheduler" class="headerlink" title="sched与scheduler"></a>sched与scheduler</h3><p>在上面的描述我们可以看到，<code>sched</code>和<code>scheduler</code>联系非常密切，他们俩通过<code>swtch</code>相互切来切去，并且一直都只在这几行切来切去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in scheduler()</span></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// in sched()</span></span><br><span class="line">swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">mycpu()-&gt;intena = intena;</span><br></pre></td></tr></table></figure>

<p>在两个线程之间进行这种样式化切换的过程有时被称为协程（coroutines）。</p>
<blockquote>
<p>存在一种情况使得调度程序对<code>swtch</code>的调用没有以<code>sched</code>结束。一个新进程第一次被调度时，它从<code>forkret</code>（<strong>kernel/proc.c</strong>:527）开始。<code>Forkret</code>是为了释放<code>p-&gt;lock</code>而包装的，要不然，新进程可以从<code>usertrapret</code>开始。</p>
</blockquote>
<h3 id="p-gt-lock保证了并发安全性"><a href="#p-gt-lock保证了并发安全性" class="headerlink" title="p-&gt;lock保证了并发安全性"></a>p-&gt;lock保证了并发安全性</h3><blockquote>
<p>考虑调度代码结构的一种方法是，它为每个进程强制维持一个不变性条件的集合，并在这些不变性条件不成立时持有<code>p-&gt;lock</code>。</p>
<p>其中一个不变性条件是：如果进程是<code>RUNNING</code>状态，计时器中断的<code>yield</code>必须能够安全地从进程中切换出去；这意味着CPU寄存器必须保存进程的寄存器值（即<code>swtch</code>没有将它们移动到<code>context</code>中），并且<code>c-&gt;proc</code>必须指向进程。另一个不变性条件是：如果进程是<code>RUNNABLE</code>状态，空闲CPU的调度程序必须安全地运行它；这意味着<code>p-&gt;context</code>必须保存进程的寄存器（即，它们实际上不在实际寄存器中），没有CPU在进程的内核栈上执行，并且没有CPU的<code>c-&gt;proc</code>引用进程。</p>
<p><u>维护上述不变性条件是xv6经常在一个线程中获取p-&gt;lock并在另一个线程中释放它的原因</u>，在保持<code>p-&gt;lock</code>时，这些属性通常不成立。</p>
<p>例如在<code>yield</code>中获取并在<code>scheduler</code>中释放。一旦<code>yield</code>开始修改一个<code>RUNNING</code>进程的状态为<code>RUNNABLE</code>，锁必须保持被持有状态，直到不变量恢复：最早的正确释放点是<code>scheduler</code>（在其自身栈上运行）清除<code>c-&gt;proc</code>之后。类似地，一旦<code>scheduler</code>开始将<code>RUNNABLE</code>进程转换为<code>RUNNING</code>，在内核线程完全运行之前（在<code>swtch</code>之后，例如在<code>yield</code>中）绝不能释放锁。</p>
<p><code>p-&gt;lock</code>还保护其他东西：<code>exit</code>和<code>wait</code>之间的相互作用，避免丢失<code>wakeup</code>的机制（参见第7.5节），以及避免一个进程退出和其他进程读写其状态之间的争用（例如，<code>exit</code>系统调用查看<code>p-&gt;pid</code>并设置<code>p-&gt;killed</code>(<strong>kernel/proc.c</strong>:611)）。为了清晰起见，也许为了性能起见，有必要考虑一下<code>p-&gt;lock</code>的不同功能是否可以拆分。</p>
</blockquote>
<p>p-&gt;lock在每次scheduler开始的时候获取，swtch到p进程的时候在yield等调用完sched的地方释放。而调用yield时获取的锁，又会在scheduler中释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Give up the CPU for one scheduling round.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);<span class="comment">// 该锁会在scheduler中释放</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  sched();</span><br><span class="line">  release(&amp;p-&gt;lock);<span class="comment">// 该锁释放的是scheduler中得到的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/proc.c scheduler()</span></span><br><span class="line">	  acquire(&amp;p-&gt;lock);<span class="comment">// 该锁会在yield等地被释放</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">      release(&amp;p-&gt;lock);<span class="comment">// 该锁会释放yield等地中获得的锁</span></span><br></pre></td></tr></table></figure>

<p>不得不说，这结构实在是太精妙了。这中间的如此多的复杂过程，就这样成功地被锁保护了起来。</p>
<h2 id="Code-mycpu-and-myproc"><a href="#Code-mycpu-and-myproc" class="headerlink" title="Code: mycpu and myproc"></a>Code: mycpu and myproc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mycpu是通过获取当前cpuid来获取cpu结构的。当前使用的cpuid约定俗成地存在了tp寄存器里。为了让mycpu有效工作，必须确保tp寄存器始终存放的是当前cpu的hartid。</p>
<p>首先是在操作系统初始化的时候要把cpuid存入tp寄存器。RISC-V规定，mhartid也即cpuid的存放点只能在machine mode被读取。因而这项工作得在<code>start.c</code>中完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/start.c </span></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"><span class="comment">// in kernel/riscv.h</span></span><br><span class="line"><span class="comment">// which hart (core) is this?</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_mhartid</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, mhartid&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内核态中，编译器被设置为保证不会以其他方式使用tp寄存器。因而初始化之后，内核态中每个CPU的tp寄存器就始终存放着自己的cpuid。</p>
<p>但这在用户进程是不成立的。因而必须在用户进程进入陷阱的时候做一些工作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># in kernel/trampoline.S uservec</span><br><span class="line">sd tp, 64(a0)</span><br><span class="line"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">ld tp, 32(a0)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须在trampoline保存用户态中使用的tp值，以及内核态中对应的hartid。</p>
<p>最后再在返回用户态的时候恢复用户态的tp值以及更新trampoline的tp值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c usertrapret()</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># in trampoline.S userret</span><br><span class="line">ld tp, 64(a0)</span><br></pre></td></tr></table></figure>

<p>注意，更新trampoline的tp值这一步很重要。因为如果在用户态发生的是时钟中断，就会引起yield，可能造成CPU的切换。这时候就需要在返回用户态的时候修改一下trapframe中的tp为当前CPU的tp。这样一来才能保证，在本次时钟中断结束，以及到下一次时钟中断修改CPU这一期间，trapframe中的tp寄存器以及内核态中的tp寄存器都是正确的。</p>
<p>通过<code>mycpu()</code>获取cpuid其实是非常脆弱的。因为你可能获取完cpuid，进程就被切到别的CPU去执行了，这就会有一个先检查后执行的竞态条件，具有并发安全隐患。因而，xv6要求使用<code>mycpu()</code>返回值的这段代码需要关中断，这样就可以避免时钟中断造成的进程切换了。比如说像<code>myproc()</code>这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the current struct proc *, or zero if none.</span></span><br><span class="line"><span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，不同于<code>mycpu()</code>，使用<code>myproc()</code>的返回值不需要进行开关中断保护。因为当前进程的指针不论处于哪个CPU都是不变的。</p>
<h2 id="Sleep-and-wakeup"><a href="#Sleep-and-wakeup" class="headerlink" title="Sleep and wakeup"></a>Sleep and wakeup</h2><p>前面我们已经介绍了进程隔离性的基本图像，接下来要讲xv6是如何让进程之间互动的。xv6使用的是经典的<em>sleep and wakeup</em>，也叫<em>序列协调（sequence coordination）</em>或<em>条件同步机制（conditional synchronization mechanisms</em>。下面，将从最基本的自旋锁实现信号量开始，来逐步讲解xv6的<em>sleep and wakeup</em>机制。</p>
<h3 id="自旋锁实现信号量"><a href="#自旋锁实现信号量" class="headerlink" title="自旋锁实现信号量"></a>自旋锁实现信号量</h3><img src="/2023/01/10/xv6/image-20230120150659730.png" class>

<img src="/2023/01/10/xv6/image-20230120150715925.png" class>

<p>缺点就是自旋太久了，因而我们需要在等待的时候调用yield，直到资源生产出来之后再继续执行。</p>
<h3 id="不安全的sleep-and-wakeup"><a href="#不安全的sleep-and-wakeup" class="headerlink" title="不安全的sleep and wakeup"></a>不安全的sleep and wakeup</h3><blockquote>
<p>Let’s imagine a pair of calls, sleep and wakeup, that work as follows:</p>
<ol>
<li><p><code>sleep(chan)</code></p>
<p>Sleeps on the arbitrary value chan, called the <em>wait channel</em>. Sleep puts the calling process to sleep, releasing the CPU for other work.  </p>
</li>
<li><p><code>wakeup(chan)</code></p>
<p>Wakes <strong>all</strong> processes sleeping on chan (if any), causing their sleep calls to return. If no processes are waiting on chan, wakeup does nothing.</p>
</li>
</ol>
</blockquote>
<p>这样一来，信号量实现就可修改为这样了：</p>
<img src="/2023/01/10/xv6/image-20230120151051989.png" class>

<p>但是，我们可以注意到，在212-213行这里产生了一个先检查后执行的竞态条件。</p>
<blockquote>
<p>如果消费者进程执行到212-213中间，此时生产者进程已经调用结束，也就是说wakeup并没有唤醒任何消费者进程。消费者进程就会一直在sleep中没人唤醒，除非生产者进程再执行一次。这样就会造成<em>lost wake-up</em> 这个问题。</p>
</blockquote>
<p>所以，我们可以选择把这个竞态条件也放入s-&gt;lock这个锁区域保护。</p>
<img src="/2023/01/10/xv6/image-20230120151353712.png" class>

<p>但是这样一来又会产生死锁问题。因而，我们可以尝试着修改sleep和wakeup的接口定义。</p>
<h3 id="sleep-and-wakeup"><a href="#sleep-and-wakeup" class="headerlink" title="sleep and wakeup"></a>sleep and wakeup</h3><blockquote>
<p>We’ll fix the preceding scheme by changing sleep’s interface: </p>
<p>The caller must pass the <em>condition lock</em> to sleep so it can <strong>release the lock</strong> after the calling process is marked as asleep and waiting on the sleep channel. The lock will force a concurrent V to wait until P has finished putting itself to sleep, so that the wakeup will find the sleeping consumer and wake it up. Once the consumer is awake again sleep <strong>reacquires the lock</strong> before returning. </p>
<p>也即在sleep中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sleep(s,&amp;s-&gt;lock)&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">	<span class="comment">//wait until wakeup</span></span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样一来，信号量就可以完美实现了：</p>
<img src="/2023/01/10/xv6/image-20230120151807102.png" class>

<img src="/2023/01/10/xv6/image-20230120151820455.png" class>

<blockquote>
<p>注：严格地说，<code>wakeup</code>只需跟在<code>acquire</code>之后就足够了（也就是说，可以在<code>release</code>之后调用<code>wakeup</code>）</p>
<p>【想了一下，有一说一确实，放在release前后都不影响】</p>
</blockquote>
<blockquote>
<p>原始Unix内核的<code>sleep</code>只是禁用了中断，这就足够了，因为Unix运行在单CPU系统上。因为xv6在多处理器上运行，所以它为<code>sleep</code>添加了一个显式锁。</p>
</blockquote>
<h2 id="Code-Sleep-and-wakeup"><a href="#Code-Sleep-and-wakeup" class="headerlink" title="Code: Sleep and wakeup"></a>Code: Sleep and wakeup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Atomically release lock and sleep on chan.</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    <span class="comment">// 获取进程锁，释放外部锁</span></span><br><span class="line">    <span class="comment">// 此进程锁将在scheduler线程中释放</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    release(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line">  <span class="comment">// 到这里来，说明已经被wakeup且被调度了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    <span class="comment">//释放进程锁，获取外部锁</span></span><br><span class="line">    <span class="comment">// 此进程锁是在scheduler中获取到的</span></span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    acquire(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果lk为p-&gt;lock，那么<strong>lk依然会在scheduler线程中被暂时释放</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到，关于<code>chan</code>这一变量的取值是非常任意的，仅需取一个约定俗成的值就OK。这里取为了信号量的地址，同时满足了逻辑需求和语义需求。</p>
<blockquote>
<p>Callers of sleep and wakeup can use any mutually convenient number as the channel. Xv6 often uses the address of a kernel data structure involved in the waiting.</p>
</blockquote>
<p>这里也解释了为什么需要while循环</p>
<blockquote>
<p>有时，多个进程在同一个通道上睡眠；例如，多个进程读取同一个管道。一个单独的<code>wakeup</code>调用就能把他们全部唤醒。其中一个将首先运行并获取与<code>sleep</code>一同调用的锁，并且（在管道例子中）读取在管道中等待的任何数据。尽管被唤醒，其他进程将发现没有要读取的数据。从他们的角度来看，醒来是“虚假的”，他们必须再次睡眠。因此，在检查条件的循环中总是调用<code>sleep</code>。</p>
</blockquote>
<h2 id="Code-Pipes"><a href="#Code-Pipes" class="headerlink" title="Code: Pipes"></a>Code: Pipes</h2><p>pipes很显然就是生产者消费者模式的一个例证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">  uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">  uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">  <span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">  <span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">piperead</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="comment">//DOC: pipe-empty并且依然有进程在写</span></span><br><span class="line">    <span class="keyword">if</span>(pr-&gt;killed)&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待直到pipe不为空</span></span><br><span class="line">    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="comment">//DOC: piperead-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">//DOC: piperead-copy</span></span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];</span><br><span class="line">    <span class="keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒写入管道的进程</span></span><br><span class="line">  wakeup(&amp;pi-&gt;nwrite);  <span class="comment">//DOC: piperead-wakeup</span></span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipewrite</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123;  <span class="comment">//DOC: pipewrite-full管道满则阻塞</span></span><br><span class="line">      <span class="keyword">if</span>(pi-&gt;readopen == <span class="number">0</span> || pr-&gt;killed)&#123;</span><br><span class="line">        release(&amp;pi-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 唤醒读取管道的进程</span></span><br><span class="line">      wakeup(&amp;pi-&gt;nread);</span><br><span class="line">      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;pi-&gt;nread);</span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非常有意思且巧妙的点，就是<strong>读写管道等待在不同的chan上</strong>，这与上面信号量的例子是不一样的。想想也确实，如果使用同一个管道的话，当唤醒的时候，就会把不论是读还是写的全部进程都唤醒过来，这对性能显然损失较大。</p>
<blockquote>
<p>The pipe code uses separate sleep channels for reader and writer (pi-&gt;nread and pi-&gt;nwrite); this might make the system more effificient in the unlikely event that there are lots of readers and writers waiting for the same pipe.</p>
</blockquote>
<h2 id="Code-Wait-exit-and-kill"><a href="#Code-Wait-exit-and-kill" class="headerlink" title="Code: Wait, exit, and kill"></a>Code: Wait, exit, and kill</h2><h3 id="exit和wait"><a href="#exit和wait" class="headerlink" title="exit和wait"></a>exit和wait</h3><blockquote>
<p><code>Sleep</code>和<code>wakeup</code>可用于多种等待。第一章介绍的一个有趣的例子是子进程<code>exit</code>和父进程<code>wait</code>之间的交互。</p>
<p>xv6记录子进程终止直到<code>wait</code>观察到它的方式是让<code>exit</code>将调用方置于<code>ZOMBIE</code>状态，在那里它一直保持到父进程的<code>wait</code>注意到它，将子进程的状态更改为<code>UNUSED</code>，复制子进程的<code>exit</code>状态码，释放子进程，并将子进程ID返回给父进程。</p>
<p>如果父进程在子进程之前退出，则父进程将子进程交给<code>init</code>进程，<code>init</code>进程将永久调用<code>wait</code>；因此，每个子进程退出后都有一个父进程进行清理。</p>
</blockquote>
<p>又是一个生产者消费者模式。只不过此时的chan是父进程，资源是僵尸子进程【草】。由于涉及到进程间的调度切换，因而实现稍微复杂了点。</p>
<p>为什么需要涉及到进程间的调度呢？子进程设置完僵尸状态后，直接通过函数ret不行吗？答案是不行，因为ret的话就会去到不知道哪的地方【大概率会变成scause=2的情况】，所以这里子进程想要退出，就得做几件事，一是依靠父进程，让父进程杀死子进程，二是把自己设置为一个特殊的状态，使得自己不会被调度从而执行ret指令出错，三是尽快让父进程杀死自己越快越好。综合上述三个原因，exit最终在调度方面的实现方式，就变成了，子进程设置自己为ZOMBIE态-&gt;启用调度-&gt;父进程杀死ZOMBIE态的子进程。这期间不变性条件的防护，就得依赖于锁，以及sleep和wakeup了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// we need the parent&#x27;s lock in order to wake it up from wait().</span></span><br><span class="line">  <span class="comment">// the parent-then-child rule says we have to lock it first.</span></span><br><span class="line">  <span class="comment">// 整个xv6都必须遵守相同的顺序（父级，然后是子级）不论是锁定还是释放，都是先父再子</span></span><br><span class="line">  acquire(&amp;original_parent-&gt;lock);</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give any children to init.</span></span><br><span class="line">  <span class="comment">// 把自己的所有孩子都托付给init进程</span></span><br><span class="line">  <span class="comment">// init进程就是在操作系统启动时</span></span><br><span class="line">  reparent(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parent might be sleeping in wait().</span></span><br><span class="line">  <span class="comment">// 唤醒wait中的父进程</span></span><br><span class="line">  <span class="comment">// 这里看上去很诡异，明明子进程状态还未完全，怎么就唤醒父亲了呢？但其实很安全。</span></span><br><span class="line">  <span class="comment">// 此时子进程仍持有父进程的锁，如果有别的CPU中断进入scheduler线程，到父进程那时会卡在aquire</span></span><br><span class="line">  <span class="comment">// 直到子进程完成后续工作后父进程才能被真正唤醒执行</span></span><br><span class="line">  wakeup1(original_parent);</span><br><span class="line"></span><br><span class="line">  p-&gt;xstate = status;</span><br><span class="line">  <span class="comment">// 设为ZOMBIE态</span></span><br><span class="line">  p-&gt;state = ZOMBIE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成后续工作，解除父进程的锁</span></span><br><span class="line">  release(&amp;original_parent-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Jump into the scheduler, never to return.</span></span><br><span class="line">  <span class="comment">// 子进程会在父进程中被释放，所以永远不会回来</span></span><br><span class="line">  sched();</span><br><span class="line">  panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">wait</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hold p-&gt;lock for the whole time to avoid lost</span></span><br><span class="line">  <span class="comment">// wakeups from a child&#x27;s exit().</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;</span><br><span class="line">      <span class="comment">// this code uses np-&gt;parent without holding np-&gt;lock.</span></span><br><span class="line">      <span class="comment">// acquiring the lock first would cause a deadlock,</span></span><br><span class="line">      <span class="comment">// since np might be an ancestor, and we already hold p-&gt;lock.</span></span><br><span class="line">      <span class="comment">// 下面的第一点其实一句话就可以搞定：</span></span><br><span class="line">      <span class="comment">// 【它违反了先获取父亲锁，再获取子锁的xv6代码规定】</span></span><br><span class="line">      <span class="comment">// 1.要是在这句话之前acquire的话，acquire到你爸，你爸这时候也刚好执行到这句话</span></span><br><span class="line">      <span class="comment">// 那么就会造成你在自旋【此时你爸在wait一开始就得到了锁】，</span></span><br><span class="line">      <span class="comment">// 你爸也在自旋【你也在wait一开始得到了锁】,这样就造成了死锁</span></span><br><span class="line">      <span class="comment">// 2.并且由于np-&gt;parent只有parent才能改，所以数据是否过时是没关系的</span></span><br><span class="line">      <span class="comment">// 因为如果不是你儿子，数据过时与否都知道不是你儿子</span></span><br><span class="line">      <span class="comment">// 如果是你儿子，那数据压根就不会过时</span></span><br><span class="line">      <span class="keyword">if</span>(np-&gt;parent == p)&#123;</span><br><span class="line">        <span class="comment">// np-&gt;parent can&#x27;t change between the check and the acquire()</span></span><br><span class="line">        <span class="comment">// because only the parent changes it, and we&#x27;re the parent.</span></span><br><span class="line">        acquire(&amp;np-&gt;lock);</span><br><span class="line">        havekids = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(np-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          <span class="comment">// Found one.</span></span><br><span class="line">          pid = np-&gt;pid;</span><br><span class="line">          <span class="comment">// 传递返回参数</span></span><br><span class="line">          <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;np-&gt;xstate,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(np-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            release(&amp;np-&gt;lock);</span><br><span class="line">            release(&amp;p-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          freeproc(np);</span><br><span class="line">          release(&amp;np-&gt;lock);</span><br><span class="line">          release(&amp;p-&gt;lock);</span><br><span class="line">          <span class="keyword">return</span> pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don&#x27;t have any children.</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || p-&gt;killed)&#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for a child to exit.</span></span><br><span class="line">    <span class="comment">// 暂时释放p锁，等待子进程获取退出</span></span><br><span class="line">    sleep(p, &amp;p-&gt;lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中值得注意的几个点：</p>
<ol>
<li><p><code>wait</code>中的<code>sleep</code>中释放的条件锁是等待进程的<code>p-&gt;lock</code>，这是上面提到的特例。</p>
</li>
<li><p>exit会将自己的所有子进程交付给一直在等待着的init进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">    <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">    wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">      <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这里！！</span></span><br><span class="line">      <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子进程退出，就会通过init的wait释放它们。然后init释放完它们后进入第三个if分支，继续进行循环。</p>
</li>
<li><p>wakeup1</p>
<blockquote>
<p>Exit calls a specialized wakeup function, wakeup1, that wakes up only the parent, and only if it is sleeping in wait.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up p if it is sleeping in wait(); used by exit().</span></span><br><span class="line"><span class="comment">// Caller must hold p-&gt;lock.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup1</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;wakeup1&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;chan == p &amp;&amp; p-&gt;state == SLEEPING) &#123;</span><br><span class="line">    p-&gt;state = RUNNABLE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>kill其实做得很温和。它只是会把想鲨的进程的p-&gt;killed设置为1，然后如果该进程sleeping，则唤醒它。最后的死亡以及销毁由进程自己来做。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kill the process with the given pid.</span></span><br><span class="line"><span class="comment">// The victim won&#x27;t exit until it tries to go</span></span><br><span class="line"><span class="comment">// to kernel space (see usertrap() in trap.c).</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid == pid)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING)&#123;</span><br><span class="line">        <span class="comment">// Wake process from sleep().</span></span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// in trap.c usertrap()</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>可能这里有一个疑问：调用完exit后，进程会变成ZOMBIE态。谁最终把它释放了呢？其实答案很简单，只有两种：init进程或者是创建它的父进程。</p>
<p>如果创建它的父进程处于wait中，那么是由父进程把它销毁的，这没什么好说的。但如果创建它的父进程不在wait呢？那么父进程最后也是会调用exit的。父进程调用完exit后，会将其所有子进程过继给init进程。所以，ZOMBIE进程最终还是会迟早被init进程杀死的。</p>
<p>由这里，可以窥见xv6进程管理的进一步的冰山一角：</p>
<p>init进程是所有进程的根系进程。它一直处于wait的死循环中，因而可以将需要被杀死的进程杀死。</p>
<p>可见，wait和exit，实际上就构筑了进程的生命周期的最后一环。</p>
<p>这种巧妙地将进程生命周期这个大事<strong>完全托付给了wait和exit这两个函数</strong>的这种结构，实在是非常精妙，太牛了吧。</p>
<blockquote>
<p>一些XV6的<code>sleep</code>循环不检查<code>p-&gt;killed</code>，因为代码在应该是原子操作的多步系统调用的中间。virtio驱动程序（*<strong>kernel/virtio_disk.c*</strong>:242）就是一个例子：它不检查<code>p-&gt;killed</code>，因为一个磁盘操作可能是文件系统保持正确状态所需的一组写入操作之一。等待磁盘I/O时被杀死的进程将不会退出，直到它完成当前系统调用并且<code>usertrap</code>看到<code>killed</code>标志</p>
</blockquote>
<blockquote>
<p>Xv6对<code>kill</code>的支持并不完全令人满意：有一些<code>sleep</code>循环可能应该检查<code>p-&gt;killed</code>。一个相关的问题是，即使对于检查<code>p-&gt;killed</code>的<code>sleep</code>循环，<code>sleep</code>和<code>kill</code>之间也存在竞争；后者可能会设置<code>p-&gt;killed</code>，并试图在受害者的循环检查<code>p-&gt;killed</code>之后但在调用<code>sleep</code>之前尝试唤醒受害者。如果出现此问题，受害者将不会注意到<code>p-&gt;killed</code>，直到其等待的条件发生。这可能比正常情况要晚一点（例如，当virtio驱动程序返回受害者正在等待的磁盘块时）或永远不会发生（例如，如果受害者正在等待来自控制台的输入，但用户没有键入任何输入）。</p>
</blockquote>
<p>是的，所以这个kill的实现其实是相当玄学的。</p>
<h2 id="Real-world-4"><a href="#Real-world-4" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>xv6调度器实现了一个简单的调度策略：它依次运行每个进程。这一策略被称为轮询调度（round robin）。真实的操作系统实施更复杂的策略，例如，允许进程具有优先级。</p>
</blockquote>
<p>我记得linux0.11用的是时间片轮转+优先级队列完美融合的方法，是真的很牛逼</p>
<blockquote>
<p>复杂的策略可能会导致意外的交互，例如优先级反转（priority inversion）和航队（convoys）。当低优先级进程和高优先级进程共享一个锁时，可能会发生优先级反转，当低优先级进程持有该锁时，可能会阻止高优先级进程前进。当许多高优先级进程正在等待一个获得共享锁的低优先级进程时，可能会形成一个长的等待进程航队；一旦航队形成，它可以持续很长时间。为了避免此类问题，在复杂的调度器中需要额外的机制。</p>
</blockquote>
<blockquote>
<p>在<code>wakeup</code>中扫描整个进程列表以查找具有匹配<code>chan</code>的进程效率低下。一个更好的解决方案是用一个数据结构替换<code>sleep</code>和<code>wakeup</code>中的<code>chan</code>，该数据结构包含在该结构上休眠的进程列表，例如Linux的等待队列。</p>
</blockquote>
<p>是的，linux的那个wakeup真的很牛，我现在都还记得当初学到那的时候的震撼。</p>
<blockquote>
<p><code>wakeup</code>的实现会唤醒在特定通道上等待的所有进程，可能有许多进程在等待该特定通道。操作系统将安排所有这些进程，它们将竞相检查睡眠条件。进程的这种行为有时被称为<strong>惊群效应</strong>（thundering herd），最好避免。</p>
<p>大多数条件变量都有两个用于唤醒的原语：<code>signal</code>用于唤醒一个进程；<code>broadcast</code>用于唤醒所有等待进程。</p>
</blockquote>
<blockquote>
<p>一个实际的操作系统将在固定时间内使用空闲列表找到自由的<code>proc</code>结构体，而不是<code>allocproc</code>中的线性时间搜索；xv6使用线性扫描是为了简单起见。</p>
</blockquote>
<h2 id="Lab-Multithreading"><a href="#Lab-Multithreading" class="headerlink" title="Lab: Multithreading"></a>Lab: Multithreading</h2><blockquote>
<p>You will implement switching between threads in a user-level threads package, use multiple threads to speed up a program, and implement a barrier.</p>
</blockquote>
<p>这个introduction看起来还是非常激动人心的，很早就想了解到底线程是怎么实现的了。不过做完发现思想还是很简单的，就是只用切换上下文和栈就行。可以看看提供给的代码。</p>
<h3 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h3><blockquote>
<p>In this exercise you will design the <strong>context switch</strong> mechanism for a user-level threading system, and then implement it. </p>
<p>To get you started, your xv6 has two files <code>user/uthread.c</code> and <code>user/uthread_switch.S</code>, and a rule in the Makefile to build a uthread program. </p>
<p><code>uthread.c</code> contains most of a user-level threading package, and code for three simple test threads. The threading package is missing some of the code to create a thread and to switch between threads.</p>
<p>You will need to add code to <code>thread_create()</code> and <code>thread_schedule()</code> in <code>user/uthread.c</code>, and <code>thread_switch</code> in <code>user/uthread_switch.S</code>. </p>
<p>One goal is ensure that when <code>thread_schedule()</code> runs a given thread for the first time, the thread executes the function passed to <code>thread_create()</code>, on its <strong>own stack.</strong> </p>
<p>Another goal is to ensure that <code>thread_switch</code> saves the registers of the thread being switched away from, restores the registers of the thread being switched to, and returns to the point in the latter thread’s instructions where it last left off. You will have to decide where to save/restore registers; modifying <code>struct thread</code> to hold registers is a good plan. </p>
<p>You’ll need to add a call to <code>thread_switch</code> in <code>thread_schedule</code>; you can pass whatever arguments you need to <code>thread_switch</code>, but the intent is to switch from thread <code>t</code> to <code>next_thread</code>.</p>
</blockquote>
<h4 id="感想-17"><a href="#感想-17" class="headerlink" title="感想"></a>感想</h4><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>看了一遍它这里面写的题目还是有点抽象的，需要结合着给的代码看，那样就清晰多了。</p>
<p>首先，要补全的地方有这几个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. in thread_schedule()</span></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 2. in thread_create()</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. in uthread_switch.S</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * save the old thread&#x27;s registers,</span></span><br><span class="line"><span class="comment">         * restore the new thread&#x27;s registers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        .globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">        <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">        ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure>

<p>这几个函数到时候会被如此调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  a_started = b_started = c_started = <span class="number">0</span>;</span><br><span class="line">  a_n = b_n = c_n = <span class="number">0</span>;</span><br><span class="line">  thread_init();</span><br><span class="line">  thread_create(thread_a);</span><br><span class="line">  thread_create(thread_b);</span><br><span class="line">  thread_create(thread_c);</span><br><span class="line">  thread_schedule();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们在第一个地方要做的，就是要填入swtch的签名。第二个地方要做的，就是要想办法让该线程一被启动就去执行参数的函数指针。第三个地方要做的，就是要完成上下文的切换。</p>
<p>所以思路其实是很直观的。我们可以模仿进程管理中用来表示上下文的context，在<code>thread_create</code>的时候把里面的ra设置为参数的函数指针入口，sp修改为thread结构体中的栈地址。swtch函数则完全把<code>kernel/swtch.S</code>超过来就行。</p>
<blockquote>
<p>在这个思路中，我们是怎么做到栈的切换的呢？</p>
<p>每个线程在<code>thread_create</code>的时候，都将自己的context中的sp修改为自己的栈地址。这样一来，在它们被调度的时候，switch会自然而然地从context中读取sp作为之后运行的sp，这样就实现了栈的切换。</p>
</blockquote>
<h5 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h5><p>我觉得其他方面都不难，最坑最细节的【也是我完全没有想到的……】就是这里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改sp为栈顶</span></span><br><span class="line">t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br></pre></td></tr></table></figure>

<p>需要注意，栈顶并不是<code>t-&gt;stack</code>。</p>
<p>通过测试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0062f</span>eb8</span><br><span class="line"><span class="number">0062f</span>ebc</span><br><span class="line"><span class="number">0062f</span>ec0</span><br><span class="line"><span class="number">0062f</span>ec4</span><br><span class="line"><span class="number">0062f</span>ec8</span><br></pre></td></tr></table></figure>

<p>栈是向下增长的，因而，栈顶确实应该是数组的末尾……</p>
<p>这里完全没有想到，还是吃了基础的亏啊。</p>
<blockquote>
<p>如果这里将<code>t-&gt;stack</code>作为sp，那么运行时会出现非常诡异的现象（打印的是abc三个的<code>thread-&gt;state</code>）：</p>
<img src="/2023/01/10/xv6/image-20230120232149776.png" class>

<p>仅有c【经测试，是仅有最后一个启动的线程】在执行，而ab的state都不是理想中的2，而是很奇怪的值。我确实有想过栈溢出问题，但是马上被我否定了。我完全没有想到是那样错的【悲】</p>
</blockquote>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><h5 id="增加context结构体定义，修改thread结构体"><a href="#增加context结构体定义，修改thread结构体" class="headerlink" title="增加context结构体定义，修改thread结构体"></a>增加context结构体定义，修改thread结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-create"><a href="#修改thread-create" class="headerlink" title="修改thread_create"></a>修改thread_create</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">// 将当前上下文保存入context</span></span><br><span class="line">  thread_switch((uint64)(&amp;(t-&gt;context)),(uint64)(&amp;(t-&gt;context)));</span><br><span class="line">  <span class="comment">// 修改sp为栈顶</span></span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">  <span class="comment">// 修改ra为参数的函数指针入口</span></span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-schedule"><a href="#修改thread-schedule" class="headerlink" title="修改thread_schedule"></a>修改thread_schedule</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">  next_thread-&gt;state = RUNNING;</span><br><span class="line">  t = current_thread;</span><br><span class="line">  current_thread = next_thread;</span><br><span class="line">  <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">   * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">   * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  thread_switch((uint64)(&amp;(t-&gt;context)),(uint64)(&amp;(current_thread-&gt;context)));</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-switch"><a href="#修改thread-switch" class="headerlink" title="修改thread_switch"></a>修改thread_switch</h5><p>全部照搬<code>kernel/swtch.S</code>，没什么好说的</p>
<h3 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h3><p>一步步细粒度化，最后，每个桶用单独一把锁，仅在调用insert处加锁就行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> locks[NBUCKET];<span class="comment">// 在main中初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><blockquote>
<p>In this assignment you’ll implement a <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Barrier_(computer_science)">barrier</a>: a point in an application at which all participating threads must wait until all other participating threads reach that point too.</p>
</blockquote>
<p>直接上代码，还是比较简单的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">   pthread_mutex_lock(&amp;(bstate.barrier_mutex));</span><br><span class="line">   bstate.nthread++;</span><br><span class="line">   <span class="keyword">while</span>(bstate.nthread &lt; nthread)&#123;</span><br><span class="line">    pthread_cond_wait(&amp;(bstate.barrier_cond), &amp;(bstate.barrier_mutex));</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 此部分仅一个线程会进入</span></span><br><span class="line">   pthread_cond_broadcast(&amp;(bstate.barrier_cond));</span><br><span class="line">   bstate.nthread = <span class="number">0</span>;</span><br><span class="line">   bstate.round++;</span><br><span class="line">end:</span><br><span class="line">   pthread_mutex_unlock(&amp;(bstate.barrier_mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h1><blockquote>
<p>来到指导书最高点！太美丽了xv6。哎呀那不文件系统吗（</p>
<p>这里是自底向上讲起的。之后可以看看hit网课的自顶向下。</p>
</blockquote>
<blockquote>
<img src="/2023/01/10/xv6/image-20230121160555370.png" class>
</blockquote>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><img src="/2023/01/10/xv6/image-20230121160641718.png" class>

<blockquote>
<p>The disk layer reads and writes blocks on an virtio hard drive. </p>
<p>The buffer cache layer <strong>caches</strong> disk blocks and <strong>synchronizes</strong> access to them, making sure that only one kernel process at a time can modify the data stored in any particular block. </p>
<p>The logging layer allows higher layers to <strong>wrap updates</strong> to several blocks in a <em>transaction</em>, and ensures that the blocks are updated atomically in the face of crashes (i.e., all of them are updated or none). 【日志记录层允许更高层将更新包装到一个<em>事务</em>中的多个块，并确保在崩溃时以原子方式更新块（即，所有块都更新或不更新）。可以类比一下数据库的那个概念。】</p>
<p>The inode layer provides individual files, each represented as an <em>inode</em> with a unique i-number and some blocks holding the file’s data. </p>
<p>The directory layer implements each directory as a <strong>special kind of inode</strong> whose content is a sequence of directory entries, each of which contains a file’s name and i-number. </p>
<p>The pathname layer provides hierarchical path names like /usr/rtm/xv6/fs.c, and resolves them with <strong>recursive</strong> lookup. </p>
<p>The file descriptor layer <strong>abstracts</strong> many Unix resources (e.g., pipes, devices, fifiles, etc.) using the file system interface, simplifying the lives of application programmers.</p>
</blockquote>
<img src="/2023/01/10/xv6/image-20230121162324747.png" class>

<blockquote>
<p>The file system must have a plan for where it stores inodes and content blocks on the disk. To do so, xv6 divides the disk into several sections, as Figure 8.2 shows.</p>
<p>The file system does not use block 0 (it holds the boot sector). </p>
<p>Block 1 is called the <strong>superblock</strong>; it contains <strong>metadata</strong> about the file system (the file system size in blocks, the number of data blocks, the number of inodes, and the number of blocks in the log). The superblock is filled in by a separate program, called <code>mkfs</code>, which builds an <strong>initial</strong> file system.</p>
<p>Blocks starting at 2 hold the log. </p>
<p>After the log are the inodes, with multiple inodes per block. </p>
<p>After those come bitmap blocks tracking which data blocks are in use. 【应该是用来标识每个块是否空闲的吧】</p>
<p>The remaining blocks are data blocks; each is either marked free in the bitmap block, or holds content for a file or directory【要么空闲要么是文件或目录】. </p>
</blockquote>
<h2 id="Buffer-cache-1"><a href="#Buffer-cache-1" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><blockquote>
<p>The buffer cache has two jobs: </p>
<ol>
<li><strong>synchronize</strong> access to disk blocks to ensure that only one copy of a block is in memory and that only one kernel thread at a time uses that copy; </li>
<li><strong>cache</strong> <u>popular blocks</u> so that they don’t need to be re-read from the slow disk. </li>
</ol>
<p>The code is in <code>bio.c</code>.</p>
<p>Buffer cache中保存磁盘块的缓冲区数量固定，这意味着如果文件系统请求还未存放在缓存中的块，Buffer cache必须回收当前保存其他块内容的缓冲区。Buffer cache为新块回收最近使用最少的缓冲区。这样做的原因是认为最近使用最少的缓冲区是最不可能近期再次使用的缓冲区。</p>
</blockquote>
<img src="/2023/01/10/xv6/image-20230124151719288.png" class>

<h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?缓冲区是否包含块的副本</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?缓冲区内容是否已交给磁盘</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这应该代表着一个磁盘块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<p>大概buf数组里存储着所有buf的内容。buf本身通过最近使用排序的双向链表连接，head是链表的头。</p>
<h3 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called by main.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  <span class="comment">// 把b插在head之后</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上层接口"><a href="#上层接口" class="headerlink" title="上层接口"></a>上层接口</h3><blockquote>
<p>The main interface exported by the buffer cache consists of <code>bread</code> and <code>bwrite</code>.</p>
<p>The buffer cache uses a per-buffer sleep-lock to ensure concurrent security.</p>
</blockquote>
<h4 id="bread"><a href="#bread" class="headerlink" title="bread"></a>bread</h4><blockquote>
<p><code>bread</code> obtains a buf containing a copy of a block which can be read or modified in memory.</p>
<p>依据给定设备号和给定扇区号寻找cache的buf。返回的buf是locked的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a locked buf with the contents of the indicated block.</span></span><br><span class="line"><span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取buf块</span></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line">    <span class="comment">// 说明cache未命中，需要从磁盘读入</span></span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bwrite"><a href="#bwrite" class="headerlink" title="bwrite"></a>bwrite</h4><blockquote>
<p>writes a modified buffer to the appropriate block on the disk</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 必须持有b的锁</span></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  <span class="comment">// 写入磁盘</span></span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="brelse-1"><a href="#brelse-1" class="headerlink" title="brelse"></a>brelse</h4><blockquote>
<p> A kernel thread must release a buffer by calling brelse when it is done with it.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    <span class="comment">// 移动到头结点和头结点的下一个结点之间的位置</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><h4 id="bget-1"><a href="#bget-1" class="headerlink" title="bget"></a>bget</h4><p>用于获取cache中是否存在block。如果不存在，则新申请一个buf，并把该buf以上锁状态返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="comment">// 这个循环条件很有意思，充分用到了双向链表的特性</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      <span class="comment">// 引用数增加</span></span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      <span class="comment">// 锁定</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="comment">// 从尾部开始遍历，确实就是最少使用的了</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="comment">// 如果该buf空闲</span></span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      <span class="comment">// 仅是新建了一个buf，还未从磁盘读取对应磁盘块的副本，因而设valid为0以供上层函数调用处理</span></span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      <span class="comment">// 锁定</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cache不够用了</span></span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Logging-layer"><a href="#Logging-layer" class="headerlink" title="Logging layer"></a>Logging layer</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>Xv6通过简单的日志记录形式解决了文件系统操作期间的崩溃问题。</p>
<p>xv6系统调用不会直接写入磁盘上的文件系统数据结构。相反，它会在磁盘上的<em>log</em>（日志）中放置它希望进行的所有磁盘写入的描述。一旦系统调用记录了它的所有写入操作，它就会向磁盘写入一条特殊的<em>commit</em>（提交）记录，表明日志包含一个完整的操作。此时，系统调用将写操作复制到磁盘上的文件系统数据结构。完成这些写入后，系统调用将擦除磁盘上的日志。</p>
</blockquote>
<blockquote>
<p>如果系统崩溃并重新启动，则在运行任何进程之前，文件系统代码将按如下方式从崩溃中恢复：</p>
<p>如果日志标记为包含完整操作，则恢复代码会将写操作复制到磁盘文件系统中它们所属的位置，然后擦除日志。如果日志没有标记为包含完整操作，则恢复代码将忽略该日志，然后擦除日志。</p>
</blockquote>
<p>这就保证了原子性。</p>
<h3 id="Log-design"><a href="#Log-design" class="headerlink" title="Log design"></a>Log design</h3><img src="/2023/01/10/xv6/image-20230121162324747.png" class>

<p>superblock记录了log的存储位置。</p>
<blockquote>
<p>它由一个头块（header block）和一系列更新块的副本（logged block）组成。</p>
<p>头块包含一个扇区号（sector）数组（每个logged block对应一个扇区号）以及日志块的计数。</p>
<p>磁盘上的头块中的计数为零表示日志中没有事务，为非零表示日志包含一个完整的已提交事务，并具有指定数量的logged block。</p>
<p>在事务提交（commit）时Xv6才向头块写入数据，在此之前不会写入。在将logged blocks复制到文件系统后，头块的计数将被设置为零。</p>
<p>因此，事务中途崩溃将导致日志头块中的计数为零；提交后的崩溃将导致非零计数。</p>
</blockquote>
<blockquote>
<p>为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写入累积到一个事务中。因此，单个提交可能涉及多个完整系统调用的写入。为了避免在事务之间拆分系统调用，日志系统仅在没有文件系统调用进行时提交。</p>
<p>同时提交多个事务的想法称为组提交（group commit）。组提交减少了磁盘操作的数量，因为成本固定的一次提交分摊了多个操作。组提交还同时为磁盘系统提供更多并发写操作，可能允许磁盘在一个磁盘旋转时间内写入所有这些操作。Xv6的virtio驱动程序不支持这种批处理，但是Xv6的文件系统设计允许这样做。</p>
<p>【这感觉实现得也还挺简略的】</p>
</blockquote>
<blockquote>
<p>Xv6在磁盘上留出固定的空间来保存日志。事务中系统调用写入的块总数必须可容纳于该空间。这导致两个后果：</p>
<ol>
<li><p>任何单个系统调用都不允许写入超过日志空间的不同块。</p>
<p>【这段话我一个字没看懂】</p>
<p>这对于大多数系统调用来说都不是问题，但其中两个可能会写入许多块：<code>write</code>和<code>unlink</code>。一个大文件的<code>write</code>可以写入多个数据块和多个位图块以及一个inode块；<code>unlink</code>大文件可能会写入许多位图块和inode。Xv6的<code>write</code>系统调用将大的写入分解为适合日志的多个较小的写入，<code>unlink</code>不会导致此问题，因为实际上Xv6文件系统只使用一个位图块。</p>
</li>
<li><p>日志空间有限的另一个后果是，除非确定系统调用的写入将可容纳于日志中剩余的空间，否则日志系统无法允许启动系统调用。</p>
</li>
</ol>
</blockquote>
<h3 id="Code-logging"><a href="#Code-logging" class="headerlink" title="Code: logging"></a>Code: logging</h3><blockquote>
<p>log的原理是这样的：</p>
<p>在每个系统调用的开始调用<code>begin_op</code>表示事务开始，然后之后新申请一块block，也即把该block的内容读入内存，并且把该block的blockno记录到log的header中。此后程序正常修改在内存中的block，磁盘中的block保持不变。最后commit的时候遍历log header中的blockno，一块块地把内存中的block写入日志和磁盘中。</p>
<p>如果程序在commit前崩溃，则内存消失，同时磁盘也不会写入；如果在commit后崩溃，那也无事发生。</p>
<p>在每次启动的时候，都会执行log的初始化，届时可以顺便恢复数据。</p>
<p>完美实现了日志的功能。</p>
</blockquote>
<img src="/2023/01/10/xv6/image-20230123212753931.png" class>

<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Contents of the header block, used for both the on-disk header block</span></span><br><span class="line"><span class="comment">// and to keep track in memory of logged block# before commit.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="comment">// 扇区号也即blockno的数组</span></span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表log磁盘块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> start;<span class="comment">// log磁盘块的开始。start开始的第一块为log header，之后皆为写入的block</span></span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// how many FS sys calls are executing.</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// in commit(), please wait.</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h4><h5 id="begin-op"><a href="#begin-op" class="headerlink" title="begin_op()"></a>begin_op()</h5><blockquote>
<p><code>begin_op</code>等待直到日志系统当前未处于提交中，并且直到有足够的未被占用的日志空间来保存此调用的写入。</p>
<p><code>log.outstanding</code>统计<strong>预定了日志空间</strong>的系统调用数；为此保留的总空间为<code>log.outstanding</code>乘以<code>MAXOPBLOCKS</code>（10）。递增<code>log.outstanding</code>会预定空间并防止在此系统调用期间发生提交（if的第二个分支）。代码保守地假设每个系统调用最多可以写入<code>MAXOPBLOCKS</code>（10）个不同的块。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the start of each FS system call.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">begin_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 正在提交则等待日志空闲</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;</span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="comment">// 日志空间不足则等待空间充足</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">// this op might exhaust log space此操作可能会耗尽日志空间; wait for commit.</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="log-write"><a href="#log-write" class="headerlink" title="log_write"></a>log_write</h5><blockquote>
<p><code>log_write</code>充当<code>bwrite</code>的代理。它将块的扇区号记录在内存中，在磁盘上的日志中预定一个槽位，并调用<code>bpin</code>将缓存固定在block cache中，以防止block cache将其逐出【具体原理就是让refcnt++，这样就不会被当成空闲block用掉了】。</p>
<p>为啥要防止换出呢？换出不是就正好自动写入磁盘了吗？这里一是为了保障前面提到的原子性，防止换入换出导致的单一写入磁盘；二是换出自动写入的是磁盘对应位而不一定是日志所在的blocks。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">log_write</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log</span></span><br><span class="line">  <span class="comment">// 30</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="comment">// log_write会注意到在单个事务中多次写入一个块的情况，并在日志中为该块分配相同的槽位。</span></span><br><span class="line">  <span class="comment">// 这种优化通常称为合并（absorption）</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorbtion</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里还是挺巧妙的。</span></span><br><span class="line">  <span class="comment">// 如果存在log.lh.block[i] == b-&gt;blockno的情况，执行此句话也无妨</span></span><br><span class="line">  <span class="comment">// 如果不存在，则给log新增一块，填入log.lh.block[log.lh.n]的位置，再++log.lh.n</span></span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log?</span></span><br><span class="line">    bpin(b);</span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="end-op"><a href="#end-op" class="headerlink" title="end_op"></a>end_op</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the end of each FS system call.</span></span><br><span class="line"><span class="comment">// 如果这是最后一层outstanding就会执行commit操作</span></span><br><span class="line"><span class="comment">// commits if this was the last outstanding operation.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// begin_op() may be waiting for log space,</span></span><br><span class="line">    <span class="comment">// and decrementing log.outstanding has decreased</span></span><br><span class="line">    <span class="comment">// the amount of reserved space.</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    <span class="comment">// call commit w/o holding locks, since not allowed</span></span><br><span class="line">    <span class="comment">// to sleep with locks.</span></span><br><span class="line">    commit();</span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// cache -&gt; log block</span></span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    <span class="comment">// head(in stack/heap) -&gt; log block</span></span><br><span class="line">    <span class="comment">// 此可以说为commit完成的标志。</span></span><br><span class="line">    <span class="comment">// 因为无论接下来是否崩溃，数据最终都会被写入disk，不同在于是在recover时还是接下来写入</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    <span class="comment">// log block -&gt; real position</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 擦除</span></span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="write-log"><a href="#write-log" class="headerlink" title="write_log"></a>write_log</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy modified blocks from cache to log.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">    brelse(from);<span class="comment">// 此处的brelse呼应了外界调用的bread</span></span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="write-head"><a href="#write-head" class="headerlink" title="write_head"></a>write_head</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write in-memory log header to disk.</span></span><br><span class="line"><span class="comment">// 这是事务提交的标志</span></span><br><span class="line"><span class="comment">// This is the true point at which the</span></span><br><span class="line"><span class="comment">// current transaction commits.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf);</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="install-trans"><a href="#install-trans" class="headerlink" title="install_trans"></a>install_trans</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy committed blocks from log to their home location</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">install_trans</span><span class="params">(<span class="type">int</span> recovering)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// read log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// read dst</span></span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="comment">// copy block to dst</span></span><br><span class="line">    bwrite(dbuf);  <span class="comment">// write dst to disk</span></span><br><span class="line">    <span class="keyword">if</span>(recovering == <span class="number">0</span>)</span><br><span class="line">      bunpin(dbuf);<span class="comment">// 如果不是在recover的过程中</span></span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="恢复与初始化"><a href="#恢复与初始化" class="headerlink" title="恢复与初始化"></a>恢复与初始化</h4><p>上面介绍了log的一次事务提交的流程。接下来介绍它是怎么恢复的。</p>
<blockquote>
<p><code>recover_from_log</code>是由<code>initlog</code>调用的，而它又是在第一个用户进程运行之前的引导期间由<code>fsinit</code>调用的。</p>
</blockquote>
<h5 id="第一个进程运行之前"><a href="#第一个进程运行之前" class="headerlink" title="第一个进程运行之前"></a>第一个进程运行之前</h5><p>由前面scheduler一章的知识可知，每个进程被初次调度的时候会先来执行<code>forkret</code>。这时候就做了log的恢复工作。</p>
<p>注释解释了为什么不选择在<code>main.c</code>中初始化，而选择在此处初始化。确实，它需要调用sleep，如果在main.c中调用sleep感觉会乱套（）毕竟那时候scheduler线程尚未被初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A fork child&#x27;s very first scheduling by scheduler()</span></span><br><span class="line"><span class="comment">// will swtch to forkret.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// static变量仅会被初始化一次</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Still holding p-&gt;lock from scheduler.</span></span><br><span class="line">  release(&amp;myproc()-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是第一个进程</span></span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    <span class="comment">// File system initialization must be run in the context of a</span></span><br><span class="line">    <span class="comment">// regular process (e.g., because it calls sleep), and thus cannot</span></span><br><span class="line">    <span class="comment">// be run from main().</span></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    fsinit(ROOTDEV);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fsinit"><a href="#fsinit" class="headerlink" title="fsinit"></a>fsinit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init fs</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fsinit</span><span class="params">(<span class="type">int</span> dev)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  initlog(dev, &amp;sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="initlog"><a href="#initlog" class="headerlink" title="initlog"></a>initlog</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlog</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> logheader) &gt;= BSIZE)</span><br><span class="line">    panic(<span class="string">&quot;initlog: too big logheader&quot;</span>);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;<span class="built_in">log</span>.lock, <span class="string">&quot;log&quot;</span>);</span><br><span class="line">  <span class="comment">// 从super block中获取必要参数</span></span><br><span class="line">  <span class="built_in">log</span>.start = sb-&gt;logstart;</span><br><span class="line">  <span class="built_in">log</span>.size = sb-&gt;nlog;</span><br><span class="line">  <span class="built_in">log</span>.dev = dev;</span><br><span class="line">  recover_from_log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="recover-from-log"><a href="#recover-from-log" class="headerlink" title="recover_from_log"></a>recover_from_log</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 读取head</span></span><br><span class="line">  read_head();</span><br><span class="line">  <span class="comment">// 注意，commit中会把header写入log block，而这里从log block读出header</span></span><br><span class="line">  <span class="comment">// 也就是说，如果header的n不为零，那么说明已经commit了，但可能未写入，重复写入保障安全</span></span><br><span class="line">  <span class="comment">// 如果header的n为零，说明未commit，在install_trans的逻辑中会什么也不做</span></span><br><span class="line">  <span class="comment">// 两种情况完美满足</span></span><br><span class="line">  install_trans(<span class="number">1</span>); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 擦除</span></span><br><span class="line">  write_head(); <span class="comment">// clear the log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Block-allocator"><a href="#Code-Block-allocator" class="headerlink" title="Code: Block allocator"></a>Code: Block allocator</h2><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>说实话没怎么懂，也不大清楚它有什么用，先大概推测一下：</p>
<p>之前的bread和bwrite这些，就是你给一个设备号和扇区号，它就帮你加载进内存cache。你如果要用的话，肯定还是使用地址方便。所以block allocator的作用之一就是给bread和bwrite加一层封装，将获取的block封装为地址返回，你可以直接操纵这个地址，<strong>而无需知道下层的细节。</strong></p>
<p>这个过程要注意的有两点：</p>
<ol>
<li><p>封装返回的地址具体是什么，怎么工作的</p>
<p>封装返回的地址实质上是buffer cache中的buf的data字段的地址【差不多】。之后的上层应用在该地址上写入，也即写入了buf，最后会通过log层真正写入磁盘。</p>
</li>
<li><p>结合bcache的LRU，详细谈谈工作机制</p>
<p>我们可以看到，在balloc中有这么一段逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> b + bi;</span><br></pre></td></tr></table></figure>

<p>看到的第一反应就是，我们需求的那块buf是bp，但是这里先是bread了一次，又是brelse了一次，这样bp的refcnt不就为0，很容易被替换掉了吗？</p>
<p>会有这个反应，一定程度上是因为没有很好地理解LRU。事实上，正是它可能被替换掉，才满足了LRU的条件。因为它可能被替掉才能说明它可能是最近最少使用的。</p>
</li>
</ol>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><blockquote>
<p>文件和目录内容存储在磁盘块中，磁盘块必须从空闲池中分配。xv6的块分配器在磁盘上维护一个空闲位图，每一位代表一个块。0表示对应的块是空闲的；1表示它正在使用中。</p>
<p>引导扇区、超级块、日志块、inode块和位图块的比特位是由程序<code>mkfs</code>初始化设置的：</p>
<img src="/2023/01/10/xv6/image-20230123234919055.png" class>
</blockquote>
<h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3><p>类似于memory allocator，块分配器也提供了两个函数：<code>bfree</code>和<code>balloc</code>。</p>
<h4 id="balloc"><a href="#balloc" class="headerlink" title="balloc"></a>balloc</h4><blockquote>
<p><code>Balloc</code>从块0到<code>sb.size</code>（文件系统中的块数）遍历每个块。它查找位图中位为零的空闲块。如果<code>balloc</code>找到这样一个块，它将更新位图并返回该块。</p>
<p>为了提高效率，循环被分成两部分。外部循环读取位图中的每个块。内部循环检查单个位图块中的所有BPB位。由于任何一个位图块在buffer cache中一次只允许一个进程使用【<code> bread(dev, BBLOCK(b, sb))</code>会返回一个上锁的block，<code>bread</code>和<code>brelse</code>隐含的独占使用避免了显式锁定的需要】，因此，如果两个进程同时尝试分配一个块也是并发安全的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a zeroed disk block.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">balloc</span><span class="params">(uint dev)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> b, bi, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  bp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(b = <span class="number">0</span>; b &lt; sb.size; b += BPB)&#123;</span><br><span class="line">    bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">    <span class="keyword">for</span>(bi = <span class="number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;</span><br><span class="line">      m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)&#123;  <span class="comment">// Is block free?</span></span><br><span class="line">        bp-&gt;data[bi/<span class="number">8</span>] |= m;  <span class="comment">// Mark block in use.</span></span><br><span class="line">        log_write(bp);</span><br><span class="line">        brelse(bp);</span><br><span class="line">        bzero(dev, b + bi);</span><br><span class="line">        <span class="keyword">return</span> b + bi;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;balloc: out of blocks&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bfree"><a href="#bfree" class="headerlink" title="bfree"></a>bfree</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a disk block.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="type">int</span> bi, m;</span><br><span class="line"></span><br><span class="line">  bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">  bi = b % BPB;</span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">  bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Inode-layer"><a href="#Inode-layer" class="headerlink" title="Inode layer"></a>Inode layer</h2><h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><blockquote>
<p>术语inode（即索引结点）可以具有两种相关含义之一。它可能是指包含文件大小和数据块编号列表的磁盘上的数据结构【on-disk inode】。或者“inode”可能指内存中的inode【in-memory inode】，它包含磁盘上inode的副本以及内核中所需的额外信息。</p>
</blockquote>
<img src="/2023/01/10/xv6/image-20230121162324747.png" class>

<h4 id="on-disk-inode"><a href="#on-disk-inode" class="headerlink" title="on-disk inode"></a>on-disk inode</h4><blockquote>
<p>The on-disk inodes are packed into a contiguous area of disk called the inode blocks. </p>
<p>Every inode is the <strong>same size,</strong> so it is easy, given a number n, to find the nth inode on the disk. In fact, this number n, called the <strong>inode number</strong> or <strong>i-number</strong>, is how inodes are <strong>identifified</strong> in the implementation.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in fs.h</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 为0表示free</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="comment">//  The nlink field counts the number of directory entries that refer to this inode,</span></span><br><span class="line">  <span class="comment">//  in order to recognize when the on-disk inode and its data blocks should be freed.</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="in-memory-inode"><a href="#in-memory-inode" class="headerlink" title="in-memory inode"></a>in-memory inode</h4><blockquote>
<p>The kernel keeps the set of active inodes in memory.</p>
<p>The kernel stores an inode in memory <strong>only</strong> if there are C pointers referring to that inode.当且仅当ref==0才会从内核中释放。</p>
<p>如果nlinks==0就会从物理block中释放。</p>
<p>The <code>iget</code> and <code>iput</code> functions acquire and release pointers to an inode, modifying the reference count.【相当于buffer cache的<code>balloc</code>和<code>bfree</code>】Pointers to an inode can come from file descriptors, current working directories, and transient kernel code such as exec.</p>
<p><code>iget</code>返回的<code>struct inode</code>可能没有任何有用的内容。为了确保它保存磁盘inode的副本，代码必须调用<code>ilock</code>。这将锁定inode（以便没有其他进程可以对其进行<code>ilock</code>），并从磁盘读取尚未读取的inode。<code>iunlock</code>释放inode上的锁。将inode指针的获取与锁定分离有助于在某些情况下避免死锁，例如在目录查找期间。多个进程可以持有指向<code>iget</code>返回的inode的C指针，但一次只能有一个进程锁定inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];<span class="comment">// 存储着inode数据的blocks的地址，从balloc中获取</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Code-inode"><a href="#Code-inode" class="headerlink" title="Code: inode"></a>Code: inode</h3><blockquote>
<p>主要是在讲inode layer这一层的方法，以及给上层提供的接口。</p>
</blockquote>
<h4 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h4><img src="/2023/01/10/xv6/image-20230124153309132.png" class>

<h4 id="底层接口"><a href="#底层接口" class="headerlink" title="底层接口"></a>底层接口</h4><blockquote>
<p><code>iget</code> <code>iput</code> </p>
</blockquote>
<h5 id="iget"><a href="#iget" class="headerlink" title="iget"></a>iget</h5><p>逻辑还是跟buffer cache非常相似的，不过可以看出这个的数据结构简单许多，也不用实现LRU。</p>
<blockquote>
<p>A struct inode pointer returned by iget() is <strong>guaranteed to be valid</strong> until the corresponding call to iput()： the inode <u>won’t be deleted</u>, and the memory referred to by the pointer <u>won’t be re-used</u> for a different inode. 【通过ref++实现。】</p>
<p>不同于buffer cache的<code>bget</code>，<code>iget()</code>提供对inode的非独占访问，因此可以有许多指向同一inode的指针。文件系统代码的许多部分都依赖于<code>iget()</code>的这种行为，既可以保存对inode的长期引用（如打开的文件和当前目录），也可以防止争用，同时避免操纵多个inode（如路径名查找）的代码产生死锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the inode with number inum on device dev</span></span><br><span class="line"><span class="comment">// and return the in-memory copy. Does not lock</span></span><br><span class="line"><span class="comment">// the inode and does not read it from disk.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">iget</span><span class="params">(uint dev, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the inode already cached?</span></span><br><span class="line">  empty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ip = &amp;icache.inode[<span class="number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">      ip-&gt;ref++;</span><br><span class="line">      release(&amp;icache.lock);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于不用实现LRU，所以只需一次循环记录即可。</span></span><br><span class="line">    <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// Remember empty slot.</span></span><br><span class="line">      empty = ip;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recycle an inode cache entry.</span></span><br><span class="line">  <span class="keyword">if</span>(empty == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;iget: no inodes&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ip = empty;</span><br><span class="line">  ip-&gt;dev = dev;</span><br><span class="line">  ip-&gt;inum = inum;</span><br><span class="line">  ip-&gt;ref = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// does not read from disk</span></span><br><span class="line">  ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="iput"><a href="#iput" class="headerlink" title="iput"></a>iput</h5><blockquote>
<p><code>iput()</code>可以写入磁盘。这意味着任何使用文件系统的系统调用都可能写入磁盘，因为系统调用可能是最后一个引用该文件的系统调用。即使像<code>read()</code>这样看起来是只读的调用，也可能最终调用<code>iput()</code>。这反过来意味着，即使是只读系统调用，如果它们使用文件系统，也必须在事务中进行包装。</p>
<p><code>iput()</code>和崩溃之间存在一种具有挑战性的交互。<code>iput()</code>不会在文件的链接计数降至零时立即截断文件，因为某些进程可能仍在内存中保留对inode的引用：进程可能仍在读取和写入该文件，因为它已成功打开该文件。但是，如果在最后一个进程关闭该文件的文件描述符之前发生崩溃，则该文件将被标记为已在磁盘上分配，但没有目录项指向它。如果不做任何处理措施的话，这块磁盘就再也用不了了。</p>
<p>文件系统以两种方式之一处理这种情况。简单的解决方案用于恢复时：重新启动后，文件系统会扫描整个文件系统，以查找标记为已分配但没有指向它们的目录项的文件。如果存在任何此类文件，接下来可以将其释放。</p>
<p>第二种解决方案不需要扫描文件系统。在此解决方案中，文件系统在磁盘（例如在超级块中）上记录链接计数降至零但引用计数不为零的文件的i-number。如果文件系统在其引用计数达到0时删除该文件，则会通过从列表中删除该inode来更新磁盘列表。重新启动时，文件系统将释放列表中的所有文件。</p>
<p>Xv6没有实现这两种解决方案，这意味着inode可能被标记为已在磁盘上分配，即使它们不再使用。这意味着随着时间的推移，xv6可能会面临磁盘空间不足的风险。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Drop a reference to an in-memory inode.</span></span><br><span class="line"><span class="comment">// If that was the last reference, the inode cache entry can</span></span><br><span class="line"><span class="comment">// be recycled.【refvnt==0 可以回收】</span></span><br><span class="line"><span class="comment">// 注意这个回收过程无需特别处理，只需自然--refcnt就行，不用像buffer cache那么烦</span></span><br><span class="line"><span class="comment">// If that was the last reference and the inode has no links</span></span><br><span class="line"><span class="comment">// to it, free the inode (and its content) on disk.【nlinks==0 copy和本体都得扔掉】</span></span><br><span class="line"><span class="comment">// All calls to iput() must be inside a transaction in</span></span><br><span class="line"><span class="comment">// case it has to free the inode.任何需要iput的地方都需要包裹在事务内，因为它可能会释放inode</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;ref == <span class="number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// inode has no links and no other references: truncate and free.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ip-&gt;ref == 1 means no other process can have ip locked,</span></span><br><span class="line">    <span class="comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span></span><br><span class="line">    acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    release(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终调用bfree，会标记bitmap，完全释放block</span></span><br><span class="line">    itrunc(ip);</span><br><span class="line">    ip-&gt;type = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/*iupdate:</span></span><br><span class="line"><span class="comment">    // Copy a modified in-memory inode to disk.</span></span><br><span class="line"><span class="comment">    // Must be called after every change to an ip-&gt;xxx field</span></span><br><span class="line"><span class="comment">	// that lives on disk, since i-node cache is write-through.</span></span><br><span class="line"><span class="comment">	write-through:</span></span><br><span class="line"><span class="comment">	CPU向cache写入数据时，同时向memory(后端存储)也写一份，使cache和memory的数据保持一致。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 这里修改的type是dinode也有的字段，所以需要update一下。</span></span><br><span class="line">    <span class="comment">// 下面的valid是dinode没有的字段，所以随便改，无需update</span></span><br><span class="line">    iupdate(ip);</span><br><span class="line">    ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    releasesleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;icache.lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;ref--;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上层接口-1"><a href="#上层接口-1" class="headerlink" title="上层接口"></a>上层接口</h4><h5 id="获取和释放inode"><a href="#获取和释放inode" class="headerlink" title="获取和释放inode"></a>获取和释放inode</h5><h6 id="ialloc"><a href="#ialloc" class="headerlink" title="ialloc"></a>ialloc</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate an inode on device dev.</span></span><br><span class="line"><span class="comment">// Mark it as allocated by  giving it type type.</span></span><br><span class="line"><span class="comment">// Returns an unlocked but allocated and referenced inode.</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">ialloc</span><span class="params">(uint dev, <span class="type">short</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;</span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// a free inode通过type判断是否free</span></span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));<span class="comment">// zerod</span></span><br><span class="line">      dip-&gt;type = type;</span><br><span class="line">      log_write(bp);   <span class="comment">// mark it allocated on the disk</span></span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;ialloc: no inodes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="inode的锁保护"><a href="#inode的锁保护" class="headerlink" title="inode的锁保护"></a>inode的锁保护</h5><p>前面说到，inode的设计使得有多个指针同时指向一个inode成为了可能。因而，修改使用inode的时候就要对其进行独占访问。使用<code>ialloc</code>获取和用<code>ifree</code>释放的inode必须被保护在<code>ilock</code>和<code>iunlock</code>区域中。</p>
<h6 id="ilock"><a href="#ilock" class="headerlink" title="ilock"></a>ilock</h6><p><code>ilock</code>既可以实现对inode的独占访问，同时也可以给未初始化的inode进行初始化工作。</p>
<blockquote>
<p><code>iget</code>返回的<code>struct inode</code>可能没有任何有用的内容。为了确保它保存磁盘inode的副本，代码必须调用<code>ilock</code>。这将锁定inode（以便没有其他进程可以对其进行<code>ilock</code>），并从磁盘读取尚未读取的inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock the given inode and reads the inode from disk if necessary.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ilock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;ilock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 通过inode索引号和superblock算出扇区号</span></span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    <span class="comment">// 填充ip</span></span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">    ip-&gt;major = dip-&gt;major;</span><br><span class="line">    ip-&gt;minor = dip-&gt;minor;</span><br><span class="line">    ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="iunlock"><a href="#iunlock" class="headerlink" title="iunlock"></a>iunlock</h6><blockquote>
<p><code>iunlock</code>释放inode上的锁。</p>
<p>将inode指针的获取与锁定分离有助于在某些情况下避免死锁，例如在目录查找期间。多个进程可以持有指向<code>iget</code>返回的inode的C指针，但一次只能有一个进程锁定inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock the given inode.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iunlock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;iunlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Code-inode-content"><a href="#Code-inode-content" class="headerlink" title="Code: inode content"></a>Code: inode content</h3><h4 id="Overview-2"><a href="#Overview-2" class="headerlink" title="Overview"></a>Overview</h4><blockquote>
<p>主要讲的是inode本身存储数据的结构</p>
</blockquote>
<blockquote>
<p>磁盘上的inode结构体<code>struct dinode</code>包含一个<code>size</code>和一个块号数组（见图8.3），数组内罗列着存储着该inode数据的块号。</p>
<p>前面的<code>NDIRECT</code>个数据块被列在数组中的前<code>NDIRECT</code>个元素中；这些块称为直接块（direct blocks）。接下来的<code>NINDIRECT</code>个数据块不在inode中列出，而是在称为间接块（indirect block）的数据块中列出。<code>addrs</code>数组中的最后一个元素给出了间接块的地址。</p>
<p>因此，可以从inode中列出的块加载文件的前12 kB（<code>NDIRECT x BSIZE</code>）字节，而只有在查阅间接块后才能加载下一个256 kB（<code>NINDIRECT x BSIZE</code>）字节。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/01/10/xv6/image-20230124163025094.png" class>

<h4 id="bmap"><a href="#bmap" class="headerlink" title="bmap"></a>bmap</h4><blockquote>
<p>函数<code>bmap</code>负责封装这个寻找数据块的过程，以便实现我们将很快看到的如<code>readi</code>和<code>writei</code>这样的更高级例程。</p>
<p><code>bmap(struct inode *ip, uint bn)</code>返回inode<code>ip</code>的第<code>bn</code>个数据块的磁盘块号。如果<code>ip</code>还没有这样的块，<code>bmap</code>会分配一个。</p>
<p><code>Bmap</code>使<code>readi</code>和<code>writei</code>很容易获取inode的数据。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inode content</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The content (data) associated with each inode is stored</span></span><br><span class="line"><span class="comment">// in blocks on the disk. The first NDIRECT block numbers</span></span><br><span class="line"><span class="comment">// are listed in ip-&gt;addrs[].  The next NINDIRECT blocks are</span></span><br><span class="line"><span class="comment">// listed in block ip-&gt;addrs[NDIRECT].</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip.</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果为direct block</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 如果为indirect block</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 如果没有，会分配一个</span></span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="itrunc"><a href="#itrunc" class="headerlink" title="itrunc"></a>itrunc</h4><blockquote>
<p><code>itrunc</code>释放文件的块，将inode的<code>size</code>重置为零。</p>
<p><code>Itrunc</code>首先释放直接块，然后释放间接块中列出的块，最后释放间接块本身。</p>
</blockquote>
<h4 id="readi"><a href="#readi" class="headerlink" title="readi"></a>readi</h4><blockquote>
<p><code>readi</code>和<code>writei</code>都是从检查<code>ip-&gt;type == T_DEV</code>开始的。这种情况处理的是数据不在文件系统中的特殊设备；我们将在文件描述符层返回到这种情况。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read data from inode.数据大小为n，从off开始，读到dst处</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="comment">// If user_dst==1, then dst is a user virtual address;</span></span><br><span class="line"><span class="comment">// otherwise, dst is a kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">readi</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; ip-&gt;size)</span><br><span class="line">    n = ip-&gt;size - off;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主循环处理文件的每个块，将数据从缓冲区复制到dst</span></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      tot = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="writei"><a href="#writei" class="headerlink" title="writei"></a>writei</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write data to inode.</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="comment">// If user_src==1, then src is a user virtual address;</span></span><br><span class="line"><span class="comment">// otherwise, src is a kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">writei</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_src, uint64 src, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// writei会自动增长文件，除非达到文件的最大大小</span></span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; MAXFILE*BSIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      n = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(off &gt; ip-&gt;size)</span><br><span class="line">      <span class="comment">// 说明扩大了文件大小，需要修改</span></span><br><span class="line">      ip-&gt;size = off;</span><br><span class="line">    <span class="comment">// write the i-node back to disk even if the size didn&#x27;t change</span></span><br><span class="line">    <span class="comment">// because the loop above might have called bmap() and added a new</span></span><br><span class="line">    <span class="comment">// block to ip-&gt;addrs[].</span></span><br><span class="line">    iupdate(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stati"><a href="#stati" class="headerlink" title="stati"></a>stati</h4><blockquote>
<p>函数<code>stati</code>将inode元数据复制到<code>stat</code>结构体中，该结构通过<code>stat</code>系统调用向用户程序公开。</p>
</blockquote>
<p>在<code>defs.h</code>中可看到inode结构体是private的，而stat是public的。</p>
<h2 id="Directory-layer"><a href="#Directory-layer" class="headerlink" title="Directory layer"></a>Directory layer</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>目录的内部实现很像文件。其inode的<code>type</code>为<code>T_DIR</code>，其数据是directory entries的集合。</p>
<p>每个entry都是一个<code>struct dirent</code>。</p>
</blockquote>
<p><strong>也就是说这一层其实本质上是一个大小一定的map</strong>，该map自身也存放在inode中，大小为inode的大小，每个表项entry<strong>映射了目录名和文件inode</strong>。所以接下来介绍的函数我们完全可以从hashmap增删改查的角度去理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;<span class="comment">// 如果为0，说明该entry free</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/01/10/xv6/image-20230124173241241.png" class>

<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><h4 id="dirlookup"><a href="#dirlookup" class="headerlink" title="dirlookup"></a>dirlookup</h4><blockquote>
<p>函数<code>dirlookup</code>在directory中搜索具有给定名称的entry。</p>
<p>它返回的指向enrty.inum相应的inode是非独占的【通过iget获取】，也即无锁状态。它还会把<code>*poff</code>设置为所需的entry的字节偏移量。</p>
<p>为什么要返回未锁定的inode？是因为调用者已锁定<code>dp</code>，因此，如果对<code>.</code>进行查找，则在返回之前尝试锁定inode将导致重新锁定<code>dp</code>并产生死锁【确实】(还有更复杂的死锁场景，涉及多个进程和<code>..</code>，父目录的别名。<code>.</code>不是唯一的问题。）</p>
<p>所以锁定交给caller来做。caller可以解锁<code>dp</code>，然后锁定该函数返回的<code>ip</code>，确保它一次只持有一个锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look for a directory entry in a directory.</span></span><br><span class="line"><span class="comment">// If found, set *poff to byte offset of entry.</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">dirlookup</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint *poff)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint off, inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;type != T_DIR)</span><br><span class="line">    panic(<span class="string">&quot;dirlookup not DIR&quot;</span>);</span><br><span class="line">  <span class="comment">// new level of abstraction,可以把directory的inode看作一个表文件，每个表项都是一个entry</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="comment">// 从directory中获取entry，也即从inode中获取数据</span></span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlookup read&quot;</span>);</span><br><span class="line">    <span class="comment">// free</span></span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(namecmp(name, de.name) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// entry matches path element</span></span><br><span class="line">      <span class="keyword">if</span>(poff)</span><br><span class="line">        *poff = off;</span><br><span class="line">      inum = de.inum;</span><br><span class="line">      <span class="keyword">return</span> iget(dp-&gt;dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dirlink"><a href="#dirlink" class="headerlink" title="dirlink"></a>dirlink</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write a new directory entry (name, inum) into the directory dp.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dirlink</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that name is not present.</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Look for an empty dirent.</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlink read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没找到空闲的则调用writei自动增长inode，添加新表项</span></span><br><span class="line">  <span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">  de.inum = inum;</span><br><span class="line">  <span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">    panic(<span class="string">&quot;dirlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pathname-layer"><a href="#Pathname-layer" class="headerlink" title="Pathname layer"></a>Pathname layer</h2><blockquote>
<p>Path name lookup involves a succession of calls to dirlookup, one for each path component.</p>
</blockquote>
<h3 id="namei和nameiparent"><a href="#namei和nameiparent" class="headerlink" title="namei和nameiparent"></a>namei和nameiparent</h3><blockquote>
<p>Namei (kernel/fs.c:661) evaluates path and returns the corresponding inode.</p>
<p>函数<code>nameiparent</code>是一个变体：它在最后一个元素之前停止，返回父目录的inode并将最后一个元素复制到<code>name</code>中。两者都调用通用函数<code>namex</code>来完成实际工作。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">0</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">1</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="namex"><a href="#namex" class="headerlink" title="namex"></a>namex</h3><blockquote>
<p><code>Namex</code>首先决定路径解析的开始位置。</p>
<p>如果路径以“ / ”开始，则从根目录开始解析；否则，从当前目录开始。</p>
<p>然后，它使用<code>skipelem</code>依次考察路径的每个元素。循环的每次迭代都必须在当前索引结点<code>ip</code>中查找<code>name</code>。</p>
<p>迭代首先给<code>ip</code>上锁并检查它是否是一个目录。如果不是，则查找失败。</p>
<p>如果caller是<code>nameiparent</code>，并且这是最后一个路径元素，则根据<code>nameiparent</code>的定义，循环会提前停止；最后一个路径元素已经复制到<code>name</code>中【在上一轮循坏中做了这件事】，因此<code>namex</code>只需返回解锁的<code>ip</code>。</p>
<p>最后，循环将使用<code>dirlookup</code>查找路径元素，并通过设置<code>ip = next</code>为下一次迭代做准备。当循环用完路径元素时，它返回<code>ip</code>。</p>
<p>注：</p>
<ol>
<li>在每次迭代中锁定<code>ip</code>是必要的，不是因为<code>ip-&gt;type</code>可以被更改，而是因为在<code>ilock</code>运行之前，<code>ip-&gt;type</code>不能保证已从磁盘加载，所以得用到ilock保证一定会被加载的这个性质。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up and return the inode for a path name.</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes.</span></span><br><span class="line"><span class="comment">// Must be called inside a transaction since it calls iput().</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用skipelem依次考察路径的每个元素</span></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early.</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>namex</code>过程可能需要很长时间才能完成：它可能涉及多个磁盘操作来读取路径名中所遍历目录的索引节点和目录块（如果它们不在buffer cache中）。</p>
<p>Xv6 is carefully designed，如果一个内核线程对<code>namex</code>的调用在磁盘I/O上阻塞，另一个查找不同路径名的内核线程可以同时进行。<code>Namex</code> locks each directory in the path <strong>separately</strong> so that lookups in different directories can proceed in parallel.锁细粒度化</p>
<p>This concurrency introduces some challenges. For example, while one kernel thread is looking up a pathname another kernel thread may be changing the directory tree by unlinking a directory. A potential risk is that a lookup may be searching a directory that has been deleted by another kernel thread and its blocks have been re-used for another directory or file.一个潜在的风险是，查找可能正在搜索已被另一个内核线程删除且其块已被重新用于另一个目录或文件的目录。</p>
<p>Xv6避免了这种竞争，也就是说，你查到的inode保证暂时不会被释放，里面的内容还是真的，而不会被重新利用从而导致里面的内容变样。</p>
<p>例如，在<code>namex</code>中执行<code>dirlookup</code>时，lookup线程持有目录上的锁，<code>dirlookup</code>返回使用<code>iget</code>获得的inode。<code>Iget</code>增加索引节点的引用计数。只有在从<code>dirlookup</code>接收inode之后，<code>namex</code>才会释放目录上的锁。现在，另一个线程可以从目录中取消inode的链接，但是xv6还不会删除inode，<u>因为inode的引用计数仍然大于零</u>。</p>
<p>另一个风险是死锁。例如，查找“<code>.</code>”时，<code>next</code>指向与<code>ip</code>相同的inode【确实】。在释放<code>ip</code>上的锁之前锁定<code>next</code>将导致死锁【为什么？？？难道不是会由于在acquire时已经持有锁，从而爆<code>panic(&quot;acquire&quot;)</code>吗？】。为了避免这种死锁，<code>namex</code>在获得下一个目录的锁之前解锁该目录。这里我们再次看到为什么<code>iget</code>和<code>ilock</code>之间的分离很重要。</p>
</blockquote>
<h2 id="File-descriptor-layer"><a href="#File-descriptor-layer" class="headerlink" title="File descriptor layer"></a>File descriptor layer</h2><blockquote>
<p>Unix的一个很酷的方面是，Unix中的大多数资源都表示为文件，包括控制台、管道等设备，当然还有真实文件。文件描述符层是实现这种一致性的层。</p>
</blockquote>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>Xv6为每个进程提供了自己的打开文件表或文件描述符。每个打开的文件都由一个<code>struct file</code>表示，它是inode或管道的封装，加上一个I/O偏移量。</p>
<p>每次调用<code>open</code>都会创建一个新的打开文件（一个新的<code>struct file</code>）：如果多个进程独立地打开同一个文件，那么不同的实例将具有不同的I/O偏移量。</p>
<p>另一方面，单个打开的文件（同一个<code>struct file</code>）可以多次出现在一个进程的文件表中，也可以出现在多个进程的文件表中。如果一个进程使用<code>open</code>打开文件，然后使用<code>dup</code>创建别名，或使用<code>fork</code>与子进程共享，就会发生这种情况。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;</span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ftable"><a href="#ftable" class="headerlink" title="ftable"></a>ftable</h3><blockquote>
<p>所有在系统中打开的文件都会被放入global file table<code>ftable</code>中。</p>
<p><code>ftable</code>具有分配文件（<code>filealloc</code>）、创建重复引用（<code>filedup</code>）、释放引用（<code>fileclose</code>）以及读取和写入数据（<code>fileread</code>和<code>filewrite</code>）的函数。</p>
<p>前三个都很常规，跟之前的xxalloc、xxfree的思路是一样的。</p>
<p>函数<code>filestat</code>、<code>fileread</code>和<code>filewrite</code>实现对文件的<code>stat</code>、<code>read</code>和<code>write</code>操作。</p>
</blockquote>
<h4 id="filealloc"><a href="#filealloc" class="headerlink" title="filealloc"></a>filealloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filealloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">      f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">      release(&amp;ftable.lock);</span><br><span class="line">      <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="filedup"><a href="#filedup" class="headerlink" title="filedup"></a>filedup</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increment ref count for file f.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filedup</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;filedup&quot;</span>);</span><br><span class="line">  f-&gt;ref++;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fileclose"><a href="#fileclose" class="headerlink" title="fileclose"></a>fileclose</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;fileclose&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ff = *f;</span><br><span class="line">  f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">  f-&gt;type = FD_NONE;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line">    pipeclose(ff.pipe, ff.writable);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line">    begin_op();</span><br><span class="line">    iput(ff.ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="filestat"><a href="#filestat" class="headerlink" title="filestat"></a>filestat</h4><blockquote>
<p>Filestat只允许在inode上操作并且调用了<code>stati</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅允许文件/设备执行</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fileread"><a href="#fileread" class="headerlink" title="fileread"></a>fileread</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read from file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 首先检查是否可读</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>((r = readi(f-&gt;ip, <span class="number">1</span>, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 移动文件指针偏移量</span></span><br><span class="line">      f-&gt;off += r;</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    panic(<span class="string">&quot;fileread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-System-calls"><a href="#Code-System-calls" class="headerlink" title="Code: System calls"></a>Code: System calls</h2><blockquote>
<p>通过使用底层提供的函数，大多数系统调用的实现都很简单（请参阅***kernel/sysfile.c***）。有几个调用值得仔细看看。</p>
<p>以下介绍的函数都在<code>kernel/sysfile.c</code>中。</p>
</blockquote>
<h3 id="sys-link"><a href="#sys-link" class="headerlink" title="sys_link"></a>sys_link</h3><p>这个函数的功能是给文件old加上一个链接，这个链接存在于文件new的父目录。感觉也就相当于把文件从old复制到new处了。具体实现逻辑就是要给该文件所在目录添加一个entry，name=新名字，inode=该文件的inode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the path new as a link to the same inode as old.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>, *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, old, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, new, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先先增加nlink</span></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">// 通过path找到ip结点</span></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(old)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="comment">// directory不能被link</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DIR)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;nlink++;</span><br><span class="line">  <span class="comment">// 修改一次字段就需要update一次</span></span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后再在目录中登记新的entry</span></span><br><span class="line">  <span class="comment">// 找到new的parent，也即new所在目录</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(new, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  ilock(dp);</span><br><span class="line">  <span class="comment">// 在目录中添加一个entry，名字为给定的新名字，inode依旧为原来的inode</span></span><br><span class="line">  <span class="comment">// new的父目录必须存在并且与现有inode位于同一设备上</span></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  iput(ip);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;nlink--;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><blockquote>
<p>它是三个文件创建系统调用的泛化：带有<code>O_CREATE</code>标志的<code>open</code>生成一个新的普通文件，<code>mkdir</code>生成一个新目录，<code>mkdev</code>生成一个新的设备文件。</p>
</blockquote>
<p>创建一个新的inode结点，结点名包含在<code>path</code>内。返回一个<strong>锁定的</strong>inode。</p>
<p>由于使用了<code>iupdate</code>等，所以该函数只能在事务中被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">create</span><span class="params">(<span class="type">char</span> *path, <span class="type">short</span> type, <span class="type">short</span> major, <span class="type">short</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">dp</span>;</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取结点父目录</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(path, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ilock(dp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 说明文件已存在</span></span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))</span><br><span class="line">      <span class="comment">// 说明此时caller为open（type == T_FILE），open调用create只能是用于创建文件</span></span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;create: ialloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;major = major;</span><br><span class="line">  ip-&gt;minor = minor;</span><br><span class="line">  ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type == T_DIR)&#123;  <span class="comment">// Create . and .. entries.</span></span><br><span class="line">    dp-&gt;nlink++;  <span class="comment">// for &quot;..&quot;</span></span><br><span class="line">    iupdate(dp);</span><br><span class="line">    <span class="comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span></span><br><span class="line">    <span class="comment">// 所以其实.和..本质上是link</span></span><br><span class="line">    <span class="keyword">if</span>(dirlink(ip, <span class="string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="number">0</span> || dirlink(ip, <span class="string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;create dots&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;create: dirlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">  iunlockput(dp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-mkdir"><a href="#sys-mkdir" class="headerlink" title="sys_mkdir"></a>sys_mkdir</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, path, MAXPATH) &lt; <span class="number">0</span> || (ip = create(path, T_DIR, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-open"><a href="#sys-open" class="headerlink" title="sys_open"></a>sys_open</h3><blockquote>
<p><code>Sys_open</code>是最复杂的，因为创建一个新文件只是它能做的一小部分。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> fd, omode;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;omode) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建失败</span></span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 文件不存在</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create返回一个锁定的inode，但namei不锁定，因此sys_open必须锁定inode本身。</span></span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="comment">// 非文件，为目录并且非只读</span></span><br><span class="line">    <span class="comment">// 所以说想要open一个目录的话只能以只读模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取file结构体和文件描述符。</span></span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">      fileclose(f);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有其他进程可以访问部分初始化的文件，因为它仅位于当前进程的表中，因而这里可以不用上锁</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class="line">    f-&gt;type = FD_DEVICE;</span><br><span class="line">    f-&gt;major = ip-&gt;major;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    f-&gt;type = FD_INODE;</span><br><span class="line">    f-&gt;off = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;ip = ip;</span><br><span class="line">  f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class="line">  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果使用了这个标志,调用 open 函数打开文件的时候会将文件原本的内容全部丢弃,文件大小变为 0。</span></span><br><span class="line">  <span class="keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;</span><br><span class="line">    itrunc(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-pipe"><a href="#sys-pipe" class="headerlink" title="sys_pipe"></a>sys_pipe</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fdarray; <span class="comment">// user pointer to array of two integers用来接收pipe两端的文件描述符</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">rf</span>, *<span class="title">wf</span>;</span></span><br><span class="line">  <span class="type">int</span> fd0, fd1;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;fdarray) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(pipealloc(&amp;rf, &amp;wf) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  fd0 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>((fd0 = fdalloc(rf)) &lt; <span class="number">0</span> || (fd1 = fdalloc(wf)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd0 &gt;= <span class="number">0</span>)</span><br><span class="line">      p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line">    fileclose(rf);</span><br><span class="line">    fileclose(wf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, fdarray, (<span class="type">char</span>*)&amp;fd0, <span class="keyword">sizeof</span>(fd0)) &lt; <span class="number">0</span> ||</span><br><span class="line">     copyout(p-&gt;pagetable, fdarray+<span class="keyword">sizeof</span>(fd0), (<span class="type">char</span> *)&amp;fd1, <span class="keyword">sizeof</span>(fd1)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line">    p-&gt;ofile[fd1] = <span class="number">0</span>;</span><br><span class="line">    fileclose(rf);</span><br><span class="line">    fileclose(wf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Real-world-5"><a href="#Real-world-5" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>实际操作系统中的buffer cache比xv6复杂得多，但它有两个相同的用途：缓存和同步对磁盘的访问。</p>
<p>与UNIX V6一样，Xv6的buffer cache使用简单的最近最少使用（LRU）替换策略；有许多更复杂的策略可以实现，每种策略都适用于某些工作场景，而不适用于其他工作场景。更高效的LRU缓存将消除链表，而改为使用哈希表进行查找，并使用堆进行LRU替换【跟我们在lock中实现的一样，再多个堆优化】。现代buffer cache通常与虚拟内存系统集成，以支持内存映射文件。</p>
<p>Xv6的日志系统效率低下。提交不能与文件系统调用同时发生。系统记录整个块，即使一个块中只有几个字节被更改。它执行同步日志写入，每次写入一个块，每个块可能需要整个磁盘旋转时间。真正的日志系统解决了所有这些问题。</p>
<p>文件系统布局中最低效的部分是目录，它要求在每次查找期间对所有磁盘块进行线性扫描【确实】。当目录只有几个磁盘块时，这是合理的，但对于包含许多文件的目录来说，开销巨大。Microsoft Windows的NTFS、Mac OS X的HFS和Solaris的ZFS（仅举几例）将目录实现为磁盘上块的平衡树。这很复杂，但可以保证目录查找在对数时间内完成（即时间复杂度为O(logn)）。</p>
<p>Xv6对于磁盘故障的解决很初级：如果磁盘操作失败，Xv6就会调用<code>panic</code>。这是否合理取决于硬件：如果操作系统位于使用冗余屏蔽磁盘故障的特殊硬件之上，那么操作系统可能很少看到故障，因此<code>panic</code>是可以的。另一方面，使用普通磁盘的操作系统应该预料到会出现故障，并能更优雅地处理它们，这样一个文件中的块丢失不会影响文件系统其余部分的使用。</p>
<p>Xv6要求文件系统安装在单个磁盘设备上，且大小不变。随着大型数据库和多媒体文件对存储的要求越来越高，操作系统正在开发各种方法来消除“每个文件系统一个磁盘”的瓶颈。基本方法是将<strong>多个物理磁盘组合成一个逻辑磁盘</strong>。RAID等硬件解决方案仍然是最流行的，但当前的趋势是在软件中尽可能多地实现这种逻辑。这些软件实现通常<strong>允许通过动态添加或删除磁盘来扩展或缩小逻辑设备</strong>等丰富功能。当然，一个能够动态增长或收缩的存储层需要一个能够做到这一点的文件系统：xv6使用的固定大小的inode块阵列在这样的环境中无法正常工作。<strong>将磁盘管理与文件系统分离可能是最干净的设计</strong>，但两者之间复杂的接口导致了一些系统（如Sun的ZFS）将它们结合起来。</p>
<p>Xv6的文件系统缺少现代文件系统的许多其他功能；例如，它缺乏对快照和增量备份的支持。</p>
<p>现代Unix系统允许使用与磁盘存储相同的系统调用访问多种资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口，如<code>/proc</code>。不同于xv6中<code>fileread</code>和<code>filewrite</code>的<code>if</code>语句，这些系统通常为每个打开的文件提供一个<strong>函数指针表</strong>【确实有印象】，每个操作一个，并通过函数指针来援引inode的调用实现。网络文件系统和用户级文件系统提供了将这些调用转换为网络RPC并在返回之前等待响应的函数。</p>
<p>（注：Linux 内核提供了一种通过<code>/proc</code>文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。）</p>
</blockquote>
<h2 id="Lab-file-system"><a href="#Lab-file-system" class="headerlink" title="Lab: file system"></a>Lab: file system</h2><blockquote>
<p>In this lab you will add large files【大文件支持】 and symbolic links【软链接】 to the xv6 file system.</p>
<p>不过做完这个实验，给我的一种感觉就是磁盘管理和内存管理真的有很多相似之处，不过也许它们所代表的思想也很普遍。</p>
</blockquote>
<h3 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h3><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><h5 id="Overview-3"><a href="#Overview-3" class="headerlink" title="Overview"></a>Overview</h5><blockquote>
<p>In this assignment you’ll increase the maximum size of an xv6 file. </p>
<p>Currently xv6 files are limited to 268 blocks, or 268*BSIZE bytes (BSIZE is 1024 in xv6). This limit comes from the fact that an xv6 inode contains 12 “direct” block numbers and one “singly-indirect” block number, which refers to a block that holds up to 256 more block numbers, for a total of 12+256=268 blocks.</p>
<p>You’ll change the xv6 file system code to support a <strong>“doubly-indirect” block</strong> in each inode, containing 256 addresses of singly-indirect blocks, each of which can contain up to 256 addresses of data blocks. The result will be that a file will be able to consist of up to 65803 blocks, or 256*256+256+11 blocks (11 instead of 12, because <strong>we will sacrifice one of the direct block numbers for the double-indirect block</strong>).</p>
</blockquote>
<h5 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h5><blockquote>
<p>If at any point during the lab you find yourself having to rebuild the file system from scratch, you can run <code>make clean</code> which forces make to rebuild fs.img.</p>
</blockquote>
<h5 id="What-to-Look-At"><a href="#What-to-Look-At" class="headerlink" title="What to Look At"></a>What to Look At</h5><p>意思就是要我们去看一眼fs.h，bmap，以及了解一下逻辑地址bn如何转化为blockno。这个我是知道的。</p>
<h5 id="Your-Job"><a href="#Your-Job" class="headerlink" title="Your Job"></a>Your Job</h5><blockquote>
<p>Modify <code>bmap()</code> so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. </p>
<p>You’ll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you’re not allowed to change the size of an on-disk inode. </p>
<p>The first 11 elements of <code>ip-&gt;addrs[]</code> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when <code>bigfile</code> writes 65803 blocks and <code>usertests</code> runs successfully.</p>
</blockquote>
<h4 id="感想-18"><a href="#感想-18" class="headerlink" title="感想"></a>感想</h4><p>意外地很简单（）在此不多做赘述，直接上代码。</p>
<p>唯一要注意的一点就是记得在<code>itrunc</code>中free掉</p>
<img src="/2023/01/10/xv6/image-20230124232433793.png" class>

<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><h5 id="修改定义"><a href="#修改定义" class="headerlink" title="修改定义"></a>修改定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in fs.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDOUBLEINDIRECT ((BSIZE/sizeof(uint))*(BSIZE/sizeof(uint)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NDOUBLEINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="修改bmap"><a href="#修改bmap" class="headerlink" title="修改bmap()"></a>修改bmap()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in fs.c</span></span><br><span class="line"><span class="comment">// 调试用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// CODE HERE</span></span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDOUBLEINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// 调试用</span></span><br><span class="line">    <span class="keyword">if</span>(bn/<span class="number">10000</span> &gt; cnt)&#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;double_indirect:%d\n&quot;</span>,bn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一层</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="comment">// 第二层</span></span><br><span class="line">    bp = bread(ip-&gt;dev,addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[(bn &gt;&gt; <span class="number">8</span>)]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[(bn &gt;&gt; <span class="number">8</span>)] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="comment">// 第三层</span></span><br><span class="line">    bp = bread(ip-&gt;dev,addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[(bn &amp; <span class="number">0x00FF</span>)]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[(bn &amp; <span class="number">0x00FF</span>)] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改itrunc"><a href="#修改itrunc" class="headerlink" title="修改itrunc"></a>修改itrunc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents).</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CODE HERE</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="number">1</span>])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="comment">// 双层循环。这里其实不应该用NINDIRECT这个宏定义的，因为意义其实不大一样。</span></span><br><span class="line">    <span class="comment">// 但是由于数值一样，这里就先凑合着用了</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">tmp_bp</span> =</span> bread(ip-&gt;dev,a[j]);</span><br><span class="line">        uint* tmp_a = (uint*)tmp_bp-&gt;data;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; NINDIRECT; k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(tmp_a[k])</span><br><span class="line">            bfree(ip-&gt;dev,tmp_a[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(tmp_bp);</span><br><span class="line">        bfree(ip-&gt;dev,a[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h3><blockquote>
<p>In this exercise you will add symbolic links to xv6. </p>
<p>Symbolic links (or <strong>soft links</strong>) refer to a linked file by pathname; when a symbolic link is opened, the kernel follows the link to the referred file. </p>
<p>Symbolic links resembles hard links, <u>but hard links are restricted to pointing to file on the same disk</u>, while symbolic links can cross disk devices. </p>
<p>Although xv6 doesn’t support multiple devices, implementing this system call is a good exercise to understand how pathname lookup works.</p>
<p>You will implement the <code>symlink(char *target, char *path)</code> system call, which creates a new symbolic link at path that refers to file named by target. For further information, see the man page symlink. To test, add symlinktest to the Makefile and run it. </p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40179091/article/details/125306898">linux：硬链接和软链接</a></p>
<p>硬链接不会创建新的物理文件，但是会使得当前物理文件的引用数加1。当硬链接产生的文件存在时，删除源文件，不会清除实际的物理文件，即对于硬链接“生成的新文件”不会产生任何影响。</p>
<p>软链接就更像一个指针，只是指向实际物理文件位置，当源文件移动或者删除时，软链接就会失效。</p>
<p>【所以说，意思就是软链接不会让inode-&gt;ulinks++的意思？】</p>
</blockquote>
<h4 id="感想-19"><a href="#感想-19" class="headerlink" title="感想"></a>感想</h4><p>这个实验比上个实验稍难一些，但也确实只是moderate的水平，其复杂程度主要来源于对文件系统的理解，还有如何判断环，以及对锁的获取和释放的应用。我做这个实验居然是没看提示的【非常骄傲&lt;-】，让我有一种自己水平上升了的感觉hhh</p>
<h5 id="正确思路-3"><a href="#正确思路-3" class="headerlink" title="正确思路"></a>正确思路</h5><p>本实验要求实现软链接。首先需要实现创建软链接：写一个系统调用 <code>symlink(char *target, char *path)</code> 用于创建一个指向target的在path的软链接；然后需要实现打开软链接进行自动的跳转：在<code>sys_open</code>中添加对文件类型为软链接的特殊处理。</p>
<h5 id="初见思路-2"><a href="#初见思路-2" class="headerlink" title="初见思路"></a>初见思路</h5><p>我的初见思路是觉得可以完全参照<code>sys_link</code>来写。但其实还是很不一样的。</p>
<p><code>sys_link</code>的逻辑：</p>
<ol>
<li>获取old的inode</li>
<li>获取new所在目录的inode，称为dp</li>
<li>在dp中添加一项entry指向old</li>
</ol>
<p><code>sys_symlink</code>的逻辑：</p>
<ol>
<li><p>通过path创建一个新的inode，作为软链接的文件</p>
<p>这里选择新建inode，而不是像link那样做，主要还是为了能遵从<code>symlinktest</code>给的接口使用方法（朴实无华的理由）。而且这么做也很方便，符合“一切皆文件”的思想，也能简单化对其在<code>open</code>中的处理。</p>
</li>
<li><p>在inode中填入target的地址</p>
<p>我们可以把软链接视为文件，文件内容是其target的path。</p>
</li>
</ol>
<p>可以说是毫不相干，所以还是直接自起炉灶比较好。</p>
<h5 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h5><p>其实没什么好说的，虽然debug过程挺久，但是靠常规的printf追踪就都可以看出来是哪里错了。下面我说说一个我印象比较深刻的吧。</p>
<p><code>symlinktest</code>中有一个检测点是，软链接不能成环，也即b-&gt;a-&gt;b是非法的。于是，我就选择了用快慢指针来检测环形链表这个思想，用来看是否出现环。</p>
<p>在<code>symlinktest</code>的另一个检测点中：</p>
<img src="/2023/01/10/xv6/image-20230125173143735.png" class>

<p>我出现了如下错误：</p>
<img src="/2023/01/10/xv6/image-20230125162542807.png" class>

<p>此时的结构是1[27]-&gt;2[28]-&gt;3[29]-&gt;4，[]内为inode的inum。</p>
<p>快慢指针的实现方式是当cnt为奇数的时候，慢指针才会移动。而上图中，cnt==0时，两个指针的值都发生了变化，这就非常诡异。</p>
<p>这其实是因为slow指针所指向的那个inode被释放了，然后又被fast指针的下一个inode捡过来用了，从而导致值覆盖。</p>
<p>为什么会被释放呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 快指针移动</span></span><br><span class="line">      readi(ip,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 在这里！！！</span></span><br><span class="line">      ilockput(ip);</span><br></pre></td></tr></table></figure>

<p>在这里，我错误地调用了<code>ilockput</code>，从而使inode的ref–，使得它在下一次fast指针调用<code>namei</code>，<code>namei</code>调用<code>iget</code>时，该inode被当做free inode使用，于是就这么寄了。</p>
<p>所以我们需要把<code>ilockput</code>的调用换成<code>ilock</code>，这样一来就能防止inode被free。至于什么时候再iput？我想还是交给操作系统启动时的清理工作来做吧23333【开摆】</p>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><img src="/2023/01/10/xv6/image-20230125165612112.png" class>

<h5 id="添加定义"><a href="#添加定义" class="headerlink" title="添加定义"></a>添加定义</h5><h6 id="fcntl-c"><a href="#fcntl-c" class="headerlink" title="fcntl.c"></a>fcntl.c</h6><p>open参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 意为只用获取软链接文件本身，而不用顺着软链接去找它的target文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_NOFOLLOW 0x100</span></span><br></pre></td></tr></table></figure>

<h6 id="stat-h"><a href="#stat-h" class="headerlink" title="stat.h"></a>stat.h</h6><p>文件类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYMLINK  4   <span class="comment">// symbol links</span></span></span><br></pre></td></tr></table></figure>

<h5 id="添加sys-symlink系统调用"><a href="#添加sys-symlink系统调用" class="headerlink" title="添加sys_symlink系统调用"></a>添加sys_symlink系统调用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in sysfile.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建软链接结点</span></span><br><span class="line">  ip = create(path,T_SYMLINK,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//printf(&quot;symlink:before writei,inum = %d\n&quot;,ip-&gt;inum);</span></span><br><span class="line">  <span class="comment">// 此处可以防止住一些并发错误</span></span><br><span class="line">  <span class="keyword">if</span>(ip ==<span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向软链接结点文件内写入其所指向的路径</span></span><br><span class="line">  writei(ip,<span class="number">0</span>,(uint64)target,<span class="number">0</span>,MAXPATH);</span><br><span class="line">  <span class="comment">//printf(&quot;symlink:after writei\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 软链接不需要让nlink++</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 记得要释放在create()中申请的锁</span></span><br><span class="line">  iunlockput(ip);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改open"><a href="#修改open" class="headerlink" title="修改open"></a>修改open</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 软链接不可能是以O_CREATE的形式创建的</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改从这里开始</span></span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="comment">// ip为快指针，slow为慢指针</span></span><br><span class="line">    uint cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">slow</span> =</span> ip;</span><br><span class="line">    <span class="comment">// 可能有多重链接，因而需要持续跳转</span></span><br><span class="line">    <span class="keyword">while</span>(ip-&gt;type == T_SYMLINK)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;slow = %d,fast = %d,cnt = %d\n&quot;,slow-&gt;inum,ip-&gt;inum,cnt);</span></span><br><span class="line">      <span class="comment">// 其实这个只需要检测一次就够了。但为了编码方便，仍然把它保留在while循环中</span></span><br><span class="line">      <span class="keyword">if</span>(omode &amp; O_NOFOLLOW)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 检测到cycle</span></span><br><span class="line">        <span class="keyword">if</span>(slow == ip &amp;&amp; cnt!=<span class="number">0</span>)&#123;</span><br><span class="line">          iunlockput(ip);</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快指针移动</span></span><br><span class="line">        readi(ip,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">        <span class="comment">// 此处不能用iunlockput()，具体原因见 感想-一些错误</span></span><br><span class="line">        iunlock(ip);</span><br><span class="line">        <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ilock(ip);</span><br><span class="line">        <span class="comment">// 慢指针移动</span></span><br><span class="line">        <span class="comment">// 注意，我慢指针移动的时候没有锁保护，因为用锁太麻烦了（）其实还是用锁比较合适</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="comment">//printf(&quot;%d\n&quot;,cnt);</span></span><br><span class="line">          readi(slow,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">          <span class="keyword">if</span>((slow = namei(path) )== <span class="number">0</span>)&#123;</span><br><span class="line">            end_op();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当跳出循环时，此时的ip必定是锁住的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab-mmap"><a href="#Lab-mmap" class="headerlink" title="Lab mmap"></a>Lab mmap</h2><blockquote>
<p>The <code>mmap</code> and <code>munmap</code> system calls allow UNIX programs to exert detailed control over their address spaces. </p>
<p>They can be used to:</p>
<ol>
<li>share memory among processes</li>
<li>map files into process address spaces</li>
<li>as part of user-level page fault schemes such as the garbage-collection algorithms discussed in lecture. </li>
</ol>
<p>In this lab you’ll add <code>mmap</code> and <code>munmap</code> to xv6, <strong>focusing on memory-mapped files</strong>.</p>
<p>mmap是系统调用，在用户态被使用。我们这次实验仅实现mmap功能的子集，也即memory-mapped files。</p>
</blockquote>
<blockquote>
<p>declaration for <code>mmap</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>参数</p>
<ol>
<li><p><code>addr</code> is always zero.</p>
<p>You can assume that <code>addr</code> will always be zero, meaning that the kernel should decide the <strong>virtual address</strong> at which to map the file.【<code>addr</code>由kernel决定，因而用户态只需传入0即可】</p>
</li>
<li><p><code>length</code> is the number of bytes to map</p>
<p>Might not be the same as the file’s length.</p>
</li>
<li><p> <code>prot</code> indicates whether the memory should be mapped readable, writeable, and/or executable.</p>
</li>
</ol>
<p>   you can assume that <code>prot</code> is <code>PROT_READ</code> or <code>PROT_WRITE</code> or both. </p>
<ol start="4">
<li><p><code>flags</code> has two values.</p>
<ol>
<li><p><code>MAP_SHARED</code></p>
<p> meaning that modifications to the mapped memory <strong>should be written back to the file</strong>, </p>
<p> 如果标记为此，则当且仅当file本身权限为RW或者WRITABLE的时候，prot才可以标记为PROT_WRITE</p>
</li>
<li><p><code>MAP_PRIVATE</code></p>
<p>meaning that they should not. </p>
<p>如果标记为此，则无论file本身权限如何，prot都可以标记为PROT_WRITE</p>
</li>
</ol>
</li>
<li><p>You can assume <code>offset</code> is zero (it’s the starting point in the file at which to map)</p>
</li>
</ol>
</li>
<li><p>return</p>
<p><code>mmap</code> returns that kernel-decided address, or 0xffffffffffffffff if it fails.</p>
</li>
</ol>
<p>如果两个进程同时对某个文件进行memory map，那么这两个进程可以不共享物理页面。</p>
</blockquote>
<blockquote>
<p><code>munmap(addr, length)</code> should remove mmap mappings in the indicated address range. </p>
<p>If the process has modified the memory and has it mapped <code>MAP_SHARED</code>, <strong>the modifications should first be written to the file</strong>. 【如果两个进程的修改发生冲突了怎么办？】</p>
<p>An <code>munmap</code> call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region).</p>
</blockquote>
<h3 id="感想-20"><a href="#感想-20" class="headerlink" title="感想"></a>感想</h3><p>这个实验做得我……怎么说，感觉非常地难受吧。虽然我认为我这次做得挺不错的，因为我没有怎么看hints，我的代码差不多全都是我自己想出来的，没有依赖保姆级教学，我认为是一个很好的进步。不过，正因为我没有看hints，导致我的想法比起答案来思路非常地奇诡，导致我第一次错误想法写了一天，看了hints后决心痛改前非，结果第二次错误想法又写了一天emmm</p>
<p>下面的第一个代码版本虽然可以过掉mmaptest，但<strong>确实还是有一个很致命的bug</strong>，并且<strong>lazy也没有lazy到位</strong>，最后的版本离正确思路还有偏差，<strong>也就是下面放的第一个代码版本是错误的，</strong>但我认为它也不是完全没有亮点。第二个版本才是经过改正的正确版本，但写得着实有点潦草。</p>
<p>笔记整理得也有点匆忙，毕竟我真的话比较多而且心里很烦。总之，先记录我的全部思路过程，至于价值如何，先不管了2333</p>
<h4 id="初见思路-3"><a href="#初见思路-3" class="headerlink" title="初见思路"></a>初见思路</h4><p>所以说，我们要做的，就是实现一个系统调用mmap，在mmap中，应该首先申请几页用来放file的内容，并且在页表中填入该项，然后再返回该项的虚拟地址。然后在munmap中，再将该file页内容写入file。</p>
<p>也就是说，直接在mmap把文件的全部内容写入内存，然后各进程读写自己的那块内容块，最后在munmap的时候把修改内容写入文件然后释放该内存块就行了</p>
<h5 id="问题：在哪里放置file的内容"><a href="#问题：在哪里放置file的内容" class="headerlink" title="问题：在哪里放置file的内容"></a>问题：在哪里放置file的内容</h5><p>题目要求<code>the kernel should decide the **virtual address** at which to map the file.</code>也就是说，在我们的<code>mmap</code>中，需要决定我们要讲文件内容放在哪里。那要放在哪呢……</p>
<p>我第一反应很奇葩：扫描页表，找到空闲页。但我自己也知道这样不可行，文件内容不止一页，这种零零散散存储需要的数据结构实现起来太麻烦了。</p>
<p>那怎么办？可以在heap内分配。那么到底怎么样才能在heap里分配？你该怎么知道heap哪里开始是空闲的，哪里是用过的，不还是得扫描页表吗？【思维大僵化】</p>
<p>其实……道理很简单。我们之间把<code>proc-&gt;sz</code>作为mapped-file的起始地址就好了。相信看到这里，你也明白这是什么原理了。能想到这个，我感觉确实很不容易。</p>
<h4 id="正确思路-4"><a href="#正确思路-4" class="headerlink" title="正确思路"></a>正确思路</h4><p>初见思路虽然简单，但是很粗暴，如果文件很大，宝贵的内存空间就会被我们浪费。所以我们借用lazy allocation的思想，先建立memory-file的映射，再在缺页中断中通过文件读写申请内存空间，把文件内容读入内存。</p>
<p>问题就在于如何“先建立memory-file的映射”。在lazy allocation中，我们是先填好所有的对应页表项，仅是不申请对应的物理内存，也即占着XX不XX。在这次实验中，我们也是这么做，只不过新增了一个难点，那就是<strong>如何管理这些页</strong>。因为lazy allocation页与页之间没有比较紧密的关系，但是在mmap中页却可以被所属文件这个关键字划分。因而，我们需要一个数据结构，来给页分门别类地组织在一起，并且记录它们的meta data比如说所属文件之类的，这也就是hints里的VMA结构，也即我的filemap结构。</p>
<p>我们可以将这样的数据结构池化，并且存储在proc域中，以避免对象的重复创建。</p>
<blockquote>
<p>我的lazy法与别人不大一样……我没有想得像他们那么完美。我的做法是，在需要读某个地址的文件内容时，直接确保这个地址前面的所有文件内容都读了进来。也即在filemap中维护一个okva，表明va<del>okva这段内存已经读入，之后就仅需再读入okva</del>need_va这段地址就行。这样虽然lazy了，但没完全lazy。</p>
<p>我认为这不能体现lazy的思想……因为一读读一坨，还是很占空间啊。</p>
</blockquote>
<p>因而，我们需要做的就是：</p>
<ol>
<li><p>在mmap中将信息填入该数据结构</p>
<ol>
<li>依据传入的长度扩容proc，原sz作为mapped-file起始地址va</li>
<li>从对象池中寻找到一个空闲的filemap，对其填写信息</li>
<li>返回1所得的va</li>
</ol>
<p>在我的代码中，还针对proc-&gt;sz不满足page-align做出了对策：先把文件的<code>PGROUNDUP(sz)-sz</code>这部分的信息读入，并且更新okva，这样一来，之后在usertrap中，就可以从okva开始一页页地分配地址，做到自然地page-align了。</p>
<blockquote>
<p>为什么要对不满足page-align的情况进行处理？</p>
<p>这是因为，growproc的时候一次性扩充一页，但proc-&gt;sz却可以不满足page-align，也就是说，proc-&gt;sz所处的这一页已经被分配了。</p>
<p>在我们的lazy思路中，我们如果不预先读入文件页，是只能等待用户陷入缺页中断的情况下才能读入文件内容。</p>
<p>但是，proc-&gt;sz这一页已经被分配了。因而，在用户态读取这一页地址的时候，<strong>并不会发生缺页中断</strong>。因而，就会发生文件内容未读入，用户读到脏数据的情况。</p>
<p>其实还有一种更简单的办法可以强制page-align，那就是，直接让起始地址为<code>PGROUNDUP(proc-&gt;sz)</code>……至于为什么我不用这个，而要写这么多麻烦的东西呢？答案是我没想到。（）</p>
</blockquote>
</li>
<li><p>在usertrap增加对缺页中断的处理</p>
<ol>
<li>依据va找到对应filemap</li>
<li>根据对应filemap的信息，使用<code>readi</code>（正确）<code>fileread</code>（错误）读取文件内容并存入物理内存</li>
</ol>
</li>
<li><p>在munmap中进行释放</p>
<ol>
<li>根据标记写入文件页，并且释放对应物理内存</li>
<li>修改filemap结构的参数，并且在其失效的时候放回对象池</li>
</ol>
</li>
<li><p>修改fork和exit</p>
<ol>
<li><p>exit</p>
<p>手动释放map-file域</p>
<blockquote>
<p>为什么不能把这些合并到<code>wait</code>中调用的<code>freepagetable</code>进行释放呢？</p>
<p>因为<code>freepagetable</code>只会释放对应的物理页，没有达到<code>munmap</code>减少文件引用等功能。</p>
</blockquote>
</li>
<li><p>fork</p>
<p>手动复制filemap池</p>
</li>
</ol>
</li>
</ol>
<h4 id="我的错误思路们"><a href="#我的错误思路们" class="headerlink" title="我的错误思路们"></a>我的错误思路们</h4><h5 id="第一次错误思路"><a href="#第一次错误思路" class="headerlink" title="第一次错误思路"></a>第一次错误思路</h5><p>上面说到：</p>
<blockquote>
<p>问题就在于如何“先建立memory-file的映射”。在lazy allocation中，我们是先填好所有的对应页表项，仅是不申请对应的物理内存，也即占着XX不XX。在这次实验中，我们也是这么做，只不过新增了一个难点，那就是<strong>如何管理这些页</strong>。因为lazy allocation页与页之间没有比较紧密的关系，但是在mmap中页却可以被所属文件这个关键字划分。因而，我们需要一个数据结构，来给页分门别类地组织在一起，并且记录它们的meta data比如说所属文件之类的，这也就是hints里的VMA结构，也即我的filemap结构。</p>
</blockquote>
<p>官方给出的答案是在proc域里的pool。我……额……是把这些信息，存入在页中（真是自找麻烦呀）</p>
<p>具体来说，就是，我在<code>mmap</code>的时候给每个文件申请一页，然后在页的开头填上和filemap结构相差无几的那些参数，再加上一个next指针，表示下一个文件页的地址。页的剩下部分就用来存储数据。总的就是一个链表结构。</p>
<p>这个思路其实很不错，比起上面的直接在proc内存的尾巴扩容，这个空间利用率应该更大，并且不仅能节省物理内存，还能节省虚拟地址空间，实现了lazy上加lazy。</p>
<p>但问题是……我<strong>为什么非要傻瓜式操纵内存，在页的开头填入参数数据</strong>，而不是把这种页抽象为一个个node，最终形成一个十字链表的形式（差不多的意思，鱼骨状），组织进proc域，这样不挺好的吗……唔，有时候我头脑昏迷程度让我自己都感到十分震惊。归根结底，还是想得太少就动手了，失策。</p>
<p>总之放上代码。我没有实现next指针，仅假设文件内容不超过一页。也就是这一页开头在mmap中填meta data，其余部分在usertrap中填入文件内容。【这个分开的点也让我迷惑至极……】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERRORADDR 0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="keyword">struct</span> file* file,uint64 offset)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">// 获取va,也即真正的address</span></span><br><span class="line">    uint64 va = p-&gt;sz;</span><br><span class="line">    <span class="keyword">if</span>(growproc(PGSIZE) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    <span class="type">char</span>* mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 保存信息：file指针、prot（这就是傻瓜式操纵内存的典范）</span></span><br><span class="line">    uint64* pointer = (uint64*)mem;</span><br><span class="line">    *pointer = (uint64)file;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)prot;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)length;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)flags;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)offset;</span><br><span class="line">    pointer++;</span><br><span class="line">    filedup(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(p-&gt;pagetable, va+PGSIZE, PGSIZE, (uint64)mem, PTE_M|PTE_X|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return start of free memory</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)(va + (uint64)pointer - (uint64)mem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64* pa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, (uint64)address, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span> ||(*pte &amp; PTE_M) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// the start is where the params save</span></span><br><span class="line">    pa = (uint64*)(PGROUNDDOWN(PTE2PA(*pte)));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span> =</span> (<span class="keyword">struct</span> file*)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> prot = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> flags = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flags == MAP_SHARED&amp;&amp;(prot&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 需要更新写内容</span></span><br><span class="line">        filewrite(file,(uint64)address,length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后释放内存</span></span><br><span class="line">    uvmunmap(p-&gt;pagetable, PGROUNDDOWN((uint64)address), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64* pa;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span> ||(*pte &amp; PTE_M) == <span class="number">0</span>)</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the start is where the params save</span></span><br><span class="line">    pa = (uint64*)(PGROUNDDOWN(PTE2PA(*pte)));</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span> =</span> (<span class="keyword">struct</span> file*)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> prot = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">size_t</span> length = (<span class="type">size_t</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((prot&amp;PROT_READ) != <span class="number">0</span>)&#123;</span><br><span class="line">      fileread(file,va,length);</span><br><span class="line">      flags |= PTE_R;</span><br><span class="line">      <span class="keyword">if</span>((prot&amp;PROT_WRITE) != <span class="number">0</span>)    flags |= PTE_W;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)     p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      *pte = ((*pte) | flags);</span><br><span class="line">    &#125; <span class="keyword">else</span>  p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="为什么下面的代码是错的"><a href="#为什么下面的代码是错的" class="headerlink" title="为什么下面的代码是错的"></a>为什么下面的代码是错的</h5><p>正如开头所说的那样，我并没有完美做好这次实验，下面代码有一个致命的bug。</p>
<p>先说说致命bug是什么。</p>
<p>我的filemap结构体其实隐藏了两个具有“offset”这一含义的状态。一个是filemap里面的成员变量offset，另一个是filemap里面的成员变量file的成员变量off：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">filemap</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span><span class="comment">//文件</span></span><br><span class="line">  uint64 offset;<span class="comment">//va相对于file开头的offset</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// in file.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在我的代码里，它们被赋予了不同的含义。</p>
<p><code>filemap-&gt;file-&gt;off</code>被用于<code>trap.c</code>中，表示的是当前未读入文件内容的起始位置（实际上也就是<code>okva-va</code>的值），用于自然地使用<code>fileread</code>进行文件读入。</p>
<blockquote>
<p>比如说，这次读入PGSIZE，那么off就会在<code>fileread</code>中自增PGSIZE。下次调用<code>fileread</code>就可以直接从下一个位置读入了，这样使代码更加简洁</p>
</blockquote>
<p><code>filemap-&gt;offset</code>被用于<code>munmap</code>中。<code>filewrite</code>同<code>fileread</code>一样，都是从<code>file-&gt;off</code>处开始取数据。<code>munmap</code>所需要取数据的起始位置和<code>trap.c</code>中需要取数据的起始位置肯定不一样，</p>
<blockquote>
<p>想想它们的功能。<code>trap.c</code>的off需要始终指向有效内存段的末尾，但<code>munmap</code>由于要对特定内存段进行写入文件操作，因而off要求可以随机指向。</p>
</blockquote>
<p>因而，我们可以将当前va对应的文件位置记录在offset中。届时，我们只需要从<code>p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va</code>取数据就行。</p>
<p>上述两个变量相辅相成，看上去似乎能够完美无缺地实现我们的功能。但是，实际上，不行。为什么呢？因为它们的file指针，<code>filemap-&gt;file</code>，如果被两个mmap区域同时使用的话，就会出问题。</p>
<p>可以来看看<code>mmaptest.c</code>中的这一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  makefile(f);</span><br><span class="line">  <span class="keyword">if</span> ((fd = open(f, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">  unlink(f);</span><br><span class="line">  <span class="type">char</span> *p1 = mmap(<span class="number">0</span>, PGSIZE*<span class="number">2</span>, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">  <span class="type">char</span> *p2 = mmap(<span class="number">0</span>, PGSIZE*<span class="number">2</span>, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// read just 2nd page.</span></span><br><span class="line">  <span class="keyword">if</span>(*(p1+PGSIZE) != <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    err(<span class="string">&quot;fork mismatch (1)&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    err(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// v1是用来触发缺页中断的函数</span></span><br><span class="line">    _v1(p1);</span><br><span class="line">    munmap(p1, PGSIZE); <span class="comment">// just the first page</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// tell the parent that the mapping looks OK.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> status = <span class="number">-1</span>;</span><br><span class="line">  wait(&amp;status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(status != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork_test failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check that the parent&#x27;s mappings are still there.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;before v1,p1 = %d\n&quot;</span>,(uint64)p1);</span><br><span class="line">  _v1(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;after v1,p1 = %d\n&quot;</span>,(uint64)p1);</span><br><span class="line">  _v1(p2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fork_test OK\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">fork_test starting</span></span><br><span class="line"><span class="comment">trap:map a page at 53248,okva = 53248</span></span><br><span class="line"><span class="comment">trap:mem[0]=65,off = 4096,size = 6144</span></span><br><span class="line"><span class="comment">trap:map a page at 57344,okva = 53248</span></span><br><span class="line"><span class="comment">trap:mem[0]=65,off = 6144,size = 6144</span></span><br><span class="line"><span class="comment">before v1,p1 = 53248</span></span><br><span class="line"><span class="comment">after v1,p1 = 53248</span></span><br><span class="line"><span class="comment">trap:map a page at 61440,okva = 61440</span></span><br><span class="line"><span class="comment">trap:mem[0]=0,off = 6144,size = 6144</span></span><br><span class="line"><span class="comment">mismatch at 0, wanted &#x27;A&#x27;, got 0x0</span></span><br><span class="line"><span class="comment">mmaptest: fork_test failed: v1 mismatch (1), pid=3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in trap.c</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap:map a page at %d,okva = %d\n&quot;</span>,start_va,p-&gt;filemaps[i].okva);</span><br><span class="line"></span><br><span class="line">fileread(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap:mem[0]=%d,off = %d,size = %d\n&quot;</span>,</span><br><span class="line">       mem[<span class="number">0</span>],p-&gt;filemaps[i].file-&gt;off,p-&gt;filemaps[i].file-&gt;ip-&gt;size);</span><br></pre></td></tr></table></figure>

<p>这段代码因为共用fd，导致file指针被两个mmap区域同时使用。</p>
<blockquote>
<p>共用fd，为什么file指针也一起共用了？</p>
<p>可以追踪一下它们的生命周期：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in sys_open()</span></span><br><span class="line">  <span class="comment">// 获取file结构体和文件描述符。</span></span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// in sysfile.c</span></span><br><span class="line"><span class="comment">// Allocate a file descriptor for the given file.</span></span><br><span class="line"><span class="comment">// Takes over file reference from caller on success.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fdalloc</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line">      p-&gt;ofile[fd] = f;</span><br><span class="line">      <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它实际上是有一个文件描述符表，key为fd，value为file指针。因而，同一张表，fd相同，file指针相同。</p>
<p>注：父子进程，同样的fd，file指针也是相同的</p>
<p><strong>fork出来的父子进程同一个句柄对同一个文件的偏移量是相同的</strong>，这个原理应该是因为，父子进程共享的是文件句柄这个结构体对象本身，也就是拷贝的时候是浅拷贝而不是深拷贝。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in fork()</span></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后的<code>check that the parent&#39;s mappings are still there.</code>环节中，<code>_v1(p1)</code>执行时并没有陷入trap，这是正常的。不正常的是<code>_v1(p2)</code>的执行结果。它陷入了trap，但是却因<code>file-&gt;off == file size</code>，导致被判定为已全部读入文件，事实上却是并没有读入文件。</p>
<p>为什么会这样呢？</p>
<p>这是因为p1和p2共用同一个fd，也就共用了同一个file指针。共用了一个file指针，那么p1和p2面对的<code>file-&gt;off</code>相同。上面说到，<code>file-&gt;off</code>用于控制文件映射。那么，当p1完成了对文件的映射，p1的off指针如果不加重置，就会永远停留在file size处。这样一来，当p2想要使用同样的file指针进行文件映射时，就会出问题。</p>
<p>这个问题的一个解决方法是每次<code>mmap</code>都深拷贝一个船新file结构体。但是这样的话，<code>file</code>域里的<code>ref</code>变量就失去了它的意义，并且file对象池应该也很快就会爆满，非常不符合设计方案。</p>
<p>这个问题的完美解，是不要赋予<code>file-&gt;off</code>这个意义，而是使用<code>readi</code>替代<code>fileread</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileread(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span><br><span class="line">readi(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span><br></pre></td></tr></table></figure>

<p>这样做的好处是，我们可以实时计算offset（前面提到，其恰恰等于okva-va），而不用把这个东西用file的off来表示。</p>
<blockquote>
<p>也确实，我之所以弯弯绕绕那么曲折，是因为只想到了<code>fileread</code>这个函数，压根没注意到还有一个<code>readi</code>……</p>
</blockquote>
<p>我在下面的代码仅做了一个能够通过测试，但是上面的<strong>bug依然存在</strong>的功利性折中代码。我是这么实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在`mmap`的时候初始化`file-&gt;off`</span></span><br><span class="line">p-&gt;filemaps[i].file-&gt;off = offset;</span><br><span class="line"><span class="comment">// 在`munmap`的时候清零`file-&gt;off`</span></span><br><span class="line">p-&gt;filemaps[i].file-&gt;off = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>因而，结论是，一步错步步错，一个错误需要更多的错误来弥补，最后还是错的（悲）</p>
<h5 id="如何把下面的错误思路改成正确思路"><a href="#如何把下面的错误思路改成正确思路" class="headerlink" title="如何把下面的错误思路改成正确思路"></a>如何把下面的错误思路改成正确思路</h5><p>可以做以下几点：</p>
<ol>
<li><p>正确地lazy</p>
<p>每次trap仅分配一页。</p>
</li>
<li><p>改用readi函数，修改<code>file-&gt;off</code>的语义</p>
</li>
</ol>
<p>这样一来，大概就可以完美地正确了。</p>
<h4 id="其他的一些小细节"><a href="#其他的一些小细节" class="headerlink" title="其他的一些小细节"></a>其他的一些小细节</h4><h5 id="file指针的生命周期"><a href="#file指针的生命周期" class="headerlink" title="file指针的生命周期"></a>file指针的生命周期</h5><p>在数据结构中存储file指针至关重要。但仔细想一想，file指针的生命周期似乎长到过分：从sys_mmap被调用，一直到usertrap处理缺页中断，最后到munmap释放，我们要求file指针的值需要保持稳定不变。</p>
<p>这么长的生命周期，它真的可以做到吗？毕竟file指针归根到底只是一个局部变量，在syscall mmap结束之后，它还有效吗？答案是有效的，这个有效性由<code>mmap</code>实现中对ref的增加来实现保障。</p>
<p>在用户态中关闭一个文件，需要使用syscall<code>close(int fd)</code>。不妨来看看<code>close</code>的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in kernel/sysfile.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argfd(<span class="number">0</span>, &amp;fd, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 一个进程打开的文件都会放入一个以fd为index的文件表里，</span></span><br><span class="line"><span class="comment">// 在xv6中，这个文件表便是`myproc()-&gt;ofile`。</span></span><br><span class="line"><span class="comment">// 可以看到，关闭一个文件首先需要把它移出文件表</span></span><br><span class="line">myproc()-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 对file指针关闭的主要操作</span></span><br><span class="line">fileclose(f);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in kernel/file.c</span></span><br><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;ftable.lock);</span><br><span class="line"><span class="comment">// 若ref数&lt;0，就会直接return</span></span><br><span class="line"><span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> release(&amp;ftable.lock);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放file</span></span><br><span class="line"><span class="comment">// close不会显式地释放file指针，只会释放file指针所指向的文件，让file指针失效。</span></span><br><span class="line">ff = *f;</span><br><span class="line">f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">f-&gt;type = FD_NONE;</span><br><span class="line">release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line"> pipeclose(ff.pipe, ff.writable);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line"> begin_op();</span><br><span class="line"> iput(ff.ip);</span><br><span class="line"> end_op();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当ref数&gt;1时，file指针就不会失效。</p>
<p>这就是为什么我们还需要在mmap中让file的ref数++。</p>
<h5 id="缺页中断蕴含的设计思想"><a href="#缺页中断蕴含的设计思想" class="headerlink" title="缺页中断蕴含的设计思想"></a>缺页中断蕴含的设计思想</h5><p>如果只存入file指针，用户态要如何对对应的文件进行读写呢？</p>
<p>我们可以自然想到也许需要设计一个函数，让用户在想要对这块内存读写的时候调用这个函数即可。但是，这样的方法使得用户对内存不能自然地读写，还需要使用我们新设计的这个函数，这显然十分地不美观。所以，我们需要找到一个方法，让上层的用户可以<strong>统一</strong>地读取任何的内存块，包括memory-mapped file内存块，而<strong>隐藏</strong>memory-mapped file与其他内存块读写方式不同的这些复杂细节。经历过前面几次实验的你看到这里一定能想到，有一个更加优美更加符合设计规范的方法，那就是：<strong>缺页中断</strong>！</p>
<blockquote>
<p>没做这个实验之前就知道mmap需要借助缺页中断来实现了，但实际自己的第一印象是觉得并不需要缺页中断，直到分析到这里才恍然大悟。</p>
<p>“让上层的用户可以<strong>统一</strong>地读取任何的内存块，而<strong>隐藏</strong>不同类型的内存块读写方式不同的这些复杂细节”</p>
<p>仔细想想，前面几个关于缺页中断的实验，比如说cow fork，lazy allocation，事实上都是基于这个思想。它们并不是不能与缺页中断分离，只是有了缺页中断，它们的实现更加简洁，更加优美。</p>
<p>再次感慨os的博大精深。小小一个缺页中断，原理那么简单，居然集中了这么多设计思想，不禁叹服。</p>
</blockquote>
<h5 id="正确答案的munmap中如果遇到未映射的页怎么办"><a href="#正确答案的munmap中如果遇到未映射的页怎么办" class="headerlink" title="正确答案的munmap中如果遇到未映射的页怎么办"></a>正确答案的munmap中如果遇到未映射的页怎么办</h5><p>在正确答案的munmap中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line"><span class="keyword">while</span>(start_va &lt; bounder)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">    <span class="comment">//写回</span></span><br><span class="line">    filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">  &#125;</span><br><span class="line">  uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">  start_va += PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果map类型为<code>MAP_SHARED</code>，并且该页尚未映射，会怎么样呢？</p>
<p>追踪filewrite的路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in file.c</span></span><br><span class="line">	  begin_op();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line"><span class="comment">// in fs.c</span></span><br><span class="line">    <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line"><span class="comment">// in vm.c copyin()</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><code>copyin</code>最终会在<code>    if(pa0 == 0)  return -1;</code>这里终结，但<code>writei</code>并不会在接收到-1的时候爆出panic或者是引发缺页中断，而只会把它当做文件结尾，默默地返回。</p>
<p>并且，在<code>munmap</code>中是一页一页地释放，而不是直接传参length全部释放，这一点也很重要。因为我们的lazy allocation很可能导致<code>va~va+length</code>这一区间内只是部分页被映射，部分页没有。如果直接传参length释放，那么在遇到第一页未被映射的时候，<code>filewrite</code>就会终止，该页之后的页就没有被写回文件的机会了。</p>
<p>所以结论是，在正确实现的<code>munmap</code>中遇到未映射的页会自动跳过，什么也不会发生。</p>
<h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in param.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFILEMAP 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">filemap</span>&#123;</span></span><br><span class="line">  uint isused;<span class="comment">//对象池思想。该filemap是否正在被使用</span></span><br><span class="line">  uint64 va;<span class="comment">//该文件的起始内存页地址</span></span><br><span class="line">  uint64 okva;<span class="comment">//该文件的起始未被读入部分对应的内存地址</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span><span class="comment">//文件</span></span><br><span class="line">  <span class="type">size_t</span> length;<span class="comment">//需要映射到内存的长度</span></span><br><span class="line">  <span class="type">int</span> flags;<span class="comment">//MAP_SHARED OR MAP_PRIVATE</span></span><br><span class="line">  <span class="type">int</span> prot;<span class="comment">//PROT_READ OR PROT_WRITE</span></span><br><span class="line">  uint64 offset;<span class="comment">//va相对于file开头的offset</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">filemap</span> <span class="title">filemaps</span>[<span class="title">NFILEMAP</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>具体系统调用注册过程略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length,prot,flags,offset;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>,&amp;length) &lt; <span class="number">0</span> || argint(<span class="number">2</span>,&amp;prot) &lt; <span class="number">0</span> || argint(<span class="number">3</span>,&amp;flags) &lt; <span class="number">0</span> || argfd(<span class="number">4</span>,<span class="number">0</span>,&amp;file) ||argint(<span class="number">5</span>,&amp;offset) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> (uint64)mmap((<span class="type">void</span>*)addr,(<span class="type">size_t</span>)length,prot,flags,file,(uint)offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERRORADDR 0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射file从offset开始长度为length的内容到内存中，返回内存中的文件内容起始地址</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="keyword">struct</span> file* file,uint64 offset)</span>&#123;</span><br><span class="line">    <span class="comment">// mmap的prot权限必须与file的权限对应，不能file只读但是mmap却可写且shared</span></span><br><span class="line">    <span class="keyword">if</span>((prot&amp;PROT_WRITE) != <span class="number">0</span>&amp;&amp;flags == MAP_SHARED &amp;&amp;file-&gt;writable == <span class="number">0</span>)       </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到filemap池中第一个空闲的filemap</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!p-&gt;filemaps[i].isused)&#123;</span><br><span class="line">        <span class="comment">// 获取va,也即真正的address</span></span><br><span class="line">        va = p-&gt;sz;</span><br><span class="line">        p-&gt;sz += length;</span><br><span class="line">        <span class="comment">// 其实这里用一个memcpy会更加优雅，可惜我忘记了（）</span></span><br><span class="line">        p-&gt;filemaps[i].isused = <span class="number">1</span>;</span><br><span class="line">        p-&gt;filemaps[i].va = va;</span><br><span class="line">        p-&gt;filemaps[i].okva = va;</span><br><span class="line">        p-&gt;filemaps[i].length = length;</span><br><span class="line">        p-&gt;filemaps[i].prot = prot;</span><br><span class="line">        p-&gt;filemaps[i].flags = flags;</span><br><span class="line">        p-&gt;filemaps[i].file = file;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = offset;</span><br><span class="line">        p-&gt;filemaps[i].offset = offset;</span><br><span class="line">        <span class="comment">// 增加文件引用数</span></span><br><span class="line">        filedup(file);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(va == <span class="number">0</span>)  <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    <span class="comment">// return start of free memory</span></span><br><span class="line">    uint64 start_va = PGROUNDUP(va);</span><br><span class="line">    <span class="comment">// 先读入处于proc已申请的内存页区域（也即没有内存对齐情况下）</span></span><br><span class="line">    uint64 off = start_va - va;</span><br><span class="line">    <span class="keyword">if</span>(off &lt; PGSIZE)&#123;</span><br><span class="line">        fileread(file,va,off);</span><br><span class="line">        file-&gt;off += off;</span><br><span class="line">        p-&gt;filemaps[i].okva = va+off;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)va;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="usertrap-1"><a href="#usertrap-1" class="headerlink" title="usertrap"></a>usertrap</h4><h5 id="错的"><a href="#错的" class="headerlink" title="错的"></a>错的</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">   uint64 va = r_stval();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">       <span class="comment">// 找到va对应的filemap</span></span><br><span class="line">     <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;va&gt;=p-&gt;filemaps[i].va </span><br><span class="line">        &amp;&amp; va&lt;p-&gt;filemaps[i].va+p-&gt;filemaps[i].length)&#123;</span><br><span class="line">       <span class="comment">// 说明本来就不应该写</span></span><br><span class="line">       <span class="keyword">if</span>(r_scause() == <span class="number">15</span> &amp;&amp; ((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) == <span class="number">0</span>)&#123;</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//说明地址不在文件范围内</span></span><br><span class="line">       <span class="keyword">if</span>(p-&gt;filemaps[i].va+p-&gt;filemaps[i].file-&gt;ip-&gt;size &lt;= va)&#123;</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 能进到这里来的都是产生了缺页中断，也就是说va对应文件数据不存在</span></span><br><span class="line">       <span class="comment">// 我们需要维护一个okva，表示从filemaps.va到okva这段地址已经加载了文件</span></span><br><span class="line">       <span class="comment">// 这样一来，我们这里就只需加载okva~va地址对应的文件了</span></span><br><span class="line">       <span class="comment">// file结构体自带的off成员会由于fileread而自动增长到对应位置，所以文件可以自然地读写</span></span><br><span class="line">       uint64 start_va = p-&gt;filemaps[i].okva;<span class="comment">// okva一定是page-align的</span></span><br><span class="line">       <span class="comment">// 加载文件内容</span></span><br><span class="line">       <span class="keyword">while</span>(start_va &lt;= va)&#123;</span><br><span class="line">         <span class="type">char</span>* mem = kalloc();</span><br><span class="line">         <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">           p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">         <span class="type">int</span> flag = PTE_X|PTE_R|PTE_U;</span><br><span class="line">         <span class="keyword">if</span>(((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">           flag |= PTE_W;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(mappages(p-&gt;pagetable, start_va, PGSIZE, (uint64)mem, flag) != <span class="number">0</span>)&#123;</span><br><span class="line">           p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">           kfree(mem);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 读入文件内容</span></span><br><span class="line">         fileread(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">         start_va += PGSIZE;</span><br><span class="line">       &#125;</span><br><span class="line">       p-&gt;filemaps[i].okva = start_va;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="对的"><a href="#对的" class="headerlink" title="对的"></a>对的</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;va&gt;=p-&gt;filemaps[i].va &amp;&amp; va&lt;p-&gt;filemaps[i].va+p-&gt;filemaps[i].length)&#123;</span><br><span class="line">      <span class="keyword">if</span>(r_scause() == <span class="number">15</span> &amp;&amp; ((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 说明本来就不应该写</span></span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].va+p-&gt;filemaps[i].file-&gt;ip-&gt;size &lt;= va)&#123;</span><br><span class="line">        <span class="comment">//说明地址不在文件范围内</span></span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      uint64 start_va = PGROUNDDOWN(va);</span><br><span class="line">        <span class="type">char</span>* mem = kalloc();</span><br><span class="line">        <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="type">int</span> flag = PTE_X|PTE_R|PTE_U;</span><br><span class="line">        <span class="keyword">if</span>(((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">         flag |= PTE_W;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable, start_va, PGSIZE, (uint64)mem, flag) != <span class="number">0</span>)&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">          kfree(mem);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readi(p-&gt;filemaps[i].file-&gt;ip,<span class="number">0</span>,(uint64)mem,va-p-&gt;filemaps[i].va+p-&gt;filemaps[i].offset,PGSIZE);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h4><h5 id="错的-1"><a href="#错的-1" class="headerlink" title="错的"></a>错的</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">min</span><span class="params">(uint64 a,uint64 b)</span>&#123;<span class="keyword">return</span> a&gt;b?b:a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放文件映射以address为起始地址，length为长度这个范围内的内存地址空间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = (uint64)address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到对应的filemap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;p-&gt;filemaps[i].va&lt;=va&amp;&amp;p-&gt;filemaps[i].va+length&gt;va)&#123;</span><br><span class="line">        <span class="comment">// 开始释放的内存地址</span></span><br><span class="line">        uint64 start_va;</span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)</span><br><span class="line">            start_va = PGROUNDUP(p-&gt;filemaps[i].va);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start_va = PGROUNDDOWN(va);</span><br><span class="line">        <span class="comment">// 结束释放的内存地址</span></span><br><span class="line">        uint64 bounder = p-&gt;filemaps[i].va + min(p-&gt;filemaps[i].file-&gt;ip-&gt;size,length);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//file的off在trap中用于表示文件已加载的位置</span></span><br><span class="line">        <span class="comment">//在这里需要用off进行filewrite，所以需要对原本在usertrap用于记录加载位置的off进行手动保存</span></span><br><span class="line">        uint64 tmp_off = p-&gt;filemaps[i].file-&gt;off;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line">        <span class="keyword">while</span>(start_va &lt; bounder &amp;&amp; start_va &lt; p-&gt;filemaps[i].okva)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">            <span class="comment">//写回</span></span><br><span class="line">            filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">          &#125;</span><br><span class="line">          uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">          start_va += PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改filemap结构体的起始地址va和长度，offset也要变，因为他记录va对应的是文件哪个位置</span></span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)&#123;</span><br><span class="line">          <span class="comment">//释放的是头几页</span></span><br><span class="line">          p-&gt;filemaps[i].offset += length;</span><br><span class="line">          p-&gt;filemaps[i].va = va+length;</span><br><span class="line">          p-&gt;filemaps[i].length -= length;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//释放的是尾几页</span></span><br><span class="line">          p-&gt;filemaps[i].length -= p-&gt;filemaps[i].length - va;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = tmp_off;</span><br><span class="line">        <span class="comment">// 检验map的合理性</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;filemaps[i].length == <span class="number">0</span> || p-&gt;filemaps[i].va &gt;= p-&gt;filemaps[i].va+length</span><br><span class="line">                        || p-&gt;filemaps[i].file-&gt;off &gt; p-&gt;filemaps[i].file-&gt;ip-&gt;size)&#123;</span><br><span class="line">          p-&gt;filemaps[i].isused = <span class="number">0</span>;<span class="comment">//释放</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 注意！！！！这句话对我的错误代码来说非常重要</span></span><br><span class="line">          p-&gt;filemaps[i].file-&gt;off = <span class="number">0</span>;</span><br><span class="line">          fileclose(p-&gt;filemaps[i].file);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对的-1"><a href="#对的-1" class="headerlink" title="对的"></a>对的</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">min</span><span class="params">(uint64 a,uint64 b)</span>&#123;<span class="keyword">return</span> a&gt;b?b:a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = (uint64)address;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;p-&gt;filemaps[i].va&lt;=va&amp;&amp;p-&gt;filemaps[i].va+length&gt;va)&#123;</span><br><span class="line">        uint64 start_va;</span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)</span><br><span class="line">                start_va = PGROUNDUP(p-&gt;filemaps[i].va);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                start_va = PGROUNDDOWN(va);</span><br><span class="line">        uint64 bounder = p-&gt;filemaps[i].va + min(p-&gt;filemaps[i].file-&gt;ip-&gt;size,length);</span><br><span class="line">        <span class="comment">//在这里需要用off进行读写，所以需要对原本的加载处off手动保存</span></span><br><span class="line">        uint64 tmp_off = p-&gt;filemaps[i].file-&gt;off;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line">        <span class="keyword">while</span>(start_va &lt; bounder)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">            <span class="comment">//写回</span></span><br><span class="line">            filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">          &#125;</span><br><span class="line">          uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">          start_va += PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改filemap结构体的起始地址va和长度，offset也要变，因为他记录va对应的是文件哪个位置</span></span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)&#123;</span><br><span class="line">          <span class="comment">//释放的是头几页</span></span><br><span class="line">          p-&gt;filemaps[i].offset += length;</span><br><span class="line">          p-&gt;filemaps[i].va = va+length;</span><br><span class="line">          p-&gt;filemaps[i].length -= length;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//释放的是尾几页</span></span><br><span class="line">          p-&gt;filemaps[i].length -= p-&gt;filemaps[i].length - va;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检验map的合理性</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;filemaps[i].length == <span class="number">0</span> || p-&gt;filemaps[i].va &gt;= p-&gt;filemaps[i].va+length</span><br><span class="line">                        || p-&gt;filemaps[i].file-&gt;off &gt; p-&gt;filemaps[i].file-&gt;ip-&gt;size)&#123;</span><br><span class="line">          p-&gt;filemaps[i].isused = <span class="number">0</span>;<span class="comment">//释放</span></span><br><span class="line">          fileclose(p-&gt;filemaps[i].file);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = tmp_off;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exit和fork"><a href="#exit和fork" class="headerlink" title="exit和fork"></a>exit和fork</h4><h5 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭map-file</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;filemaps[i].isused)&#123;</span><br><span class="line">    munmap((<span class="type">void</span>*)(p-&gt;filemaps[i].va),p-&gt;filemaps[i].length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fork-1"><a href="#fork-1" class="headerlink" title="fork"></a>fork</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">  np-&gt;filemaps[i].isused = p-&gt;filemaps[i].isused;</span><br><span class="line">  np-&gt;filemaps[i].va = p-&gt;filemaps[i].va;</span><br><span class="line">  np-&gt;filemaps[i].okva = p-&gt;filemaps[i].okva;</span><br><span class="line">  np-&gt;filemaps[i].file = p-&gt;filemaps[i].file;</span><br><span class="line">  np-&gt;filemaps[i].length = p-&gt;filemaps[i].length;</span><br><span class="line">  np-&gt;filemaps[i].flags = p-&gt;filemaps[i].flags;</span><br><span class="line">  np-&gt;filemaps[i].offset = p-&gt;filemaps[i].offset;</span><br><span class="line">  np-&gt;filemaps[i].prot = p-&gt;filemaps[i].prot;</span><br><span class="line">  <span class="keyword">if</span>(np-&gt;filemaps[i].file)</span><br><span class="line">    filedup(np-&gt;filemaps[i].file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改uvmcopy和uvmunmap"><a href="#修改uvmcopy和uvmunmap" class="headerlink" title="修改uvmcopy和uvmunmap"></a>修改uvmcopy和uvmunmap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in uvmunmap()</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      *pte = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// in uvmcopy()</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<h1 id="其他的对实验未涉及的思考"><a href="#其他的对实验未涉及的思考" class="headerlink" title="其他的对实验未涉及的思考"></a>其他的对实验未涉及的思考</h1><h2 id="由mkfs引发的对虚拟机的学习"><a href="#由mkfs引发的对虚拟机的学习" class="headerlink" title="由mkfs引发的对虚拟机的学习"></a>由mkfs引发的对虚拟机的学习</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247489645&idx=5&sn=a6ad41806effb6bc8ff4815f4eab968a&chksm=fbb29193ccc51885348ce6dfb81661ecc17cd271bf6fb79a78a656b49d4eccaa9de7606c01cc&scene=27">懂了！VMware/KVM/Docker原来是这么回事儿</a>这篇文章对虚拟化、虚拟机技术讲解很到位，写得通俗易懂，非常值得一看</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24123210/answer/2852910075">KVM 的「基于内核的虚拟机」是什么意思？</a>这篇文章对QEMU-KVM架构进行了详细的介绍。还有这篇文章对应的知乎问题下面的高赞回答有机会也可以去看看。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hbuxiaofei/article/details/113556046">QEMU/KVM原理概述</a>这篇文章前面的原理和上面那个差不多，后面有使用kvm做一个精简内核的实例，有兴趣/有精力/有需要可以看看。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23924713/article/details/126080325">MIT6.S081操作系统实验——操作系统是如何在qemu虚拟机中启动的？</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mumu3w/article/details/54173069">xv6分析–mkfs源代码注释</a></p>
</blockquote>
<p>以前只是知道，xv6是运行在qemu提供的虚拟环境之上的。qemu是什么，怎么虚拟的，虚拟机和宿主机是怎么交互的，这些一概不通。今天心血来潮想研究下qemu，虚拟机啥的到底是什么玩意，虽然看得有些猪脑过载，但还是写下一些个人的整理。</p>
<h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>在了解qemu之前，可以先了解一下虚拟化的思想。</p>
<h5 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h5><blockquote>
<p>虚拟化的主要思想是，通过分层将底层的复杂、难用的资源虚拟抽象成简单、易用的资源，<strong>提供给上层</strong>使用。</p>
<p>本质上，计算机的发展过程也是虚拟化不断发展的过程，底层的资源或者通过<strong>空间的分割</strong>，或者通过<strong>时间的分割</strong>，将下层的资源通过一种简单易用的方式转换成另一种资源，提供给上层使用。</p>
<p>虚拟化可分为以下几方面：</p>
<ol>
<li><strong>CPU抽象</strong>：机器码、汇编语言到C语言、再到高级语言的不断虚拟的过程</li>
<li><strong>存储抽象</strong>：操作系统通过文件和目录抽象</li>
<li><strong>网络抽象</strong>：TCP/IP协议栈模型将网卡设备中传递的二进制数据，经过网络层、传输层的抽象后，为应用程序提供了便捷的网络包处理接口，而无需关心底层的IP路由、分片等细节</li>
<li><strong>进程抽象</strong>：操作系统通过进程抽象为不同的应用程序提供了安全隔离的执行环境，并且有着独立的CPU和内存等资源</li>
</ol>
</blockquote>
<p>虚拟化的思想实际上就是我以前一直称为“抽象”的思想，以接口的形式逐层向上服务。</p>
<h5 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h5><blockquote>
<p>虚拟机的核心能力在于<strong>提供一个执行环境</strong>（隐藏底层细节），并在其中完成用户的指定任务。</p>
</blockquote>
<blockquote>
<p>虚拟机有多种不同的<strong>形式</strong>，包括提供指令执行环境的进程、模拟器和高级语言虚拟机，或者是提供一个完整的系统环境的系统虚拟机。</p>
</blockquote>
<h6 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h6><p>进程实际上就是一种虚拟机。</p>
<blockquote>
<p>进程可以看作是一组<strong>资源的集合</strong>，有自己<strong>独立</strong>的进程地址空间以及<strong>独立</strong>的CPU和寄存器，执行程序员编写的指令，完成一定的任务。</p>
<p>操作系统可以创建多个进程，每一个进程都可以看成一个<strong>独立的虚拟机</strong>，它们在执行指令、访问内存的时候并不会相互影响影响。</p>
</blockquote>
<h6 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h6><h6 id="高级语言虚拟机"><a href="#高级语言虚拟机" class="headerlink" title="高级语言虚拟机"></a>高级语言虚拟机</h6><h6 id="系统虚拟机"><a href="#系统虚拟机" class="headerlink" title="系统虚拟机"></a>系统虚拟机</h6><blockquote>
<p>通过<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">系统虚拟化技术</a>，能够在<strong>单个的宿主机硬件平台上运行多个虚拟机</strong>，每个虚拟机都有着完整的虚拟机硬件，如虚拟的CPU、内存、虚拟的外设等，并且虚拟机之间能够实现完整的隔离。</p>
<p>在系统虚拟化中，管理全局物理资源的软件叫作<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%91%E6%8E%A7%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">虚拟机监控器</a>（Virtual Machine Monitor，VMM），<u>VMM之于虚拟机就如同操作系统之于进程</u>，VMM利用时分复用或者空分复用的办法将硬件资源在各个虚拟机之间进行分配。</p>
</blockquote>
<h5 id="qemu-1"><a href="#qemu-1" class="headerlink" title="qemu"></a>qemu</h5><p>可以看到，qemu就是一种虚拟机。它可以模拟虚拟机硬件，为操作系统提供虚拟硬件环境，从而能够让不同的操作系统能够在不同主机硬件上执行。</p>
<h4 id="qemu-kvm架构"><a href="#qemu-kvm架构" class="headerlink" title="qemu-kvm架构"></a>qemu-kvm架构</h4><h5 id="诞生的原因"><a href="#诞生的原因" class="headerlink" title="诞生的原因"></a>诞生的原因</h5><blockquote>
<p>其对于虚拟化技术的优化，以及发展的前因后果，具体可以看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247489645&idx=5&sn=a6ad41806effb6bc8ff4815f4eab968a&chksm=fbb29193ccc51885348ce6dfb81661ecc17cd271bf6fb79a78a656b49d4eccaa9de7606c01cc&scene=27">懂了！VMware/KVM/Docker原来是这么回事儿</a>这篇文章。</p>
<p>概括来讲，大致有以下几个要点：</p>
</blockquote>
<h6 id="两种虚拟化方案"><a href="#两种虚拟化方案" class="headerlink" title="两种虚拟化方案"></a>两种虚拟化方案</h6><img src="/2023/01/10/xv6/640.png" class>

<img src="/2023/01/10/xv6/640-1676793944101-7.png" class>

<h6 id="实现上述的虚拟化方案"><a href="#实现上述的虚拟化方案" class="headerlink" title="实现上述的虚拟化方案"></a>实现上述的虚拟化方案</h6><p>一个典型的做法是——<code>陷阱 &amp; 模拟</code>技术</p>
<p>什么意思？<strong>简单来说就是正常情况下直接把虚拟机中的代码指令放到物理的CPU上去执行，一旦执行到一些敏感指令，就触发异常，控制流程交给VMM，由VMM来进行对应的处理，以此来营造出一个虚拟的计算机环境。</strong></p>
<h6 id="x86架构的问题"><a href="#x86架构的问题" class="headerlink" title="x86架构的问题"></a>x86架构的问题</h6><p>x86架构使得上述做法用不了了。因为它引入了四种权限</p>
<img src="/2023/01/10/xv6/image-20230219160725978.png" class>

<h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h6><ol>
<li><p>全虚拟化</p>
<p>VMware的二进制翻译技术、QEMU的模拟指令集</p>
</li>
<li><p>半虚拟化</p>
</li>
<li><p>硬件辅助虚拟化</p>
<p>硬件辅助虚拟化细节较为复杂，简单来说，新一代CPU在原先的Ring0-Ring3四种工作状态之下，再引入了一个叫工作模式的概念，有<code>VMX root operation</code>和<code>VMX non-root operation</code>两种模式，每种模式都具有完整的Ring0-Ring3四种工作状态，前者是VMM运行的模式，后者是虚拟机中的OS运行的模式。</p>
<p>qemu-kvm架构正是借助于此实现的。</p>
</li>
</ol>
<h6 id="kvm"><a href="#kvm" class="headerlink" title="kvm"></a>kvm</h6><p>kvm就是借助硬件辅助虚拟化诞生的。可以把kvm看作是一堆系统调用。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.redhat.com/zh/topics/virtualization/what-is-KVM">什么是 KVM？</a></p>
<p>KVM本身是一个<strong>内核模块</strong>，它导出了一系列的<strong>接口</strong>到用户空间，用户态程序可以使用这些接口创建虚拟机。</p>
<p>具体而言，KVM 可帮助您将 Linux 转变为<a target="_blank" rel="noopener" href="https://www.redhat.com/zh/topics/virtualization/what-is-a-hypervisor">虚拟机监控程序</a>，使主机计算机能够运行多个隔离的虚拟环境，即虚拟客户机或虚拟机（VM）。【也即，虚拟机—进程，KVM—操作系统】</p>
</blockquote>
<blockquote>
<p>在虚拟化底层技术上，<u>KVM和VMware后续版本一样</u>，都是基于<strong>硬件辅助虚拟化</strong>实现。不同的是VMware作为独立的第三方软件可以安装在Linux、Windows、MacOS等多种不同的操作系统之上，而KVM作为一项虚拟化技术已经<strong>集成</strong>到Linux内核之中，可以认为Linux内核本身就是一个HyperVisor，这也是KVM名字的含义，因此该技术只能在Linux服务器上使用。</p>
</blockquote>
<h6 id="qemu-kvm"><a href="#qemu-kvm" class="headerlink" title="qemu-kvm"></a>qemu-kvm</h6><p>KVM本身基于硬件辅助虚拟化，仅仅实现CPU和内存的虚拟化，但一台计算机不仅仅有CPU和内存，还需要各种各样的I/O设备，不过KVM不负责这些。这个时候，QEMU就和KVM搭上了线，经过改造后的QEMU，负责外部设备的虚拟，KVM负责底层执行引擎和内存的虚拟，两者彼此互补，成为新一代云计算虚拟化方案的宠儿。</p>
<h5 id="qemu-kvm总体架构"><a href="#qemu-kvm总体架构" class="headerlink" title="qemu-kvm总体架构"></a>qemu-kvm总体架构</h5><p>KVM只负责最核心的<strong>CPU虚拟化和内存虚拟化</strong>部分；QEMU作为其用户态组件，负责完成<strong>大量外设的模拟</strong>。</p>
<img src="/2023/01/10/xv6/v2-249a3f162de88198bbe415110fc71c7f_1440w.jpg" class>

<h6 id="VMX-root和VMX-non-root"><a href="#VMX-root和VMX-non-root" class="headerlink" title="VMX root和VMX non root"></a>VMX root和VMX non root</h6><blockquote>
<p>VMX root是宿主机模式，此时CPU在运行包括QEMU在内的普通进程和宿主机的操作系统内核；</p>
<p>VMX non-root是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">虚拟机模式</a>，此时CPU在运行虚拟机中的用户程序和操作系统代码。</p>
</blockquote>
<p>也就是说，虚拟机的程序，包括用户程序和内核程序，都运行在non-root模式。宿主机的所有程序，包括用户程序【包括qemu】和内核程序【包括kvm】，都运行在root模式。</p>
<h6 id="qemu层（左上）"><a href="#qemu层（左上）" class="headerlink" title="qemu层（左上）"></a>qemu层（左上）</h6><p>上面说到，qemu负责的是大量外设的模拟。它具体要做以下几件事：</p>
<blockquote>
<p>初始化虚拟机：</p>
<ol>
<li><p>创建模拟的芯片组</p>
</li>
<li><p>创建<strong>CPU线程</strong>来表示虚拟机的CPU</p>
<p>QEMU在初始化虚拟机的CPU线程时，首先设置好相应的虚拟CPU寄存器的值，然后调用KVM的接口将虚拟机运行起来，这样CPU线程就会被调度在物理CPU上执行虚拟机的代码。</p>
</li>
<li><p><strong>在QEMU的虚拟地址空间中分配空间作为虚拟机的物理地址</strong></p>
</li>
<li><p>根据用户在命令行<strong>指定的设备</strong>为虚拟机创建对应的虚拟设备【如各种IO设备】</p>
</li>
</ol>
<p>虚拟机运行时：</p>
<ol>
<li><p>监听多种事件</p>
<p>包括虚拟机对设备的I/O访问、用户对虚拟机管理界面、虚拟设备对应的宿主机上的一些I/O事件（比如虚拟机网络数据的接收）等</p>
</li>
<li><p>调用函数处理</p>
</li>
</ol>
</blockquote>
<p>可以看到，qemu确实利用了宿主机的各种资源，提供了一个很完美的硬件环境。其资源对应关系为：</p>
<p>虚拟机的CPU——宿主机的一个线程</p>
<p>虚拟机的物理地址——qemu在宿主机的虚拟地址</p>
<p>虚拟机对硬件设备的访问 —→ 对qemu的访问 </p>
<h6 id="kvm层（下方）"><a href="#kvm层（下方）" class="headerlink" title="kvm层（下方）"></a>kvm层（下方）</h6><p>它大概做了两件事：</p>
<ol>
<li><p>给qemu提供运行时的参数</p>
<p>通过“/dev/kvm”设备，比如CPU个数、内存布局、运行等。</p>
</li>
<li><p>截获VM Exit事件【下面会讲，用来完成虚拟机和硬件环境的交互】并进行处理。</p>
</li>
</ol>
<h6 id="虚拟机层（右上）"><a href="#虚拟机层（右上）" class="headerlink" title="虚拟机层（右上）"></a>虚拟机层（右上）</h6><ol>
<li><p>CPU——QEMU进程中的一个线程</p>
<p>通过QEMU和KVM的相互协作，虚拟机的线程会被宿主机操作系统正常调度，<strong>直接执行虚拟机中的代码</strong></p>
</li>
<li><p>物理地址——QEMU进程中的虚拟地址</p>
</li>
<li><p>设备——QEMU实现</p>
<p>在运行过程中，虚拟机操作系统通过设备的I/O端口（Port IO、PIO）或者MMIO（Memory Mapped I/O）进行交互，<strong>KVM会截获这个请求</strong>【也即VM Exit，下面会讲】，大多数时候KVM会将请求分发到用户空间的QEMU进程中，由<strong>QEMU处理</strong>这些I/O请求</p>
</li>
</ol>
<h5 id="虚拟机在QEMU-KVM架构的执行方法"><a href="#虚拟机在QEMU-KVM架构的执行方法" class="headerlink" title="虚拟机在QEMU-KVM架构的执行方法"></a>虚拟机在QEMU-KVM架构的执行方法</h5><h6 id="状态管理虚拟化"><a href="#状态管理虚拟化" class="headerlink" title="状态管理虚拟化"></a>状态管理虚拟化</h6><p>虚拟机肯定是会与它的硬件环境进行交互的，它的硬件环境也就是QEMU—KVM。</p>
<p>虚拟机的用户程序和内核程序都是直接由宿主机的操作系统正常调度，我们可以将其看作虚拟态。QEMU—KVM可以看作是宿主机的进程，我们可以将其看作宿主态。因而，当虚拟机一些事情希望由QEMU—KVM来做，我们就需要从虚拟态转移到宿主态。</p>
<p>听起来有没有感觉很耳熟？是的，“从用户态陷入内核态”，跟这个的原理是一样的。</p>
<p>因而，虚拟机与硬件环境交互，实际上是虚拟态和宿主态状态的转换，如下图：</p>
<img src="/2023/01/10/xv6/v2-9377a260d034d2904b1807d3fe53dcd9_1440w.jpg" class>

<p><strong>VM Exit</strong></p>
<p>当虚拟机中的代码是敏感指令或者说满足了一定的退出条件时，CPU会从虚拟态退出到KVM，这叫作VM Exit。</p>
<p>这就像在用户态执行指令陷入内核一样。</p>
<p>VM Exit首先陷入到KVM中进行处理，如果KVM无法处理，比如说虚拟机写了设备的寄存器地址，那么KVM会将这个写操作分派到QEMU中进行处理。</p>
<p><strong>VM Entry</strong></p>
<p>当KVM或者QEMU处好了退出事件之后，又可以将CPU置于虚拟态以运行虚拟机代码，这叫作VM Entry。</p>
<h6 id="内存管理虚拟化"><a href="#内存管理虚拟化" class="headerlink" title="内存管理虚拟化"></a>内存管理虚拟化</h6><blockquote>
<p>QEMU在初始化的时候会通过<code>mmap</code>分配虚拟内存空间作为虚拟机的物理内存，【感觉思路打开，物理内存与文件对应了起来】QEMU在不断更新内存布局的过程中会持续调用KVM接口通知内核KVM模块虚拟机的内存分布。</p>
</blockquote>
<p>虚拟机在运行过程中，首先需要将虚拟机的虚拟地址（Guest Virtual Address，GVA）转换成虚拟机的物理地址（Guest Physical Address，GPA），然后将虚拟机的物理地址转换成宿主机的虚拟地址（Host Virtual Address，HVA），最终转换成宿主机的物理地址（Host Physical Address，HPA）。</p>
<p>整个寻址过程由硬件实现，具体实现方式为扩展页表（Extended Page Table，EPT）。</p>
<p>在支持EPT的环境中，虚拟机在<strong>第一次访问内存的时候就会陷入到KVM</strong>，KVM会<strong>逐渐建立</strong>起所谓的EPT页面【lazy思想贯穿始终，还是该叫自适应？】。这样虚拟机的虚拟CPU在后面访问虚拟机虚拟内存地址的时候，首先会被转换为虚拟机物理地址，接着会查找EPT页表，然后得到宿主机物理地址。【有种TLB的感觉】</p>
<img src="/2023/01/10/xv6/v2-942e1ed598eed3d401d00e4719224d27_1440w.jpg" class>

<h6 id="外设管理虚拟化"><a href="#外设管理虚拟化" class="headerlink" title="外设管理虚拟化"></a>外设管理虚拟化</h6><p>设备模拟的本质是要为虚拟机提供一个<strong>与物理设备接口完全一致的虚拟接口</strong>。</p>
<p>虚拟机中的操作系统与设备进行的数据交互或者由QEMU和（或）KVM完成，或者由宿主机上对应的后端设备完成。</p>
<p>QEMU在初始化过程中会创建好模拟芯片组和必要的模拟设备，包括南北桥芯片、PCI根总线、ISA根总线等总线系统，以及各种PCI设备、ISA设备等。</p>
<p>外设虚拟化主要有如下几种方式：</p>
<ol>
<li><p>纯软件模拟（完全虚拟化）</p>
<p>QEMU最早的方案，虚拟机内核不用做任何修改，每一次对设备的寄存器读写都会陷入到KVM，进而到QEMU，QEMU再对这些请求进行处理并模拟硬件行为。</p>
<p>软件模拟会导致非常多的QEMU/KVM接入，效率低下。</p>
</li>
<li><p>virtio设备（半虚拟化）</p>
<p>virtio设备是一类特殊的设备，并没有对应的物理设备，所以需要虚拟机内部操作系统安装特殊的virtio驱动。</p>
<p>相比软件模拟，virtio方案提高了虚拟设备的性能。</p>
</li>
<li><p>设备直通</p>
<p>将物理硬件设备直接挂到虚拟机上，虚拟机直接与物理设备交互，尽可能在I/O路径上减少QEMU/KVM的参与。</p>
<p>设备直通经常搭配硬件虚拟化支持技术SRIOV（Single Root I/O Virtualization，单根输入/输出虚拟化）使用，SRIOV能够将单个的物理硬件高效地虚拟出多个虚拟硬件。</p>
</li>
</ol>
<img src="/2023/01/10/xv6/v2-555d017ce5b65457f98617a5fdf232af_1440w.jpg" class>

<h6 id="中断处理虚拟化"><a href="#中断处理虚拟化" class="headerlink" title="中断处理虚拟化"></a>中断处理虚拟化</h6><p>操作系统通过写设备的I/O端口或者MMIO地址来与设备交互，设备通过发送中断来通知操作系统事件。</p>
<p>QEMU/KVM一方面需要完成这项<strong>中断设备的模拟</strong>，另一方面需要模拟<strong>中断的请求处理</strong>。</p>
<blockquote>
<p>QEMU支持单CPU的Intel 8259中断控制器以及SMP的I/O APIC（I/O Advanced Programmable Interrupt Controller）和LAPIC（Local Advanced Programmable Interrupt Controller）中断控制器。在这种方式下，虚拟外设通过QEMU向虚拟机注入中断，需要先陷入到KVM，然后由KVM向虚拟机注入中断，这是一个非常费时的操作。</p>
<p>为了提高虚拟机的效率，KVM自己也实现了中断控制器Intel 8259、I/O APIC以及LAPIC。用户可以有选择地让QEMU或者KVM模拟全部中断控制器，也可以让QEMU模拟Intel 8259中断控制器和I/O APIC，让KVM模拟LAPIC。</p>
</blockquote>
<h4 id="xv6的全启动运行过程梳理"><a href="#xv6的全启动运行过程梳理" class="headerlink" title="xv6的全启动运行过程梳理"></a>xv6的全启动运行过程梳理</h4><p>介绍完上述的qemu虚拟化，接下来就可以对xv6的全启动进行一个梳理了。</p>
<p>首先，在宿主机执行<code>make qemu</code>。</p>
<p>在<code>Makefile</code>中可以看到：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">qemu: $K/kernel fs.img</span></span><br><span class="line">        <span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span></span><br><span class="line">QEMU = qemu-system-riscv64</span><br></pre></td></tr></table></figure>

<p>在log中可以看到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">mkfs/mkfs fs.img README user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie user/_mmaptest</span><br><span class="line">...</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>具体的<code>Makefile</code>相关内容我不大了解，但结合输出，我想大概是先通过<code>riscv64-linux-gnu-gcc</code>编译链接完所有文件，然后再执行<code>mkfs</code>产生<code>fs.img</code>镜像（<code>mkfs</code>后面那些东西应该是文件参数，对应于源码中的读取可执行程序进磁盘的部分），最后再运行<code>qemu-system-riscv64</code>开始对虚拟机进行boot。</p>
<p>boot直至启动后的所有代码，都是通过QEMU-KVM架构处理，直接运行在宿主机的CPU上的。其余的各种管理，可以详见小标题<code>虚拟机在QEMU-KVM架构的执行方法</code>。</p>
<h4 id="mkfs的作用及源码解读"><a href="#mkfs的作用及源码解读" class="headerlink" title="mkfs的作用及源码解读"></a>mkfs的作用及源码解读</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>上面的知识表明，<strong>操作系统的启动在于文件系统初始化之后</strong>，这是因为操作系统本身的启动代码，放在磁盘映像<code>fs.img</code>中，而<code>fs.img</code>正是由文件系统初始化时弄出来的。也就是说，<strong>文件系统是操作系统的爸爸</strong>。【我以前一直以为是反过来的】</p>
<img src="/2023/01/10/xv6/image-20230121162324747.png" class>

<blockquote>
<p>图中的boot块就是操作系统的引导扇区。</p>
</blockquote>
<p>而<code>mkfs</code>的作用，正是把宿主机提供的<strong>虚拟地址空间作为虚拟磁盘</strong>，把虚拟地址空间划分为如上图所示的地址结构。<strong>它是运行在宿主机当中的</strong>。有了<code>mkfs</code>，才能有我们的虚拟机。</p>
<h5 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mumu3w/article/details/54173069">xv6分析–mkfs源代码注释</a></p>
<p>yysy这个就写得很好了。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/21/JavaWeb/" rel="prev" title="JavaWeb">
      <i class="fa fa-chevron-left"></i> JavaWeb
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/25/cs144/" rel="next" title="cs144">
      cs144 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Operating-system-interface"><span class="nav-number">1.</span> <span class="nav-text">Operating system interface</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Operating-system-oganization"><span class="nav-number">2.</span> <span class="nav-text">Operating system oganization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel-organization"><span class="nav-number">2.1.</span> <span class="nav-text">Kernel organization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E5%86%85%E6%A0%B8%E4%B8%8E%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="nav-number">2.1.1.</span> <span class="nav-text">宏内核与微内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code-xv6-organization"><span class="nav-number">2.1.2.</span> <span class="nav-text">Code: xv6 organization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-overview"><span class="nav-number">2.2.</span> <span class="nav-text">Process overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-starting-xv6-and-the-fifirst-process"><span class="nav-number">2.3.</span> <span class="nav-text">Code: starting xv6 and the fifirst process</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#xv6"><span class="nav-number">2.3.1.</span> <span class="nav-text">xv6</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">加载操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">操作系统初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#entry-S%E9%85%8D%E7%BD%AE%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="nav-number">2.3.1.2.1.</span> <span class="nav-text">entry.S配置栈空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#start-c"><span class="nav-number">2.3.1.2.2.</span> <span class="nav-text">start.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#main-c"><span class="nav-number">2.3.1.2.3.</span> <span class="nav-text">main.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#proc-c%E4%B8%AD%E7%9A%84userinit"><span class="nav-number">2.3.1.2.4.</span> <span class="nav-text">proc.c中的userinit()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#initcode-S"><span class="nav-number">2.3.1.2.5.</span> <span class="nav-text">initcode.S</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#init-c"><span class="nav-number">2.3.1.2.6.</span> <span class="nav-text">init.c</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">感想</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux0-11"><span class="nav-number">2.3.2.</span> <span class="nav-text">linux0.11</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">加载操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%85%A5bootsect-s"><span class="nav-number">2.3.2.1.1.</span> <span class="nav-text">读入bootsect.s</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bootsect-s"><span class="nav-number">2.3.2.1.2.</span> <span class="nav-text">bootsect.s</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setup-s"><span class="nav-number">2.3.2.1.3.</span> <span class="nav-text">setup.s</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">操作系统初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#head-s"><span class="nav-number">2.3.2.2.1.</span> <span class="nav-text">head.s</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#main-c-1"><span class="nav-number">2.3.2.2.2.</span> <span class="nav-text">main.c</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-1"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">感想</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world"><span class="nav-number">2.4.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-system-calls"><span class="nav-number">2.5.</span> <span class="nav-text">Lab system calls</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#trace"><span class="nav-number">2.5.1.</span> <span class="nav-text">trace</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-2"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">代码步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%AD%BE%E5%90%8D"><span class="nav-number">2.5.1.2.1.</span> <span class="nav-text">在各种文件添加签名</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#user-user-h"><span class="nav-number">2.5.1.2.1.1.</span> <span class="nav-text">user&#x2F;user.h</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#user-usys-pl"><span class="nav-number">2.5.1.2.1.2.</span> <span class="nav-text">user&#x2F;usys.pl</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#syscall-h"><span class="nav-number">2.5.1.2.1.3.</span> <span class="nav-text">syscall.h</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#syscall-c"><span class="nav-number">2.5.1.2.1.4.</span> <span class="nav-text">syscall.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9Makefile"><span class="nav-number">2.5.1.2.1.5.</span> <span class="nav-text">修改Makefile</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">2.5.1.2.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9proc-h"><span class="nav-number">2.5.1.2.2.1.</span> <span class="nav-text">修改proc.h</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BC%96%E5%86%99trace-c"><span class="nav-number">2.5.1.2.2.2.</span> <span class="nav-text">编写trace.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9syscall-c"><span class="nav-number">2.5.1.2.2.3.</span> <span class="nav-text">修改syscall.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%A8sysproc-c%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.5.1.2.2.4.</span> <span class="nav-text">在sysproc.c中添加系统调用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%A8defs-h%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9C%80%E8%A6%81public%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><span class="nav-number">2.5.1.2.2.5.</span> <span class="nav-text">在defs.h中添加需要public的函数签名</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sysinfotest"><span class="nav-number">2.5.2.</span> <span class="nav-text">sysinfotest</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-3"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sysinfo-c"><span class="nav-number">2.5.2.2.1.</span> <span class="nav-text">sysinfo.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sysproc-c%E4%B8%AD"><span class="nav-number">2.5.2.2.2.</span> <span class="nav-text">sysproc.c中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kalloc-c%E4%B8%AD"><span class="nav-number">2.5.2.2.3.</span> <span class="nav-text">kalloc.c中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#proc-c%E4%B8%AD"><span class="nav-number">2.5.2.2.4.</span> <span class="nav-text">proc.c中</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E9%A2%98"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">附加题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#trace-plus"><span class="nav-number">2.5.2.3.1.</span> <span class="nav-text">trace plus</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sysinfo-plus"><span class="nav-number">2.5.2.3.2.</span> <span class="nav-text">sysinfo plus</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Page-tables"><span class="nav-number">3.</span> <span class="nav-text">Page tables</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Paging-hardware"><span class="nav-number">3.1.</span> <span class="nav-text">Paging hardware</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.1.1.</span> <span class="nav-text">为什么需要页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%BB%84%E6%88%90"><span class="nav-number">3.1.2.</span> <span class="nav-text">页表组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">页表项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%A1%B5%E8%A1%A8%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">单页表和多级页表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.3.</span> <span class="nav-text">页表使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel-address-space"><span class="nav-number">3.2.</span> <span class="nav-text">Kernel address space</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-creating-an-address-space"><span class="nav-number">3.3.</span> <span class="nav-text">Code: creating an address space</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vm-c"><span class="nav-number">3.3.1.</span> <span class="nav-text">vm.c</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA%E4%BE%8B%E4%BB%8B%E7%BB%8D%E5%90%84%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">以初始化为例介绍各个函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.3.1.1.1.</span> <span class="nav-text">创建页表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A3%85%E4%B8%8A%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.3.1.1.2.</span> <span class="nav-text">装上页表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%96%91%E9%97%AE"><span class="nav-number">3.3.1.1.2.1.</span> <span class="nav-text">疑问</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%88%91%E7%9A%84%E9%94%99%E8%AF%AF%E6%83%B3%E6%B3%95"><span class="nav-number">3.3.1.1.2.2.</span> <span class="nav-text">我的错误想法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E7%AD%94"><span class="nav-number">3.3.1.1.2.3.</span> <span class="nav-text">解答</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Physical-memory-allocation"><span class="nav-number">3.4.</span> <span class="nav-text">Physical memory allocation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Physical-memory-allocator"><span class="nav-number">3.5.</span> <span class="nav-text">Code: Physical memory allocator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-address-space"><span class="nav-number">3.6.</span> <span class="nav-text">Process address space</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-sbrk"><span class="nav-number">3.7.</span> <span class="nav-text">Code: sbrk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-exec"><span class="nav-number">3.8.</span> <span class="nav-text">Code:exec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world-1"><span class="nav-number">3.9.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab%EF%BC%9APagetable"><span class="nav-number">3.10.</span> <span class="nav-text">Lab：Pagetable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Speed-up-system-calls"><span class="nav-number">3.10.1.</span> <span class="nav-text">Speed up system calls</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-4"><span class="nav-number">3.10.1.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%8C%E9%BE%99"><span class="nav-number">3.10.1.1.1.</span> <span class="nav-text">乌龙</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#panic-freewalk-leaf"><span class="nav-number">3.10.1.1.2.</span> <span class="nav-text">panic:freewalk leaf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.10.1.1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">3.10.1.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E7%AD%94%E9%A2%98"><span class="nav-number">3.10.1.3.</span> <span class="nav-text">问答题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Print-a-page-table"><span class="nav-number">3.10.2.</span> <span class="nav-text">Print a page table</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-5"><span class="nav-number">3.10.2.1.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="nav-number">3.10.2.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E7%AD%94%E9%A2%98-1"><span class="nav-number">3.10.2.3.</span> <span class="nav-text">问答题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Detecting-which-pages-have-been-accessed"><span class="nav-number">3.10.3.</span> <span class="nav-text">Detecting which pages have been accessed</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-6"><span class="nav-number">3.10.3.1.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="nav-number">3.10.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-kernel-page-table-per-process"><span class="nav-number">3.10.4.</span> <span class="nav-text">A kernel page table per process</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-7"><span class="nav-number">3.10.4.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%B9%B2"><span class="nav-number">3.10.4.1.1.</span> <span class="nav-text">为什么要这么干</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Emyproc"><span class="nav-number">3.10.4.1.2.</span> <span class="nav-text">关于myproc()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">3.10.4.1.3.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E9%A1%B5%E8%A1%A8%E4%BD%86%E4%B8%8D%E9%87%8A%E6%94%BE%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-number">3.10.4.1.4.</span> <span class="nav-text">释放页表但不释放物理内存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="nav-number">3.10.4.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.10.4.2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#swtch%E6%97%B6%E5%88%87%E6%8D%A2%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.10.4.2.2.</span> <span class="nav-text">swtch时切换页表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9kvmpa"><span class="nav-number">3.10.4.2.3.</span> <span class="nav-text">修改kvmpa</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8A%E6%94%BE"><span class="nav-number">3.10.4.2.4.</span> <span class="nav-text">释放</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Simplify-copyin-copyinstr"><span class="nav-number">3.10.5.</span> <span class="nav-text">Simplify copyin&#x2F;copyinstr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-8"><span class="nav-number">3.10.5.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AF%E5%85%A5%E5%B9%BB%E6%83%B3"><span class="nav-number">3.10.5.1.1.</span> <span class="nav-text">误入幻想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%B0%E4%B8%8A%E6%AD%A3%E9%80%94"><span class="nav-number">3.10.5.1.2.</span> <span class="nav-text">走上正途</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="nav-number">3.10.5.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B8%94%E7%BF%81%E4%B9%8B%E5%88%A9%E5%87%BD%E6%95%B0"><span class="nav-number">3.10.5.2.1.</span> <span class="nav-text">渔翁之利函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9fork%E3%80%81exec%E3%80%81sbrk"><span class="nav-number">3.10.5.2.2.</span> <span class="nav-text">修改fork、exec、sbrk</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#fork"><span class="nav-number">3.10.5.2.2.1.</span> <span class="nav-text">fork</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#exec"><span class="nav-number">3.10.5.2.2.2.</span> <span class="nav-text">exec</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sbrk"><span class="nav-number">3.10.5.2.2.3.</span> <span class="nav-text">sbrk</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#userinit"><span class="nav-number">3.10.5.2.3.</span> <span class="nav-text">userinit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E6%8E%89freewalk%E7%9A%84panic%EF%BC%88%E6%88%91%E7%89%B9%E6%9C%89%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%89"><span class="nav-number">3.10.5.2.4.</span> <span class="nav-text">删掉freewalk的panic（我特有的缺点）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Traps-and-system-calls"><span class="nav-number">4.</span> <span class="nav-text">Traps and system calls</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RISC-V-trap-machinery"><span class="nav-number">4.1.</span> <span class="nav-text">RISC-V trap machinery</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#control-register"><span class="nav-number">4.1.1.</span> <span class="nav-text">control register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.1.2.</span> <span class="nav-text">硬件处理步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traps-from-user-space"><span class="nav-number">4.2.</span> <span class="nav-text">Traps from user space</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#uservec"><span class="nav-number">4.2.1.</span> <span class="nav-text">uservec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usertrap"><span class="nav-number">4.2.2.</span> <span class="nav-text">usertrap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.3.</span> <span class="nav-text">执行对应的处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usertrapret"><span class="nav-number">4.2.4.</span> <span class="nav-text">usertrapret</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#userret"><span class="nav-number">4.2.5.</span> <span class="nav-text">userret</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-calling-system-calls"><span class="nav-number">4.3.</span> <span class="nav-text">Code: calling system calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-system-call-arguments"><span class="nav-number">4.4.</span> <span class="nav-text">Code: system call arguments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traps-from-kernel-space"><span class="nav-number">4.5.</span> <span class="nav-text">Traps from kernel space</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kernelvec"><span class="nav-number">4.5.1.</span> <span class="nav-text">kernelvec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kerneltrap"><span class="nav-number">4.5.2.</span> <span class="nav-text">kerneltrap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-fault-exceptions"><span class="nav-number">4.6.</span> <span class="nav-text">Page-fault exceptions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab%EF%BC%9ATrap"><span class="nav-number">4.7.</span> <span class="nav-text">Lab：Trap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%8F%92%E6%9B%B2"><span class="nav-number">4.7.1.</span> <span class="nav-text">小插曲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RISC-V-assembly"><span class="nav-number">4.7.2.</span> <span class="nav-text">RISC-V assembly</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88"><span class="nav-number">4.7.2.1.</span> <span class="nav-text">题目和答案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%93%E4%BC%9A"><span class="nav-number">4.7.2.2.</span> <span class="nav-text">体会</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Backtrace"><span class="nav-number">4.7.3.</span> <span class="nav-text">Backtrace</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-9"><span class="nav-number">4.7.3.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%9C%A8s0%E4%B8%AD%E7%9A%84%E6%A0%88%E5%B8%A7%E6%8C%87%E9%92%88"><span class="nav-number">4.7.3.1.1.</span> <span class="nav-text">存储在s0中的栈帧指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E6%A0%88%E5%B8%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">4.7.3.1.2.</span> <span class="nav-text">栈的结构与栈帧的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%E5%BD%A2%E6%88%90"><span class="nav-number">4.7.3.1.3.</span> <span class="nav-text">思路形成</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="nav-number">4.7.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Alarm"><span class="nav-number">4.7.4.</span> <span class="nav-text">Alarm</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">4.7.4.1.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E8%A7%81%E6%80%9D%E8%B7%AF"><span class="nav-number">4.7.4.1.1.</span> <span class="nav-text">初见思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF"><span class="nav-number">4.7.4.1.2.</span> <span class="nav-text">正确思路</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#part-1"><span class="nav-number">4.7.4.1.2.1.</span> <span class="nav-text">part 1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#part-2"><span class="nav-number">4.7.4.1.2.2.</span> <span class="nav-text">part 2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#part-3"><span class="nav-number">4.7.4.1.2.3.</span> <span class="nav-text">part 3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#part-4"><span class="nav-number">4.7.4.1.2.4.</span> <span class="nav-text">part 4</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#part-5"><span class="nav-number">4.7.4.1.2.5.</span> <span class="nav-text">part 5</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-10"><span class="nav-number">4.7.4.1.3.</span> <span class="nav-text">感想</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="nav-number">4.7.4.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sigalarm-c"><span class="nav-number">4.7.4.2.1.</span> <span class="nav-text">sigalarm.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#trap-c"><span class="nav-number">4.7.4.2.2.</span> <span class="nav-text">trap.c</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab%EF%BC%9Axv6-lazy-page-allocation"><span class="nav-number">4.8.</span> <span class="nav-text">Lab：xv6 lazy page allocation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Eliminate-allocation-from-sbrk"><span class="nav-number">4.8.1.</span> <span class="nav-text">Eliminate allocation from sbrk()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lazy-allocation"><span class="nav-number">4.8.2.</span> <span class="nav-text">Lazy allocation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-11"><span class="nav-number">4.8.2.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">4.8.2.1.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E9%9A%BE%E4%BB%A5%E5%AF%9F%E8%A7%89%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">4.8.2.1.2.</span> <span class="nav-text">一个难以察觉的错误</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#debug%E8%BF%87%E7%A8%8B"><span class="nav-number">4.8.2.1.3.</span> <span class="nav-text">debug过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="nav-number">4.8.2.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#trap-c-1"><span class="nav-number">4.8.2.2.1.</span> <span class="nav-text">trap.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#vm-c-1"><span class="nav-number">4.8.2.2.2.</span> <span class="nav-text">vm.c</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lazytests-and-Usertests"><span class="nav-number">4.8.3.</span> <span class="nav-text">Lazytests and Usertests</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-12"><span class="nav-number">4.8.3.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%BB%B7%E4%B8%8D%E4%BD%8F%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">4.8.3.1.1.</span> <span class="nav-text">一个绷不住的错误</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="nav-number">4.8.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-Copy-on-Write-Fork-for-xv6"><span class="nav-number">4.9.</span> <span class="nav-text">Lab: Copy-on-Write Fork for xv6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-13"><span class="nav-number">4.9.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="nav-number">4.9.1.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90-1"><span class="nav-number">4.9.1.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E5%88%86%E6%9E%90"><span class="nav-number">4.9.1.2.1.</span> <span class="nav-text">总分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="nav-number">4.9.1.2.2.</span> <span class="nav-text">引用数实现分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.9.1.2.2.1.</span> <span class="nav-text">数组的大小和数据类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%A2%9E%E5%87%8F%E5%BC%95%E7%94%A8"><span class="nav-number">4.9.1.2.2.2.</span> <span class="nav-text">什么时候增减引用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="nav-number">4.9.1.2.2.3.</span> <span class="nav-text">并发安全</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E9%9A%BE%E7%82%B9%E4%B8%8E%E9%94%99%E8%AF%AF"><span class="nav-number">4.9.1.3.</span> <span class="nav-text">主要难点与错误</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#scause-2"><span class="nav-number">4.9.1.3.1.</span> <span class="nav-text">scause&#x3D;2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kernel%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8"><span class="nav-number">4.9.1.3.2.</span> <span class="nav-text">kernel无法启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%97%B6%E5%87%8F%E5%B0%91%E5%AF%B9%E7%89%A9%E7%90%86%E9%A1%B5%E7%9A%84%E5%BC%95%E7%94%A8%E6%95%B0"><span class="nav-number">4.9.1.3.3.</span> <span class="nav-text">在缺页中断时减少对物理页的引用数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%AD%E5%BC%95%E5%8F%91%E5%B9%B6%E5%A4%84%E7%90%86%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="nav-number">4.9.1.3.4.</span> <span class="nav-text">在内核态中引发并处理缺页中断</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%83%E5%BE%97"><span class="nav-number">4.9.1.4.</span> <span class="nav-text">心得</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="nav-number">4.9.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89COW%E6%A0%87%E8%AE%B0"><span class="nav-number">4.9.2.1.</span> <span class="nav-text">定义COW标记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.9.2.2.</span> <span class="nav-text">引用数组初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE%E9%A1%B5%E6%97%B6%E5%A2%9E%E5%88%A0%E5%BC%95%E7%94%A8"><span class="nav-number">4.9.2.3.</span> <span class="nav-text">申请和释放页时增删引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9fork%E6%97%B6%E5%AF%B9%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B9%B6%E6%A0%87%E8%AE%B0%E5%BC%95%E7%94%A8%E6%95%B0%E5%A2%9E%E5%8A%A0"><span class="nav-number">4.9.2.4.</span> <span class="nav-text">修改fork时对页表的复制操作，并标记引用数增加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%EF%BC%8C%E6%A0%87%E8%AE%B0%E5%BC%95%E7%94%A8%E6%95%B0%E5%87%8F%E5%B0%91"><span class="nav-number">4.9.2.5.</span> <span class="nav-text">处理缺页中断，标记引用数减少</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#uvmunmap%E6%97%B6%E5%87%8F%E5%B0%91%E5%BC%95%E7%94%A8%E6%95%B0"><span class="nav-number">4.9.2.6.</span> <span class="nav-text">uvmunmap时减少引用数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9walkaddr"><span class="nav-number">4.9.2.7.</span> <span class="nav-text">修改walkaddr</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8walkaddr%E4%B8%AD%E8%A7%A6%E5%8F%91%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="nav-number">4.9.2.7.1.</span> <span class="nav-text">在walkaddr中触发缺页中断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8kerneltrap%E5%86%85%E8%A1%A5%E4%B8%8A%E5%AF%B9%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">4.9.2.7.2.</span> <span class="nav-text">在kerneltrap内补上对缺页中断的处理</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Interrupts-and-device-drivers"><span class="nav-number">5.</span> <span class="nav-text">Interrupts and device drivers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Console-input"><span class="nav-number">5.1.</span> <span class="nav-text">Code: Console input</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E5%B1%82%E9%80%BB%E8%BE%91"><span class="nav-number">5.1.1.</span> <span class="nav-text">上层逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91"><span class="nav-number">5.1.2.</span> <span class="nav-text">底层逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UART"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">UART</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kerneltrap-1"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">kerneltrap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#devintr"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">devintr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#uartintr"><span class="nav-number">5.1.2.4.</span> <span class="nav-text">uartintr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#consoleintr"><span class="nav-number">5.1.2.5.</span> <span class="nav-text">consoleintr</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Console-output"><span class="nav-number">5.2.</span> <span class="nav-text">Code: Console output</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#uartputc"><span class="nav-number">5.2.1.</span> <span class="nav-text">uartputc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uartstart"><span class="nav-number">5.2.2.</span> <span class="nav-text">uartstart</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transmit-complete-interrupt"><span class="nav-number">5.2.3.</span> <span class="nav-text">transmit complete interrupt</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Concurrency-in-drivers"><span class="nav-number">5.3.</span> <span class="nav-text">Concurrency in drivers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Timer-interrupts"><span class="nav-number">5.4.</span> <span class="nav-text">Timer interrupts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world-2"><span class="nav-number">5.5.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-networking"><span class="nav-number">5.6.</span> <span class="nav-text">Lab: networking</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-14"><span class="nav-number">5.6.1.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="nav-number">5.6.2.</span> <span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF-1"><span class="nav-number">5.6.2.1.</span> <span class="nav-text">正确思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-number">5.6.2.2.</span> <span class="nav-text">个人的推理过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="nav-number">5.6.3.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Locking"><span class="nav-number">6.</span> <span class="nav-text">Locking</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-spinlock"><span class="nav-number">6.1.</span> <span class="nav-text">Code: spinlock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#spinlock"><span class="nav-number">6.1.1.</span> <span class="nav-text">spinlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acquire"><span class="nav-number">6.1.2.</span> <span class="nav-text">acquire</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sync-synchronize"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">__sync_synchronize();</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#push-off%E5%92%8Cpop-off"><span class="nav-number">6.1.2.2.</span> <span class="nav-text">push_off和pop_off</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#release"><span class="nav-number">6.1.3.</span> <span class="nav-text">release</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Using-locks"><span class="nav-number">6.2.</span> <span class="nav-text">Code: Using locks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deadlock-and-lock-ordering"><span class="nav-number">6.3.</span> <span class="nav-text">Deadlock and lock ordering</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Locks-and-interrupt-handlers"><span class="nav-number">6.4.</span> <span class="nav-text">Locks and interrupt handlers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%A7%A3%E5%86%B3%E4%BA%86%E4%B8%80%E5%8D%8A%E7%9A%84%E7%96%91%E9%97%AE"><span class="nav-number">6.4.1.</span> <span class="nav-text">一个解决了一半的疑问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">6.4.1.1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E7%AD%94-1"><span class="nav-number">6.4.1.2.</span> <span class="nav-text">解答</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sleep-locks"><span class="nav-number">6.5.</span> <span class="nav-text">Sleep locks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world-3"><span class="nav-number">6.6.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-locks"><span class="nav-number">6.7.</span> <span class="nav-text">Lab: locks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-allocator"><span class="nav-number">6.7.1.</span> <span class="nav-text">Memory allocator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-15"><span class="nav-number">6.7.1.1.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="nav-number">6.7.1.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">6.7.1.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="nav-number">6.7.1.2.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kfree"><span class="nav-number">6.7.1.2.3.</span> <span class="nav-text">kfree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kalloc"><span class="nav-number">6.7.1.2.4.</span> <span class="nav-text">kalloc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer-cache"><span class="nav-number">6.7.2.</span> <span class="nav-text">Buffer cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-16"><span class="nav-number">6.7.2.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E8%A7%81%E6%80%9D%E8%B7%AF-1"><span class="nav-number">6.7.2.1.1.</span> <span class="nav-text">初见思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF-2"><span class="nav-number">6.7.2.1.2.</span> <span class="nav-text">正确思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#debug%E8%BF%87%E7%A8%8B-1"><span class="nav-number">6.7.2.1.3.</span> <span class="nav-text">debug过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="nav-number">6.7.2.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.7.2.2.1.</span> <span class="nav-text">定义数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="nav-number">6.7.2.2.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bget"><span class="nav-number">6.7.2.2.3.</span> <span class="nav-text">bget</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#brelse"><span class="nav-number">6.7.2.2.4.</span> <span class="nav-text">brelse</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9bunpin%E5%92%8Cbpin"><span class="nav-number">6.7.2.2.5.</span> <span class="nav-text">修改bunpin和bpin</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Scheduling"><span class="nav-number">7.</span> <span class="nav-text">Scheduling</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Context-switching"><span class="nav-number">7.1.</span> <span class="nav-text">Code: Context switching</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#context"><span class="nav-number">7.1.1.</span> <span class="nav-text">context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swtch"><span class="nav-number">7.1.2.</span> <span class="nav-text">swtch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sched"><span class="nav-number">7.1.3.</span> <span class="nav-text">sched</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scheduler"><span class="nav-number">7.1.4.</span> <span class="nav-text">scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85"><span class="nav-number">7.1.5.</span> <span class="nav-text">一些补充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Scheduling"><span class="nav-number">7.2.</span> <span class="nav-text">Code: Scheduling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sched%E5%89%8D%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B"><span class="nav-number">7.2.1.</span> <span class="nav-text">sched前要做的事</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sched%E4%B8%8Escheduler"><span class="nav-number">7.2.2.</span> <span class="nav-text">sched与scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#p-gt-lock%E4%BF%9D%E8%AF%81%E4%BA%86%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">7.2.3.</span> <span class="nav-text">p-&gt;lock保证了并发安全性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-mycpu-and-myproc"><span class="nav-number">7.3.</span> <span class="nav-text">Code: mycpu and myproc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sleep-and-wakeup"><span class="nav-number">7.4.</span> <span class="nav-text">Sleep and wakeup</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">7.4.1.</span> <span class="nav-text">自旋锁实现信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84sleep-and-wakeup"><span class="nav-number">7.4.2.</span> <span class="nav-text">不安全的sleep and wakeup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-and-wakeup"><span class="nav-number">7.4.3.</span> <span class="nav-text">sleep and wakeup</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Sleep-and-wakeup"><span class="nav-number">7.5.</span> <span class="nav-text">Code: Sleep and wakeup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Pipes"><span class="nav-number">7.6.</span> <span class="nav-text">Code: Pipes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Wait-exit-and-kill"><span class="nav-number">7.7.</span> <span class="nav-text">Code: Wait, exit, and kill</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exit%E5%92%8Cwait"><span class="nav-number">7.7.1.</span> <span class="nav-text">exit和wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kill"><span class="nav-number">7.7.2.</span> <span class="nav-text">kill</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world-4"><span class="nav-number">7.8.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-Multithreading"><span class="nav-number">7.9.</span> <span class="nav-text">Lab: Multithreading</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Uthread-switching-between-threads"><span class="nav-number">7.9.1.</span> <span class="nav-text">Uthread: switching between threads</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-17"><span class="nav-number">7.9.1.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="nav-number">7.9.1.1.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9D%91"><span class="nav-number">7.9.1.1.2.</span> <span class="nav-text">坑</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="nav-number">7.9.1.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0context%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%EF%BC%8C%E4%BF%AE%E6%94%B9thread%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">7.9.1.2.1.</span> <span class="nav-text">增加context结构体定义，修改thread结构体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9thread-create"><span class="nav-number">7.9.1.2.2.</span> <span class="nav-text">修改thread_create</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9thread-schedule"><span class="nav-number">7.9.1.2.3.</span> <span class="nav-text">修改thread_schedule</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9thread-switch"><span class="nav-number">7.9.1.2.4.</span> <span class="nav-text">修改thread_switch</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-threads"><span class="nav-number">7.9.2.</span> <span class="nav-text">Using threads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Barrier"><span class="nav-number">7.9.3.</span> <span class="nav-text">Barrier</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#File-system"><span class="nav-number">8.</span> <span class="nav-text">File system</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Overview"><span class="nav-number">8.1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-cache-1"><span class="nav-number">8.2.</span> <span class="nav-text">Buffer cache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-number">8.2.1.</span> <span class="nav-text">数据结构定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-3"><span class="nav-number">8.2.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.2.3.</span> <span class="nav-text">上层接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bread"><span class="nav-number">8.2.3.1.</span> <span class="nav-text">bread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bwrite"><span class="nav-number">8.2.3.2.</span> <span class="nav-text">bwrite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#brelse-1"><span class="nav-number">8.2.3.3.</span> <span class="nav-text">brelse</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82"><span class="nav-number">8.2.4.</span> <span class="nav-text">具体细节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bget-1"><span class="nav-number">8.2.4.1.</span> <span class="nav-text">bget</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Logging-layer"><span class="nav-number">8.3.</span> <span class="nav-text">Logging layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">8.3.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Log-design"><span class="nav-number">8.3.2.</span> <span class="nav-text">Log design</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code-logging"><span class="nav-number">8.3.3.</span> <span class="nav-text">Code: logging</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">8.3.3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.3.2.</span> <span class="nav-text">关键函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#begin-op"><span class="nav-number">8.3.3.2.1.</span> <span class="nav-text">begin_op()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#log-write"><span class="nav-number">8.3.3.2.2.</span> <span class="nav-text">log_write</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#end-op"><span class="nav-number">8.3.3.2.3.</span> <span class="nav-text">end_op</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#commit"><span class="nav-number">8.3.3.2.4.</span> <span class="nav-text">commit</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#write-log"><span class="nav-number">8.3.3.2.4.1.</span> <span class="nav-text">write_log</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#write-head"><span class="nav-number">8.3.3.2.4.2.</span> <span class="nav-text">write_head</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#install-trans"><span class="nav-number">8.3.3.2.4.3.</span> <span class="nav-text">install_trans</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.3.3.3.</span> <span class="nav-text">恢复与初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E4%B9%8B%E5%89%8D"><span class="nav-number">8.3.3.3.1.</span> <span class="nav-text">第一个进程运行之前</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fsinit"><span class="nav-number">8.3.3.3.2.</span> <span class="nav-text">fsinit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#initlog"><span class="nav-number">8.3.3.3.3.</span> <span class="nav-text">initlog</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#recover-from-log"><span class="nav-number">8.3.3.3.4.</span> <span class="nav-text">recover_from_log</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-Block-allocator"><span class="nav-number">8.4.</span> <span class="nav-text">Code: Block allocator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3"><span class="nav-number">8.4.1.</span> <span class="nav-text">个人理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitmap"><span class="nav-number">8.4.2.</span> <span class="nav-text">bitmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#allocator"><span class="nav-number">8.4.3.</span> <span class="nav-text">allocator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#balloc"><span class="nav-number">8.4.3.1.</span> <span class="nav-text">balloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bfree"><span class="nav-number">8.4.3.2.</span> <span class="nav-text">bfree</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inode-layer"><span class="nav-number">8.5.</span> <span class="nav-text">Inode layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#inode"><span class="nav-number">8.5.1.</span> <span class="nav-text">inode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#on-disk-inode"><span class="nav-number">8.5.1.1.</span> <span class="nav-text">on-disk inode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#in-memory-inode"><span class="nav-number">8.5.1.2.</span> <span class="nav-text">in-memory inode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code-inode"><span class="nav-number">8.5.2.</span> <span class="nav-text">Code: inode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Overview-1"><span class="nav-number">8.5.2.1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.5.2.2.</span> <span class="nav-text">底层接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#iget"><span class="nav-number">8.5.2.2.1.</span> <span class="nav-text">iget</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iput"><span class="nav-number">8.5.2.2.2.</span> <span class="nav-text">iput</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E5%B1%82%E6%8E%A5%E5%8F%A3-1"><span class="nav-number">8.5.2.3.</span> <span class="nav-text">上层接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BEinode"><span class="nav-number">8.5.2.3.1.</span> <span class="nav-text">获取和释放inode</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ialloc"><span class="nav-number">8.5.2.3.1.1.</span> <span class="nav-text">ialloc</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#inode%E7%9A%84%E9%94%81%E4%BF%9D%E6%8A%A4"><span class="nav-number">8.5.2.3.2.</span> <span class="nav-text">inode的锁保护</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ilock"><span class="nav-number">8.5.2.3.2.1.</span> <span class="nav-text">ilock</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#iunlock"><span class="nav-number">8.5.2.3.2.2.</span> <span class="nav-text">iunlock</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code-inode-content"><span class="nav-number">8.5.3.</span> <span class="nav-text">Code: inode content</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Overview-2"><span class="nav-number">8.5.3.1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bmap"><span class="nav-number">8.5.3.2.</span> <span class="nav-text">bmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#itrunc"><span class="nav-number">8.5.3.3.</span> <span class="nav-text">itrunc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readi"><span class="nav-number">8.5.3.4.</span> <span class="nav-text">readi</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writei"><span class="nav-number">8.5.3.5.</span> <span class="nav-text">writei</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stati"><span class="nav-number">8.5.3.6.</span> <span class="nav-text">stati</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Directory-layer"><span class="nav-number">8.6.</span> <span class="nav-text">Directory layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">8.6.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">8.6.2.</span> <span class="nav-text">相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dirlookup"><span class="nav-number">8.6.2.1.</span> <span class="nav-text">dirlookup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dirlink"><span class="nav-number">8.6.2.2.</span> <span class="nav-text">dirlink</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pathname-layer"><span class="nav-number">8.7.</span> <span class="nav-text">Pathname layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#namei%E5%92%8Cnameiparent"><span class="nav-number">8.7.1.</span> <span class="nav-text">namei和nameiparent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#namex"><span class="nav-number">8.7.2.</span> <span class="nav-text">namex</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File-descriptor-layer"><span class="nav-number">8.8.</span> <span class="nav-text">File descriptor layer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="nav-number">8.8.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ftable"><span class="nav-number">8.8.2.</span> <span class="nav-text">ftable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#filealloc"><span class="nav-number">8.8.2.1.</span> <span class="nav-text">filealloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filedup"><span class="nav-number">8.8.2.2.</span> <span class="nav-text">filedup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fileclose"><span class="nav-number">8.8.2.3.</span> <span class="nav-text">fileclose</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filestat"><span class="nav-number">8.8.2.4.</span> <span class="nav-text">filestat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fileread"><span class="nav-number">8.8.2.5.</span> <span class="nav-text">fileread</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-System-calls"><span class="nav-number">8.9.</span> <span class="nav-text">Code: System calls</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-link"><span class="nav-number">8.9.1.</span> <span class="nav-text">sys_link</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#create"><span class="nav-number">8.9.2.</span> <span class="nav-text">create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-mkdir"><span class="nav-number">8.9.3.</span> <span class="nav-text">sys_mkdir</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-open"><span class="nav-number">8.9.4.</span> <span class="nav-text">sys_open</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-pipe"><span class="nav-number">8.9.5.</span> <span class="nav-text">sys_pipe</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-world-5"><span class="nav-number">8.10.</span> <span class="nav-text">Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-file-system"><span class="nav-number">8.11.</span> <span class="nav-text">Lab: file system</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Large-files"><span class="nav-number">8.11.1.</span> <span class="nav-text">Large files</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="nav-number">8.11.1.1.</span> <span class="nav-text">实验内容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Overview-3"><span class="nav-number">8.11.1.1.1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Preliminaries"><span class="nav-number">8.11.1.1.2.</span> <span class="nav-text">Preliminaries</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#What-to-Look-At"><span class="nav-number">8.11.1.1.3.</span> <span class="nav-text">What to Look At</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Your-Job"><span class="nav-number">8.11.1.1.4.</span> <span class="nav-text">Your Job</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-18"><span class="nav-number">8.11.1.2.</span> <span class="nav-text">感想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="nav-number">8.11.1.3.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">8.11.1.3.1.</span> <span class="nav-text">修改定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9bmap"><span class="nav-number">8.11.1.3.2.</span> <span class="nav-text">修改bmap()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9itrunc"><span class="nav-number">8.11.1.3.3.</span> <span class="nav-text">修改itrunc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbolic-links"><span class="nav-number">8.11.2.</span> <span class="nav-text">Symbolic links</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-19"><span class="nav-number">8.11.2.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF-3"><span class="nav-number">8.11.2.1.1.</span> <span class="nav-text">正确思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E8%A7%81%E6%80%9D%E8%B7%AF-2"><span class="nav-number">8.11.2.1.2.</span> <span class="nav-text">初见思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF"><span class="nav-number">8.11.2.1.3.</span> <span class="nav-text">一些错误</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="nav-number">8.11.2.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%AE%9A%E4%B9%89"><span class="nav-number">8.11.2.2.1.</span> <span class="nav-text">添加定义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#fcntl-c"><span class="nav-number">8.11.2.2.1.1.</span> <span class="nav-text">fcntl.c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#stat-h"><span class="nav-number">8.11.2.2.1.2.</span> <span class="nav-text">stat.h</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0sys-symlink%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">8.11.2.2.2.</span> <span class="nav-text">添加sys_symlink系统调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9open"><span class="nav-number">8.11.2.2.3.</span> <span class="nav-text">修改open</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-mmap"><span class="nav-number">8.12.</span> <span class="nav-text">Lab mmap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%9F%E6%83%B3-20"><span class="nav-number">8.12.1.</span> <span class="nav-text">感想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E8%A7%81%E6%80%9D%E8%B7%AF-3"><span class="nav-number">8.12.1.1.</span> <span class="nav-text">初见思路</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9C%A8%E5%93%AA%E9%87%8C%E6%94%BE%E7%BD%AEfile%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">8.12.1.1.1.</span> <span class="nav-text">问题：在哪里放置file的内容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF-4"><span class="nav-number">8.12.1.2.</span> <span class="nav-text">正确思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E7%9A%84%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF%E4%BB%AC"><span class="nav-number">8.12.1.3.</span> <span class="nav-text">我的错误思路们</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF"><span class="nav-number">8.12.1.3.1.</span> <span class="nav-text">第一次错误思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E9%94%99%E7%9A%84"><span class="nav-number">8.12.1.3.2.</span> <span class="nav-text">为什么下面的代码是错的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%8B%E9%9D%A2%E7%9A%84%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF%E6%94%B9%E6%88%90%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF"><span class="nav-number">8.12.1.3.3.</span> <span class="nav-text">如何把下面的错误思路改成正确思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%BB%86%E8%8A%82"><span class="nav-number">8.12.1.4.</span> <span class="nav-text">其他的一些小细节</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#file%E6%8C%87%E9%92%88%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">8.12.1.4.1.</span> <span class="nav-text">file指针的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E8%95%B4%E5%90%AB%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="nav-number">8.12.1.4.2.</span> <span class="nav-text">缺页中断蕴含的设计思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E7%AD%94%E6%A1%88%E7%9A%84munmap%E4%B8%AD%E5%A6%82%E6%9E%9C%E9%81%87%E5%88%B0%E6%9C%AA%E6%98%A0%E5%B0%84%E7%9A%84%E9%A1%B5%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">8.12.1.4.3.</span> <span class="nav-text">正确答案的munmap中如果遇到未映射的页怎么办</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-18"><span class="nav-number">8.12.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3"><span class="nav-number">8.12.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap"><span class="nav-number">8.12.2.2.</span> <span class="nav-text">mmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#usertrap-1"><span class="nav-number">8.12.2.3.</span> <span class="nav-text">usertrap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E7%9A%84"><span class="nav-number">8.12.2.3.1.</span> <span class="nav-text">错的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E7%9A%84"><span class="nav-number">8.12.2.3.2.</span> <span class="nav-text">对的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#munmap"><span class="nav-number">8.12.2.4.</span> <span class="nav-text">munmap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%99%E7%9A%84-1"><span class="nav-number">8.12.2.4.1.</span> <span class="nav-text">错的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E7%9A%84-1"><span class="nav-number">8.12.2.4.2.</span> <span class="nav-text">对的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exit%E5%92%8Cfork"><span class="nav-number">8.12.2.5.</span> <span class="nav-text">exit和fork</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#exit"><span class="nav-number">8.12.2.5.1.</span> <span class="nav-text">exit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fork-1"><span class="nav-number">8.12.2.5.2.</span> <span class="nav-text">fork</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9uvmcopy%E5%92%8Cuvmunmap"><span class="nav-number">8.12.2.6.</span> <span class="nav-text">修改uvmcopy和uvmunmap</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E5%AF%B9%E5%AE%9E%E9%AA%8C%E6%9C%AA%E6%B6%89%E5%8F%8A%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">9.</span> <span class="nav-text">其他的对实验未涉及的思考</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B1mkfs%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%A6%E4%B9%A0"><span class="nav-number">9.1.</span> <span class="nav-text">由mkfs引发的对虚拟机的学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#qemu"><span class="nav-number">9.1.1.</span> <span class="nav-text">qemu</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">9.1.1.1.</span> <span class="nav-text">是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">9.1.1.1.1.</span> <span class="nav-text">虚拟化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">9.1.1.1.2.</span> <span class="nav-text">虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">9.1.1.1.2.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%99%A8"><span class="nav-number">9.1.1.1.2.2.</span> <span class="nav-text">模拟器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">9.1.1.1.2.3.</span> <span class="nav-text">高级语言虚拟机</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">9.1.1.1.2.4.</span> <span class="nav-text">系统虚拟机</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#qemu-1"><span class="nav-number">9.1.1.1.3.</span> <span class="nav-text">qemu</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#qemu-kvm%E6%9E%B6%E6%9E%84"><span class="nav-number">9.1.1.2.</span> <span class="nav-text">qemu-kvm架构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%9E%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">9.1.1.2.1.</span> <span class="nav-text">诞生的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E8%99%9A%E6%8B%9F%E5%8C%96%E6%96%B9%E6%A1%88"><span class="nav-number">9.1.1.2.1.1.</span> <span class="nav-text">两种虚拟化方案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8A%E8%BF%B0%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96%E6%96%B9%E6%A1%88"><span class="nav-number">9.1.1.2.1.2.</span> <span class="nav-text">实现上述的虚拟化方案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#x86%E6%9E%B6%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">9.1.1.2.1.3.</span> <span class="nav-text">x86架构的问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.1.2.1.4.</span> <span class="nav-text">解决方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#kvm"><span class="nav-number">9.1.1.2.1.5.</span> <span class="nav-text">kvm</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#qemu-kvm"><span class="nav-number">9.1.1.2.1.6.</span> <span class="nav-text">qemu-kvm</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#qemu-kvm%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-number">9.1.1.2.2.</span> <span class="nav-text">qemu-kvm总体架构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#VMX-root%E5%92%8CVMX-non-root"><span class="nav-number">9.1.1.2.2.1.</span> <span class="nav-text">VMX root和VMX non root</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#qemu%E5%B1%82%EF%BC%88%E5%B7%A6%E4%B8%8A%EF%BC%89"><span class="nav-number">9.1.1.2.2.2.</span> <span class="nav-text">qemu层（左上）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#kvm%E5%B1%82%EF%BC%88%E4%B8%8B%E6%96%B9%EF%BC%89"><span class="nav-number">9.1.1.2.2.3.</span> <span class="nav-text">kvm层（下方）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B1%82%EF%BC%88%E5%8F%B3%E4%B8%8A%EF%BC%89"><span class="nav-number">9.1.1.2.2.4.</span> <span class="nav-text">虚拟机层（右上）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9C%A8QEMU-KVM%E6%9E%B6%E6%9E%84%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.1.2.3.</span> <span class="nav-text">虚拟机在QEMU-KVM架构的执行方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">9.1.1.2.3.1.</span> <span class="nav-text">状态管理虚拟化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">9.1.1.2.3.2.</span> <span class="nav-text">内存管理虚拟化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%96%E8%AE%BE%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">9.1.1.2.3.3.</span> <span class="nav-text">外设管理虚拟化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">9.1.1.2.3.4.</span> <span class="nav-text">中断处理虚拟化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xv6%E7%9A%84%E5%85%A8%E5%90%AF%E5%8A%A8%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="nav-number">9.1.1.3.</span> <span class="nav-text">xv6的全启动运行过程梳理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mkfs%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="nav-number">9.1.1.4.</span> <span class="nav-text">mkfs的作用及源码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">9.1.1.4.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="nav-number">9.1.1.4.2.</span> <span class="nav-text">代码解读</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">修年</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">修年</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
