<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="修年">





<title>Lab4   TCPConnection | 修年</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiunian&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiunian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc" style="right: -4em;">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Lab4   TCPConnection</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">修年</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">二月 25, 2023&nbsp;&nbsp;22:19:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Lab4-TCPConnection"><a href="#Lab4-TCPConnection" class="headerlink" title="Lab4   TCPConnection"></a>Lab4   TCPConnection</h1><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="耗时情况"><a href="#耗时情况" class="headerlink" title="耗时情况"></a>耗时情况</h3><p>【长舒一口气】</p>
<p>最开始先记录下总体耗时情况吧。本次实验共耗费我16h+【不包括接下来写笔记的时间23333】，共耗费三个工作日。第一天看完了指导书，写完了代码，过掉了<code>#45 reorder</code>之前的所有测试。第二天过掉了<code>#55 t_ucS_1M_32k</code>之前的所有测试，直到第三天才过完了所有测试。</p>
<p>我觉得这整个过程还是挺有意义的，每天都有新的进展，看到test case越过越多是真的很高兴。但是可以说第二天以来就都是面向测试用例改bug了，非常折磨非常坐牢，既要去再次理清之前写过的shit山，又得搞清楚很多让人一头雾水不知从何下手的地方。但总之，这三天很充实，并不会让人觉得心累。</p>
<p>放个通关截图吧，感人至深。</p>
<p><img src="/2023/02/25/cs144/image-20230305160608116.png" alt="image-20230305160608116"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在<code>TCPConnection</code>中具体要做什么，指导书已经写得很详细了，跟着指导书就行。代码部分还是不折磨的，思路直观清晰。</p>
<h4 id="指导书内容"><a href="#指导书内容" class="headerlink" title="指导书内容"></a>指导书内容</h4><blockquote>
<p>Here are the basic rules the TCPConnection has to follow:</p>
</blockquote>
<ol>
<li><p><strong>Receiving segments</strong></p>
<p>大概是在<code>segment_received</code>中做</p>
<p><img src="/2023/02/25/cs144/image-20230303103640065.png" alt="image-20230303103640065"></p>
<ol>
<li><p>检查RST flag</p>
<p>如果RST被设置，sets <strong>both</strong> the inbound and outbound streams to the <strong>error state</strong>，杀死当前connection</p>
<p>return;</p>
<p>具体实现中，杀死connection可以置<code>_linger_after_streams_finish</code>为false。<code> the inbound and outbound streams</code>对应着receiver和sender里的stream。让它们都处于error状态，只需设置<code>ByteStream</code>中的error字段</p>
</li>
<li><p>如果收到的segment with an invalid sequence number，connection需要发送empty segment应答</p>
<p><img src="/2023/02/25/cs144/image-20230303110238265.png" alt="image-20230303110238265"></p>
</li>
<li><p>转发segment给receiver</p>
</li>
<li><p>如果ACK，则把ackno和win_size给sender</p>
</li>
</ol>
</li>
<li><p><strong>Sending segments</strong></p>
<ol>
<li>任何时候sender把segment放进其out流，你都要从中取出来</li>
<li>从receiver处获取ackno和window_size，填入segment中</li>
<li>放到自己的segment_out中</li>
</ol>
<p>从上述表述中，我们需要注意两点：</p>
<ol>
<li><p>顺带ACK</p>
<p>可以看到，这跟我们上课的时候所学的一样，是“顺带ACK”，也即ACK报文并非独立发送，而是在下一次要发送其他数据报文的时候携带发送。这也一定程度上使得ack报文发送不会太频繁也不会太稀疏。</p>
</li>
<li><p>一定要经由sender</p>
<p>我们如果想要发送一个报文，一定得先把它存入sender中，再从sender的segment_out中取出来。这样做的目的是把该报文列入sender的超时重传管辖范围，你如果直接把报文发送到自己的segment_out中，就无法管理其超时重传了</p>
</li>
</ol>
</li>
<li><p><strong>When time passes</strong></p>
<p>在<code>tick()</code>中</p>
<ol>
<li>调用sender的<code>tick()</code></li>
<li>检查sender的连续超时重传次数，如果大于<code>MAX RETX ATTEMPTS</code>，则关闭连接，并且发送RST标志的空报文</li>
<li>end the connection cleanly if necessary</li>
</ol>
</li>
</ol>
<p>再注意一点对于connection的关闭。它要求有一个time pass</p>
<p><img src="/2023/02/25/cs144/image-20230303111131650.png" alt="image-20230303111131650"></p>
<p><img src="/2023/02/25/cs144/image-20230303112817891.png" alt="image-20230303112817891"></p>
<p>第一点挺好实现的，第二点需要在析构函数中检测。</p>
<p>最后的5.1部分值得一看。</p>
<h4 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h4><p><code>TCPConnection</code>的public函数接口定义以及具体要做什么如下。结合上面的指导书内容，<code>TCPConnection</code>的实现就很简单了，我就不多bb了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   TCPConfig _cfg;</span><br><span class="line">   <span class="comment">// 一个endpoint可以同时作为sender和receiver。</span></span><br><span class="line">   TCPReceiver _receiver&#123;_cfg.recv_capacity&#125;;</span><br><span class="line">   TCPSender _sender&#123;_cfg.send_capacity, _cfg.rt_timeout, _cfg.fixed_isn&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! outbound queue of segments that the TCPConnection wants sent</span></span><br><span class="line">   <span class="comment">// 把要发送的segment放在这里就行了</span></span><br><span class="line">   std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Should the TCPConnection stay active (and keep ACKing)</span></span><br><span class="line">   <span class="comment">//! for 10 * _cfg.rt_timeout milliseconds after both streams have ended,</span></span><br><span class="line">   <span class="comment">//! in case the remote TCPConnection doesn&#x27;t know we&#x27;ve received its whole stream?</span></span><br><span class="line">   <span class="type">bool</span> _linger_after_streams_finish&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 也许需要调用TCPSender的fill_window()，然后从其segment_out中取出来，再发送给自己的segment_out</span></span><br><span class="line">   <span class="comment">// Initiate a connection by sending a SYN segment初始化connection并且发送SYN</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  这几个都很好实现，都很直观，只需调sender和receiver的API就行  */</span></span><br><span class="line">   <span class="comment">// 由上层socket调用，data路径 socket-&gt;connection-&gt;sender.stream_in().write()</span></span><br><span class="line">   <span class="comment">//! \brief Write data to the outbound byte stream, and send it over TCP if possible</span></span><br><span class="line">   <span class="comment">//! \returns the number of bytes from `data` that were actually written.</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;data)</span></span>;</span><br><span class="line">   <span class="comment">//! \returns the number of `bytes` that can be written right now.</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="comment">//! \brief Shut down the outbound byte stream (still allows reading incoming data)</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">end_input_stream</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//! \brief The inbound byte stream received from the peer</span></span><br><span class="line">   <span class="function">ByteStream &amp;<span class="title">inbound_stream</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">stream_out</span>(); &#125;</span><br><span class="line">   <span class="comment">// number of bytes sent and not yet acknowledged, counting SYN/FIN each as one byte</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">bytes_in_flight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="comment">//! \brief number of bytes not yet reassembled</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">unassembled_bytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief Number of milliseconds since the last segment was received</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// debug用</span></span><br><span class="line">   <span class="comment">//!&lt; \brief summarize the state of the sender, receiver, and the connection</span></span><br><span class="line">   <span class="function">TCPState <span class="title">state</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &#123;_sender, _receiver, <span class="built_in">active</span>(), _linger_after_streams_finish&#125;; &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这些函数都会由上层在某些时候调用</span></span><br><span class="line">   <span class="comment">// 时钟滴答、收到segment以及从segment_out中取数据，这些都是由os调用相应函数实现的</span></span><br><span class="line">   <span class="comment">// 这也正是所谓“协议”的接口意义！</span></span><br><span class="line">   <span class="comment">//! \name Methods for the owner or operating system to call</span></span><br><span class="line">   <span class="comment">//! Called when a new segment has been received from the network</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Called periodically when time elapses</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief TCPSegments that the TCPConnection has enqueued for transmission.</span></span><br><span class="line">   <span class="comment">//! \note The owner or operating system will dequeue these and</span></span><br><span class="line">   <span class="comment">//! put each one into the payload of a lower-layer datagram (usually Internet datagrams (IP),</span></span><br><span class="line">   <span class="comment">//! but could also be user datagrams (UDP) or any other kind).</span></span><br><span class="line">   <span class="function">std::queue&lt;TCPSegment&gt; &amp;<span class="title">segments_out</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _segments_out; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief Is the connection still alive in any way?</span></span><br><span class="line">   <span class="comment">//! \returns `true` if either stream is still running or if the TCPConnection is lingering</span></span><br><span class="line">   <span class="comment">//! after both streams have finished (e.g. to ACK retransmissions from the peer)</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">active</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Construct a new connection from a configuration</span></span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">TCPConnection</span><span class="params">(<span class="type">const</span> TCPConfig &amp;cfg)</span> : _cfg&#123;</span>cfg&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \name construction and destruction</span></span><br><span class="line">   <span class="comment">//! moving is allowed; copying is disallowed; default construction not possible</span></span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">TCPConnection</span>();  <span class="comment">//!&lt; destructor sends a RST if the connection is still open</span></span><br><span class="line">   <span class="built_in">TCPConnection</span>() = <span class="keyword">delete</span>;</span><br><span class="line">   <span class="built_in">TCPConnection</span>(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">   TCPConnection &amp;<span class="keyword">operator</span>=(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">   <span class="built_in">TCPConnection</span>(<span class="type">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">   TCPConnection &amp;<span class="keyword">operator</span>=(<span class="type">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>这部分暂时还不大明白，随便瞎写一点（）</p>
<p>首先是socket实现，似乎要涉及到对一些事件，比如说<code>segment receive</code>的监听。它具体是这么做的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_helper/tcp_sponge_socket.cc  _initialize_TCP()</span></span><br><span class="line">    <span class="comment">// Set up the event loop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are four possible events to handle:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 1) Incoming datagram received (needs to be given to</span></span><br><span class="line">    <span class="comment">//    TCPConnection::segment_received method)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 2) Outbound bytes received from local application via a write()</span></span><br><span class="line">    <span class="comment">//    call (needs to be read from the local stream socket and</span></span><br><span class="line">    <span class="comment">//    given to TCPConnection::data_written method)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 3) Incoming bytes reassembled by the TCPConnection</span></span><br><span class="line">    <span class="comment">//    (needs to be read from the inbound_stream and written</span></span><br><span class="line">    <span class="comment">//    to the local stream socket back to the application)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 4) Outbound segment generated by TCP (needs to be</span></span><br><span class="line">    <span class="comment">//    given to underlying datagram socket)</span></span><br></pre></td></tr></table></figure>

<p>比如说event4：</p>
<p><img src="/2023/02/25/cs144/image-20230304171810877.png" alt="image-20230304171810877"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_61233877/article/details/124349171">什么是eventloop</a></p>
<p>事件循环（event loop）就是 任务在主线程不断进栈出栈的一个循环过程。任务会在将要执行时进入主线程，在执行完毕后会退出主线程。</p>
<p>这里的大致意思就是增加了一个监听事件，一旦tcp_connection的segments_out有元素，就会马上取出来</p>
</blockquote>
<p>这部分不大懂，不知道后面会不会涉及对socket的编写？</p>
<p>还有一点是对测试脚本好像有了点了解。比如在<code>build/CTestTestfile.cmake</code>中可以看到每个测试的对应脚本以及使用的options：</p>
<p><img src="/2023/02/25/cs144/image-20230304170132380.png" alt="image-20230304170132380"></p>
<p>如果不知道option的用法可以这么做：</p>
<p><img src="/2023/02/25/cs144/image-20230305232621024.png" alt="image-20230305232621024"></p>
<p>这些脚本实现的对应代码在<code>sponge/apps</code>中。</p>
<p>又比如，在<code>sponge/etc/tests.cmake</code>中，可以找到各个测试程序执行的参数，就可以比如说修改测试的Timeout时间：</p>
<p><img src="/2023/02/25/cs144/image-20230305232913611.png" alt="image-20230305232913611"></p>
<h3 id="总结：状态机"><a href="#总结：状态机" class="headerlink" title="总结：状态机"></a>总结：状态机</h3><p>我们已经完整实现了整个TCP协议，是时候该对其做出一个总结了。</p>
<p>TCP协议本质上是一个<strong>状态机</strong>。</p>
<p>在我们的sponge TCP中，我们将一个endpoint的TCP协议分成了两个状态机，一个是<code>TCPReceiver</code>的状态机，另一个是<code>TCPSender</code>的状态机。它们依据外界的输入【从app或者互联网】来进行状态的转移。</p>
<p>以下几张图完美地体现了状态转移关系【具体的状态体现标注在代码中了】：</p>
<p><img src="/2023/02/25/cs144/image-20230226200935395.png" alt="image-20230226200935395"></p>
<p><img src="/2023/02/25/cs144/image-20230226202631406.png" alt="image-20230226202631406"></p>
<p><img src="/2023/02/25/cs144/image-20230305225738049.png" alt="image-20230305225738049"></p>
<p><img src="/2023/02/25/cs144/image-20230225232723083-1678028236763-1.png" alt="image-20230225232723083"></p>
<p>而<code>TCPConnection</code>并不是状态机，它是两个状态机和外界联通的<u>桥梁</u>。它的职能有：</p>
<ol>
<li><p>给状态机提供输入</p>
<p>包括：</p>
<ol>
<li>app调用<code>write</code>传进来的数据</li>
<li>peer通过<code>segment_received</code>传进来的数据</li>
</ol>
</li>
<li><p>处理状态机的输出</p>
<p>包括：</p>
<ol>
<li>app调用receiver的stream接口获取数据</li>
<li>通过<code>send_segment</code>向peer传递数据</li>
</ol>
</li>
</ol>
<p>也可以说，它具有显式推动状态机状态转移的作用，比如说：</p>
<ol>
<li>给状态机传递外界数据让他们转移</li>
<li><code>connect</code>通过调用<code>fill_window</code>推动<code>_sender</code>从CLOSED状态转移到SYN_SENT状态</li>
<li>转移到ERROR状态的条件判断</li>
</ol>
<p>等等等。</p>
<p>也因而，<code>TCPConnection</code>并不包含复杂的逻辑和算法，它仅仅是做一些条件判断，以及一些数据转发的工作。</p>
<h3 id="喜闻乐见的bug合集"><a href="#喜闻乐见的bug合集" class="headerlink" title="喜闻乐见的bug合集"></a>喜闻乐见的bug合集</h3><p>相比于代码的编写，本次实验最难的部分是测试。由于lab4基于lab0-3，因而前面没有发现的bug在本次黑压压162个测试之下会全部涌现出来。有些bug我还是不知道怎么回事，并且debug过程也不像xv6那样条理清晰步步为营，感觉充满着不少玄幻色彩，所以<strong>也没有很多干货好说</strong>。在这里就先记录下印象比较深刻，耗时比较久的bug吧。</p>
<h4 id="TCP-produced-‘ackno-1’"><a href="#TCP-produced-‘ackno-1’" class="headerlink" title="TCP produced ‘ackno=1’"></a>TCP produced ‘ackno=1’</h4><p><img src="/2023/02/25/cs144/image-20230303214944132.png" alt="image-20230303214944132"></p>
<p>需要发送一个ackno=2的帧，但是不知道为什么却发送了一个ackno=1的，并且无论我怎么找，在哪里print，都只能找到一个ackno=2的，连1的影子都看不到。这个现象确实很诡异，但其实它的内因很简单。它是由于我对空的ACK帧发送条件限制得不恰当才出现的。</p>
<blockquote>
<p>有没有觉得这里有点跳跃？我是怎么通过这个现象得知是ACK发送不恰当导致的？</p>
<p>答案是我当时也没想到这一点，无头苍蝇般转了可能有一个小时，这里print一下那里print一下都没有发现异常。最后我放弃了这个用例去看下一个错误的用例，才发现了这个小bug，改了一下发现这个也一起过了【绷】</p>
</blockquote>
<p>本来我是这么写的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把_sender的所有segment都发送出去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当没有要发送的帧，无法进行顺带ACK时，就只能发送一个只有ACK的空帧</span></span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            _sender.<span class="built_in">send_empty_ack_segment</span>(_receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in segment_received()</span></span><br><span class="line">    <span class="comment">//if (seg.length_in_sequence_space() != 0) &#123;</span></span><br><span class="line">    <span class="comment">//    empty_ack_send();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br></pre></td></tr></table></figure>

<p>如果这么写的话，当这台endpoint收到peer的一个empty ACK后，它就也会以示敬意回复一个empty ACK，这样除了本应发过去的ackno=2的报文，就多了个幽灵般的ackno=1的empty ACK，从而导致上面的错误。</p>
<p>因而，正确的做法是，我们在receive时只对**!empty**的seg进行ACK回复就行。具体写法可以看看我下面的代码。</p>
<h4 id="超时重传时间翻倍问题"><a href="#超时重传时间翻倍问题" class="headerlink" title="超时重传时间翻倍问题"></a>超时重传时间翻倍问题</h4><p><img src="/2023/02/25/cs144/image-20230303224104016.png" alt="image-20230303224104016"></p>
<p><img src="/2023/02/25/cs144/image-20230303224053277.png" alt="image-20230303224053277"></p>
<p>可以看到，它是想要我们在1000ms后再发一次FIN的，也即rto依然等于1000，但是我们的rto却是2000.为啥呢？那就去看看超时重传呗。</p>
<p>原来的超时重传代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_sender.cc</span></span><br><span class="line"><span class="keyword">if</span> (timer_start &amp;&amp; ticks &gt; timer_ticks &amp;&amp; ticks - timer_ticks &gt;= rto) &#123;</span><br><span class="line">    <span class="comment">// resend</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(tmp_segments.<span class="built_in">front</span>().segment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (window_size != <span class="number">0</span>) &#123;</span><br><span class="line">        cons_retran++;</span><br><span class="line">        rto *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer_ticks = ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改完后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timer_start &amp;&amp; ticks &gt; timer_ticks &amp;&amp; ticks - timer_ticks &gt;= rto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tmp_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// resend</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(tmp_segments.<span class="built_in">front</span>().segment);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (window_size != <span class="number">0</span>) &#123;</span><br><span class="line">            cons_retran++;</span><br><span class="line">            rto *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    timer_ticks = ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想想超时重传的定义，是不是重传了之后才会double时间呀（）</p>
<h4 id="assembler"><a href="#assembler" class="headerlink" title="assembler"></a>assembler</h4><p><img src="/2023/02/25/cs144/image-20230304163111298.png" alt="image-20230304163111298"></p>
<p>这个test花了我半个下午的时间排查和修改。大致流程及报错信息是，一方发了65000个byte，但是另一方只能收到&lt;&lt;65000个。最后print了一下，发现是<code>streamassembler</code>写错了，在stream end的时候仍然有很大一部分数据未被整流。</p>
<blockquote>
<p>这个直面屎山的经历极大地鼓舞了我</p>
</blockquote>
<p>之前在写<code>streamassembler</code>的时候就知道有个地方是错的了，那就是我对capacity的理解【具体见前面的笔记】。现在只用改一下就好了。修改方式很简单，加上这两句话就行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">right = right &lt;= left_bound + _capacity ? right : left_bound + _capacity;  <span class="comment">// 右边越界的也不要</span></span><br><span class="line"><span class="keyword">if</span> (o_left &gt;= left_bound + _capacity)       <span class="keyword">goto</span> end;  <span class="comment">// 越界的不要</span></span><br></pre></td></tr></table></figure>

<h4 id="t-udp-client-send超时"><a href="#t-udp-client-send超时" class="headerlink" title="t_udp_client_send超时"></a><code>t_udp_client_send</code>超时</h4><p><img src="/2023/02/25/cs144/image-20230304215748823.png" alt="image-20230304215748823"></p>
<p>这个错因非常地诡异，我到最后也还是没有自己找出来。直到我瞎搜来搜去看到了这篇文章：</p>
<blockquote>
<p>我也是真的很佩服这篇文章的作者能找到这个点</p>
<p><img src="/2023/02/25/cs144/image-20230304221420748.png" alt="image-20230304221420748"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lawliet12/p/17066719.html">https://www.cnblogs.com/lawliet12/p/17066719.html</a></p>
</blockquote>
<p><img src="/2023/02/25/cs144/image-20230305215310021.png" alt="image-20230305215310021"></p>
<p>噔噔咚。</p>
<p>我为什么不用<code>_cfg.rt_timeout</code>呢？答案是我当初脑子一抽以为<code>rt_timeout</code>是static、const的，就写了个<code>TCPConfig::rt_timeout</code>然后报错了，我懒得思考了就换成了上面的那个，结果……就这东西，又花费了我好久好久【悲】怪我没有认真看，没发现<code>rt_timeout</code>不是一个静态常量。</p>
<h4 id="t-ucS-1M-32K超时"><a href="#t-ucS-1M-32K超时" class="headerlink" title="t_ucS_1M_32K超时"></a><code>t_ucS_1M_32K</code>超时</h4><p><img src="/2023/02/25/cs144/image-20230305162239877.png" alt="image-20230305162239877"></p>
<p>以及其后面的其他test也都超时了。</p>
<p>说实话我真是百思不得其解，这里打印来那里打印去，也都看得眼花缭乱什么也看不出来，使用指导书那些手动测试的方法，还有抓包，都十分地正常，但它自动测试就是会timeout。</p>
<p>我折腾来折腾去，这里print那里print，最后还怀疑是电脑问题就放到服务器上跑了一下结果还是不行。绝望之际，我只能使出了<strong>万策尽之时的迫不得已的非法手段</strong>：将我的一部分代码替换成别人的看看会怎么样。【传统艺能23333】</p>
<p>最终我定位发现是<code>TCPSender</code>出了问题，我猜测是因为状态机出错了。我比对着别人的代码【知道这不对，但我心态已经崩了。。。】，以及指导书提供的状态机，发现是这个地方出了小问题：</p>
<p><img src="/2023/02/25/cs144/image-20230305220614819.png" alt="image-20230305220614819"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in tcp_sender.cc fill_window()</span></span><br><span class="line">		<span class="comment">// 注释的是以前写的错误版本</span></span><br><span class="line">        <span class="comment">// if (_stream.input_ended() &amp;&amp; !fin &amp;&amp; remaining &gt; 0) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !fin &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// last segment</span></span><br><span class="line">            segment.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">            fin = <span class="literal">true</span>;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里不应该是<code>input_ended</code>，而应该是<code>eof</code>……</p>
<p>改了之后立刻所有测试都能跑通了【悲】</p>
<blockquote>
<p>那么问题来了，为什么错误版本就会timeout呢？我的猜测如下：</p>
<p>eof的条件如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_input_end &amp;&amp; buffer.<span class="built_in">empty</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，eof既要求input_ended，又要求缓冲区内所有数据成功发送。这也很符合FIN_SENT的语义：在数据流终止时（所有数据成功发送，不要求fully acked）发送FIN。</p>
<p>如果按照我错误版本的写法，会导致数据还没发送完毕（<code>!buffer.empty()</code>），就发送了FIN。之后数据虽然还能正常进入receiver的bytestream，并且发送给peer的receiver。但是会存在这也一个空窗期：FIN之后的数据还没到的时候，peer的receiver接收到FIN，并且peer的app从socket将receiver接收到的数据全部读出。出现了这样的空窗期，就会导致peer的receiver的stream达到eof状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in tcp_receiver.cc segment_received()</span></span><br><span class="line">     <span class="keyword">if</span> (abs_seqno != <span class="number">0</span>)</span><br><span class="line">         _reassembler.<span class="built_in">push_substring</span>(data, index, header.fin);</span><br><span class="line"><span class="comment">// in streamassembler.cc</span></span><br><span class="line"> <span class="keyword">if</span> (is_eof &amp;&amp; buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">     _output.<span class="built_in">end_input</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>【接下来就是猜了】由于bytestream eof了，socket就停止读了。后来的数据再来，receiver的stream的缓冲区就满了，receiver就只能一直丢包。【接下来是真的<strong>纯猜</strong>】而且由于测试脚本问题，在这之后都不会调用tick方法了，故而超时重传检测不会被触发，而sender也会因为没有ack，而一直重传重传，就死循环然后timeout寄掉了。</p>
<p>纯猜部分的依据是：</p>
<p><img src="/2023/02/25/cs144/image-20230305173110776.png" alt="image-20230305173110776"></p>
<p><img src="/2023/02/25/cs144/image-20230305173152469.png" alt="image-20230305173152469"></p>
<p>可以看到，tick方法一直被调用，但是ticks却不变。数据报文一直被重传，但是retran一直不变。ticks-timer_ticks一直大于rto，但却始终无法进入那句if（经测试是这样的）。这非常奇怪，我也不知道为什么。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>【珍贵的调试用代码没删的版本放在github了。】</p>
<h3 id="TCPConnection-hh"><a href="#TCPConnection-hh" class="headerlink" title="TCPConnection.hh"></a>TCPConnection.hh</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPConnection</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="type">size_t</span> rec_tick&#123;&#125;;<span class="comment">// 上一次收到segment时的ticks数</span></span><br><span class="line">    <span class="type">size_t</span> ticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">segment_send</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">empty_ack_send</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_rst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="TCPConnection-cc"><a href="#TCPConnection-cc" class="headerlink" title="TCPConnection.cc"></a>TCPConnection.cc</h3><p>如果想要以状态机的视角来看待，可以看看<a target="_blank" rel="noopener" href="https://github.com/shootfirst/CS144/">感恩</a>的代码。他写得很清晰。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_connection.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ticks - rec_tick; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一个只有ACK的空帧，仅在segment_received中调用</span></span><br><span class="line"><span class="comment">// 当没有要发送的帧，无法进行顺带ACK时，</span></span><br><span class="line"><span class="comment">// 为了保障一定有ACK发送，就只能发送一个只有ACK的空帧</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::empty_ack_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            _sender.<span class="built_in">send_empty_ack_segment</span>(_receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把_sender的所有segment都发送出去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// 顺带ACK</span></span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connection被置为error状态的部分必要操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::set_rst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重置发送的ticks</span></span><br><span class="line">    rec_tick = ticks;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        <span class="comment">// RST is set</span></span><br><span class="line">        <span class="built_in">set_rst</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回复对方问你是死是活的信息</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        seg.<span class="built_in">header</span>().seqno - _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">        <span class="built_in">segment_send</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123; <span class="comment">// ack_received也会调用fill_window</span></span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 只在本次收到的seg需要被ACK的时候才要ACK。</span></span><br><span class="line">    <span class="comment">// 需要被ACK：FIN/SYN/携带数据   总之就是length!=0</span></span><br><span class="line">    <span class="comment">// 不得不说，FIN和SYN都会占一个序列号这个点给ACK设计带来了简便，同时也增加了安全性</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">empty_ack_send</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If the inbound stream ends before the TCPConnection has reached EOF </span></span><br><span class="line">    <span class="comment">// on its outbound stream, this variable needs to be set to false</span></span><br><span class="line">    <span class="comment">// 如果receiver的那个stream比sender的stream早结束，就不用等待</span></span><br><span class="line">    <span class="comment">// 为什么呢？因为receiver的stream结束说明了全部的seg都成功接收并且全部整流【参见assembler实现】</span></span><br><span class="line">    <span class="comment">// 也就说明对方不发送数据了，并且已经把FIN也发过来了</span></span><br><span class="line">    <span class="comment">// 也即对方进入了FIN_WAIT状态</span></span><br><span class="line">    <span class="comment">// 而我们的sender还在输出，也即我们在CLOSE_WAIT状态</span></span><br><span class="line">    <span class="comment">// 因而我们只需输出完剩余数据再发送AF,最后直接关闭就行</span></span><br><span class="line">    <span class="comment">// 因为我们知道对方已经关闭了，无需再进行linger。</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; !_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        <span class="comment">// peer:FIN_WAIT   self:CLOSE_WAIT</span></span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="comment">// 处于error状态</span></span><br><span class="line">    <span class="keyword">if</span> (!_linger_after_streams_finish &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">error</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">error</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 满足条件1-3</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp;</span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">fully_acked</span>()) &#123;</span><br><span class="line">        <span class="comment">// 无需等待的话就直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!_linger_after_streams_finish)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 否则需要等待10*timeout</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">time_since_last_segment_received</span>() &gt;= <span class="number">10</span> * _cfg.rt_timeout)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> res = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    <span class="comment">// 注意此处需要手动调一下fill_window和send方法</span></span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ms_since_last_tick: number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    ticks += ms_since_last_tick;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; _cfg.MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>())</span><br><span class="line">            _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();  <span class="comment">// 清除sender遗留的所有帧</span></span><br><span class="line">        _sender.<span class="built_in">send_empty_rst_segment</span>();<span class="comment">// 只发送rst帧</span></span><br><span class="line">        <span class="built_in">set_rst</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// end the connection cleanly if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp;</span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">fully_acked</span>()</span><br><span class="line">	&amp;&amp; <span class="built_in">time_since_last_segment_received</span>() &gt;= <span class="number">10</span> * _cfg.rt_timeout) &#123;</span><br><span class="line">        <span class="comment">// 等待结束</span></span><br><span class="line">	    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="comment">// send_segment重复代码。目的是防止发送SYN外还发送别的东西</span></span><br><span class="line">    <span class="keyword">if</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// shutdown uncleanly</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">	    	<span class="built_in">set_rst</span>();</span><br><span class="line">            _sender.<span class="built_in">send_empty_rst_segment</span>();</span><br><span class="line">            <span class="built_in">segment_send</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="debug函数"><a href="#debug函数" class="headerlink" title="debug函数"></a>debug函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_helper/tcp_segment.hh</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_seg</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">         std::cerr&lt;&lt;<span class="string">&quot;  flag=&quot;</span>&lt;&lt;(<span class="built_in">header</span>().syn?<span class="string">&quot;S&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;(<span class="built_in">header</span>().ack?<span class="string">&quot;A&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;(<span class="built_in">header</span>().fin?<span class="string">&quot;F&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">            &lt;&lt;<span class="string">&quot;  seqno=&quot;</span>&lt;&lt;<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>()&lt;&lt;<span class="string">&quot;   ackno=&quot;</span>&lt;&lt;<span class="built_in">header</span>().ackno.<span class="built_in">raw_value</span>()</span><br><span class="line">            &lt;&lt;<span class="string">&quot;  payload_size:&quot;</span>&lt;&lt;<span class="built_in">payload</span>().<span class="built_in">size</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>in libsponge/tcp_helper/fd_adapter.cc</code></p>
<p><img src="/2023/02/25/cs144/image-20230304172207234.png" alt="image-20230304172207234"></p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/02/25/cs144/">cs144</a>
            
            
            <a class="next" rel="next" href="/2023/01/10/xv6$chap1/">Operating system interface</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 修年 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>