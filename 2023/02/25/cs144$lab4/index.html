<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat.png">
  <link rel="mask-icon" href="/images/cat.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiunianjun.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Lab4   TCPConnection心得耗时情况【长舒一口气】 最开始先记录下总体耗时情况吧。本次实验共耗费我16h+【不包括接下来写笔记的时间23333】，共耗费三个工作日。第一天看完了指导书，写完了代码，过掉了#45 reorder之前的所有测试。第二天过掉了#55 t_ucS_1M_32k之前的所有测试，直到第三天才过完了所有测试。 我觉得这整个过程还是挺有意义的，每天都有新的进展，看到">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab4   TCPConnection">
<meta property="og:url" content="https://xiunianjun.github.io/2023/02/25/cs144$lab4/index.html">
<meta property="og:site_name" content="修年">
<meta property="og:description" content="Lab4   TCPConnection心得耗时情况【长舒一口气】 最开始先记录下总体耗时情况吧。本次实验共耗费我16h+【不包括接下来写笔记的时间23333】，共耗费三个工作日。第一天看完了指导书，写完了代码，过掉了#45 reorder之前的所有测试。第二天过掉了#55 t_ucS_1M_32k之前的所有测试，直到第三天才过完了所有测试。 我觉得这整个过程还是挺有意义的，每天都有新的进展，看到">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230305160608116.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230303103640065.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230303110238265.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230303111131650.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230303112817891.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230304171810877.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230304170132380.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230305232621024.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230305232913611.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230226200935395.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230226202631406.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230305225738049.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230225232723083-1678028236763-1.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230303214944132.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230303224104016.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230303224053277.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230304163111298.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230304215748823.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230304221420748.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230305215310021.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230305162239877.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230305220614819.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230305173110776.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230305173152469.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230304172207234.png">
<meta property="article:published_time" content="2023-02-25T14:19:00.000Z">
<meta property="article:modified_time" content="2023-03-05T15:35:33.975Z">
<meta property="article:author" content="修年">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230305160608116.png">

<link rel="canonical" href="https://xiunianjun.github.io/2023/02/25/cs144$lab4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Lab4   TCPConnection | 修年</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
	
		<script type="text/javascript" 
		color="244,180,180" opacity='0.5' zIndex="-2" count="80"
		src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
	

  <div class="container use-motion">
    <div class="headband"></div>
<a target="_blank" rel="noopener" href="https://github.com/xiunianjun" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">修年</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiunianjun.github.io/2023/02/25/cs144$lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="修年">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修年">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Lab4   TCPConnection
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-25 22:19:00" itemprop="dateCreated datePublished" datetime="2023-02-25T22:19:00+08:00">2023-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-05 23:35:33" itemprop="dateModified" datetime="2023-03-05T23:35:33+08:00">2023-03-05</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Lab4-TCPConnection"><a href="#Lab4-TCPConnection" class="headerlink" title="Lab4   TCPConnection"></a>Lab4   TCPConnection</h1><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="耗时情况"><a href="#耗时情况" class="headerlink" title="耗时情况"></a>耗时情况</h3><p>【长舒一口气】</p>
<p>最开始先记录下总体耗时情况吧。本次实验共耗费我16h+【不包括接下来写笔记的时间23333】，共耗费三个工作日。第一天看完了指导书，写完了代码，过掉了<code>#45 reorder</code>之前的所有测试。第二天过掉了<code>#55 t_ucS_1M_32k</code>之前的所有测试，直到第三天才过完了所有测试。</p>
<p>我觉得这整个过程还是挺有意义的，每天都有新的进展，看到test case越过越多是真的很高兴。但是可以说第二天以来就都是面向测试用例改bug了，非常折磨非常坐牢，既要去再次理清之前写过的shit山，又得搞清楚很多让人一头雾水不知从何下手的地方。但总之，这三天很充实，并不会让人觉得心累。</p>
<p>放个通关截图吧，感人至深。</p>
<p><img src="/2023/02/25/cs144/image-20230305160608116.png" alt="image-20230305160608116"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在<code>TCPConnection</code>中具体要做什么，指导书已经写得很详细了，跟着指导书就行。代码部分还是不折磨的，思路直观清晰。</p>
<h4 id="指导书内容"><a href="#指导书内容" class="headerlink" title="指导书内容"></a>指导书内容</h4><blockquote>
<p>Here are the basic rules the TCPConnection has to follow:</p>
</blockquote>
<ol>
<li><p><strong>Receiving segments</strong></p>
<p>大概是在<code>segment_received</code>中做</p>
<p><img src="/2023/02/25/cs144/image-20230303103640065.png" alt="image-20230303103640065"></p>
<ol>
<li><p>检查RST flag</p>
<p>如果RST被设置，sets <strong>both</strong> the inbound and outbound streams to the <strong>error state</strong>，杀死当前connection</p>
<p>return;</p>
<p>具体实现中，杀死connection可以置<code>_linger_after_streams_finish</code>为false。<code> the inbound and outbound streams</code>对应着receiver和sender里的stream。让它们都处于error状态，只需设置<code>ByteStream</code>中的error字段</p>
</li>
<li><p>如果收到的segment with an invalid sequence number，connection需要发送empty segment应答</p>
<p><img src="/2023/02/25/cs144/image-20230303110238265.png" alt="image-20230303110238265"></p>
</li>
<li><p>转发segment给receiver</p>
</li>
<li><p>如果ACK，则把ackno和win_size给sender</p>
</li>
</ol>
</li>
<li><p><strong>Sending segments</strong></p>
<ol>
<li>任何时候sender把segment放进其out流，你都要从中取出来</li>
<li>从receiver处获取ackno和window_size，填入segment中</li>
<li>放到自己的segment_out中</li>
</ol>
<p>从上述表述中，我们需要注意两点：</p>
<ol>
<li><p>顺带ACK</p>
<p>可以看到，这跟我们上课的时候所学的一样，是“顺带ACK”，也即ACK报文并非独立发送，而是在下一次要发送其他数据报文的时候携带发送。这也一定程度上使得ack报文发送不会太频繁也不会太稀疏。</p>
</li>
<li><p>一定要经由sender</p>
<p>我们如果想要发送一个报文，一定得先把它存入sender中，再从sender的segment_out中取出来。这样做的目的是把该报文列入sender的超时重传管辖范围，你如果直接把报文发送到自己的segment_out中，就无法管理其超时重传了</p>
</li>
</ol>
</li>
<li><p><strong>When time passes</strong></p>
<p>在<code>tick()</code>中</p>
<ol>
<li>调用sender的<code>tick()</code></li>
<li>检查sender的连续超时重传次数，如果大于<code>MAX RETX ATTEMPTS</code>，则关闭连接，并且发送RST标志的空报文</li>
<li>end the connection cleanly if necessary</li>
</ol>
</li>
</ol>
<p>再注意一点对于connection的关闭。它要求有一个time pass</p>
<p><img src="/2023/02/25/cs144/image-20230303111131650.png" alt="image-20230303111131650"></p>
<p><img src="/2023/02/25/cs144/image-20230303112817891.png" alt="image-20230303112817891"></p>
<p>第一点挺好实现的，第二点需要在析构函数中检测。</p>
<p>最后的5.1部分值得一看。</p>
<h4 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h4><p><code>TCPConnection</code>的public函数接口定义以及具体要做什么如下。结合上面的指导书内容，<code>TCPConnection</code>的实现就很简单了，我就不多bb了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   TCPConfig _cfg;</span><br><span class="line">   <span class="comment">// 一个endpoint可以同时作为sender和receiver。</span></span><br><span class="line">   TCPReceiver _receiver&#123;_cfg.recv_capacity&#125;;</span><br><span class="line">   TCPSender _sender&#123;_cfg.send_capacity, _cfg.rt_timeout, _cfg.fixed_isn&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! outbound queue of segments that the TCPConnection wants sent</span></span><br><span class="line">   <span class="comment">// 把要发送的segment放在这里就行了</span></span><br><span class="line">   std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Should the TCPConnection stay active (and keep ACKing)</span></span><br><span class="line">   <span class="comment">//! for 10 * _cfg.rt_timeout milliseconds after both streams have ended,</span></span><br><span class="line">   <span class="comment">//! in case the remote TCPConnection doesn&#x27;t know we&#x27;ve received its whole stream?</span></span><br><span class="line">   <span class="type">bool</span> _linger_after_streams_finish&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 也许需要调用TCPSender的fill_window()，然后从其segment_out中取出来，再发送给自己的segment_out</span></span><br><span class="line">   <span class="comment">// Initiate a connection by sending a SYN segment初始化connection并且发送SYN</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  这几个都很好实现，都很直观，只需调sender和receiver的API就行  */</span></span><br><span class="line">   <span class="comment">// 由上层socket调用，data路径 socket-&gt;connection-&gt;sender.stream_in().write()</span></span><br><span class="line">   <span class="comment">//! \brief Write data to the outbound byte stream, and send it over TCP if possible</span></span><br><span class="line">   <span class="comment">//! \returns the number of bytes from `data` that were actually written.</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;data)</span></span>;</span><br><span class="line">   <span class="comment">//! \returns the number of `bytes` that can be written right now.</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="comment">//! \brief Shut down the outbound byte stream (still allows reading incoming data)</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">end_input_stream</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//! \brief The inbound byte stream received from the peer</span></span><br><span class="line">   <span class="function">ByteStream &amp;<span class="title">inbound_stream</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">stream_out</span>(); &#125;</span><br><span class="line">   <span class="comment">// number of bytes sent and not yet acknowledged, counting SYN/FIN each as one byte</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">bytes_in_flight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="comment">//! \brief number of bytes not yet reassembled</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">unassembled_bytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief Number of milliseconds since the last segment was received</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// debug用</span></span><br><span class="line">   <span class="comment">//!&lt; \brief summarize the state of the sender, receiver, and the connection</span></span><br><span class="line">   <span class="function">TCPState <span class="title">state</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &#123;_sender, _receiver, <span class="built_in">active</span>(), _linger_after_streams_finish&#125;; &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这些函数都会由上层在某些时候调用</span></span><br><span class="line">   <span class="comment">// 时钟滴答、收到segment以及从segment_out中取数据，这些都是由os调用相应函数实现的</span></span><br><span class="line">   <span class="comment">// 这也正是所谓“协议”的接口意义！</span></span><br><span class="line">   <span class="comment">//! \name Methods for the owner or operating system to call</span></span><br><span class="line">   <span class="comment">//! Called when a new segment has been received from the network</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Called periodically when time elapses</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief TCPSegments that the TCPConnection has enqueued for transmission.</span></span><br><span class="line">   <span class="comment">//! \note The owner or operating system will dequeue these and</span></span><br><span class="line">   <span class="comment">//! put each one into the payload of a lower-layer datagram (usually Internet datagrams (IP),</span></span><br><span class="line">   <span class="comment">//! but could also be user datagrams (UDP) or any other kind).</span></span><br><span class="line">   <span class="function">std::queue&lt;TCPSegment&gt; &amp;<span class="title">segments_out</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _segments_out; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief Is the connection still alive in any way?</span></span><br><span class="line">   <span class="comment">//! \returns `true` if either stream is still running or if the TCPConnection is lingering</span></span><br><span class="line">   <span class="comment">//! after both streams have finished (e.g. to ACK retransmissions from the peer)</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">active</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Construct a new connection from a configuration</span></span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">TCPConnection</span><span class="params">(<span class="type">const</span> TCPConfig &amp;cfg)</span> : _cfg&#123;</span>cfg&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \name construction and destruction</span></span><br><span class="line">   <span class="comment">//! moving is allowed; copying is disallowed; default construction not possible</span></span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">TCPConnection</span>();  <span class="comment">//!&lt; destructor sends a RST if the connection is still open</span></span><br><span class="line">   <span class="built_in">TCPConnection</span>() = <span class="keyword">delete</span>;</span><br><span class="line">   <span class="built_in">TCPConnection</span>(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">   TCPConnection &amp;<span class="keyword">operator</span>=(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">   <span class="built_in">TCPConnection</span>(<span class="type">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">   TCPConnection &amp;<span class="keyword">operator</span>=(<span class="type">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>这部分暂时还不大明白，随便瞎写一点（）</p>
<p>首先是socket实现，似乎要涉及到对一些事件，比如说<code>segment receive</code>的监听。它具体是这么做的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_helper/tcp_sponge_socket.cc  _initialize_TCP()</span></span><br><span class="line">    <span class="comment">// Set up the event loop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are four possible events to handle:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 1) Incoming datagram received (needs to be given to</span></span><br><span class="line">    <span class="comment">//    TCPConnection::segment_received method)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 2) Outbound bytes received from local application via a write()</span></span><br><span class="line">    <span class="comment">//    call (needs to be read from the local stream socket and</span></span><br><span class="line">    <span class="comment">//    given to TCPConnection::data_written method)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 3) Incoming bytes reassembled by the TCPConnection</span></span><br><span class="line">    <span class="comment">//    (needs to be read from the inbound_stream and written</span></span><br><span class="line">    <span class="comment">//    to the local stream socket back to the application)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 4) Outbound segment generated by TCP (needs to be</span></span><br><span class="line">    <span class="comment">//    given to underlying datagram socket)</span></span><br></pre></td></tr></table></figure>

<p>比如说event4：</p>
<p><img src="/2023/02/25/cs144/image-20230304171810877.png" alt="image-20230304171810877"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_61233877/article/details/124349171">什么是eventloop</a></p>
<p>事件循环（event loop）就是 任务在主线程不断进栈出栈的一个循环过程。任务会在将要执行时进入主线程，在执行完毕后会退出主线程。</p>
<p>这里的大致意思就是增加了一个监听事件，一旦tcp_connection的segments_out有元素，就会马上取出来</p>
</blockquote>
<p>这部分不大懂，不知道后面会不会涉及对socket的编写？</p>
<p>还有一点是对测试脚本好像有了点了解。比如在<code>build/CTestTestfile.cmake</code>中可以看到每个测试的对应脚本以及使用的options：</p>
<p><img src="/2023/02/25/cs144/image-20230304170132380.png" alt="image-20230304170132380"></p>
<p>如果不知道option的用法可以这么做：</p>
<p><img src="/2023/02/25/cs144/image-20230305232621024.png" alt="image-20230305232621024"></p>
<p>这些脚本实现的对应代码在<code>sponge/apps</code>中。</p>
<p>又比如，在<code>sponge/etc/tests.cmake</code>中，可以找到各个测试程序执行的参数，就可以比如说修改测试的Timeout时间：</p>
<p><img src="/2023/02/25/cs144/image-20230305232913611.png" alt="image-20230305232913611"></p>
<h3 id="总结：状态机"><a href="#总结：状态机" class="headerlink" title="总结：状态机"></a>总结：状态机</h3><p>我们已经完整实现了整个TCP协议，是时候该对其做出一个总结了。</p>
<p>TCP协议本质上是一个<strong>状态机</strong>。</p>
<p>在我们的sponge TCP中，我们将一个endpoint的TCP协议分成了两个状态机，一个是<code>TCPReceiver</code>的状态机，另一个是<code>TCPSender</code>的状态机。它们依据外界的输入【从app或者互联网】来进行状态的转移。</p>
<p>以下几张图完美地体现了状态转移关系【具体的状态体现标注在代码中了】：</p>
<p><img src="/2023/02/25/cs144/image-20230226200935395.png" alt="image-20230226200935395"></p>
<p><img src="/2023/02/25/cs144/image-20230226202631406.png" alt="image-20230226202631406"></p>
<p><img src="/2023/02/25/cs144/image-20230305225738049.png" alt="image-20230305225738049"></p>
<p><img src="/2023/02/25/cs144/image-20230225232723083-1678028236763-1.png" alt="image-20230225232723083"></p>
<p>而<code>TCPConnection</code>并不是状态机，它是两个状态机和外界联通的<u>桥梁</u>。它的职能有：</p>
<ol>
<li><p>给状态机提供输入</p>
<p>包括：</p>
<ol>
<li>app调用<code>write</code>传进来的数据</li>
<li>peer通过<code>segment_received</code>传进来的数据</li>
</ol>
</li>
<li><p>处理状态机的输出</p>
<p>包括：</p>
<ol>
<li>app调用receiver的stream接口获取数据</li>
<li>通过<code>send_segment</code>向peer传递数据</li>
</ol>
</li>
</ol>
<p>也可以说，它具有显式推动状态机状态转移的作用，比如说：</p>
<ol>
<li>给状态机传递外界数据让他们转移</li>
<li><code>connect</code>通过调用<code>fill_window</code>推动<code>_sender</code>从CLOSED状态转移到SYN_SENT状态</li>
<li>转移到ERROR状态的条件判断</li>
</ol>
<p>等等等。</p>
<p>也因而，<code>TCPConnection</code>并不包含复杂的逻辑和算法，它仅仅是做一些条件判断，以及一些数据转发的工作。</p>
<h3 id="喜闻乐见的bug合集"><a href="#喜闻乐见的bug合集" class="headerlink" title="喜闻乐见的bug合集"></a>喜闻乐见的bug合集</h3><p>相比于代码的编写，本次实验最难的部分是测试。由于lab4基于lab0-3，因而前面没有发现的bug在本次黑压压162个测试之下会全部涌现出来。有些bug我还是不知道怎么回事，并且debug过程也不像xv6那样条理清晰步步为营，感觉充满着不少玄幻色彩，所以<strong>也没有很多干货好说</strong>。在这里就先记录下印象比较深刻，耗时比较久的bug吧。</p>
<h4 id="TCP-produced-‘ackno-1’"><a href="#TCP-produced-‘ackno-1’" class="headerlink" title="TCP produced ‘ackno=1’"></a>TCP produced ‘ackno=1’</h4><p><img src="/2023/02/25/cs144/image-20230303214944132.png" alt="image-20230303214944132"></p>
<p>需要发送一个ackno=2的帧，但是不知道为什么却发送了一个ackno=1的，并且无论我怎么找，在哪里print，都只能找到一个ackno=2的，连1的影子都看不到。这个现象确实很诡异，但其实它的内因很简单。它是由于我对空的ACK帧发送条件限制得不恰当才出现的。</p>
<blockquote>
<p>有没有觉得这里有点跳跃？我是怎么通过这个现象得知是ACK发送不恰当导致的？</p>
<p>答案是我当时也没想到这一点，无头苍蝇般转了可能有一个小时，这里print一下那里print一下都没有发现异常。最后我放弃了这个用例去看下一个错误的用例，才发现了这个小bug，改了一下发现这个也一起过了【绷】</p>
</blockquote>
<p>本来我是这么写的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把_sender的所有segment都发送出去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当没有要发送的帧，无法进行顺带ACK时，就只能发送一个只有ACK的空帧</span></span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            _sender.<span class="built_in">send_empty_ack_segment</span>(_receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in segment_received()</span></span><br><span class="line">    <span class="comment">//if (seg.length_in_sequence_space() != 0) &#123;</span></span><br><span class="line">    <span class="comment">//    empty_ack_send();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br></pre></td></tr></table></figure>

<p>如果这么写的话，当这台endpoint收到peer的一个empty ACK后，它就也会以示敬意回复一个empty ACK，这样除了本应发过去的ackno=2的报文，就多了个幽灵般的ackno=1的empty ACK，从而导致上面的错误。</p>
<p>因而，正确的做法是，我们在receive时只对**!empty**的seg进行ACK回复就行。具体写法可以看看我下面的代码。</p>
<h4 id="超时重传时间翻倍问题"><a href="#超时重传时间翻倍问题" class="headerlink" title="超时重传时间翻倍问题"></a>超时重传时间翻倍问题</h4><p><img src="/2023/02/25/cs144/image-20230303224104016.png" alt="image-20230303224104016"></p>
<p><img src="/2023/02/25/cs144/image-20230303224053277.png" alt="image-20230303224053277"></p>
<p>可以看到，它是想要我们在1000ms后再发一次FIN的，也即rto依然等于1000，但是我们的rto却是2000.为啥呢？那就去看看超时重传呗。</p>
<p>原来的超时重传代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_sender.cc</span></span><br><span class="line"><span class="keyword">if</span> (timer_start &amp;&amp; ticks &gt; timer_ticks &amp;&amp; ticks - timer_ticks &gt;= rto) &#123;</span><br><span class="line">    <span class="comment">// resend</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(tmp_segments.<span class="built_in">front</span>().segment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (window_size != <span class="number">0</span>) &#123;</span><br><span class="line">        cons_retran++;</span><br><span class="line">        rto *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer_ticks = ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改完后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timer_start &amp;&amp; ticks &gt; timer_ticks &amp;&amp; ticks - timer_ticks &gt;= rto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tmp_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// resend</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(tmp_segments.<span class="built_in">front</span>().segment);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (window_size != <span class="number">0</span>) &#123;</span><br><span class="line">            cons_retran++;</span><br><span class="line">            rto *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    timer_ticks = ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想想超时重传的定义，是不是重传了之后才会double时间呀（）</p>
<h4 id="assembler"><a href="#assembler" class="headerlink" title="assembler"></a>assembler</h4><p><img src="/2023/02/25/cs144/image-20230304163111298.png" alt="image-20230304163111298"></p>
<p>这个test花了我半个下午的时间排查和修改。大致流程及报错信息是，一方发了65000个byte，但是另一方只能收到&lt;&lt;65000个。最后print了一下，发现是<code>streamassembler</code>写错了，在stream end的时候仍然有很大一部分数据未被整流。</p>
<blockquote>
<p>这个直面屎山的经历极大地鼓舞了我</p>
</blockquote>
<p>之前在写<code>streamassembler</code>的时候就知道有个地方是错的了，那就是我对capacity的理解【具体见前面的笔记】。现在只用改一下就好了。修改方式很简单，加上这两句话就行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">right = right &lt;= left_bound + _capacity ? right : left_bound + _capacity;  <span class="comment">// 右边越界的也不要</span></span><br><span class="line"><span class="keyword">if</span> (o_left &gt;= left_bound + _capacity)       <span class="keyword">goto</span> end;  <span class="comment">// 越界的不要</span></span><br></pre></td></tr></table></figure>

<h4 id="t-udp-client-send超时"><a href="#t-udp-client-send超时" class="headerlink" title="t_udp_client_send超时"></a><code>t_udp_client_send</code>超时</h4><p><img src="/2023/02/25/cs144/image-20230304215748823.png" alt="image-20230304215748823"></p>
<p>这个错因非常地诡异，我到最后也还是没有自己找出来。直到我瞎搜来搜去看到了这篇文章：</p>
<blockquote>
<p>我也是真的很佩服这篇文章的作者能找到这个点</p>
<p><img src="/2023/02/25/cs144/image-20230304221420748.png" alt="image-20230304221420748"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lawliet12/p/17066719.html">https://www.cnblogs.com/lawliet12/p/17066719.html</a></p>
</blockquote>
<p><img src="/2023/02/25/cs144/image-20230305215310021.png" alt="image-20230305215310021"></p>
<p>噔噔咚。</p>
<p>我为什么不用<code>_cfg.rt_timeout</code>呢？答案是我当初脑子一抽以为<code>rt_timeout</code>是static、const的，就写了个<code>TCPConfig::rt_timeout</code>然后报错了，我懒得思考了就换成了上面的那个，结果……就这东西，又花费了我好久好久【悲】怪我没有认真看，没发现<code>rt_timeout</code>不是一个静态常量。</p>
<h4 id="t-ucS-1M-32K超时"><a href="#t-ucS-1M-32K超时" class="headerlink" title="t_ucS_1M_32K超时"></a><code>t_ucS_1M_32K</code>超时</h4><p><img src="/2023/02/25/cs144/image-20230305162239877.png" alt="image-20230305162239877"></p>
<p>以及其后面的其他test也都超时了。</p>
<p>说实话我真是百思不得其解，这里打印来那里打印去，也都看得眼花缭乱什么也看不出来，使用指导书那些手动测试的方法，还有抓包，都十分地正常，但它自动测试就是会timeout。</p>
<p>我折腾来折腾去，这里print那里print，最后还怀疑是电脑问题就放到服务器上跑了一下结果还是不行。绝望之际，我只能使出了<strong>万策尽之时的迫不得已的非法手段</strong>：将我的一部分代码替换成别人的看看会怎么样。【传统艺能23333】</p>
<p>最终我定位发现是<code>TCPSender</code>出了问题，我猜测是因为状态机出错了。我比对着别人的代码【知道这不对，但我心态已经崩了。。。】，以及指导书提供的状态机，发现是这个地方出了小问题：</p>
<p><img src="/2023/02/25/cs144/image-20230305220614819.png" alt="image-20230305220614819"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in tcp_sender.cc fill_window()</span></span><br><span class="line">		<span class="comment">// 注释的是以前写的错误版本</span></span><br><span class="line">        <span class="comment">// if (_stream.input_ended() &amp;&amp; !fin &amp;&amp; remaining &gt; 0) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !fin &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// last segment</span></span><br><span class="line">            segment.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">            fin = <span class="literal">true</span>;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里不应该是<code>input_ended</code>，而应该是<code>eof</code>……</p>
<p>改了之后立刻所有测试都能跑通了【悲】</p>
<blockquote>
<p>那么问题来了，为什么错误版本就会timeout呢？我的猜测如下：</p>
<p>eof的条件如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_input_end &amp;&amp; buffer.<span class="built_in">empty</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，eof既要求input_ended，又要求缓冲区内所有数据成功发送。这也很符合FIN_SENT的语义：在数据流终止时（所有数据成功发送，不要求fully acked）发送FIN。</p>
<p>如果按照我错误版本的写法，会导致数据还没发送完毕（<code>!buffer.empty()</code>），就发送了FIN。之后数据虽然还能正常进入receiver的bytestream，并且发送给peer的receiver。但是会存在这也一个空窗期：FIN之后的数据还没到的时候，peer的receiver接收到FIN，并且peer的app从socket将receiver接收到的数据全部读出。出现了这样的空窗期，就会导致peer的receiver的stream达到eof状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in tcp_receiver.cc segment_received()</span></span><br><span class="line">     <span class="keyword">if</span> (abs_seqno != <span class="number">0</span>)</span><br><span class="line">         _reassembler.<span class="built_in">push_substring</span>(data, index, header.fin);</span><br><span class="line"><span class="comment">// in streamassembler.cc</span></span><br><span class="line"> <span class="keyword">if</span> (is_eof &amp;&amp; buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">     _output.<span class="built_in">end_input</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>【接下来就是猜了】由于bytestream eof了，socket就停止读了。后来的数据再来，receiver的stream的缓冲区就满了，receiver就只能一直丢包。【接下来是真的<strong>纯猜</strong>】而且由于测试脚本问题，在这之后都不会调用tick方法了，故而超时重传检测不会被触发，而sender也会因为没有ack，而一直重传重传，就死循环然后timeout寄掉了。</p>
<p>纯猜部分的依据是：</p>
<p><img src="/2023/02/25/cs144/image-20230305173110776.png" alt="image-20230305173110776"></p>
<p><img src="/2023/02/25/cs144/image-20230305173152469.png" alt="image-20230305173152469"></p>
<p>可以看到，tick方法一直被调用，但是ticks却不变。数据报文一直被重传，但是retran一直不变。ticks-timer_ticks一直大于rto，但却始终无法进入那句if（经测试是这样的）。这非常奇怪，我也不知道为什么。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>【珍贵的调试用代码没删的版本放在github了。】</p>
<h3 id="TCPConnection-hh"><a href="#TCPConnection-hh" class="headerlink" title="TCPConnection.hh"></a>TCPConnection.hh</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPConnection</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="type">size_t</span> rec_tick&#123;&#125;;<span class="comment">// 上一次收到segment时的ticks数</span></span><br><span class="line">    <span class="type">size_t</span> ticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">segment_send</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">empty_ack_send</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_rst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="TCPConnection-cc"><a href="#TCPConnection-cc" class="headerlink" title="TCPConnection.cc"></a>TCPConnection.cc</h3><p>如果想要以状态机的视角来看待，可以看看<a target="_blank" rel="noopener" href="https://github.com/shootfirst/CS144/">感恩</a>的代码。他写得很清晰。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_connection.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ticks - rec_tick; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一个只有ACK的空帧，仅在segment_received中调用</span></span><br><span class="line"><span class="comment">// 当没有要发送的帧，无法进行顺带ACK时，</span></span><br><span class="line"><span class="comment">// 为了保障一定有ACK发送，就只能发送一个只有ACK的空帧</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::empty_ack_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            _sender.<span class="built_in">send_empty_ack_segment</span>(_receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把_sender的所有segment都发送出去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// 顺带ACK</span></span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connection被置为error状态的部分必要操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::set_rst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重置发送的ticks</span></span><br><span class="line">    rec_tick = ticks;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        <span class="comment">// RST is set</span></span><br><span class="line">        <span class="built_in">set_rst</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回复对方问你是死是活的信息</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        seg.<span class="built_in">header</span>().seqno - _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">        <span class="built_in">segment_send</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123; <span class="comment">// ack_received也会调用fill_window</span></span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 只在本次收到的seg需要被ACK的时候才要ACK。</span></span><br><span class="line">    <span class="comment">// 需要被ACK：FIN/SYN/携带数据   总之就是length!=0</span></span><br><span class="line">    <span class="comment">// 不得不说，FIN和SYN都会占一个序列号这个点给ACK设计带来了简便，同时也增加了安全性</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">empty_ack_send</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If the inbound stream ends before the TCPConnection has reached EOF </span></span><br><span class="line">    <span class="comment">// on its outbound stream, this variable needs to be set to false</span></span><br><span class="line">    <span class="comment">// 如果receiver的那个stream比sender的stream早结束，就不用等待</span></span><br><span class="line">    <span class="comment">// 为什么呢？因为receiver的stream结束说明了全部的seg都成功接收并且全部整流【参见assembler实现】</span></span><br><span class="line">    <span class="comment">// 也就说明对方不发送数据了，并且已经把FIN也发过来了</span></span><br><span class="line">    <span class="comment">// 也即对方进入了FIN_WAIT状态</span></span><br><span class="line">    <span class="comment">// 而我们的sender还在输出，也即我们在CLOSE_WAIT状态</span></span><br><span class="line">    <span class="comment">// 因而我们只需输出完剩余数据再发送AF,最后直接关闭就行</span></span><br><span class="line">    <span class="comment">// 因为我们知道对方已经关闭了，无需再进行linger。</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; !_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        <span class="comment">// peer:FIN_WAIT   self:CLOSE_WAIT</span></span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="comment">// 处于error状态</span></span><br><span class="line">    <span class="keyword">if</span> (!_linger_after_streams_finish &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">error</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">error</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 满足条件1-3</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp;</span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">fully_acked</span>()) &#123;</span><br><span class="line">        <span class="comment">// 无需等待的话就直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!_linger_after_streams_finish)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 否则需要等待10*timeout</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">time_since_last_segment_received</span>() &gt;= <span class="number">10</span> * _cfg.rt_timeout)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> res = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    <span class="comment">// 注意此处需要手动调一下fill_window和send方法</span></span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ms_since_last_tick: number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    ticks += ms_since_last_tick;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; _cfg.MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>())</span><br><span class="line">            _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();  <span class="comment">// 清除sender遗留的所有帧</span></span><br><span class="line">        _sender.<span class="built_in">send_empty_rst_segment</span>();<span class="comment">// 只发送rst帧</span></span><br><span class="line">        <span class="built_in">set_rst</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// end the connection cleanly if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp;</span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">fully_acked</span>()</span><br><span class="line">	&amp;&amp; <span class="built_in">time_since_last_segment_received</span>() &gt;= <span class="number">10</span> * _cfg.rt_timeout) &#123;</span><br><span class="line">        <span class="comment">// 等待结束</span></span><br><span class="line">	    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="comment">// send_segment重复代码。目的是防止发送SYN外还发送别的东西</span></span><br><span class="line">    <span class="keyword">if</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// shutdown uncleanly</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">	    	<span class="built_in">set_rst</span>();</span><br><span class="line">            _sender.<span class="built_in">send_empty_rst_segment</span>();</span><br><span class="line">            <span class="built_in">segment_send</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="debug函数"><a href="#debug函数" class="headerlink" title="debug函数"></a>debug函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_helper/tcp_segment.hh</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_seg</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">         std::cerr&lt;&lt;<span class="string">&quot;  flag=&quot;</span>&lt;&lt;(<span class="built_in">header</span>().syn?<span class="string">&quot;S&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;(<span class="built_in">header</span>().ack?<span class="string">&quot;A&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;(<span class="built_in">header</span>().fin?<span class="string">&quot;F&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">            &lt;&lt;<span class="string">&quot;  seqno=&quot;</span>&lt;&lt;<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>()&lt;&lt;<span class="string">&quot;   ackno=&quot;</span>&lt;&lt;<span class="built_in">header</span>().ackno.<span class="built_in">raw_value</span>()</span><br><span class="line">            &lt;&lt;<span class="string">&quot;  payload_size:&quot;</span>&lt;&lt;<span class="built_in">payload</span>().<span class="built_in">size</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>in libsponge/tcp_helper/fd_adapter.cc</code></p>
<p><img src="/2023/02/25/cs144/image-20230304172207234.png" alt="image-20230304172207234"></p>

    </div>

    
    
    

		<div>
		  
			<div>
    
        <div style="text-align:center;color: #f7cdcd;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
		  
		</div>

      <footer class="post-footer">

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab4-TCPConnection"><span class="nav-number">1.</span> <span class="nav-text">Lab4   TCPConnection</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%83%E5%BE%97"><span class="nav-number">1.1.</span> <span class="nav-text">心得</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%97%E6%97%B6%E6%83%85%E5%86%B5"><span class="nav-number">1.1.1.</span> <span class="nav-text">耗时情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">1.1.2.</span> <span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AF%BC%E4%B9%A6%E5%86%85%E5%AE%B9"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">指导书内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">接口说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.1.3.</span> <span class="nav-text">测试程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">1.1.4.</span> <span class="nav-text">总结：状态机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%96%9C%E9%97%BB%E4%B9%90%E8%A7%81%E7%9A%84bug%E5%90%88%E9%9B%86"><span class="nav-number">1.1.5.</span> <span class="nav-text">喜闻乐见的bug合集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-produced-%E2%80%98ackno-1%E2%80%99"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">TCP produced ‘ackno&#x3D;1’</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%BF%BB%E5%80%8D%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">超时重传时间翻倍问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#assembler"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">assembler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#t-udp-client-send%E8%B6%85%E6%97%B6"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">t_udp_client_send超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#t-ucS-1M-32K%E8%B6%85%E6%97%B6"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">t_ucS_1M_32K超时</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCPConnection-hh"><span class="nav-number">1.2.1.</span> <span class="nav-text">TCPConnection.hh</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCPConnection-cc"><span class="nav-number">1.2.2.</span> <span class="nav-text">TCPConnection.cc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#debug%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">debug函数</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="修年"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">修年</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:nniferyy@gmail.com" title="E-Mail → mailto:nniferyy@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">修年</span>
</div>


<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("10/04/2022 17:38:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  



  <script type="text/javascript" src="/js/clicklove.js"></script>
</body>
</html>
