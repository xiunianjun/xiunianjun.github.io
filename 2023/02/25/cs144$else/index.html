<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="修年"><meta name="copyright" content="修年"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>其他的对实验未涉及的思考 | 修年</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"xiunianjun.github.io","root":"/","title":"修年","version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="其他的对实验未涉及的思考网络层实现在我们的协议栈实现中，我们负责了运输层的TCP协议、网络层的ARP协议以及数据链路层的ETH协议的编写，剩下的网络层的IP协议则由官方给定。接下来我们就来探究下网络层的实现。 总体架构 You’ve done this already. In Lab 4, we gave:  an object that represents an Internet datagr">
<meta property="og:type" content="article">
<meta property="og:title" content="其他的对实验未涉及的思考">
<meta property="og:url" content="https://xiunianjun.github.io/2023/02/25/cs144$else/index.html">
<meta property="og:site_name" content="修年">
<meta property="og:description" content="其他的对实验未涉及的思考网络层实现在我们的协议栈实现中，我们负责了运输层的TCP协议、网络层的ARP协议以及数据链路层的ETH协议的编写，剩下的网络层的IP协议则由官方给定。接下来我们就来探究下网络层的实现。 总体架构 You’ve done this already. In Lab 4, we gave:  an object that represents an Internet datagr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/class_socket__inherit__graph.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230309232045195.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/image-20230310185319115.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/02/25/cs144/class_fd_adapter_base__inherit__graph.png">
<meta property="article:published_time" content="2023-02-25T14:19:00.000Z">
<meta property="article:modified_time" content="2023-03-11T07:08:03.036Z">
<meta property="article:author" content="修年">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiunianjun.github.io/2023/02/25/cs144/class_socket__inherit__graph.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="修年"><img width="96" loading="lazy" src="/images/head.png" alt="修年"></a><div class="site-author-name"><a href="/about/">修年</a></div><span class="site-name">修年</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">46</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">6</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><span class="icon iconify" data-icon="ri:rss-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://user.qzone.qq.com/1776527992/main" title="QQ" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/xiunianjun" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:nniferyy@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E5%AF%B9%E5%AE%9E%E9%AA%8C%E6%9C%AA%E6%B6%89%E5%8F%8A%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">1.</span> <span class="toc-text">其他的对实验未涉及的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">网络层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">总体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ipv4-datagram-hh-amp-amp-ipv4-header-hh"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">ipv4_datagram.hh &amp;&amp; ipv4_header.hh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-over-ip"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">tcp_over_ip</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">Socket实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileDescriptor"><span class="toc-number">1.2.1.</span> <span class="toc-text">FileDescriptor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6-1"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">包装系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket"><span class="toc-number">1.2.2.</span> <span class="toc-text">Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6-2"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">构造器的参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCPSpongeSocket"><span class="toc-number">1.2.3.</span> <span class="toc-text">* TCPSpongeSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">双线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">事件监听</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#initialize-TCP"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">_initialize_TCP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tcp-loop"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">_tcp_loop</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#eventloop"><span class="toc-number">1.2.3.2.3.</span> <span class="toc-text">eventloop</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">生命周期的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#connect"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">connect</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tcp-main"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">_tcp_main</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#listen-and-accept"><span class="toc-number">1.2.3.3.3.</span> <span class="toc-text">listen_and_accept</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CS144TCPSocket-%E5%92%8C-FullStackSocket"><span class="toc-number">1.2.4.</span> <span class="toc-text">CS144TCPSocket 和 FullStackSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Adapter%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">Adapter实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apps"><span class="toc-number">1.3.</span> <span class="toc-text">apps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bidirectional-stream-copy"><span class="toc-number">1.3.1.</span> <span class="toc-text">bidirectional_stream_copy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://xiunianjun.github.io/2023/02/25/cs144$else/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="修年"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="修年"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">其他的对实验未涉及的思考</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2023-02-25 22:19:00" itemprop="dateCreated datePublished" datetime="2023-02-25T22:19:00+08:00">2023-02-25</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2023-03-11 15:08:03" itemprop="dateModified" datetime="2023-03-11T15:08:03+08:00">2023-03-11</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="其他的对实验未涉及的思考"><a href="#其他的对实验未涉及的思考" class="headerlink" title="其他的对实验未涉及的思考"></a>其他的对实验未涉及的思考</h1><h2 id="网络层实现"><a href="#网络层实现" class="headerlink" title="网络层实现"></a>网络层实现</h2><p>在我们的协议栈实现中，我们负责了运输层的TCP协议、网络层的ARP协议以及数据链路层的ETH协议的编写，剩下的网络层的IP协议则由官方给定。接下来我们就来探究下网络层的实现。</p>
<h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><blockquote>
<p><strong>You’ve done this already.</strong></p>
<p>In Lab 4, we gave:</p>
<ol>
<li>an object that represents an Internet datagram and knows how to parse and serialize itself (<code>tcp_helpers/ipv4_datagram.&#123;hh,cc&#125;</code>) 表示了Internet datagram的数据结构，它可以自己序列化。</li>
<li>the logic to encapsulate(封装) TCP segments in IP (now found in <code>tcp_helpers/tcp_over_ip.cc</code>).</li>
</ol>
<p>The <code>CS144TCPSocket</code> uses these tools to connect your <code>TCPConnection</code> to a TUN device.</p>
</blockquote>
<p>也即，IP协议主要由两个文件实现，一个是IP数据报抽象为的类<code>ipv4_datagram.&#123;hh,cc&#125;</code>，另一个是将TCP报文封装为IP报文的类<code>tcp_helpers/tcp_over_ip.cc</code>；除此之外，IP协议还负责与下次协议连接，在实验0-4中它通过<code>CS144TCPSocket</code>与TUN连接，在实验5-6则与TAN连接。</p>
<p>连接部分暂且先放到下一部分讲，下面来看看IP协议的具体实现。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="ipv4-datagram-hh-amp-amp-ipv4-header-hh"><a href="#ipv4-datagram-hh-amp-amp-ipv4-header-hh" class="headerlink" title="ipv4_datagram.hh &amp;&amp; ipv4_header.hh"></a>ipv4_datagram.hh &amp;&amp; ipv4_header.hh</h4><p><code>ipv4_datagram</code>没什么好说的，跟<code>TCPSegment</code>的结构一模一样。<code>ipv4_header</code>也没什么好说的，就纯纯是IP数据报的报头、</p>
<h4 id="tcp-over-ip"><a href="#tcp-over-ip" class="headerlink" title="tcp_over_ip"></a>tcp_over_ip</h4><h5 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h5><p>它的头文件很简单，只包含一个类的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A converter from TCP segments to serialized IPv4 datagrams</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPOverIPv4Adapter</span> : <span class="keyword">public</span> FdAdapterBase &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::optional&lt;TCPSegment&gt; <span class="title">unwrap_tcp_in_ip</span><span class="params">(<span class="type">const</span> InternetDatagram &amp;ip_dgram)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">InternetDatagram <span class="title">wrap_tcp_in_ip</span><span class="params">(TCPSegment &amp;seg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// SPONGE_LIBSPONGE_TCP_OVER_IP_HH</span></span></span><br></pre></td></tr></table></figure>

<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><p>可以看到，相比于TCP和ETH/ARP协议，IP协议的实现可以说是非常简单。它作为一个中间层，只需要把上面给的东西包装下再传到下面，或者把下面给的东西解包下再传给上面，无需其他复杂的算法和数据结构（比如TCP的reliable transmission和ETH/ARP的地址自学习），也无需跟外界打交道。</p>
<p>除了打包解包外，它只需确保一件事，那就是一台主机只能同时拥有一个TCP连接。这样一来也能简化其实现：填写IP协议头时，它就只需从自己保存的config中取参数就行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来拆IP数据包为一个TCP数据包</span></span><br><span class="line"><span class="comment">//! If this succeeds, it then checks that the received segment is related to the</span></span><br><span class="line"><span class="comment">//! current connection. When a TCP connection has been established, this means</span></span><br><span class="line"><span class="comment">//  如果TCP连接已建立，则会检查src和dst端口号的正确性</span></span><br><span class="line"><span class="comment">//! checking that the source and destination ports in the TCP header are correct.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! If the TCP connection is listening 如果处于listening状态，并且参数为SYN报文</span></span><br><span class="line"><span class="comment">//! and the TCP segment read from the wire includes a SYN, this function clears the</span></span><br><span class="line"><span class="comment">//  就需要解除listening的flag，记录下src和dst的地址和端口号</span></span><br><span class="line"><span class="comment">//! `_listen` flag and records the source and destination addresses and port numbers</span></span><br><span class="line"><span class="comment">//  目的是为了 filter future reads</span></span><br><span class="line"><span class="comment">//  这说明我们的sponge实现是单线程的，也就是一台主机只能同时建立一个TCP连接</span></span><br><span class="line"><span class="comment">//  并且在此时会忽略其他主机发过来的数据包</span></span><br><span class="line"><span class="comment">//! from the TCP header; it uses this information to filter future reads.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  returns a std::optional&lt;TCPSegment&gt; that is empty if the segment was invalid or unrelated</span></span><br><span class="line"><span class="function">optional&lt;TCPSegment&gt; <span class="title">TCPOverIPv4Adapter::unwrap_tcp_in_ip</span><span class="params">(<span class="type">const</span> InternetDatagram &amp;ip_dgram)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// is the IPv4 datagram for us?</span></span><br><span class="line">    <span class="comment">// Note: it&#x27;s valid to bind to address &quot;0&quot; (INADDR_ANY) and reply from actual address contacted</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">listening</span>() <span class="built_in">and</span> (ip_dgram.<span class="built_in">header</span>().dst != <span class="built_in">config</span>().source.<span class="built_in">ipv4_numeric</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the IPv4 datagram from our peer?</span></span><br><span class="line">    <span class="comment">// 过滤非peer发来的其他数据包</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">listening</span>() <span class="built_in">and</span> (ip_dgram.<span class="built_in">header</span>().src != <span class="built_in">config</span>().destination.<span class="built_in">ipv4_numeric</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// does the IPv4 datagram claim that its payload is a TCP segment?</span></span><br><span class="line">    <span class="comment">// 我们只需解包TCP数据报</span></span><br><span class="line">    <span class="keyword">if</span> (ip_dgram.<span class="built_in">header</span>().proto != IPv4Header::PROTO_TCP) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the payload a valid TCP segment?</span></span><br><span class="line">    TCPSegment tcp_seg;</span><br><span class="line">    <span class="keyword">if</span> (ParseResult::NoError != tcp_seg.<span class="built_in">parse</span>(ip_dgram.<span class="built_in">payload</span>(), ip_dgram.<span class="built_in">header</span>().<span class="built_in">pseudo_cksum</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the TCP segment for us?</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_seg.<span class="built_in">header</span>().dport != <span class="built_in">config</span>().source.<span class="built_in">port</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should we target this source addr/port (and use its destination addr as our source) in reply?</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listening</span>()) &#123;</span><br><span class="line">        <span class="comment">// records the source and destination addresses and port numbers</span></span><br><span class="line">        <span class="keyword">if</span> (tcp_seg.<span class="built_in">header</span>().syn <span class="keyword">and</span> <span class="keyword">not</span> tcp_seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">            <span class="built_in">config_mutable</span>().source = &#123;<span class="built_in">inet_ntoa</span>(&#123;<span class="built_in">htobe32</span>(ip_dgram.<span class="built_in">header</span>().dst)&#125;), <span class="built_in">config</span>().source.<span class="built_in">port</span>()&#125;;</span><br><span class="line">            <span class="built_in">config_mutable</span>().destination = &#123;<span class="built_in">inet_ntoa</span>(&#123;<span class="built_in">htobe32</span>(ip_dgram.<span class="built_in">header</span>().src)&#125;), tcp_seg.<span class="built_in">header</span>().sport&#125;;</span><br><span class="line">            <span class="built_in">set_listening</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the TCP segment from our peer?</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_seg.<span class="built_in">header</span>().sport != <span class="built_in">config</span>().destination.<span class="built_in">port</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tcp_seg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Takes a TCP segment, sets port numbers as necessary, and wraps it in an IPv4 datagram</span></span><br><span class="line"><span class="comment">//! \param[in] seg is the TCP segment to convert</span></span><br><span class="line"><span class="function">InternetDatagram <span class="title">TCPOverIPv4Adapter::wrap_tcp_in_ip</span><span class="params">(TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set the port numbers in the TCP segment</span></span><br><span class="line">    seg.<span class="built_in">header</span>().sport = <span class="built_in">config</span>().source.<span class="built_in">port</span>();</span><br><span class="line">    seg.<span class="built_in">header</span>().dport = <span class="built_in">config</span>().destination.<span class="built_in">port</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an Internet Datagram and set its addresses and length</span></span><br><span class="line">    InternetDatagram ip_dgram;</span><br><span class="line">    ip_dgram.<span class="built_in">header</span>().src = <span class="built_in">config</span>().source.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    ip_dgram.<span class="built_in">header</span>().dst = <span class="built_in">config</span>().destination.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    <span class="comment">// uint8_t hlen = LENGTH / 4;  //!&lt; header length</span></span><br><span class="line">    <span class="comment">// uint8_t doff = LENGTH / 4;  //!&lt; data offset</span></span><br><span class="line">    ip_dgram.<span class="built_in">header</span>().len = ip_dgram.<span class="built_in">header</span>().hlen * <span class="number">4</span> + seg.<span class="built_in">header</span>().doff * <span class="number">4</span> + seg.<span class="built_in">payload</span>().<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set payload, calculating TCP checksum using information from IP header</span></span><br><span class="line">    ip_dgram.<span class="built_in">payload</span>() = seg.<span class="built_in">serialize</span>(ip_dgram.<span class="built_in">header</span>().<span class="built_in">pseudo_cksum</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ip_dgram;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Socket实现"><a href="#Socket实现" class="headerlink" title="Socket实现"></a>Socket实现</h2><p>最top的话可以分为<code>CS144TCPSocket</code>和<code>FullStackSocket</code>。</p>
<p>继承关系如下图：</p>
<p><img src="/2023/02/25/cs144/class_socket__inherit__graph.png" alt="Inheritance graph" loading="lazy"></p>
<p>其中，<code>TCPSocket</code>是完完全全的包装类，它的所有协议栈都是在内核态中实现（也就是跟我们之后写的没半毛钱关系），它的存在意义应该是用在lab0来写<code>webget</code>的测试。而<code>CS144TCPSocket</code>就是我们在lab0-4用的了，它的数据链路层由内核实现，网络层和运输层由用户实现。<code>FullStackSocket</code>就是加上了我们在lab5做的用户态数据链路层。</p>
<p>最主要的部分是<code>TCPSpongeSocket</code>的实现，其他就是一些包装类没什么好说的。</p>
<h3 id="FileDescriptor"><a href="#FileDescriptor" class="headerlink" title="FileDescriptor"></a>FileDescriptor</h3><p>将socket看作是fd，将网络看作是IO，这一抽象简直是太伟大了，牛逼到爆。</p>
<h4 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! A reference-counted handle to a file descriptor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileDescriptor</span> &#123;</span><br><span class="line">    <span class="comment">//! \brief A handle on a kernel file descriptor.</span></span><br><span class="line">    <span class="comment">//! \details FileDescriptor objects contain a std::shared_ptr to a FDWrapper.</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FDWrapper</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> _fd;                    <span class="comment">// file descriptor number returned by the kernel</span></span><br><span class="line">        <span class="type">bool</span> _eof = <span class="literal">false</span>;          <span class="comment">// fd是否eof</span></span><br><span class="line">        <span class="type">bool</span> _closed = <span class="literal">false</span>;       <span class="comment">// fd是否close</span></span><br><span class="line">        <span class="comment">// fd被读写的次数</span></span><br><span class="line">        <span class="type">unsigned</span> _read_count = <span class="number">0</span>;   </span><br><span class="line">        <span class="type">unsigned</span> _write_count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Construct from a file descriptor number returned by the kernel</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">FDWrapper</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd)</span></span>;</span><br><span class="line">        <span class="comment">//! Closes the file descriptor upon destruction</span></span><br><span class="line">        ~<span class="built_in">FDWrapper</span>();</span><br><span class="line">        <span class="comment">//! Calls [close(2)](\ref man2::close) on FDWrapper::_fd</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//! An FDWrapper cannot be copied or moved</span></span><br><span class="line">        <span class="built_in">FDWrapper</span>(<span class="type">const</span> FDWrapper &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">        FDWrapper &amp;<span class="keyword">operator</span>=(<span class="type">const</span> FDWrapper &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="built_in">FDWrapper</span>(FDWrapper &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">        FDWrapper &amp;<span class="keyword">operator</span>=(FDWrapper &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! A reference-counted handle to a shared FDWrapper</span></span><br><span class="line">    std::shared_ptr&lt;FDWrapper&gt; _internal_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private constructor used to duplicate the FileDescriptor (increase the reference count)  这个构造函数会增加其参数传进来的那个fd的引用，也许相当于dump</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FileDescriptor</span><span class="params">(std::shared_ptr&lt;FDWrapper&gt; other_shared_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">register_read</span><span class="params">()</span> </span>&#123; ++_internal_fd-&gt;_read_count; &#125;    <span class="comment">//!&lt; increment read count</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">register_write</span><span class="params">()</span> </span>&#123; ++_internal_fd-&gt;_write_count; &#125;  <span class="comment">//!&lt; increment write count</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Construct from a file descriptor number returned by the kernel</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FileDescriptor</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Free the std::shared_ptr; the FDWrapper destructor calls close() when the refcount goes to zero.</span></span><br><span class="line">    ~<span class="built_in">FileDescriptor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  读写  */</span></span><br><span class="line">    <span class="function">std::string <span class="title">read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> limit = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::max())</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(std::string &amp;str, <span class="type">const</span> <span class="type">size_t</span> limit = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::max())</span></span>;</span><br><span class="line">    <span class="comment">// possibly blocking until all is written</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">write</span>(<span class="built_in">BufferViewList</span>(str), write_all); &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;str, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">write</span>(<span class="built_in">BufferViewList</span>(str), write_all); &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(BufferViewList buffer, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Close the underlying file descriptor</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; _internal_fd-&gt;<span class="built_in">close</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Copy a FileDescriptor explicitly, increasing the FDWrapper refcount</span></span><br><span class="line">    <span class="function">FileDescriptor <span class="title">duplicate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Set blocking(true) or non-blocking(false)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_blocking</span><span class="params">(<span class="type">const</span> <span class="type">bool</span> blocking_state)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p>差不多就是全程调用系统调用没什么好说的，记录下几个有意思的点</p>
<h5 id="包装系统调用"><a href="#包装系统调用" class="headerlink" title="包装系统调用"></a>包装系统调用</h5><p>可以看下其调用系统调用的方式，看起来很有意思：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileDescriptor::set_blocking</span><span class="params">(<span class="type">const</span> <span class="type">bool</span> blocking_state)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">SystemCall</span>(<span class="string">&quot;fcntl&quot;</span>, <span class="built_in">fcntl</span>(<span class="built_in">fd_num</span>(), F_GETFL));</span><br><span class="line">    <span class="keyword">if</span> (blocking_state) &#123;</span><br><span class="line">        flags ^= (flags &amp; O_NONBLOCK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags |= O_NONBLOCK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SystemCall</span>(<span class="string">&quot;fcntl&quot;</span>, <span class="built_in">fcntl</span>(<span class="built_in">fd_num</span>(), F_SETFL, flags));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说这里设置文件读写是否阻塞就是通过系统调用实现的。</p>
<p>在写os实验时，你应该就能很深刻感受到，很多时候调用完一个系统调用后，对它的返回结果进行合法性判断以及错误处理还是有点烦的（举例来说，如<code>if(kalloc() == 0)</code>或者<code>if(mappages() == 0)</code>，出错后杀死进程等等等）。在那会我们还可以直接就这么冗余地干了，但是这里不行，一是我们要用面向对象的思想，二是我们的重点事实上并不是操作系统而是网络，因而最好还是这么封装下以减少冗余代码。</p>
<p>而它除了会调用系统调用外，还使用了一个包装性的方法<code>SystemCall</code>来保障调用的安全性和合理性。看看<code>SystemCall</code>的具体实现方式，确实就是包了层安全检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SystemCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (return_value &gt;= <span class="number">0</span> || errno == errno_mask) &#123;</span><br><span class="line">        <span class="keyword">return</span> return_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">unix_error</span>(attempt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os内核看不懂c++，所以要注意转换为c-style的字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SystemCall</span><span class="params">(<span class="type">const</span> string &amp;attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SystemCall</span>(attempt.<span class="built_in">c_str</span>(), return_value, errno_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>没什么好说的，只是操作系统socket接口的包装类。</p>
<h4 id="头文件-2"><a href="#头文件-2" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base class for network sockets (TCP, UDP, etc.)</span></span><br><span class="line"><span class="comment">// Socket is generally used via a subclass. See TCPSocket and UDPSocket for usage examples.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span> : <span class="keyword">public</span> FileDescriptor &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! Get the local or peer address the socket is connected to</span></span><br><span class="line">    <span class="function">Address <span class="title">get_address</span><span class="params">(<span class="type">const</span> std::string &amp;name_of_function,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> std::function&lt;<span class="type">int</span>(<span class="type">int</span>, sockaddr *, <span class="type">socklen_t</span> *)&gt; &amp;function)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Socket</span>(<span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type);</span><br><span class="line">    <span class="built_in">Socket</span>(FileDescriptor &amp;&amp;fd, <span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> option_type&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setsockopt</span><span class="params">(<span class="type">const</span> <span class="type">int</span> level, <span class="type">const</span> <span class="type">int</span> option, <span class="type">const</span> option_type &amp;option_value)</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Bind a socket to a local address, usually for listen/accept</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bind</span><span class="params">(<span class="type">const</span> Address &amp;address)</span></span>;</span><br><span class="line">    <span class="comment">// Connect a socket to a peer address</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> Address &amp;address)</span></span>;</span><br><span class="line">    <span class="comment">// Shut down a socket</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">(<span class="type">const</span> <span class="type">int</span> how)</span></span>;</span><br><span class="line">    <span class="comment">//! Get local address of socket</span></span><br><span class="line">    <span class="function">Address <span class="title">local_address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//! Get peer address of socket</span></span><br><span class="line">    <span class="function">Address <span class="title">peer_address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//! Allow local address to be reused sooner</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_reuseaddr</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! A wrapper around [UDP sockets](\ref man7::udp)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UDPSocket</span> : <span class="keyword">public</span> Socket &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//! \brief Construct from FileDescriptor (used by TCPOverUDPSocketAdapter)</span></span><br><span class="line">    <span class="comment">//! \param[in] fd is the FileDescriptor from which to construct</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UDPSocket</span><span class="params">(FileDescriptor &amp;&amp;fd)</span> : Socket(std::move(fd), AF_INET, SOCK_DGRAM) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Default: construct an unbound, unconnected UDP socket</span></span><br><span class="line">    <span class="built_in">UDPSocket</span>() : <span class="built_in">Socket</span>(AF_INET, SOCK_DGRAM) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// carries received data and information about the sender</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">received_datagram</span> &#123;</span><br><span class="line">        Address source_address;  <span class="comment">//!&lt; Address from which this datagram was received</span></span><br><span class="line">        std::string payload;     <span class="comment">//!&lt; UDP datagram payload</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//! Receive a datagram and the Address of its sender</span></span><br><span class="line">    <span class="function">received_datagram <span class="title">recv</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> mtu = <span class="number">65536</span>)</span></span>;</span><br><span class="line">    <span class="comment">//! Receive a datagram and the Address of its sender (caller can allocate storage)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recv</span><span class="params">(received_datagram &amp;datagram, <span class="type">const</span> <span class="type">size_t</span> mtu = <span class="number">65536</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Send a datagram to specified Address</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendto</span><span class="params">(<span class="type">const</span> Address &amp;destination, <span class="type">const</span> BufferViewList &amp;payload)</span></span>;</span><br><span class="line">    <span class="comment">//! Send datagram to the socket&#x27;s connected address (must call connect() first)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> BufferViewList &amp;payload)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! A wrapper around [TCP sockets](\ref man7::tcp)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSocket</span> : <span class="keyword">public</span> Socket &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Construct from FileDescriptor (used by accept())</span></span><br><span class="line">    <span class="comment">// fd is the FileDescriptor from which to construct</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TCPSocket</span><span class="params">(FileDescriptor &amp;&amp;fd)</span> : Socket(std::move(fd), AF_INET, SOCK_STREAM) &#123;</span>&#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Default: construct an unbound, unconnected TCP socket</span></span><br><span class="line">    <span class="built_in">TCPSocket</span>() : <span class="built_in">Socket</span>(AF_INET, SOCK_STREAM) &#123;&#125;</span><br><span class="line">    <span class="comment">//! Mark a socket as listening for incoming connections</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">(<span class="type">const</span> <span class="type">int</span> backlog = <span class="number">16</span>)</span></span>;</span><br><span class="line">    <span class="comment">//! Accept a new incoming connection</span></span><br><span class="line">    <span class="function">TCPSocket <span class="title">accept</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! A wrapper around [Unix-domain stream sockets](\ref man7::unix)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LocalStreamSocket</span> : <span class="keyword">public</span> Socket &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...构造器</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// SPONGE_LIBSPONGE_SOCKET_HH</span></span></span><br></pre></td></tr></table></figure>

<h4 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="构造器的参数"><a href="#构造器的参数" class="headerlink" title="构造器的参数"></a>构造器的参数</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuxingen/article/details/44995467">参考文章</a></p>
<p>也是系统调用socket的参数，了解一下知识多多益善。</p>
<ol>
<li><p>domain</p>
<p>在本次实验中只会取值前两个，即本地通信和IPv4网络通信</p>
<p><img src="/2023/02/25/cs144/image-20230309232045195.png" alt="image-20230309232045195" loading="lazy"></p>
</li>
<li><p>type</p>
<p>好像比如说取<code>SOCK_DGRAM</code>就是UDP，取<code>SOCK_STREAM</code>就是TCP。</p>
</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Socket */</span></span><br><span class="line"><span class="comment">/* 构造器 */</span></span><br><span class="line"><span class="comment">// default constructor for socket of (subclassed) domain and type</span></span><br><span class="line">Socket::<span class="built_in">Socket</span>(<span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type) : <span class="built_in">FileDescriptor</span>(<span class="built_in">SystemCall</span>(<span class="string">&quot;socket&quot;</span>, <span class="built_in">socket</span>(domain, type, <span class="number">0</span>))) &#123;&#125;</span><br><span class="line"><span class="comment">// construct from file descriptor</span></span><br><span class="line">Socket::<span class="built_in">Socket</span>(FileDescriptor &amp;&amp;fd, <span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type) : <span class="built_in">FileDescriptor</span>(<span class="built_in">move</span>(fd)) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the local or peer address the socket is connected to</span></span><br><span class="line"><span class="comment">// 此为private函数，应该是用于方便下面那两个函数的，虽然我觉得这个设计意图没什么必要（）</span></span><br><span class="line"><span class="function">Address <span class="title">Socket::get_address</span><span class="params">(<span class="type">const</span> string &amp;name_of_function,<span class="type">const</span> function&lt;<span class="type">int</span>(<span class="type">int</span>, sockaddr *, <span class="type">socklen_t</span> *)&gt; &amp;function)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Address::Raw address;</span><br><span class="line">    <span class="type">socklen_t</span> size = <span class="built_in">sizeof</span>(address);</span><br><span class="line">	<span class="built_in">SystemCall</span>(name_of_function, <span class="built_in">function</span>(<span class="built_in">fd_num</span>(), address, &amp;size));</span><br><span class="line">    <span class="keyword">return</span> &#123;address, size&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Address <span class="title">Socket::local_address</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">get_address</span>(<span class="string">&quot;getsockname&quot;</span>, getsockname); &#125;</span><br><span class="line"><span class="function">Address <span class="title">Socket::peer_address</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">get_address</span>(<span class="string">&quot;getpeername&quot;</span>, getpeername); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">这两个函数是用于把socket连到CS的</span></span><br><span class="line"><span class="comment">将socket的一端连上本机，就需要调用bind；连上别的什么东西就要用connect</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// bind socket to a specified local address (usually to listen/accept)</span></span><br><span class="line"><span class="comment">// address is a local Address to bind</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::bind</span><span class="params">(<span class="type">const</span> Address &amp;address)</span> </span>&#123; <span class="built_in">SystemCall</span>(<span class="string">&quot;bind&quot;</span>, ::<span class="built_in">bind</span>(<span class="built_in">fd_num</span>(), address, address.<span class="built_in">size</span>())); &#125;</span><br><span class="line"><span class="comment">// connect socket to a specified peer address</span></span><br><span class="line"><span class="comment">// address is the peer&#x27;s Address</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::connect</span><span class="params">(<span class="type">const</span> Address &amp;address)</span> </span>&#123; <span class="built_in">SystemCall</span>(<span class="string">&quot;connect&quot;</span>, ::<span class="built_in">connect</span>(<span class="built_in">fd_num</span>(), address, address.<span class="built_in">size</span>())); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shut down a socket in the specified way</span></span><br><span class="line"><span class="comment">// how can be `SHUT_RD`, `SHUT_WR`, or `SHUT_RDWR`</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::shutdown</span><span class="params">(<span class="type">const</span> <span class="type">int</span> how)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SystemCall</span>(<span class="string">&quot;shutdown&quot;</span>, ::<span class="built_in">shutdown</span>(<span class="built_in">fd_num</span>(), how));</span><br><span class="line">    <span class="keyword">switch</span> (how) &#123;</span><br><span class="line">        <span class="keyword">case</span> SHUT_RD:</span><br><span class="line">            <span class="built_in">register_read</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set socket option，传入协议层以及要设置非选项的键和值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> option_type&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setsockopt</span><span class="params">(<span class="type">const</span> <span class="type">int</span> level, <span class="type">const</span> <span class="type">int</span> option, <span class="type">const</span> option_type &amp;option_value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SystemCall</span>(<span class="string">&quot;setsockopt&quot;</span>, ::<span class="built_in">setsockopt</span>(<span class="built_in">fd_num</span>(), level, option, &amp;option_value, <span class="built_in">sizeof</span>(option_value)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allow local address to be reused sooner, at the cost of some robustness</span></span><br><span class="line"><span class="comment">// 以鲁棒性为代价，让local address可复用</span></span><br><span class="line"><span class="comment">// Using `SO_REUSEADDR` may reduce the robustness of your application</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::set_reuseaddr</span><span class="params">()</span> </span>&#123; <span class="built_in">setsockopt</span>(SOL_SOCKET, SO_REUSEADDR, <span class="built_in">int</span>(<span class="literal">true</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UDPSocket */</span></span><br><span class="line"><span class="comment">// 从socket中接收数据并放进datagram中</span></span><br><span class="line"><span class="comment">// If mtu is too small to hold the received datagram, this method throws a runtime_error</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDPSocket::recv</span><span class="params">(received_datagram &amp;datagram, <span class="type">const</span> <span class="type">size_t</span> mtu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// receive source address and payload</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> recv_len = <span class="built_in">SystemCall</span>(</span><br><span class="line">        <span class="string">&quot;recvfrom&quot;</span>,</span><br><span class="line">        ::<span class="built_in">recvfrom</span>(</span><br><span class="line">            <span class="built_in">fd_num</span>(), datagram.payload.<span class="built_in">data</span>(), datagram.payload.<span class="built_in">size</span>(), MSG_TRUNC, datagram_source_address, &amp;fromlen));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UDPSocket::received_datagram <span class="title">UDPSocket::recv</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> mtu)</span> </span>&#123;</span><br><span class="line">    received_datagram ret&#123;&#123;<span class="literal">nullptr</span>, <span class="number">0</span>&#125;, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">recv</span>(ret, mtu);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向socket发送数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendmsg_helper</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd_num,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> sockaddr *destination_address,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="type">socklen_t</span> destination_address_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> BufferViewList &amp;payload)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> bytes_sent = <span class="built_in">SystemCall</span>(<span class="string">&quot;sendmsg&quot;</span>, ::<span class="built_in">sendmsg</span>(fd_num, &amp;message, <span class="number">0</span>));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDPSocket::sendto</span><span class="params">(<span class="type">const</span> Address &amp;destination, <span class="type">const</span> BufferViewList &amp;payload)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sendmsg_helper</span>(<span class="built_in">fd_num</span>(), destination, destination.<span class="built_in">size</span>(), payload);</span><br><span class="line">    <span class="built_in">register_write</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDPSocket::send</span><span class="params">(<span class="type">const</span> BufferViewList &amp;payload)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sendmsg_helper</span>(<span class="built_in">fd_num</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>, payload);</span><br><span class="line">    <span class="built_in">register_write</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="TCPSpongeSocket"><a href="#TCPSpongeSocket" class="headerlink" title="* TCPSpongeSocket"></a>* TCPSpongeSocket</h3><p>上面那俩类其实就是两个包装类，用来将系统调用包装为c++类，看起来很抽象很迷惑。<strong>但到这就不一样了！我们开始用上我们之前写的TCP协议的代码了！</strong></p>
<p>除了跟fd以及socket一致的<code>read</code>、<code>write</code>以及<code>close</code>之外，<code>TCPSocket</code>最独特的功能，应该就是TCP连接的建立与释放了，其状态转移等逻辑已由我们在Lab0-4实现，此socket类仅实现<u>事件的监听</u>和<u>TCP协议对象生命周期的管理</u>。</p>
<h4 id="双线程"><a href="#双线程" class="headerlink" title="双线程"></a>双线程</h4><p>在详细说明其两个功能——事件监听和生命周期管理——之前，不妨先了解下其总体的架构。</p>
<p><code>TCPSpongeSocket</code>需要双线程实现。其中一个线程用来招待其owner：它会执行向owner public的connect、read、write等服务。另一个线程用来运行<code>TCPConnection</code>：它会时刻调用connection的tick方法，并且进行事件监听。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \class TCPSpongeSocket</span></span><br><span class="line"><span class="comment">//! This class involves the simultaneous operation of two threads.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! One, the &quot;owner&quot; or foreground thread, interacts with this class in much the</span></span><br><span class="line"><span class="comment">//! same way as one would interact with a TCPSocket: it connects or listens, writes to</span></span><br><span class="line"><span class="comment">//! and reads from a reliable data stream, etc. Only the owner thread calls public</span></span><br><span class="line"><span class="comment">//! methods of this class.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! The other, the &quot;TCPConnection&quot; thread, takes care of the back-end tasks that the kernel would</span></span><br><span class="line"><span class="comment">//! perform for a TCPSocket: reading and parsing datagrams from the wire, filtering out</span></span><br><span class="line"><span class="comment">//! segments unrelated to the connection, etc.</span></span><br></pre></td></tr></table></figure>

<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>完成事件监听的核心部分是方法<code>_tcp_loop</code>以及<code>_initialize_TCP</code>中对<code>_eventloop</code>的初始化，还有<code>eventloop</code>的实现。</p>
<p>看下来其实理解难度不大（虽然细节很多并且我懒得研究了），但我认为很值得学习。</p>
<h5 id="initialize-TCP"><a href="#initialize-TCP" class="headerlink" title="_initialize_TCP"></a>_initialize_TCP</h5><p>主要功能是添加我们想监听的事件，有四个，分别是从app得到数据、有要向app发送的数据、从底层协议得到数据、有要向底层协议发送的数据。具体的话，代码和注释都写得很详细就不说了。</p>
<p>可以看到，TCP与协议栈交互【包括收发数据报】，是通过<code>AdaptT _datagram_adapter;</code>实现的；TCP与上层APP交互【包括传送数据】，是通过<code>LocalStreamSocket _thread_data;</code>实现的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::_initialize_TCP(<span class="type">const</span> TCPConfig &amp;config) &#123;</span><br><span class="line">    _tcp.<span class="built_in">emplace</span>(config);</span><br><span class="line">    <span class="comment">// Set up the event loop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are four possible events to handle:需要监听以下四种事件</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 1) Incoming datagram received (needs to be given to</span></span><br><span class="line">    <span class="comment">//    TCPConnection::segment_received method)得到底层协议栈送过来的data</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 2) Outbound bytes received from local application via a write()</span></span><br><span class="line">    <span class="comment">//    call (needs to be read from the local stream socket and</span></span><br><span class="line">    <span class="comment">//    given to TCPConnection::data_written method)得到上层app送过来的data</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 3) Incoming bytes reassembled by the TCPConnection</span></span><br><span class="line">    <span class="comment">//    (needs to be read from the inbound_stream and written</span></span><br><span class="line">    <span class="comment">//    to the local stream socket back to the application)TCP协议需要向app写入data</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 4) Outbound segment generated by TCP (needs to be</span></span><br><span class="line">    <span class="comment">//    given to underlying datagram socket)TCP需要向外界发送data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 1: read from filtered packet stream and dump into TCPConnection得到外界data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::In,</span><br><span class="line">                        [&amp;] &#123;</span><br><span class="line">                            <span class="keyword">auto</span> seg = _datagram_adapter.<span class="built_in">read</span>();</span><br><span class="line">                            <span class="keyword">if</span> (seg) &#123;</span><br><span class="line">                                _tcp-&gt;<span class="built_in">segment_received</span>(<span class="built_in">move</span>(seg.<span class="built_in">value</span>()));</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (_thread_data.<span class="built_in">eof</span>() <span class="keyword">and</span> _tcp.<span class="built_in">value</span>().<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> _fully_acked) &#123; _fully_acked = <span class="literal">true</span>; &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        [&amp;] &#123; <span class="keyword">return</span> _tcp-&gt;<span class="built_in">active</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 2: read from pipe into outbound buffer得到app data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">        <span class="comment">// LocalStreamSocket _thread_data;</span></span><br><span class="line">		<span class="comment">// 看来用户是通过socket写入的数据</span></span><br><span class="line">        _thread_data,</span><br><span class="line">        Direction::In,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> data = _thread_data.<span class="built_in">read</span>(_tcp-&gt;<span class="built_in">remaining_outbound_capacity</span>());</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> len = data.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> amount_written = _tcp-&gt;<span class="built_in">write</span>(<span class="built_in">move</span>(data));</span><br><span class="line">            <span class="keyword">if</span> (amount_written != len) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;TCPConnection::write() accepted less than advertised length&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (_thread_data.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">                _tcp-&gt;<span class="built_in">end_input_stream</span>();</span><br><span class="line">                _outbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        [&amp;] &#123; <span class="built_in">return</span> (_tcp-&gt;<span class="built_in">active</span>()) <span class="built_in">and</span> (<span class="keyword">not</span> _outbound_shutdown) <span class="built_in">and</span> (_tcp-&gt;<span class="built_in">remaining_outbound_capacity</span>() &gt; <span class="number">0</span>); &#125;,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            _tcp-&gt;<span class="built_in">end_input_stream</span>();</span><br><span class="line">            _outbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 3: read from inbound buffer into pipe向app写入data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">        _thread_data,</span><br><span class="line">        Direction::Out,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            ByteStream &amp;inbound = _tcp-&gt;<span class="built_in">inbound_stream</span>();</span><br><span class="line">            <span class="comment">// Write from the inbound_stream into the pipe</span></span><br><span class="line">            <span class="type">const</span> <span class="type">size_t</span> amount_to_write = <span class="built_in">min</span>(<span class="built_in">size_t</span>(<span class="number">65536</span>), inbound.<span class="built_in">buffer_size</span>());</span><br><span class="line">            <span class="type">const</span> std::string buffer = inbound.<span class="built_in">peek_output</span>(amount_to_write);</span><br><span class="line">            <span class="comment">// 通过向socket写实现</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> bytes_written = _thread_data.<span class="built_in">write</span>(<span class="built_in">move</span>(buffer), <span class="literal">false</span>);</span><br><span class="line">            inbound.<span class="built_in">pop_output</span>(bytes_written);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inbound.<span class="built_in">eof</span>() <span class="keyword">or</span> inbound.<span class="built_in">error</span>()) &#123;</span><br><span class="line">                _thread_data.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">                _inbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="keyword">not</span> _tcp-&gt;<span class="built_in">inbound_stream</span>().<span class="built_in">buffer_empty</span>()) <span class="built_in">or</span></span><br><span class="line">                   ((_tcp-&gt;<span class="built_in">inbound_stream</span>().<span class="built_in">eof</span>() <span class="keyword">or</span> _tcp-&gt;<span class="built_in">inbound_stream</span>().<span class="built_in">error</span>()) <span class="keyword">and</span> <span class="keyword">not</span> _inbound_shutdown);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 4: read outbound segments from TCPConnection and send as datagrams向外界写data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::Out,</span><br><span class="line">                        [&amp;] &#123;</span><br><span class="line">                            <span class="keyword">while</span> (<span class="keyword">not</span> _tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                                <span class="comment">// 通过对adapter写实现</span></span><br><span class="line">                                _datagram_adapter.<span class="built_in">write</span>(_tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">front</span>());</span><br><span class="line">                                _tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        [&amp;] &#123; <span class="keyword">return</span> <span class="keyword">not</span> _tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tcp-loop"><a href="#tcp-loop" class="headerlink" title="_tcp_loop"></a>_tcp_loop</h5><p>可以看到，<code>_tcp_loop</code>的功能就是，在<code>condition</code>为真的时候，一是监听我们之前塞进<code>_event_loop</code>的所有事件，二是调用<code>TCPConnection</code>的<code>tick</code>方法来管理时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// condition is a function returning true if loop should continue</span></span><br><span class="line"><span class="comment">// Process events while specified condition is true</span></span><br><span class="line"><span class="comment">// 周期性调用事件condition以达到监听等待事件的效果，管理TCP的tick</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::_tcp_loop(<span class="type">const</span> function&lt;<span class="built_in">bool</span>()&gt; &amp;condition) &#123;</span><br><span class="line">    <span class="keyword">auto</span> base_time = <span class="built_in">timestamp_ms</span>();</span><br><span class="line">    <span class="comment">// 当条件一直为真时，监听event</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">condition</span>()) &#123;</span><br><span class="line">        <span class="comment">// 持续监听eventloop中的各种event</span></span><br><span class="line">        <span class="keyword">auto</span> ret = _eventloop.<span class="built_in">wait_next_event</span>(TCP_TICK_MS);</span><br><span class="line">        <span class="comment">// 条件为退出/丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (ret == EventLoop::Result::Exit <span class="keyword">or</span> _abort) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果tcp还存活，则调用其tick方法</span></span><br><span class="line">        <span class="keyword">if</span> (_tcp.<span class="built_in">value</span>().<span class="built_in">active</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> next_time = <span class="built_in">timestamp_ms</span>();</span><br><span class="line">            _tcp.<span class="built_in">value</span>().<span class="built_in">tick</span>(next_time - base_time);</span><br><span class="line">            _datagram_adapter.<span class="built_in">tick</span>(next_time - base_time);</span><br><span class="line">            base_time = next_time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="eventloop"><a href="#eventloop" class="headerlink" title="eventloop"></a>eventloop</h5><p>eventloop具体是通过Linux提供的poll机制来进行事件监听的。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_49328056/article/details/123454707">Linux poll机制</a></p>
<p>怎么说，又一次感受到了“<strong>网络就是IO</strong>”这个抽象的牛逼之处。操作系统的poll机制和poll函数本质上是针对IO读写来设计的，而正因为网络的本质是IO，正因为网络收发数据包、与上层app交互本质还是IO（因为通过文件描述符），才能在这里采用这种方式进行文件读写。</p>
<p>我的评价是佩服到五体投地好吧</p>
<p><img src="/2023/02/25/cs144/image-20230310185319115.png" alt="image-20230310185319115" loading="lazy"></p>
<p><strong>poll函数就是IO等待的一种实现机制。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>事件类型events可以为下列值：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POLLIN</span>:<span class="string">有数据可读</span></span><br><span class="line"><span class="attr">POLLRDNORM</span>:<span class="string">有普通数据可读，等效于POLLIN</span></span><br><span class="line"><span class="attr">POLLRDBAND</span>:<span class="string">有优先数据可读</span></span><br><span class="line"><span class="attr">POLLPRI</span>:<span class="string">有紧迫数据可读</span></span><br><span class="line"><span class="attr">POLLOUT</span>:<span class="string">写数据不会导致阻塞</span></span><br><span class="line"><span class="attr">POLLWRNORM</span>:<span class="string">写普通数据不会导致阻塞</span></span><br><span class="line"><span class="attr">POLLWRBAND</span>:<span class="string">写优先数据不会导致阻塞</span></span><br><span class="line"><span class="attr">POLLMSG</span>:<span class="string">SIGPOLL消息可用</span></span><br><span class="line"><span class="attr">POLLER</span>:<span class="string">指定的文件描述符发生错误</span></span><br><span class="line"><span class="attr">POLLHUP</span>:<span class="string">指定的文件描述符挂起事件</span></span><br><span class="line"><span class="attr">POLLNVAL</span>:<span class="string">无效的请求，打不开指定的文件描述符</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们在前面的eventloop的rule初始化中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::In,</span><br><span class="line">                        [&amp;] &#123; ... &#125;);</span><br></pre></td></tr></table></figure>

<p>这个的意思是针对<code>_datagram_adapter</code>这个文件的<code>Direction::In</code>这个事件发生时，就会执行<code>[&amp;]</code>中的事件。那么<code>Direction::In</code>是什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Direction</span> : <span class="type">short</span> &#123;</span><br><span class="line">    In = POLLIN,   <span class="comment">//!&lt; Callback will be triggered when Rule::fd is readable.</span></span><br><span class="line">    Out = POLLOUT  <span class="comment">//!&lt; Callback will be triggered when Rule::fd is writable.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见，eventloop具体是通过os提供的IO事件机制来进行监听的。</p>
<p>具体的监听以及执行逻辑由<code>wait_next_event</code>来实现。它主要干的就是，清理掉那些我们不感兴趣的或者已经似了（比如说对应的fd已经close之类的）的事件，然后找到那些触发到了的active的事件并且调用它们的caller。</p>
<p>具体代码还是有些微复杂的，有兴趣可以去看看，这里就不放了。</p>
<h4 id="生命周期的管理"><a href="#生命周期的管理" class="headerlink" title="生命周期的管理"></a>生命周期的管理</h4><p>核心部分为方法<code>connect</code>、<code>listen_and_accept</code>以及<code>_tcp_main</code>。</p>
<h5 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h5><p>由客户端调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client调用</span></span><br><span class="line"><span class="comment">// 未收到外界连接时，owner进程会阻塞</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::<span class="built_in">connect</span>(<span class="type">const</span> TCPConfig &amp;c_tcp, <span class="type">const</span> FdAdapterConfig &amp;c_ad) &#123;</span><br><span class="line">    <span class="comment">// 初始化tcp的事件监听</span></span><br><span class="line">    _initialize_TCP(c_tcp);</span><br><span class="line">    <span class="comment">// 初始化adapater</span></span><br><span class="line">    _datagram_adapter.<span class="built_in">config_mut</span>() = c_ad;</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: Connecting to &quot;</span> &lt;&lt; c_ad.destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;...\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 我们实现的：发送SYN报文</span></span><br><span class="line">    _tcp-&gt;<span class="built_in">connect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一的状态管理</span></span><br><span class="line">    <span class="type">const</span> TCPState expected_state = TCPState::State::SYN_SENT;</span><br><span class="line">    <span class="comment">// 等待直到条件为假，也即脱离SYN-SENT转移到ESTABLISHED</span></span><br><span class="line">    _tcp_loop([&amp;] &#123; <span class="keyword">return</span> _tcp-&gt;<span class="built_in">state</span>() == TCPState::State::SYN_SENT; &#125;);</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Successfully connected to &quot;</span> &lt;&lt; c_ad.destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立连接后开启connection进程, 执行_tcp_main，继续监听event直到死亡</span></span><br><span class="line">    _tcp_thread = <span class="built_in">thread</span>(&amp;TCPSpongeSocket::_tcp_main, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tcp-main"><a href="#tcp-main" class="headerlink" title="_tcp_main"></a>_tcp_main</h5><p>负责establish状态的监听以及之后关闭TCP连接的擦屁股工作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::_tcp_main() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> _tcp.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;no TCP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 持续监听直到死亡</span></span><br><span class="line">        _tcp_loop([] &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br><span class="line">        <span class="built_in">shutdown</span>(SHUT_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> _tcp.<span class="built_in">value</span>().<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;DEBUG: TCP connection finished &quot;</span></span><br><span class="line">                 &lt;&lt; (_tcp.<span class="built_in">value</span>().<span class="built_in">state</span>() == TCPState::State::RESET ? <span class="string">&quot;uncleanly&quot;</span> : <span class="string">&quot;cleanly.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _tcp.<span class="built_in">reset</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Exception in TCPConnection runner thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="listen-and-accept"><a href="#listen-and-accept" class="headerlink" title="listen_and_accept"></a>listen_and_accept</h5><p>由服务器端调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server调用</span></span><br><span class="line"><span class="comment">// 未收到外界连接时，owner进程会阻塞</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::<span class="built_in">listen_and_accept</span>(<span class="type">const</span> TCPConfig &amp;c_tcp, <span class="type">const</span> FdAdapterConfig &amp;c_ad) &#123;</span><br><span class="line">     _initialize_TCP(c_tcp);</span><br><span class="line">    _datagram_adapter.<span class="built_in">config_mut</span>() = c_ad;</span><br><span class="line">    </span><br><span class="line">    _datagram_adapter.<span class="built_in">set_listening</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: Listening for incoming connection...\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 等待直到ESTABLISHED。注意下这里的状态条件</span></span><br><span class="line">    <span class="comment">// 其中各种收发报文的事件由tcp_loop中的event做</span></span><br><span class="line">    _tcp_loop([&amp;] &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> s = _tcp-&gt;<span class="built_in">state</span>();</span><br><span class="line">        <span class="built_in">return</span> (s == TCPState::State::LISTEN <span class="keyword">or</span> s == TCPState::State::SYN_RCVD <span class="keyword">or</span> s == TCPState::State::SYN_SENT);</span><br><span class="line">    &#125;);</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;New connection from &quot;</span> &lt;&lt; _datagram_adapter.<span class="built_in">config</span>().destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启connection进程</span></span><br><span class="line">    _tcp_thread = <span class="built_in">thread</span>(&amp;TCPSpongeSocket::_tcp_main, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CS144TCPSocket-和-FullStackSocket"><a href="#CS144TCPSocket-和-FullStackSocket" class="headerlink" title="CS144TCPSocket 和 FullStackSocket"></a>CS144TCPSocket 和 FullStackSocket</h3><p>主菜（上面那个）已经说完了，这两个就是简单的包装类，没什么好说的，大概就做了点传参工作，主要差异还是adapter。</p>
<h3 id="Adapter实现"><a href="#Adapter实现" class="headerlink" title="Adapter实现"></a>Adapter实现</h3><p>在我们的<code>TCPSpongeSocket</code>实现中，我们引入了“adapter”的概念。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//! Adapter to underlying datagram socket (e.g., UDP or IP)</span></span><br><span class="line">    AdaptT _datagram_adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> TCPOverUDPSpongeSocket = TCPSpongeSocket&lt;TCPOverUDPSocketAdapter&gt;;</span><br><span class="line"><span class="keyword">using</span> TCPOverIPv4SpongeSocket = TCPSpongeSocket&lt;TCPOverIPv4OverTunFdAdapter&gt;;</span><br><span class="line"><span class="keyword">using</span> TCPOverIPv4OverEthernetSpongeSocket = TCPSpongeSocket&lt;TCPOverIPv4OverEthernetAdapter&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LossyTCPOverUDPSpongeSocket = TCPSpongeSocket&lt;LossyTCPOverUDPSocketAdapter&gt;;</span><br><span class="line"><span class="keyword">using</span> LossyTCPOverIPv4SpongeSocket = TCPSpongeSocket&lt;LossyTCPOverIPv4OverTunFdAdapter&gt;;</span><br></pre></td></tr></table></figure>

<p>它很完美地以策略模式的形式，凝结出了我们本次实验所需的各种协议栈的共同代码，放进了<code>TCPSpongeSocket</code>，而将涉及到协议栈差异的部分用adapter完成。</p>
<p>在<code>TCPSpongeSocket</code>中，adapter主要完成了如下操作：</p>
<ol>
<li><p>adapter的tick函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in tcp_loop</span></span><br><span class="line">_tcp.<span class="built_in">value</span>().<span class="built_in">tick</span>(next_time - base_time);</span><br><span class="line">_datagram_adapter.<span class="built_in">tick</span>(next_time - base_time);</span><br></pre></td></tr></table></figure></li>
<li><p>作为订阅事件的IO流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::In,</span><br><span class="line">                        [&amp;] &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li>
<li><p>TCP层通过对其读写来获取TCP segment</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto seg = _datagram_adapter.read();</span><br><span class="line">_datagram_adapter.write(_tcp-&gt;segments_out().front());</span><br></pre></td></tr></table></figure></li>
<li><p>记录各类参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datagram_adapter.<span class="built_in">config</span>().destination.<span class="built_in">to_string</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/2023/02/25/cs144/class_fd_adapter_base__inherit__graph.png" alt="Inheritance graph" loading="lazy"></p>
<p>具体实现说实话没什么好说的，确实无非也就是上面那几个方法，然后在里面包装下和操作系统提供的tun和tap的接口交互罢了，代码也比较简单，此处就不说了。</p>
<h2 id="apps"><a href="#apps" class="headerlink" title="apps"></a>apps</h2><p>除了对协议栈的实现之外，在app文件夹下还有许多对我们实现的协议栈的应用实例。我认为了解下应用实例也是很重要的。</p>
<h3 id="bidirectional-stream-copy"><a href="#bidirectional-stream-copy" class="headerlink" title="bidirectional_stream_copy"></a>bidirectional_stream_copy</h3><p>其作用就是建立stdin/stdout与socket的关联。它从stdin读输入，作为上层app的输入写入socket；从socket读输出，传给上层app，也即stdout输出。它的具体实现在stdin/stdout之间隔了两条bytestream，分别是<code>_inbound</code>和<code>_outbound</code>。</p>
<p>由于stdin、stdout、socket本质上都是fd，所以我们依然可以采用跟上面一样的事件驱动方式。我们只需在socket有输出时马上读给inbound bytestream，在inbound bytestream有输入时马上读给stdout，在stdin有输入时马上写入outbound bytestream，在outbound bytestream有输入时马上读给socket。遵守这4条rule就行了。</p>
<p>因而，具体实现就是<code>TCPSpongeSocket::_initialize_TCP</code>和<code>TCPSpongeSocket::_tcp_loop</code>的结合体，订阅事件+循环等待。由于跟前面类似，在此就不放代码了。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他都太复杂了，感觉我水平一般还不大能理解，也懒得看了【草】总之先咕咕咕</p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>修年</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://xiunianjun.github.io/2023/02/25/cs144$else/" title="其他的对实验未涉及的思考">https://xiunianjun.github.io/2023/02/25/cs144$else/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2023/03/13/cmu15445/" rel="prev" title="CMU15445"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">CMU15445</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2023/02/25/cs144/" rel="next" title="cs144"><span class="post-nav-text">cs144</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> 修年</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.2</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>