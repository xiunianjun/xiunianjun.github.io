<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="修年">





<title>计算机组成原理 | 修年</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiunian&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiunian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc" style="right: -4em;">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">计算机组成原理</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">修年</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">六月 21, 2023&nbsp;&nbsp;19:09:29</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="冯诺依曼"><a href="#冯诺依曼" class="headerlink" title="冯诺依曼"></a>冯诺依曼</h3><p>以运算器为中心，指令和数据同等地位（不满足摩尔定律）</p>
<p><img src="/2023/06/21/comporgan/image-20230617133555268.png" alt="image-20230617133555268"></p>
<h3 id="存储器为中心"><a href="#存储器为中心" class="headerlink" title="存储器为中心"></a>存储器为中心</h3><p><img src="/2023/06/21/comporgan/image-20230617133840406.png" alt="image-20230617133840406"></p>
<h3 id="哈佛架构"><a href="#哈佛架构" class="headerlink" title="哈佛架构"></a>哈佛架构</h3><p>哈佛结构<strong>数据空间和程序空间是分开的</strong></p>
<p><strong>大部分ROM操作部分是采用了冯诺依曼结构</strong>，</p>
<p>有些需要CPU与ROM之间快速的响应和交互，采用的是<strong>5级流水的哈佛结构。</strong></p>
<p>早期（如X86）采用冯诺依曼</p>
<p>DSP和ARM用改进哈佛</p>
<p><img src="/2023/06/21/comporgan/image-20230617134010940.png" alt="image-20230617134010940"></p>
<h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><p><img src="/2023/06/21/comporgan/image-20230617134045099.png" alt="image-20230617134045099"></p>
<h1 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h1><h2 id="数的表示"><a href="#数的表示" class="headerlink" title="数的表示"></a>数的表示</h2><h3 id="无符号数与有符号数"><a href="#无符号数与有符号数" class="headerlink" title="无符号数与有符号数"></a>无符号数与有符号数</h3><h4 id="机器数与真值"><a href="#机器数与真值" class="headerlink" title="机器数与真值"></a>机器数与真值</h4><p><img src="/2023/06/21/comporgan/image-20230619211124996.png" alt="image-20230619211124996"></p>
<p>意思就是真值有±符号，机器数把±符号换成了数字罢了</p>
<h4 id="原码-补码-反码-移码"><a href="#原码-补码-反码-移码" class="headerlink" title="原码/补码/反码/移码"></a>原码/补码/反码/移码</h4><p><img src="/2023/06/21/comporgan/image-20230617142534411.png" alt="image-20230617142534411"></p>
<h5 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h5><p>整数用逗号隔开，小数用小数点隔开</p>
<h6 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h6><p><img src="/2023/06/21/comporgan/image-20230617140847726.png" alt="image-20230617140847726"></p>
<h6 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h6><p><img src="/2023/06/21/comporgan/image-20230617140920563.png" alt="image-20230617140920563"></p>
<h6 id="注意0的特殊情况"><a href="#注意0的特殊情况" class="headerlink" title="注意0的特殊情况"></a>注意0的特殊情况</h6><p><img src="/2023/06/21/comporgan/image-20230617141011120.png" alt="image-20230617141011120"></p>
<h5 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h5><blockquote>
<p>对于负数，原码-&gt;补码符号位不变，数值位按位取反再加一的理论由来。神奇的是对于补码-&gt;原码，也是按位取反再加一。</p>
<p>简单证明一下：</p>
<p>设x为补码，y为原码，n为位数</p>
<p>已知 x = !(y - 2^n) +1</p>
<p>则反转一下可得 y = !(x - 1) + 2^n</p>
</blockquote>
<p>符号位不变，按位取反再加一</p>
<h6 id="整数-1"><a href="#整数-1" class="headerlink" title="整数"></a>整数</h6><p><img src="/2023/06/21/comporgan/image-20230617141209384.png" alt="image-20230617141209384"></p>
<h6 id="小数-1"><a href="#小数-1" class="headerlink" title="小数"></a>小数</h6><p><img src="/2023/06/21/comporgan/image-20230617141232325.png" alt="image-20230617141232325"></p>
<h6 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h6><p><strong>[y]补</strong><u>连同符号位在内</u>，每位取反末位加1，即得**[-y]补**</p>
<p>后面那三个是真的抽象</p>
<p><img src="/2023/06/21/comporgan/image-20230617141627719.png" alt="image-20230617141627719"></p>
<h5 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h5><p>对于正数，反码和原码一致；</p>
<p>对于负数，反码为原码的数值位取反</p>
<h6 id="整数-2"><a href="#整数-2" class="headerlink" title="整数"></a>整数</h6><p><img src="/2023/06/21/comporgan/image-20230617141351461.png" alt="image-20230617141351461"></p>
<h6 id="小数-2"><a href="#小数-2" class="headerlink" title="小数"></a>小数</h6><p><img src="/2023/06/21/comporgan/image-20230617141418617.png" alt="image-20230617141418617"></p>
<h6 id="0"><a href="#0" class="headerlink" title="0"></a>0</h6><p><img src="/2023/06/21/comporgan/image-20230617141525918.png" alt="image-20230617141525918"></p>
<h5 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h5><blockquote>
<p>注意，移码只有整数形式的定义，这与它的用途有关。计算机中，移码通常用来标识浮点数的阶码【阶码是整数】。</p>
</blockquote>
<p>与补码数值位计算方式相同，区别是符号位相反</p>
<p><img src="/2023/06/21/comporgan/image-20230617142858076.png" alt="image-20230617142858076"></p>
<p><img src="/2023/06/21/comporgan/image-20230617145309340.png" alt="image-20230617145309340"></p>
<p>注意，移码的0为100000，最小值为000000</p>
<h3 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h3><h4 id="表示形式和范围"><a href="#表示形式和范围" class="headerlink" title="表示形式和范围"></a>表示形式和范围</h4><p><img src="/2023/06/21/comporgan/image-20230617143220170.png" alt="image-20230617143220170"></p>
<p>注意，这边的上溢和下溢只与阶码有关，与尾数无关。</p>
<p>这个溢出条件及其处理方式需要记，会考</p>
<p><img src="/2023/06/21/comporgan/image-20230617143328674.png" alt="image-20230617143328674"></p>
<h4 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h4><p><img src="/2023/06/21/comporgan/image-20230617143654003.png" alt="image-20230617143654003"></p>
<h5 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h5><p><img src="/2023/06/21/comporgan/image-20230617143731873.png" alt="image-20230617143731873"></p>
<h5 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h5><p><img src="/2023/06/21/comporgan/image-20230617143912465.png" alt="image-20230617143912465"></p>
<p><img src="/2023/06/21/comporgan/image-20230617145251169.png" alt="image-20230617145251169"></p>
<h5 id="题型-表示范围"><a href="#题型-表示范围" class="headerlink" title="题型 表示范围"></a>题型 表示范围</h5><p><img src="/2023/06/21/comporgan/image-20230617145826541.png" alt="image-20230617145826541"></p>
<p>看得我cpu快烧了</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7b9dd240685c">https://www.jianshu.com/p/7b9dd240685c</a></p>
<p><img src="/2023/06/21/comporgan/image-20230617145857698.png" alt="image-20230617145857698"></p>
<p>之所以最小负数不一样，是因为原码不能表示-1，补码可以；</p>
<p>之所以规格化最大负数是那玩意，是因为最大负数本应为2^-8，为了规格化必须再加个2^-1，然后原码转补码就变成那样了</p>
</blockquote>
<h3 id="IEEE754标准"><a href="#IEEE754标准" class="headerlink" title="IEEE754标准"></a>IEEE754标准</h3><p>难绷，最沙比的来了</p>
<p><img src="/2023/06/21/comporgan/image-20230617150024955.png" alt="image-20230617150024955"></p>
<p>没有阶符和数符力</p>
<p><img src="/2023/06/21/comporgan/image-20230617150101092.png" alt="image-20230617150101092"></p>
<p><img src="/2023/06/21/comporgan/image-20230617150816446.png" alt="image-20230617150816446"></p>
<p>它就相当于指数是移码表示的，并且注意到一点就是指数的0和255被征用表示特殊的数了，所以指数范围为1-254</p>
<p><img src="/2023/06/21/comporgan/image-20230617151013979.png" alt="image-20230617151013979"></p>
<h4 id="题型-把数转化为IEEE754"><a href="#题型-把数转化为IEEE754" class="headerlink" title="题型 把数转化为IEEE754"></a>题型 把数转化为IEEE754</h4><p>首先背一下上面那个数的范围图，然后判断下是规格化还是非规格化，然后套公式就行了</p>
<p><img src="/2023/06/21/comporgan/image-20230617152014370.png" alt="image-20230617152014370"></p>
<p><img src="/2023/06/21/comporgan/image-20230617152309065.png" alt="image-20230617152309065"></p>
<h3 id="算术移位与逻辑移位"><a href="#算术移位与逻辑移位" class="headerlink" title="算术移位与逻辑移位"></a>算术移位与逻辑移位</h3><blockquote>
<p>来自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34283722/article/details/107093193">https://blog.csdn.net/qq_34283722/article/details/107093193</a> ：</p>
<p><img src="/2023/06/21/comporgan/wps1-1687348655099-311.jpg" alt="img"> </p>
<p>这应该与补码的运算机制有关。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230617152527973.png" alt="image-20230617152527973"></p>
<p>反码不论是左还是右都添1</p>
<p><img src="/2023/06/21/comporgan/image-20230617152938114.png" alt="image-20230617152938114"></p>
<p>注意，符号位不变！！！这点在左移的时候需要尤其注意，很容易出错</p>
<h2 id="RISC-V概述"><a href="#RISC-V概述" class="headerlink" title="RISC-V概述"></a>RISC-V概述</h2><h3 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h3><p>ISA位宽：通用寄存器的宽度，决定了寻址范围大小、数据运算强弱。</p>
<h4 id="CISC-RISC"><a href="#CISC-RISC" class="headerlink" title="CISC-RISC"></a>CISC-RISC</h4><p><img src="/2023/06/21/comporgan/image-20230619211742901.png" alt="image-20230619211742901"></p>
<h4 id="X86-amp-MIPS"><a href="#X86-amp-MIPS" class="headerlink" title="X86 &amp; MIPS"></a>X86 &amp; MIPS</h4><p>相比于上述的差异，还有以下几个：</p>
<ol>
<li>x86有8个通用寄存器，MIPS有32个</li>
<li>x86有标志寄存器，MIPS没有</li>
<li>x86为两地址指令，MIPS为三地址</li>
<li>x86有堆栈指令，MIPS没有</li>
<li>x86有IO指令，MIPS设备统一编址</li>
<li>x86函数参数只用栈帧，MIPS用4寄存器+栈帧</li>
<li><strong>X86的字为2字节，MIPS/RISC-V的字为4字节</strong></li>
</ol>
<h3 id="RISC-V的特点"><a href="#RISC-V的特点" class="headerlink" title="RISC-V的特点"></a>RISC-V的特点</h3><ol>
<li><p><strong>RISC-V是小端，也即低字节放在低地址</strong></p>
</li>
<li><p>支持<strong>字节（8位）、半字（16位）、字（32位）、双字（64位，64位架构）</strong>的数据传输</p>
<p>主存按照字节进行编址</p>
</li>
<li><p>采用<strong>哈佛结构</strong></p>
</li>
<li><p>三种特权模式</p>
<p><img src="/2023/06/21/comporgan/image-20230617155657577.png" alt="image-20230617155657577"></p>
</li>
<li><p>模块化设计</p>
<p><img src="/2023/06/21/comporgan/image-20230617155224429.png" alt="image-20230617155224429"></p>
</li>
</ol>
<h2 id="RISC-V汇编语言"><a href="#RISC-V汇编语言" class="headerlink" title="RISC-V汇编语言"></a>RISC-V汇编语言</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><img src="/2023/06/21/comporgan/image-20230619212236116.png" alt="image-20230619212236116"></p>
<p><img src="/2023/06/21/comporgan/image-20230617194244388.png" alt="image-20230617194244388"></p>
<p>x3的全局指的是全局的静态数据区</p>
<h3 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h3><p><img src="/2023/06/21/comporgan/image-20230617160729611.png" alt="image-20230617160729611"></p>
<h4 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h4><p>RISC-V 忽略溢出问题，<strong>高位被截断</strong>，低位写入目标寄存器</p>
<p>如果想要保留乘法所有位：</p>
<p><img src="/2023/06/21/comporgan/image-20230617183814367.png" alt="image-20230617183814367"></p>
<p><img src="/2023/06/21/comporgan/image-20230617183924758.png" alt="image-20230617183924758"></p>
<p><img src="/2023/06/21/comporgan/image-20230617184010487.png" alt="image-20230617184010487"></p>
<h4 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h4><p><img src="/2023/06/21/comporgan/image-20230617184151843.png" alt="image-20230617184151843"></p>
<h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><p><img src="/2023/06/21/comporgan/image-20230617185225785.png" alt="image-20230617185225785"></p>
<p>shift left logical，shift left arithmetic</p>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>ld/sd，lw/sw，lh/sh（半字，也即2字节），lb/sb，以及load指令对应的无符号数（+后缀u）版本。</p>
<p><strong>bAddrReg+offset为4的倍数，数据传输指令除了字节指令（lb sb lbu）外都需要按字对齐。</strong></p>
<p>注意，如果为有符号数取数，放入寄存器时会<strong>自动进行符号扩展</strong>。</p>
<p><img src="/2023/06/21/comporgan/image-20230617191543433.png" alt="image-20230617191543433"></p>
<h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><p><img src="/2023/06/21/comporgan/image-20230617192731684.png" alt="image-20230617192731684"></p>
<h4 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h4><p><img src="/2023/06/21/comporgan/image-20230617193045409.png" alt="image-20230617193045409"></p>
<h4 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h4><p><img src="/2023/06/21/comporgan/image-20230617193346852.png" alt="image-20230617193346852"></p>
<p>j：+label，用于实现无条件跳转，使用相对于当前 PC（程序计数器）的<strong>偏移量</strong>来计算目标地址，跳转范围较广</p>
<p>jr：+寄存器，用于实现通过寄存器的值进行跳转，跳转的目标是存储在寄存器中的地址，<strong>而不是</strong>相对于 PC 的偏移量</p>
<h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h4><p><img src="/2023/06/21/comporgan/image-20230617193450180.png" alt="image-20230617193450180"></p>
<p><img src="/2023/06/21/comporgan/image-20230617193521343.png" alt="image-20230617193521343"></p>
<h3 id="函数调用及栈的使用"><a href="#函数调用及栈的使用" class="headerlink" title="函数调用及栈的使用"></a>函数调用及栈的使用</h3><p><img src="/2023/06/21/comporgan/image-20230617195109547.png" alt="image-20230617195109547"></p>
<h3 id="六种指令格式"><a href="#六种指令格式" class="headerlink" title="六种指令格式"></a>六种指令格式</h3><p><img src="/2023/06/21/comporgan/image-20230617213801145.png" alt="image-20230617213801145"></p>
<p>注意，<strong>jalr属于I型指令</strong>，而非J型指令！！！</p>
<p><img src="/2023/06/21/comporgan/image-20230617213815058.png" alt="image-20230617213815058"></p>
<p><img src="/2023/06/21/comporgan/image-20230620164851924.png" alt="image-20230620164851924"></p>
<h4 id="R型指令"><a href="#R型指令" class="headerlink" title="R型指令"></a>R型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617214018489.png" alt="image-20230617214018489"></p>
<p><img src="/2023/06/21/comporgan/image-20230617214139338.png" alt="image-20230617214139338"></p>
<h4 id="I型指令"><a href="#I型指令" class="headerlink" title="I型指令"></a>I型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617214544561.png" alt="image-20230617214544561"></p>
<p><img src="/2023/06/21/comporgan/image-20230617214659517.png" alt="image-20230617214659517"></p>
<p><img src="/2023/06/21/comporgan/image-20230617214735023.png" alt="image-20230617214735023"></p>
<h5 id="特例1-load"><a href="#特例1-load" class="headerlink" title="特例1 load"></a>特例1 load</h5><p><img src="/2023/06/21/comporgan/image-20230617215007481.png" alt="image-20230617215007481"></p>
<h5 id="特例2-jalr"><a href="#特例2-jalr" class="headerlink" title="特例2 jalr"></a>特例2 jalr</h5><p><img src="/2023/06/21/comporgan/image-20230617215304022.png" alt="image-20230617215304022"></p>
<p>注意，jalr也属于I型指令，且<strong>其funct3为0</strong></p>
<h4 id="S型指令"><a href="#S型指令" class="headerlink" title="S型指令"></a>S型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617215730749.png" alt="image-20230617215730749"></p>
<p><img src="/2023/06/21/comporgan/image-20230617215842401.png" alt="image-20230617215842401"></p>
<h4 id="B型指令"><a href="#B型指令" class="headerlink" title="B型指令"></a>B型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617220521906.png" alt="image-20230617220521906"></p>
<p>这个计算过程很值得注意</p>
<p><img src="/2023/06/21/comporgan/image-20230617220833542.png" alt="image-20230617220833542"></p>
<p><img src="/2023/06/21/comporgan/image-20230617220903564.png" alt="image-20230617220903564"></p>
<p><img src="/2023/06/21/comporgan/image-20230617221131122.png" alt="image-20230617221131122"></p>
<h4 id="U型指令"><a href="#U型指令" class="headerlink" title="U型指令"></a>U型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617221220495.png" alt="image-20230617221220495"></p>
<p><img src="/2023/06/21/comporgan/image-20230617221323268.png" alt="image-20230617221323268"></p>
<p><img src="/2023/06/21/comporgan/image-20230617221508473.png" alt="image-20230617221508473"></p>
<p>666</p>
<h4 id="J型指令"><a href="#J型指令" class="headerlink" title="J型指令"></a>J型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617222154873.png" alt="image-20230617222154873"></p>
<h2 id="寻址方式（x86）"><a href="#寻址方式（x86）" class="headerlink" title="寻址方式（x86）"></a>寻址方式（x86）</h2><blockquote>
<p><img src="/2023/06/21/comporgan/wps4-1687349010620-334.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps5-1687349010620-335.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps6-1687349010620-336.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps7-1687349010621-337.jpg" alt="img"><img src="/2023/06/21/comporgan/wps8-1687349010621-338.jpg" alt="img"> </p>
<p>尽管A很小，但可以让EA很大，从而扩展寻址范围。同时相对于上面的直接寻址，它更容易编程，因为只用修改A存储的那个地址值，而不用修改指令【比如说对数组进行循环，这个间接寻址就只用A++就行，而不用去修改指令里的那个“A”。】。</p>
<p>That is 指针【】</p>
<p><img src="/2023/06/21/comporgan/wps9-1687349010621-339.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps10-1687349010621-340.jpg" alt="img">至于为啥间接寻址不便于循环，也许是因为间接寻址是访存两次比较慢，要是真用来循环还了得</p>
<p><img src="/2023/06/21/comporgan/wps11-1687349010621-341.jpg" alt="img"><img src="/2023/06/21/comporgan/wps12-1687349010621-342.jpg" alt="img"> </p>
<p>程序动态定位</p>
<p><img src="/2023/06/21/comporgan/wps13-1687349010621-343.jpg" alt="img">循环数组时，可以用A作为数组地址，IX作为数组下标？？？【为什么不能用基址寻址？】</p>
<p>应该是因为基址寻址的基址是系统内定的，数组循环问题需要用户指定数组起始地址，所以不能用基址寻址，只能用面向用户的变址寻址。</p>
<p><img src="/2023/06/21/comporgan/wps14-1687349010621-344.jpg" alt="img">区别就在于直接寻址直接把指令参数****硬编码在内存****中，非常耗费空间。变址寻址则把指令参数作为变量了。</p>
<p><img src="/2023/06/21/comporgan/wps15-1687349010621-345.jpg" alt="img">更应该像是指令寻址方式。</p>
<p>程序浮动：程序在内存单元的位置出现变化【毕竟不可能同一个程序在每台电脑都是在同一个物理地址，相当于又减少了硬编码】</p>
<p><img src="/2023/06/21/comporgan/wps16.jpg" alt="img"><img src="/2023/06/21/comporgan/wps17.jpg" alt="img">【为2002H是因为假设字长为2byte】</p>
<p><img src="/2023/06/21/comporgan/wps18.jpg" alt="img"><img src="/2023/06/21/comporgan/wps19.jpg" alt="img"> </p>
<p>一般栈顶地址最低。 </p>
</blockquote>
<h1 id="运算方法"><a href="#运算方法" class="headerlink" title="运算方法"></a>运算方法</h1><h2 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h2><h3 id="一位乘法运算"><a href="#一位乘法运算" class="headerlink" title="一位乘法运算"></a>一位乘法运算</h3><h4 id="原码一位乘"><a href="#原码一位乘" class="headerlink" title="原码一位乘"></a>原码一位乘</h4><blockquote>
<p><img src="/2023/06/21/comporgan/image-20230621195833297.png" alt="image-20230621195833297"></p>
<p>大致明白了：</p>
<p>①乘积一共有四位，故而需要两个寄存器来保存。</p>
<p>②按照上面的原理公式，每次右移一位，被移出的那一位也是最后的结果（相当于竖式中每次相加的最后一位），需要把它存储在另一个寄存器中。</p>
<p>③我们选择了存乘数的寄存器，因为乘数已经乘过的位是没用的。存乘数的那个寄存器的乘数不断被结果的低位所替代。</p>
<p>故****基本流程****：</p>
<p>①准备阶段：清零ACC【置部分积=0】，在MQ中放乘数，X中放被乘数</p>
<p>②判断MQ中乘数最低位，若为1，则ACC部分积加上X中的被乘数；若为0，则ACC不变</p>
<p>③将ACC和MQ中四位数字视作一个整体，符号位也算上，进行逻辑右移，左侧补0.</p>
<p>④重复上述过程，按移位次数来控制结束。</p>
<p>⑤则最后，ACC中存储的就是乘法结果的高位，MQ中存储的结果就是乘法中的低位。</p>
<p>这其实就是我们用的列竖式一行一行加起来的一个过程。</p>
<p><img src="/2023/06/21/comporgan/wps2-1687348739116-313.jpg" alt="img"></p>
<p>S是符号位，GM是乘法标志位。</p>
<p>控制门：当最后一位是1时，控制门打开，X中的被乘数进入加法器。</p>
</blockquote>
<ol>
<li><p>部分积  乘数</p>
</li>
<li><p>乘数不用符号位，写数值位即可</p>
</li>
<li><p>按照是0是1，要么+被乘数要么+0</p>
</li>
<li><p>右移（连符号位一起逻辑右移）</p>
<p><img src="/2023/06/21/comporgan/image-20230620232152706.png" alt="image-20230620232152706"></p>
</li>
<li><p>直到乘数全部移完</p>
</li>
</ol>
<h4 id="Booth算法"><a href="#Booth算法" class="headerlink" title="Booth算法"></a>Booth算法</h4><ol>
<li><p>部分积 乘数 y补（一开始为0）</p>
</li>
<li><p>部分积双符号位，乘数单符号位且参与运算</p>
<p><img src="/2023/06/21/comporgan/image-20230620212054291.png" alt="image-20230620212054291"></p>
</li>
<li><p>每次依据乘数和y补的关系，进行是否加被乘数的决策：</p>
<p>注意右移不同于原码，是算术右移</p>
<p><img src="/2023/06/21/comporgan/image-20230620212122222.png" alt="image-20230620212122222"></p>
</li>
<li><p>最后一步不用移位</p>
<p><img src="/2023/06/21/comporgan/image-20230620212150280.png" alt="image-20230620212150280"></p>
</li>
</ol>
<h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p>逻辑左移</p>
<p><strong>最后得到的余数还得乘个2的-n次方</strong></p>
<h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><ol>
<li>被除数（余数）  商</li>
<li>先加上 - 除数的补</li>
<li>如果得到结果≥0，则上商1，左移</li>
<li>如果小于0，则上商0，+除数补，左移</li>
<li>左移5次（商包括符号位的所有数字被填满），最后一次上商不用移位</li>
</ol>
<h4 id="不恢复余数法（加减交替法）"><a href="#不恢复余数法（加减交替法）" class="headerlink" title="不恢复余数法（加减交替法）"></a>不恢复余数法（加减交替法）</h4><blockquote>
<p><img src="/2023/06/21/comporgan/image-20230621200001791.png" alt="image-20230621200001791"></p>
<p>总结一下，大概流程：</p>
<p>①准备阶段：MQ清零【存放商】，ACC放入被除数，X放入除数</p>
<p>②ACC - X中的值</p>
<p>③若ACC中值【上一轮的余数】为负，则上商0；为正，则上商1.ACC左移一位。判断MQ的最后一位【上商的值】，若为负，则ACC + X中的y<em>；为正，ACC - X中的y</em>。【注意，若为第一次减去X，则当余数为正时，就即刻发生溢出错误退出】</p>
<p>④重复③，直到移位n次。</p>
<p><img src="/2023/06/21/comporgan/wps3-1687348786857-315.jpg" alt="img"> </p>
<p>V表示是否溢出。 </p>
</blockquote>
<ol>
<li><p>被除数（余数） 商</p>
</li>
<li><p>先加上 - 除数的补</p>
</li>
<li><p>如果得到结果≥0，则上商1，左移，下一次继续加 - 除数的补</p>
</li>
<li><p>如果小于0，则上商0，左移，下一次加除数的补</p>
<p><img src="/2023/06/21/comporgan/image-20230620234054088.png" alt="image-20230620234054088"></p>
<p>逻辑左移</p>
</li>
<li><p>左移5次（商包括符号位的所有数字被填满），最后一次上商不用移位</p>
</li>
</ol>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><blockquote>
<p>（1）意思是，舍去的要是1，就在保留数+1.如果是0就直接舍去。</p>
<p><img src="/2023/06/21/comporgan/wps4-1687348858599-317.jpg" alt="img">这意思难道是说可以一次性右移，最后再看要不要+1，而不是移一下加一次1？【不过想了一下，这两种顺序得到的结果好像是一样的。】</p>
</blockquote>
<h2 id="快速进位链"><a href="#快速进位链" class="headerlink" title="快速进位链"></a>快速进位链</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AB4y1p7ax?spm_id_from=333.880.my_history.page.click&amp;vd_source=ac571aae41aa0b588dd184591f27f582">https://www.bilibili.com/video/BV1AB4y1p7ax?spm_id_from=333.880.my_history.page.click&amp;vd_source=ac571aae41aa0b588dd184591f27f582</a> </p>
<p>以及老师在这讲的也挺好的【p88】</p>
<p><img src="/2023/06/21/comporgan/wps5-1687348905962-319.jpg" alt="img"><img src="/2023/06/21/comporgan/wps6.jpg" alt="img"> </p>
<p>当AiBi都为1时，无论Ci是什么，都必定进位1；当AiBi有一个为1时，Ci才会起决定性作用；当AiBi都为0时，无论Ci是什么，都不会进位。因此，AiBi为本地进位，Ai+Bi为传送条件。（乘号表示且，加号表示或）</p>
<p><img src="/2023/06/21/comporgan/wps7.jpg" alt="img">进位链是影响加法器速度的瓶颈</p>
<p><img src="/2023/06/21/comporgan/wps8.jpg" alt="img">但问题是电路太复杂了，因此给出折中方案：</p>
<p><img src="/2023/06/21/comporgan/wps9.jpg" alt="img"> </p>
<p>4先产生进位，传给3，3再产生进位，传给4，依次下去。</p>
<p><img src="/2023/06/21/comporgan/wps10.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps11.jpg" alt="img"><img src="/2023/06/21/comporgan/wps12.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps13.jpg" alt="img"><img src="/2023/06/21/comporgan/wps14.jpg" alt="img"> </p>
<p>相当于又套了一层并行进位链。</p>
<p><img src="/2023/06/21/comporgan/wps15.jpg" alt="img">实在是太强了。感受到还要再套一层分组的必要性了。</p>
</blockquote>
<h1 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h1><h2 id="RISC-V数据通路的组件选择"><a href="#RISC-V数据通路的组件选择" class="headerlink" title="RISC-V数据通路的组件选择"></a>RISC-V数据通路的组件选择</h2><p><img src="/2023/06/21/comporgan/image-20230617232028775.png" alt="image-20230617232028775"></p>
<p><strong>RISC CPU采用哈佛架构。</strong></p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ol>
<li><p>DM Data Memory 数据存储器</p>
<p><strong>读异步</strong>，写有写使能</p>
</li>
<li><p>IM Instruction Memory 指令存储器</p>
<p>一般read only</p>
</li>
</ol>
<h3 id="寄存器堆"><a href="#寄存器堆" class="headerlink" title="寄存器堆"></a>寄存器堆</h3><p>同步写异步读</p>
<p><img src="/2023/06/21/comporgan/image-20230617233101214.png" alt="image-20230617233101214"></p>
<h3 id="立即数扩展（生成）部件"><a href="#立即数扩展（生成）部件" class="headerlink" title="立即数扩展（生成）部件"></a>立即数扩展（生成）部件</h3><p>零扩展、符号扩展</p>
<h3 id="PC（程序计数器）"><a href="#PC（程序计数器）" class="headerlink" title="PC（程序计数器）"></a>PC（程序计数器）</h3><p>支持两种加法：+4、+立即数</p>
<h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><blockquote>
<p>【以下运算器结构适用于累加型运算器。累加器好像意思是一次最多两个输入。 】</p>
<p>运算器的功能是运算，因此其核心就是ALU（算术逻辑单元）。ALU是一个组合电路，组合电路的特点是，如果输入撤销了，那么输出结果也会撤销【组合逻辑电路】。因而，为了让ALU的结果能被保存，必须在输入端加上两个寄存器来保证信号持续输入。这两个寄存器一个叫做ACC，另一个叫做x，也叫做数据寄存器。</p>
<p><img src="/2023/06/21/comporgan/wps1-1687346760932-291.jpg" alt="img">MQ也是寄存器，用于保存计算过程中溢出的位数。</p>
<p><img src="/2023/06/21/comporgan/wps2.jpg" alt="img">具体见第六章，弹幕说汇编语言也有讲。乘法要这样放是为了防止乘积低位覆盖乘数。</p>
<p><img src="/2023/06/21/comporgan/wps3.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps4.jpg" alt="img">ACC里存放着上面的操作或者与外部交流得到的被乘数，按照约定需要转移到X里。我猜M放在MQ而不是ACC，可能是因为第一二步是并行的，如果放在ACC就需要一些等待。</p>
<p>并且乘法做的是移位累加【可能相当于上面乘法原理的第一个图吧】，ACC用来存储这些累加的暂时交换成果，因而需要将ACC先清空为0.</p>
<p>这些操作的先后顺序由控制器进行控制。</p>
<p><img src="/2023/06/21/comporgan/wps5.jpg" alt="img"> </p>
<p>MQ也称乘商寄存器</p>
</blockquote>
<p>运算类型：加、减、或、比较、slt、nor</p>
<p>操作数：寄存器或立即数</p>
<p><img src="/2023/06/21/comporgan/image-20230619214753499.png" alt="image-20230619214753499"></p>
<h2 id="RISC-V部分指令的数据通路设计"><a href="#RISC-V部分指令的数据通路设计" class="headerlink" title="RISC-V部分指令的数据通路设计"></a>RISC-V部分指令的数据通路设计</h2><h3 id="取数指令的完成过程"><a href="#取数指令的完成过程" class="headerlink" title="取数指令的完成过程"></a>取数指令的完成过程</h3><blockquote>
<p><img src="/2023/06/21/comporgan/image-20230621192714673.png" alt="image-20230621192714673"></p>
<p>下面是取数指令的完成过程。</p>
<p>完成一条指令有三个阶段：取指令、分析指令、执行指令。</p>
<p>取指令：PC把地址送到MAR，MAR把地址送到存储体。存储体在控制器的控制下，把地址所对应的指令的内容发给MDR，MDR把取出的指令送到IR.</p>
<p>分析指令：IR将指令的操作码部分交予CU，CU控制IR，IR将指令中的地址码部分交予MAR，MAR给存储体，存储体在控制器控制下给MDR，MDR送给ACC。</p>
<p>【这个过程正像是计算机网络，只不过此处全靠硬件完成，计算机网络只能依靠协议】</p>
</blockquote>
<h3 id="流水线周期"><a href="#流水线周期" class="headerlink" title="流水线周期"></a>流水线周期</h3><h4 id="RISC-V-1"><a href="#RISC-V-1" class="headerlink" title="RISC-V"></a>RISC-V</h4><p><img src="/2023/06/21/comporgan/image-20230617233444017.png" alt="image-20230617233444017"></p>
<p><img src="/2023/06/21/comporgan/image-20230618170512788.png" alt="image-20230618170512788"></p>
<p>注意，在ID阶段还会发生读寄存器</p>
<p><img src="/2023/06/21/comporgan/image-20230617233433422.png" alt="image-20230617233433422"></p>
<h4 id="X86"><a href="#X86" class="headerlink" title="X86"></a>X86</h4><blockquote>
<p>一、指令周期</p>
<ol>
<li>基本概念</li>
</ol>
<p>① 指令周期</p>
<p>② 每条指令的指令周期不同</p>
<p><img src="/2023/06/21/comporgan/wps2-1687349142625-366.jpg" alt="img">ADD取指阶段和执行阶段都需要一次访存</p>
<p>③ 具有间接寻址的指令周期</p>
<p><img src="/2023/06/21/comporgan/wps3-1687349142626-367.jpg" alt="img"> </p>
<p>三个周期各需要访存一次。【****现在暂时还不知道这有毛用****】</p>
<p>④ 具有中断周期的指令周期</p>
<p><img src="/2023/06/21/comporgan/wps4-1687349142626-368.jpg" alt="img"> </p>
<p>⑤ 指令周期的流程</p>
<p><img src="/2023/06/21/comporgan/wps5-1687349142626-369.jpg" alt="img"> </p>
<p>⑥ CPU工作周期的标志</p>
<p>指令周期的不同阶段，控制器要做不同的操作，要发出不同的命令。因而，控制器需要知道当前处于指令周期的哪一个阶段。</p>
<p><img src="/2023/06/21/comporgan/wps6-1687349142626-370.jpg" alt="img">用四个触发器</p>
<ol start="2">
<li>指令周期的数据流</li>
</ol>
<p>① 取指周期</p>
<p><img src="/2023/06/21/comporgan/wps7-1687349142626-371.jpg" alt="img"> </p>
<p>首先，PC把自己里面存的地址放进MAR，再通过地址总线传输给存储器。</p>
<p>CU通过控制总线向存储器发出读控制信号。</p>
<p>存储器执行读操作，通过数据总线传输取到的指令给MDR，MDR再传给IR。</p>
<p>CU把加一后的地址保存在PC中，为下一条指令取指做准备。</p>
<p>② 间址周期</p>
<p><img src="/2023/06/21/comporgan/wps8-1687349142626-372.jpg" alt="img"> </p>
<p>如果指令的数据部分采用的是间接寻址的方式，那么此时，MDR中的地址部分不是有效地址，而是存储存储有效地址的存储单元的地址值。因而，我们需要再通过一次访存操作，把有效地址值存储在MDR中。</p>
<p>③ 执行周期</p>
<p><img src="/2023/06/21/comporgan/wps9-1687349142626-373.jpg" alt="img">留给第九章介绍。</p>
<p>④ 中断周期</p>
<p>做了三件事：保存断点、形成服务程序入口地址、中断返回</p>
<p><img src="/2023/06/21/comporgan/wps10-1687349142626-374.jpg" alt="img"> </p>
<p>首先，保存断点。由CU来确定断电保存在内存单元的哪里。CU把地址传给MAR,MAR将其发到存储器，CU给存储器写命令。PC将自己的值【也就是下一条要执行的命令的地址值】交付给MDR，MDR传给存储器。【MDR在读写操作时都充当了缓冲区的角色。】</p>
<p>然后，CU形成中断服务程序入口地址，并直接把它写入到CU。 </p>
</blockquote>
<h2 id="流水线处理器"><a href="#流水线处理器" class="headerlink" title="流水线处理器"></a>流水线处理器</h2><h3 id="流水线概述"><a href="#流水线概述" class="headerlink" title="流水线概述"></a>流水线概述</h3><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p><img src="/2023/06/21/comporgan/image-20230618150003983.png" alt="image-20230618150003983"></p>
<p>这点我觉得讲得挺好的。以前只知道流水线通过并行来加速指令执行，但这里给出了一个新的思路：如果是单周期处理器，则RISC-V的时钟周期受执行时间最长的指令限制；如果是流水线处理器，时钟周期就可以由某个步骤决定，主频就可以加快。这个出发点很有意思。</p>
<p>如果流水线各阶段平衡，也即每个阶段需要的执行时间差不多，则</p>
<p><img src="/2023/06/21/comporgan/image-20230618150515599.png" alt="image-20230618150515599"></p>
<p>也即在理想条件和有大量指令的情况下，<strong>流水线带来的加速比约等于流水线的级数</strong>，若各阶段不完全平衡，加速比会变小。</p>
<p>流水线技术是通过<strong>提高指令的吞吐率</strong>来提高性能的。</p>
<h4 id="RISC-V与流水线"><a href="#RISC-V与流水线" class="headerlink" title="RISC-V与流水线"></a>RISC-V与流水线</h4><p>我们可以看到，比起X86，<strong>RISC-V是面向流水线设计的</strong>，其特性与流水线高度相关：</p>
<ol>
<li><p><strong>指令长度相同</strong></p>
<p>简化IF和ID</p>
</li>
<li><p><strong>只有六种指令格式，格式整齐</strong></p>
<p>能在一个阶段内完成译码和读寄存器（ID）</p>
</li>
<li><p><strong>只通过load、store访存</strong></p>
<p>可以利用EX阶段计算存储器地址，然后在下一阶段访存（MEM）</p>
</li>
</ol>
<h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><p><img src="/2023/06/21/comporgan/image-20230618151040625.png" alt="image-20230618151040625"></p>
<h4 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h4><p><img src="/2023/06/21/comporgan/image-20230618151208189.png" alt="image-20230618151208189"></p>
<h4 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h4><p><img src="/2023/06/21/comporgan/image-20230618151243620.png" alt="image-20230618151243620"></p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><h6 id="前递"><a href="#前递" class="headerlink" title="前递"></a>前递</h6><p><img src="/2023/06/21/comporgan/image-20230618151601721.png" alt="image-20230618151601721"></p>
<h6 id="编译重排"><a href="#编译重排" class="headerlink" title="编译重排"></a>编译重排</h6><p><img src="/2023/06/21/comporgan/image-20230618151706080.png" alt="image-20230618151706080"></p>
<h6 id="停顿（气泡）"><a href="#停顿（气泡）" class="headerlink" title="停顿（气泡）"></a>停顿（气泡）</h6><p>实在不行只能暂停流水线了</p>
<p><img src="/2023/06/21/comporgan/image-20230618151637437.png" alt="image-20230618151637437"></p>
<h4 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h4><p><img src="/2023/06/21/comporgan/image-20230619220308876.png" alt="image-20230619220308876"></p>
<h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><h6 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h6><p><img src="/2023/06/21/comporgan/image-20230619220259945.png" alt="image-20230619220259945"></p>
<h6 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h6><ol>
<li><p>遇到分支预测就停顿</p>
</li>
<li><p>分支预测</p>
<ol>
<li><p>静态分支预测</p>
<p><img src="/2023/06/21/comporgan/image-20230618153106322.png" alt="image-20230618153106322"></p>
</li>
<li><p>动态分支预测</p>
<p><img src="/2023/06/21/comporgan/image-20230618153125295.png" alt="image-20230618153125295"></p>
</li>
</ol>
</li>
</ol>
<h3 id="流水线数据通路和控制"><a href="#流水线数据通路和控制" class="headerlink" title="流水线数据通路和控制"></a>流水线数据通路和控制</h3><h4 id="流水线数据通路"><a href="#流水线数据通路" class="headerlink" title="流水线数据通路"></a>流水线数据通路</h4><h5 id="流水线寄存器"><a href="#流水线寄存器" class="headerlink" title="流水线寄存器"></a>流水线寄存器</h5><p><img src="/2023/06/21/comporgan/image-20230618154028950.png" alt="image-20230618154028950"></p>
<p><img src="/2023/06/21/comporgan/image-20230618154608423.png" alt="image-20230618154608423"></p>
<p>66666，这个帅</p>
<p><img src="/2023/06/21/comporgan/image-20230618154815411.png" alt="image-20230618154815411"></p>
<h4 id="流水线控制"><a href="#流水线控制" class="headerlink" title="流水线控制"></a>流水线控制</h4><h3 id="数据冒险：前递与停顿"><a href="#数据冒险：前递与停顿" class="headerlink" title="数据冒险：前递与停顿"></a>数据冒险：前递与停顿</h3><h4 id="前递-1"><a href="#前递-1" class="headerlink" title="前递"></a>前递</h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>前递有两种情况：</p>
<p><img src="/2023/06/21/comporgan/image-20230618155952018.png" alt="image-20230618155952018"></p>
<h5 id="前递产生条件"><a href="#前递产生条件" class="headerlink" title="前递产生条件"></a>前递产生条件</h5><ol>
<li>RegWrite != 0（写有效）</li>
<li>Rd != x0</li>
</ol>
<h5 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h5><p>流水线寄存器解决：</p>
<p><img src="/2023/06/21/comporgan/image-20230618160141827.png" alt="image-20230618160141827"></p>
<p>并且增加前递所需硬件。</p>
<h4 id="停顿"><a href="#停顿" class="headerlink" title="停顿"></a>停顿</h4><p>流水线寄存器解决：</p>
<ol>
<li><p>置ID/EX寄存器中控制信号为0（防止寄存器和存储器被写入数据），执行空指令nop</p>
</li>
<li><p>禁止PC寄存器和IF/ID寄存器内容改变</p>
<p>下一条指令就能重新取指</p>
</li>
</ol>
<h3 id="控制冒险-1"><a href="#控制冒险-1" class="headerlink" title="控制冒险"></a>控制冒险</h3><p><img src="/2023/06/21/comporgan/image-20230618161320779.png" alt="image-20230618161320779"></p>
<p><img src="/2023/06/21/comporgan/image-20230618161333487.png" alt="image-20230618161333487"></p>
<p>缩短分支延迟的方法：</p>
<h4 id="硬件支持-1"><a href="#硬件支持-1" class="headerlink" title="硬件支持"></a>硬件支持</h4><p><img src="/2023/06/21/comporgan/image-20230618161429557.png" alt="image-20230618161429557"></p>
<h4 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h4><p><img src="/2023/06/21/comporgan/image-20230618161807387.png" alt="image-20230618161807387"></p>
<p><img src="/2023/06/21/comporgan/image-20230618161932429.png" alt="image-20230618161932429"></p>
<h4 id="计算目标地址"><a href="#计算目标地址" class="headerlink" title="计算目标地址"></a>计算目标地址</h4><p><img src="/2023/06/21/comporgan/image-20230618162114338.png" alt="image-20230618162114338"></p>
<h3 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h3><p><img src="/2023/06/21/comporgan/wps11-1687349247410-385.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps12-1687349247410-386.jpg" alt="img"> </p>
<p>超流水技术要求一个时钟周期内不同的指令不能相互叠加干扰。</p>
<p><img src="/2023/06/21/comporgan/wps13-1687349247410-387.jpg" alt="img"> </p>
<p>意思就是多条指令并成一条，有公共的取指、译码、写回阶段，但是执行阶段各不相同且并行执行，应该是这样。 </p>
<h3 id="例外和中断"><a href="#例外和中断" class="headerlink" title="例外和中断"></a>例外和中断</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><img src="/2023/06/21/comporgan/image-20230618162247586.png" alt="image-20230618162247586"></p>
<p>内部的一定是例外，外部的只有<strong>IO请求和硬件故障</strong>是中断</p>
<p><img src="/2023/06/21/comporgan/image-20230618162302149.png" alt="image-20230618162302149"></p>
<p><img src="/2023/06/21/comporgan/image-20230618162437636.png" alt="image-20230618162437636"></p>
<p><img src="/2023/06/21/comporgan/image-20230618162500928.png" alt="image-20230618162500928"></p>
<p>哦哦哦WOC!!!!!</p>
<p>这让我想起来在做xv6的时候，的那个kerneltrap和usertrap，应该就是这里的这个统一入口地址。</p>
<p>xv6是RISC-V架构，故而发生中断的时候，就会跳转到统一的kernel trap，然后再在里面通过scause进行读取。666</p>
<p>不过盘问了下gpt，RISC-V对于exception和interruption的处理方式是不一样的：</p>
<p>在RISC-V中，异常通常是由于程序执行过程中的错误或非预期事件而引起的，包括<strong>故障（faults）、陷阱（traps）和中止（aborts）</strong>。中断（interrupts）则是由外部事件触发的，例如定时器到期、外部设备请求等。中断是异步事件，与当前正在执行的指令无关，因此会在任何时候发生。</p>
<p>例外是通过统一入口地址处理，中断则是中断向量的方式</p>
<h4 id="流水线中的例外"><a href="#流水线中的例外" class="headerlink" title="流水线中的例外"></a>流水线中的例外</h4><p><img src="/2023/06/21/comporgan/image-20230618163521639.png" alt="image-20230618163521639"></p>
<h2 id="微操作（X86）"><a href="#微操作（X86）" class="headerlink" title="微操作（X86）"></a>微操作（X86）</h2><p>X86将一条指令的执行分为多个微操作。</p>
<blockquote>
<p>一、微操作命令分析</p>
<p>微操作命令是控制单元在完成一大条指令时所需要细分完成的一条条微小的命令</p>
<p><img src="/2023/06/21/comporgan/image-20230621201435702.png" alt="image-20230621201435702"></p>
<ol>
<li><p>取值周期</p>
<p><img src="/2023/06/21/comporgan/image-20230621201345807.png" alt="image-20230621201345807"></p>
</li>
<li><p>间址周期</p>
<p><img src="/2023/06/21/comporgan/image-20230621201351939.png" alt="image-20230621201351939"></p>
</li>
<li><p>执行周期  ①访存指令  ②非访存指令  ③转移指令  ④三类指令的指令周期</p>
<p><img src="/2023/06/21/comporgan/image-20230621201358396.png" alt="image-20230621201358396"></p>
<p><img src="/2023/06/21/comporgan/wps1-1687349648125-391.jpg" alt="img"><img src="/2023/06/21/comporgan/wps2-1687349648126-392.jpg" alt="img"></p>
<p><img src="/2023/06/21/comporgan/image-20230621201423245.png" alt="image-20230621201423245"></p>
</li>
<li><p>中断周期  硬件法和软件法</p>
<p><img src="/2023/06/21/comporgan/wps3-1687349692211-395.jpg" alt="img"><img src="/2023/06/21/comporgan/wps4-1687349692211-396.jpg" alt="img"></p>
<p>硬件和软件法。</p>
</li>
</ol>
<p>二、控制单元的功能</p>
<ol>
<li><p>输入信号</p>
<p>①时钟信号  ②指令寄存器【控制信号与操作码有关】  ③标志  ④外来信号【中断请求、总线请求】</p>
</li>
<li><p>输出信号</p>
<p>①CPU内各种控制信号【比如（PC）+1-&gt;PC这种】</p>
<p>②送至控制总线的信号【比如中断响应、总线响应】</p>
</li>
<li><p>控制信号举例</p>
<p>①不使用内部总线</p>
<p>②采用内部总线</p>
</li>
<li><p>多级时序系统</p>
<ol>
<li><p>机器周期  </p>
<p><strong>取指周期=机器周期=最复杂的微操作所需时间【访存】</strong></p>
<p>在机器周期内部也需要有时钟来控制微操作的执行顺序</p>
</li>
<li><p>时钟周期（节拍、状态）</p>
<p>每个指令周期都可分为若干个机器周期，每个机器周期都可分为若干个节拍（时钟周期）。一个机器周期内包含多少节拍与需要发送多少控制信号、控制信号复杂度、控制信号能否并行有关。</p>
<p>时钟产生节拍信号，不同的节拍信号有不同的先后顺序。</p>
<p>一个时钟周期产生一个或几个【并行的几个，或者是操作时间很短，虽然有一定的先后顺序，但可以在一个节拍内完成】微操作命令</p>
<p>时钟信号利用上升沿让CU发出控制命令【微操作】控制各个不同部件。</p>
</li>
</ol>
</li>
<li><p>控制方式</p>
<p>①同步控制方式  采用<strong>定长的</strong>机器周期、<strong>不定长</strong>的机器周期、<strong>中央控制和局部控制相结合</strong></p>
<p>​    当指令大多都是可以提前确定的，就用同步。当一条微操作的时间很难控制，可以采用异步控制。</p>
<p>②异步控制方式  等待IO读写</p>
<p>③联合控制方式  同步与异步结合</p>
<p>④人工控制</p>
</li>
</ol>
<p>三、组合逻辑设计</p>
<ol>
<li><p>组合逻辑控制单元框图</p>
<p>①CU外特性  ②节拍信号</p>
</li>
<li><p>微操作的节拍安排</p>
<p>①安排微操作时序的原则</p>
<p>原则一：先后顺序不更改。</p>
<p>原则二：可以并行执行的，且微操作间没有先后顺序的，就尽量把它们安排在一个节拍中。</p>
<p>原则三：时间较短微操作尽量在一个节拍内且可以有先后顺序。</p>
<p>②取值周期间址周期执行周期的</p>
<p><img src="/2023/06/21/comporgan/image-20230621201709245.png" alt="image-20230621201709245"></p>
<p><img src="/2023/06/21/comporgan/image-20230621201717225.png" alt="image-20230621201717225"></p>
<p><img src="/2023/06/21/comporgan/image-20230621201722561.png" alt="image-20230621201722561"></p>
<p><img src="/2023/06/21/comporgan/image-20230621201732549.png" alt="image-20230621201732549"></p>
</li>
</ol>
</blockquote>
<h1 id="存储器-1"><a href="#存储器-1" class="headerlink" title="存储器"></a>存储器</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p><img src="/2023/06/21/comporgan/image-20230618183618033.png" alt="image-20230618183618033"></p>
<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><blockquote>
<p>寄存器分为两类，体系结构寄存器和非体系结构寄存器。前者可以让程序员调度使用，后者不行。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618183742599.png" alt="image-20230618183742599"></p>
<p><img src="/2023/06/21/comporgan/image-20230618183845067.png" alt="image-20230618183845067"></p>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><h4 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h4><blockquote>
<p>MAR中的地址需要经过译码器才能得到对应存储体中的位置。MDR中的数据是读是写需要通过读写电路控制，读写电路接收控制电路的读写信号。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618184214916.png" alt="image-20230618184214916"></p>
<h4 id="与CPU连接"><a href="#与CPU连接" class="headerlink" title="与CPU连接"></a>与CPU连接</h4><p><img src="/2023/06/21/comporgan/image-20230618211118255.png" alt="image-20230618211118255"></p>
<h4 id="小端模式"><a href="#小端模式" class="headerlink" title="小端模式"></a>小端模式</h4><p><img src="/2023/06/21/comporgan/image-20230618211717123.png" alt="image-20230618211717123"></p>
<h4 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h4><p><img src="/2023/06/21/comporgan/image-20230618211918511.png" alt="image-20230618211918511"></p>
<h3 id="半导体存储芯片简介"><a href="#半导体存储芯片简介" class="headerlink" title="半导体存储芯片简介"></a>半导体存储芯片简介</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="/2023/06/21/comporgan/image-20230618212044462.png" alt="image-20230618212044462"></p>
<p><img src="/2023/06/21/comporgan/image-20230618212116854.png" alt="image-20230618212116854"></p>
<h4 id="译码驱动方式"><a href="#译码驱动方式" class="headerlink" title="译码驱动方式"></a>译码驱动方式</h4><h5 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h5><p><img src="/2023/06/21/comporgan/image-20230618212207454.png" alt="image-20230618212207454"></p>
<h5 id="重合法"><a href="#重合法" class="headerlink" title="重合法"></a>重合法</h5><p><img src="/2023/06/21/comporgan/image-20230618212227553.png" alt="image-20230618212227553"></p>
<h3 id="RAM-随机存取存储器"><a href="#RAM-随机存取存储器" class="headerlink" title="RAM 随机存取存储器"></a>RAM 随机存取存储器</h3><h4 id="DRAM和SRAM"><a href="#DRAM和SRAM" class="headerlink" title="DRAM和SRAM"></a>DRAM和SRAM</h4><p><img src="/2023/06/21/comporgan/image-20230618222428159.png" alt="image-20230618222428159"></p>
<h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><h5 id="基本电路"><a href="#基本电路" class="headerlink" title="基本电路"></a>基本电路</h5><blockquote>
<p><img src="/2023/06/21/comporgan/image-20230621193330855.png" alt="image-20230621193330855"></p>
<p>核心就是利用****触发器（T1—T4）****来表示0和1的</p>
<p>用T5和T6行开关来控制对触发器部件读写，用T7和T8列开关……【对应上面说的重合法？】</p>
<p>写入要在A段写入数据，同时在A’段写入数据的非【因为触发器是双稳态的，要求两边输入的信号相反。】对应的，写选择那边输入数据也得对称经过门和非门。</p>
</blockquote>
<h5 id="经典芯片"><a href="#经典芯片" class="headerlink" title="经典芯片"></a>经典芯片</h5><p><img src="/2023/06/21/comporgan/image-20230618212447162.png" alt="image-20230618212447162"></p>
<h5 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h5><p><img src="/2023/06/21/comporgan/wps1.jpg" alt="img"></p>
<p>上面的部分是64*64的基本电路矩阵。我们按列分，每十六列为一组，则分成了四组。因为2^4=16，因而我们用四位来表示地址控制信号。</p>
<p>对于行，当地址控制信号为0000时，表示选择存储矩阵的第一行的数据，为0001时，选择第二行的……依此类推。</p>
<p>对于列，当地址控制信号为0000时，表示选择每一组的第一列的数据，为0001时，选择第二列的……依此类推。</p>
<p>每一组只能有一列被选中，这就达到了一次读写四位的目的。【一个字节分开存】</p>
<h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><h5 id="基本电路-1"><a href="#基本电路-1" class="headerlink" title="基本电路"></a>基本电路</h5><blockquote>
<p>主要是通过电容的充放电实现的</p>
<p><img src="/2023/06/21/comporgan/wps1-1687347239255-303.jpg" alt="img"> </p>
<p>左侧三管那个中，读数据线读出的跟存储的是相反的，存0读1，存1读0.但写入跟输入的信息是相同的。</p>
<p>右侧单管中，读出时数据线有电流则是1，没有则是0.写入时，对Cs充电则为1，Cs放电（输入信号为低电平）则为0.</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618215704699.png" alt="image-20230618215704699"></p>
<h5 id="经典芯片-读写"><a href="#经典芯片-读写" class="headerlink" title="经典芯片/读写"></a>经典芯片/读写</h5><p><img src="/2023/06/21/comporgan/image-20230618215803608.png" alt="image-20230618215803608"></p>
<blockquote>
<p><img src="/2023/06/21/comporgan/wps2-1687347264734-305.jpg" alt="img"></p>
<p>14位的地址分了两次传，分别作为行列地址。</p>
<p>RAS:行选控制信号 CAS：列选控制信号 WE：读写控制信号。产生的时钟控制了芯片内部的读写操作</p>
<p><img src="/2023/06/21/comporgan/wps3-1687347264735-306.jpg" alt="img"> </p>
<p>如果读放大器左边有电，那么右边输出没电；左没电右有电.这样，读放大器左边的部分，有电表示0，没电表示1 ；读放大器右边的部分，有电表示1，没电表示0.</p>
</blockquote>
<h5 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h5><p>为什么要刷新：</p>
<p><img src="/2023/06/21/comporgan/image-20230619224003589.png" alt="image-20230619224003589"></p>
<h6 id="集中刷新"><a href="#集中刷新" class="headerlink" title="集中刷新"></a>集中刷新</h6><p><img src="/2023/06/21/comporgan/image-20230618221439701.png" alt="image-20230618221439701"></p>
<h6 id="分散刷新"><a href="#分散刷新" class="headerlink" title="分散刷新"></a>分散刷新</h6><p><img src="/2023/06/21/comporgan/image-20230618221603727.png" alt="image-20230618221603727"></p>
<h6 id="异步刷新"><a href="#异步刷新" class="headerlink" title="异步刷新"></a>异步刷新</h6><p><img src="/2023/06/21/comporgan/image-20230618222049113.png" alt="image-20230618222049113"></p>
<h3 id="ROM-只读存储器"><a href="#ROM-只读存储器" class="headerlink" title="ROM 只读存储器"></a>ROM 只读存储器</h3><ol>
<li><p>掩膜ROM(MROM)  用户不能修改</p>
<p><img src="/2023/06/21/comporgan/image-20230618222716561.png" alt="image-20230618222716561"></p>
</li>
<li><p>PROM（一次性编程）  破坏性编程</p>
<p><img src="/2023/06/21/comporgan/image-20230618223116398.png" alt="image-20230618223116398"></p>
</li>
<li><p>EPROM（多次性编程）</p>
<p><img src="/2023/06/21/comporgan/image-20230618223151914.png" alt="image-20230618223151914"></p>
</li>
<li><p>EEPROM（电可擦写）</p>
<p><img src="/2023/06/21/comporgan/image-20230618223229585.png" alt="image-20230618223229585"></p>
</li>
<li><p>Flash Memory（闪速型存储器）</p>
<p><img src="/2023/06/21/comporgan/image-20230618223252821.png" alt="image-20230618223252821"></p>
</li>
</ol>
<h3 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h3><h4 id="存储器容量的扩展"><a href="#存储器容量的扩展" class="headerlink" title="存储器容量的扩展"></a>存储器容量的扩展</h4><h5 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h5><p><img src="/2023/06/21/comporgan/image-20230618224638384.png" alt="image-20230618224638384"></p>
<h5 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h5><p><img src="/2023/06/21/comporgan/image-20230618224745584.png" alt="image-20230618224745584"></p>
<p>带了片选思想</p>
<h5 id="位字扩展"><a href="#位字扩展" class="headerlink" title="位字扩展"></a>位字扩展</h5><p><img src="/2023/06/21/comporgan/image-20230618224955557.png" alt="image-20230618224955557"></p>
<h4 id="存储器与CPU的连接-1"><a href="#存储器与CPU的连接-1" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h4><h3 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h3><p><img src="/2023/06/21/comporgan/image-20230620221830055.png" alt="image-20230620221830055"></p>
<h4 id="汉明码组成"><a href="#汉明码组成" class="headerlink" title="汉明码组成"></a>汉明码组成</h4><p><img src="/2023/06/21/comporgan/image-20230620222021345.png" alt="image-20230620222021345"></p>
<p><img src="/2023/06/21/comporgan/image-20230620222133679.png" alt="image-20230620222133679"></p>
<p><img src="/2023/06/21/comporgan/image-20230620222301502.png" alt="image-20230620222301502"></p>
<p>n为数据的位数</p>
<p><img src="/2023/06/21/comporgan/image-20230620222225994.png" alt="image-20230620222225994"></p>
<p><img src="/2023/06/21/comporgan/image-20230620222518156.png" alt="image-20230620222518156"></p>
<h4 id="汉明码纠错"><a href="#汉明码纠错" class="headerlink" title="汉明码纠错"></a>汉明码纠错</h4><p><img src="/2023/06/21/comporgan/image-20230620222951821.png" alt="image-20230620222951821"></p>
<p>跟组成的步骤是一样的</p>
<h3 id="提高访存速度的措施"><a href="#提高访存速度的措施" class="headerlink" title="提高访存速度的措施"></a>提高访存速度的措施</h3><p><img src="/2023/06/21/comporgan/image-20230618233156234.png" alt="image-20230618233156234"></p>
<p><img src="/2023/06/21/comporgan/image-20230618233234559.png" alt="image-20230618233234559"></p>
<p><img src="/2023/06/21/comporgan/image-20230618233325427.png" alt="image-20230618233325427"></p>
<p><img src="/2023/06/21/comporgan/image-20230619224341497.png" alt="image-20230619224341497"></p>
<p><img src="/2023/06/21/comporgan/image-20230618233855438.png" alt="image-20230618233855438"></p>
<p>不过这里也帅得一批，非常有那种从小到大的抽象思维在。</p>
<p>之前的单独一块RAM芯片，一个字节是分开存；这里的一个主存堆，一个块是分主存存。</p>
<h2 id="Cache-高速缓冲存储器"><a href="#Cache-高速缓冲存储器" class="headerlink" title="Cache 高速缓冲存储器"></a>Cache 高速缓冲存储器</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/06/21/comporgan/image-20230618233726163.png" alt="image-20230618233726163"></p>
<h4 id="技术指标-1"><a href="#技术指标-1" class="headerlink" title="技术指标"></a>技术指标</h4><p><img src="/2023/06/21/comporgan/image-20230618233800847.png" alt="image-20230618233800847"></p>
<p><img src="/2023/06/21/comporgan/image-20230618234113714.png" alt="image-20230618234113714"></p>
<p>因为在一个存取周期当中，每体都可以取一个字，16体就可以取16字，因而一个存取周期可以取出16个字出来。</p>
<p><img src="/2023/06/21/comporgan/image-20230618234151529.png" alt="image-20230618234151529"></p>
<p>但是这个公式前提是访问cache和主存并行。如果换用另一个策略，即先看cache有没有，没有再去主存，计算公式就不一样。</p>
<h3 id="Cache的读写操作"><a href="#Cache的读写操作" class="headerlink" title="Cache的读写操作"></a>Cache的读写操作</h3><blockquote>
<p><img src="/2023/06/21/comporgan/wps1-1687103084226-2.jpg" alt="img"></p>
<p>cache接收CPU发来的地址信号。CPU发出的地址中的块内地址无需转换，而块号需要通过主存cache地址映射变换机构转化成cache内的块号。【所以说CPU访问cache的时候，传给cache的地址是主存的物理地址吧？然后再通过主存cache地址映射转化为cache的块内地址。】</p>
<p>如果命中，则转换机构工作，传递地址给cache存储体，存储体通过数据总线发送信号。</p>
<p>如果不命中，并且cache没装满，则发送信号给主存。</p>
<p>如果不命中，且cache装满了，则cache替换机构使用替换算法，淘汰cache中一些块，同时发送信号给主存。</p>
<p>主存收到信号，<strong>在数据总线上发给cpu要的东西之后，再将所在块发给cache</strong>。</p>
<p><img src="/2023/06/21/comporgan/image-20230621193732489.png" alt="image-20230621193732489"></p>
</blockquote>
<h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><p><img src="/2023/06/21/comporgan/image-20230618234639119.png" alt="image-20230618234639119"></p>
<h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><p><img src="/2023/06/21/comporgan/image-20230618234752772.png" alt="image-20230618234752772"></p>
<h3 id="Cache-主存映射"><a href="#Cache-主存映射" class="headerlink" title="Cache-主存映射"></a>Cache-主存映射</h3><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p><img src="/2023/06/21/comporgan/image-20230618234904098.png" alt="image-20230618234904098"></p>
<p><img src="/2023/06/21/comporgan/image-20230618234921789.png" alt="image-20230618234921789"></p>
<h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><p><img src="/2023/06/21/comporgan/image-20230618235007647.png" alt="image-20230618235007647"></p>
<h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><p><img src="/2023/06/21/comporgan/image-20230618235147739.png" alt="image-20230618235147739"></p>
<h3 id="缓存替换算法"><a href="#缓存替换算法" class="headerlink" title="缓存替换算法"></a>缓存替换算法</h3><p><img src="/2023/06/21/comporgan/image-20230618235750985.png" alt="image-20230618235750985"></p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><blockquote>
<p>现在很多处理器至少有三级cache。比如每个核一个cache，多个核还有一个公用的cache。</p>
<p>流水线计算机很多都分了指令cache和数据cache，避免资源冲突。</p>
<p>注意，每个层次的cache采用的映射可能不一样。</p>
<p><strong>靠近CPU采用直接相连或者路数（r）少的组相连【其实直接相连就相当于是一路的组相联了】。中间的用组相联。距离CPU较远的用全相联。</strong></p>
<p>距离越远，对速度要求越低，对利用率要求越高。</p>
</blockquote>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="与Cache的差异"><a href="#与Cache的差异" class="headerlink" title="与Cache的差异"></a>与Cache的差异</h3><p><img src="/2023/06/21/comporgan/image-20230619000944183.png" alt="image-20230619000944183"></p>
<h3 id="虚拟存储器-1"><a href="#虚拟存储器-1" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p><img src="/2023/06/21/comporgan/image-20230618235955557.png" alt="image-20230618235955557"></p>
<p><img src="/2023/06/21/comporgan/image-20230619000042556.png" alt="image-20230619000042556"></p>
<p>相当于把主存-辅存（磁盘）看成另一个cache-主存。这也就类似于内存页面换入换出了。原来这玩意叫虚拟存储器啊，不过这也类似于虚拟地址空间的叫法就是了。</p>
<p><img src="/2023/06/21/comporgan/image-20230619000208477.png" alt="image-20230619000208477"></p>
<p><img src="/2023/06/21/comporgan/image-20230619000304314.png" alt="image-20230619000304314"></p>
<h3 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h3><p><img src="/2023/06/21/comporgan/image-20230619000428020.png" alt="image-20230619000428020"></p>
<h3 id="访问流程"><a href="#访问流程" class="headerlink" title="访问流程"></a>访问流程</h3><p><img src="/2023/06/21/comporgan/image-20230619000542665.png" alt="image-20230619000542665"></p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p><img src="/2023/06/21/comporgan/image-20230619000628910.png" alt="image-20230619000628910"></p>
<p><img src="/2023/06/21/comporgan/image-20230619000804374.png" alt="image-20230619000804374"></p>
<p><img src="/2023/06/21/comporgan/image-20230619000827244.png" alt="image-20230619000827244"></p>
<p><img src="/2023/06/21/comporgan/image-20230619000851370.png" alt="image-20230619000851370"></p>
<h2 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h2><p>硬盘、U盘、软盘、磁带、光盘</p>
<h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p><img src="/2023/06/21/comporgan/image-20230619142112318.png" alt="image-20230619142112318"></p>
<p><img src="/2023/06/21/comporgan/image-20230619142148621.png" alt="image-20230619142148621"></p>
<p><img src="/2023/06/21/comporgan/image-20230619143428427.png" alt="image-20230619143428427"></p>
<p><img src="/2023/06/21/comporgan/image-20230619143411577.png" alt="image-20230619143411577"></p>
<h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><h3 id="是啥"><a href="#是啥" class="headerlink" title="是啥"></a>是啥</h3><p>总线两个特点：<strong>分时</strong>和<strong>共享</strong></p>
<p>遵循<strong>协议</strong>或<strong>标准，方便</strong>计算机系统集成、扩展和进化</p>
<p>总线的猝发传输方式：在一个总线周期内，传输存储地址连续的多个数据字的总线传输方式。</p>
<h3 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h3><p><img src="/2023/06/21/comporgan/image-20230618173335493.png" alt="image-20230618173335493"></p>
<p><img src="/2023/06/21/comporgan/image-20230618173414845.png" alt="image-20230618173414845"></p>
<h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><h3 id="单总线"><a href="#单总线" class="headerlink" title="单总线"></a>单总线</h3><p>注意，单总线是默认统一编址的？</p>
<p><img src="/2023/06/21/comporgan/image-20230618175005524.png" alt="image-20230618175005524"></p>
<h3 id="面向CPU的双总线"><a href="#面向CPU的双总线" class="headerlink" title="面向CPU的双总线"></a>面向CPU的双总线</h3><p><img src="/2023/06/21/comporgan/image-20230618175035406.png" alt="image-20230618175035406"></p>
<h3 id="存储器为中心-1"><a href="#存储器为中心-1" class="headerlink" title="存储器为中心"></a>存储器为中心</h3><p><img src="/2023/06/21/comporgan/image-20230618175435591.png" alt="image-20230618175435591"></p>
<h3 id="有通道的多总线结构"><a href="#有通道的多总线结构" class="headerlink" title="有通道的多总线结构"></a>有通道的多总线结构</h3><p><img src="/2023/06/21/comporgan/image-20230618175533637.png" alt="image-20230618175533637"></p>
<p><img src="/2023/06/21/comporgan/image-20230618175631552.png" alt="image-20230618175631552"></p>
<p>帅</p>
<p><img src="/2023/06/21/comporgan/image-20230618175705273.png" alt="image-20230618175705273"></p>
<p><img src="/2023/06/21/comporgan/image-20230618175743501.png" alt="image-20230618175743501"></p>
<h2 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h2><h3 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h3><p><img src="/2023/06/21/comporgan/image-20230618180345695.png" alt="image-20230618180345695"></p>
<p><img src="/2023/06/21/comporgan/image-20230618180704321.png" alt="image-20230618180704321"></p>
<p>注意，独立请求是最快的</p>
<h4 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h4><blockquote>
<p>所有设备可在BR线发布总线请求，主设备通过BG线表态，争得总线的设备要通过BS线告诉其他设备总线忙。</p>
<p>BG线中，总线同意信号会依次遍历每一个设备，直到找到第一个提出请求的设备。</p>
<p>可见，这个遍历顺序就代表了各个IO设备的优先级顺序。</p>
<p>这样相当于分离出格外的线来控制信号。这种方式对电路故障非常敏感。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618180431836.png" alt="image-20230618180431836"></p>
<h4 id="计数器定时查询"><a href="#计数器定时查询" class="headerlink" title="计数器定时查询"></a>计数器定时查询</h4><blockquote>
<p>意思好像是，在BR线提出请求，主设备接收到请求后，可以响应的情况下，启动计数器，计数器初始值为零。计数器的值通过设备地址线输出。如果计数器为0，则观察接口0有没有请求，没有的话计数器++，继续看下一个，以此类推，直到找到第一个对应接口，则开始传输数据，BS线启用。</p>
<p>设备地址线需要给所有设备地址进行编码，因此宽度与设备数有关。</p>
<p>这个的优点在于，优先级的确定更加灵活了。比如说，计数器不一定从零开始而是从上一次停止的地方开始（<strong>循环优先级</strong>，这样的话每个设备的机会均等），或者用软件控制优先级初始值，或者每一次不一定++而是有其他计算规则。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618180602116.png" alt="image-20230618180602116"></p>
<h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><blockquote>
<p>优先级由主设备内部逻辑（排队器）规定。也可以用自适应、计数器等等等。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618180645765.png" alt="image-20230618180645765"></p>
<h3 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h3><p><img src="/2023/06/21/comporgan/image-20230618180848436.png" alt="image-20230618180848436"></p>
<p>这玩意传输周期还考了</p>
<p><img src="/2023/06/21/comporgan/image-20230618180912414.png" alt="image-20230618180912414"></p>
<p>这个通信方式有哪几种也要求默写了</p>
<p><img src="/2023/06/21/comporgan/image-20230618181827840.png" alt="image-20230618181827840"></p>
<p>这个同步和异步的特点总结得很棒</p>
<p>同步、异步、半同步三者的共同点：</p>
<p><img src="/2023/06/21/comporgan/image-20230618181948854.png" alt="image-20230618181948854"></p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><blockquote>
<p><img src="/2023/06/21/comporgan/wps1-1687346993910-297.jpg" alt="img">定宽定距的时钟</p>
<p>白色菱形代表有地址、命令、数据；紫色阴影代表没有东西</p>
<p>数字电路中，数字电平从低电平（数字“0”）变为高电平（数字“1”）的那一瞬间（时刻）叫作上升沿。数字电平从高电平（数字“1”）变为低电平（数字“0”）的那一瞬间叫作下降沿。</p>
<p>有固定的时间点，和在每个固定时间点固定要做的事</p>
<p>第一部分：主设备要给出地址信号</p>
<p>第二部分：给出读命令（控制信号）</p>
<p>第三部分：从设备传输数据给主设备</p>
<p>第四部分：读命令、数据信号撤销</p>
<p>第五部分：地址信号撤销</p>
<p><img src="/2023/06/21/comporgan/wps2-1687346993911-298.jpg" alt="img"> </p>
<p><em><strong>*先给数据能保证命令到达立刻写入正确数据。菱形那段表示电平并非瞬间稳定*</strong></em></p>
<p><em><strong>*如果数据是并行就先给数据，再给读写信号，直接锁存；如果是串行数据，就先给读写信号，再给数据*</strong></em></p>
<p>有固定的时间点，和在每个固定时间点固定要做的事</p>
<p>第一部分：主设备要给出地址信号</p>
<p>第二部分：主设备给出数据信号</p>
<p>第三部分：主设备给出写入信号</p>
<p>第四部分：写入</p>
<p>第五部分：读命令、数据信号撤销</p>
<p>第六部分：地址信号撤销</p>
</blockquote>
<p>同步通信通常只适用于总线长度短的。</p>
<p>因为是并行总线，总线长度长了很难做到等长，到达设备后就不同步了</p>
<p>因为需要统一时标；总线长，需要迁就最远的设备；读写时间差距大，需要迁就最慢的设备</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p><img src="/2023/06/21/comporgan/image-20230618181416220.png" alt="image-20230618181416220"></p>
<h5 id="不互锁"><a href="#不互锁" class="headerlink" title="不互锁"></a>不互锁</h5><p>CPU从主存读信息</p>
<p>主要用在<strong>单机</strong>不同设备之间的通信中</p>
<h5 id="半互锁"><a href="#半互锁" class="headerlink" title="半互锁"></a>半互锁</h5><p><strong>多机</strong>系统中，某个CPU需要访问共享存储器时</p>
<h5 id="全互锁"><a href="#全互锁" class="headerlink" title="全互锁"></a>全互锁</h5><p>主要用于<strong>网络通信</strong>，如TCP三握手</p>
<h4 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h4><p>输入数据为例：</p>
<p><img src="/2023/06/21/comporgan/image-20230618181924196.png" alt="image-20230618181924196"></p>
<h4 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h4><blockquote>
<p>在子周期2中，从模块实际上从从模块变成了主模板，因为它发起了占用总线的请求。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618182050912.png" alt="image-20230618182050912"></p>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><h3 id="发展概况"><a href="#发展概况" class="headerlink" title="发展概况"></a>发展概况</h3><p><img src="/2023/06/21/comporgan/image-20230619144243913.png" alt="image-20230619144243913"></p>
<p><img src="/2023/06/21/comporgan/image-20230619144359313.png" alt="image-20230619144359313"></p>
<p><img src="/2023/06/21/comporgan/image-20230619144452679.png" alt="image-20230619144452679"></p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="/2023/06/21/comporgan/image-20230619144602504.png" alt="image-20230619144602504"></p>
<blockquote>
<p>① IO指令</p>
<p>操作码相当于标志，标志这个指令是IO的。命令码才算是操作码，指出对IO设备做什么。设备码给出IO设备或者设备中某一个寄存器【端口】的编址。</p>
<p>② 通道指令</p>
<p>通道是小型DMA处理器，可以实现IO设备与主机之间进行信息交互。</p>
<p>通道有自己的控制器，有的通道还有存储器。</p>
<p>通道能够执行由通道指令组成的通道程序。</p>
<p>通常情况下，编程人员在应用程序当中，为了调用外部设备，应用程序中需要增加广义IO指令【这意思是封装吧】。广义IO指令要指出参加数据传输的IO设备、数据传输主存的首地址、传输数据的长度、传输方向。操作系统根据广义IO指令给出的参数以及要求的操作，会编写一个由通道指令组成的通道程序，并且会把程序放到内存或者是通道内存的指定位置，之后启动通道进行工作。</p>
</blockquote>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><h4 id="编址"><a href="#编址" class="headerlink" title="编址"></a>编址</h4><p><img src="/2023/06/21/comporgan/image-20230619144651480.png" alt="image-20230619144651480"></p>
<h4 id="选址和传送"><a href="#选址和传送" class="headerlink" title="选址和传送"></a>选址和传送</h4><p><img src="/2023/06/21/comporgan/image-20230619144727325.png" alt="image-20230619144727325"></p>
<h4 id="联络方式"><a href="#联络方式" class="headerlink" title="联络方式"></a>联络方式</h4><p><img src="/2023/06/21/comporgan/image-20230619144851937.png" alt="image-20230619144851937"></p>
<p><img src="/2023/06/21/comporgan/image-20230619145010236.png" alt="image-20230619145010236"></p>
<h4 id="连接方式-1"><a href="#连接方式-1" class="headerlink" title="连接方式"></a>连接方式</h4><p><img src="/2023/06/21/comporgan/image-20230619145037444.png" alt="image-20230619145037444"></p>
<h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><p><img src="/2023/06/21/comporgan/image-20230619145313853.png" alt="image-20230619145313853"></p>
<h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p><img src="/2023/06/21/comporgan/image-20230619145133293.png" alt="image-20230619145133293"></p>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p><img src="/2023/06/21/comporgan/image-20230619145154206.png" alt="image-20230619145154206"></p>
<p><img src="/2023/06/21/comporgan/image-20230619145214775.png" alt="image-20230619145214775"></p>
<h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p><img src="/2023/06/21/comporgan/image-20230619145252864.png" alt="image-20230619145252864"></p>
<h2 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/06/21/comporgan/image-20230619145414624.png" alt="image-20230619145414624"></p>
<h2 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/06/21/comporgan/image-20230619151239077.png" alt="image-20230619151239077"></p>
<h3 id="功能和组成"><a href="#功能和组成" class="headerlink" title="功能和组成"></a>功能和组成</h3><p><img src="/2023/06/21/comporgan/image-20230619151310223.png" alt="image-20230619151310223"></p>
<p><img src="/2023/06/21/comporgan/image-20230619151421396.png" alt="image-20230619151421396"></p>
<p><img src="/2023/06/21/comporgan/image-20230619151442848.png" alt="image-20230619151442848"></p>
<h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p><img src="/2023/06/21/comporgan/image-20230619151602920.png" alt="image-20230619151602920"></p>
<h2 id="程序查询方式-1"><a href="#程序查询方式-1" class="headerlink" title="程序查询方式"></a>程序查询方式</h2><p><img src="/2023/06/21/comporgan/image-20230619151713642.png" alt="image-20230619151713642"></p>
<p><img src="/2023/06/21/comporgan/image-20230619152130068.png" alt="image-20230619152130068"></p>
<p><img src="/2023/06/21/comporgan/image-20230619152909693.png" alt="image-20230619152909693"></p>
<h2 id="程序中断方式-1"><a href="#程序中断方式-1" class="headerlink" title="程序中断方式"></a>程序中断方式</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h4 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h4><p><img src="/2023/06/21/comporgan/image-20230619153352974.png" alt="image-20230619153352974"></p>
<p><img src="/2023/06/21/comporgan/image-20230619153557165.png" alt="image-20230619153557165"></p>
<h4 id="接口电路"><a href="#接口电路" class="headerlink" title="接口电路"></a>接口电路</h4><p><img src="/2023/06/21/comporgan/image-20230619153715848.png" alt="image-20230619153715848"></p>
<h5 id="中断请求触发器和中断屏蔽触发器"><a href="#中断请求触发器和中断屏蔽触发器" class="headerlink" title="中断请求触发器和中断屏蔽触发器"></a>中断请求触发器和中断屏蔽触发器</h5><p><img src="/2023/06/21/comporgan/image-20230619153949008.png" alt="image-20230619153949008"></p>
<p><img src="/2023/06/21/comporgan/image-20230619154445642.png" alt="image-20230619154445642"></p>
<h4 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h4><p>外部中断一般是<strong>由计算机外设发出的</strong>中断请求，如：键盘中断、打印机中断、定时器中断等。</p>
<p>外部中断一般指io高低电平(下降沿等由寄存器配置)来触发并响应io中断函数。</p>
<h3 id="接口电路-1"><a href="#接口电路-1" class="headerlink" title="接口电路"></a>接口电路</h3><h4 id="排队器"><a href="#排队器" class="headerlink" title="排队器"></a>排队器</h4><p><img src="/2023/06/21/comporgan/image-20230619155014803.png" alt="image-20230619155014803"></p>
<p><img src="/2023/06/21/comporgan/image-20230619155029933.png" alt="image-20230619155029933"></p>
<h5 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h5><p><img src="/2023/06/21/comporgan/image-20230619155054248.png" alt="image-20230619155054248"></p>
<blockquote>
<p>以下介绍的是链式排队器</p>
<ol>
<li>INTR默认为0，取非为1. 经&amp;后整个排队电路为1</li>
<li>当i设备发出请求，INTRi=1，取非为0，经&amp;后变为0，INTPi之后的电路清零，只有i之前的INTP为1</li>
<li>3在一连串的显示为 1 的INTP中，最后一个显示1的设备优先级最高。因为按照我们的分析，是它发出了请求</li>
</ol>
<p>使用与非+非而不是直接与门是因为与非门+非更便宜。</p>
<p>我猜这个意思是，链式排队的话，越前面的优先级越高，现在我们讲的是怎么快速****找出****最高的最前面的是哪一个。之所以为什么越前面的优先级最高，可从这个电路中得知。如果一个东西发出请求，那么它后面的INTPi’都会被置零，因而它肯定比它后面的高级。因此越前面的优先级越高。</p>
<p><a target="_blank" rel="noopener" href="https://www.likecs.com/show-390301.html">https://www.likecs.com/show-390301.html</a> </p>
<p><img src="/2023/06/21/comporgan/wps1-1687348473779-309.jpg" alt="img"> </p>
<p>这个可以验证我的观点。至于这个轮询方式，应该在第三章的总线那边讲过，应该用的是链式查询。 </p>
</blockquote>
<h5 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h5><p>程序查询</p>
<p><img src="/2023/06/21/comporgan/image-20230619155116410.png" alt="image-20230619155116410"></p>
<h4 id="中断向量形成部件"><a href="#中断向量形成部件" class="headerlink" title="中断向量形成部件"></a>中断向量形成部件</h4><h5 id="硬件向量法"><a href="#硬件向量法" class="headerlink" title="硬件向量法"></a>硬件向量法</h5><p><img src="/2023/06/21/comporgan/image-20230619155154822.png" alt="image-20230619155154822"></p>
<h5 id="软件查询法"><a href="#软件查询法" class="headerlink" title="软件查询法"></a>软件查询法</h5><p><img src="/2023/06/21/comporgan/image-20230619161630629.png" alt="image-20230619161630629"></p>
<h4 id="接口电路组成"><a href="#接口电路组成" class="headerlink" title="接口电路组成"></a>接口电路组成</h4><p><img src="/2023/06/21/comporgan/image-20230619161803883.png" alt="image-20230619161803883"></p>
<blockquote>
<p>应该意思就是，参照上面那个程序电路图，首先CPU先发送一个启动IO设备的命令，然后就去忙了。</p>
<p>与此同时，IO接口接到命令开始准备，比如说对DBR的整理【因读写而异】。</p>
<p>IO接口准备完之后会卡在INTR那边，等待CPU的中断查询信号。</p>
<p>CPU本来一直在不断边干自己的活边发送中断查询信号【在每条指令执行阶段的结束前】，终于逮到这个时候发现IO接口已经准备好了，就回复中断响应信号，CPU进入中断周期，执行中断隐指令。</p>
<p>IO接口发出中断请求后就排好队选好设备了，收到CPU的中断响应信号，就给CPU发向量地址，CPU根据地址去内存中找到中断服务程序并开始执行，之后就可以开始数据传输了。</p>
<p>可见这个过程是异步的。</p>
</blockquote>
<h3 id="中断响应（中断处理过程）"><a href="#中断响应（中断处理过程）" class="headerlink" title="中断响应（中断处理过程）"></a>中断响应（中断处理过程）</h3><p><img src="/2023/06/21/comporgan/image-20230619162001376.png" alt="image-20230619162001376"></p>
<p><img src="/2023/06/21/comporgan/image-20230619162057309.png" alt="image-20230619162057309"></p>
<h4 id="IO中断处理过程"><a href="#IO中断处理过程" class="headerlink" title="IO中断处理过程"></a>IO中断处理过程</h4><p><img src="/2023/06/21/comporgan/image-20230619162142239.png" alt="image-20230619162142239"></p>
<p><img src="/2023/06/21/comporgan/image-20230619201800980.png" alt="image-20230619201800980"></p>
<h3 id="单重-多重中断服务流程（CPU）"><a href="#单重-多重中断服务流程（CPU）" class="headerlink" title="单重/多重中断服务流程（CPU）"></a>单重/多重中断服务流程（CPU）</h3><p><img src="/2023/06/21/comporgan/image-20230619201934346.png" alt="image-20230619201934346"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202014591.png" alt="image-20230619202014591"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202106846.png" alt="image-20230619202106846"></p>
<h3 id="中断屏蔽技术（CPU）"><a href="#中断屏蔽技术（CPU）" class="headerlink" title="中断屏蔽技术（CPU）"></a>中断屏蔽技术（CPU）</h3><p><img src="/2023/06/21/comporgan/image-20230619202207357.png" alt="image-20230619202207357"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202219859.png" alt="image-20230619202219859"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202321781.png" alt="image-20230619202321781"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202355070.png" alt="image-20230619202355070"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202434146.png" alt="image-20230619202434146"></p>
<h2 id="DMA方式-1"><a href="#DMA方式-1" class="headerlink" title="DMA方式"></a>DMA方式</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><img src="/2023/06/21/comporgan/image-20230619202548302.png" alt="image-20230619202548302"></p>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p><img src="/2023/06/21/comporgan/image-20230619202628150.png" alt="image-20230619202628150"></p>
<p>沙比</p>
<p><img src="/2023/06/21/comporgan/image-20230619202708423.png" alt="image-20230619202708423"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202739633.png" alt="image-20230619202739633"></p>
<h3 id="功能和组成-1"><a href="#功能和组成-1" class="headerlink" title="功能和组成"></a>功能和组成</h3><p><img src="/2023/06/21/comporgan/image-20230619202841809.png" alt="image-20230619202841809"></p>
<p><img src="/2023/06/21/comporgan/image-20230619203043097.png" alt="image-20230619203043097"></p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><h4 id="DMA传送过程"><a href="#DMA传送过程" class="headerlink" title="DMA传送过程"></a>DMA传送过程</h4><p>预处理、数据传送、后处理</p>
<p><img src="/2023/06/21/comporgan/image-20230619203248171.png" alt="image-20230619203248171"></p>
<p>注意还有个传送字数，看来有点安全设定。如果溢出了就需要中断</p>
<p><img src="/2023/06/21/comporgan/image-20230619203423482.png" alt="image-20230619203423482"></p>
<p><img src="/2023/06/21/comporgan/image-20230619203535039.png" alt="image-20230619203535039"></p>
<h3 id="连接方式-2"><a href="#连接方式-2" class="headerlink" title="连接方式"></a>连接方式</h3><p><img src="/2023/06/21/comporgan/image-20230619204520342.png" alt="image-20230619204520342"></p>
<p><img src="/2023/06/21/comporgan/image-20230619204537086.png" alt="image-20230619204537086"></p>
<h3 id="与程序中断比较"><a href="#与程序中断比较" class="headerlink" title="与程序中断比较"></a>与程序中断比较</h3><p><img src="/2023/06/21/comporgan/image-20230619204641555.png" alt="image-20230619204641555"></p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/08/12/kernel_compile/">内核编译</a>
            
            
            <a class="next" rel="next" href="/2023/06/21/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 修年 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>