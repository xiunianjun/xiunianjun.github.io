<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="修年">





<title>Project1   Buffer Pool | 修年</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiunian&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiunian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc" style="right: -4em;">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Project1   Buffer Pool</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">修年</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">三月 13, 2023&nbsp;&nbsp;22:19:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Project1-Buffer-Pool"><a href="#Project1-Buffer-Pool" class="headerlink" title="Project1   Buffer Pool"></a>Project1   Buffer Pool</h1><p>先放个通关记录~</p>
<p><img src="/2023/03/13/cmu15445/image-20230330235300907.png" alt="image-20230330235300907"></p>
<blockquote>
<p>特别鸣谢：</p>
<p>某不愿透露姓名的友人hhj</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/617466684">大佬的实验过程</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613920859">大佬的性能优化</a></p>
</blockquote>
<blockquote>
<p>During the semester, you will build a <u>disk-oriented</u> storage manager for the <a target="_blank" rel="noopener" href="https://github.com/cmu-db/bustub">BusTub</a> DBMS.</p>
<p>注：DBMS(Database Management System)，比如说Oracle数据库</p>
<p>The first programming project is to implement a <strong>buffer pool</strong> in your storage manager.The buffer pool is responsible for <u>moving physical pages back and forth from main memory to disk</u>.也就是负责物理页从磁盘的读写</p>
<p>It allows a DBMS to support databases that are larger than the amount of memory available to the system. 是的，这其实就跟内存换入换出差不多。我们现在是不是要在用户态实现这个功能？我记得xv6似乎是没有这个机制的。有点小期待呀。不过这部分感觉说不定和xv6的磁盘管理（使用双向链表管理buffer cache），及其的改进版本（lab:locking  使用哈希+双向链表）比较类似。</p>
<blockquote>
<p>注：xv6确实没有内存换入换出机制，其是固定大小的内存空间。但xv6的文件系统有采用LRU算法的buffer cache（怪不得有什么数据库型的文件系统，这两个确实有点像）。</p>
</blockquote>
<p>The buffer pool’s operations are transparent to other parts in the system. For example, the system asks the buffer pool for a page using its unique identifier (<code>page_id_t</code>) and it does not know whether that page is already in memory or whether the system has to retrieve it from disk.</p>
<p><strong>Your implementation will need to be thread-safe</strong>. </p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于这几天时间比较零散+事情比较多，因此完成的总时间数不一定值得参考：26h（乐）</p>
<p>本次实验要说简单也还算简单。大概就是实现一个database与磁盘交换页的buffer pool，机制类似于内存换入换出。而实现这个buffer pool，首先得实现换入换出算法，也即task1的LRU-K算法。再然后就是在我们的LRU-K算法的基础上，实现真正的buffer pool（真正指：真正地存储以及读写磁盘、向外暴露接口），也即<code>BufferPoolManager</code>。最后，我们会实现类似于<code>lock_guard</code>这样结构的<code>PageGuard</code>，用于自动释放页引用和读写锁。最后的最后，我们会对实现的buffer pool进行性能优化，优化方向包括细粒度化锁以实现并行IO、针对特定应用场景调整LRU-K策略等。</p>
<p>这四者都是相互联系相互递进的，我认为每一个task都设计得非常不错，写完了之后对它所涉及的知识点都有了更深刻的理解。我认为其中最优美的一点就是<strong>LRU-K算法与buffer pool的解耦</strong>，这个设计让我十分地赞叹。</p>
<p>最后，再对我的完成情况进行一个评价。本次实验确实内容不是很难【除了性能调优部分，这个我是真不懂QAQ】，毕竟它指导书以及代码注释都给了详细的步骤参考，我之所以做了那么久一是因为我有不好的习惯，就是没认真看指导书和提示就开始按着自己的理解写，然后写完就直接开始debug开始交了；二是因为这几天学业的破事太多、竞赛也逐步开始了，因而战线拉得太长，总耗时就太多了。</p>
<p>因而，吸取经验，我之后coding完了之后，再照着指导书仔仔细细地过一遍自己的代码。同时，15445这个实验我也决定先暂时搁置，毕竟接下来这两个月应该会在竞赛和学业两头转，实在不能抽出很大段时间继续写了。</p>
<p>就酱。</p>
<h2 id="Task1-LRU-K"><a href="#Task1-LRU-K" class="headerlink" title="Task1  LRU-K"></a>Task1  LRU-K</h2><blockquote>
<p>This component is responsible for tracking page usage in the buffer pool.</p>
<p>The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. LRU-K 算法驱逐一个帧，其backward k-distance是替换器中所有帧的最大值。</p>
<p>Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access.  <code>backward k-distance</code>=现在的时间戳 - 之前第k次访问时的时间戳</p>
<p>A frame with fewer than k historical accesses is given +inf as its backward k-distance. 不足k次访问的帧的backward k-distance应该设置为inf（对应上图左边那个访问记录队列吧）</p>
<p>**When multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access, overall, out of all frames).**如果有多个inf的结点，按照LRU规则淘汰（也即上图左边那个历史记录队列采取LRU规则）</p>
<p>The maximum size for the <code>LRUKReplacer</code> is the same as the size of the buffer pool since it contains placeholders for all of the frames in the <code>BufferPoolManager</code>. However, at any given moment, not all the frames in the replacer are considered to be evictable. The size of <code>LRUKReplacer</code> is represented by the number of <em>evictable</em> frames. The <code>LRUKReplacer</code> is initialized to have no frames in it. Then, <u>only when a frame is marked as evictable, replacer’s size will increase</u>.   size为可驱逐的frame数而非所有frame数。</p>
</blockquote>
<h3 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h3><p>本次实验要我们实现的是一个LRU-K算法的页面置换器。</p>
<p>LRU-K算法是对LRU算法和LFU算法的折中优化，平衡了LFU和LRU的性能和开销的同时，也解决了缓存污染问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。具体来说，它维护了一个<code>backward k-distance</code>，其计算方法：</p>
<ol>
<li>如果已经被访问过k次：<code> backward k-distance</code> = <code>current_timestamp_</code> - <strong>倒数第k次</strong>访问的时间戳</li>
<li>如果还没被访问过k次：<code> backward k-distance</code> = +inf</li>
</ol>
<p>页面驱逐规则：</p>
<ol>
<li><p>驱逐<code> backward k-distance</code> 最大的页。</p>
<p>也即情况2总是优先会比情况1被驱逐；每次优先驱逐previous k次访问最早的页面。</p>
</li>
<li><p>当有多个页值为+inf，则采取FIFO规则进行驱逐。</p>
</li>
</ol>
<p>故而，在具体实现中，为了便于管理，我将此拆分为两个队列：</p>
<blockquote>
<p>思路来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhanglong_4444/article/details/88344953">LRU . LFU 和 LRU-K 的解释与区别</a></p>
<p><img src="/2023/03/13/cmu15445/image-20230323205851168.png" alt="image-20230323205851168"></p>
<ol>
<li><p>数据第一次被访问，加入到访问历史列表；</p>
</li>
<li><p>如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p>
</li>
<li><p>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p>
</li>
<li><p>缓存数据队列中被再次访问后，重新排序；</p>
</li>
<li><p>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p>
</li>
</ol>
</blockquote>
<p>每个页面结构持有一个时间戳队列即可：</p>
<p><img src="/2023/03/13/cmu15445/image-20231128152139485.png" alt="image-20231128152139485"></p>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><h4 id="刚coding完"><a href="#刚coding完" class="headerlink" title="刚coding完"></a>刚coding完</h4><p>task1的内容就是实现对一堆<code>frame_id</code>的LRU-K算法管理，挺简单的（也可能是测试用例少我错误没排查出来2333）</p>
<p>我并没有用默认给的模板的<code>unorder_map</code>，也没有用默认给的模板思路（但原理以及最终效果是差不多的，就是没用它的方法），而是选择类似像上面这张图一样，分成两个队列实现，一个队列<code>visit_record_</code>存储那些访问次数&lt;k的数据，另一个队列<code>cache_data_</code>存储那些访问次数&gt;=k的顺序，每次优先淘汰<code>visit_record_</code>中的数据，<u>两个队列都采用LRU的方式管理。与此同时，我觉得LRU管理时间戳只用记录最新访问的就行，所以将历史访问时间戳队列改成了只有一个变量。</u></p>
<h4 id="终于通过online-test"><a href="#终于通过online-test" class="headerlink" title="终于通过online-test"></a>终于通过online-test</h4><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_63848007/article/details/125426740">FIFO和LRU</a>这里面的实例非常直观地说明了两种算法的差异，可以跟着手推感受一下</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Altair_alpha/article/details/127745308">pro1</a>这个用的是我上面的那个想法，是错的。但是评论很值得参考：</p>
<p><img src="/2023/03/13/cmu15445/image-20230329230045194.png" alt="image-20230329230045194"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hrbust_cxl/article/details/127138778">pro1</a>这个评论的“偷测试用例”xswl，虽然这次没用，但以后说不定能用上：</p>
<p><img src="/2023/03/13/cmu15445/image-20230329230139300.png" alt="image-20230329230139300"></p>
</blockquote>
<h5 id="正确思路-1"><a href="#正确思路-1" class="headerlink" title="正确思路"></a>正确思路</h5><p>……简单个屁！！</p>
<p>算法上，上面错误的算法确实很简单；而正确的算法也确实很简单。那么难的是什么呢？我觉得难的还是搞清楚它要我们实现的究竟是上面东西。</p>
<p>结合指导书这段话：</p>
<blockquote>
<p>The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. 每次驱逐<code> backward k-distance</code>最大的</p>
<p>那么<code> backward k-distance</code>是什么？</p>
<p>Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. <code> backward k-distance</code> = <code>current_timestamp_</code> - <strong>倒数第k次</strong>访问的时间戳</p>
<p>A frame with fewer than k historical accesses is given +inf as its backward k-distance. 没有达到k次访问的，<code> backward k-distance</code>为+inf。也就是说，每次优先从历史访问队列清除元素。</p>
<p>【**When multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access, overall, out of all frames).**】当历史访问队列有多个元素，就驱逐英文描述那样的frame。</p>
</blockquote>
<p>我们可以发现，它这个对于两个队列的LRU，并非我们原来算法那样，对于每个frame，针对其最新的访问时间戳，也即<code>history_.back()</code>，进行LRU淘汰；而是，针对其倒数第k新的访问记录，也即<code>history_.front() &amp;&amp; history_.size()&lt;=k</code>，进行LRU淘汰。</p>
<p>其中，由于历史访问队列的记录少于k个，<u>因而其事实上从k-distance算法退化为了FIFO算法</u>。【感受一下这一点的优美：FIFO实际上是k-distance的特例】</p>
<p>我们上面的算法比较的是<code>history_.back()</code>，所以可以省略时间戳队列为一个变量，然后将两个队列使用FILO的形式组织起来。正确算法就不能这么简单了，要按front排序的话，实现开销可能更大，所以下面就采用了map形式来实现logn的查找。</p>
<h5 id="关于LRU的翻译"><a href="#关于LRU的翻译" class="headerlink" title="关于LRU的翻译"></a>关于LRU的翻译</h5><p>这里一个点我其实还是很疑惑的，完全想不通。</p>
<p>就是，对缓存队列实现k-distance算法没毛病，这段话已经写得很清楚了。</p>
<blockquote>
<p>Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. <code> backward k-distance</code> = <code>current_timestamp_</code> - <strong>倒数第k次</strong>访问的时间戳</p>
</blockquote>
<p>但是，为什么历史访问队列要用FIFO呢？是我英语不好吗，这段话不是实现纯正LRU的意思吗：</p>
<blockquote>
<p>【**When multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access, overall, out of all frames).**】当历史访问队列有多个元素，就驱逐英文描述那样的frame。</p>
</blockquote>
<p>我翻译一下：</p>
<p>当多个frame有+inf这个<code> backward k-distance</code>的时候，replacer需要驱逐拥有全部（overall）frame中最早的timestamp的frame。（也就是说，frame，它的最近访问记录是所有frame里面最早的）</p>
<p>这样确实看起来就是要用LRU。</p>
<p>但其实，是我英语不好。咨询了场外热心人士hhj之后，我才修订出了如下版本：</p>
<p>当多个frame有+inf这个<code> backward k-distance</code>的时候，replacer需要驱逐拥有全部（overall）frame中最早的timestamp的frame。（也就是说选择一个frame，这个frame的<strong>最不近</strong>的访问记录，是所有frame中最近最少访问的）【也即这个frame的history的front是所有frame中最早的，也即使用FIFO算法】</p>
<p>可见，正确解法确实是没问题的，就是理解上很困难。要是可以配个实例就好了QAQ</p>
<p>所以说，所谓LRU（Least Recently Used）的直译还是最不近使用，也即最近最少使用。里面这个least不是用来修饰recent表示recent程度深的，相反它表示的是recent的程度浅。英语不好的惨痛教训啊。</p>
<p><img src="/2023/03/13/cmu15445/image-20230330160207757.png" alt="image-20230330160207757"></p>
<p>最后一下子交了这么多次才过。绷不住了。</p>
<h2 id="Task2-BufferPoolManager"><a href="#Task2-BufferPoolManager" class="headerlink" title="Task2   BufferPoolManager"></a>Task2   BufferPoolManager</h2><blockquote>
<p>The <code>BufferPoolManager</code> is responsible for fetching database pages from the <code>DiskManager</code> and storing them in memory.从DiskManager中取出页，然后存入内存。</p>
<p>也就是说，我们的Buffer Pool是磁盘到内存的映射，我们在Task1实现了内存部分的管理数据结构？</p>
<p>The <code>BufferPoolManager</code> can also write dirty pages out to disk when it is either explicitly instructed to do so or when it needs to evict a page to make space for a new page.也要负责dirty页的写回</p>
<p>You will also not need to implement the code that actually reads and writes data to disk (this is called the <code>DiskManager</code> in our implementation). We will provide that functionality. <code>DiskManager</code>已给出</p>
<p>All in-memory pages in the system are represented by <code>Page</code> objects.  Each <code>Page</code> object contains a block of memory that the <code>DiskManager</code> will use as a location to copy the contents of a <strong>physical page</strong> that it reads from disk. <code>Page</code> 是可复用的内存页容器</p>
<p>The <code>Page</code> object’s identifer (<code>page_id</code>) keeps track of what physical page it contains; if a <code>Page</code> object does not contain a physical page, then its <code>page_id</code> must be set to <code>INVALID_PAGE_ID</code>.</p>
<p>也就是说，<code>page_id</code>表示的是实际的物理页号；<code>frame_id</code>表示的是你的Page容器的序号，同时也是LRU的对象。你需要一个类似<code>&lt;fid, pid&gt;</code>这样的map来记录这二者的映射。具体是通过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Array of buffer pool pages. */</span></span><br><span class="line">Page *pages_; <span class="comment">// &lt;fid, pid&gt;</span></span><br><span class="line"><span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_; <span class="comment">// &lt;pid, fid&gt;</span></span><br></pre></td></tr></table></figure>

<p>Each <code>Page</code> object also maintains a counter for the number of threads that have “pinned” that page. Your <code>BufferPoolManager</code> is not allowed to free a <code>Page</code> that is pinned. 有引用计数机制</p>
<p>Each <code>Page</code> object also keeps track of whether it is dirty or not. It is your job to record whether a page was modified before it is unpinned.  Your <code>BufferPoolManager</code> must write the contents of a dirty <code>Page</code> back to disk before that object can be reused.需要track dirty，并且这是你要干的；要写回，这也是你要干的</p>
<p>Your <code>BufferPoolManager</code> implementation will use the <code>LRUKReplacer</code> class that you created in the previous steps of this assignment. The <code>LRUKReplacer</code> will keep track of when <code>Page</code> objects are accessed so that it can decide which one to evict when it must free a frame to make room for copying a new physical page from disk. When mapping <code>page_id</code> to <code>frame_id</code> in the <code>BufferPoolManager</code>, again be warned that STL containers are not thread-safe.</p>
</blockquote>
<h3 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h3><h4 id="刚coding完-1"><a href="#刚coding完-1" class="headerlink" title="刚coding完"></a>刚coding完</h4><p>task2说得比较复杂，实现的函数较多，实际coding细节也比较繁琐，但debug倒是很轻松。</p>
<p>主要内容就是实现<code>BufferPoolManager</code>，在task1实现的LRU-K算法的基础上，写具体的内存换入换出的接口逻辑。</p>
<p>再次回顾我们整个project1的目的：实现一个从磁盘到内存的buffer。task1只是实现了一个内存页换入换出的LRU-K算法部分，task2则基于算法部分，实现了具体与上层交互的像样的逻辑。</p>
<p>我认为这其中一个亮点就是，它非常完美地将LRU-K算法和具体的上层逻辑进行了<strong>解耦</strong>。LRU-K只需关注如何将这一堆<code>freme_id</code>组织起来组织好，而无需关心具体内存页存放在哪，以及对应frame淘汰之后内存页又何去何从，因为这些逻辑都会由上层实现；而上层逻辑也无需关心具体的淘汰页算法【LRU-K/LRU/LFU，只需替换replacer_就可以替换换入换出策略】，而只需打好evictable标记，并且在调用evict方法之后做好后处理（如内存释放等等等）即可。</p>
<p>这其中有一个小细节也值得借鉴，即从<code>page_id_</code>到<code>frame_id_</code>的转化。<code>frame_id_</code>有界，比较方便LRU-K算法实现，并且进行了LRU-K算法的容量控制，同时由于算法和上层逻辑的容量相同，故而也是<code>pages_</code>的索引号；而<code>page_id_</code>不能有界，因为实际上访问到的物理页不可能只共享<code>pool_size_</code>个序列号。故而在这样解耦实现的基础上，二者缺一不可。</p>
<p>还有<code>frame_id_</code>的复用，它是采用了类似我们日常生活中取号那样，要用号时从队列头取，不用号时塞回队列尾就行，这种方式我觉得还挺有意思。</p>
<p>其他部分虽然步骤繁杂，但理解难度不高，而且它提示得也很保姆了，所以不多bb。</p>
<h4 id="通过online-test"><a href="#通过online-test" class="headerlink" title="通过online-test"></a>通过online-test</h4><p>确实算简单了，我主要倒在没有认真看它的需求，这应该是语文问题（绷</p>
<p>一个是<code>FetchPage</code>这里：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330162812680.png" alt="image-20230330162812680"></p>
<p>如果所求物理页存在于buffer pool，直接返回+record access即可，不用再写回+读入。因为它的提示这边：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330162941774.png" alt="image-20230330162941774"></p>
<p>这个是句号。也就是说后面那些写回啊read啊，是没找到时才做的，不是并列关系。</p>
<p>这也很合理，毕竟你找到所需页就说明不用从磁盘读入，也即找到所需页=直接返回即可。</p>
<p>另一个是<code>UnpinPage</code>这里：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330163031739.png" alt="image-20230330163031739"></p>
<p>不应该写<code>is_dirty_ = is_dirty</code>，因为它的提示这边：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330163058921.png" alt="image-20230330163058921"></p>
<p>可见参数<code>is_dirty</code>为true是需要设置为dirty，为false的话没有别的意义，保持原来值就行。</p>
<p>还有一个就是，在<code>Page</code>类中声明了friend：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330163337929.png" alt="image-20230330163337929"></p>
<p>故而<code>BufferPoolManager</code>可以直接访问<code>Page</code>的私有成员变量，而无需手动为<code>Page</code>添加Getter/Setter方法。</p>
<h2 id="Task3-Page-Guard"><a href="#Task3-Page-Guard" class="headerlink" title="Task3   Page Guard"></a>Task3   Page Guard</h2><p>这是要写我们在上面用的那个PageGuard？这让我想起了Lab0的<code>ValueGuard</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValueGuard</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ValueGuard</span>(Trie root, <span class="type">const</span> T &amp;value) : <span class="built_in">root_</span>(std::<span class="built_in">move</span>(root)), <span class="built_in">value_</span>(value) &#123;&#125;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>*() <span class="type">const</span> -&gt; <span class="type">const</span> T &amp; &#123; <span class="keyword">return</span> value_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Trie root_;</span><br><span class="line">  <span class="type">const</span> T &amp;value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不过其实这两个是不一样的。本次要实现的Page Guard的语义更类似<code>lock_guard</code>。</p>
<blockquote>
<p>我们需要手动调用<code>UnpinPage</code>，但这中就跟new/delete、malloc/free一样都要靠人脑来记住，不大安全。</p>
<p>You will implement <code>BasicPageGuard</code> which store the pointers to <code>BufferPoolManager</code> and <code>Page</code> objects. <u>A page guard ensures that <code>UnpinPage</code> is called on the corresponding <code>Page</code> object as soon as it goes out of scope.</u> 【也许这需要在析构函数中实现？】Note that it should <strong>still</strong> expose a method for a programmer to manually unpin the page.仍然需要提供UnPin方法。</p>
<p>As <code>BasicPageGuard</code> hides the underlying <code>Page</code> pointer, it can also provide read-only/write data APIs that provide <strong>compile-time checks</strong> to ensure that the <code>is_dirty</code> flag is set correctly for each use case.这个思想很值得学习。</p>
<p>In the future projects, multiple threads will be reading and writing from the same pages, thus reader-writer latches are required to ensure the correctness of the data. Note that in the <code>Page</code> class, there are relevant latching methods for this purpose. Similar to unpinning of a page, a programmer can forget to unlatch a page after use. To mitigate the problem, you will implement <code>ReadPageGuard</code> and <code>WritePageGuard</code> which automatically unlatch the pages as soon as they go out of scope.</p>
</blockquote>
<h3 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h3><p>怎么说，其实只用仔细看相关文档和它的要求就不难，但你懂的我的尿性就是不细看文档，所以这里我也用gdb调了蛮久才过的。正确思路没什么好说的，直接记录下我觉得比较有意义的错误吧。</p>
<h4 id="错误集锦"><a href="#错误集锦" class="headerlink" title="错误集锦"></a>错误集锦</h4><h5 id="析构函数的调用"><a href="#析构函数的调用" class="headerlink" title="析构函数的调用"></a>析构函数的调用</h5><p><img src="/2023/03/13/cmu15445/image-20230330233252372.png" alt="image-20230330233252372"></p>
<p>在这个用例中，退出“}”会调用两次析构函数。</p>
<h5 id="奇怪的死锁"><a href="#奇怪的死锁" class="headerlink" title="奇怪的死锁"></a>奇怪的死锁</h5><h6 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h6><p>我在coding的过程中，遇到了一个很神奇的死锁现象。</p>
<p>在这里<code>page-&gt;WLatch();</code>这句会死锁，而且还是在第一次调用<code>FetchWritePage()</code>时死锁的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WritePageGuard</span>(BufferPoolManager *bpm, Page *page) : <span class="built_in">guard_</span>(bpm, page) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是添加了一句<code>page-&gt;WUnlatch();</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WritePageGuard</span>(BufferPoolManager *bpm, Page *page) : <span class="built_in">guard_</span>(bpm, page) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它就不会死锁了。</p>
<p>这很奇怪，到底是发生了什么？我用GDB调了半天，在<code>RWLatch.WLock()</code>处打了断点，也没发现在这之前有调用过lock()。于是我就去看了下<code>std::shared_mutex</code>的官方文档（当然，这中间想了很久也不知道怎么办）：</p>
<p><img src="/2023/03/13/cmu15445/image-20230331222601644.png" alt="image-20230331222601644"></p>
<p>我就怀疑是不是我哪里写错了，所以就干了这种undefined的事，然后就导致死锁了。于是我写了个测试程序：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330195418370.png" alt="image-20230330195418370"></p>
<p>发现，当在调用<code>WLock</code>（也即<code>std::shared_mutex::lock()</code>）之前，如果多调了一次<code>XUnlock</code>（也即<code>std::shared_mutex::unlock()</code>或者<code>std::shared_mutex::unlock_shared()</code>），就会卡住。</p>
<p>这说明确实发生了不匹配问题。于是我就在<code>Page</code>中添加了两个成员变量用来记录上锁和解锁的次数，并且在gurad test中打印了出来，结果发现：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330233018049.png" alt="image-20230330233018049"></p>
<p>确实发生了不匹配问题，是在这里:</p>
<p><img src="/2023/03/13/cmu15445/image-20230330233252372.png" alt="image-20230330233252372"></p>
<p>之后用gdb调下就发现错误了，不赘述了。</p>
<h6 id="另外的想法"><a href="#另外的想法" class="headerlink" title="另外的想法"></a>另外的想法</h6><p>在出现死锁问题时，我是想着，会不会是测试程序中，对同一页获取了一次<code>ReadGuardPage</code>对象之后，再对同一页获取<code>Read/WriteGuardPage</code>导致的呢？于是我就开始思考如何防范这个流程，最后写下了这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageRead</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; ReadPageGuard </span>&#123;</span><br><span class="line">  Page *page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="type">bool</span> should_release = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!page-&gt;rwlatch_.<span class="built_in">try_lock_shared</span>()) &#123;</span><br><span class="line">    <span class="comment">// 说明此时已有read/write锁</span></span><br><span class="line">    should_release = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, pagei, should_release&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageWrite</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; WritePageGuard </span>&#123;</span><br><span class="line">  Page *page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="type">bool</span> should_release = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!page-&gt;rwlatch_.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">    <span class="comment">// 获取write锁失败，可能原因：该进程持有write锁、别的进程有read锁、该进程持有read锁</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;rwlatch_.<span class="built_in">try_lock_shared</span>()) &#123;</span><br><span class="line">      <span class="comment">// 成功read，说明是别的进程有read锁</span></span><br><span class="line">      page-&gt;rwlatch_.<span class="built_in">unlock_shared</span>();</span><br><span class="line">      <span class="comment">// 等待</span></span><br><span class="line">      page-&gt;rwlatch_.<span class="built_in">lock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 说明当前进程有read/write锁</span></span><br><span class="line">      should_release = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, pagei, should_release&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但很遗憾的是，我发现是无法区分当前进程持有write还是read锁的。也许有别的办法但我没想起来。</p>
<p>总之，我认为这段代码还是很有参考价值的，姑且放着先。</p>
<h2 id="Task4-性能调优"><a href="#Task4-性能调优" class="headerlink" title="Task4   性能调优"></a>Task4   性能调优</h2><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/644160340">CMU 15-445 2023 P1 优化攻略 [rank#3]</a>  写得非常细致，思路很清晰</p>
<p> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/617466684">CMU 15-445 Project 1 (Spring 2023) 优化记录</a></p>
</blockquote>
<blockquote>
<p>我的实现有一些并发小问题，详见lab2的并发部分~</p>
</blockquote>
<p>lru-k的算法优化是自己想的，并行IO的优化思路全部来自 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/617466684">CMU 15-445 Project 1 (Spring 2023) 优化记录</a>，我只是把这位大佬的思路自己实现了一遍。感觉还是太菜了，面对这种实际场景毫无还手之力一点思路没有QAQ但正是如此，这个细粒度化锁的小task才值得学习。</p>
<p>放上优化前后性能对比：</p>
<p><img src="/2023/03/13/cmu15445/image-20230331000020775.png" alt="image-20230331000020775"></p>
<p><img src="/2023/03/13/cmu15445/image-20230404140838247.png" alt="image-20230404140838247"></p>
<h3 id="Better-replacer-algorithm"><a href="#Better-replacer-algorithm" class="headerlink" title="Better replacer algorithm"></a>Better replacer algorithm</h3><blockquote>
<p>In the leaderboard test, we will have multiple threads accessing the pages on the disk. There are two types of threads running in the benchmark:在具体的benchtest中，可以分为两类线程。</p>
<ol>
<li>Scan threads. Each scan thread will update all pages on the disk <u>sequentially</u>. There will be 8 scan threads.</li>
<li>Get threads. Each get thread will randomly select a page for access using the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Zipf's_law">zipfian distribution</a>. There will be 8 get threads.</li>
</ol>
<p>Given that get workload is skewed（有偏向性的）(i.e., some pages are more frequently accessed than others), you can design your LRU-k replacer to <u>take page access type into consideration</u>, so as to reduce page miss.</p>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>我们可以回想起当初选择LRU-K而不选择LRU算法的原因：缓存污染。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43237362/article/details/121619601">LRU 一种缓存淘汰算法</a></p>
<p>缓存污染：</p>
<p>LRU因为只需要一次访问就能成为最新鲜的数据，当出现很多偶发数据时，这些偶发的数据也会被当作最新鲜的，从而成为缓存。但其实这些偶发数据以后并不会是被经常访问的。</p>
</blockquote>
<p>而在这里也是同理。我们的benchtest中，scan线程是顺序地访问磁盘上所有页，而get线程是遵从zip分布地访问，显然get线程的access记录比scan线程的有价值的多，并且scan线程的数据是很容易污染get线程的。</p>
<p>所以，我的解决方法是，如果某个页被第一次访问，且该访问方式为SCAN，则RecordAccess进入历史访问队列；如果某个页不是被第一次访问，且访问方式为SCAN，则不做任何处理。不用修改UnpinPage的处理方式。</p>
<h3 id="Parallel-I-O-operations"><a href="#Parallel-I-O-operations" class="headerlink" title="Parallel I/O operations"></a>Parallel I/O operations</h3><blockquote>
<p>Instead of holding a global lock when accessing the disk manager【不要在访问<code>disk_manager_</code>的时候使用bpm的全局锁<code>latch_</code>】, you can issue multiple requests to the disk manager at the same time. This optimization will be very useful in modern storage devices, where concurrent access to the disk can make better use of the disk bandwidth.</p>
</blockquote>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>详细的解决方法<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/617466684">大佬</a>这边已经说得很清楚了，接下来我就对其总体的做法进行一点总结，加上一些个人理解。</p>
<p>我刚看到这个需求的时候是这么做的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pages_[fid].<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[fid].<span class="built_in">GetPageId</span>(), pages_[fid].<span class="built_in">GetData</span>());</span><br><span class="line">    latch_.<span class="built_in">lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即在原来代码的基础上做简单的改动，每次执行到涉及磁盘读写的地方，就暂时地开一下锁。但其实这样是不行的，当多个线程访问bpm，线程A在这里开锁执行Write，线程B正好得到锁，然后对<code>pages_[fid]</code>执行比如说ResetMemory操作，这样就寄了。</p>
<p>所以，在磁盘读写的时候，我们仍然需要使用锁保护，只不过我们需要选择粒度更细的锁。这时我们就可以想到在<code>page_guard</code>里常用的page自带的锁。在这里用page锁，既能够锁保护，又符合语义，看起来非常完美：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pages_[fid].<span class="built_in">WLatch</span>();</span><br><span class="line">latch_.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">if</span> (pages_[fid].<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[fid].<span class="built_in">GetPageId</span>(), pages_[fid].<span class="built_in">GetData</span>());</span><br><span class="line">&#125;</span><br><span class="line">latch_.<span class="built_in">lock</span>();</span><br><span class="line">pages_[fid].<span class="built_in">WUnlatch</span>();</span><br></pre></td></tr></table></figure>

<p>但由于我们在return<code>page_guard</code>的时候会获取锁，因而在这样的情况下，会发生死锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> reader_guard_1 = bpm-&gt;<span class="built_in">FetchPageRead</span>(page_id_temp);</span><br><span class="line"><span class="keyword">auto</span> reader_guard_2 = bpm-&gt;<span class="built_in">FetchPageRead</span>(page_id_temp);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里我们首先获取<code>reader_guard_1</code> ，持有了该 page 的读锁，并允许其他线程读；但在获取<code>reader_guard_2</code>时，<code>FetchPage</code>会在释放 bpm 写锁前，请求该 page 的写锁；但由于<code>reader_guard_1</code>已经申请了该 page 的读锁，就会造成死锁，与预期结果不符。</p>
</blockquote>
<p>因而，我们就可以选择在bpm内部，单独为pages_数组的每一页都维护一个锁，在每个对page页属性进行读写的地方进行锁定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_mutex latch_;</span><br><span class="line">std::vector&lt;std::mutex&gt; pages_latch_;</span><br></pre></td></tr></table></figure>

<p>然后对代码进行重排序，尽量分离bpm内部成员和page内部成员属性的修改：（以<code>FetchPage</code>为例）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPage</span><span class="params">(<span class="type">page_id_t</span> page_id, [[maybe_unused]] AccessType access_type)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">frame_id_t</span> fid;</span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Evict</span>(&amp;fid)) &#123; ... &#125;</span><br><span class="line">    <span class="comment">// 这些地方不涉及对page的读写，只涉及对bpm内部成员的读写</span></span><br><span class="line">    page_table_.<span class="built_in">erase</span>(page_table_.<span class="built_in">find</span>(pages_[fid].<span class="built_in">GetPageId</span>()));</span><br><span class="line">    page_table_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(page_id, fid));</span><br><span class="line"></span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(fid, access_type);</span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(fid, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个锁的交接点</span></span><br><span class="line">    pages_latch_[fid].<span class="built_in">lock</span>();</span><br><span class="line">    latch_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pages_[fid].<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[fid].<span class="built_in">GetPageId</span>(), pages_[fid].<span class="built_in">GetData</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Page *res = &amp;(pages_[fid]);</span><br><span class="line">    res-&gt;page_id_ = page_id;</span><br><span class="line">    res-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, res-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">    res-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    res-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pages_latch_[fid].<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这些地方不涉及对page的读写，只涉及对bpm内部成员的读写</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid = free_list_.<span class="built_in">front</span>();</span><br><span class="line">  free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">  page_table_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(page_id, fid));</span><br><span class="line"></span><br><span class="line">  replacer_-&gt;<span class="built_in">RecordAccess</span>(fid, access_type);</span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(fid, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两个锁的交接点</span></span><br><span class="line">  pages_latch_[fid].<span class="built_in">lock</span>();</span><br><span class="line">  latch_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  Page *res = &amp;(pages_[fid]);</span><br><span class="line">  res-&gt;page_id_ = page_id;</span><br><span class="line">  res-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, res-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  res-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  res-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  pages_latch_[fid].<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他地方也是一样。就不多赘述了。</p>
<h5 id="一个小地方"><a href="#一个小地方" class="headerlink" title="一个小地方"></a>一个小地方</h5><p>当外界需要对页进行读写时，需要使用page自带的锁；而当bpm内部需要对页进行读写时，则使用的是bpm内部自带的页锁。</p>
<p>这句话说完，相信危险性已经显而易见了：我们使用了两把不同的锁维护了同一个变量！而且可能会有两个线程分别持有这两个锁，对这个变量并发更新！</p>
<p>但其实，在当前这个场景，这么做是没问题的。</p>
<p>外界实质上只能对page的data字段进行读写。因而，有上述危险的，实质上就只有bpm中会对data字段进行改变的地方，也即<code>bpm::NewPage()</code>、<code>bpm::FetchPage()</code>、<code>bpm::DeletePage()</code>这三个地方。</p>
<p>而在前两个地方，我们会使用到的page都是闲置/已经被释放的页，因而外界不可能，也即不可能有别的线程，会持有page的锁并且对其修改；同样的，在第三个地方，我们会使用的page也是pincount==0的页，仅有当前线程在对其进行读写。</p>
<p>因而，综上所述，这样做是并发安全的。</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/03/13/cmu15445$lab0/">Project0   C++ Primer</a>
            
            
            <a class="next" rel="next" href="/2023/03/10/%E5%AF%B9moore%E5%9E%8B%E5%92%8Cmealy%E5%9E%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E7%90%86%E8%A7%A3/">状态机</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 修年 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>