<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="修年">





<title>Project0   C++ Primer | 修年</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiunian&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiunian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc" style="right: -4em;">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Project0   C++ Primer</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">修年</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">三月 13, 2023&nbsp;&nbsp;22:19:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Project0-C-Primer"><a href="#Project0-C-Primer" class="headerlink" title="Project0   C++ Primer"></a>Project0   C++ Primer</h1><p>相比于fall2022（Trie），<u>spring2023（COW-Trie）的难度更大，算法更复杂</u>【毕竟是要实现一个cow的数据结构】，我认为两个都很有意义，故而两个都做了。</p>
<p>其中在Trie中，由于我是第一次接触cpp，所以遇到了很多麻烦。好在经过18h+的cpp拷打后，cow-trie虽然难度大，语法也更复杂一些，但我还是很快（话虽如此也花了7、8小时23333）就完美pass了。不过效率可能还是不大高，毕竟我不熟悉cpp，很多地方可能都直接拷贝了emm希望后续学习可以加把劲。</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><blockquote>
<p>In this project, you will implement a key-value store backed by a concurrent <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Trie">trie</a>. 实现并发安全的trie</p>
<p>To simplify the explaination, we will assume tha the keys are all <u>non-empty</u> <u>variable-length</u> <strong>strings</strong> but in practice they can be any arbitrary type.  key为非空变长字符串</p>
<p>The key-value store you will implement can store string keys mapped to values of any type. key必须是字符串类型，但value可以是任意类型</p>
<p>The value of a key is stored in the node representing the <strong>last</strong> character of that key.</p>
<p><img src="/2023/03/13/cmu15445/image-20230312150245669.png" alt="image-20230312150245669"></p>
</blockquote>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>本次实验完成时间总计18h+。是的，lab0就做了这么久【难绷】</p>
<p>其实光就实验内容来看，无非就是实现trie树，算法上没有很难，最难的应该是Remove函数的编写，因为它是个递归。</p>
<p>但正如本次实验的主题<code>C++ Primer</code>所揭示的那样，本次实验的真正难点在于C++……而在接触本实验之前，我对c++<u>一无所知</u>。</p>
<p>除了这个萌新debuf之外，我还不小心犯了另一件非常sb的乌龙，加上对cpp实在是太小白了，再加上这几天破事又贼多，更是让我心态大崩，差点一蹶不振不想写了（。</p>
<p>因而，整个实验在我看来<strong>十分痛苦</strong>。coding阶段，就是 语法错误-看了半天报错信息才发现哪错了-改错误-改得不对-再改-再改-再改……这样的痛苦过程在循环往复；运行阶段，就是看着stack trace发呆、用gdb调来调去还不知道为什么错了这样的痛苦过程在循环往复。好在，我还是坚持下来了，虽然内心还是很浮躁很浮躁（</p>
<p>不过总而言之，我认为这次实验给我收获挺大的。它帮助我熟悉了C++，但我认为更重要的，是它帮我矫正了心态。做这个实验之前，我内心是很浮躁的（那会破事太多了），而且因为它是lab0所以有点轻敌（对不起。。），因而我所采取的策略是“错误驱动”，也即哪里报错就百度下怎么改就行。这样的心态就导致我的debug过程极度痛苦，因为完全看不懂报错信息，压根不知道错在哪里，百度也百度不出来。于是我被迫修改了战略，去看了我一直不想看的书，学了我一直很害怕的cpp，用了我一直很抗拒的gdb调试，才发现其实都没有我想象的这么恐怖。这期间、这几天的种种心路历程，我认为是十分可贵的。</p>
<h4 id="错误集锦"><a href="#错误集锦" class="headerlink" title="错误集锦"></a>错误集锦</h4><h5 id="sb错误"><a href="#sb错误" class="headerlink" title="sb错误"></a>sb错误</h5><p>我下载下来starter code的时候，发现找不到它要我们实现的<code>p0_trie.h</code>，只有这几个：</p>
<p><img src="/2023/03/13/cmu15445/image-20230318154940622.png" alt="image-20230318154940622"></p>
<p>我便觉得可能是实验代码改版了。但是我<strong>并没有多想</strong>，我觉得可能只是代码模板改版了但实验内容不变QAQ【为什么会这么觉得呢？因为我看到指导书的url为fall2022便以为这是最新版指导书，没有想到春季学期也可以开课，还有个spring2023呃呃】而且代码看起来也确实是要我们实现Trie树【虽然跟指导书说得不大一样】。故而，我就这么直接开干了。</p>
<p>写完了Tire树的逻辑【这部分确实挺简单的】之后，我就开始了漫长的痛苦且折磨的原地兜圈之旅。由于真正的spring2023的代码模板是实现COW-Trie，故而代码模板中很多地方都使用了const关键字，包括树结点以及树的children_成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in class Trie</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; root_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">auto</span> <span class="title">Get</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> T *</span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">auto</span> <span class="title">Put</span><span class="params">(std::string_view key, T value)</span> <span class="type">const</span> -&gt; Trie</span>;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Remove</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; Trie</span>;</span><br><span class="line"><span class="comment">// in class TrieNode</span></span><br><span class="line">  std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;&gt; children_;</span><br></pre></td></tr></table></figure>

<p>如上是spring2023的代码模板。</p>
<p>如果使用其给我们提供的COW-Tire接口来实现Trie树，就会产生巨大的矛盾。你无法在<code>root_</code>的孩子中插入或者删除一个树节点，因为<code>root_</code>指向一个const对象，其<code>children_</code>域也是const的。同样的，你也无法对<code>root_</code>的孩子的孩子集合做增删结点操作，因为它也是const的。</p>
<p>由于对C++不熟悉，通过满屏幕的报错从而搞清楚上面那些东西这件事，就花费了我很多很多时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: no matching function <span class="keyword">for</span> call to </span><br><span class="line">    ‘std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> bustub::TrieNode&gt; &gt;</span><br><span class="line">    ::<span class="built_in">insert</span>(std::pair&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> bustub::TrieNode&gt; &gt;) <span class="type">const</span>’</span><br></pre></td></tr></table></figure>

<p>比如说这个错误我就看了半天完全不知道啥意思（</p>
<p>好在明白上面这点后，我很快就发现了spring2023的存在，然后切到了fall2022的正确分支【乐】</p>
<p>经过了此乌龙后，我深刻地意识到了我对C++一窍不通的程度（，比如说上面的这些const，还有比如说&amp;是什么东西&amp;&amp;又是什么东西，shared_ptr又是什么东西等等等，我都不懂。故而，我压制了内心的浮躁，去简单看了一下书，了解了new的作用、左值引用右值引用、move、智能指针这几个地方，然后再去重新开始写本实验，最终果然好了不少。</p>
<h5 id="错误使用unique-ptr-get"><a href="#错误使用unique-ptr-get" class="headerlink" title="错误使用unique_ptr::get"></a>错误使用unique_ptr::get</h5><p>在<code>Trie::GetValue</code>中，我本来是这么写的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	std::unique_ptr&lt;TrieNode&gt;* t = &amp;root_;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	std::unique_ptr&lt;TrieNodeWithValue&lt;T&gt;&gt; <span class="built_in">tmp</span>(<span class="keyword">dynamic_cast</span>&lt;TrieNodeWithValue&lt;T&gt; *&gt;(t-&gt;<span class="built_in">get</span>()));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就会导致，tmp和(*t)会指向同一块内存区域，并且它们都是<code>unique_ptr</code>。随后，代码块遇到<code>&#125;</code>结束，tmp的析构函数被调用，那块内存区域被free，但(*t)依然指向那块内存区域，随后在释放整个Trie树时这块区域就会被再次释放，然后寄（</p>
<h5 id="共享unique-ptr"><a href="#共享unique-ptr" class="headerlink" title="共享unique_ptr"></a>共享unique_ptr</h5><p>有一个方法可以在不剥夺某个<code>unique_ptr</code>的所有权的同时，又能用另一个变量来操作该指针所指向的对象。这个方法就是——使用指向<code>unique_ptr</code>的指针（。</p>
<p>也即比如：<code>std::unique_ptr&lt;TrieNode&gt; *</code></p>
<h5 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h5><p>本次实验还格外要求了代码规范问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make format</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make check-lint</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make check-clang-tidy-p0</span></span><br></pre></td></tr></table></figure>

<h5 id="自测"><a href="#自测" class="headerlink" title="自测"></a>自测</h5><p>我暂时没进行gradescope的自测，原因是它上面报了个跟我没啥关系的错，我不知道怎么改呃呃。</p>
<p><img src="/2023/03/13/cmu15445/image-20230318165521340.png" alt="image-20230318165521340"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In file included from /autograder/bustub/src/common/bustub_instance.cpp:17:</span><br><span class="line">/autograder/bustub/src/include/common/bustub_instance.h:30:10: fatal error: &#x27;libfort/lib/fort.hpp&#x27; file not found</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include <span class="string">&quot;libfort/lib/fort.hpp&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>都指向说找不到这个fort。但我真的不知道它为啥找不到，因为我看CMakeLists.txt中已经加了<code>third_party/</code>这个include目录了，并且这个东西的路径也确实是<code>third_party/libfort/lib/for.hpp</code>。</p>
<p>我还在<code>CMackLists.txt</code>、<code>src/CMackLists.txt</code>、<code>tools/shell/CMackLists.txt</code>里面都加了<code>include($&#123;PROJECT_SOURCE_DIR&#125;/third_party/libfort/lib/fort.hpp)</code>，但是依然报了这样的错：</p>
<p><img src="/2023/03/13/cmu15445/image-20230318173941576.png" alt="image-20230318173941576"></p>
<p><img src="/2023/03/13/cmu15445/image-20230318174102171.png" alt="image-20230318174102171"></p>
<p>它这为啥找不到我是真的很不理解。</p>
<p>所以真的很奇怪。暂且先放着吧，之后有精力研究下这些编译链接过程。</p>
<h2 id="COW-Trie"><a href="#COW-Trie" class="headerlink" title="COW-Trie"></a>COW-Trie</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613920859">CMU 15445 Project 0 (Spring 2023) 学习记录</a>  参考了task2和一个bug</p>
</blockquote>
<p>先放个通关截图~</p>
<p><img src="/2023/03/13/cmu15445/image-20230322235159843.png" alt="image-20230322235159843"></p>
<p>总体用时（coding+debug+note）10h+</p>
<p>本次实验是在它给的接口的基础上，实现一株并发安全的cow的trie树，还有一个小小的实现<code>upper</code>和<code>lower</code>函数的实验用来熟悉我们之后要写的db的东西。算法难度还是有一些的，我的coding和debug时间估摸着可能有46开。</p>
<p>总体来说整个实验还是非常有价值的，相比往年难度和意义都更上了一层。感谢实验设计者让我做到设计得这么好的实验~</p>
<h3 id="Task1-cow-trie"><a href="#Task1-cow-trie" class="headerlink" title="Task1 cow-trie"></a>Task1 cow-trie</h3><blockquote>
<p>In this task, you will need to modify <code>trie.h</code> and <code>trie.cpp</code> to implement a copy-on-write trie.</p>
<p>下面举例说明</p>
<p>Consider inserting <code>(&quot;ad&quot;, 2)</code> in the above example. We create a new <code>Node2</code> by reusing two of the child nodes from the original tree, and creating a new value node 2. (See figure below)</p>
<p><img src="/2023/03/13/cmu15445/image-20230323000513767.png" alt="image-20230323000513767"></p>
<p>If we then insert <code>(&quot;b&quot;, 3)</code>, we will create a new root, a new node and reuse the previous nodes. In this way, we can get the content of the trie before and after each insertion operation. As long as we have the root object (<code>Trie</code> class), we can access the data inside the trie at that time. (See figure below)</p>
<p><img src="/2023/03/13/cmu15445/image-20230323000601882.png" alt="image-20230323000601882"></p>
<p>One more example: if we then insert <code>(&quot;a&quot;, &quot;abc&quot;)</code> and remove <code>(&quot;ab&quot;, 1)</code>, we can get the below trie. Note that parent nodes can have values, and you will need to purge all unnecessary nodes after removal.</p>
<p><img src="/2023/03/13/cmu15445/image-20230323000658620.png" alt="image-20230323000658620"></p>
<p>To create a new node, you should use the <code>Clone</code> function on the <code>TrieNode</code> class. To reuse an existing node in the new trie, you can copy <code>std::shared_ptr&lt;TrieNode&gt;</code>: copying a shared pointer doesn’t copy the underlying data.</p>
<p>You <strong>should not</strong> manually allocate memory by using <code>new</code> and <code>delete</code> in this project. <code>std::shared_ptr</code> will deallocate the object when no one has a reference to the underlying object.</p>
</blockquote>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><p>task1的目标就是实现我们的cow-trie的主体，先不要求并发。</p>
<p>虽说算法上比较复杂，但是由于它图解以及代码中的注释解说都已经说得很详细了，再加上之前已经写过了trie树有一个大体框架，因而具体coding的时候思路还是比较清晰的。</p>
<p>我认为具体的难点还是在于cpp上。下面列出了几个比较有价值的错误和相关debug过程，其中<code>const转移</code>和<code>显示保存is_value_node_</code>是我认为两个比较难的点。</p>
<h4 id="错误集锦-1"><a href="#错误集锦-1" class="headerlink" title="错误集锦"></a>错误集锦</h4><h5 id="const转移"><a href="#const转移" class="headerlink" title="const转移"></a>const转移</h5><p>在<code>trie.h</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The root of the trie.</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; root_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  <span class="comment">// Create a new trie with the given root.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Trie</span><span class="params">(std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; root)</span> : root_(std::move(root)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create an empty trie.</span></span><br><span class="line">  <span class="built_in">Trie</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the value associated with the given key.</span></span><br><span class="line">  <span class="comment">// 1. If the key is not in the trie, return nullptr.</span></span><br><span class="line">  <span class="comment">// 2. If the key is in the trie but the type is mismatched, return nullptr.</span></span><br><span class="line">  <span class="comment">// 3. Otherwise, return the value.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Get</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> T *</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Put a new key-value pair into the trie. If the key already exists, overwrite the value.</span></span><br><span class="line">  <span class="comment">// Returns the new trie.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Put</span><span class="params">(std::string_view key, T value)</span> <span class="type">const</span> -&gt; Trie</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the key from the trie. If the key does not exist, return the original trie.</span></span><br><span class="line">  <span class="comment">// Otherwise, returns the new trie.</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Remove</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; Trie</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，为了呼应我们的cow-trie，在语法上强制性要求不能“directly modify”，它将<code>root_</code>和<code>children_-&gt;second</code>同时设置为了一个指向对象为const的指针。而这意味着什么呢？意味着我们不能修改<code>root_</code>的内容，也不能修改<code>root_-&gt;children_-&gt;second</code>的内容，同样的孩子的孩子也不行。这就需要我们在<code>Put</code>方法中遍历trie时，对遍历路径上的每个结点都需要copy一次，故而我们的代码具体是如下实现的：</p>
<p>首先，利用<code>TrieNode::Clone()</code>方法来创造一个非const指针的新root：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in trie.h  TrieNode&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Clone</span><span class="params">()</span> <span class="type">const</span> -&gt; std::unique_ptr&lt;TrieNode&gt; </span>&#123; <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;TrieNode&gt;(children_); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创造新的根节点，并且为非const类型</span></span><br><span class="line">std::shared_ptr&lt;TrieNode&gt; root = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(root_-&gt;<span class="built_in">Clone</span>());</span><br><span class="line"><span class="comment">// 使用t指针来遍历trie树</span></span><br><span class="line">std::shared_ptr&lt;TrieNode&gt; t = root;</span><br></pre></td></tr></table></figure>

<p>再然后，每次迭代的时候在遍历路径上创造新的结点，结点类型非const；再利用shared_ptr的共享复制（<code> t = tmp;</code>），就能使得当前的t指针一直保持非const状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; key.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">auto</span> it = t-&gt;children_.<span class="built_in">find</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">  <span class="keyword">if</span> (it == t-&gt;children_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="function">std::shared_ptr&lt;TrieNode&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">new</span> TrieNode())</span></span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      t = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::shared_ptr&lt;TrieNodeWithValue&lt;T&gt;&gt; <span class="built_in">tmp</span>(<span class="keyword">new</span> <span class="built_in">TrieNodeWithValue</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value))));</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      t = tmp;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      std::shared_ptr&lt;TrieNodeWithValue&lt;T&gt;&gt; node =</span><br><span class="line">          std::make_shared&lt;TrieNodeWithValue&lt;T&gt;&gt;(it-&gt;second-&gt;children_, std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value)));</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      t = node;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::shared_ptr&lt;TrieNode&gt; node = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(it-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    t = node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：我本来的写法是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; key.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">auto</span> it = t-&gt;children_.<span class="built_in">find</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">  <span class="keyword">if</span> (it == t-&gt;children_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="function">std::shared_ptr&lt;TrieNode&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">new</span> TrieNode())</span></span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::shared_ptr&lt;TrieNodeWithValue&lt;T&gt;&gt; <span class="built_in">tmp</span>(<span class="keyword">new</span> <span class="built_in">TrieNodeWithValue</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value))));</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      std::shared_ptr&lt;TrieNodeWithValue&lt;T&gt;&gt; node =</span><br><span class="line">          std::make_shared&lt;TrieNodeWithValue&lt;T&gt;&gt;(it-&gt;second-&gt;children_, std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value)));</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::shared_ptr&lt;TrieNode&gt; node = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(it-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  it = t-&gt;children_.<span class="built_in">find</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">  t = it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是为了省事，将t指针的转移集中放在了循环体最后进行。但这样是不行的。</p>
<p>cpp中，可以将非const对象自然转移为const对象，比如代码中就将非const的新结点放进了<code>children_</code>中；但是不允许将const对象自然转移为非const对象，比如代码中的<code>t = it-&gt;second;</code>。因而，我们对t指针的转移不能在新结点放入其<code>children_</code>之后。</p>
</blockquote>
<blockquote>
<p>注2：在这里，我本来还多用了一个prev指针，因为在coding的时候用的是上面的本来的写法，误以为t指针只能是const，所以还得有父节点才能再把t指针复制一遍。但其实并非如此，而且就算如此prev指针也还是跟t指针一样的const的。。。不过还好编译前发现了上面那点改过来了，要不然就得面对编译大报错2333</p>
</blockquote>
<h5 id="make-shared"><a href="#make-shared" class="headerlink" title="make_shared"></a>make_shared</h5><p><code>make_shared</code>作用也类似于new，会在堆上开辟空间用以存放共享指针的base对象。这也让我想起来我在做上面那个实验时一个地方改成<code>make_shared</code>就对了，估计是犯了用栈中对象创建共享指针的错误。</p>
<blockquote>
<p>官方鼓励用<code>make_shared</code>函数来创建对象，而不要手动去new。这一是因为，new出来的类型是原始指针，<code>make_shared</code>可以防止我们去使用原始指针创建多个引用计数体系；二是因为，<code>make_shared</code>可以防止内存碎片化。</p>
</blockquote>
<h5 id="一个奇妙的报错"><a href="#一个奇妙的报错" class="headerlink" title="一个奇妙的报错"></a>一个奇妙的报错</h5><p>在写这样的shared_ptr的共享转移时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;TrieNode&gt; tmp = <span class="built_in">make_shared</span>&lt;TrieNode&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">t = tmp;</span><br></pre></td></tr></table></figure>

<p>会在<code>t=tmp</code>这里报错不能把int类型的tmp复制给t。我看了半天很奇怪哪来的int类型，查了半天怎么共享shared_ptr，最后才发现是因为这里：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">make_shared</span>&lt;TrieNode&gt;()</span><br></pre></td></tr></table></figure>

<p>漏了个<code>std::</code>呃呃。</p>
<h5 id="显式保存is-value-node"><a href="#显式保存is-value-node" class="headerlink" title="显式保存is_value_node_"></a>显式保存is_value_node_</h5><p>在<code>trie.cpp RemoveHelper()</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i != key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意此处需要保留原来的is_value_node_，之后再赋值回去！！！</span></span><br><span class="line">    <span class="type">bool</span> tmp_val = node-&gt;second-&gt;is_value_node_;</span><br><span class="line">    std::shared_ptr&lt;TrieNode&gt; tmp = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(node-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">    tmp-&gt;is_value_node_ = tmp_val;</span><br><span class="line">    </span><br><span class="line">    root-&gt;children_.<span class="built_in">erase</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">    root-&gt;children_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key.<span class="built_in">at</span>(i), tmp));</span><br><span class="line">    flag = <span class="built_in">RemoveHelper</span>(tmp, key, i + <span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>否则会：</p>
<p><img src="/2023/03/13/cmu15445/image-20230323114435061.png" alt="image-20230323114435061"></p>
<p>查看<code>trie_test.cpp</code>的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(TrieTest, BasicRemoveTest2) &#123;</span><br><span class="line">  <span class="keyword">auto</span> trie = <span class="built_in">Trie</span>();</span><br><span class="line">  <span class="comment">// Put something</span></span><br><span class="line">  trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;test&quot;</span>, <span class="number">2333</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(*trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;test&quot;</span>), <span class="number">2333</span>);</span><br><span class="line">  trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;te&quot;</span>, <span class="number">23</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(*trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;te&quot;</span>), <span class="number">23</span>);</span><br><span class="line">  trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;tes&quot;</span>, <span class="number">233</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(*trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;tes&quot;</span>), <span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete something</span></span><br><span class="line">  trie = trie.<span class="built_in">Remove</span>(<span class="string">&quot;te&quot;</span>);</span><br><span class="line">  trie = trie.<span class="built_in">Remove</span>(<span class="string">&quot;tes&quot;</span>);</span><br><span class="line">  trie = trie.<span class="built_in">Remove</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;te&quot;</span>), <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;tes&quot;</span>), <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;test&quot;</span>), <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它是在<code>ASSERT_EQ(trie.Get&lt;uint32_t&gt;(&quot;te&quot;), nullptr);</code>这句报错的。这确实很奇怪，因为“te”已经被remove了。这是为什么呢？</p>
<p>经过gdb调试，trie的Remove和Put功能都确实很正常，但是我发现了一个诡异的现象。</p>
<p>在经过<code>trie = trie.Remove(&quot;te&quot;);</code>这句话后，trie的状态是t-e-(s)-(t)【括号表示为有值结点，类型为<code>TireNodeWithValue</code>】，符合预期。但是，经过紧随其后的<code>trie = trie.Remove(&quot;tes&quot;);</code>之后，trie的状态却变成了t-(e)-s-(t)。</p>
<p><img src="/2023/03/13/cmu15445/image-20230323115902073.png" alt="image-20230323115902073"></p>
<p>这实在是很诡异，为什么经过了一次Remove之后，<code>trie = trie.Remove(&quot;te&quot;);</code>这句话的效果就被重置了？</p>
<p>我想了挺久，最终认为这是构造方法的问题。</p>
<p>再次看一遍我们的Remove的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i != key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    std::shared_ptr&lt;TrieNode&gt; tmp = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(node-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">    </span><br><span class="line">    root-&gt;children_.<span class="built_in">erase</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">    root-&gt;children_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key.<span class="built_in">at</span>(i), tmp));</span><br><span class="line">    flag = <span class="built_in">RemoveHelper</span>(tmp, key, i + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;second-&gt;is_value_node_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!node-&gt;second-&gt;children_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::shared_ptr&lt;TrieNode&gt; tmp = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(node-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">        tmp-&gt;is_value_node_ = <span class="literal">false</span>;</span><br><span class="line">        root-&gt;children_.<span class="built_in">erase</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">        root-&gt;children_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key.<span class="built_in">at</span>(i), tmp));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;children_.<span class="built_in">erase</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及<code>TrieNodeWithValue::Clone()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Clone</span><span class="params">()</span> <span class="type">const</span> -&gt; std::unique_ptr&lt;TrieNode&gt; <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::make_unique&lt;TrieNodeWithValue&lt;T&gt;&gt;(children_, value_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及Clone()方法调用的<code>TrieNodeWithValue</code>的构造方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TrieNodeWithValue</span><span class="params">(std::shared_ptr&lt;T&gt; value)</span> : value_(std::move(value)) &#123;</span> <span class="keyword">this</span>-&gt;is_value_node_ = <span class="literal">true</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，在多态作用下，e结点始终是一个<code>TrieNodeWithValue</code>的结点。</p>
<p>在我们去除tes这个key时，会到这个分支：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i != key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    std::shared_ptr&lt;TrieNode&gt; tmp = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(node-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br></pre></td></tr></table></figure>

<p>Clone()中会调用<code>node-&gt;second</code>，也即e结点的构造方法，然后将e结点的<code>is_value_node_</code>设置为true，从而导致<code>Get</code>中无法通过这句代码返回nullptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(t-&gt;is_value_node_)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因而，为了解决这个问题，我们就需要暂存<code>is_value_node_</code>，并在之后恢复它。</p>
<h3 id="Task2-concurrency"><a href="#Task2-concurrency" class="headerlink" title="Task2  concurrency"></a>Task2  concurrency</h3><blockquote>
<p>In this task, you will need to modify <code>trie_store.h</code> and <code>trie_store.cpp</code>.需要实现并发安全版本。</p>
<p>For the original Trie class, everytime we modify the trie, we need to get the new root to access the new content. But for the concurrent key-value store, the <code>put</code> and <code>delete</code> methods <strong>do not</strong> have a return value. This requires you to use concurrency primitives to synchronize reads and writes so that no data is lost through the process.在并发安全版本中，<code>Put</code>和<code>Get</code>不会返回trie，而是应该修改包装类的base trie。</p>
<p>Your concurrent key-value store should concurrently serve <strong>multiple readers and a single writer</strong>. That is to say, when someone is modifying the trie, reads can still be performed on the <u>old root</u>. When someone is reading, writes can still be performed without waiting for reads.同一时刻可以有一个writer和多个reader。</p>
<p>Also, if we get a reference to a value from the trie, we should be able to access it no matter how we modify the trie. The <code>Get</code> function from <code>Trie</code> only returns a pointer. If the trie node storing this value has been removed, the pointer will be dangling. Therefore, in <code>TrieStore</code>, we return a <code>ValueGuard</code> which stores both a reference to the value and the TrieNode corresponding to the root of the trie structure, so that the value can be accessed as we store the <code>ValueGuard</code>.为我们提供了 <code>ValueGuard</code>用以确保return值长时间有效。</p>
<p>To achieve this, we have provided you with the pseudo code for <code>TrieStore::Get</code> in <code>trie_store.cpp</code>. Please read it carefully and think of how to implement <code>TrieStore::Put</code> and <code>TrieStore::Remove</code>.我们在<code>Get</code>方法中给出了详细的步骤引导。你需要依据它来对<code>Put</code>和<code>Get</code>进行修改。</p>
</blockquote>
<h4 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h4><p>task2的内容是实现cow-trie并发安全版本的包装类<code>TrieStore</code>。</p>
<p>相比于fall2022的并发内容，由于加上了cow的特性，本次实验更加复杂。我写了三版都没写对，看到别人的才豁然开朗（很遗憾没有自己再多想会儿……）接下来就从我的错误版本开始，逐步过渡到正确版本吧。</p>
<h4 id="错误集锦-2"><a href="#错误集锦-2" class="headerlink" title="错误集锦"></a>错误集锦</h4><h5 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h5><p><code>Get</code>的实现很简单，按他说的一步步做就行，在这边不做赘述。<code>Put</code>和<code>Remove</code>思路差不多，在此只放<code>Put</code>的代码。</p>
<p><img src="/2023/03/13/cmu15445/image-20230321185244067.png" alt="image-20230321185244067"></p>
<p>这样看起来很合理：同一时刻似乎确实只有一个writer对root_进行修改，也似乎确实同时可以有别的线程获取root_lock_对其进行读取。但其实，前者是错误的。</p>
<p>假如说进程A和进程B都在<code>Put</code>逻辑中。进程A执行到了<code>root_ = new_trie</code>这句话，然后进程B进入到<code>root_.Put</code>中。</p>
<p><code>root_ = new_trie</code>使用了运算符=的默认实现，进行浅拷贝，故而会修改<code>root_-&gt;root_</code>；<code>root_.Put</code>中会对<code>root_-&gt;root_</code>进行移动。</p>
<p>进程B在Put中执行<code>std::move(root_)</code>之后，进程A又让<code>root_-&gt;root_</code>变成了别的值（trie浅拷贝），导致原来的root_的引用计数变为0，自动释放（因为是智能指针shared_ptr），进程B在Put中再次访问就会寄。</p>
<blockquote>
<p>注，此处是因为智能指针引用计数为零才释放的，cpp没有垃圾回收机制。</p>
</blockquote>
<h5 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Put</span><span class="params">(std::string_view key, T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line">  root_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  Trie tmp = root_;</span><br><span class="line">  root_lock_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  write_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  Trie new_trie = tmp.<span class="built_in">Put</span>(key, std::<span class="built_in">move</span>(value));</span><br><span class="line">  write_lock_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  root_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  root_ = new_trie;</span><br><span class="line">  root_lock_.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>版本1错误后，我发现我并没有按它强调的“somehow similar to Get”那样，模仿<code>Get</code>中的写法来做。于是我就修改了下，版本2诞生了。</p>
<p>但是这样的话，依然不能解决版本1中的问题。所以我又搞了个版本3.</p>
<h5 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Put</span><span class="params">(std::string_view key, T value)</span> </span>&#123;</span><br><span class="line">  write_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  Trie tmp = root_;</span><br><span class="line">  Trie new_trie = tmp.<span class="built_in">Put</span>(key, std::<span class="built_in">move</span>(value));</span><br><span class="line">  root_ = new_trie;</span><br><span class="line">  write_lock_.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能通过所有测试了。</p>
<p>但这样做虽然能解决多个writer的争夺问题，但不能解决一个writer和一个reader的争夺问题：因为两者都争夺同一个root_变量，但只有reader争夺root_lock_，这显然很不安全。因而，终极版本应该是这样：</p>
<h5 id="正确版本"><a href="#正确版本" class="headerlink" title="正确版本"></a>正确版本</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Put</span><span class="params">(std::string_view key, T value)</span> </span>&#123;</span><br><span class="line">  write_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  root_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  Trie tmp = root_;</span><br><span class="line">  root_lock_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  Trie new_trie = tmp.<span class="built_in">Put</span>(key, std::<span class="built_in">move</span>(value));</span><br><span class="line"></span><br><span class="line">  root_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  root_ = new_trie;</span><br><span class="line">  root_lock_.<span class="built_in">unlock</span>();</span><br><span class="line">  write_lock_.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到整个思维过程是线性的，逐步改进下来，正确答案其实很容易想到。只可惜我太浮躁了，没有静下心来好好想，在版本3之后就去看了眼别人怎么写的（罪过）没有独立思考，算是一个小遗憾。</p>
<h3 id="Task3-debugging"><a href="#Task3-debugging" class="headerlink" title="Task3  debugging"></a>Task3  debugging</h3><h4 id="感想-3"><a href="#感想-3" class="headerlink" title="感想"></a>感想</h4><p>一个考查我们debug入门技巧的小任务，简单，但我觉得形势很新颖。</p>
<h4 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h4><p>随便贴点debug过程的截图。</p>
<p><img src="/2023/03/13/cmu15445/image-20230322221526353.png" alt="image-20230322221526353"></p>
<p><img src="/2023/03/13/cmu15445/image-20230322221634506.png" alt="image-20230322221634506"></p>
<p><img src="/2023/03/13/cmu15445/image-20230322221716462.png" alt="image-20230322221716462"></p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><h5 id="gdb：Attempt-to-take-address-of-value-not-located-in-memory"><a href="#gdb：Attempt-to-take-address-of-value-not-located-in-memory" class="headerlink" title="gdb：Attempt to take address of value not located in memory."></a>gdb：Attempt to take address of value not located in memory.</h5><p>任务中，需要获取root_的孙子。所以我就这么写了个gdb指令：<code>p root_-&gt;children_.find(&#39;9&#39;)-&gt;second</code>，然后就爆出了标题这个错误。</p>
<p>百度了下看到了这个：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sy4331/article/details/121587271">gdb调试时好用的命令</a></p>
<p><img src="/2023/03/13/cmu15445/image-20230323142137068.png" alt="image-20230323142137068"></p>
</blockquote>
<p>也许是因为我们通过.访问了children_的成员find吧（</p>
<p>总之，我最后是在<code>trie_debug_test</code>添加了这几行代码解决的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Put a breakpoint here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) How many children nodes are there on the root?</span></span><br><span class="line"><span class="comment">// Replace `CASE_1_YOUR_ANSWER` in `trie_answer.h` with the correct answer.</span></span><br><span class="line"><span class="keyword">if</span> (CASE_1_YOUR_ANSWER != <span class="built_in">Case1CorrectAnswer</span>()) &#123;</span><br><span class="line">  <span class="built_in">ASSERT_TRUE</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> it = trie.root_-&gt;children_.<span class="built_in">find</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">// (2) How many children nodes are there on the node of prefix `9`?</span></span><br><span class="line"><span class="comment">// Replace `CASE_2_YOUR_ANSWER` in `trie_answer.h` with the correct answer.</span></span><br><span class="line"><span class="keyword">if</span> (CASE_2_YOUR_ANSWER != <span class="built_in">Case2CorrectAnswer</span>()) &#123;</span><br><span class="line">  <span class="built_in">ASSERT_TRUE</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> val = trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;93&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; val &lt;&lt; it-&gt;first &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// (3) What&#x27;s the value for `93`?</span></span><br><span class="line"><span class="comment">// Replace `CASE_3_YOUR_ANSWER` in `trie_answer.h` with the correct answer.</span></span><br><span class="line"><span class="keyword">if</span> (CASE_3_YOUR_ANSWER != <span class="built_in">Case3CorrectAnswer</span>()) &#123;</span><br><span class="line">  <span class="built_in">ASSERT_TRUE</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即添加了it和val，以及防止unused报错的cout语句。gdb调试时打印it和val就行。</p>
<h5 id="答案对但是过不了评测"><a href="#答案对但是过不了评测" class="headerlink" title="答案对但是过不了评测"></a>答案对但是过不了评测</h5><blockquote>
<p>来自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613920859">CMU 15445 Project 0 (Spring 2023) 学习记录</a>  </p>
<p>在我本地的环境上，调试三问的答案分别是<code>8 1 42</code>，但该答案无法通过 Grade 平台的评测。发现在 Discord 上有人提出了同样的问题，助教 Alex Chi 给出了解答：</p>
<blockquote>
<p>Alex Chi — 2023/02/15 23:29<br>It is possible that your environment produces different random numbers than the grading environment. In case your environment is producing different set of random numbers than our grader, replace your TrieDebugger test with:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> trie = <span class="built_in">Trie</span>();</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;65&quot;</span>, <span class="number">25</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;61&quot;</span>, <span class="number">65</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;82&quot;</span>, <span class="number">84</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;2&quot;</span>, <span class="number">42</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;16&quot;</span>, <span class="number">67</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;94&quot;</span>, <span class="number">53</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;20&quot;</span>, <span class="number">35</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;3&quot;</span>, <span class="number">57</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;93&quot;</span>, <span class="number">30</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;75&quot;</span>, <span class="number">29</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>难绷，我反复确认了好几遍（。主要还是太相信cmu的权威了，觉得这实验都发布了好几个月了应该不会有错，就没想到是这个问题。我觉得最好还是把这个问题反应在指导书上吧。</p>
<h3 id="Task4-SQL-String-Functions"><a href="#Task4-SQL-String-Functions" class="headerlink" title="Task4  SQL String Functions"></a>Task4  SQL String Functions</h3><blockquote>
<p>Now it is time to dive into BusTub itself! </p>
<p>You will need to implement <code>upper</code> and <code>lower</code> SQL functions. </p>
<p>This can be done in 2 steps: </p>
<ol>
<li>implement the function logic in <code>string_expression.h</code>.</li>
<li>register the function in BusTub, so that the SQL framework can call your function when the user executes a SQL, in <code>plan_func_call.cpp</code>.</li>
</ol>
<p>To test your implementation, you can use <code>bustub-shell</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">make -j`nproc` shell</span><br><span class="line">./bin/bustub-shell</span><br><span class="line"><span class="meta prompt_">bustub&gt; </span><span class="language-bash">select upper(<span class="string">&#x27;AbCd&#x27;</span>), lower(<span class="string">&#x27;AbCd&#x27;</span>);</span></span><br><span class="line">ABCD abcd</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="感想-4"><a href="#感想-4" class="headerlink" title="感想"></a>感想</h4><p>说实话乍一看我还没看懂（。它放在这个位置，我还以为跟上面实现的cow-trie有什么关系，并且误以为这个upper和lower是什么上层接口底层接口的意思，跟它大眼瞪小眼了半天。直到看到了下面的案例，才发现跟trie似乎没有任何关系23333</p>
<p>本次实验内容其实就是实现sql的转换大小写的函数。知道了要做什么之后，任务就很简单了，按着它提示一步步做就行。</p>
<p>不过此task重点其实也是在稍微了解下我们接下来要打交道的sql框架的代码。比如说，此次我们的实现涉及到的，居然是一个差不多是工厂模式（其实更像策略模式？）的一部分：</p>
<p>外界传入想调用的函数名，通过<code>GetFuncCallFromFactory</code>获取对应的处理对象</p>
<p><img src="/2023/03/13/cmu15445/image-20230322154915206.png" alt="image-20230322154915206"></p>
<p>得到处理对象后调用其<code>Compute</code>方法就行</p>
<p><img src="/2023/03/13/cmu15445/image-20230322154849449.png" alt="image-20230322154849449"></p>
<p>第一次如此鲜明地看到一个设计模式在cpp的应用，真是让我非常震撼。</p>
<h3 id="代码规范-1"><a href="#代码规范-1" class="headerlink" title="代码规范"></a>代码规范</h3><p>依旧是这三件套：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p0</span><br></pre></td></tr></table></figure>

<h4 id="错误集锦-3"><a href="#错误集锦-3" class="headerlink" title="错误集锦"></a>错误集锦</h4><h5 id="关于sanitizer"><a href="#关于sanitizer" class="headerlink" title="关于sanitizer"></a>关于sanitizer</h5><p>执行了该命令：<code>cmake -DCMAKE_BUILD_TYPE=Debug -DBUSTUB_SANITIZER= ..</code>之后，执行<code>make</code>报错<code>missing argument to &#39;-fsanitize=&#39;</code></p>
<p>发生这个的原因是cmake的命令中将<code>BUSTUB_SANITIZER</code>设置成了空。解决方法就是将其设置为别的值就好了，具体想设置成什么值可以参见：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/578225802">关于GCC/LLVM编译器中的sanitize选项用处用法详解</a> 我这里姑且随便设置了个<code>leak</code>。</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/06/17/%E5%AF%B9GRUB%E5%92%8Cinitramfs%E7%9A%84%E5%B0%8F%E6%8E%A2%E7%A9%B6/">对GRUB和initramfs的小探究</a>
            
            
            <a class="next" rel="next" href="/2023/03/13/cmu15445$lab1/">Project1   Buffer Pool</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 修年 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>