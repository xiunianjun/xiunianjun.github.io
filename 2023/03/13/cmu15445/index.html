<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="修年">





<title>CMU15445 | 修年</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiunian&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiunian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc" style="right: -4em;">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">CMU15445</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">修年</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">三月 13, 2023&nbsp;&nbsp;22:19:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <blockquote>
<p><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/">实验官网</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/xiunianjun/cmu15445">代码</a></p>
</blockquote>
<h3 id="Project0-C-Primer"><a href="#Project0-C-Primer" class="headerlink" title="Project0   C++ Primer"></a><a href="/2023/03/13/cmu15445$lab0">Project0   C++ Primer</a></h3><h3 id="Project1-Buffer-Pool"><a href="#Project1-Buffer-Pool" class="headerlink" title="Project1   Buffer Pool"></a><a href="/2023/03/13/cmu15445$lab1">Project1   Buffer Pool</a></h3><h3 id="Project2-B-Tree-Index"><a href="#Project2-B-Tree-Index" class="headerlink" title="Project2   B+Tree Index"></a><a href="/2023/03/13/cmu15445$lab2">Project2   B+Tree Index</a></h3><h3 id="Project3-Query-Execution"><a href="#Project3-Query-Execution" class="headerlink" title="Project3   Query Execution"></a><a href="/2023/03/13/cmu15445$lab3">Project3   Query Execution</a></h3><h1 id="Project4-Concurrency"><a href="#Project4-Concurrency" class="headerlink" title="Project4   Concurrency"></a>Project4   Concurrency</h1><p>在上面的project中，我们实现了负责管理内存页缓冲与磁盘的、用于一切数据和索引页管理的buffer pool，然后实现了一个b+树索引，最后实现了增删改查等操作的底层执行器以及部分查询优化规则。这一小节，我们将完成数据库的并发控制，我想大概是要实现事务机制。</p>
<p>如果要实现事务机制，那么我们就需要关注如何实现事务的ACID。也即，我们是如何保障事务的原子性、隔离性、一致性、持久性的。这就需要关注<strong>事务的原子性的实现和事务的调度</strong>，关注事务并行执行时的正确性。</p>
<blockquote>
<p>In this project, you will add support for <strong>transactions</strong> in BusTub by adding a lock manager and then using it for concurrent query execution. </p>
<p>The lock manager will support <strong>table locks</strong> and <strong>tuple locks</strong> in <strong>five</strong> lock modes: intention-shared, intention-exclusive, shared-intention-exclusive, shared, and exclusive. </p>
<p>The lock manager will <u>process lock requests from transactions</u>, grant locks to transactions, and check if locks are released appropriately based on the <strong>transaction’s isolation level</strong>.</p>
</blockquote>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="transactions"><a href="#transactions" class="headerlink" title="transactions"></a>transactions</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p><img src="/2023/03/13/cmu15445/image-20231119160134524.png" alt="image"></p>
<h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><p>要了解事务的并发控制，首先了解什么是调度、串行化。</p>
<p><img src="/2023/03/13/cmu15445/image-20231119160217938.png" alt="image"></p>
<p><img src="/2023/03/13/cmu15445/image-20231119160636318.png" alt="image"></p>
<p>事务并发控制大概有以下这几种方法：</p>
<ol>
<li><p>基于封锁的并发控制</p>
<p>使用<strong>两段封锁协议2pl</strong>来控制资源互斥的事务串行化执行，形成一个合理的串行调度；</p>
<p>同时，通过<strong>死锁检测</strong>方法来去除隐患的死锁。</p>
</li>
<li><p>基于时间戳的并发控制</p>
</li>
<li><p>基于有效性确认的并发控制</p>
</li>
</ol>
<p>在本次实验中，我们就是采用<strong>基于封锁的并发控制</strong>。</p>
<h5 id="两段封锁协议"><a href="#两段封锁协议" class="headerlink" title="两段封锁协议"></a>两段封锁协议</h5><p><img src="/2023/03/13/cmu15445/image-20231119183734987.png" alt="image"></p>
<p>在DBMS中，lock manager模块负责管理系统中的锁。每当事务需要加锁或者升级锁的时候，都需要向它发出请求。lock manager 内部维护着一个表，上面记录着当前所有锁的分配信息，用于跟踪哪些事务持有哪些锁，以及哪些事务正在等待获得哪些锁。由于我们想获得可串行化的调度序列，因此我们需要利用lock manager来实施加锁策略，以保证事务操作的正确性和并发度。</p>
<p>两阶段锁的实现由两阶段组成。</p>
<ul>
<li>growing 阶段：事务可以按需获取某条数据的锁，lock manager 决定同意或者拒绝</li>
<li>shringking 阶段：事务只能释放之前获取的锁，不能获得新锁，即一旦开始释放锁，之后就只能释放锁。</li>
</ul>
<p>通过2PL获得的调度策略是冲突可串行化的。</p>
<p>但是该方法有着致命的弱点：可能会导致<strong>级联中止</strong> (cascading aborts)。如下图所示的 “脏读”现象。为了保证整个调度是可串行化的，DBMS 需要在 T1 中止后将一些对T1有依赖的事务也中止，这些事务曾经读取过 T1 写入的数据。而这些中止可能进而使得其它正在进行的事务级联地中止。</p>
<p>为了解决这个问题，可以使用2PL的增强版变种。该方法要求<strong>事务持有的锁一直到其提交或者中止时才释放</strong>，从而使得每个事务在结束之前，其写过的数据不能被其它事务读取或者重写。</p>
<p><img src="/2023/03/13/cmu15445/v2-78b6f9cdb1b36484c3e0217f27730650_1440w.webp" alt="img"></p>
<h5 id="隔离等级"><a href="#隔离等级" class="headerlink" title="隔离等级"></a>隔离等级</h5><p><img src="/2023/03/13/cmu15445/image-20231119183354649.png" alt="image"></p>
<h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><p>基于封锁的并发控制通过<strong>死锁检测</strong>方法来去除隐患的死锁。</p>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78897428">聊一聊数据库中的锁 - 老刘的文章 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/51676675">一文了解db2的锁 - somenzz的文章 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3aa634b0567c">CMU 15445 14.二阶段锁定 + homework 4</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/488482354">【15-445】8.事务(3)串行化 - 只爱睡觉的文章 - 知乎</a>  这篇文章写得很棒</p>
</blockquote>
<h4 id="多级粒度锁机制"><a href="#多级粒度锁机制" class="headerlink" title="多级粒度锁机制"></a>多级粒度锁机制</h4><p>假设存在如下需求：事务T需要访问一个有1亿个元组的数据库。</p>
<p>我们希望T只发出单个请求就能封锁整个数据库，因此这里需要引入允许系统定义<strong>多级粒度</strong>(granularity)锁的机制，并允许定义各种大小的数据项和数据粒度的层次结构。这种层次结构可以图形化地表示为树。</p>
<p><img src="/2023/03/13/cmu15445/v2-6a8363d4fada6e578c03b3d8d87c4813_1440w.webp" alt="img"></p>
<p>树中每个结点都可以单独加锁。当一个事务对一个结点加锁时，该事务也以同样类型的锁<strong>隐式地封锁这个结点的全部子结点</strong>。</p>
<p>但这样处理存在一个问题：事务T希望封锁整个子树，因此它只需给子树的根结点加锁。但是如果T在子树的某部分持有锁，那么T给该根结点加锁就会失败。<strong>如何判定根结点是否可以加锁呢</strong>？一种可能的方法是搜索整棵树。然而，这个方法破坏了多粒度封锁机制的初衷。另一种方法是引入一种新的锁类型，即<strong>意向锁类型</strong>( intentionlock mode)。</p>
<p>如果一个结点加上了意向锁，则意味着将要在树的较低层进行显式加锁(也就是说，以更小的粒度加锁)。这里有三种意向锁：</p>
<ul>
<li>**Intention-Shared (IS)**：说明在较低级别会使用共享锁（S）来显式上锁。</li>
<li>**Intention-Exclusive (IX)**：说明在较低级会使用互斥锁（X）来显式上锁</li>
<li><strong>Shared+Intention-Exclusive (SIX)<strong>：以该节点为根的子树</strong>已经显式得到了共享锁</strong>，并且<strong>将要</strong>在树的更低层次显示加上互斥锁。</li>
</ul>
<p>对某个结点进行加锁之前，需要获取它到根节点路径上的所有相关意向锁，具体规则如下图所示：</p>
<p><img src="/2023/03/13/cmu15445/webp-1706931395906-19.webp" alt="img"></p>
<p>引入该机制后，在一个结点显式加锁之前，该结点的全部祖先均需要加上意向锁。当我们希望给某个结点加锁时，事务必须遍历从根到该节点的路径，判断路径上的节点是否被加了意向锁：如果已加，则该显示加锁过程不能成功；如果未加，<strong>则给该路径上的节点加上意向锁</strong>。</p>
<h4 id="实际实现"><a href="#实际实现" class="headerlink" title="实际实现"></a>实际实现</h4><p>如上节所示，锁定层次结构有多种粒度：</p>
<p><img src="/2023/03/13/cmu15445/v2-34a703b4147e594149bc2a8d37110327_1440w.webp" alt="img"></p>
<p>而在实际的DBMS中，讨论锁的并发控制，我们通常只考虑table和tuple粒度，也即<strong>表锁与行锁</strong>。</p>
<p>如果加表锁，则表中所有的行都受到同等程度的影响；如果加行锁，则加锁的范围针对的是表及下属的行。有时对表加锁后，还要在相应的数据行上加锁。</p>
<p>针对表锁和行锁，我们可以使用上一小节提到的多级粒度锁机制。具体来说，表锁包括意图锁和传统的XS锁，行锁只包括XS锁。在具体上锁操作中，首先获取意图锁表明自己对表中的某些行有读写的需求，等到真正要读写了才会真正获取行锁。也即，它支持多个事务同时对表的不同行进行读写，故而相比传统锁住整个表的XS锁会更高效一些。</p>
<p>常见的表锁及其含义如下表所示：</p>
<p><img src="/2023/03/13/cmu15445/v2-0f3d06461969e38d22795ec8b33b3270_1440w.webp" alt="img"></p>
<p>其互斥矩阵如下图所示：</p>
<p><img src="/2023/03/13/cmu15445/webp.webp" alt="img"></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>与此同时这里还有几个使用锁的例子：</p>
<p><img src="/2023/03/13/cmu15445/image-20240203113752672.png" alt="image-20240203113752672"></p>
<p><img src="/2023/03/13/cmu15445/image-20240203113803390.png" alt="image-20240203113803390"></p>
<blockquote>
<p><strong>对意图锁的理解</strong>【TODO，这里我不大认可，怎么感觉它说的是LM的活】</p>
<p>意图锁是一种<strong>表锁</strong>，也即影响一个表中的所有元组。</p>
<p>对于 IX、IS 和 SIX 这些意图锁，我们可以这样理解：严格来说他们并不是一种锁，而是<strong>存放表中行锁的信息</strong>。</p>
<p>举个通俗的例子，我们去住一个酒店。可以把整个酒店比喻成一张表，每个房间是一个行。当我们预定一个房间时，就对该行（房间）添加 X 锁，但是同时会在酒店的前台对该行（房间）做一个信息登记（旅客姓名、住多长时间等）。大家可以把意图锁当成这个酒店前台，它并不是真正意义上的锁，它维护表中每行的加锁信息，是共用的。后续的旅客通过酒店前台来看哪个房间是可用的，那么，如果没有意图锁，会出现什么情况呢，假设我要住房间，那么我每次都要到每一个房间看看这个房间有没有住人，显然这样做的效率是很低下的。其实，最早的 DB2 版本是没有意图锁的，但这对并发影响很大，后来就增加了意图锁。所有的数据库（Oracle、Infomix 和 Sybase）都有意图锁的实现机制。</p>
</blockquote>
<h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><blockquote>
<p>To ensure correct interleaving of transactions’ operations, the DBMS uses a <strong>lock manager (LM)</strong> to control when transactions are allowed to access data items. The basic idea of a LM is that it maintains an internal data structure about the locks currently held by active transactions. Transactions issue lock requests to the LM before they access data items, and the LM will either grant the lock, block the transaction until the lock is available, or abort the transaction.</p>
<p>为了保证并发控制，DBMS通常会有一个lock manager(LM)，它记录了每个锁都被哪些事务正在持有着。每个事务要访问数据前都需要获取特定的锁，LM的作用就是检查这个锁是否可用，是的话就让该事务获取锁然后执行，否则的话就阻塞该事务，或者直接中止该事务。</p>
<p>In your implementation, there will be a <strong>global LM</strong> for the BusTub system. The <code>TableHeap</code> and <code>Executor</code> classes will use your LM to acquire locks on tuple records (by record id <code>RID</code>) when a transaction attempts to access or modify a tuple.</p>
<p>Your LM must implement hierarchical <strong>table-level and tuple-level intention locks</strong> (described above) and three isolation levels: <code>READ_UNCOMMITED</code>, <code>READ_COMMITTED</code>, and <code>REPEATABLE_READ</code>. The LM should grant or release locks according to a transaction’s isolation level.</p>
<p>需要支持多级粒度锁和三个隔离级别。</p>
<p>We provide a <code>Transaction</code> context handle (<code>include/concurrency/transaction.h</code>) with an isolation level attribute (i.e., <code>READ_UNCOMMITED</code>, <code>READ_COMMITTED</code>, and <code>REPEATABLE_READ</code>) and information about its acquired locks. </p>
<p><code>Transaction</code> context记录了很多有用的信息，如隔离级别、所需锁等。</p>
<p>The LM will need to check the isolation level of transaction and expose correct behavior on lock/unlock requests. Any invalid lock operation should lead to an ABORTED transaction state (implicit abort) and throw an exception. A failed lock attempt (such as for a <strong>deadlock</strong>) does not result in an exception, but the LM should return false for the lock request.</p>
<p>当锁操作不合法需要将事务abort并且抛出异常；失败的锁操作（如可能导致死锁）则不会导致异常，而只是简单地返回false。</p>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>bustub采用了<strong>两段封锁协议</strong>（2PL），也即事务可以分为以下几个阶段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Transaction states <span class="keyword">for</span> <span class="number">2</span>PL:</span><br><span class="line">*</span><br><span class="line">*     _________________________</span><br><span class="line">*    |                         v</span><br><span class="line">* GROWING -&gt; SHRINKING -&gt; COMMITTED   ABORTED</span><br><span class="line">*    |__________|________________________^</span><br></pre></td></tr></table></figure>

<p>并且，bustub采取了表锁和行锁粒度，遵循<strong>多级粒度锁机制</strong>。表锁有<strong>意图锁</strong>和S/X锁，行锁只有S/X锁；当访问一个表时，可以直接获取它的S/X锁，或者先获取其意图锁再获取对应访问行的S/X锁。</p>
<p>同时，bustub也支持三个隔离级别，也即<code>READ_UNCOMMITTED</code>，<code>REPEATABLE_READ</code>和<code>READ_COMMITTED</code>。它们应该分别对应于一级协议（解决丢失修改）、二级协议（解决脏读）、三级协议（解决不可重复读）。</p>
<p>而本次实验所需实现的，就是一个lock manager（LM）。它需要管理系统中所有资源的锁，并且当事务调用lock方法尝试获取某个类型的锁时，它需要检验是否合理后再进行授权。在bustub中它是全局的。具体来说，它对外提供这四个主要接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockTable</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UnlockTable</span><span class="params">(Transaction *txn, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockRow</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid, <span class="type">const</span> RID &amp;rid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UnlockRow</span><span class="params">(Transaction *txn, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid, <span class="type">const</span> RID &amp;rid, <span class="type">bool</span> force = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>每个事务要访问数据前都需要通过这些接口获取特定的锁。LM类内部检查这个锁是否可用，是的话就让该事务获取锁（GRANT）然后执行，否则的话就阻塞（BLOCK）该事务，或者直接中止（ABORT）该事务。同时，它也会进行周期性的死锁检测，避免2pl的死锁问题。</p>
<p>在task1，我们需要实现LM的lock/unlock基本功能；在task2，我们需要实现LM的死锁检测功能。</p>
<h3 id="Task-1-Lock-Manager"><a href="#Task-1-Lock-Manager" class="headerlink" title="Task #1 - Lock Manager"></a>Task #1 - Lock Manager</h3><blockquote>
<p>The only file you need to modify for this task is the <code>LockManager</code> class (<code>concurrency/lock_manager.cpp</code> and <code>include/concurrency/lock_manager.h</code>). You must implement the following functions:</p>
<ul>
<li><code>LockTable(Transaction, LockMode, TableOID)</code></li>
<li><code>UnlockTable(Transction, TableOID)</code></li>
<li><code>LockRow(Transaction, LockMode, TableOID, RID)</code></li>
<li><code>UnlockRow(Transaction, TableOID, RID, force)</code></li>
</ul>
<p>The LM’s specific locking mechanism depends on the transaction isolation level, whether it is a table-level or tuple-level lock, and the type of lock involved. Make sure you are familiar with the <code>Transaction</code> class’s API and member variables, defined in <code>transaction.h</code> and <code>lock_manager.h</code> Then, carefully read through <code>[LOCK_NOTE]</code>, <code>[UNLOCK_NOTE]</code>, and the LM’s functions’ specifications (in <code>lock_manager.h</code>).</p>
<p>TODO，force，这个意思我没看懂</p>
<p>The <code>UnlockRow</code> has a <code>force</code> parameter because executor implementations might need to determine whether a tuple is accessible before deciding whether to include it. If <code>force</code> is set to true, the operation bypasses all 2PL checks as if the tuple is not locked.</p>
<p>For <code>UnlockRow</code>, we have a <code>force</code> parameter, because in the executor implementation, we might need to <em>peek</em> whether a tuple is accessible by a transaction before deciding whether to scan this tuple to parent executors. If <code>force</code> is set to true, this operation bypasses all 2PL checks as if the tuple is never locked by the transaction.</p>
<p><strong>HINTS</strong></p>
<ul>
<li>Think carefully about when do you need to upgrade a lock, and about what operations on the <code>LockRequestQueue</code> is needed when you need to update a table/tuple lock.</li>
<li>You will need some way to notify waiting transactions when a lock is available. We recommend using <code>std::condition_variable </code>provided as part of <code>LockRequestQueue</code>.</li>
<li>The lock manager should update the state of transactions as needed. For example, the state of a transaction may be changed from <code>GROWING</code> to <code>SHRINKING</code> by an <code>unlock</code> operation. See the methods in <code>transaction.h</code></li>
<li>You should keep track of the locks acquired by a transaction using <code>*_lock_set_</code> so that the <code>TransactionManager</code> can release locks appropriately when it commits or aborts a transaction.</li>
<li>Setting a transaction’s state to ABORTED implicitly aborts it, but it is not explicitly aborted until <code>TransactionManager::Abort</code> is called. You should read this function and the provided tests to understand what it does and how your lock manager is used in the abort process.</li>
</ul>
</blockquote>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>要结合bustub支持的特性实现LM的lock/unlock基本功能，首先要明确lock/unlock函数的基本框架：</p>
<p>对于Lock()类函数，</p>
<ol>
<li>检验加锁合法性，不合法则中止事务</li>
<li>一个循环，内部不断尝试获取锁，获取不到则沉睡等待唤醒</li>
</ol>
<p>对于Unlock()类函数，</p>
<ol>
<li>检验解锁合法性，不合法则中止事务</li>
<li>进行解锁相关操作，唤醒所有沉睡中事务</li>
</ol>
<p>接下来，先介绍LM的数据结构，然后再从这三方面详细介绍LM中Lock()的实现：整体沉睡唤醒机制、合法性检测以及更新锁的实现。最后再在第四部分单独说明实现较为简单的Unlock()。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>LM的作用是管理所有资源的锁，而在bustub中资源粒度只为“table”和“tuple”。故而，只需有两个类似map的数据结构，分别记录表锁和行锁信息即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Structure that holds lock requests for a given table oid */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">table_oid_t</span>, std::shared_ptr&lt;LockRequestQueue&gt;&gt; table_lock_map_;</span><br><span class="line"><span class="comment">/** Coordination */</span></span><br><span class="line">std::mutex table_lock_map_latch_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Structure that holds lock requests for a given RID */</span></span><br><span class="line">std::unordered_map&lt;RID, std::shared_ptr&lt;LockRequestQueue&gt;&gt; row_lock_map_;</span><br><span class="line"><span class="comment">/** Coordination */</span></span><br><span class="line">std::mutex row_lock_map_latch_;</span><br></pre></td></tr></table></figure>

<p>其中<code>LockRequestQueue</code>记录了每个资源锁队列信息，具体结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockRequestQueue</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 阻塞于该资源的请求队列 */</span></span><br><span class="line">    std::list&lt;LockRequest *&gt; request_queue_;</span><br><span class="line">    <span class="comment">/** 用于对request_queue_内部线程进行同步，下下小节细说 */</span></span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    <span class="comment">/** 用于lock upgrade的实现，之后细说 */</span></span><br><span class="line">    <span class="type">txn_id_t</span> upgrading_ = INVALID_TXN_ID;</span><br><span class="line">    <span class="comment">/** 用于保护本结构 */</span></span><br><span class="line">    std::mutex latch_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockRequest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Txn_id of the txn requesting the lock */</span></span><br><span class="line">    <span class="type">txn_id_t</span> txn_id_;</span><br><span class="line">    <span class="comment">/** Locking mode of the requested lock */</span></span><br><span class="line">    LockMode lock_mode_;</span><br><span class="line">    <span class="comment">/** Oid of the table for a table lock; oid of the table the row belong to for a row lock */</span></span><br><span class="line">    <span class="type">table_oid_t</span> oid_;</span><br><span class="line">    <span class="comment">/** Rid of the row for a row lock; unused for table locks */</span></span><br><span class="line">    RID rid_;</span><br><span class="line">    <span class="comment">/** 记录该请求是否已经被授权 */</span></span><br><span class="line">    <span class="type">bool</span> granted_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相当于每个table OR tuple都有一个等待的事务队列，和它自己的锁。</p>
<h4 id="FIFO沉睡唤醒机制"><a href="#FIFO沉睡唤醒机制" class="headerlink" title="FIFO沉睡唤醒机制"></a>FIFO沉睡唤醒机制</h4><blockquote>
<p>感觉这里还是很有含金量的，通过<code>std::condition_variable</code>实现一个自定义的FIFO锁。</p>
</blockquote>
<h5 id="c-知识"><a href="#c-知识" class="headerlink" title="c++知识"></a>c++知识</h5><p><code>std::condition_variable</code> 是 C++ 标准库中用于线程间同步的工具之一，它通常与 <code>std::mutex</code> 一起使用，用于实现在特定条件下的线程等待和唤醒操作。<code>std::condition_variable</code> 提供了一种方式，允许一个线程等待另一个线程满足某个特定条件，然后通知等待的线程条件已经满足。</p>
<p>下面是一个简单的示例，演示了 <code>std::condition_variable</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitForCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Condition satisfied! Doing some work.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">waitingThread</span><span class="params">(waitForCondition)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    </span><br><span class="line">    waitingThread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的<code>unique_lock</code>值得注意。这东西和lock guard差不多，区别可能就在于<code>std::unique_lock</code> 提供了更多的灵活性，允许手动锁定和释放互斥量，并且在不同的作用域内多次锁定和解锁。一般都会将它传给条件变量的wait函数。</p>
<p>条件变量的基本流程图原理可见下图（来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39277419/article/details/99544724">condition_variable 条件变量</a>）：</p>
<p><img src="/2023/03/13/cmu15445/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mjc3NDE5,size_16,color_FFFFFF,t_70.jpeg" alt="在这里插入图片描述"></p>
<p><img src="/2023/03/13/cmu15445/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mjc3NDE5,size_16,color_FFFFFF,t_70-1707395142292-3.jpeg" alt="在这里插入图片描述"></p>
<p>可见，它其实就是在外部上锁，然后内部解锁，等到被唤醒再次获取锁。故而，我们可以用它实现沉睡唤醒机制。</p>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>由文档可得：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Both <span class="title function_">LockTable</span><span class="params">()</span> and <span class="title function_">LockRow</span><span class="params">()</span> are blocking methods; they should wait till the lock is granted and then <span class="keyword">return</span>. If the transaction was aborted in the meantime, <span class="keyword">do</span> not grant the lock and <span class="keyword">return</span> <span class="literal">false</span>.</span><br><span class="line">Unlocking a resource should also grant any new lock requests <span class="keyword">for</span> the resource (<span class="keyword">if</span> possible).</span><br></pre></td></tr></table></figure>

<p>由此我们可知lock和unlock的大抵机制。在lock中，如果当前不可用，则沉睡等待唤醒；unlock之后则通知所有线程。</p>
<p>我们可以通过<code>LockRequestQueue</code>结构体中的条件变量<code>cv_</code>来实现<strong>沉睡唤醒机制</strong>。而沉睡唤醒机制实现要点之一就是明确<strong>沉睡的条件</strong>。</p>
<p>LM的实现要求使用<strong>FIFO顺序</strong>来满足事务请求，而<code>std::condition_variable</code>的<code>notify_one</code>方法是按随机顺序的。所以我们只能手动使用<code>LockRequestQueue.request_queue_</code>队列来模拟FIFO，也即<u>仅当当前线程为队首元素，才进行锁的授权</u>。</p>
<p>除此之外，还需注意一点，也即要求如果请求队列中有多个锁能被满足，那么需要对它们<u>同时一次性授权</u>。比如说，假定当前请求队列为“SSXSX”，那么此次授权之后的请求队列应为“<u>SS</u>XSX”。（划线表示已授权）</p>
<p>其中，这个“满足”关系可被理解为<strong>兼容</strong>。锁之间的兼容矩阵如下图所示：</p>
<p><img src="/2023/03/13/cmu15445/webp.webp" alt="img"></p>
<p>故而，结合上述两点后，可得我们最终实现的<strong>沉睡条件</strong>：<u>当且仅当该请求与它前面所有请求都兼容，才能授权该请求</u>。以<code>LockTable()</code>为例，最终形成如下代码（伪码表示）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockManager::LockTable</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">table_oid_t</span> &amp;oid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = table_lock_map_.<span class="built_in">find</span>(oid);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">req_queue_lock</span><span class="params">(it-&gt;second-&gt;latch_)</span></span>;</span><br><span class="line">  it-&gt;second-&gt;request_queue_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid)); <span class="comment">// 加入当前请求到队尾</span></span><br><span class="line">  <span class="keyword">auto</span> req_it = std::<span class="built_in">prev</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前锁需要插入</span></span><br><span class="line">  <span class="keyword">switch</span> (lock_mode) &#123; <span class="comment">// 不同的锁类型有不同的机制，在此仅以S/X锁为例</span></span><br><span class="line">      <span class="keyword">case</span> LockMode::EXCLUSIVE: <span class="comment">// X锁不与任何其它锁兼容，故要求当前请求前面的为空</span></span><br><span class="line">        <span class="comment">// 注意这里不能直接判empty。因为有可能在wait过程中请求队列尾插了新的请求</span></span><br><span class="line">        <span class="keyword">while</span> (!(std::<span class="built_in">all_of</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(), req_it, [is_upgraded](LockRequest* req) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;))) &#123;</span><br><span class="line">          it-&gt;second-&gt;cv_.<span class="built_in">wait</span>(req_queue_lock);</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 注意需要更新it，因为stl的容器增删元素后迭代器不会始终指向原来那个元素……</span></span><br><span class="line">        <span class="keyword">for</span> (req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LockMode::SHARED: <span class="comment">// S锁只与S和IS兼容，故要求当前请求前面的为空或者全都是兼容类型</span></span><br><span class="line">        <span class="keyword">while</span> (!(std::<span class="built_in">all_of</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(), req_it, [is_upgraded](LockRequest* req) &#123; <span class="keyword">return</span> req-&gt;lock_mode_ == LockMode::SHARED || req-&gt;lock_mode_ == LockMode::INTENTION_SHARED; &#125;))) &#123;</span><br><span class="line">          it-&gt;second-&gt;cv_.<span class="built_in">wait</span>(req_queue_lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  (*req_it)-&gt;granted_ = <span class="literal">true</span>; <span class="comment">// 标记为已授权</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而唤醒机制就相较简单了，只需在unlock时移出队列并且调用<code>notify_all</code>即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockManager::UnlockTable</span><span class="params">(Transaction *txn, <span class="type">table_oid_t</span> &amp;oid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = table_lock_map_.<span class="built_in">find</span>(oid);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">req_queue_lock</span><span class="params">(it-&gt;second-&gt;latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123; <span class="comment">// 移出队列</span></span><br><span class="line">      <span class="built_in">BUSTUB_ASSERT</span>((*req_it)-&gt;granted_, <span class="string">&quot;Must have been granted in unlock function!&quot;</span>);</span><br><span class="line">      <span class="built_in">delete</span> (*req_it);</span><br><span class="line">      it-&gt;second-&gt;request_queue_.<span class="built_in">erase</span>(req_it);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知其余线程</span></span><br><span class="line">  it-&gt;second-&gt;cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="合法性检测"><a href="#合法性检测" class="headerlink" title="合法性检测"></a>合法性检测</h4><p>我将合法性检验放在了整个函数的最前面。具体来说，需要考虑以下几个因素：</p>
<ol>
<li><p>隔离级别</p>
<p>隔离级别是否支持这种类型的锁？</p>
<p>比如说<code>READ_UNCOMMITTED</code>级别就不支持IS/S/SIX锁，抛出<code>LOCK_SHARED_ON_READ_UNCOMMITTED</code>异常</p>
</li>
<li><p>封锁协议</p>
<p>对于不同的隔离级别，在SHRINKING阶段允许加的锁的类型也不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*    REPEATABLE_READ:</span><br><span class="line">*        The transaction is required to take all locks.</span><br><span class="line">*        All locks are allowed in the GROWING state</span><br><span class="line">*        No locks are allowed in the SHRINKING state</span><br><span class="line">*</span><br><span class="line">*    READ_COMMITTED:</span><br><span class="line">*        The transaction is required to take all locks.</span><br><span class="line">*        All locks are allowed in the GROWING state</span><br><span class="line">*        Only IS, S locks are allowed in the SHRINKING state</span><br><span class="line">*</span><br><span class="line">*    READ_UNCOMMITTED:</span><br><span class="line">*        The transaction is required to take only IX, X locks.</span><br><span class="line">*        X, IX locks are allowed in the GROWING state.</span><br><span class="line">*        S, IS, SIX locks are never allowed</span><br></pre></td></tr></table></figure></li>
<li><p>其它</p>
<p>比如说对于行锁，它需要检测是否已经获取了对应的表锁。这里测试似乎遵循事务与线程一一对应的原则，所以我们应该只用在行锁的前面检测是否获取表锁就行，不用担心执行着执行着表锁没了的情况。我在此采用了通过txn的set判断的方法从而避免了对资源锁的争夺：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> holding_table_lock = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (lock_mode == LockMode::SHARED) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((txn-&gt;<span class="built_in">GetSharedTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetSharedTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetIntentionSharedTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetIntentionSharedTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) !=</span><br><span class="line">       txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>())) &#123;</span><br><span class="line">    holding_table_lock = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) !=</span><br><span class="line">       txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>())) &#123;</span><br><span class="line">    holding_table_lock = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="锁的更新"><a href="#锁的更新" class="headerlink" title="锁的更新"></a>锁的更新</h4><p>TODO，关于锁更新的意图我着实不大了解……等写完本次实验再回过头来看看吧。</p>
<blockquote>
<p><strong>LOCK UPGRADE:</strong><br>   Calling Lock() on a resource <u>that is already locked</u> should have the following behaviour:</p>
<ul>
<li><p>If requested lock mode is the same as that of the lock presently held, Lock() should return true since it already has the lock.</p>
<p>lock_mode不变，则简单地return true</p>
</li>
<li><p>If requested lock mode is different, Lock() should upgrade the lock held by the transaction.</p>
<p>lock_mode有变，需要进行锁的更新</p>
</li>
</ul>
<p>   A lock request being upgraded should be prioritised over other waiting lock requests on the same resource. 这句话值得注意！！！更新锁这个请求是<strong>最高级</strong>的，需要优先处理！！</p>
<p>   While upgrading, <u>only the following transitions should be allowed:</u> 只有下列情况的更新合法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IS -&gt; [S, X, IX, SIX]</span><br><span class="line">S -&gt; [X, SIX]</span><br><span class="line">IX -&gt; [X, SIX]</span><br><span class="line">SIX -&gt; [X]</span><br></pre></td></tr></table></figure>

<p>   Any other upgrade is considered incompatible, and such an attempt should set the TransactionState as ABORTED and throw a TransactionAbortException (INCOMPATIBLE_UPGRADE)</p>
<p>   Furthermore, only one transaction should be allowed to upgrade its lock on a given resource. Multiple concurrent lock upgrades on the same resource should set the TransactionState as ABORTED and throw a TransactionAbortException (UPGRADE_CONFLICT). 不能多个事务同时对某个资源更新锁</p>
</blockquote>
<p>这里大概意思就是，我们要实现锁的更新，并且更新锁这个请求优先级最高，需要优先处理。故而，这里涉及到两个关键问题的处理，一个是如何实现锁的更新，另一个就是如何保证更新锁的优先级。</p>
<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><p>我这里给出的解决方案是，对更新时的更新锁和非更新锁进行分别的处理。</p>
<ol>
<li><p>更新锁</p>
<p>我的实现是在<u>释放旧锁之后</u>进行锁的争取。首先，释放旧锁，但是<u>不调用</u><code>notify_all</code>；如果当前队列中存在正在执行中的并且与新锁相冲突的请求（也即只有在队列中仅存在【兼容的 || 不兼容但还没被授权】的请求时才获取锁），则等待该请求释放。</p>
<blockquote>
<p>这里我本来打算实现先不释放旧锁，等到获取到新锁之后再释放旧锁。也即：</p>
<p>比方说S-&gt;X的情况，①先删除S的授权，然后再走常规锁的流程获取X的授权（也即有没有锁的时期），②先获取X的授权，再删除S的授权（也即有兼有S和X锁的时期）</p>
<p>我本来是选择②的，但现在发现完全没必要这么做，因为这是锁的内部实现，中间这段空窗期是不会有新的事务获取到该资源的（一个是不进行notify，另一个是更新锁优先级最高），故而为实现简单起见（<strong>并且线上测试也是要求先释放锁……</strong>）选择了先释放再获取。</p>
</blockquote>
<p>然后，直到更新锁被唤醒后，将自己插入到请求队列头（头插表示优先级最高）。至此成功被授权。</p>
</li>
<li><p>非更新锁</p>
<p>当更新锁在争取锁时，控制其它所有请求都不争夺授权（也即一直保持ungranted状态，表示优先级最高）。直到冲突请求释放，更新锁被授权，才回到正常的控制流中。</p>
</li>
</ol>
<p>其具体伪代码如下所示（仅以shared为例）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> is_upgraded = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/* case of upgrade */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">    it-&gt;second-&gt;upgrading_ = txn-&gt;<span class="built_in">GetTransactionId</span>();</span><br><span class="line">    is_upgraded = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 先进行解锁操作，但不会进行notify</span></span><br><span class="line">    <span class="built_in">delete</span> (*req_it);</span><br><span class="line">    it-&gt;second-&gt;request_queue_.<span class="built_in">erase</span>(req_it);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!is_upgraded) &#123;	<span class="comment">// 非更新锁的正常控制流。更新锁在后面才插入到队列的首部（表示优先级最高）</span></span><br><span class="line">  it-&gt;second-&gt;request_queue_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> req_it = std::<span class="built_in">prev</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (is_upgraded) &#123;	<span class="comment">// 更新锁需要关注整个队列，而不是它之前的队列</span></span><br><span class="line">  req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (lock_mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> LockMode::SHARED:</span><br><span class="line">    <span class="comment">// 这里条件比较复杂</span></span><br><span class="line">    <span class="comment">// 对于除了更新锁以外的其它锁，第一个条件分支满足，所以就一直等待，直到</span></span><br><span class="line">    <span class="comment">// it-&gt;second-&gt;upgrading_变为INVALID_TXN_ID，也即更新完成</span></span><br><span class="line">    <span class="comment">// 这体现了更新锁的最高级优先级</span></span><br><span class="line">    <span class="keyword">while</span> ((it-&gt;second-&gt;upgrading_ != INVALID_TXN_ID &amp;&amp; !is_upgraded) ||</span><br><span class="line">    <span class="comment">// 而对于更新锁，第一个条件为false，故而看第二个条件</span></span><br><span class="line">    <span class="comment">// 只有在队列中仅存在兼容的（原本控制流中的lock_mode判断语句），    </span></span><br><span class="line">    <span class="comment">// 或者不兼容但还没被授权（(!(req-&gt;granted_)）的请求时才获取锁</span></span><br><span class="line">            (!(std::<span class="built_in">all_of</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(), req_it,</span><br><span class="line">               [is_upgraded, txn, it](LockRequest *req) &#123;</span><br><span class="line">                 <span class="comment">// 【不兼容但还没被授权 || 自己的旧锁 || 兼容的】</span></span><br><span class="line">                 <span class="built_in">return</span> (is_upgraded &amp;&amp; (!(req-&gt;granted_))) || (txn-&gt;<span class="built_in">GetTransactionId</span>() == it-&gt;second-&gt;upgrading_) || req-&gt;lock_mode_ == LockMode::SHARED || req-&gt;lock_mode_ == LockMode::INTENTION_SHARED; &#125;)))) </span><br><span class="line">    &#123;</span><br><span class="line">      it-&gt;second-&gt;cv_.<span class="built_in">wait</span>(req_queue_lock);</span><br><span class="line">      <span class="comment">// 跟上面一样需要更新it</span></span><br><span class="line">      <span class="keyword">if</span> (is_upgraded) &#123;</span><br><span class="line">        req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_upgraded) &#123;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  <span class="keyword">auto</span> upgraded_req = <span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid);</span><br><span class="line">  upgraded_req-&gt;granted_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 更新锁插入到队头，体现其优先级最高</span></span><br><span class="line">  it-&gt;second-&gt;request_queue_.<span class="built_in">push_front</span>(upgraded_req);</span><br><span class="line">  <span class="comment">// 表明更新完成</span></span><br><span class="line">  it-&gt;second-&gt;upgrading_ = INVALID_TXN_ID;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  (*req_it)-&gt;granted_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="更新锁的唯一性"><a href="#更新锁的唯一性" class="headerlink" title="更新锁的唯一性"></a>更新锁的唯一性</h5><p>除此之外，对于某一个资源，同一时刻只能有一个事务更新锁，不然会引发死锁问题，因为机制是持有旧锁的情况下更新新锁。</p>
<p>具体来说可以这样理解：（参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46879188/article/details/113882685">https://blog.csdn.net/weixin_46879188/article/details/113882685</a> 加一些个人实现理解）</p>
<p>一般更新模式由一个事务组成，此事务读取记录，获取资源的S锁，然后修改行，此操作要求锁转换为X锁。</p>
<p>如果两个事务获得了资源上的S锁，然后试图同时更新数据，则一个事务尝试将锁转换为X锁，此时锁队列变化情况为：<code>SS-&gt;SX</code>，发生锁等待。</p>
<p>第二个事务也试图获取X锁以进行更新，注意此刻它是不进行notify地释放锁。这时候，它会由于不满足<code>it-&gt;second-&gt;upgrading_ != INVALID_TXN_ID</code>这个条件一直卡住，另一个事务也迟迟收不到notify，从而导致死锁情况发生。</p>
<p>那么可能就要问了，我们能不能修改一下沉睡的条件，也即将更新事务从一个拓展为一个数组，然后限制多个同时获取更新锁的情况下一个真获取其他等待呢？那么我们也很容易从结果看出，这种情况下不也跟同一时刻只能有一个事务更新锁是一个道理。。。所以不如简单粗暴地限制这个条件。</p>
<p>而再至于为什么多个事务同时更新锁是不合法的（也即会抛出异常而非简单返回false），我想这就是事务调度问题了。同一时刻两个事务都在更新某个资源，显而易见是调度出错了，所以理所当然应该抛出异常。</p>
<h3 id="Task-2-Deadlock-Detection"><a href="#Task-2-Deadlock-Detection" class="headerlink" title="Task #2 - Deadlock Detection"></a>Task #2 - Deadlock Detection</h3><blockquote>
<p>Your lock manager should run deadlock detection in a background thread, periodically building a waits-for graph and abort transactions as needed to eliminate deadlocks.</p>
<p><strong>REQUIREMENTS</strong></p>
<p>You must implement and use the following graph API for cycle detection:</p>
<ul>
<li><code>AddEdge(txn_id_t t1, txn_id_t t2)</code>: Adds an edge in your graph from <code>t1</code> to <code>t2</code>, representing that <code>t1</code> is waiting for <code>t2</code>. If the edge already exists, you don’t have to do anything.</li>
<li><code>RemoveEdge(txn_id_t t1, txn_id_t t2)</code>: Removes edge <code>t1</code> to <code>t2</code> from your graph. If no such edge exists, you don’t have to do anything.</li>
<li><code>HasCycle(txn_id_t&amp; txn_id)</code>: Looks for a cycle by using depth-first search (DFS). If it finds a cycle, <code>HasCycle</code> should store the transaction id of the youngest transaction in the cycle in <code>txn_id</code> and return true. Your function should return the first cycle it finds. If your graph has no cycles, <code>HasCycle</code> should return false.</li>
<li><code>GetEdgeList()</code>: Returns a list of tuples representing the edges in your graph. We will use this to test correctness of your graph. A pair <code>(t1,t2)</code> corresponds to an edge from <code>t1</code> to <code>t2</code>.</li>
<li><code>RunCycleDetection()</code>: Contains skeleton code for running cycle detection in the background. You should implement your cycle detection algorithm here.</li>
</ul>
<p>You may implement the graph however you want, as long as you support the above API. We will use that API to test your implementation.</p>
<p>You may need to access the status of a transaction from the member variable <code>txn_manager_</code>. If <code>txn_manager_</code> is set to <code>nullptr</code>, <code>StartDeadlockDetection</code> will not be called, and you do not need to detect deadlocks.</p>
<h5 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h5><ul>
<li>Your background thread should build the waits-for graph every time it wakes up. You should not maintain the waits-for graph over time; it should be built and destroyed every time the deadlock detection thread wakes up.</li>
<li>Your cycle detection algorithm must be deterministic. To achieve this, you should always explore the lowest transaction id first, by starting the depth-first search from the node with lowest transaction id and exploring neighbors in order (by transaction id) when searching from a node.</li>
<li>When you find a cycle, abort the <strong>youngest</strong> transaction to break the cycle by setting that transaction’s state to ABORTED.</li>
<li>When your detection thread wakes up, it must break all cycles that exist. If you follow the above requirements, you will always find the cycles in a deterministic order. This also means that, when you are building your graph, you should not add nodes for aborted transactions or draw edges to aborted transactions.</li>
<li>Your background cycle detection algorithm may need to get a pointer to a transaction using a <code>txn_id</code>. There is a member variable <code>txn_manager_</code> in lock manager, and <code>Transaction* GetTransaction(txn_id_t txn_id)</code> enables you do that.</li>
</ul>
<h5 id="HINTS"><a href="#HINTS" class="headerlink" title="HINTS"></a>HINTS</h5><ul>
<li>Remember that the waits-for graph is a directed graph, with an edge for each transaction waiting for another transaction. Because multiple transactions may share a lock on the same object, a single transaction may be waiting for multiple transactions.</li>
<li>When a transaction is aborted, set the transaction’s state to <code>ABORTED</code>. The transaction manager should then take care of the explicit abort and rollback changes.</li>
<li>A transaction waiting for a lock may be aborted by the background cycle detection thread. You must have a way to notify waiting transactions that they’ve been aborted.</li>
<li>You can use <code>std::this_thread::sleep_for</code> to help write test cases, to cause threads to wake up in a pre-defined order. You can also tweak <code>CYCLE_DETECTION_INTERVAL</code> in <code>common/config.h</code> in your test cases.</li>
</ul>
</blockquote>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/labs/"># labs</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/03/13/cmu15445$lab2/">Project2   B+Tree</a>
            
            
            <a class="next" rel="next" href="/2023/03/13/cmu15445$lab3/">Project3   Query Execution</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 修年 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>