<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="修年">





<title>CMU15445 | 修年</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiunian&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiunian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc" style="right: -4em;">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">CMU15445</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">修年</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">三月 13, 2023&nbsp;&nbsp;22:19:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <blockquote>
<p><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/">实验官网</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/xiunianjun/cmu15445">代码</a></p>
</blockquote>
<h3 id="Project0-C-Primer"><a href="#Project0-C-Primer" class="headerlink" title="Project0   C++ Primer"></a><a href="/2023/03/13/cmu15445$lab0">Project0   C++ Primer</a></h3><h3 id="Project1-Buffer-Pool"><a href="#Project1-Buffer-Pool" class="headerlink" title="Project1   Buffer Pool"></a><a href="/2023/03/13/cmu15445$lab1">Project1   Buffer Pool</a></h3><h3 id="Project2-B-Tree-Index"><a href="#Project2-B-Tree-Index" class="headerlink" title="Project2   B+Tree Index"></a><a href="/2023/03/13/cmu15445$lab2">Project2   B+Tree Index</a></h3><h1 id="Project3-Query-Execution"><a href="#Project3-Query-Execution" class="headerlink" title="Project3   Query Execution"></a>Project3   Query Execution</h1><blockquote>
<p>In this project, you will implement the components that allow BusTub to execute queries. You will create the operator executors that execute SQL queries and implement optimizer rules to transform query plans.</p>
<p>实现SQL查询的执行，并且实现语句优化。</p>
</blockquote>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Bustub-Framewor"><a href="#Bustub-Framewor" class="headerlink" title="Bustub Framewor"></a>Bustub Framewor</h3><p><img src="/2023/03/13/cmu15445/image-20231227153858926.png" alt="image-20231227153858926"></p>
<h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>介绍完了bustub的框架之后，它对通过语法树进行查询优化进行了详细的样例介绍。</p>
<p>首先温习一下什么是语法树（<em>abstract syntax tree, AST</em> ）：</p>
<p>SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Select `title`</span><br><span class="line">From Books, Borrowers, Loans</span><br><span class="line">Where Books.LC_NO = Loans.LC_NO and Borrowers.CARD_NO = Loans.CARD_NO and DATE &lt;= 1/1/78</span><br></pre></td></tr></table></figure>

<p>其语法树表示+优化结果如下图所示：</p>
<p><img src="/2023/03/13/cmu15445/image-20231227155236633.png" alt="image-20231227155236633"></p>
<p>算法如下，其关键思路就是选择投影尽早做，能移多下去就移多下去</p>
<p><img src="/2023/03/13/cmu15445/image-20231227155806019.png" alt="image-20231227155806019"></p>
<p>而这里15445介绍的也是这样的语法树优化算法。</p>
<p>首先记录一下它这几个专有名词对应的操作：</p>
<blockquote>
<ol>
<li>Projection：投影</li>
<li>Filter：选择</li>
<li>MockScan：对一个表进行的扫描操作</li>
<li>Aggregation：聚合函数</li>
<li>NestedLoopJoin：嵌套循环连接</li>
</ol>
</blockquote>
<p>再结合它给的几个语法树的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM __mock_table_1;</span><br><span class="line"></span><br><span class="line">=== PLANNER ===</span><br><span class="line">Projection &#123; exprs=[#<span class="number">0.0</span>, #<span class="number">0.1</span>] &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)</span><br><span class="line">	MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)</span><br><span class="line">=== OPTIMIZER ===</span><br><span class="line">MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT colA, MAX(colB) FROM</span><br><span class="line">  (SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE) GROUP BY colA;</span><br><span class="line"></span><br><span class="line">=== OPTIMIZER ===</span><br><span class="line">Agg &#123; types=[max], aggregates=[#<span class="number">0.1</span>], group_by=[#<span class="number">0.0</span>] &#125;</span><br><span class="line">  NestedLoopJoin &#123; type=Inner, predicate=(#<span class="number">0.0</span>=#<span class="number">1.0</span>) &#125;</span><br><span class="line">    MockScan &#123; table=__mock_table_1 &#125;</span><br><span class="line">    MockScan &#123; table=__mock_table_3 &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/13/cmu15445/image-20231227160450894.png" alt="image-20231227160450894"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM __mock_table_1 WHERE colA &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">=== OPTIMIZER ===                                     </span><br><span class="line"> Filter &#123; predicate=(#<span class="number">0.0</span>&gt;<span class="number">1</span>) &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)         </span><br><span class="line">   MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">values (<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">=== PLANNER === </span><br><span class="line">Projection &#123; exprs=[#<span class="number">0.0</span>, #<span class="number">0.1</span>, #<span class="number">0.2</span>] &#125; | (__values#<span class="number">0.0</span>:INTEGER, __values#<span class="number">0.1</span>:INTEGER, __values#<span class="number">0.2</span>:VARCHAR) </span><br><span class="line">Values &#123; rows=<span class="number">2</span> &#125; | (__values#<span class="number">0.0</span>:INTEGER, __values#<span class="number">0.1</span>:INTEGER, __values#<span class="number">0.2</span>:VARCHAR)                     </span><br><span class="line">=== OPTIMIZER ===</span><br><span class="line">Values &#123; rows=<span class="number">2</span> &#125; | (__values#<span class="number">0.0</span>:INTEGER, __values#<span class="number">0.1</span>:INTEGER, __values#<span class="number">0.2</span>:VARCHAR)</span><br></pre></td></tr></table></figure>

<p>可以看到，它大概是用缩进来表示了AST的父子关系。</p>
<p>我们课上学习的语法树中每个table标志对应着一个MockScan；笛卡尔积+选择操作可以表示为一个NestedLoopJoin。</p>
<p>对于这些输出的意义，指导书也给了详细的解释：</p>
<p>ColumnValueExpression</p>
<p>也即类似<code>exprs=[#0.0, #0.1]</code>，<code>#0</code>意为<strong>第一个子节点</strong>（不是第一个表的意思。。）</p>
<h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><blockquote>
<p>In this project, you will add new <strong>operator executors</strong> and <strong>query optimizations</strong> to BusTub. </p>
<p>BusTub uses the <strong>iterator</strong> (i.e., Volcano) query processing model, in which <u>every executor implements a <code>Next</code> function to get the next tuple result</u>. </p>
<p>When the DBMS invokes an executor’s <code>Next</code> function, the executor returns either:</p>
<p> (1) a single tuple</p>
<p>​    In BusTub’s implementation of the iterator model, 除了元组外还会返回<strong>record identifier</strong> (<code>RID</code>)</p>
<p> (2) an indicator that there are no more tuples. </p>
<p>With this approach, each executor implements a loop that continues calling <code>Next</code> on its children to retrieve tuples and process them one by one.</p>
</blockquote>
<h3 id="ADDITIONAL-INFORMATION"><a href="#ADDITIONAL-INFORMATION" class="headerlink" title="ADDITIONAL INFORMATION"></a>ADDITIONAL INFORMATION</h3><h4 id="System-Catalog"><a href="#System-Catalog" class="headerlink" title="System Catalog"></a>System Catalog</h4><blockquote>
<p>The entirety of the catalog implementation is in <code>src/include/catalog/catalog.h</code>. You should pay particular attention to the member functions <code>Catalog::GetTable()</code> and <code>Catalog::GetIndex()</code>. You will use these functions in the implementation of your executors to query the catalog for tables and indexes.</p>
</blockquote>
<p>它意思大概是说在实现executor时可能需要用到catelog里这两个函数。</p>
<p><code>GetTable</code>返回一个<code>TableInfo</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TableInfo</span> &#123;</span><br><span class="line">  <span class="comment">/** The table schema */</span></span><br><span class="line">  Schema schema_;</span><br><span class="line">  <span class="comment">/** The table name */</span></span><br><span class="line">  <span class="type">const</span> std::string name_;</span><br><span class="line">  <span class="comment">/** An owning pointer to the table heap */</span></span><br><span class="line">  std::unique_ptr&lt;TableHeap&gt; table_;</span><br><span class="line">  <span class="comment">/** The table OID */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">table_oid_t</span> oid_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>For the table modification executors (<code>InsertExecutor</code>, <code>UpdateExecutor</code>, and <code>DeleteExecutor</code>) you must modify all indexes for the table targeted by the operation. You may find the <code>Catalog::GetTableIndexes()</code> function useful for querying all of the indexes defined for a particular table. Once you have the <code>IndexInfo</code> instance for each of the table’s indexes, you can invoke index modification operations on the underlying index structure.</p>
<p>In this project, we use your implementation of B+ Tree Index from Project 2 as the underlying data structure for all index operations. Therefore, successful completion of this project relies on a working implementation of the B+ Tree Index.</p>
</blockquote>
<p><strong>话说index是那个索引吗，就是每张表有几个建立在某个属性的索引，也即一张表可以有n棵b+树</strong></p>
<p><code>GetIndex</code>返回一个<code>IndexInfo</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexInfo</span> &#123;</span><br><span class="line">  <span class="comment">/** The schema for the index key */</span></span><br><span class="line">  Schema key_schema_;</span><br><span class="line">  <span class="comment">/** The name of the index */</span></span><br><span class="line">  std::string name_;</span><br><span class="line">  <span class="comment">/** An owning pointer to the index */</span></span><br><span class="line">  std::unique_ptr&lt;Index&gt; index_;</span><br><span class="line">  <span class="comment">/** The unique OID for the index */</span></span><br><span class="line">  <span class="type">index_oid_t</span> index_oid_;</span><br><span class="line">  <span class="comment">/** The name of the table on which the index is created */</span></span><br><span class="line">  std::string table_name_;</span><br><span class="line">  <span class="comment">/** The size of the index key, in bytes */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> key_size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Optimizer-Rule-Implementation-Guide"><a href="#Optimizer-Rule-Implementation-Guide" class="headerlink" title="Optimizer Rule Implementation Guide"></a>Optimizer Rule Implementation Guide</h4><blockquote>
<p>The BusTub optimizer is a <strong>rule-based optimizer</strong>. Most optimizer rules construct optimized plans in a <strong>bottom-up way</strong>(自底向上). Because the query plan has this tree structure, before applying the optimizer rules to the current plan node, you want to first recursively apply the rules to its children.</p>
<p>At each plan node, you should determine if the source plan structure matches the one you are trying to optimize, and then check the attributes in that plan to see if it can be optimized into the target optimized plan structure.</p>
<p><u>In the public BusTub repository, we already provide the implementation of several optimizer rules. Please take a look at them as reference.</u></p>
</blockquote>
<h3 id="Task1-Access-Method-Executors"><a href="#Task1-Access-Method-Executors" class="headerlink" title="Task1  Access Method Executors"></a>Task1  Access Method Executors</h3><blockquote>
<p>In the background section above, we saw that the BusTub can already retrieve data from mock tables in <code>SELECT</code> queries. </p>
<p>This is implemented without real tables by using a <code>MockScan</code> executor to always generate the same tuples using a predefined algorithm. </p>
<p>This is why you cannot update these tables.</p>
</blockquote>
<p>也就是说意思是目前的mockscan executor不是真的查表，而是返回固定的元组。</p>
<p>看了一遍代码，感觉大概明白了。我们可以来看一下迭代器的Next函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">MockScanExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cursor_ == size_) &#123;</span><br><span class="line">    <span class="comment">// Scan complete</span></span><br><span class="line">    <span class="keyword">return</span> EXECUTOR_EXHAUSTED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shuffled_idx_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    *tuple = <span class="built_in">func_</span>(cursor_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *tuple = <span class="built_in">func_</span>(shuffled_idx_[cursor_]);</span><br><span class="line">  &#125;</span><br><span class="line">  ++cursor_;</span><br><span class="line">  *rid = <span class="built_in">MakeDummyRID</span>();</span><br><span class="line">  <span class="keyword">return</span> EXECUTOR_ACTIVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心就是调用func_来获取表的元组。</p>
<p>也就是说是这样的，每个MockScanExecutor用来执行一个plan，那么也就对应着某一个table。通过执行某一个table特定的迭代function，就可以返回元组。</p>
<p>这个迭代function比如说对于表tas_2023是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (table == <span class="string">&quot;__mock_table_tas_2023&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [plan](<span class="type">size_t</span> cursor) &#123;</span><br><span class="line">    std::vector&lt;Value&gt; values&#123;&#125;;</span><br><span class="line">    values.<span class="built_in">push_back</span>(ValueFactory::<span class="built_in">GetVarcharValue</span>(ta_list_2023[cursor]));</span><br><span class="line">    values.<span class="built_in">push_back</span>(ValueFactory::<span class="built_in">GetVarcharValue</span>(ta_oh_2023[cursor]));</span><br><span class="line">    <span class="keyword">return</span> Tuple&#123;values, &amp;plan-&gt;<span class="built_in">OutputSchema</span>()&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即<strong>MockScanExecutor负责对表指针的管理，function负责实际对表的物理访问</strong>。这样就成功解耦了。</p>
<blockquote>
<p>In this task, you will implement executors that read from and write to tables in the storage system. </p>
<ul>
<li><code>src/execution/seq_scan_executor.cpp</code></li>
<li><code>src/execution/insert_executor.cpp</code></li>
<li><code>src/execution/update_executor.cpp</code></li>
<li><code>src/execution/delete_executor.cpp</code></li>
<li><code>src/execution/index_scan_executor.cpp</code></li>
</ul>
</blockquote>
<p>而我们本次实验就是需要实现这么一大堆的executor。看来又是个体力活了。</p>
<h4 id="seq-scan"><a href="#seq-scan" class="headerlink" title="seq_scan"></a>seq_scan</h4><h5 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h5><h6 id="c-知识"><a href="#c-知识" class="headerlink" title="c++知识"></a>c++知识</h6><p><img src="/2023/03/13/cmu15445/image-20240115121419677.png" alt="image-20240115121419677"></p>
<p>可以看到，前缀++重载的运算符方法和后缀++是不一样的。</p>
<h6 id="MockScan"><a href="#MockScan" class="headerlink" title="MockScan"></a>MockScan</h6><p>值得一提的是它跟MockScan的关系。MockScan是一种模拟操作，所以各种表都是硬编码在它的mock_scan.h里的；而SeqScan就是真正的遍历操作了，它需要获取tuple就需要通过各种复杂的物理操作和封装一步步读取了。</p>
<h6 id="physical-layer"><a href="#physical-layer" class="headerlink" title="physical layer"></a>physical layer</h6><p>通过实现SeqScan，我们可以初步窥探整个bustub物理层面交互的架构。</p>
<p>跟之前project中的索引entry一样，实际的数据tuple也保存在page中，其对应类为<code>TablePage</code>。并且是堆文件组织结构：</p>
<p><img src="/2023/03/13/cmu15445/image-20240115114448798.png" alt="image-20240115114448798"></p>
<blockquote>
<p><code>TablePage</code>的结构值得一提。</p>
<p>在它的成员定义中，我们可以看到其中有两个柔性数组成员（Flexible array member）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> page_start_[<span class="number">0</span>];</span><br><span class="line">TupleInfo tuple_info_[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>之前的Project2，我们只接触过一个的case，这里的两个感觉其实也同理可得，相当于<code>page_start_</code>和<code>tuple_info_</code>都指向最末尾空闲空间的开始。</p>
<p><code>TablePage</code>的实际存储结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  increase											   increase  &lt;-</span><br><span class="line">| ------------------------------- | ********************************* |</span><br><span class="line">↑								  ↑</span><br><span class="line">page_start &amp; tuple_info    +TUPLE_INFO_SIZE*<span class="title function_">sizeof</span><span class="params">(TupleInfo)</span></span><br></pre></td></tr></table></figure>

<p>也即tuple info存储在前半部分，tuple data存储在后半部分，并且二者增长方式相反。</p>
</blockquote>
<p>而多页<code>TablePage</code>就构成了一个<code>TableHeap</code>，也即其物理存储空间。每次创建表时，我们就会分配对应的heap空间和相关meta data。<code>TableHeap</code>对外提供了增删改查元组的方法，也提供了一个迭代器实现<code>TableIterator</code>，用于遍历里面的元素。</p>
<p>而由于元组tuple存储在磁盘中，所以我们需要在读取它的值的时候先进行反序列化<code>DeserializeFrom</code>，这个过程需要用到表的类型信息和offset信息之类的，所以<code>Tuple::GetValue</code>需要传入<code>schema</code>参数。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>它基本原理也就是顺序遍历整张表，没什么好说的。</p>
<p>在本次的sequence scan实现中，我们就需要首先获取表对应的iterator：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 巨长一串</span></span><br><span class="line">table_iterator_ = std::<span class="built_in">make_unique</span>&lt;TableIterator&gt;(exec_ctx_-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">GetTableOid</span>())-&gt;table_-&gt;<span class="built_in">MakeIterator</span>());</span><br></pre></td></tr></table></figure>

<p>然后通过这个iterator不断迭代获取元素即可。</p>
<h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><h5 id="一些想法-1"><a href="#一些想法-1" class="headerlink" title="一些想法"></a>一些想法</h5><h6 id="recursive-execute"><a href="#recursive-execute" class="headerlink" title="recursive execute"></a>recursive execute</h6><p>对于SQL的嵌套子查询，bustub采用的是递归实现。具体来说，以insertion为例：</p>
<p>外界调用情况如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute a query plan.</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Execute</span><span class="params">(...)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Construct the executor for the abstract plan node</span></span><br><span class="line">  <span class="keyword">auto</span> executor = ExecutorFactory::<span class="built_in">CreateExecutor</span>(exec_ctx, plan);      </span><br><span class="line">  executor-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  <span class="built_in">PollExecutor</span>(executor.<span class="built_in">get</span>(), plan, result_set);</span><br><span class="line">  <span class="built_in">PerformChecks</span>(exec_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CreateExecutor</code>是一个递归函数，递归创建每个子查询的实例，把对应的executor返回给父查询</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ExecutorFactory::CreateExecutor</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    -&gt; std::unique_ptr&lt;AbstractExecutor&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">switch</span> (plan-&gt;<span class="built_in">GetType</span>()) &#123;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">case</span> PlanType::SeqScan: &#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;SeqScanExecutor&gt;(exec_ctx, <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> SeqScanPlanNode *&gt;(plan.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">case</span> PlanType::Insert: &#123;</span><br><span class="line">      <span class="keyword">auto</span> insert_plan = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> InsertPlanNode *&gt;(plan.<span class="built_in">get</span>());</span><br><span class="line">      <span class="comment">// 递归创建每个子查询的实例</span></span><br><span class="line">      <span class="keyword">auto</span> child_executor = ExecutorFactory::<span class="built_in">CreateExecutor</span>(exec_ctx, insert_plan-&gt;<span class="built_in">GetChildPlan</span>());</span><br><span class="line">      <span class="comment">// 把对应的executor返回给父查询</span></span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;InsertExecutor&gt;(exec_ctx, insert_plan, std::<span class="built_in">move</span>(child_executor));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们再在父查询的Init中调用子查询的Init</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，就能递归实现嵌套子查询。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><blockquote>
<p>The <code>InsertExecutor</code> inserts tuples into a table and <strong>updates any affected indexes</strong>.</p>
<p>The planner will ensure that the values have the same schema as the table. The executor will produce a single tuple of integer type as the output, indicating how many rows have been inserted into the table.</p>
</blockquote>
<p>这里将Insert语句插入的值视为一个匿名子表，对其初始化后使用它的迭代器进行元素访问即可。</p>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><h5 id="一些想法-2"><a href="#一些想法-2" class="headerlink" title="一些想法"></a>一些想法</h5><h6 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h6><p>bustub将一切表达式抽象为了这么几个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AbstractExpression <span class="comment">// 基类</span></span><br><span class="line">ConstantValueExpression <span class="comment">// 常量值表达式</span></span><br><span class="line">ColumnValueExpression <span class="comment">// 列值表达式，访问某一列的值</span></span><br><span class="line">ArithmeticExpression <span class="comment">// 算术表达式，树递归结构，子节点是值or算术表达式</span></span><br><span class="line">ComparisonExpression <span class="comment">// 比较表达式，表示两个表达式</span></span><br><span class="line">LogicExpression <span class="comment">// 逻辑表达式</span></span><br><span class="line">StringExpression <span class="comment">// 字符串表达式，包括原字符串or upper之类的</span></span><br></pre></td></tr></table></figure>

<p>而从UpdatePlanNode中，我们可以获取到update字句的所有表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The new expression at each column */</span></span><br><span class="line">std::vector&lt;AbstractExpressionRef&gt; target_expressions_;</span><br></pre></td></tr></table></figure>

<p>比如此处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bustub&gt; explain (o,s) update test_1 <span class="built_in">set</span> colB = <span class="number">15445</span>;</span><br><span class="line">=== OPTIMIZER ===</span><br><span class="line"><span class="comment">// 可以注意这边target_exprs的值</span></span><br><span class="line">Update &#123; table_oid=<span class="number">20</span>, target_exprs=[#<span class="number">0.0</span>, <span class="number">15445</span>, #<span class="number">0.2</span>, #<span class="number">0.3</span>] &#125; | (__bustub_internal.update_rows:INTEGER)</span><br><span class="line">  SeqScan &#123; table=test_1 &#125; | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER)</span><br></pre></td></tr></table></figure>

<p>然后我们分别计算每个expression的值，就可以获取更新之后的元组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// insert again</span></span><br><span class="line">   std::vector&lt;Value&gt; insert_values;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> exp : plan_-&gt;target_expressions_) &#123;</span><br><span class="line">     <span class="comment">// tuple为旧值元组</span></span><br><span class="line">     insert_values.<span class="built_in">push_back</span>(exp-&gt;<span class="built_in">Evaluate</span>(&amp;tuple, table_info-&gt;schema_));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 注意table_info应为要插入的表的info，此处易写为update plan子表的info</span></span><br><span class="line">   table_heap-&gt;<span class="built_in">InsertTuple</span>(<span class="built_in">TupleMeta</span>(), <span class="built_in">Tuple</span>(insert_values, &amp;(table_info-&gt;schema_)));</span><br></pre></td></tr></table></figure>



<h6 id="lazy-delete"><a href="#lazy-delete" class="headerlink" title="lazy delete"></a>lazy delete</h6><p>删除元组的实现似乎只是简单地标记<code>is_delete_</code>为true就好了。但是我在实际的代码实现（<code>InsertTuple</code>）中似乎并没有看到重组删除空间or覆盖删除空间，每次插入页满只是简单地再申请新的一页，不会再回头。也许是为了简化起见暂不实现这个吧。</p>
<p>不过改进方法也很简单，对每个表进行固定分配页（或者说提供一个数据量达到百分之几的时候扩容的机制），然后页面间组织成环形链表，这样就能充分覆盖删除空间，同时也兼顾一定性能了。</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><p>update的实现也不会很难，只需先删除原来的元组，再加个新元组即可。</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>delete的实现完全照搬update就行，没什么好说的。</p>
<h4 id="index-scan"><a href="#index-scan" class="headerlink" title="index_scan"></a>index_scan</h4><blockquote>
<p>The <code>IndexScanExecutor</code> iterates over an <strong>index</strong> to retrieve <code>RIDs</code> for tuples. The operator then uses these RIDs to retrieve their tuples in the corresponding table. It then emits these tuples one at a time.</p>
<p>You can test your index scan executor by <code>SELECT FROM &lt;table&gt; ORDER BY &lt;index column&gt;</code>. We will explain why <code>ORDER BY</code> can be transformed into <code>IndexScan</code> in <a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project3/#task3">Task #3</a>.     哦吼，也就是说order-by会被翻译为index scan？那order-by的关键字如果不存在索引会怎么样，现建吗</p>
<p>BusTub only supports indexes with a single, unique integer column. Our test cases will not contain duplicate keys. The type of the index object in the plan will <strong>always be</strong> <code>BPlusTreeIndexForTwoIntegerColumn</code> in this project. You can safely cast it and store it in the executor object:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BPlusTreeIndexForTwoIntegerColumn = BPlusTreeIndex&lt;IntegerKeyType, IntegerValueType, IntegerComparatorType&gt;;</span><br><span class="line"></span><br><span class="line">tree_ = <span class="built_in">dynamic_cast</span>&lt;BPlusTreeIndexForTwoIntegerColumn *&gt;(index_info_-&gt;index_.<span class="built_in">get</span>())</span><br></pre></td></tr></table></figure>

<p>但我看测试里怎么好像有两个键的index？</p>
<p>You can then construct an index iterator from the index object, scan through all the keys and tuple IDs, lookup the tuple from the table heap, and emit all tuples in order. </p>
<p>是的，project2的b+树实现确实只存了rid，然后我们通过rid就能知道实际的物理位置了</p>
</blockquote>
<h5 id="一些想法-3"><a href="#一些想法-3" class="headerlink" title="一些想法"></a>一些想法</h5><h6 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h6><p>通过b+树组织索引结构，索引结点中存的是RID，RID可以用来指示tuple的物理位置，于是我们通过RID就可以获取到tuple，从而减少了磁盘IO。RID结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RID: Record Identifier</span></span><br><span class="line"><span class="comment">// 高32位是pgid，低32位是slot num</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RID</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">RID</span><span class="params">(<span class="type">int64_t</span> rid)</span> : page_id_(static_cast&lt;page_id_t&gt;(rid &gt;&gt; <span class="number">32</span>)), slot_num_(static_cast&lt;uint32_t&gt;(rid)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">int64_t</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(page_id_)) &lt;&lt; <span class="number">32</span> | slot_num_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">page_id_t</span> page_id_&#123;INVALID_PAGE_ID&#125;;</span><br><span class="line">  <span class="type">uint32_t</span> slot_num_&#123;<span class="number">0</span>&#125;;  <span class="comment">// logical offset from 0, 1...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并且，bustub保证了对于有索引的表，是不会有重复元组的，故而b+树实际上应该是一个稠密索引。</p>
<p>（毕竟这个情况似乎有点复杂……物理存储上应该是按插入顺序顺序存储的，故而重复元组可能不放在一起，而我们实现的b+树又不支持重复结点，所以就会g。如果想要支持重复元组，可能就需要从两个改变思路入手，要么是修改b+树支持重复索引结点，此时b+树依然为稠密索引；要么是修改为链式存储结构以支持重复元组放在一起，此时b+树为稀疏索引。）</p>
<h6 id="c-知识-1"><a href="#c-知识-1" class="headerlink" title="c++知识"></a>c++知识</h6><p>非常非常崩溃，怎么保存索引尝试了很久都没做到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样不行……</span></span><br><span class="line">std::unique_ptr&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt; iterator_;</span><br><span class="line">iterator_ = std::<span class="built_in">make_unique</span>&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt;(std::<span class="built_in">move</span>(tree_-&gt;<span class="built_in">GetBeginIterator</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样也不行……</span></span><br><span class="line">BPlusTreeIndexIteratorForTwoIntegerColumn iterator_;</span><br><span class="line">iterator_ = std::<span class="built_in">move</span>(tree_-&gt;<span class="built_in">GetBeginIterator</span>());</span><br></pre></td></tr></table></figure>

<p>没办法，最终只能保存tree，iterator在next里动态获取了，我真是服了。等之后看完c++primer或者c++水平有所提升了再来解决这个问题吧。</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><p>难绷，本来以为这个index-scan应该是最简单的，毕竟只用调用现成索引接口，没想到居然写了最久，可能足足两三个小时。。。</p>
<p>首先的一个大难点就是如何保存迭代器了。在之前的seq-scan的时候，使用的是unique ptr，然而这里却不行会报一堆奇奇怪怪的错误（具体见<code>一些想法-c++知识</code>）。最后只能换一个思路，不保存迭代器而是保存<code>next_key_</code>了。然而又由于之前b+树的实现bug问题，导致对end iterator解引用是合法的，所以会产生各种奇奇怪怪的错误。解决了这个之后，之前写的insert、update、delete的更新索引部分又出了问题，rid和insert_key弄错了，诸如此类。</p>
<p>总之，解决了这一大堆小问题之后，才总算通过了index-scan的测试，真是令人南蚌。具体改了什么bug可以详情见<code>b8d3ba546cfdea6fc576ad8d668322c87f6386c1</code>这个commit。</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/labs/"># labs</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/03/13/cmu15445$lab2/">Project2   B+Tree</a>
            
            
            <a class="next" rel="next" href="/2023/03/13/cmu15445$lab0/">Project0   C++ Primer</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 修年 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>