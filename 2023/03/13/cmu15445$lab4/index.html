<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="修年">





<title>Project4   Concurrency | 修年</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiunian&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiunian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc" style="right: -4em;">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Project4   Concurrency</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">修年</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">三月 13, 2023&nbsp;&nbsp;22:19:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Project4-Concurrency"><a href="#Project4-Concurrency" class="headerlink" title="Project4   Concurrency"></a>Project4   Concurrency</h1><p>在上面的project中，我们实现了负责管理内存页缓冲与磁盘的、用于一切数据和索引页管理的buffer pool，然后实现了一个b+树索引，最后实现了增删改查等操作的底层执行器以及部分查询优化规则。这一小节，我们将完成数据库的并发控制。需要关注<strong>事务的原子性的实现和事务的调度</strong>，关注事务并行执行时的正确性。</p>
<blockquote>
<p>In this project, you will add support for <strong>transactions</strong> in BusTub by adding a lock manager and then using it for concurrent query execution. </p>
<p>The lock manager will support <strong>table locks</strong> and <strong>tuple locks</strong> in <strong>five</strong> lock modes: intention-shared, intention-exclusive, shared-intention-exclusive, shared, and exclusive. </p>
<p>The lock manager will <u>process lock requests from transactions</u>, grant locks to transactions, and check if locks are released appropriately based on the <strong>transaction’s isolation level</strong>.</p>
</blockquote>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78897428">聊一聊数据库中的锁 - 老刘的文章 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/51676675">一文了解db2的锁 - somenzz的文章 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3aa634b0567c">CMU 15445 14.二阶段锁定 + homework 4</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/488482354">【15-445】8.事务(3)串行化 - 只爱睡觉的文章 - 知乎</a>  这篇文章写得很棒</p>
</blockquote>
<h4 id="多级粒度锁机制"><a href="#多级粒度锁机制" class="headerlink" title="多级粒度锁机制"></a>多级粒度锁机制</h4><p>假设存在如下需求：事务T需要访问一个有1亿个元组的数据库。</p>
<p>我们希望T只发出单个请求就能封锁整个数据库，因此这里需要引入允许系统定义<strong>多级粒度</strong>(granularity)锁的机制，并允许定义各种大小的数据项和数据粒度的层次结构。这种层次结构可以图形化地表示为树。</p>
<p><img src="/2023/03/13/cmu15445/v2-6a8363d4fada6e578c03b3d8d87c4813_1440w.webp" alt="img"></p>
<p>树中每个结点都可以单独加锁。当一个事务对一个结点加锁时，该事务也以同样类型的锁<strong>隐式地封锁这个结点的全部子结点</strong>。</p>
<p>但这样处理存在一个问题：事务T希望封锁整个子树，因此它只需给子树的根结点加锁。但是如果T在子树的某部分持有锁，那么T给该根结点加锁就会失败。<strong>如何判定根结点是否可以加锁呢</strong>？一种可能的方法是搜索整棵树。然而，这个方法破坏了多粒度封锁机制的初衷。另一种方法是引入一种新的锁类型，即<strong>意向锁类型</strong>( intentionlock mode)。</p>
<p>如果一个结点加上了意向锁，则意味着将要在树的较低层进行显式加锁(也就是说，以更小的粒度加锁)。这里有三种意向锁：</p>
<ul>
<li>**Intention-Shared (IS)**：说明在较低级别会使用共享锁（S）来显式上锁。</li>
<li>**Intention-Exclusive (IX)**：说明在较低级会使用互斥锁（X）来显式上锁</li>
<li><strong>Shared+Intention-Exclusive (SIX)<strong>：以该节点为根的子树</strong>已经显式得到了共享锁</strong>，并且<strong>将要</strong>在树的更低层次显示加上互斥锁。</li>
</ul>
<p>对某个结点进行加锁之前，需要获取它到根节点路径上的所有相关意向锁，具体规则如下图所示：</p>
<p><img src="/2023/03/13/cmu15445/webp-1706931395906-19.webp" alt="img"></p>
<p>引入该机制后，在一个结点显式加锁之前，该结点的全部祖先均需要加上意向锁。当我们希望给某个结点加锁时，事务必须遍历从根到该节点的路径，判断路径上的节点是否被加了意向锁：如果已加，则该显示加锁过程不能成功；如果未加，<strong>则给该路径上的节点加上意向锁</strong>。</p>
<h4 id="实际实现"><a href="#实际实现" class="headerlink" title="实际实现"></a>实际实现</h4><p>如上节所示，锁定层次结构有多种粒度：</p>
<p><img src="/2023/03/13/cmu15445/v2-34a703b4147e594149bc2a8d37110327_1440w.webp" alt="img"></p>
<p>而在bustub中，讨论锁的并发控制，我们通常只考虑table和tuple粒度，也即<strong>表锁与行锁</strong>。</p>
<p>如果加表锁，则表中所有的行都受到同等程度的影响；如果加行锁，则加锁的范围针对的是表及下属的行。有时对表加锁后，还要在相应的数据行上加锁。</p>
<p>针对表锁和行锁，我们可以使用上一小节提到的多级粒度锁机制。具体来说，表锁包括意图锁和传统的XS锁，行锁只包括XS锁。在具体上锁操作中，首先获取意图锁表明自己对表中的某些行有读写的需求，等到真正要读写了才会真正获取行锁。也即，它支持多个事务同时对表的不同行进行读写，故而相比传统锁住整个表的XS锁会更高效一些。</p>
<p>如果使用意图锁，需要对表加上意图锁才能对行加上XS锁，这就相当于是上面那个树结构的简化情况。</p>
<p>常见的表锁及其含义如下表所示：</p>
<p><img src="/2023/03/13/cmu15445/v2-0f3d06461969e38d22795ec8b33b3270_1440w.webp" alt="img"></p>
<p>其互斥矩阵如下图所示：</p>
<p><img src="/2023/03/13/cmu15445/webp.webp" alt="img"></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>与此同时这里还有几个使用锁的例子：</p>
<p><img src="/2023/03/13/cmu15445/image-20240203113752672.png" alt="image-20240203113752672"></p>
<p><img src="/2023/03/13/cmu15445/image-20240203113803390.png" alt="image-20240203113803390"></p>
<h3 id="concurrency"><a href="#concurrency" class="headerlink" title="concurrency"></a>concurrency</h3><p>要了解事务的并发控制，首先了解什么是调度、串行化。</p>
<p><img src="/2023/03/13/cmu15445/image-20231119160217938.png" alt="image"></p>
<p><img src="/2023/03/13/cmu15445/image-20231119160636318.png" alt="image"></p>
<p>事务并发控制大概有以下这几种方法：</p>
<ol>
<li><p>基于封锁的并发控制</p>
<p>使用<strong>两段封锁协议2pl</strong>来控制资源互斥的事务串行化执行，形成一个合理的串行调度；</p>
<p>同时，通过<strong>死锁检测</strong>方法来去除隐患的死锁。</p>
</li>
<li><p>基于时间戳的并发控制</p>
</li>
<li><p>基于有效性确认的并发控制</p>
</li>
</ol>
<p>在本次实验中，我们就是采用<strong>基于封锁的并发控制</strong>。</p>
<h4 id="两段封锁协议"><a href="#两段封锁协议" class="headerlink" title="两段封锁协议"></a>两段封锁协议</h4><p><img src="/2023/03/13/cmu15445/image-20231119183734987.png" alt="image"></p>
<p>在DBMS中，lock manager模块负责管理系统中的锁。每当事务需要加锁或者升级锁的时候，都需要向它发出请求。lock manager 内部维护着一个表，上面记录着当前所有锁的分配信息，用于跟踪哪些事务持有哪些锁，以及哪些事务正在等待获得哪些锁。由于我们想获得可串行化的调度序列，因此我们需要利用lock manager来实施加锁策略，以保证事务操作的正确性和并发度。</p>
<p>两阶段锁的实现由两阶段组成。</p>
<ul>
<li>growing 阶段：事务可以按需获取某条数据的锁，lock manager 决定同意或者拒绝</li>
<li>shringking 阶段：事务只能释放之前获取的锁，不能获得新锁，即一旦开始释放锁，之后就只能释放锁。</li>
</ul>
<p>通过2PL获得的调度策略是冲突可串行化的。</p>
<p>但是该方法有着致命的弱点：可能会导致<strong>级联中止</strong> (cascading aborts)。如下图所示的 “脏读”现象。为了保证整个调度是可串行化的，DBMS 需要在 T1 中止后将一些对T1有依赖的事务也中止，这些事务曾经读取过 T1 写入的数据。而这些中止可能进而使得其它正在进行的事务级联地中止。</p>
<p>为了解决这个问题，可以使用2PL的增强版变种（也即bustub所采取的版本）。该方法要求<strong>事务持有的X锁一直到其提交或者中止时才释放</strong>，从而使得每个事务在结束之前，其写过的数据不能被其它事务读取或者重写。</p>
<p><img src="/2023/03/13/cmu15445/v2-78b6f9cdb1b36484c3e0217f27730650_1440w.webp" alt="img"></p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p><img src="/2023/03/13/cmu15445/image-20231119183354649.png" alt="image"></p>
<ol>
<li><p>三个隔离级别含义</p>
<p><code>READ_UNCOMMITTED</code>、<code>READ_COMMITTED</code>、<code>REPEATED_READ</code>分别对应上图的1/2/3级协议。</p>
<ol>
<li><p><code>READ_UNCOMMITTED</code></p>
<p>由于读时不加锁，所以可以读取其他事务未提交的修改，也即有脏读现象。</p>
</li>
<li><p><code>READ_COMMITTED</code></p>
<p>读时加共享锁，故而只能读取其他事务已提交的修改；读完后立刻解锁，所以当同一个事务中读两次，有可能产生不可重复读现象。</p>
</li>
<li><p><code>REPEATED_READ</code></p>
<p>读时加共享锁，故而只能读取其他事务已提交的修改；事务提交时才解读锁，所以同一个事务中读的两次结果一定一致。</p>
</li>
</ol>
</li>
<li><p>支持锁类型</p>
<p><code>READ_UNCOMMITTED</code>级别不支持IS/S/SIX锁</p>
</li>
<li><p>读写操作</p>
<ul>
<li><p>A transaction should hold X locks for all write operations until it commit or aborts, regardless of its isolation level.  不论是什么隔离级别，写都需要获取X锁。</p>
</li>
<li><p>For <code>REPEATABLE_READ</code>, a transaction should take and hold S locks for all read operations until it commits or aborts.  重复读，所有读操作都需要获取S锁，直到事务commit or abort才释放。</p>
</li>
<li><p>For <code>READ_COMMITTED</code>, a transaction should take S locks for all read operations, but can release them immediately.  读已提交，所有读操作都需要获取S锁，读完立刻释放。</p>
</li>
<li><p>For <code>READ_UNCOMMITTED</code>, a transaction does not need to take any S locks for read operations.  读未提交，所有读操作都不用获取S锁。</p>
</li>
</ul>
</li>
<li><p>与2PL结合——Shrinking阶段允许解锁情况</p>
<ul>
<li><p>REPEATABLE_READ:</p>
<p>GROWINHG阶段可以加任何锁；</p>
<p>SHRINKING阶段不能加任何锁。【也即S、IS也必须像X一样等到事务提交/终止时才能解锁】</p>
</li>
<li><p>READ_COMMITTED:</p>
<p>GROWINHG阶段可以加任何锁；</p>
<p>SHRINKING阶段只能加IS/S锁。【也即S、IS可以用完即解锁】</p>
</li>
<li><p>READ_UNCOMMITTED:</p>
<p>GROWINHG阶段可以加IX/X锁；【不支持共享锁】</p>
<p>SHRINKING阶段不能加任何锁。</p>
</li>
</ul>
</li>
</ol>
<h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>基于封锁的并发控制通过<strong>死锁检测</strong>方法来去除隐患的死锁。</p>
<p>在os课上，我们学过的死锁检测算法是通过构建资源分配图实现的：</p>
<p><img src="/2023/03/13/cmu15445/image-20240221174955281.png" alt="image-20240221174955281"></p>
<p><img src="/2023/03/13/cmu15445/image-20240221175201124.png" alt="image-20240221175201124"></p>
<p><img src="/2023/03/13/cmu15445/image-20240221175444948.png" alt="image-20240221175444948"></p>
<p><img src="/2023/03/13/cmu15445/image-20240221175123917.png" alt="image-20240221175123917"></p>
<p><img src="/2023/03/13/cmu15445/image-20240221175212083.png" alt="image-20240221175212083"></p>
<p>然后还有<strong>环路和死锁的关系</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/654942846">【操作系统】死锁（详细）</a></p>
<p>① 如果进程-资源分配图中无环路</p>
<p>——&gt;则此时系统没有发生死锁</p>
<p>② 如果进程-资源分配图中有环路，且每个资源类中仅有一个资源</p>
<p>——&gt;则系统中发生了死锁，此时，环路是系统发生死锁的<strong>充要条件</strong>，环路中的进程便为死锁进程</p>
<p>③ 如果进程-资源分配图中有环路，且涉及的资源类中有多个资源</p>
<p>——&gt;则环的存在只是产生死锁的<strong>必要条件而不是充分条件</strong></p>
<h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><blockquote>
<p>To ensure correct interleaving of transactions’ operations, the DBMS uses a <strong>lock manager (LM)</strong> to control when transactions are allowed to access data items. The basic idea of a LM is that it maintains an internal data structure about the locks currently held by active transactions. Transactions issue lock requests to the LM before they access data items, and the LM will either grant the lock, block the transaction until the lock is available, or abort the transaction.</p>
<p>为了保证并发控制，DBMS通常会有一个lock manager(LM)，它记录了每个锁都被哪些事务正在持有着。每个事务要访问数据前都需要获取特定的锁，LM的作用就是检查这个锁是否可用，是的话就让该事务获取锁然后执行，否则的话就阻塞该事务，或者直接中止该事务。</p>
<p>In your implementation, there will be a <strong>global LM</strong> for the BusTub system. The <code>TableHeap</code> and <code>Executor</code> classes will use your LM to acquire locks on tuple records (by record id <code>RID</code>) when a transaction attempts to access or modify a tuple.</p>
<p>Your LM must implement hierarchical <strong>table-level and tuple-level intention locks</strong> (described above) and three isolation levels: <code>READ_UNCOMMITED</code>, <code>READ_COMMITTED</code>, and <code>REPEATABLE_READ</code>. The LM should grant or release locks according to a transaction’s isolation level.</p>
<p>需要支持多级粒度锁和三个隔离级别。</p>
<p>We provide a <code>Transaction</code> context handle (<code>include/concurrency/transaction.h</code>) with an isolation level attribute (i.e., <code>READ_UNCOMMITED</code>, <code>READ_COMMITTED</code>, and <code>REPEATABLE_READ</code>) and information about its acquired locks. </p>
<p><code>Transaction</code> context记录了很多有用的信息，如隔离级别、所需锁等。</p>
<p>The LM will need to check the isolation level of transaction and expose correct behavior on lock/unlock requests. Any invalid lock operation should lead to an ABORTED transaction state (implicit abort) and throw an exception. A failed lock attempt (such as for a <strong>deadlock</strong>) does not result in an exception, but the LM should return false for the lock request.</p>
<p>当锁操作不合法需要将事务abort并且抛出异常；失败的锁操作（如可能导致死锁）则不会导致异常，而只是简单地返回false。</p>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>bustub采用了<strong>两段封锁协议</strong>（2PL），也即事务可以分为以下几个阶段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Transaction states <span class="keyword">for</span> <span class="number">2</span>PL:</span><br><span class="line">*</span><br><span class="line">*     _________________________</span><br><span class="line">*    |                         v</span><br><span class="line">* GROWING -&gt; SHRINKING -&gt; COMMITTED   ABORTED</span><br><span class="line">*    |__________|________________________^</span><br></pre></td></tr></table></figure>

<p>并且，bustub采取了表锁和行锁粒度，遵循<strong>多级粒度锁机制</strong>。表锁有<strong>意图锁</strong>和S/X锁，行锁只有S/X锁；当访问一个表时，可以直接获取它的S/X锁，或者先获取其意图锁再获取对应访问行的S/X锁。</p>
<p>同时，bustub也支持三个隔离级别，也即<code>READ_UNCOMMITTED</code>，<code>REPEATABLE_READ</code>和<code>READ_COMMITTED</code>。它们应该分别对应于一级协议（解决丢失修改）、二级协议（解决脏读）、三级协议（解决不可重复读）。</p>
<p>而本次实验所需实现的，就是一个lock manager（LM），并且通过LM来实现各个executor执行的并发安全。它需要管理系统中所有资源的锁，并且当事务调用lock方法尝试获取某个类型的锁时，它需要检验是否合理后再进行授权。在bustub中它是全局的。具体来说，它对外提供这四个主要接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockTable</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UnlockTable</span><span class="params">(Transaction *txn, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockRow</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid, <span class="type">const</span> RID &amp;rid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UnlockRow</span><span class="params">(Transaction *txn, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid, <span class="type">const</span> RID &amp;rid, <span class="type">bool</span> force = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>每个事务要访问数据前都需要通过这些接口获取特定的锁。LM类内部检查这个锁是否可用，是的话就让该事务获取锁（GRANT）然后执行，否则的话就阻塞（BLOCK）该事务，或者直接中止（ABORT）该事务。同时，它也会进行周期性的死锁检测，避免2pl的死锁问题。</p>
<p>在task1，我们需要实现LM的lock/unlock基本功能；在task2，我们需要实现LM的死锁检测功能；在task3，我们需要运用LM来保证executor执行时的并发安全。</p>
<h3 id="Task-1-Lock-Manager"><a href="#Task-1-Lock-Manager" class="headerlink" title="Task #1 - Lock Manager"></a>Task #1 - Lock Manager</h3><blockquote>
<p>The only file you need to modify for this task is the <code>LockManager</code> class (<code>concurrency/lock_manager.cpp</code> and <code>include/concurrency/lock_manager.h</code>). You must implement the following functions:</p>
<ul>
<li><code>LockTable(Transaction, LockMode, TableOID)</code></li>
<li><code>UnlockTable(Transction, TableOID)</code></li>
<li><code>LockRow(Transaction, LockMode, TableOID, RID)</code></li>
<li><code>UnlockRow(Transaction, TableOID, RID, force)</code></li>
</ul>
<p>The LM’s specific locking mechanism depends on the transaction isolation level, whether it is a table-level or tuple-level lock, and the type of lock involved. Make sure you are familiar with the <code>Transaction</code> class’s API and member variables, defined in <code>transaction.h</code> and <code>lock_manager.h</code> Then, carefully read through <code>[LOCK_NOTE]</code>, <code>[UNLOCK_NOTE]</code>, and the LM’s functions’ specifications (in <code>lock_manager.h</code>).</p>
<p>The <code>UnlockRow</code> has a <code>force</code> parameter because executor implementations might need to determine whether a tuple is accessible before deciding whether to include it. If <code>force</code> is set to true, the operation bypasses all 2PL checks as if the tuple is not locked.</p>
<p>For <code>UnlockRow</code>, we have a <code>force</code> parameter, because in the executor implementation, we might need to <em>peek</em> whether a tuple is accessible by a transaction before deciding whether to scan this tuple to parent executors. If <code>force</code> is set to true, this operation bypasses all 2PL checks as if the tuple is never locked by the transaction.</p>
<p><strong>HINTS</strong></p>
<ul>
<li>Think carefully about when do you need to upgrade a lock, and about what operations on the <code>LockRequestQueue</code> is needed when you need to update a table/tuple lock.</li>
<li>You will need some way to notify waiting transactions when a lock is available. We recommend using <code>std::condition_variable </code>provided as part of <code>LockRequestQueue</code>.</li>
<li>The lock manager should update the state of transactions as needed. For example, the state of a transaction may be changed from <code>GROWING</code> to <code>SHRINKING</code> by an <code>unlock</code> operation. See the methods in <code>transaction.h</code></li>
<li>You should keep track of the locks acquired by a transaction using <code>*_lock_set_</code> so that the <code>TransactionManager</code> can release locks appropriately when it commits or aborts a transaction.</li>
<li>Setting a transaction’s state to ABORTED implicitly aborts it, but it is not explicitly aborted until <code>TransactionManager::Abort</code> is called. You should read this function and the provided tests to understand what it does and how your lock manager is used in the abort process.</li>
</ul>
</blockquote>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>要结合bustub支持的特性实现LM的lock/unlock基本功能，首先要明确lock/unlock函数的基本框架：</p>
<p>对于Lock()类函数，</p>
<ol>
<li>检验加锁合法性，不合法则中止事务</li>
<li>一个循环，内部不断尝试获取锁，获取不到则沉睡等待唤醒</li>
</ol>
<p>对于Unlock()类函数，</p>
<ol>
<li>检验解锁合法性，不合法则中止事务</li>
<li>进行解锁相关操作，唤醒所有沉睡中事务</li>
</ol>
<p>接下来，先介绍LM的数据结构，然后再从这三方面详细介绍LM中Lock()的实现：整体沉睡唤醒机制、合法性检测以及更新锁的实现。最后再在第四部分单独说明实现较为简单的Unlock()。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>LM的作用是管理所有资源的锁，而在bustub中资源粒度只为“table”和“tuple”。故而，只需有两个类似map的数据结构，分别记录表锁和行锁信息即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Structure that holds lock requests for a given table oid */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">table_oid_t</span>, std::shared_ptr&lt;LockRequestQueue&gt;&gt; table_lock_map_;</span><br><span class="line"><span class="comment">/** Coordination */</span></span><br><span class="line">std::mutex table_lock_map_latch_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Structure that holds lock requests for a given RID */</span></span><br><span class="line">std::unordered_map&lt;RID, std::shared_ptr&lt;LockRequestQueue&gt;&gt; row_lock_map_;</span><br><span class="line"><span class="comment">/** Coordination */</span></span><br><span class="line">std::mutex row_lock_map_latch_;</span><br></pre></td></tr></table></figure>

<p>其中<code>LockRequestQueue</code>记录了每个资源锁队列信息，具体结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockRequestQueue</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 阻塞于该资源的请求队列 */</span></span><br><span class="line">    std::list&lt;LockRequest *&gt; request_queue_;</span><br><span class="line">    <span class="comment">/** 用于对request_queue_内部线程进行同步，下下小节细说 */</span></span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    <span class="comment">/** 用于lock upgrade的实现，之后细说 */</span></span><br><span class="line">    <span class="type">txn_id_t</span> upgrading_ = INVALID_TXN_ID;</span><br><span class="line">    <span class="comment">/** 用于保护本结构 */</span></span><br><span class="line">    std::mutex latch_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockRequest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Txn_id of the txn requesting the lock */</span></span><br><span class="line">    <span class="type">txn_id_t</span> txn_id_;</span><br><span class="line">    <span class="comment">/** Locking mode of the requested lock */</span></span><br><span class="line">    LockMode lock_mode_;</span><br><span class="line">    <span class="comment">/** Oid of the table for a table lock; oid of the table the row belong to for a row lock */</span></span><br><span class="line">    <span class="type">table_oid_t</span> oid_;</span><br><span class="line">    <span class="comment">/** Rid of the row for a row lock; unused for table locks */</span></span><br><span class="line">    RID rid_;</span><br><span class="line">    <span class="comment">/** 记录该请求是否已经被授权 */</span></span><br><span class="line">    <span class="type">bool</span> granted_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相当于每个table OR tuple都有一个等待的事务队列，和它自己的锁。</p>
<h4 id="FIFO沉睡唤醒机制"><a href="#FIFO沉睡唤醒机制" class="headerlink" title="FIFO沉睡唤醒机制"></a>FIFO沉睡唤醒机制</h4><blockquote>
<p>感觉这里还是很有含金量的，通过<code>std::condition_variable</code>实现一个自定义的FIFO锁。</p>
</blockquote>
<h5 id="c-知识"><a href="#c-知识" class="headerlink" title="c++知识"></a>c++知识</h5><p><code>std::condition_variable</code> 是 C++ 标准库中用于线程间同步的工具之一，它通常与 <code>std::mutex</code> 一起使用，用于实现在特定条件下的线程等待和唤醒操作。<code>std::condition_variable</code> 提供了一种方式，允许一个线程等待另一个线程满足某个特定条件，然后通知等待的线程条件已经满足。</p>
<p>下面是一个简单的示例，演示了 <code>std::condition_variable</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitForCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Condition satisfied! Doing some work.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">waitingThread</span><span class="params">(waitForCondition)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    </span><br><span class="line">    waitingThread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的<code>unique_lock</code>值得注意。这东西和lock guard差不多，区别可能就在于<code>std::unique_lock</code> 提供了更多的灵活性，允许手动锁定和释放互斥量，并且在不同的作用域内多次锁定和解锁。一般都会将它传给条件变量的wait函数。</p>
<p>条件变量的基本流程图原理可见下图（来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39277419/article/details/99544724">condition_variable 条件变量</a>）：</p>
<p><img src="/2023/03/13/cmu15445/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mjc3NDE5,size_16,color_FFFFFF,t_70.jpeg" alt="在这里插入图片描述"></p>
<p><img src="/2023/03/13/cmu15445/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mjc3NDE5,size_16,color_FFFFFF,t_70-1707395142292-3.jpeg" alt="在这里插入图片描述"></p>
<p>可见，它其实就是在外部上锁，然后内部解锁，等到被唤醒再次获取锁。故而，我们可以用它实现沉睡唤醒机制。</p>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>由文档可得：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Both <span class="title function_">LockTable</span><span class="params">()</span> and <span class="title function_">LockRow</span><span class="params">()</span> are blocking methods; they should wait till the lock is granted and then <span class="keyword">return</span>. If the transaction was aborted in the meantime, <span class="keyword">do</span> not grant the lock and <span class="keyword">return</span> <span class="literal">false</span>.</span><br><span class="line">Unlocking a resource should also grant any new lock requests <span class="keyword">for</span> the resource (<span class="keyword">if</span> possible).</span><br></pre></td></tr></table></figure>

<p>由此我们可知lock和unlock的大抵机制。在lock中，如果当前不可用，则沉睡等待唤醒；unlock之后则通知所有线程。</p>
<p>我们可以通过<code>LockRequestQueue</code>结构体中的条件变量<code>cv_</code>来实现<strong>沉睡唤醒机制</strong>。而沉睡唤醒机制实现要点之一就是明确<strong>沉睡的条件</strong>。</p>
<p>LM的实现要求使用<strong>FIFO顺序</strong>来满足事务请求，而<code>std::condition_variable</code>的<code>notify_one</code>方法是按随机顺序的。所以我们只能手动使用<code>LockRequestQueue.request_queue_</code>队列来模拟FIFO，也即<u>仅当当前线程为队首元素，才进行锁的授权</u>。</p>
<p>除此之外，还需注意一点，也即要求如果请求队列中有多个锁能被满足，那么需要对它们<u>同时一次性授权</u>。比如说，假定当前请求队列为“SSXSX”，那么此次授权之后的请求队列应为“<u>SS</u>XSX”。（划线表示已授权）</p>
<p>其中，这个“满足”关系可被理解为<strong>兼容</strong>。锁之间的兼容矩阵如下图所示：</p>
<p><img src="/2023/03/13/cmu15445/webp.webp" alt="img"></p>
<p>故而，结合上述两点后，可得我们最终实现的<strong>沉睡条件</strong>：<u>当且仅当该请求与它前面所有请求都兼容，才能授权该请求</u>。以<code>LockTable()</code>为例，最终形成如下代码（伪码表示）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockManager::LockTable</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">table_oid_t</span> &amp;oid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = table_lock_map_.<span class="built_in">find</span>(oid);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">req_queue_lock</span><span class="params">(it-&gt;second-&gt;latch_)</span></span>;</span><br><span class="line">  it-&gt;second-&gt;request_queue_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid)); <span class="comment">// 加入当前请求到队尾</span></span><br><span class="line">  <span class="keyword">auto</span> req_it = std::<span class="built_in">prev</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前锁需要插入</span></span><br><span class="line">  <span class="keyword">switch</span> (lock_mode) &#123; <span class="comment">// 不同的锁类型有不同的机制，在此仅以S/X锁为例</span></span><br><span class="line">      <span class="keyword">case</span> LockMode::EXCLUSIVE: <span class="comment">// X锁不与任何其它锁兼容，故要求当前请求前面的为空</span></span><br><span class="line">        <span class="comment">// 注意这里不能直接判empty。因为有可能在wait过程中请求队列尾插了新的请求</span></span><br><span class="line">        <span class="keyword">while</span> (!(std::<span class="built_in">all_of</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(), req_it, [is_upgraded](LockRequest* req) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;))) &#123;</span><br><span class="line">          it-&gt;second-&gt;cv_.<span class="built_in">wait</span>(req_queue_lock);</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 注意需要更新it，因为stl的容器增删元素后迭代器不会始终指向原来那个元素……</span></span><br><span class="line">        <span class="keyword">for</span> (req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LockMode::SHARED: <span class="comment">// S锁只与S和IS兼容，故要求当前请求前面的为空或者全都是兼容类型</span></span><br><span class="line">        <span class="keyword">while</span> (!(std::<span class="built_in">all_of</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(), req_it, [is_upgraded](LockRequest* req) &#123; <span class="keyword">return</span> req-&gt;lock_mode_ == LockMode::SHARED || req-&gt;lock_mode_ == LockMode::INTENTION_SHARED; &#125;))) &#123;</span><br><span class="line">          it-&gt;second-&gt;cv_.<span class="built_in">wait</span>(req_queue_lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  (*req_it)-&gt;granted_ = <span class="literal">true</span>; <span class="comment">// 标记为已授权</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而唤醒机制就相较简单了，只需在unlock时移出队列并且调用<code>notify_all</code>即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockManager::UnlockTable</span><span class="params">(Transaction *txn, <span class="type">table_oid_t</span> &amp;oid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = table_lock_map_.<span class="built_in">find</span>(oid);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">req_queue_lock</span><span class="params">(it-&gt;second-&gt;latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123; <span class="comment">// 移出队列</span></span><br><span class="line">      <span class="built_in">BUSTUB_ASSERT</span>((*req_it)-&gt;granted_, <span class="string">&quot;Must have been granted in unlock function!&quot;</span>);</span><br><span class="line">      <span class="built_in">delete</span> (*req_it);</span><br><span class="line">      it-&gt;second-&gt;request_queue_.<span class="built_in">erase</span>(req_it);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知其余线程</span></span><br><span class="line">  it-&gt;second-&gt;cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="合法性检测"><a href="#合法性检测" class="headerlink" title="合法性检测"></a>合法性检测</h4><p>我将合法性检验放在了整个函数的最前面。具体来说，需要考虑以下几个因素：</p>
<ol>
<li><p>隔离级别</p>
<ol>
<li><p>隔离级别是否支持这种类型的锁？</p>
<p>比如说<code>READ_UNCOMMITTED</code>级别就不支持IS/S/SIX锁，抛出<code>LOCK_SHARED_ON_READ_UNCOMMITTED</code>异常；</p>
<p>对于不同的隔离级别，在SHRINKING阶段允许加的锁的类型也不同。</p>
<p>具体可以看background部分关于隔离级别的介绍。</p>
</li>
</ol>
</li>
<li><p>其它</p>
<p>比如说对于行锁，它需要检测是否已经获取了对应的表锁。这里测试似乎遵循事务与线程一一对应的原则，所以我们应该只用在行锁的前面检测是否获取表锁就行，不用担心执行着执行着表锁没了的情况。我在此采用了通过txn的set判断的方法从而避免了对资源锁的争夺：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> holding_table_lock = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (lock_mode == LockMode::SHARED) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((txn-&gt;<span class="built_in">GetSharedTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetSharedTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetIntentionSharedTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetIntentionSharedTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) !=</span><br><span class="line">       txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>())) &#123;</span><br><span class="line">    holding_table_lock = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) !=</span><br><span class="line">       txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>())) &#123;</span><br><span class="line">    holding_table_lock = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="锁的更新"><a href="#锁的更新" class="headerlink" title="锁的更新"></a>锁的更新</h4><blockquote>
<p><strong>LOCK UPGRADE:</strong><br>Calling Lock() on a resource <u>that is already locked</u> should have the following behaviour:</p>
<ul>
<li><p>If requested lock mode is the same as that of the lock presently held, Lock() should return true since it already has the lock.</p>
<p>lock_mode不变，则简单地return true</p>
</li>
<li><p>If requested lock mode is different, Lock() should upgrade the lock held by the transaction.</p>
<p>lock_mode有变，需要进行锁的更新</p>
</li>
</ul>
<p>   A lock request being upgraded should be prioritised over other waiting lock requests on the same resource. 这句话值得注意！！！更新锁这个请求是<strong>最高级</strong>的，需要优先处理！！</p>
<p>   While upgrading, <u>only the following transitions should be allowed:</u> 只有下列情况的更新合法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IS -&gt; [S, X, IX, SIX]</span><br><span class="line">S -&gt; [X, SIX]</span><br><span class="line">IX -&gt; [X, SIX]</span><br><span class="line">SIX -&gt; [X]</span><br></pre></td></tr></table></figure>

<p>   Any other upgrade is considered incompatible, and such an attempt should set the TransactionState as ABORTED and throw a TransactionAbortException (INCOMPATIBLE_UPGRADE)</p>
<p>   Furthermore, only one transaction should be allowed to upgrade its lock on a given resource. Multiple concurrent lock upgrades on the same resource should set the TransactionState as ABORTED and throw a TransactionAbortException (UPGRADE_CONFLICT). 不能多个事务同时对某个资源更新锁</p>
</blockquote>
<p>常常涉及这么一种情况：事务持有S锁，接下来又想申请将自己的S锁转化为X锁。不能简单地先释放S锁再继续申请X锁，因为这会产生一段未加锁区域从而有并发安全隐患。这时候就需要引入锁的更新。</p>
<p>锁的更新其实就相当于是在锁对象内部实现一个先释放再申请的原子操作了。它是这样保证更新操作的原子性的：</p>
<ol>
<li>释放原有锁</li>
<li>控制其它所有目前未获取到锁的事务都不能再获取锁（也即，<strong>更新锁优先级最高</strong>，其它为授权的锁申请都只能等待直到更新锁完成）</li>
<li>等待直到目标更新锁可获取</li>
</ol>
<p>这样一来，就能保证那段真空的未加锁区域不会被别的事务抢占先机了。故而，这里涉及到两个关键问题的处理，一个是如何实现锁的更新，另一个就是如何保证更新锁的优先级。</p>
<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><p>我这里给出的解决方案是，对更新时的更新锁和非更新锁进行分别的处理。</p>
<ol>
<li><p>更新锁</p>
<p>我的实现是在<u>释放旧锁之后</u>进行锁的争取。首先，释放旧锁，但是<u>不调用</u><code>notify_all</code>；如果当前队列中存在正在执行中的并且与新锁相冲突的请求（也即只有在队列中仅存在【兼容的 || 不兼容但还没被授权】的请求时才获取锁），则等待该请求释放。</p>
<blockquote>
<p>这里我本来打算实现先不释放旧锁，等到获取到新锁之后再释放旧锁。也即：</p>
<p>比方说S-&gt;X的情况，①先删除S的授权，然后再走常规锁的流程获取X的授权（也即有没有锁的时期），②先获取X的授权，再删除S的授权（也即有兼有S和X锁的时期）</p>
<p>我本来是选择②的，但现在发现完全没必要这么做，因为这是锁的内部实现，中间这段空窗期是不会有新的事务获取到该资源的（一个是不进行notify，另一个是更新锁优先级最高），故而为实现简单起见（<strong>并且线上测试也是要求先释放锁……</strong>）选择了先释放再获取。</p>
</blockquote>
<p>然后，直到更新锁被唤醒后，将自己插入到请求队列头（头插表示优先级最高）。至此成功被授权。</p>
</li>
<li><p>非更新锁</p>
<p>当更新锁在争取锁时，控制其它所有请求都不争夺授权（也即一直保持ungranted状态，表示优先级最高）。直到冲突请求释放，更新锁被授权，才回到正常的控制流中。</p>
</li>
</ol>
<p>其具体伪代码如下所示（仅以shared为例）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> is_upgraded = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/* case of upgrade */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">    it-&gt;second-&gt;upgrading_ = txn-&gt;<span class="built_in">GetTransactionId</span>();</span><br><span class="line">    is_upgraded = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 先进行解锁操作，但不会进行notify</span></span><br><span class="line">    <span class="built_in">delete</span> (*req_it);</span><br><span class="line">    it-&gt;second-&gt;request_queue_.<span class="built_in">erase</span>(req_it);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!is_upgraded) &#123;	<span class="comment">// 非更新锁的正常控制流。更新锁在后面才插入到队列的首部（表示优先级最高）</span></span><br><span class="line">  it-&gt;second-&gt;request_queue_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> req_it = std::<span class="built_in">prev</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (is_upgraded) &#123;	<span class="comment">// 更新锁需要关注整个队列，而不是它之前的队列</span></span><br><span class="line">  req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (lock_mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> LockMode::SHARED:</span><br><span class="line">    <span class="comment">// 这里条件比较复杂</span></span><br><span class="line">    <span class="comment">// 对于除了更新锁以外的其它锁，第一个条件分支满足，所以就一直等待，直到</span></span><br><span class="line">    <span class="comment">// it-&gt;second-&gt;upgrading_变为INVALID_TXN_ID，也即更新完成</span></span><br><span class="line">    <span class="comment">// 这体现了更新锁的最高级优先级</span></span><br><span class="line">    <span class="keyword">while</span> ((it-&gt;second-&gt;upgrading_ != INVALID_TXN_ID &amp;&amp; !is_upgraded) ||</span><br><span class="line">    <span class="comment">// 而对于更新锁，第一个条件为false，故而看第二个条件</span></span><br><span class="line">    <span class="comment">// 只有在队列中仅存在兼容的（原本控制流中的lock_mode判断语句），    </span></span><br><span class="line">    <span class="comment">// 或者不兼容但还没被授权（(!(req-&gt;granted_)）的请求时才获取锁</span></span><br><span class="line">            (!(std::<span class="built_in">all_of</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(), req_it,</span><br><span class="line">               [is_upgraded, txn, it](LockRequest *req) &#123;</span><br><span class="line">                 <span class="comment">// 【不兼容但还没被授权 || 自己的旧锁 || 兼容的】</span></span><br><span class="line">                 <span class="built_in">return</span> (is_upgraded &amp;&amp; (!(req-&gt;granted_))) || (txn-&gt;<span class="built_in">GetTransactionId</span>() == it-&gt;second-&gt;upgrading_) || req-&gt;lock_mode_ == LockMode::SHARED || req-&gt;lock_mode_ == LockMode::INTENTION_SHARED; &#125;)))) </span><br><span class="line">    &#123;</span><br><span class="line">      it-&gt;second-&gt;cv_.<span class="built_in">wait</span>(req_queue_lock);</span><br><span class="line">      <span class="comment">// 跟上面一样需要更新it</span></span><br><span class="line">      <span class="keyword">if</span> (is_upgraded) &#123;</span><br><span class="line">        req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_upgraded) &#123;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  <span class="keyword">auto</span> upgraded_req = <span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid);</span><br><span class="line">  upgraded_req-&gt;granted_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 更新锁插入到队头，体现其优先级最高</span></span><br><span class="line">  it-&gt;second-&gt;request_queue_.<span class="built_in">push_front</span>(upgraded_req);</span><br><span class="line">  <span class="comment">// 表明更新完成</span></span><br><span class="line">  it-&gt;second-&gt;upgrading_ = INVALID_TXN_ID;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  (*req_it)-&gt;granted_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="更新锁的唯一性"><a href="#更新锁的唯一性" class="headerlink" title="更新锁的唯一性"></a>更新锁的唯一性</h5><p>除此之外，对于某一个资源，同一时刻只能有一个事务更新锁，不然会引发死锁问题，因为机制是持有旧锁的情况下更新新锁。</p>
<p>具体来说可以这样理解：（参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46879188/article/details/113882685">https://blog.csdn.net/weixin_46879188/article/details/113882685</a> 加一些个人实现理解）</p>
<p>一般更新模式由一个事务组成，此事务读取记录，获取资源的S锁，然后修改行，此操作要求锁转换为X锁。</p>
<p>如果两个事务获得了资源上的S锁，然后试图同时更新数据，则一个事务尝试将锁转换为X锁，此时锁队列变化情况为：<code>SS-&gt;SX</code>，发生锁等待。</p>
<p>第二个事务也试图获取X锁以进行更新，注意此刻它是不进行notify地释放锁。这时候，它会由于不满足<code>it-&gt;second-&gt;upgrading_ != INVALID_TXN_ID</code>这个条件（用于保障更新锁的最高优先级）而一直卡住，另一个事务也迟迟收不到notify，从而导致死锁情况发生。</p>
<p>那么可能就要问了，我们能不能修改一下沉睡的条件，也即将更新事务从一个拓展为一个数组，然后限制多个同时获取更新锁的情况下一个真获取其他等待呢？那么我们也很容易从结果看出，这种情况下不也跟同一时刻只能有一个事务更新锁是一个道理。。。所以不如简单粗暴地限制这个条件。</p>
<p>因此，在bustub实现中，当遇到更新冲突时，我们选择直接终止回滚事务。</p>
<h3 id="Task-2-Deadlock-Detection"><a href="#Task-2-Deadlock-Detection" class="headerlink" title="Task #2 - Deadlock Detection"></a>Task #2 - Deadlock Detection</h3><blockquote>
<p>Your lock manager should run deadlock detection in a background thread, periodically building a <strong>waits-for graph</strong> and abort transactions as needed to eliminate deadlocks.</p>
<p><strong>REQUIREMENTS</strong></p>
<p>You must implement and use the following graph API for <strong>cycle detection</strong>:</p>
<ul>
<li><code>AddEdge(txn_id_t t1, txn_id_t t2)</code>: Adds an edge in your graph from <code>t1</code> to <code>t2</code>, representing that <code>t1</code> is waiting for <code>t2</code>. If the edge already exists, you don’t have to do anything.</li>
<li><code>RemoveEdge(txn_id_t t1, txn_id_t t2)</code>: Removes edge <code>t1</code> to <code>t2</code> from your graph. If no such edge exists, you don’t have to do anything.</li>
<li><code>HasCycle(txn_id_t&amp; txn_id)</code>: Looks for a cycle by using depth-first search (DFS). If it finds a cycle, <code>HasCycle</code> should store the transaction id of the youngest transaction in the cycle in <code>txn_id</code> and return true. Your function should return the first cycle it finds. If your graph has no cycles, <code>HasCycle</code> should return false.</li>
<li><code>GetEdgeList()</code>: Returns a list of tuples representing the edges in your graph. We will use this to test correctness of your graph. A pair <code>(t1,t2)</code> corresponds to an edge from <code>t1</code> to <code>t2</code>.</li>
<li><code>RunCycleDetection()</code>: Contains skeleton code for running cycle detection in the background. You should implement your cycle detection algorithm here.</li>
</ul>
<p>You may implement the graph however you want, as long as you support the above API. We will use that API to test your implementation.</p>
<p>You may need to access the status of a transaction from the member variable <code>txn_manager_</code>. If <code>txn_manager_</code> is set to <code>nullptr</code>, <code>StartDeadlockDetection</code> will not be called, and you do not need to detect deadlocks.</p>
<p><strong>HINTS</strong></p>
<ul>
<li><p>Your background cycle detection algorithm may need to get a pointer to a transaction using a <code>txn_id</code>. There is a member variable <code>txn_manager_</code> in lock manager, and <code>Transaction* GetTransaction(txn_id_t txn_id)</code> enables you do that.</p>
</li>
<li><p>You can also tweak <code>CYCLE_DETECTION_INTERVAL</code> in <code>common/config.h</code> in your test cases.</p>
</li>
</ul>
</blockquote>
<h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>这里相当于是对上文background部分提到的死锁检测算法的一个简化。我们视锁为一个资源，故而每个资源类中仅有一个资源（互斥锁），所以当存在环路时，我们就可以直接判断存在死锁。而由于只有一个资源，所以资源结点其实是没什么必要的，所以我们就简化为了简单的每个顶点都为一个事务、边表示事务等待关系的图形式（waits-for graph），将问题转化为<strong>找出该图的环</strong>，如果环存在，则说明产生了死锁。</p>
<p>本次任务在此基础上的额外要求是：</p>
<ol>
<li><p>一个事务可能有多条指向其他事务的边</p>
<blockquote>
<p>Remember that the waits-for graph is a directed graph, with an edge for each transaction waiting for another transaction. Because multiple transactions may share a lock on the same object, a single transaction may be waiting for multiple transactions.</p>
</blockquote>
<p>比如说<code>SSSX</code>，此时队列中的X对应事务就会有三条边。</p>
</li>
<li><p>图不能动态维护，必须在bg进程中实时创建/销毁</p>
<blockquote>
<p>Your background thread should build the waits-for graph every time it wakes up. <strong>You should not maintain the waits-for graph over time</strong>; it should be built and destroyed every time the deadlock detection thread wakes up.</p>
</blockquote>
<p>不能动态维护waits-for图，它是由死锁检测进程一次性创建的。也即，我们需要在<code>RunCycleDetection</code>函数中获取table_map锁和row_map锁，来进行waits-for表时的构建。</p>
<blockquote>
<p>已产生死锁情况下，死锁检测进程再获取这两个锁会不会死上加死？</p>
<p>其实不会。仔细结合下我们的实现，在死锁的情况下，两个死锁进程都是在wait()条件变量中沉睡的，此时是释放了表锁和行锁状态，所以我们的死锁检测进程这时候获取锁是安全的，不会死上加死。</p>
</blockquote>
</li>
<li><p>环的检测结果需要是确定性的</p>
<blockquote>
<p>Your cycle detection algorithm must be <strong>deterministic</strong>. To achieve this, you should always explore the lowest transaction id first, by starting the depth-first search from the node with lowest transaction id and exploring neighbors in order (by transaction id) when searching from a node.</p>
</blockquote>
<p>也即如果图中包含多个环，需要以固定的次序返回这些环。为此，我们需要按照<code>txn_id</code>的顺序来遍历整个图。</p>
</li>
<li><p>当检测到环时，需要对环中最年轻（youngest）的事务进行abort来破除死锁</p>
<blockquote>
<p>When you find a cycle, abort the <strong>youngest</strong> transaction to break the cycle by setting that transaction’s state to ABORTED.</p>
</blockquote>
<p>并且这时候，需要进行一次notify，防止这个正在处于abort状态的进程一直沉睡，导致无法真正abort。</p>
<blockquote>
<p>A transaction waiting for a lock may be aborted by the background cycle detection thread. You must have a way to notify waiting transactions that they’ve been aborted.</p>
</blockquote>
</li>
</ol>
<h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p>图的数据结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">txn_id_t</span>, std::set&lt;<span class="type">txn_id_t</span>&gt;&gt; waits_for_;</span><br></pre></td></tr></table></figure>

<p>由于要求通过保证DFS遍历顺序来确保结果的确定性，并且两个事务间只会有一条边，故而使用了有序的map和set。</p>
<p>实现图中找环的DFS算法也是比较简单的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> LockManager::FindCycle &#123;</span><br><span class="line">  <span class="keyword">if</span> (visited.<span class="built_in">find</span>(source_txn) != visited.<span class="built_in">end</span>()) &#123;  <span class="comment">// has cycle</span></span><br><span class="line">    <span class="comment">// delete no-circle prefix</span></span><br><span class="line">    <span class="comment">// 注意需要删除path中[path.begin(), path.find(source_txn))</span></span><br><span class="line">    <span class="comment">// 这个区间内的元素，因为我们只需要环的路径</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  visited.<span class="built_in">insert</span>(source_txn);</span><br><span class="line">  path.<span class="built_in">push_back</span>(source_txn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : waits_for_[source_txn]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FindCycle</span>(edge, path, visited)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  visited.<span class="built_in">erase</span>(visited.<span class="built_in">find</span>(source_txn));</span><br><span class="line">  path.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> LockManager::HasCycle&#123;</span><br><span class="line">  <span class="keyword">if</span> (waits_for_.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;	<span class="comment">// 剪枝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;wait_pair : waits_for_) &#123;	<span class="comment">// 此处需要一个for循环，因为不一定是连通图</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FindCycle</span>(wait_pair.first, path, visited)) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后整个检测的逻辑也是比较简单的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LockManager::RunCycleDetection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (enable_cycle_detection_) &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(cycle_detection_interval);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 1. build wait-for graph</span></span><br><span class="line">      <span class="comment">// 遍历table lock map和row lock map，填写wait-for graph</span></span><br><span class="line">      <span class="comment">// 我只对这种情况进行处理：txn1-&gt;txn2，其中txn1-&gt;granted==false,txn2-&gt;granted==true</span></span><br><span class="line">      <span class="comment">// 毕竟感觉这样才是比较显式的死锁……</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 2. detect cycle and abort txn</span></span><br><span class="line">      <span class="type">txn_id_t</span> abort_txn;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">HasCycle</span>(&amp;abort_txn)) &#123;</span><br><span class="line">        <span class="comment">// 2.1. do an abort</span></span><br><span class="line">        txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 2.2. notify related txns</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;lock_req : sleep_for[abort_txn]) &#123;</span><br><span class="line">          <span class="comment">// 上面维护了sleep_for，表明该事务正在等待哪些资源</span></span><br><span class="line">          lock_req-&gt;cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        sleep_for.<span class="built_in">erase</span>(sleep_for.<span class="built_in">find</span>(abort_txn));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3. delete all related edges of wait-for graph</span></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3. destory waot-for graph</span></span><br><span class="line">      waits_for_.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说比较简单，没什么好说的。</p>
<h3 id="Task-3-Concurrent-Query-Execution"><a href="#Task-3-Concurrent-Query-Execution" class="headerlink" title="Task #3 - Concurrent Query Execution"></a>Task #3 - Concurrent Query Execution</h3><blockquote>
<p>To support concurrent query execution, executors must lock and unlock tables and tuples as needed to achieve the isolation level specified in the transaction. To simplify this task, you can <u>ignore concurrent index execution and just focus on data stored in heap files</u>.</p>
<p><strong>忽略索引</strong>，只关注涉及数据修改的地方</p>
<p>You must update methods of some executors implemented in Project 3. </p>
<p>Note that <u>transactions should abort when lock/unlock fails</u>. If a transaction aborts, you will <u>need to undo</u> its previous write operations; to achieve this, you will need to <strong>maintain the write set</strong> in each transaction, which is used by the <code>Abort()</code> method of the transaction manager. </p>
<p><strong>需要实现UNDO撤销事务</strong></p>
<p>If the executor fails to acquire a lock, you should throw an <code>ExecutionException</code> so that the execution engine will tell the user that the query failed.</p>
<p>当获取锁失败时（也即LM的方法<code>return false</code>或者抛出<code>TransactionAbortException</code>时），executor需要抛出<code>ExecutionException</code>。</p>
<p>You should not assume that a transaction only consists of just one query. Specifically, this means a tuple might be accessed by different queries more than once in a transaction. Think about how you should handle this under different isolation levels.</p>
<p>一个事务可能包括多个sql，也即一个tuple可能会在事务中以不同形式被访问多次。需要结合隔离级别来思考这个问题的处理方式。</p>
</blockquote>
<h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>在上面的部分中我们实现了LM，在这个task中我们需要把LM应用到实际的数据库执行之中。</p>
<p>我们使用的是火山模型，故而可以比较方便地实现2PL协议。以<code>REPEATED_READ</code>级别下的2PL为例，我们只需在每个executor的<code>Init</code>中获取表锁，在<code>Next</code>中获取行锁，最后在事务<code>Commit/Abort</code>时释放，自火山模型自顶向下都依照这个规律，即可实现GROWING阶段和SHRINKING阶段的分离。</p>
<p>那么，我们具体来说需要修改哪些executor的实现呢？首先，为了简化起见，bustub忽略对使用索引情况的并发控制，以及对update的并发控制（只在leaderboard中要求）。其次，那些<strong>针对中间表进行处理</strong>的executor也不用【因为中间产物不可能会被并发访问……】，如nlj、hash join、聚合函数实现等等。故而，剩下的便只有对底层表直接访问的executor，也即<strong>seq scan executor</strong>和<strong>insert executor</strong>（delete executor通过seq scan executor实现，所以无需额外加解锁）。</p>
<p>明确了需要修改哪些地方以进行加解锁之后，还有一点需要注意，也即回滚（rollback）的实现。当事务被终止（Abort）时，我们需要对它既定修改的部分进行回滚处理，这就需要我们在涉及修改底层表格的地方维护写集（write set），也即insert和delete。</p>
<p>总结下来，本任务需要修改这几个文件：</p>
<blockquote>
<p>To complete this task, you must add support for concurrent query execution in the following executors and the transaction manager:</p>
<ul>
<li><code>src/execution/seq_scan_executor.cpp</code></li>
<li><code>src/execution/insert_executor.cpp</code></li>
<li><code>src/execution/delete_executor.cpp</code></li>
<li><code>src/concurrency/transaction_manager.cpp</code></li>
</ul>
<p>You must pass all tests and produce correct results for the Terrier Benchmark (see below) without segfaults and deadlocks. You do not need to handle concurrency for indexes or the update executor, except for the leaderboard tests.</p>
</blockquote>
<p>接下来，将从两个方面进行详细的介绍。</p>
<h4 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h5><blockquote>
<p><strong>SeqScan Executor</strong></p>
<ul>
<li>In <code>Init</code>, take a table lock. Get an iterator by using <code>MakeEagerIterator</code> instead of <code>MakeIterator</code>. (<code>MakeIterator</code> is introduced to avoid the <strong>Halloween problem</strong>【下文详细说明】 in Project 3’s UpdateExecutor, but you do not need it now.)</li>
<li>In <code>Next</code><ol>
<li>Get the current position of the table iterator.</li>
<li>Lock the tuple as needed for the isolation level.</li>
<li>Fetch the tuple. Check tuple meta, and if you have implemented filter pushdown to scan, check the predicate.</li>
<li>If the tuple should not be read by this transaction, <strong>force unlock</strong> the row. Otherwise, unlock the row as needed for the isolation level.</li>
<li>If the current operation is delete (by checking executor context <code>IsDelete()</code>, which will be set to true for <code>DELETE</code> and <code>UPDATE</code>), you should assume all tuples scanned will be deleted, and you should take X locks on the table and tuple as necessary <em>in step 2</em>.</li>
</ol>
</li>
</ul>
<p><strong>Insert Executor</strong></p>
<ul>
<li>In <code>Init</code>, take a table lock.</li>
<li>In <code>Next</code>, pass the lock manager, transaction object, and table id to <code>InsertTuple</code> so as to insert and lock a tuple atomically.</li>
</ul>
</blockquote>
<p>它这边步骤说得很详细了，再次便不多说。</p>
<p>需要注意的有以下几点：</p>
<ol>
<li><p>表锁应该使用意图锁（IX/IS），行锁应该使用XS锁</p>
</li>
<li><p>insert只需用IX表锁，不用担心scan会遍历到新插入的元组是否有问题，因为这是依隔离级别而定的</p>
</li>
<li><p>注意一下不同隔离级别的要求，具体可以见background部分对隔离级别的介绍</p>
</li>
<li><p>锁更新的处理</p>
<p>需要考虑多次插入删除锁的更新情况，比如下面的例子，一个事务就是一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO result SELECT * FROM tmp; DELETE FROM tmp; SELECT count(*) FROM result;</span><br></pre></td></tr></table></figure>

<p>并且最后select是要能感知到前面的结果的。</p>
<p>这种情况下，为了避免死锁or abort问题，得先在获取S（IS）锁之前判断是否含有X（IX），是的话不获取，否则才获取。</p>
</li>
</ol>
<h5 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h5><blockquote>
<p><strong>Insert Executor</strong></p>
<ul>
<li>Be sure that you maintain the write set as needed.</li>
</ul>
<p><strong>Delete Executor</strong></p>
<ul>
<li>If you have implemented <code>SeqScanExecutor</code> correctly based on <code>IsDelete()</code> in executor context, you do not need to take any any locks in this executor.</li>
<li>Be sure that you maintain the write set in <code>Next</code>.</li>
</ul>
<p><strong>Transaction Manager</strong></p>
<ul>
<li>In <code>Commit</code>, you generally do not need to do anything except release all the locks.</li>
<li>In <code>Abort</code>, you should revert all changes of this transaction based on its write set.</li>
</ul>
</blockquote>
<p>要点：</p>
<ol>
<li><p>在insert和delete中增加对事务writeset修改的语句。这个只是调用api，没什么好说的</p>
</li>
<li><p>rollback实现</p>
<p>在abort中需要倒序遍历writeset进行UNDO：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = txn-&gt;<span class="built_in">GetWriteSet</span>()-&gt;<span class="built_in">rbegin</span>(); it != txn-&gt;<span class="built_in">GetWriteSet</span>()-&gt;<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> meta = it-&gt;table_heap_-&gt;<span class="built_in">GetTupleMeta</span>(it-&gt;rid_);</span><br><span class="line">    meta.is_deleted_ = !(meta.is_deleted_);	<span class="comment">// 对delete和insert都适用的写得方便的小trick</span></span><br><span class="line">    it-&gt;table_heap_-&gt;<span class="built_in">UpdateTupleMeta</span>(meta, it-&gt;rid_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Terrier-Benchmark"><a href="#Terrier-Benchmark" class="headerlink" title="Terrier Benchmark"></a>Terrier Benchmark</h4><p>大概就是，表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE nft(id INT, terrier INT);</span><br><span class="line">INSERT INTO nft VALUES (0, 0), (1, 1), ...;</span><br></pre></td></tr></table></figure>

<p>有两个线程，线程里不断循环运行着这样的两个事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- begin txn1</span><br><span class="line">SELECT * FROM nft WHERE id = &lt;nft_id&gt;; -- record the terrier_id</span><br><span class="line">DELETE FROM nft WHERE id = &lt;nft_id&gt;;</span><br><span class="line">-- end txn1</span><br><span class="line"></span><br><span class="line">-- begin txn2</span><br><span class="line">INSERT INTO nft VALUES (&lt;nft_id&gt;, &lt;terrier_id&gt;)</span><br><span class="line">-- end txn2</span><br></pre></td></tr></table></figure>

<p>除此之外还有另一个线程，线程里有这么个事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- begin txn3</span><br><span class="line">SELECT count(*) FROM nft WHERE terrier = &lt;terrier_id&gt;;</span><br><span class="line">SELECT count(*) FROM nft WHERE terrier = &lt;terrier_id&gt;;</span><br><span class="line">-- end txn3</span><br></pre></td></tr></table></figure>

<p>设定在<code>REPEATED_READ</code>级别下，所以两个查询结果应该一致。这样地检查，最后统计的指标是这三种事务的吞吐量以及终止事务的个数。</p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>首先就是特别傻的一个问题，terrier bench中不知怎的insert也成功了，但是select就是检测不到insert的结果……大概执行序列是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert txn begin.</span><br><span class="line">scan txn begin.</span><br><span class="line">insert txn commit.</span><br><span class="line">scan txn commit.</span><br></pre></td></tr></table></figure>

<p>看了半天没懂为什么insert txn已经提交scan txn还是看不到它的结果。。。最后发现是这里忘改了呃呃：</p>
<p><img src="/2023/03/13/cmu15445/image-20240226202841362.png" alt="image-20240226202841362"></p>
<h4 id="附：Halloween-Protection"><a href="#附：Halloween-Protection" class="headerlink" title="附：Halloween Protection"></a>附：Halloween Protection</h4><blockquote>
<p><strong>SeqScan Executor</strong></p>
<ul>
<li>In <code>Init</code>, take a table lock. Get an iterator by using <code>MakeEagerIterator</code> instead of <code>MakeIterator</code>. (<code>MakeIterator</code> is introduced to avoid the <strong>Halloween problem</strong> in Project 3’s UpdateExecutor, but you do not need it now.)</li>
</ul>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34351321/article/details/90164892">什么是Halloween Problem</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LvanHades/p/4481497.html">sql server的处理方法</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36758138">SQL 中的 Halloween Problem</a></p>
</blockquote>
<p>大概是说，update操作的实现方法为先delete再insert，并且一般优化它下面可能会连接一个index scan，就会导致在配合底层迭代器使用时，一个元组被更新多次，从而产生死循环、更新错误等问题。Sql Server为了防止该问题，采取了spool（一个用于缓存或存储中间结果的临时存储区域）来暂存原本的索引，遍历过程中也会转而遍历spool、写入真正的物理存储，从而防止索引乱套带来的问题。</p>
<p>而在Project#4中提到的“<code>MakeIterator</code> is introduced to avoid the Halloween problem in Project 3’s UpdateExecutor”，指的是我们在本次实验中会通过原地更新而非先删除再插入来实现update，所以就不会发生Halloween Problem。</p>
<p>接下来，我们可以了解一下Project#3中具体的防范实现。首先可以了解一下bustub会产生什么样的Halloween Problem。</p>
<p>由于bustub的删除不是真删除，而是采用标记+尾插法的方式，故而应该不会出现反复访问某个元组多次的现象（因为不会发生物理现象的位移）。真正需要防范的，是多个进程同时进行迭代和更新的现象。</p>
<p>比如说，进程A进行insert操作，进程B进行update操作。我们的原意是先update再insert，故而就算insert插入的新元组符合条件，我们也不应该将其进行update。但是，在不进行并发保护的情况下（也即project#3的情况），如果按照标准迭代器实现（也即遍历到表格末尾才停止），我们很有可能会连insert进来的新元组也遍历到，从而一起更新。</p>
<p>也即，update了多余的元组，这会是bustub中真正发生的Halloween Problem。防范方式相信也很直观了，就是<u>限制update中遍历的表范围为update时的表范围，不囊括之后插入的元组</u>。</p>
<p>我们是通过<code>MakeIterator</code>来实现防范的。看下<code>TableIterator</code>的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TableIterator</span>(TableHeap *table_heap, RID rid, RID stop_at_rid);</span><br></pre></td></tr></table></figure>

<p>可知它这实际上是一个区间结构，迭代范围为[rid, stop_at_rid)。当遇到<code>stop_at_rid</code>，迭代器就会使<code>IsEnd()</code>为真。</p>
<p>对比<code>MakeIterator</code>和<code>MakeEagerIterator</code>的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MakeIterator</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="keyword">this</span>, &#123;first_page_id_, <span class="number">0</span>&#125;, &#123;last_page_id, page-&gt;<span class="built_in">GetNumTuples</span>()&#125;&#125;;</span><br><span class="line"><span class="comment">// MakeEagerIterator</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="keyword">this</span>, &#123;first_page_id_, <span class="number">0</span>&#125;, &#123;INVALID_PAGE_ID, <span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>前者是以<code>last_page_id</code>为界，而后者以<code>INVALID_PAGE_ID</code>为界。其中，<code>last_page_id</code>表示当前表的最后一页物理页，会在insert之中被修改。这样一来，<code>MakeIterator</code>就能限制遍历的范围为当前创建的所有元组了。</p>
<p><u>而在Project#4中</u>，我们会实现update的原地更新，所以<strong>无需防范Halloween Problem的发生</strong>，故而无需使用<code>MakeIterator</code>，只使用<code>MakeEagerIterator</code>即可。</p>
<h3 id="Leaderboard"><a href="#Leaderboard" class="headerlink" title="Leaderboard"></a>Leaderboard</h3><p><img src="/2023/03/13/cmu15445/image-20240227223236821.png" alt="image-20240227223236821"></p>
<p>只能说前面性能烂了一路，到这里总的只会更烂hhh</p>
<p>运行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j`<span class="built_in">nproc</span>` terrier-bench</span><br><span class="line">./bin/bustub-terrier-bench --duration 30000 --nft 10000</span><br></pre></td></tr></table></figure>

<p>它这里给了几个优化策略：</p>
<ol>
<li><p>谓词下推到seq scan</p>
<blockquote>
<p><strong>Predicate pushdown to SeqScan:</strong> You can implement a predicate filter in SeqScanExecutor so that you lock fewer tuples when doing SeqScan. You can enable MergeFilterScan optimizer rule <a target="_blank" rel="noopener" href="https://github.com/cmu-db/bustub/blob/master/src/optimizer/merge_filter_scan.cpp"><code>merge_filter_scan.cpp</code></a> and implement this optimization.</p>
</blockquote>
<p>这个就是要enable<code>MergeFilterScan</code>，在p3已经开启了。</p>
</li>
<li><p>实现in-place的update操作</p>
<blockquote>
<p><strong>Implement In-Place UpdateExecutor:</strong> You can improve your UpdateExecutor implementation so that tuples can be updated in-place and will probably be more efficient. Modify <code>terrier_benchmark_config.h</code> to instruct Terriers to use <code>UPDATE</code> for exchanging NFTs.</p>
</blockquote>
<p>之前在terrier bench中都是通过先delete再insert实现，这里之后就直接调用update executor了。</p>
<p>实现方式也很简单，用函数<code>UpdateTupleInPlaceUnsafe</code>即可。</p>
<p>并且注意需要兼容Abort部分，需要维护写集，在Abort中恢复。但它给定的<code>TableWriteRecord</code>并没有记录old tuple的字段，所以我只得使用<code>IndexWriteRecord</code>来凑数了。</p>
<p>需要注意的一点是，我此处的in-place update的实现并没有更新索引，也即默认它更新字段是不包括索引字段的。这仅能通过terrier bench，会寄在p3的index scan test。</p>
</li>
<li><p>使用索引</p>
<blockquote>
<p><strong>Use Index:</strong> You can create an index over the NFT table, and then push the predicate down to IndexScanExecutor to do index lookup. For example, if we have an index over NFT’s id column, the <code>SELECT * FROM nft WHERE id = 1</code> can actually be done like (1) extract <code>id = 1</code> predicate and (2) directly call <code>GetValue(1)</code> over the index, instead of doing a full index scan or table scan. You will need to update index scan plan to facilitate this optimization. Modify <code>terrier_benchmark_config.h</code> to instruct Terriers to create an index before exchanging NFTs.</p>
</blockquote>
<p>大概就是需要把update-seqscan化为update-indexscan。这个也在p3做过了。然后就是需要在index scan executor的实现中仿照seq scan加解锁。</p>
</li>
</ol>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/03/13/cmu15445$lab5/">源码解读</a>
            
            
            <a class="next" rel="next" href="/2023/03/13/cmu15445/">CMU15445</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 修年 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>