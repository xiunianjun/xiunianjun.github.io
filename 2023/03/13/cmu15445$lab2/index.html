<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="修年"><meta name="copyright" content="修年"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>Project2   B+Tree | 修年</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"xiunianjun.github.io","root":"/","title":"修年","version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="Project2   B+Tree In this programming project you will implement a B+Tree index in your database system. Your implementation will support thread-safe search, insertion, deletion (including splitting a">
<meta property="og:type" content="article">
<meta property="og:title" content="Project2   B+Tree">
<meta property="og:url" content="https://xiunianjun.github.io/2023/03/13/cmu15445$lab2/index.html">
<meta property="og:site_name" content="修年">
<meta property="og:description" content="Project2   B+Tree In this programming project you will implement a B+Tree index in your database system. Your implementation will support thread-safe search, insertion, deletion (including splitting a">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiunianjun.github.io/2023/03/13/cmu15445/B+-tree-remove-61.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/03/13/cmu15445/image-20230417181239196.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/03/13/cmu15445/image-20230418110917819.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/03/13/cmu15445/image-20230418110258801.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/03/13/cmu15445/image-20230418110753966.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/03/13/cmu15445/image-20230505002652748.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/03/13/cmu15445/image-20230505002731312.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/03/13/cmu15445/image-20230505011731797.png">
<meta property="og:image" content="https://xiunianjun.github.io/2023/03/13/cmu15445/image-20230505011744924.png">
<meta property="article:published_time" content="2023-03-13T14:19:00.000Z">
<meta property="article:modified_time" content="2023-11-18T13:20:25.274Z">
<meta property="article:author" content="修年">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiunianjun.github.io/2023/03/13/cmu15445/B+-tree-remove-61.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="修年"><img width="96" loading="lazy" src="/images/head.png" alt="修年"></a><div class="site-author-name"><a href="/about/">修年</a></div><span class="site-name">修年</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">45</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">6</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><span class="icon iconify" data-icon="ri:rss-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://user.qzone.qq.com/1776527992/main" title="QQ" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/xiunianjun" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:nniferyy@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Project2-B-Tree"><span class="toc-number">1.</span> <span class="toc-text">Project2   B+Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Task1-B-Tree-Pages"><span class="toc-number">1.1.</span> <span class="toc-text">Task1   B+Tree Pages</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task2a-Insertion-and-Search"><span class="toc-number">1.2.</span> <span class="toc-text">Task2a   Insertion and Search</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://xiunianjun.github.io/2023/03/13/cmu15445$lab2/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="修年"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="修年"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Project2   B+Tree</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2023-03-13 22:19:00" itemprop="dateCreated datePublished" datetime="2023-03-13T22:19:00+08:00">2023-03-13</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2023-11-18 21:20:25" itemprop="dateModified" datetime="2023-11-18T21:20:25+08:00">2023-11-18</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="Project2-B-Tree"><a href="#Project2-B-Tree" class="headerlink" title="Project2   B+Tree"></a>Project2   B+Tree</h1><blockquote>
<p>In this programming project you will implement a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%2B_tree">B+Tree</a> index in your database system.</p>
<p>Your implementation will support thread-safe <u>search, insertion, deletion</u> (including splitting and merging nodes包括分裂和合并结点), and an iterator to support in-order leaf scans.</p>
</blockquote>
<p>它这里的B+树（以及wiki里的）跟王道考研讲得不大一样。王道考研的B+每个结点一个关键字对应一个child，但是这里的是B树的形式。</p>
<p><img src="/2023/03/13/cmu15445/B+-tree-remove-61.png" alt="undefined" loading="lazy"></p>
<p><img src="/2023/03/13/cmu15445/image-20230417181239196.png" alt="image-20230417181239196" loading="lazy"></p>
<h2 id="Task1-B-Tree-Pages"><a href="#Task1-B-Tree-Pages" class="headerlink" title="Task1   B+Tree Pages"></a>Task1   B+Tree Pages</h2><blockquote>
<p>You must implement three Page classes to store the data of your B+Tree:</p>
<ol>
<li><p>B+Tree Page  <code>BPlusTreePage</code></p>
<p>下面那两个的基类</p>
</li>
<li><p>B+Tree Internal Page</p>
<p>An Internal Page stores <strong>m</strong> ordered keys and <strong>m+1</strong> child pointers (as page_ids) to other B+Tree Pages.These keys and pointers are internally represented as an array of key/page_id pairs. </p>
<p>Because the number of pointers does not equal the number of keys, <strong>the first key is set to be invalid, and lookups should always start with the second key.</strong></p>
<p>At any time, each internal page should be at least half full.【min_size&lt;=  &lt;=max_size】</p>
<p>During deletion, two half-full pages can be merged, or keys and pointers can be redistributed to avoid merging. During insertion, one full page can be split into two, or keys and pointers can be redistributed to avoid splitting. </p>
</li>
<li><p>B+Tree Leaf Page</p>
<p>The Leaf Page stores <strong>m</strong> ordered keys and their <strong>m</strong> corresponding values.  In your implementation, the value should always be the 64-bit record_id for where the actual tuples are stored; see the <code>RID</code> class, in <code>src/include/common/rid.h</code>. </p>
<p>*<strong>Note:*</strong> Even though Leaf Pages and Internal Pages contain the same type of key, they may have different value types. <strong>Thus, the <code>max_size</code> can be different.</strong></p>
</li>
</ol>
</blockquote>
<h2 id="Task2a-Insertion-and-Search"><a href="#Task2a-Insertion-and-Search" class="headerlink" title="Task2a   Insertion and Search"></a>Task2a   Insertion and Search</h2><blockquote>
<p>The index should <strong>support only unique keys;</strong> if you try to reinsert an existing key into the index, it should not perform the insertion, and should return false. key必须unique</p>
<p>B+Tree pages should be split (or keys should be redistributed) if an insertion would violate the B+Tree’s invariants. 插入时需要分裂</p>
<p>If an insertion changes the page ID of the root, you must update the <code>root_page_id</code> in the B+Tree index’s header page. You can do this by accessing the <code>header_page_id_</code> page, which is given to you in the constructor.  Then, by using <code>reinterpret_cast</code>, you can interpret this page as a <code>BPlusTreeHeaderPage</code> (from <code>src/include/storage/page/b_plus_tree_header_page.h</code>) and update the root page ID from there. You also must implement <code>GetRootPageId</code>, which currently returns 0 by default.对<code>root_page_id</code>的一切访问，都需要通过<code>header_page_id_</code>。如果插入后改变了root的page ID，需要更新<code>root_page_id</code>。</p>
<p>We recommend that you use the page guard classes from Project 1 to help prevent synchronization problems. For this checkpoint, we recommend that you use <code>FetchPageBasic</code> (defined in <code>src/include/storage/page/</code>) when you access a page. 在当前task中，我们推荐你使用pro1实现的page guard，比如说这里如果要访问一页，就需要用 <code>FetchPageBasic</code> 。</p>
<p>You may optionally use the <code>Context</code> class (defined in <code>src/include/storage/index/b_plus_tree.h</code>) to track the pages that you’ve read or written (via the <code>read_set_</code> and <code>write_set_</code> fields) or to store other metadata that you need to pass into other functions recursively.你可以随意使用和修改 <code>Context</code> class，它大概就是一个存储共享信息的对象。</p>
<p>If you are using the <code>Context</code> class, here are some tips:如果你要用，要注意以下几点：</p>
<ul>
<li><p>You might only need to use <code>write_set_</code> when inserting or deleting. 当你在为B+树插入/删除结点时，需要用到<code>write_set_</code>。【为什么？这个set存储的是修改路径上的结点吗？然后如果要分裂/合并结点，只需什么while(pop且需要分裂/合并){分裂/合并}？？所以说这里的deque是栈结构？】</p>
<p>也就是说，其实我们就可以不用递归了，而是将上下文存储在context-&gt;write_set_这个栈里面就行了？大概是这个意思吧</p>
<p>It is possible that you don’t need to use <code>read_set_</code>, depending on your implementation.</p>
<p>read可以用递归（比较简单）也可以不用，所以说具体看实现。</p>
</li>
<li><p>You might want to store the root page id in the context and acquire write guard of header page when modifying the B+Tree.你需要将root page id存储在context，并且在修改b+树（插入、删除）时获取header page的WritePageGurad。</p>
</li>
<li><p>To find a parent to the current node, look at the back of <code>write_set_</code>. It should contain all nodes along the access path.如果想要寻找当前node的父亲，可以看看<code>write_set_.back</code>，它包含了访问路径上所有结点的引用【所以确实是当成栈来用了】</p>
</li>
<li><p>You should use <code>BUSTUB_ASSERT</code> to help you find inconsistent data in your implementation. 需要使用 <code>BUSTUB_ASSERT</code>。</p>
<p>For example, if you want to split a node (except root), you might want to ensure there is still at least one node in the <code>write_set_</code>. If you need to split root, you might want to check if <code>header_page_</code> is <code>std::nullopt</code>.</p>
<p>如果你想要分割一个根节点以外的node，那你必须保证<code>write_set_</code>中至少有一个结点；如果你想要分割根节点，那你必须保证<code>header_page_</code>非空。</p>
</li>
<li><p>To unlock the header page, simply set <code>header_page_</code> to <code>std::nullopt</code>. To unlock other pages, pop from the <code>write_set_</code> and drop.如果你想要不锁住header page，那就置其为空指针；如果想释放别的页，那就将它从 <code>write_set_</code> pop出来就行。【这是因为我们要用到的page类型都是page guard，可以析构时unpin吗？】</p>
</li>
</ul>
</blockquote>
<p>这是我的get方法，这里简要记录下思路。</p>
<p>我并没有使用到它说的context对象。我是类似对二叉搜索树查找的思路进行查找的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::GetValue</span><span class="params">(<span class="type">const</span> KeyType &amp;key, std::vector&lt;ValueType&gt; *result, Transaction *txn)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  BasicPageGuard guard = bpm_-&gt;<span class="built_in">FetchPageBasic</span>(header_page_id_);</span><br><span class="line">  InternalPage* root = guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;<span class="built_in">GetSize</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;root-&gt;<span class="built_in">GetSize</span>();i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">comparator_</span>(key,root-&gt;<span class="built_in">KeyAt</span>(i)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// if(key&lt;root-&gt;KeyAt(i))&#123;</span></span><br><span class="line">        guard = bpm_-&gt;<span class="built_in">FetchPageBasic</span>(root-&gt;<span class="built_in">ValueAt</span>(i<span class="number">-1</span>));</span><br><span class="line">        root = guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">      guard = bpm_-&gt;<span class="built_in">FetchPageBasic</span>(root-&gt;<span class="built_in">ValueAt</span>(root-&gt;<span class="built_in">GetSize</span>()<span class="number">-1</span>));</span><br><span class="line">      root = guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;<span class="built_in">IsLeafPage</span>())&#123;</span><br><span class="line">      <span class="keyword">auto</span> leaf = guard.<span class="built_in">As</span>&lt;LeafPage&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;leaf-&gt;<span class="built_in">GetSize</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">comparator_</span>(key,leaf-&gt;<span class="built_in">KeyAt</span>(i)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// if(key == leaf-&gt;KeyAt(i))&#123;</span></span><br><span class="line">          result-&gt;<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;ValueType&gt;(leaf-&gt;<span class="built_in">ValueAt</span>(i)));</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>进度：编译成功，测试寄</p>
<p>下一步目标：</p>
<ol>
<li>添加asset语句</li>
<li>看看测试到底哪里出错了</li>
</ol>
<p>记录下我的全代码和思路吧</p>
<ol>
<li><p>page</p>
<p>都代表着一页物理页，并且其结构为header+value。如leaf page：</p>
<p><img src="/2023/03/13/cmu15445/image-20230418110917819.png" alt="image-20230418110917819" loading="lazy"></p>
<ol>
<li><p>b_plus_tree_page        值得注意的就：IncreaseSize的amount可以是负数，代表减少size</p>
</li>
<li><p>b_plus_tree_internal_page</p>
<ol>
<li><p>增加了新的接口：SetValueAt</p>
</li>
<li><p>具体实现</p>
<ol>
<li><p>简述</p>
<p>占据一个物理页大小，代表b+树非叶结点，其key表示结点关键字，value表示指向孩子的指针。由于其结构如下：</p>
<p><img src="/2023/03/13/cmu15445/image-20230418110258801.png" alt="image-20230418110258801" loading="lazy"></p>
<p>因而key的个数比value小1，在具体实现中，key0被置为无效值。</p>
<p>故而，比如说获取index的左区间页，则为[index - 1].second；右区间页则为[index].second。</p>
</li>
<li><p>空结点的size被置为1     因为我认为默认有key0和value0</p>
</li>
<li><p>key相关函数从1开始遍历，value相关函数从0开始遍历</p>
</li>
<li><p>进行了边界保护</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>b_plus_tree_leaf_page</p>
<ol>
<li><p>增加了新的接口：ValueAt、SetKeyAt、SetValueAt</p>
</li>
<li><p>具体实现</p>
<ol>
<li><p>简述</p>
<p>占据一个物理页大小，代表b+树叶结点，其key表示结点关键字，value为真正存储数据的RID。其结构如下：</p>
<p><img src="/2023/03/13/cmu15445/image-20230418110753966.png" alt="image-20230418110753966" loading="lazy"></p>
<p>因而key与value数量一致。</p>
</li>
<li><p>相比于非叶结点，header新增了线性索引。<strong>这点我还没实现</strong>。</p>
</li>
<li><p>key和value都可以从0开始遍历</p>
</li>
<li><p>进行了边界保护</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>b+树</p>
<p>b+树本身每个结点都是物理页，并且还额外用了另一个物理页header_page来记录其root page的id。这个header_page的id被记录在成员变量中，在构造函数中被初始化为root id = INVALID，并且在context中被获取写锁。</p>
<ol>
<li><p>判空</p>
<ol>
<li>获取header_page</li>
<li>如果header page记录的root id INVALID，说明空</li>
<li>否则，继续获取root page</li>
<li>如果root_page为叶结点，当其size==0时为空；否则，size&lt;=1为空。</li>
</ol>
</li>
<li><p>查找</p>
<ol>
<li>获取root page</li>
<li>采用迭代方式进行查找。<ol>
<li>对于叶结点，从0开始遍历其所有key，寻找是否有相同的key。注意应该使用<code>comparator_(a,b)</code>来判等。</li>
<li>对于非叶结点，从1开始遍历其所有key。由于结点内部递增排序，因而当找到第一个比target大的key时，说明target应该插入到该key的左侧。</li>
</ol>
</li>
</ol>
</li>
<li><p>插入</p>
<ol>
<li><p>获取root page，登记context上下文，并且将root push进context的访问队列<code>write_set_</code>中</p>
</li>
<li><p>如果root page不存在</p>
<ol>
<li>新申请一页，更新header_page</li>
<li>对新root page进行init，并且插入key和value。注意此时root应为叶结点</li>
<li>return true</li>
</ol>
</li>
<li><p>顺着b+树一级一级查找，直到找到目标leaf</p>
<p>过程同查找，区别就是找到叶结点时应该break而非做别的事</p>
</li>
<li><p>如果key已存在，return false</p>
</li>
<li><p>插入new record到目标leaf中</p>
<ol>
<li><p>先分裂</p>
<ol>
<li><p>通过<code>write_set_</code>获取当前leaf的父节点root</p>
<ol>
<li><code>write_set_</code>为空，说明根节点就是leaf结点。此时新建一页，置root为该页</li>
<li>否则，置为back()，并且pop_back()。</li>
</ol>
</li>
<li><p>对leaf结点进行分裂</p>
<ol>
<li><p>创建新节点，并且copy旧结点的后半部分</p>
</li>
<li><p>缩小旧结点的size</p>
</li>
<li><p>改变leaf指针的值</p>
<p>因为最后要将new record插入到新分裂出的结点</p>
</li>
</ol>
</li>
<li><p>将leaf中间的那个结点值copy插入到root中【注意，不同于b树，中间结点还是会存在于两个新leaf结点中之一的，所以这里用词为copy而非move】</p>
<p>一个插入排序，从1开始遍历。最终，root的新key连接着新value（new node的page id）</p>
</li>
<li><p>向上生长</p>
<ol>
<li><p>当路径队列为空或者当前结点root无需分裂时退出</p>
</li>
<li><p>获取当前结点root的parent</p>
</li>
<li><p>分割root结点</p>
<p>由于这是对internal page的分割，故而与上面对leaf page的分割稍有不同：idx从1开始复制。我们将新节点的最左孩子置为了空，保留了旧结点的最右孩子。</p>
</li>
<li><p>将root中间的那个结点值copy插入到parent中</p>
</li>
<li><p>移动root指针：root=parent</p>
</li>
</ol>
</li>
<li><p>退出4循环后，如果需要生长根节点</p>
<ol>
<li><p>创建并初始化根节点，登记</p>
<p>注意，设置key0对于value指向旧结点。</p>
</li>
<li><p>分割当前结点</p>
</li>
<li><p>将中间部分的那个结点插入到新根节点中</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>再插入new record到分裂出的新leaf中</p>
<p>插入排序，从0开始遍历。</p>
</li>
<li><p>释放ctx，return true。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>以上就是我的全部实现。下次写代码的时候可以复习下这整个流程，我只能帮到这里了！</p>
<p>遇到个小插曲：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/minglee/p/9016306.html">Check for working C compiler: /usr/bin/cc - broken</a></p>
<p>感觉可能是内核切来切去的问题？总之我最后在5.11内核把build文件删了，重新执行<code>cmake -DCMAKE_CXX_COMPILER=$(which g++) -DCMAKE_C_COMPILER=$(which gcc) ..</code>就突然ok了。</p>
<p><img src="/2023/03/13/cmu15445/image-20230505002652748.png" alt="image-20230505002652748" loading="lazy"></p>
<p>我发现在这里创建的root最后好像会被释放掉？</p>
<p>比如我看到新root的page为6，连接也做得好好的，最后出了函数就寄了：</p>
<p><img src="/2023/03/13/cmu15445/image-20230505002731312.png" alt="image-20230505002731312" loading="lazy"></p>
<p>还有一个是发现新的leaf page好像不大对，其类型甚至是internal呃呃，我调下看看</p>
<p>尼玛，绷不住了是这里：</p>
<p><img src="/2023/03/13/cmu15445/image-20230505011731797.png" alt="image-20230505011731797" loading="lazy"></p>
<p>原来写的</p>
<p><img src="/2023/03/13/cmu15445/image-20230505011744924.png" alt="image-20230505011744924" loading="lazy"></p>
<p>改了之后test2马上ok，乐</p>
<p>完成了index_iterator的编写。接下来需要修改b+tree.cpp，新增Begin的实现。</p>
<p>不过index iterator报错了，之后再改</p>
<p>乐，我过了iterator的编译之后，第一件事肯定是重构这沙比石山</p>
<p>乐，重载++运算符的话，一定要特别注意：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>++() -&gt; INDEXITERATOR_TYPE &amp; &#123; </span><br><span class="line">    <span class="keyword">auto</span> page = guard_.<span class="built_in">As</span>&lt;LeafPage&gt;();</span><br><span class="line">    cnt_ ++;</span><br><span class="line">    <span class="comment">// printf(&quot;cnt: %d, get size: %d, next id %d\n&quot;, cnt_, page-&gt;GetSize(), page-&gt;GetNextPageId());</span></span><br><span class="line">    <span class="keyword">if</span> (cnt_ &lt; page-&gt;<span class="built_in">GetSize</span>()) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;here\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> res = <span class="keyword">new</span> <span class="built_in">INDEXITERATOR_TYPE</span>(bpm_, page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">    <span class="comment">// printf(&quot;res: cnt %d, pgid %d\n&quot;, res-&gt;cnt_, res-&gt;pgid_);</span></span><br><span class="line">    <span class="keyword">return</span> *res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我原来是这么写的，但这么写实际上正确的只是返回值，目前的这个this对象是没有变的。所以我们其实应该这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>++() -&gt; INDEXITERATOR_TYPE &amp; &#123; </span><br><span class="line">    <span class="keyword">auto</span> page = guard_.<span class="built_in">As</span>&lt;LeafPage&gt;();</span><br><span class="line">    cnt_ ++;</span><br><span class="line">    <span class="keyword">if</span> (cnt_ &lt; page-&gt;<span class="built_in">GetSize</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pgid_ = page-&gt;<span class="built_in">GetNextPageId</span>();</span><br><span class="line">    cnt_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泪目！</p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>修年</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://xiunianjun.github.io/2023/03/13/cmu15445$lab2/" title="Project2   B+Tree">https://xiunianjun.github.io/2023/03/13/cmu15445$lab2/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2023/03/13/cmu15445/" rel="prev" title="CMU15445"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">CMU15445</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2023/02/25/cs144/" rel="next" title="cs144"><span class="post-nav-text">cs144</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> 修年</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.2</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>