<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java并发编程实战</title>
    <url>/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<blockquote>
<p>idea 替换注释正则表达式<code>/\*&#123;1,2&#125;[\s\S]*?\*/</code></p>
</blockquote>
<h1 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h1><h2 id="线程的作用"><a href="#线程的作用" class="headerlink" title="线程的作用"></a>线程的作用</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102195038586.png" class>

<p>这一段写得很好，非常易懂地概括了什么是“多线程把异步转化为同步”：把异步中的不同操作分解为一个个独立的同类型操作，然后只需实现这些相较简单的同类型操作，再异步地把它们调度起来就行。<strong>线程正是把复杂的异步工作流分解成了一组简单的同步工作流</strong>。</p>
<h2 id="线程无处不在"><a href="#线程无处不在" class="headerlink" title="线程无处不在"></a>线程无处不在</h2><p>如果一个模块在代码中引入了并发性，那么它所有的代码路径【调用链】都得是并发的。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/wps1.jpg" class> 

<p>最后一句话很关键，“把线程安全性封装在共享对象内部”</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/wps2.jpg" class> 

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/wps3.jpg" class> 

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/wps4.jpg" class> 

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/wps5.jpg" class> 

<p>这个不同于上面的方法：将共享对象包装为线程安全的。它是要求了这些共享对象仅能在事件线程中运行，这样来保证线程安全性。</p>
<h1 id="第二章-线程安全性"><a href="#第二章-线程安全性" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h1><p>**<u>线程安全的核心就是对状态的访问和操作进行管理</u>**，特别是对那些共享（shared）的、可变（mutable）的状态。关于本句话，其中几点将在下面一一细说：</p>
<ol>
<li><p>状态</p>
<p>状态是<strong>指存储在状态变量里的数据</strong>，如成员变量、静态域等等等。对象的状态还可能包括其他依赖对象的域，如HashMap的状态包括Map.Entry的状态。</p>
</li>
<li><p>共享和可变</p>
<p>共享意味着变量可以由多个线程同时访问，可变意味着变量的值在生命周期可发生变化</p>
</li>
<li><p>是否需要线程安全</p>
<p><strong>取决于它是否被多个线程访问</strong>。比如说，如果一个局部变量仅在某个函数体中同时只被一个线程访问，那么它就不需要线程安全，不需要同步机制。</p>
</li>
</ol>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102200122078.png" class>



<h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102200220498.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102200229901.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102200300955.png" class>

<p>注意，<strong>线程安全不会违背不变性和后验条件</strong>，这句话在后面会用到。</p>
<h3 id="无状态对象一定是线程安全的"><a href="#无状态对象一定是线程安全的" class="headerlink" title="无状态对象一定是线程安全的"></a>无状态对象一定是线程安全的</h3><p>在此举例一个无状态线程：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102200408861.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatelessFactorize</span> <span class="keyword">implements</span>  <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req,ServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102200450178.png" class>

<p><strong>无状态对象一定是线程安全的</strong></p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><p>我们可以在无状态对象的基础上为它增加一个域：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102201019332.png" class>

<p>这是线程不安全的，因为++count包含了三个动作：<strong>读取—修改—写入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov reg,count</span><br><span class="line">add reg,1</span><br><span class="line">mov count,reg</span><br></pre></td></tr></table></figure>

<p>它并不具有原子性。</p>
<p>在并发编程中，这种由于时序原因产生错误的情况叫做“<strong>竞态条件</strong>”。</p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102201348670.png" class>

<p>竞态条件有两种常见的类型。两种竞态条件的本质其实都是“<strong>基于对象之前的状态来定义对象状态的转换</strong>”。对于读取-修改-写入，是先copy原值，然后对原值+1，再写回，这是基于对象之前的状态来定义对象状态的转换；对于先检查后执行，很显然就是判断原值然后再转换到下一个状态，这就不必说了。</p>
<h4 id="读取-修改-写入"><a href="#读取-修改-写入" class="headerlink" title="读取-修改-写入"></a>读取-修改-写入</h4><p>如上引例</p>
<h4 id="先检查后执行"><a href="#先检查后执行" class="headerlink" title="先检查后执行"></a>先检查后执行</h4><p>实例：懒加载，延迟初始化中的竞态条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyInitRace</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExpensiveObject</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ExpensiveObject <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">ExpensiveObject</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="竞态条件与数据竞争差别"><a href="#竞态条件与数据竞争差别" class="headerlink" title="竞态条件与数据竞争差别"></a>竞态条件与数据竞争差别</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/wps6.jpg" class>



<p>这书里讲得云里雾里的，百度了一下： </p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/wps7.jpg" class> 

<p>比如说书给例子，线程向共享对象读写数据，线程是操作对象A，共享对象是被操作对象B。则：</p>
<p>竞态条件：在乎的是被线程操控的共享对象的结果是否正确</p>
<p>数据竞争：在乎的是操作共享对象后，线程的结果是否正确。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/wps8.jpg" class> 

<p>确实，书里对数据竞争强调的是一个读一个写，对竞态条件更像是两个同时写 </p>
<h3 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102201926491.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102201940603.png" class>



<p>我们可以用一个线程安全类来解决前面的Count请求的需求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingFactorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span>&#123; <span class="keyword">return</span> count.get(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(SevletRequest req,ServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102202043701.png" class>



<h2 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h2><h3 id="线程安全分析法与为什么要加锁"><a href="#线程安全分析法与为什么要加锁" class="headerlink" title="线程安全分析法与为什么要加锁"></a>线程安全分析法与为什么要加锁</h3><p>上面说到，当对象内仅有<u>一个状态</u>时，可以<strong>通过使用线程安全类来保障原子性</strong>。但当对象里存在<u>多个状态</u>时，就必须<strong>用锁来进行线程同步</strong>，而非简单地用多个线程安全类。</p>
<p>还是以上面的实例来解释。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102202253296.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeCachingFactorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger&gt; lastNumber = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger[]&gt; lastFactors = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req,ServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此处产生了竞态条件。</span></span><br><span class="line"><span class="comment">        如果一个变量在此之后，return之前修改了lastFactors，就会寄</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (i.equals(lastNumber.get())) encodeIntoResponse(resp,lastFactors.get());</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            BigInteger[] factors = factor(i);</span><br><span class="line">            <span class="comment">//本该需要瞬间一起完成的两个动作之间有时间间隔，不具原子性</span></span><br><span class="line">            lastNumber.set(i);</span><br><span class="line">            lastFactors.set(factors);</span><br><span class="line">            encodeIntoResponse(resp,factors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102202335091.png" class>

<p>这段论述非常精彩，昭示了两个道理：1.分析线程安全性的时候，可以从“不变性条件不被破坏”开始考虑，首先考虑<strong>不变性条件</strong>应该是什么。2.在不变性条件涉及的多个变量彼此不独立，因而这些变量需要<strong>同时同步更新</strong>，上面那个例子就是因为不变性约束条件中的两个不独立变量没有同时同步更新。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102204155544.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102202729768.png" class>

<p>确实，非常重要的一点就是<strong>在两个需要连续同时修改的变量之间有了并行的时间间隔，导致此期间并行的线程的不变性被破坏</strong>。</p>
<h3 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102203034529.png" class>



<p>同步代码块包含两部分，锁的引用和保护的代码段。关键字synchronized修饰的方法就是一段同步代码段，其锁对象为当前实例【非静态方法】或者是当前class的实例【静态方法】。</p>
<blockquote>
<p>这个具体的“锁”是什么以前是真不知道。已知的是所有Object都有wait和什么什么notify方法。不过想想也确实。所有线程争抢着访问一个对象的某个同步方法段，这不正跟所有线程争抢着一个锁是差不多意思的吗？“锁”的定义其实是很宽泛的</p>
</blockquote>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102203228798.png" class>

<p>java的内置锁<strong>并非无饥饿</strong>的。当线程B永远不释放锁，A会一直等待下去。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102203331822.png" class>

<p>我们可以用synchronized来解决上面的计数器问题，即直接给service方法设为synchronized。当然这种方法性能很糟糕，因为它极大降低了并发度。</p>
<h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102203636560.png" class>

<p>其中关于粒度的理解：</p>
<p>不是“每一次调用获取一次锁，该锁属于该此调用”，而是“每个线程调用时获取一次锁，该锁属于该线程”</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102203915238.png" class>



<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102203748800.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingWidget</span> <span class="keyword">extends</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(toString()+<span class="string">&quot;:calling doSomething.&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上述代码，创建了一个LoggingWidget实例，然后调用该实例的dosmething方法，就会获取到该实例的锁。如果不允许重入，那么在做super.doSomething时，该实例的锁【注意，是同一个实例】已经被占用还未释放，因此产生死锁。<strong>有重入就可以避免此问题</strong>。</p>
<h2 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102203950728.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102204031620.png" class>

<p>但这很考验人的记性。一旦你在某个地方忘了同步了就会寄。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102204225493.png" class>



<h2 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h2><p>上面那个直接对service方法进行synchronized的改善方法粒度太粗了，可以试试如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedFactorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span> (<span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> BigInteger lastNumber;</span><br><span class="line">    <span class="meta">@GuardedBy</span> (<span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line">    <span class="meta">@GuardedBy</span> (<span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> <span class="type">long</span> hits;</span><br><span class="line">    <span class="meta">@GuardedBy</span> (<span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> <span class="type">long</span> cacheHits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">getHits</span><span class="params">()</span>&#123;<span class="keyword">return</span> hits;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">double</span> <span class="title function_">getCacheHitRatio</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)cacheHits/(<span class="type">double</span>) hits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req,ServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            ++hits;</span><br><span class="line">            <span class="keyword">if</span> (i.equals(lastNumber))&#123;</span><br><span class="line">                ++cacheHits;</span><br><span class="line">                factors = lastFactors.clone();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//局部变量无需同步保护</span></span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="literal">null</span>)&#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                lastNumber = i;</span><br><span class="line">                lastFactors = factors.clone();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102220922809.png" class>

<p>毕竟因数分解的时候无需同步保护，因为这时候参与运算的都是局部变量。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221102221015006.png" class>



<h1 id="第三章-安全地共享对象"><a href="#第三章-安全地共享对象" class="headerlink" title="第三章 安全地共享对象"></a>第三章 安全地共享对象</h1><p>上一章讲述了，线程安全的本质就是对共享和可变状态进行管理，以及介绍了用锁来保护状态。</p>
<p>本章将引入同步除原子性外的另一特性——可见性，然后再介绍如何构建线程安全类，并且安全地发布和共享对象。</p>
<p>关键词：可见性    Volatile    线程封闭    不可变对象</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105163155450.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105163232378.png" class>



<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="引例——可见性的定义"><a href="#引例——可见性的定义" class="headerlink" title="引例——可见性的定义"></a>引例——可见性的定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!ready)&#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">        number=<span class="number">42</span>;</span><br><span class="line">        ready=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105163609582.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105163846509.png" class>

<blockquote>
<p>关于此程序显示出的对于内存可见性的理解，可以看这篇文章：</p>
<p><a href="https://blog.csdn.net/m0_55161603/article/details/122488932">多线程(六):并发编程的三大特性之可见性</a></p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YyX6bi94oCZ,size_20,color_FFFFFF,t_70,g_se,x_16.png" class>

<p>其实原因非常显而易见：主线程改了之后不会立刻把变量刷新到主存【可能默认是在ret时刷新，或者定时刷新，前者会导致相互等待的死锁，后者也会产生性能问题】，导致主线程的那个修改的flag变量对t1线程是**<u>不可见</u>**的，因此t1会继续循环等待。</p>
</blockquote>
<h3 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105164337363.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105164403871.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105164419485.png" class>



<h3 id="最低安全性"><a href="#最低安全性" class="headerlink" title="最低安全性"></a>最低安全性</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105164525354.png" class>

<p>注意，<strong>最低安全性不适用于非volatile类型的64位数据。</strong></p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105164615006.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105164639635.png" class>



<h3 id="加锁与可见性"><a href="#加锁与可见性" class="headerlink" title="加锁与可见性"></a>加锁与可见性</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105164739481-1667638065032-4.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105164903200.png" class>

<p>要实现这种操作，我们可以设想一下关于内存可见性这一块内置锁的实现原理：<u>lock时绑定指定变量，unlock时再刷新这个/些绑定变量的内存</u>。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105165043425.png" class>

<p>所以说得有锁，并且锁还得是对的。</p>
<p>看着看着有种always语句块的感觉了2333</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105165120398.png" class>



<h3 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h3><h4 id="Volatile保证内存可见性"><a href="#Volatile保证内存可见性" class="headerlink" title="Volatile保证内存可见性"></a>Volatile保证内存可见性</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105165208197.png" class>到其他线程。【我想大概就是一改变了，就马上刷新内存中的旧值，然后也许通过什么嗅探检测到值变化，通知所有线程改变自己持有的旧值。】

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105165414826.png" class>

<p><u>注意不放在寄存器里或者线程的私有栈里</u></p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105165453198.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105165544977.png" class>

<blockquote>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YyX6bi94oCZ,size_20,color_FFFFFF,t_70,g_se,x_16-1667638524177-6.png" class>
</blockquote>
<h4 id="Volatile不保证原子性"><a href="#Volatile不保证原子性" class="headerlink" title="Volatile不保证原子性"></a>Volatile不保证原子性</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105171553395.png" class>

<blockquote>
<p><a href="https://blog.csdn.net/qq_46190347/article/details/109908724">volatile为什么不能保证原子性？</a>   </p>
<p>但这个有争议：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105170154847.png" class>

<ul>
<li>在多处理器下，为了保证各个处理器的缓存是一致的，就会<strong>实现缓存一致性协议</strong>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，<strong>会重新从系统内存中把数据读到处理器缓存里</strong>。</li>
</ul>
<p>也就是说，</p>
<p>如果线程B在+1前知道数据无效了，就会重新载入数据然后+1然后载入内存，结果正确；</p>
<p>如果线程B在+1后才知道数据无效，虽然会重新载入数据，数据为A修改后的新数据，但是此时指令无法回退，因而只能继续执行下一条指令：写回内存，B写回内存的是A修改后的新数据，因而结果错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大致过程：</span><br><span class="line">a:mov reg 1</span><br><span class="line">b:mov reg 1</span><br><span class="line">a:add reg 1</span><br><span class="line">b:add reg 1</span><br><span class="line">a:mov reg mem</span><br><span class="line">然后b线程得到通知，重新载入数据:mov reg mem</span><br><span class="line">但是指令无法回退：mov reg mem</span><br><span class="line">因而结果是A修改后的值被写入了两遍。</span><br></pre></td></tr></table></figure>

<p>所以其实<strong>volatile仅确保单次读写的瞬时线程安全</strong>。<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105170451407.png" class></p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105170516201.png" class>

<p>以下是别人的理解扩展：</p>
<p><a href="https://www.cnblogs.com/keeya/p/9255136.html">对volatile不具有原子性的理解</a></p>
<p><a href="https://bbs.csdn.net/topics/391996453?page=1">volatile 无法保证原子性一个简单示例的疑问</a></p>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析 </a></p>
</blockquote>
<h4 id="Volatile的使用方法"><a href="#Volatile的使用方法" class="headerlink" title="Volatile的使用方法"></a>Volatile的使用方法</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105165638152.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105171257946.png" class>

<p>下面给出一个volatile的典型用法：检查某个状态标记以判断是否退出循环。【也就是上文那个例子】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> asleep;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">	<span class="keyword">while</span>(!asleep)	countingSheep();</span><br></pre></td></tr></table></figure>



<h2 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h2><h3 id="发布与逸出的概念"><a href="#发布与逸出的概念" class="headerlink" title="发布与逸出的概念"></a>发布与逸出的概念</h3><h4 id="通俗地解释发布和逸出"><a href="#通俗地解释发布和逸出" class="headerlink" title="通俗地解释发布和逸出"></a>通俗地解释发布和逸出</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105194322515.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105194351358.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105194432263.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105194443414.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105194459170.png" class>

<p>这个“逸出作用域”的表述非常不错。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105194530237.png" class>



<h4 id="什么时候会发生发布和逸出"><a href="#什么时候会发生发布和逸出" class="headerlink" title="什么时候会发生发布和逸出"></a>什么时候会发生发布和逸出</h4><h5 id="外部方法"><a href="#外部方法" class="headerlink" title="外部方法"></a>外部方法</h5><p><u>当把一个对象传递给某个外部方法，就相当于发布了这个对象</u>。</p>
<p>外部方法：<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105194808800.png" class></p>
<h5 id="发布内部的类实例"><a href="#发布内部的类实例" class="headerlink" title="发布内部的类实例"></a>发布内部的类实例</h5><p>“this escape”</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105195101889.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">(EventSource source)</span>&#123;</span><br><span class="line">        id = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//发布</span></span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="comment">//内部类</span></span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">EventListener</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span>&#123;</span><br><span class="line">                    <span class="comment">//doSomething(e);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        name = <span class="string">&quot;escape&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://blog.csdn.net/weixin_34348050/article/details/114174525">java this 逸出_Java并发编程——this引用逸出(“this” Escape)</a></p>
<p>并发编程实践中，this引用逃逸(“this”escape)是指对象还没有构造完成，它的this引用就被发布出去了。</p>
<p>ThisEscape在构造函数中引入了一个内部类EventListener，而内部类会自动的持有其外部类(这里是ThisEscape)的this引用。source.registerListener会将内部类发布出去，从而ThisEscape.this引用也随着内部类被发布了出去。但此时ThisEscape对象还没有构造完成 —— id已被赋值为1，但name还没被赋值，仍然为null。这样一来，就有些线程持有不完整实例，不确定性太大了</p>
</blockquote>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105195710718.png" class>

<p>也就是说，如果是单线程情况下，这样做是没问题的，毕竟最后都会构造完整。但多线程情况下，这俩有时间间隔，因此会产生问题，并且不能靠简单地把这句发布对象的语句放在构造函数最后一行。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105200359583.png" class>

<p><u><strong>这段话非常值得注意</strong></u></p>
<p>所以说上面那个例子的正确代码：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221105201404889.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SafeListener</span><span class="params">()</span>&#123;</span><br><span class="line">        listener = <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span>&#123;</span><br><span class="line">                <span class="comment">//doSomething(e);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title function_">newInstance</span><span class="params">(EventSource source)</span>&#123;</span><br><span class="line">        <span class="type">SafeListener</span> <span class="variable">safe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SafeListener</span>();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><h3 id="线程封闭是什么"><a href="#线程封闭是什么" class="headerlink" title="线程封闭是什么"></a>线程封闭是什么</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106160450642.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106160533344.png" class>

<p>线程封闭一般有三种方法，这三种方法的规范性是逐级递增的。</p>
<h3 id="Ad-hoc线程封闭"><a href="#Ad-hoc线程封闭" class="headerlink" title="Ad-hoc线程封闭"></a>Ad-hoc线程封闭</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106160651709.png" class>

<blockquote>
<p>这里，书写得非常地抽象。通过查阅资料可得解释得更通俗的：</p>
<p><a href="https://blog.csdn.net/iteye_2159/article/details/82549680">Ad-hoc线程封闭</a></p>
<p><a href="https://stackoverflow.com/questions/9039503/example-of-ad-hoc-thread-confinement-in-java">Example of ad hoc thread confinement in Java</a></p>
<p>总之其实精华就这一句话：<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106160841188.png" class></p>
<p>并且都是人为约束，并且一般可能会用volatile来控制单线程写这种情况下的同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Don&#x27;t modify this from any other thread than Thread X.</span></span><br><span class="line"><span class="comment">// So use it read-only for those other threads.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> someNumber;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106160956574.png" class>

<p>也就是我们前面说的，局部变量只能在该线程内访问，除非逸出了，否则是非常安全的。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106161052333.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106161424469.png" class>

<h4 id="对于基本类型"><a href="#对于基本类型" class="headerlink" title="对于基本类型"></a>对于基本类型</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106161152939.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106161113990.png" class>意思就是说，java没有指针，获取不了这些不是对象的基本类型的引用，因而这些基本类型不可能通过调用外部方法之类的逸出【调用外部方法仅仅是取得它们的一份copy而非本身】，所以这些基本类型的局部变量始终封闭在线程内。

<h4 id="对于引用类型"><a href="#对于引用类型" class="headerlink" title="对于引用类型"></a>对于引用类型</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106161352744.png" class>

<p>因而需要格外注意逸出问题</p>
<p>下面给出对基本类型和引用类型栈封闭的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span>&#123;</span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    SortedSet&lt;Animal&gt; animals;</span><br><span class="line">    <span class="comment">//基本类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numPairs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">candidate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要详细写好注释↓</span></span><br><span class="line">    <span class="comment">//animals被封闭在方法中，不要使它们逸出！</span></span><br><span class="line">    animals = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Animal&gt;(<span class="keyword">new</span> <span class="title class_">SpeciesGenderComparator</span>());</span><br><span class="line">    animals.addAll(candidates);</span><br><span class="line">    <span class="keyword">for</span> (Animal a : animals)&#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate == <span class="literal">null</span> || !candidate.isPotentialMate(a))</span><br><span class="line">                candidate = a;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ark.load(<span class="keyword">new</span> <span class="title class_">AnimalPair</span>(candidate,a));</span><br><span class="line">            ++numPairs;</span><br><span class="line">            candidate = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;<span class="type">char</span>[]&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numPairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><blockquote>
<p><a href="https://blog.csdn.net/u010445301/article/details/111322569">史上最全ThreadLocal 详解（一）</a></p>
</blockquote>
<h4 id="简介和应用实例"><a href="#简介和应用实例" class="headerlink" title="简介和应用实例"></a>简介和应用实例</h4><p>上面介绍了使用局部变量来实现线程封闭的方法，也就是栈封闭。它只要合理地控制在调用方法时不发生逸出，就可以实现线程安全。</p>
<p>当有多个线程都需要同一类对象【比如Connection对象、ThreadID】，并且要求每个线程内的该对象是不一样的，并且该对象需要在多个方法中访问，栈封闭的方法就显得有些麻烦和不够优雅：需要在每个线程内都创建一个不同的对象实例，并且在调用方法的时候，都把该对象实例作为参数传进去。</p>
<p>这时候就需要ThreadLocal类了。</p>
<p>ThreadLocal类会给每个线程分配一个对象，并且仅需使用get方法，就能自动地把线程中的对象给弄出来。并且这些分配的对象对于各个线程来说都是隔离，相互不可见的，因此实现了线程封闭，具有安全性。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106163700136.png" class>

<p>以ThreadID为例：</p>
<p>For example, the class below generates unique identifiers local to each thread. A thread’s id is assigned the first time it invokes ThreadId.get() and remains unchanged on subsequent calls.下面代码保证每个线程首次调用ThreadId.get方法后可以分配到一个不重ID，并且ID一旦确定，之后再调用get方法得到的ID是不会改变的。它这相当于维护了一个共有的计数器局部变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadId</span> &#123;</span><br><span class="line">    <span class="comment">// Atomic integer containing the next thread ID to be assigned</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Thread local variable containing each thread&#x27;s ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nextId.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Returns the current thread&#x27;s unique ID, assigning it if necessary</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadId.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个想获取自身ThreadID的线程，在所有想用到ID的方法中，只需：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">AtomicInteger</span> <span class="variable">myID</span> <span class="operator">=</span> ThreadID.get();</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而不用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">myID</span> <span class="operator">=</span> getID();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method</span><span class="params">(AtomicInteger myID)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样大大简化了实现。</p>
<p>再比如：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106150158599.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> Connection <span class="title function_">initialValue</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106171312783.png" class>

<p>关于这个的大概代码猜想：</p>
<p>这样一来，在一个线程中使用toString，就仅需造一个buf【这个是ThreadLocal封闭】，而不用每次调用都造一个【这个是栈封闭】了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;<span class="type">char</span>[]&gt; buf</span><br><span class="line"> 	= <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;<span class="type">char</span>[]&gt;()&#123;</span><br><span class="line"> 		<span class="meta">@Override</span></span><br><span class="line"> 		<span class="keyword">public</span> <span class="type">char</span>[] initialValue()&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">12</span>];</span><br><span class="line">         &#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="comment">//使用buf</span></span><br><span class="line"> <span class="type">char</span>[] buffer = buf.get();</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><h5 id="大致结构"><a href="#大致结构" class="headerlink" title="大致结构"></a>大致结构</h5><p>我们可以初步猜想，ThreadLocal大概是通过一个map实现的，里面存储着&lt;Thread,value&gt;这样的键值对，每次就能通过Thread来取出对应的value了。Java低版本确实是这么做的。但Java的高版本对此进行了优化。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0NDUzMDE=,size_16,color_FFFFFF,t_70.png" class>

<p>从本来的：ThreadLocalMap&lt;Thread, value&gt; ∈ ThreadLocal</p>
<p>变成了：    ThreadLocalMap&lt;ThreadLocal, value&gt; ∈ Thread</p>
<p>并且其中的ThreadLocal这个key是以弱引用【WeakReference】的方式实现的。</p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_49684062/article/details/124875810">ThreadLocal探究</a></p>
<p>这样的结构演进有什么好处<br>在旧版的ThreadLocal中，所有线程都将本地变量存在同一个ThreadLocalMap中，当并发量比较高的时候，ThreadLocalMap中的数据量会很大，而新版的ThreadLocalMap是属于线程的，也就是每个线程都操作属于自己的ThreadLocalMap，那么map中存储的变量就只有自己所存入的，数据量大大减少。</p>
<p>还有一个好处，旧版的ThreadLocalMap属于ThreadLocal，当Thread实例被销毁时ThreadLocalMap里该线程的数据<u>不会被同时销毁</u>【这也许就带来了危险性】，而新版ThreadLocalMap属于线程，<u>线程被销毁时，ThreadLocalMap也随之销毁</u>。</p>
</blockquote>
<h5 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h5><blockquote>
<p>This class provides thread-local variables.线程局部变量，也就是我们说的线程封闭手法。</p>
<p>These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. 每个线程都有它自己的、独立初始化的该变量的副本。</p>
<p>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).它一般用于私有静态字段，whose 状态和线程关系密切。</p>
<p>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible.</p>
<p>After a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).最后会被垃圾回收</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    它这个初始化方法非常聪明且独特。</span></span><br><span class="line"><span class="comment">    一般使用它的时候是直接new然后重载一个匿名内部类的，</span></span><br><span class="line"><span class="comment">    于是就直接在建立匿名内部类时override此方法，在里面构造初始化的对象，</span></span><br><span class="line"><span class="comment">    且该方法仅在get调用的时候才会顺带调用</span></span><br><span class="line"><span class="comment">    有一种lazy的思想在里面。</span></span><br><span class="line"><span class="comment">    Normally, this method is invoked at most once per thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Creates a thread local variable.</span></span><br><span class="line">    <span class="comment">//The initial value of the variable is determined by Supplier的get方法.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="title function_">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//也就是说，每个线程都有个ThreadLocal的map成员变量</span></span><br><span class="line">        <span class="comment">//里面装的是&lt;ThreadLocal变量，该变量在该线程的值&gt;这样的键值对</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//得到线程里存储的ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//&lt;ThreadLocal, value&gt;</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map==null【还没有线程局部变量】或者e==null【还没有该线程局部变量】</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">return</span> map != <span class="literal">null</span> &amp;&amp; map.getEntry(<span class="built_in">this</span>) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取初始化值</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//传入空map的第一个结点</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">            TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">            m.remove(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> ThreadLocalMap <span class="title function_">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T <span class="title function_">childValue</span><span class="params">(T parentValue)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line"></span><br><span class="line">        SuppliedThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier) &#123;</span><br><span class="line">            <span class="built_in">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ThreadLocalMap is a customized hash map suitable only for maintaining thread local values.</span></span><br><span class="line"><span class="comment">    To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.key【ThreadLocal】是弱引用的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Note that null keys (i.e. entry.get() == null) mean that the key is no longer referenced, so the entry can be expunged from table. Such entries are referred to as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">   		意思就是说陈旧条目【stale entry】指的是key为空的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">//The value associated with this ThreadLocal.</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//The initial capacity -- MUST be a power of two.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//The next size value at which to resize.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set the resize threshold to maintain at worst a 2/3 load factor.</span></span><br><span class="line">        <span class="comment">//默认情况下，装载因子为2/3</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">            threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使i增加，并且让增加后的结果模len。也就是(++i)%len。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//也就是(--i)%len。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Construct a new map initially containing (firstKey, firstValue). </span></span><br><span class="line">        <span class="comment">//ThreadLocalMaps are constructed lazily,</span></span><br><span class="line">        <span class="comment">//so we only create one when we have at least one entry to put in it.</span></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">            <span class="comment">//依旧是HashMap里面经典的掩码操作，key的hashcode作为entry在table里的序号</span></span><br><span class="line">            <span class="comment">//与hashmap的差别就在于，hashmap的桶table一个里面可以存放多个结点，</span></span><br><span class="line">            <span class="comment">//但这里的ThreadLocal的hash显然是不冲突的，因而只能存放一个结点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">            Entry[] parentTable = parentMap.table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">            setThreshold(len);</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[len];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> parentTable[j];</span><br><span class="line">                <span class="comment">//有对应结点</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                    <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                        <span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (table[h] != <span class="literal">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        table[h] = c;</span><br><span class="line">                        size++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">                 e != <span class="literal">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">                 e != <span class="literal">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">            <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">            <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">            <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">                 i = prevIndex(i, len))</span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">            <span class="comment">// occurs first</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">                <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">                <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">                <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">                <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">                <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">                <span class="comment">// first still present in the run.</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">            tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">            tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                    e.value = <span class="literal">null</span>;</span><br><span class="line">                    tab[i] = <span class="literal">null</span>;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                        tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                        <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                        <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">                    n = len;</span><br><span class="line">                    removed = <span class="literal">true</span>;</span><br><span class="line">                    i = expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">            expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">            Entry[] oldTab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">            Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                        e.value = <span class="literal">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                            h = nextIndex(h, newLen);</span><br><span class="line">                        newTab[h] = e;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setThreshold(newLen);</span><br><span class="line">            size = count;</span><br><span class="line">            table = newTab;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">                    expungeStaleEntry(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li><h6 id="哈希方法和解决哈希冲突"><a href="#哈希方法和解决哈希冲突" class="headerlink" title="哈希方法和解决哈希冲突"></a>哈希方法和解决哈希冲突</h6><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221106165903124.png" class>

<p>存在哈希冲突的话，大概是采用的线性探测方法。</p>
</li>
<li><h6 id="解决内存泄漏"><a href="#解决内存泄漏" class="headerlink" title="解决内存泄漏"></a>解决内存泄漏</h6><p>关于其remove方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">	<span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">		m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m.remove</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//线性探测</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">                 e != <span class="literal">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>两篇文章都有解释</p>
<blockquote>
<p> remove方法，直接将ThrealLocal 对应的值从当前相差Thread中的ThreadLocalMap中删除。为什么要删除，这涉及到内存泄露的问题。</p>
<p> 实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p>
<p> 所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p>
<p> ThreadLocal其实是与线程绑定的一个变量，如此就会出现一个问题：如果没有将ThreadLocal内的变量删除（remove）或替换，它的生命周期将会与线程共存。通常线程池中对线程管理都是采用线程复用的方法，在线程池中线程很难结束甚至于永远不会结束，这将意味着线程持续的时间将不可预测，甚至与JVM的生命周期一致。举个例字，如果ThreadLocal中直接或间接包装了集合类或复杂对象，每次在同一个ThreadLocal中取出对象后，再对内容做操作，那么内部的集合类和复杂对象所占用的空间可能会开始持续膨胀。<br> ————————————————<br> 版权声明：本文为CSDN博主「倔强的不服」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：<a href="https://blog.csdn.net/u010445301/article/details/111322569">https://blog.csdn.net/u010445301/article/details/111322569</a></p>
</blockquote>
<blockquote>
<p>ThreadLocal内存泄漏问题的解析。<br>前面我们说到它虽然线程安全，但是它存在一个问题那就是内存泄漏。</p>
<p>首先我们要明白为什么会内存泄漏，前面也说了ThreaLocal是一个弱引用，什么是弱引用就是当它为null时候，就会被垃圾回收机制给带走，重点就是，如果我们的ThreadLocal突然为null，然后就被回收了，但此时我们的ThreadLocalMap它的生命周期是和Thread相同的，简单理解就是，裤子没了，兜还在，兜里面还有我们的数据，这就造成了内存泄漏。</p>
<p>如何解决那：我们必须在使用完ThreadLocal后，执行remove()方法，避免内存溢出。<br>————————————————<br>版权声明：本文为CSDN博主「某刘姓男子i的码农客栈」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_20783497/article/details/107980858">https://blog.csdn.net/qq_20783497/article/details/107980858</a></p>
</blockquote>
</li>
</ol>
<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><h4 id="不可变对象的线程安全性"><a href="#不可变对象的线程安全性" class="headerlink" title="不可变对象的线程安全性"></a>不可变对象的线程安全性</h4><p>满足同步需求的另一种方案就是使用<strong>不可变对象</strong>。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107192736143.png" class>

<p>这个思路非常地简单粗暴：什么东西影响了，就直接让它消失。非常有意思2333</p>
<p>如果某个对象在创建后不能被修改，那么它就叫不可变对象。<strong>线程安全性是不可变对象的固有属性之一</strong>。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107192949343.png" class>

<p>比如说final域只能在声明的成员域或者构造函数中初始化，两者本质上都是在构造函数中初始化的。</p>
<p>并且不可变对象也更加安全。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107193040278.png" class>



<h4 id="不可变对象与final域"><a href="#不可变对象与final域" class="headerlink" title="不可变对象与final域"></a>不可变对象与final域</h4><p><strong>不可变性不等于将对象中的所有域都设置为final域</strong>，因为final类型的域可以是对可变对象的引用。【这就类似C语言中const指针】当且仅当满足下列条件，对象才是不可变的：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107193244450.png" class>

<blockquote>
<p>对于这里注释提到的String类，它讲得有些让人迷惑。因而我查阅资料得到解说如下：</p>
<p><a href="https://www.likecs.com/show-306534264.html">String中hashCode方法的线程安全</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">　　<span class="comment">//默认值是0</span></span><br><span class="line">　　<span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//将成员变量hash缓存到局部变量</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">　　　　 <span class="comment">//这里使用的是局部变量，因此没有多线程修改的风险</span></span><br><span class="line">     <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="type">char</span> val[] = value;</span><br><span class="line">         <span class="comment">//求hashcode过程使用局部h变量防止产生静态条件</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">             h = <span class="number">31</span> * h + val[i];</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//把求出的hashcode缓存到局部变量，原子操作</span></span><br><span class="line">         <span class="comment">//这里不需要考虑线程可见性的问题，</span></span><br><span class="line">         <span class="comment">//如果其它线程未能及时看到最新修改，重新计算hash值代价也不大</span></span><br><span class="line">         hash = h;</span><br><span class="line">   	&#125;</span><br><span class="line">   	<span class="keyword">return</span> h;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回去看书中注释的描述：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107193539234.png" class>

<p>这个的意思就是说，对每个线程来说，同一个字符串hashcode值都是一样的【每次计算都得到相同的结果】，所以就不会产生多个线程计算出不同值的情况，导致不同步的发生。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107193749887.png" class>

<p>意思是说之所以hashcode值一样，是因为这个hashcode计算是基于不可变对象的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>

<p>并且重复计算性能代价可能远没有加锁的消耗来得大，因而这里仅使用了栈封闭来保证一定程度上的线程同步。</p>
</blockquote>
<h4 id="可变对象基础上构建不可变类"><a href="#可变对象基础上构建不可变类" class="headerlink" title="可变对象基础上构建不可变类"></a>可变对象基础上构建不可变类</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107194256286.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreeStooge</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreeStooge</span><span class="params">()</span>&#123;</span><br><span class="line">        stooges.add(<span class="string">&quot;Moe&quot;</span>);</span><br><span class="line">        stooges.add(<span class="string">&quot;Larry&quot;</span>);</span><br><span class="line">        stooges.add(<span class="string">&quot;Curly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStooge</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107194348592.png" class>

<p>也就是说，实现的核心是保证可变对象不变即可。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107194428126.png" class>



<h3 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107194530808.png" class>

<p><strong>final不仅保证了引用对象的不可变，还保证了不可变对象初始化过程中的线程安全性</strong>。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107194620923.png" class>

<p><u>所以说还是尽量多用final</u>。</p>
<h3 id="Volatile与不可变对象提供弱原子性"><a href="#Volatile与不可变对象提供弱原子性" class="headerlink" title="Volatile与不可变对象提供弱原子性"></a>Volatile与不可变对象提供弱原子性</h3><p>也就是这个图片中所说的：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107194428126.png" class>

<p><strong>使用volatile变量来发布不可变对象</strong>，不仅可以更新保存在不可变对象中的程序状态，还可以为一组操作提供弱原子性。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107194915104.png" class>

<p>前面的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeCachingFactorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger&gt; lastNumber = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger[]&gt; lastFactors = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req,ServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        <span class="comment">/*竞态条件*/</span></span><br><span class="line">        <span class="keyword">if</span> (i.equals(lastNumber.get())) encodeIntoResponse(resp,lastFactors.get());</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            BigInteger[] factors = factor(i);</span><br><span class="line">            <span class="comment">//时间间隔</span></span><br><span class="line">            lastNumber.set(i);</span><br><span class="line">            lastFactors.set(factors);</span><br><span class="line">            encodeIntoResponse(resp,factors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如今，利用<u>volatile和不可变类的相互配合</u>，我们修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="comment">//从使用两个分别原子的变量，变为使用一个volatile修饰的不可变类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">OneValueCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OneValueCache</span>(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req,ServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="literal">null</span>)&#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            <span class="comment">//直接new一个新容器，利用了final域在初始化过程中的线程安全，因而保证了原子性</span></span><br><span class="line">            <span class="comment">//同时也用了volatile快刷新的性质，保证了可见性，当一个线程设置为新的，其他会立即看到</span></span><br><span class="line">            <span class="comment">//妙啊，这样就非常完美地达成了线程安全性</span></span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">OneValueCache</span>(i,factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp,factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneValueCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OneValueCache</span><span class="params">(BigInteger lastNumber, BigInteger[] lastFactors)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastNumber = lastNumber;</span><br><span class="line">        <span class="comment">//传递副本，保证不可变</span></span><br><span class="line">        <span class="built_in">this</span>.lastFactors = Arrays.copyOf(lastFactors,lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="literal">null</span> || !lastNumber.equals(i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//传递副本，保证不可变</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors,lastFactors.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107195410815.png" class>

<p><u>每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据</u>，其本质就是利用不可变性消除了访问和更新多个变量的竞态条件。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107195726551.png" class>

<p>因为依然满足该程序的不变性原理：factor数组中各个数字的乘积=lastNumber，也就是说容器对象的两个值都是正确对应的，因而容器对象处于一致的状态。又或者是因为volatile及时刷新，因此确保了各个线程的内存可见性。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221107195925725.png" class>



<h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109130800775.png" class>

<p>现在，我们要来讲讲如何安全地对对象进行发布。</p>
<h3 id="一个不正确程序案例"><a href="#一个不正确程序案例" class="headerlink" title="一个不正确程序案例"></a>一个不正确程序案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Holder holder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span>&#123;	holder = <span class="keyword">new</span> <span class="title class_">Holder</span>();	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是Holder类定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(<span class="type">int</span> n)</span>&#123;	<span class="built_in">this</span>.n = n;	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assertSanity</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( n != n )	</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;This statement is false.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Holder类本身是没有问题的，这段代码出问题的原因是holder没有被正确地发布。</p>
<p>关于holder为什么没有被正确地发布：</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903890219958279">【并发编程】安全发布对象与防止对象逸出(原因与防护方法)</a></p>
<h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><p>由参考文章1：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109131429942.png" class>

<p>可知，new一个对象并非原子操作，并且很有可能先得到内存引用才初始化对象。</p>
<p>因而，在上面那段不安全代码的语境下可分析：</p>
<h5 id="Holder的错误发布有三点如下："><a href="#Holder的错误发布有三点如下：" class="headerlink" title="Holder的错误发布有三点如下："></a>Holder的错误发布有三点如下：</h5><p>首先明确，<u>引用</u>，和<u>引用的对象的状态</u>，这两个是两个需要独立考虑的方面。前者是一个指针值，后者是指针所指的数据。下面的点1仅考虑引用的更新，点2考虑了引用对象的状态更新。</p>
<p><strong>\1.</strong> 发布对象的那个线程给holder初始化之后，holder这个引用没有及时刷新到内存，因而对其他线程不可见，其他线程读到的holder引用是旧的。</p>
<p><strong>\2.</strong> 又或者，发布了holder还没初始化完毕的时候，别的进程读取到未完成初始化的holder这个引用，但这个引用指向的状态却是旧的，因为它还没完成初始化，其状态值为旧值或者默认值。【发生了上面new一个对象的指令重排】</p>
<p><strong>\3.</strong> 如果在assert方法中两次读取n发生了上面第二条，就可能会导致前后的n不唯一，抛出异常。</p>
<p>由书中表述，如果<strong>将Holder转化为不可变类</strong>，那么该发布是安全的。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109132022027.png" class>

<p>至于为什么，可见下个标题。</p>
<blockquote>
<p><strong>此处插入思考</strong>：是否可以将<code>public Holder holder</code>修改为<code>public final Holder holder</code>，或者volatile修饰，来解决上述问题呢？</p>
<p><a href="http://www.qb5200.com/article/359649.html">java多线程关键字final和static详解</a></p>
<p>通过看该文章得知：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109132352737.png" class>

<p><strong>volatile和final都会禁止字段引用的对象在构造对象过程中发生指令重排</strong>，别的线程得到引用的时候构造已经完成，而不会先得到引用再完成构造，并且两个标志都可以保证可见性。</p>
<p>不过继续读下去，书中给出了答案：我说的这个方法也是<strong>可行</strong>的。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109132548021.png" class>

<p>我的疑问就是第二点和第三点。</p>
</blockquote>
<h3 id="不可变对象的初始化安全性"><a href="#不可变对象的初始化安全性" class="headerlink" title="不可变对象的初始化安全性"></a>不可变对象的初始化安全性</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109132717706.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109132738240.png" class>



<h3 id="安全发布的常用模式"><a href="#安全发布的常用模式" class="headerlink" title="安全发布的常用模式"></a>安全发布的常用模式</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109132832943.png" class>

<p>分别解说</p>
<h4 id="静态初始化对象引用"><a href="#静态初始化对象引用" class="headerlink" title="静态初始化对象引用"></a>静态初始化对象引用</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109132929110.png" class>

<h4 id="volatile、final以及AtomicReferance保护引用"><a href="#volatile、final以及AtomicReferance保护引用" class="headerlink" title="volatile、final以及AtomicReferance保护引用"></a>volatile、final以及AtomicReferance保护引用</h4><p>详见上面那个不正确案例最后的思考</p>
<h4 id="由锁保护的区域"><a href="#由锁保护的区域" class="headerlink" title="由锁保护的区域"></a>由锁保护的区域</h4><p>这个区域除了是通过程序构造的，也可以是<strong>使用Java自带的线程安全类库</strong>。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109133120493.png" class>



<h3 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h3><p><u>安全发布可以保证发布时的线程安全</u>。<strong>所以说你如果承诺发布后可以一直保证不可变，那就一直都是线程安全的。</strong></p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109133235142.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109133251948.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109133314863.png" class>



<h3 id="对象的可变性与正确发布"><a href="#对象的可变性与正确发布" class="headerlink" title="对象的可变性与正确发布"></a>对象的可变性与正确发布</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109133403869.png" class>



<h3 id="安全地共享对象"><a href="#安全地共享对象" class="headerlink" title="安全地共享对象"></a>安全地共享对象</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221109133444191.png" class>



<h1 id="第四章-对象的组合"><a href="#第四章-对象的组合" class="headerlink" title="第四章  对象的组合"></a>第四章  对象的组合</h1><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112203702550.png" class>

<p>也就是说上面都是在讲怎么让一个对象的共享变得安全，下面我们讲怎么依据设计模式，让一个类更容易成为线程安全的</p>
<h2 id="如何设计线程安全的类"><a href="#如何设计线程安全的类" class="headerlink" title="如何设计线程安全的类"></a>如何设计线程安全的类</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112203853654.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112204009839.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112204035468.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112204050006.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112204127325.png" class>



<h3 id="收集同步需求"><a href="#收集同步需求" class="headerlink" title="收集同步需求"></a>收集同步需求</h3><h4 id="本质上是找不变性条件和后验条件"><a href="#本质上是找不变性条件和后验条件" class="headerlink" title="本质上是找不变性条件和后验条件"></a>本质上是找不变性条件和后验条件</h4><p>要保证不变性条件始终成立，确保后验条件符合预期。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112204358000.png" class>

<p>讲了什么是不变性条件和后验条件：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112204436442.png" class>



<p><strong>无效的状态转换只能出现在原子序列中</strong></p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112204529641.png" class>



<h3 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112204751892.png" class>

<p>也就是说先验条件和状态域相关。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112204935339.png" class>



<h3 id="状态的所有权"><a href="#状态的所有权" class="headerlink" title="状态的所有权"></a>状态的所有权</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112205020647.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112205120608.png" class>

<p>666666</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112205137533.png" class>



<h2 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h2><h3 id="什么是实例封闭"><a href="#什么是实例封闭" class="headerlink" title="什么是实例封闭"></a>什么是实例封闭</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112205253662.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112205402333.png" class>

<p>所以需要上一章学的安全发布。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112205642126.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过封闭机制保证线程安全</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonSet</span> &#123;</span><br><span class="line">    <span class="comment">//不安全</span></span><br><span class="line">    <span class="comment">//封闭在实例内部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Person&gt; mySet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对所有代码路径加锁访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addPerson</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">        mySet.add(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">containsPerson</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySet.contains(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112205737505.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112205827098.png" class>

<p>阅读源码可知：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SynchronizedCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt;, Serializable &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3053995032091335093L</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> Collection&lt;E&gt; c;  <span class="comment">// Backing Collection</span></span><br><span class="line">     <span class="keyword">final</span> Object mutex;     <span class="comment">// Object on which to synchronize</span></span><br><span class="line"></span><br><span class="line">     SynchronizedCollection(Collection&lt;E&gt; c) &#123;</span><br><span class="line">         <span class="built_in">this</span>.c = Objects.requireNonNull(c);</span><br><span class="line">         mutex = <span class="built_in">this</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) &#123;</span><br><span class="line">         <span class="built_in">this</span>.c = Objects.requireNonNull(c);</span><br><span class="line">         <span class="built_in">this</span>.mutex = Objects.requireNonNull(mutex);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.size();&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.isEmpty();&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.contains(o);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.toArray();&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.toArray(a);&#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意此处没用同步</span></span><br><span class="line">     <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> c.iterator(); <span class="comment">// Must be manually synched by user!</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.add(e);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.remove(o);&#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; coll)</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.containsAll(coll);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.addAll(coll);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; coll)</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.removeAll(coll);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; coll)</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.retainAll(coll);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;c.clear();&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.toString();&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// Override default methods in Collection</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;c.forEach(consumer);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.removeIf(filter);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> c.spliterator(); <span class="comment">// Must be manually synched by user!</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> c.stream(); <span class="comment">// Must be manually synched by user!</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> c.parallelStream(); <span class="comment">// Must be manually synched by user!</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;s.defaultWriteObject();&#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>就是把原来的collection给实例封闭了，之后的访问都用了同步锁。</p>
<h3 id="Java监视器模式"><a href="#Java监视器模式" class="headerlink" title="Java监视器模式"></a>Java监视器模式</h3><h4 id="使用内置锁"><a href="#使用内置锁" class="headerlink" title="使用内置锁"></a>使用内置锁</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112210412251.png" class>

<p>直白点来说，就是把所有要访问自己状态的地方/方法通通synchronized。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112210529548.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监视器模式</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span>  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">increment</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == Long.MAX_VALUE)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样虽然简单，但缺点就是很粗暴：同步的粒度太粗了。</p>
<h4 id="使用私有锁"><a href="#使用私有锁" class="headerlink" title="使用私有锁"></a>使用私有锁</h4><p>也跟内置锁道理差不多</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112210707212.png" class>

<p>也就是说私有锁可以让外面的世界也参与到同步中来，但内置锁不大行。</p>
<h3 id="示例：车辆追踪"><a href="#示例：车辆追踪" class="headerlink" title="示例：车辆追踪"></a>示例：车辆追踪</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutablePoint</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x,y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MutablePoint</span><span class="params">()</span> &#123;</span><br><span class="line">        x=<span class="number">0</span>;y=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MutablePoint</span><span class="params">(MutablePoint p)</span>&#123;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="built_in">this</span>.x=p.x;</span><br><span class="line">        <span class="built_in">this</span>.y=p.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于监视器模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorVehicleTracker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MutablePoint&gt; locations;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MonitorVehicleTracker</span><span class="params">(</span></span><br><span class="line"><span class="params">            Map&lt;String,MutablePoint&gt; locations</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.locations = deepCopy(locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Map&lt;String,MutablePoint&gt; <span class="title function_">getLocations</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deepCopy(locations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> MutablePoint <span class="title function_">getLocation</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        <span class="type">MutablePoint</span> <span class="variable">loc</span> <span class="operator">=</span> locations.get(id);</span><br><span class="line">        <span class="comment">//返回copy对象，深拷贝</span></span><br><span class="line">        <span class="keyword">return</span> loc == <span class="literal">null</span>?<span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">MutablePoint</span>(loc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setLocation</span><span class="params">(String id,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">MutablePoint</span> <span class="variable">loc</span> <span class="operator">=</span> locations.get(id);</span><br><span class="line">        <span class="keyword">if</span> (loc == <span class="literal">null</span>)    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        loc.x = x;</span><br><span class="line">        loc.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为什么这方法不用锁？是因为调用它的地方都锁着</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,MutablePoint&gt; <span class="title function_">deepCopy</span><span class="params">(Map&lt;String,MutablePoint&gt; m)</span>&#123;</span><br><span class="line">        Map&lt;String,MutablePoint&gt; res = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry en : m.entrySet())&#123;</span><br><span class="line">            <span class="comment">//此处通过MutablePoint的构造函数重新拷贝了一个Point</span></span><br><span class="line">            <span class="comment">//如果简单地使用HashMap的构造函数new HashMap(m)的拷贝来创建一个新的map是不行的</span></span><br><span class="line">            <span class="comment">//因为这样只会拷贝Point对象的指针值，依然是浅拷贝</span></span><br><span class="line">            res.put((String) en.getKey(),<span class="keyword">new</span> <span class="title class_">MutablePoint</span>((MutablePoint) en.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112211040741.png" class>



<h2 id="将线程安全性委托给独立的状态变量"><a href="#将线程安全性委托给独立的状态变量" class="headerlink" title="将线程安全性委托给独立的状态变量"></a>将线程安全性委托给独立的状态变量</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112214828113.png" class>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112211131280.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112211228101.png" class>

<p>意思就是<strong>保证一个类里面仅有一个状态，只要该状态是线程安全的，那么该类也就是线程安全的</strong>。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> x,y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将线程安全委托给ConcurrentMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingVehicleTracker</span> &#123;</span><br><span class="line">    <span class="comment">//用了两个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String,Point&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,Point&gt; unmodifiableMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DelegatingVehicleTracker</span><span class="params">(Map&lt;String,Point&gt; ps)</span> &#123;</span><br><span class="line">        locations = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(ps);</span><br><span class="line">        unmodifiableMap = Collections.unmodifiableMap(locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Point&gt; <span class="title function_">getLocations</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//unmodifiableMap baked by locations,所以locations变化也会反映到unmodifiableMap上</span></span><br><span class="line">        <span class="comment">//目的只是为了提供外界无法修改的视图</span></span><br><span class="line">        <span class="comment">//不得不说真是妙啊</span></span><br><span class="line">        <span class="keyword">return</span> unmodifiableMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">getLocation</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> locations.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLocation</span><span class="params">(String id,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (locations.replace(id,<span class="keyword">new</span> <span class="title class_">Point</span>(x,y)) == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112212146973.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112212300760.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String,Point&gt; <span class="title function_">getLocations</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(locations));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="委托给多个状态变量"><a href="#委托给多个状态变量" class="headerlink" title="委托给多个状态变量"></a>委托给多个状态变量</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112213102179.png" class>

<p>也就是说这些对象彼此不会构成不变性条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将线程安全性委托给多个状态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisualComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;KeyListener&gt; keyListeners = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MouseListener&gt; mouseListeners = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addKeyListener</span><span class="params">(KeyListener listener)</span>&#123;</span><br><span class="line">        keyListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMouseListener</span><span class="params">(MouseListener listener)</span>&#123;</span><br><span class="line">        mouseListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeKeyListener</span><span class="params">(KeyListener listener)</span>&#123;</span><br><span class="line">        keyListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remiveMouseListener</span><span class="params">(MouseListener listener)</span>&#123;</span><br><span class="line">        mouseListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112214037284.png" class>

<p>而且键盘监听和鼠标监听彼此独立。</p>
<h3 id="不独立多个状态变量不能委托"><a href="#不独立多个状态变量不能委托" class="headerlink" title="不独立多个状态变量不能委托"></a>不独立多个状态变量不能委托</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberRange</span> &#123;</span><br><span class="line">    <span class="comment">//不变性条件： lower&lt;=upper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">lower</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">upper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLower</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="comment">//先检查后执行</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;upper.get())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        lower.set(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUpper</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;lower.get())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        upper.set(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInRange</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i&gt;=lower.get() &amp;&amp; i&lt;=upper.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112214638690.png" class>

<p>根本原因就是因为不独立。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112214728158.png" class>



<h3 id="发布被委托的状态变量"><a href="#发布被委托的状态变量" class="headerlink" title="发布被委托的状态变量"></a>发布被委托的状态变量</h3><h4 id="什么时候可以发布"><a href="#什么时候可以发布" class="headerlink" title="什么时候可以发布"></a>什么时候可以发布</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112215241300.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112215257481.png" class>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112220857295.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sit;</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafePoint</span> &#123;</span><br><span class="line">    <span class="comment">//注意此处x和y没有用任何同步修饰词修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SafePoint</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(a[<span class="number">0</span>],a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处为什么不直接用this(p.x,p.y)呢？</span></span><br><span class="line">    <span class="comment">//是因为x和y本身并没有任何线程安全的防护手段，这样做的话会发生竞态条件。况且x和y也被实例封闭了</span></span><br><span class="line">    <span class="comment">//私有构造函数捕获模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafePoint</span><span class="params">(SafePoint p)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(p.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">SafePoint</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x=x;</span><br><span class="line">        <span class="built_in">this</span>.y=y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x、y都放入数组，保证x和y的同时读写，nb</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span>[] get()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x=x;</span><br><span class="line">        <span class="built_in">this</span>.y=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跟上面那个委托没什么差，区别只在于上面的那个SafePoint类，既是线程安全的，又是可修改的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublishingVehicleTracker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,SafePoint&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,SafePoint&gt; unmodifiableMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PublishingVehicleTracker</span><span class="params">(Map&lt;String,SafePoint&gt; locations)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.locations = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(locations);</span><br><span class="line">        <span class="built_in">this</span>.unmodifiableMap = Collections.unmodifiableMap(<span class="built_in">this</span>.locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,SafePoint&gt; <span class="title function_">getLocations</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unmodifiableMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SafePoint <span class="title function_">getLocation</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> locations.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLocations</span><span class="params">(String id,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!locations.containsKey(id))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        locations.get(id).set(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112221016278.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112221511655.png" class>

<p>这仅仅是一个委托发布的实例。</p>
<h2 id="在现有的线程安全类中添加功能"><a href="#在现有的线程安全类中添加功能" class="headerlink" title="在现有的线程安全类中添加功能"></a>在现有的线程安全类中添加功能</h2><h3 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112221938081.png" class>

<p>比如说想给vector添加一个“put-if-absent”</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112222013827.png" class>

<p>可以用子类扩展法，也可以直接加源代码。后者有时候源代码不可访问，前者的父类很多域可能不对子类开发，并且非常脆弱。因而下面介绍几种比较好的机制。</p>
<h3 id="客户端加锁机制"><a href="#客户端加锁机制" class="headerlink" title="客户端加锁机制"></a>客户端加锁机制</h3><h4 id="定义和实例"><a href="#定义和实例" class="headerlink" title="定义和实例"></a>定义和实例</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112222209818.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotThreadSafeListHelper</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">putIfAbsent</span><span class="params">(E x)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">absent</span> <span class="operator">=</span> !list.contains(x);</span><br><span class="line">        <span class="keyword">if</span> (absent)</span><br><span class="line">            list.add(x);</span><br><span class="line">        <span class="keyword">return</span> absent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112222531751.png" class>

<p>我曹，66666666</p>
<p>也就是说，这里加的是ListHelper的锁，只能让别的线程不能通过putIfAbsent方法同时修改list，但别的线程完全可以直接获取list再修改。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112223055129.png" class>

<p>客户端指的是我们的ListHelper。我们正是不知道list这个对象使用的是哪一个锁才发愣的。</p>
<p>所以我们使用ArrayList自身的锁，也就是list自己的内置，来加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用客户端加锁实现</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListHelper</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putIfAbsent</span><span class="params">(E x)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(list) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">absent</span> <span class="operator">=</span> !list.contains(x);</span><br><span class="line">            <span class="keyword">if</span> (absent)</span><br><span class="line">                list.add(x);</span><br><span class="line">            <span class="keyword">return</span> absent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112223253272.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112223308479.png" class>

<p>它非常依赖于其他类的客户端加锁机制。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112223346242.png" class>

<p>确实，毕竟你锁被外界拿去用了。</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112223451927.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImprovedList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//实例封闭</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImprovedList</span><span class="params">(List&lt;T&gt; list)</span>&#123;<span class="built_in">this</span>.list=list;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">putIfAbsent</span><span class="params">(T x)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> list.contains(x);</span><br><span class="line">        <span class="keyword">if</span> (contains)</span><br><span class="line">            list.add(x);</span><br><span class="line">        <span class="keyword">return</span> !contains;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;list.clear();&#125;</span><br><span class="line">    <span class="comment">//... 按照类似的方式委托List接口其他未实现的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112223906893.png" class>

<p>是的，跟synchronizedList非常像</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221112224015303.png" class>

<p>这也就是用的java的监视器模式了</p>
<h1 id="第五章-基础构建模块"><a href="#第五章-基础构建模块" class="headerlink" title="第五章  基础构建模块"></a>第五章  基础构建模块</h1><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119163644159.png" class>

<p>保证独立即可委托，从而构建一个线程安全类</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119163713258.png" class>

<h2 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119163731417.png" class>

<p>差不多都是使用的监视器模式。</p>
<p>同步容器类：Vector、Hashtable、Collections.synchronizedXxx</p>
<h3 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119163802519.png" class>

<p>也就是需要避免两个原子操作之间的非线程安全的时间间隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getLast</span><span class="params">(Vector list)</span>&#123;</span><br><span class="line">       <span class="comment">//复合操作</span></span><br><span class="line">       <span class="comment">//先检查后执行</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteLast</span><span class="params">(Vector list)</span>&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;</span><br><span class="line">           list.remove(lastIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119163906029.png" class>

<p>它这段话说得非常好。<strong>由于Vector这个类本身是线程安全的，因而它可以保证外部任何操作都不会导致该对象因为并发而被破坏</strong>。但是，我们用不加锁的复合操作虽然不会破坏Vector，但可能导致不能出现我们想要的结果。</p>
<p>所以我们必须用锁机制来对此复合操作进行保护：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getLast</span><span class="params">(Vector list)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="comment">//复合操作</span></span><br><span class="line">        <span class="comment">//先检查后执行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteLast</span><span class="params">(Vector list)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;</span><br><span class="line">        list.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，<u>迭代也是一种经典的复合操作</u>。我们可以通过下面这种粗粒度加锁来避免：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">(Vector list)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="迭代器与ConcurrentModificationException"><a href="#迭代器与ConcurrentModificationException" class="headerlink" title="迭代器与ConcurrentModificationException"></a>迭代器与ConcurrentModificationException</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119164546375.png" class>

<p>所以才会引入fail-fast机制。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119171630079.png" class>

<blockquote>
<p>foreach语法糖内部是通过Iterator来实现的。</p>
<p><a href="https://blog.csdn.net/u012745499/article/details/114747228">Java 的 foreach 本质</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIterableForEach</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反编译后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIterableForEach</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(i.hashNext())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)i.next();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119172040649.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119172052035.png" class>

<p>可见同步容器类还是有很多局限性的。</p>
<h3 id="隐藏迭代器"><a href="#隐藏迭代器" class="headerlink" title="隐藏迭代器"></a>隐藏迭代器</h3><p>有时候，迭代会隐藏起来。要一个个揪出需要加锁的地方是非常麻烦的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//隐藏在字符串连接中的迭代操作</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiddenIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer i)</span>&#123;    set.add(i); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Integer i)</span>&#123; set.remove(i);  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTenThings</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            add(r.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//隐式迭代</span></span><br><span class="line">        System.out.println(<span class="string">&quot;DEBUG: Added ten elements to &quot;</span>+ set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119190630312.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119190917620.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119190929046.png" class>



<h2 id="并发容器类"><a href="#并发容器类" class="headerlink" title="并发容器类"></a>并发容器类</h2><p>同步容器类的加锁太粗粒度了，导致并发性弱。因而引入并发容器类来解决问题。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119191147301.png" class>

<p>ConcurrentHashMap —— HashMap</p>
<p>CopyOnWriteArrayList —— List</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119191235595.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119191308182.png" class>

<p>BlockingQueue</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119191324306.png" class>

<p>ConcurrentSkipListMap —— TreeMap</p>
<p>ConcurrentSkipListSet  ——  TreeSet</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119202234992.png" class>

<p>使用分段锁来细粒度加锁。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119202329557.png" class>

<blockquote>
<p>关于ConcurrentHashMap的分段锁：<a href="https://blog.csdn.net/fengyuyeguirenenen/article/details/125204199">ConcurrentHashMap</a></p>
<p>JDK1.7中，ConcurrentHashMap 类所采用的正是分段锁的思想，将 HashMap 进行切割，把 HashMap 中的哈希数组切分成小数组，每个小数组有 n 个 HashEntry 组成，其中小数组继承自<code>ReentrantLock（可重入锁）</code>，这个小数组名叫<code>Segment</code>。</p>
<p>JDK1.8 中 ConcurrentHashMap 类取消了 Segment 分段锁，采用 <code>CAS</code> + <code>synchronized</code> 来保证并发安全，数据结构跟 jdk1.8 中 HashMap 结构类似，都是<strong>数组 + 链表（当链表长度大于 8 时，链表结构转为红黑二叉树</strong>）结构。</p>
<p>ConcurrentHashMap 中 synchronized 只锁定当前链表或红黑二叉树的首节点，只要节点 <a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a> 不冲突，就不会产生并发，相比 JDK1.7 的 ConcurrentHashMap 效率又提升了 N 倍！</p>
</blockquote>
<blockquote>
<p>关于ConcurrentHashMap的弱一致性：<a href="https://developer.aliyun.com/article/802743">ConcurrentHashMap的弱一致性</a></p>
<p>get方法是弱一致的，是什么含义？可能你期望往ConcurrentHashMap底层数据结构中加入一个元素后，立马能对get可见，但ConcurrentHashMap并不能如你所愿。换句话说，put操作将一个元素加入到底层数据结构后，get可能在某段时间内还看不到这个元素，若不考虑内存模型，单从代码逻辑上来看，却是应该可以看得到的。</p>
</blockquote>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119203312221.png" class>

<p>精确值—&gt;估计值</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119203355005.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119203415659.png" class>

<blockquote>
<p>关于AQS框架：<a href="https://www.cnblogs.com/yidengjiagou/p/16872787.html">重大发现，AQS加锁机制竟然跟Synchronized有惊人的相似</a></p>
<p>在并发多线程的情况下，为了保证数据安全性，一般我们会对数据进行加锁，通常使用<strong>Synchronized</strong>或者<strong>ReentrantLock</strong>同步锁。<strong>Synchronized</strong>是基于JVM实现，而<strong>ReentrantLock</strong>是基于Java代码层面实现的，底层是继承的<strong>AQS</strong>。</p>
<p><strong>AQS</strong>全称**<code>AbstractQueuedSynchronizer</code>**，即抽象队列同步器，是一种用来构建锁和同步器的框架。</p>
<p>我们常见的并发锁<strong>ReentrantLock</strong>、<strong>CountDownLatch</strong>、<strong>Semaphore</strong>、<strong>CyclicBarrier</strong>都是基于<strong>AQS</strong>实现的，所以说不懂<strong>AQS</strong>实现原理的，就不能说了解Java锁。</p>
</blockquote>
<blockquote>
<p>并发容器类不能实现独占访问：</p>
<p>类似ConcurrentHashMap的并发容器不能采用客户端加锁机制，因为并发容器<strong>没有采用synchronized内置锁</strong>而大多基于AQS框架（不是独占式的锁），所以使用客户端加锁机制来扩展并发容器的方法是不能实现的。 </p>
<p>所以说不能客户端加锁不是不提倡，而是真的不行【】</p>
</blockquote>
<p><strong>所以最好还是用并发容器类替代同步容器类</strong>。</p>
<h3 id="对部分复合操作的支持"><a href="#对部分复合操作的支持" class="headerlink" title="对部分复合操作的支持"></a>对部分复合操作的支持</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119203521971.png" class>

<p>客户端加锁不能使用，就只能用它提供的东西了。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p><code>Copy-On-Write</code>意为“写入时复制”，仅当要修改的时候，才会重新创建一次副本，实现可变性。犹记得第一次接触到这个思想是在操作系统的fork()创建子进程的原理那个地方，那可真是有些惊为天人23333</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119204509455.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119204539700.png" class>

<p>也就是说，COWAL内部维护的base数组是事实不可变的，因而访问它的时候不需要同步。但是，我们事实上需要一个可变的并发容器，那该怎么办呢？解决方法就是每次要修改的时候，直接把base数组换成一个新的数组，就像之前某个例子一样，这样就能实现可变性了。</p>
<p>与此同时，这样的方法也能保证多线程访问时的内存可见性。</p>
<p>由COWAL的底层代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//base数组，volatile保证引用一变就可以刷新</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">        array = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//getArray:直接返回base数组的引用</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">//创建新数组再修改</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//直接改变base数组的引用</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，它保证可见性，<strong>是直接修改引用的</strong>，并且注意，<strong>对原数组的拷贝是浅拷贝的</strong>。这样一来，就既不会改变原数组的东西，也能保证可见性的更新迅速了。我的评价是牛逼爆了。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119205630359.png" class>



<h2 id="阻塞队列和生产者—消费者模式"><a href="#阻塞队列和生产者—消费者模式" class="headerlink" title="阻塞队列和生产者—消费者模式"></a>阻塞队列和生产者—消费者模式</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119210711439.png" class>

<p>简直就是为了生产者消费者而生的</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119210747830.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119221409722.png" class>

<p>这两段话说得非常本质，需要有个缓冲队列本质上就是因为处理数据速率的不同，生产者消费者也起到了解耦作用</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119215627731.png" class>

<p>所以说用有界队列还是更好</p>
<p>BlockingQueue有多种实现。</p>
<p>ArrayBlockingQueue和LinkedBlockingQueue是FIFO队列，PriorityBlockingQueue是优先队列，最后还有一个特殊的SynhronousQueue。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119215927307.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119215942352.png" class>



<h3 id="实例：桌面搜索"><a href="#实例：桌面搜索" class="headerlink" title="实例：桌面搜索"></a>实例：桌面搜索</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119221256910.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCrawler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingDeque&lt;File&gt; fileQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileFilter fileFilter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileCrawler</span><span class="params">(BlockingDeque&lt;File&gt; fileQueue, FileFilter fileFilter, File root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fileQueue = fileQueue;</span><br><span class="line">        <span class="built_in">this</span>.fileFilter = fileFilter;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            crawl(root);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//中断处理</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">crawl</span><span class="params">(File root)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        File[] entries = root.listFiles(fileFilter);</span><br><span class="line">        <span class="keyword">if</span> (entries!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (File entry:entries)&#123;</span><br><span class="line">                <span class="comment">//递归打印目录</span></span><br><span class="line">                <span class="keyword">if</span> (entry.isDirectory())    crawl(entry);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!alreadyIndexed(entry))    fileQueue.put(entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Indexer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingDeque&lt;File&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Indexer</span><span class="params">(BlockingDeque&lt;File&gt; q)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.queue=q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                indexFile(queue.take());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119221315897.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119221540919.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启动生产者-消费者程序</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startIndexing</span><span class="params">(File[] roots)</span>&#123;</span><br><span class="line">       BlockingDeque&lt;File&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(BOUND);</span><br><span class="line">       <span class="type">FileFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileFilter</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (File root : roots)&#123;</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FileCrawler</span>(queue,filter,root)).start();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N_CONSUMERS;i++)&#123;</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Indexer</span>((queue))).start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="串行线程封闭"><a href="#串行线程封闭" class="headerlink" title="串行线程封闭"></a>串行线程封闭</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119221744613.png" class>

<p>安全发布</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119221806125.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119221900918.png" class>

<p>6666666</p>
<p>之所以叫“串行”，想必是因为这个过程：发布-转接-放弃访问权是一个串行过程。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119221943793.png" class>



<p>总而言之，串行线程封闭的具体做法就是，一个线程将一个安全发布的对象的所有权完全转移给另一个线程，保证之后自己不会再使用。这样一来，该对象就相当于被另一个线程封闭了。而如何保证“自己以后不再使用”呢？最简单的方法就是<strong>安全发布</strong>完这个东西后直接把这个东西给<strong>踢出去</strong>。</p>
<p>阻塞队列是自动会把这个东西安全发布然后就踢出去的，所以说阻塞队列简化了这个工作。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119221958208.png" class>



<h3 id="双端队列与工作密取"><a href="#双端队列与工作密取" class="headerlink" title="双端队列与工作密取"></a>双端队列与工作密取</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119223533465.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221119223546716.png" class>



<h2 id="阻塞方法与中断方法"><a href="#阻塞方法与中断方法" class="headerlink" title="阻塞方法与中断方法"></a>阻塞方法与中断方法</h2><h3 id="阻塞方法"><a href="#阻塞方法" class="headerlink" title="阻塞方法"></a>阻塞方法</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121191104345.png" class>

<p>当某方法抛出InterruptedException时，表明该方法为阻塞方法，也即这个方法会在执行过程中由于各种原因而被阻塞。如果这个方法被中断，它将会努力提前结束阻塞状态。</p>
<h3 id="中断方法"><a href="#中断方法" class="headerlink" title="中断方法"></a>中断方法</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121191250778.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121191328110.png" class>

<h3 id="处理InterruptedException的两种选择"><a href="#处理InterruptedException的两种选择" class="headerlink" title="处理InterruptedException的两种选择"></a>处理InterruptedException的两种选择</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121191349835.png" class>

<h4 id="传递InterruptedException"><a href="#传递InterruptedException" class="headerlink" title="传递InterruptedException"></a>传递InterruptedException</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121191456581.png" class>

<h4 id="恢复中断"><a href="#恢复中断" class="headerlink" title="恢复中断"></a>恢复中断</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121191520346.png" class>

<blockquote>
<p>此处关于为什么如果代码是Runnable的一部分就不能抛出异常：</p>
<p>是因为java的异常继承体系。</p>
<p>在重写的run方法中,我们只能够进行异常的捕获而不能够抛出异常,原因是因为在父类Runnable接口中,run方法没有抛出异常,则实现Runnable的子类就无法抛出异常</p>
<p>所以实际上是语法层面上不允许。</p>
</blockquote>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121191708397.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121191728634.png" class>



<h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121191810990.png" class>

<p>实现同步的方法：使用同步容器类/并发容器类、使用锁、使用同步工具类</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121192438624.png" class>



<h3 id="闭锁-CountDownLatch"><a href="#闭锁-CountDownLatch" class="headerlink" title="闭锁 CountDownLatch"></a>闭锁 CountDownLatch</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121192535333.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121192555787.png" class>



<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121192630679.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用CountDownLatch来进行计时测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHarness</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">timeTasks</span><span class="params">(<span class="type">int</span> nThreads,<span class="keyword">final</span> Runnable task)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="comment">//初始化计数器为1</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">startGate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">endGate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(nThreads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        startGate.await();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            task.run();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            endGate.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">//所有线程刷拉拉往下走</span></span><br><span class="line">        startGate.countDown();</span><br><span class="line">        <span class="comment">//等待所有线程结束</span></span><br><span class="line">        endGate.await();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">return</span> end-start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121192901165.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121192926252.png" class>

<p>是的，这样测试出来的时间应该更加平均，性能更加准确。</p>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121193032281.png" class>

<blockquote>
<p><a href="https://www.bilibili.com/video/BV1QF411T7tu/">java的future机制原理</a></p>
<p>关于Future：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121193544175.png" class>

<p>其中get方法是阻塞的。</p>
<p>获取异步任务执行完后的结果。</p>
<p>关于FutureTask：</p>
<p>FutureTask既包含了Future的语义，又包含了Runnable的语义。</p>
<p>它其实内部封装了一个Runnable Task。调用FutureTask的run，其实本质上就是调用Task的run，只不过要多一些检查和存储结果之类的手续。</p>
<p>所以说它其实就是通过内部封装一个线程，然后就能获取这个线程运行的状态和运行的结果等等等，这样来实现Future语义的。</p>
</blockquote>
<blockquote>
<p>关于Callable</p>
<p>Runnable里面的run方法是不能传参，也没有返回值的。Callable相当于有返回值的Runnable，也即书中说的“有生成结果的Runnable”。</p>
</blockquote>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121193917574.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121194051035.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Preloader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;ProductInfo&gt; future =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;ProductInfo&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;ProductInfo&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> ProductInfo <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> loadProductInfo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(future);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;thread.start();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProductInfo <span class="title function_">get</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> DataLoadException,InterruptedException&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//阻塞</span></span><br><span class="line">            <span class="keyword">return</span> future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> DataLoadException)</span><br><span class="line">                <span class="keyword">throw</span> (DataLoadException) cause;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> launderThrowable(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title function_">launderThrowable</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException)</span><br><span class="line">            <span class="keyword">return</span> (RuntimeException) t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Not checked.&quot;</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121194254226.png" class>

<p>也就是调用start线程启动后，可以就去做别的事情，回来就可以拿到结果了，通过这样实现异步调用。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121194423118.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121194431458.png" class>

<p>这里其实是在讲异常的事了。可以给我们一个启发式思路：</p>
<p>Callable抛出的Exception这种抽象的异常集合该如何分解处理：<strong>首先分解出受检查的异常</strong>【也就是说我们调用该方法就知道该方法可能会抛出的异常】，<strong>然后针对其他未检查异常，再进行处理</strong>。此例中是把这些未检查异常分成了Error和RuntimeException。</p>
<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量  Semaphore"></a>信号量  Semaphore</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121195739093.png" class>

<blockquote>
<p>注意</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121195919749.png" class>
</blockquote>
<p>这种情况下，其实信号量跟BlockingQueue语义十分近似：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121195806397.png" class>

<p>信号量还可以用来将非阻塞容器包装为<strong>有界阻塞容器</strong>。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121195832306.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121195859137.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用信号量为容器设置边界,有界+阻塞</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedHashSet</span> &lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">//baked collection，同步容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line">    <span class="comment">//信号量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BoundedHashSet</span><span class="params">(<span class="type">int</span> bound)</span>&#123;</span><br><span class="line">        <span class="comment">//同步容器类</span></span><br><span class="line">        <span class="built_in">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">//初始化许可数</span></span><br><span class="line">        sem = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(bound);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(T e)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="comment">//获取许可</span></span><br><span class="line">        sem.acquire();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//由于是同步容器类，故而不用使用锁来保护状态</span></span><br><span class="line">            wasAdded=set.add(e);</span><br><span class="line">            <span class="keyword">return</span> wasAdded;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//try捕获异常/正常return后，finally语句都会执行。</span></span><br><span class="line">            <span class="keyword">if</span> (!wasAdded)</span><br><span class="line">                sem.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasRemoved</span> <span class="operator">=</span> set.remove(o);</span><br><span class="line">        <span class="keyword">if</span> (wasRemoved)</span><br><span class="line">            sem.release();</span><br><span class="line">        <span class="keyword">return</span> wasRemoved;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：try语句块正常return后，finally语句依然会执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     System.out.println(haha());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">haha</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;main!&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> number++;</span><br><span class="line">     &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;come!&quot;</span>+number);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">main!</span></span><br><span class="line"><span class="comment">come!11</span></span><br><span class="line"><span class="comment">10*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="栅栏-Barrier"><a href="#栅栏-Barrier" class="headerlink" title="栅栏  Barrier"></a>栅栏  Barrier</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121201042970.png" class>

<p>闭锁是某个事件发生后所有线程才能继续执行；栅栏是所有线程都在同样位置等待才能继续执行。</p>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121201229274.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121201246054.png" class>

<p>一个线程寄了，其他所有等待线程都会死。</p>
<p>栅栏我觉得一个很重要的点就是保证并发安全。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121201328760.png" class>

<p>常常出现那种需要等待所有线程都完成某一步操作才能进行下一步操作的情况，所以栅栏不得不说非常实用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CellularAutomata</span> &#123;</span><br><span class="line">    <span class="comment">//细胞板</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Board mainBoard;</span><br><span class="line">    <span class="comment">//栅栏</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line">    <span class="comment">//计算线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker[] workers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CellularAutomata</span><span class="params">(Board board)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mainBoard = board;</span><br><span class="line">        <span class="comment">//所有可调度的CPU都被拉过来了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">  		<span class="comment">//当所有线程到达栅栏后，马上执行该run方法：提交计算得出的新值</span></span><br><span class="line">        <span class="built_in">this</span>.barrier = <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(count,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        mainBoard.commitNewValues();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">//创建工作线程池</span></span><br><span class="line">        <span class="built_in">this</span>.workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            <span class="comment">//分治，把大的细胞板划分成多个小细胞板处理</span></span><br><span class="line">            workers[i] = <span class="keyword">new</span> <span class="title class_">Worker</span>(mainBoard,getSubBoard(count,i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span>  <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">final</span> Board board;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Board board)</span>&#123;<span class="built_in">this</span>.board = board;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!board.hasConverged())&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; board.getMaxX(); x++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; board.getMaxY(); y++)</span><br><span class="line">                        <span class="comment">//为二维细胞板上每个点计算新值</span></span><br><span class="line">                        board.setNewValue(x,y,computeValue(x,y));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//计算完之后等待其它线程也计算完</span></span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workers.length; i++)</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(workers[i]).start();</span><br><span class="line">        mainBoard.waitForConvergence();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121201756450.png" class></p>
<p>的目的</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121201822846.png" class>
</blockquote>
<h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121210919384.png" class>

<p>这个“写满”大概对应着栅栏思想里的“全部到达”</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121211001697.png" class>



<h2 id="示例：构建高效且可伸缩的结果缓存"><a href="#示例：构建高效且可伸缩的结果缓存" class="headerlink" title="示例：构建高效且可伸缩的结果缓存"></a>示例：构建高效且可伸缩的结果缓存</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121211107957.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121211128730.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Computable</span> &lt;A,V&gt;&#123;</span><br><span class="line">    V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;String, BigInteger&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigInteger <span class="title function_">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//经过长时间的计算后</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用内置锁对方法进行上锁"><a href="#用内置锁对方法进行上锁" class="headerlink" title="用内置锁对方法进行上锁"></a>用内置锁对方法进行上锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//感受一下cache也是Computable的这个多态运用的巧妙性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memoizer1</span>&lt;A,V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A,V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A,V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A,V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memoizer1</span><span class="params">(Computable&lt;A,V&gt; c)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.c=c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对整个方法体进行上锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>)&#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg,result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保证了线程安全，但是可伸缩性极差，而且很有可能变成普通的串行排队计算。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121211459958.png" class>



<h3 id="使用并发容器类"><a href="#使用并发容器类" class="headerlink" title="使用并发容器类"></a>使用并发容器类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memoizer2</span> &lt;A,V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A,V&gt;&#123;</span><br><span class="line">    <span class="comment">//并发map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A,V&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A,V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memoizer2</span><span class="params">(Computable&lt;A,V&gt; c)</span>&#123;<span class="built_in">this</span>.c = c;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>)&#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg,result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确实加锁的粒度小了【没有把高耗时的compute过程锁上】，但会带来某个值重复计算的问题。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121211733836.png" class>

<p>而且这不仅仅是性能损耗问题，还有可能会变成安全隐患。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121211807065.png" class>



<h3 id="使用FutureTask"><a href="#使用FutureTask" class="headerlink" title="使用FutureTask"></a>使用FutureTask</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121212307607.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memoizer3</span>&lt;A,V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A,V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache</span><br><span class="line">            = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A,V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memoizer3</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)&#123;</span><br><span class="line">            Callable&lt;V&gt; eval = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(eval);</span><br><span class="line">            f = ft;</span><br><span class="line">            cache.put(arg,ft);</span><br><span class="line">            <span class="comment">//没有启动新线程，直接润</span></span><br><span class="line">            ft.run();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121212617734.png" class>

<p>这个“判断是否开始”与“判断是否完成”的表述非常有意思。<u>此时cache变成了arg和一个异步任务得到的未来结果的映射，而非arg和结果的映射。</u>从此处也可好好理解感受一下“Future”的语义（一个异步执行的结果）。</p>
<p>只是它依然没有解决上面所说的问题，还是可能会有两个线程计算同一个值，虽然概率小得多，<strong>主要原因是因为它使用了非原子的“先检查后执行”</strong>。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121213943478.png" class>

<p>因而，我们可以通过map提供的putifabsent同步方法来解决这个问题。</p>
<h3 id="使用FutureTask和putIfAbsent"><a href="#使用FutureTask和putIfAbsent" class="headerlink" title="使用FutureTask和putIfAbsent"></a>使用FutureTask和putIfAbsent</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memoizer</span>&lt;A,V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A,V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache</span><br><span class="line">            = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A,V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memoizer</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="comment">//一重保险，筛选线程，防止ft对象重复声明销毁</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)&#123;</span><br><span class="line">            Callable&lt;V&gt; eval = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(eval);</span><br><span class="line">            f = cache.putIfAbsent(arg,ft);</span><br><span class="line">            <span class="comment">//二重保险，保障仅一个线程能进入</span></span><br><span class="line">            <span class="comment">//只有那个成功把ft放进map的线程才能进入。</span></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>)&#123;</span><br><span class="line">                f = ft;</span><br><span class="line">                ft.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这个最终版本看起来很完美，但实际上，它还会带来其他的性能问题。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121214243997.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221121214325038.png" class>



<h3 id="运用最终方案建立cache"><a href="#运用最终方案建立cache" class="headerlink" title="运用最终方案建立cache"></a>运用最终方案建立cache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;BigInteger,BigInteger[]&gt; c =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Computable</span>&lt;BigInteger, BigInteger[]&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> BigInteger[] compute(BigInteger arg) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                    <span class="keyword">return</span> factor(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;BigInteger,BigInteger[]&gt; cache =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Memoizer</span>&lt;&gt;(c);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req,ServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            encodeIntoResponse(resp,cache.compute(i));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            encodeError(resp,<span class="string">&quot;factorization interrupted.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="第六章-任务执行"><a href="#第六章-任务执行" class="headerlink" title="第六章  任务执行"></a>第六章  任务执行</h1><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123215101486.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123220853642.png" class>

<h2 id="在线程中执行任务"><a href="#在线程中执行任务" class="headerlink" title="在线程中执行任务"></a>在线程中执行任务</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123215133315.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123215151038.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123215159438.png" class>

<p>也就是说，一个请求视为一个任务。这样做是非常reasonable的，因为每个请求间都是独立的。</p>
<h3 id="串行地执行任务"><a href="#串行地执行任务" class="headerlink" title="串行地执行任务"></a>串行地执行任务</h3><p>调度任务最简单粗暴的就是直接让任务串行执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串行的web服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleThreadWebServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">connection</span> <span class="operator">=</span> socket.accept();</span><br><span class="line">            handleRequest(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123215531413.png" class>

<p>这里有一个点非常棒：网络也是IO，也会造成阻塞。</p>
<h3 id="为每一个任务都创建一个线程"><a href="#为每一个任务都创建一个线程" class="headerlink" title="为每一个任务都创建一个线程"></a>为每一个任务都创建一个线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleThreadWebServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">connection</span> <span class="operator">=</span> socket.accept();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123215819352.png" class>

<p>但是其实这种方式是不好的，因为它无限制地创建线程，这听起来就很容易寄，要知道，高并发的服务器可能会一次解决几千万个请求【当然不知道有没有那么多hhh】，每个都创建一个线程的话，很容易爆内存，而且还会有很大的性能开销。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123220049679.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123220100054.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123220111457.png" class>

<p>而且这样的话，要是高并发情况下，服务器会马上崩溃，做不到我们之前说的自我调节功能。</p>
<p>所以，我们应该为系统能创建的线程数做一个限制。如此，便引出了Executor框架。</p>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123220940346.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">An object that executes submitted Runnable tasks.</span></span><br><span class="line"><span class="comment">An Executor is normally used instead of explicitly creating threads. </span></span><br><span class="line"><span class="comment">此接口提供了一种将任务的提交与每个任务将如何运行的机制解耦的方法，包括线程使用、调度等的详细信息。</span></span><br><span class="line"><span class="comment">The Executor implementations provided in this package implement ExecutorService, which is a more extensive interface. The ThreadPoolExecutor class provides an extensible thread pool implementation. The Executors class provides convenient factory methods for these Executors.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123221628683.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123221641189.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123221651930.png" class>



<h3 id="示例：基于Executor线程池的Web服务器"><a href="#示例：基于Executor线程池的Web服务器" class="headerlink" title="示例：基于Executor线程池的Web服务器"></a>示例：基于Executor线程池的Web服务器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExecutionWebServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NTHREADS</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//工厂方法创建线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">exec</span></span><br><span class="line">            <span class="operator">=</span> Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">connection</span> <span class="operator">=</span> socket.accept();</span><br><span class="line">            <span class="comment">//每次提交一个任务，自然会在某个时刻调度执行</span></span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123223707121.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123223718412.png" class>

<h4 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h4><h5 id="Executor到底什么原理"><a href="#Executor到底什么原理" class="headerlink" title="Executor到底什么原理"></a>Executor到底什么原理</h5><p>这里感觉绕来绕去的，execute到底是会创建一个线程，还是不会创建一个线程？到底是在调用时就创建线程执行任务，还是会在将来的某一个时刻调度执行任务？它这里说得云里雾里的，我来锐评一下我的看法。</p>
<p>首先，我认为，它给我们的ExecutorService类的execute应该都仅仅是提交任务，放进任务队列，之所以什么时候执行得看调度情况。【Form java ThreadPoolExecutor.execute:   Executes the given task sometime <strong>in the future</strong>. 】</p>
<p>而下面那两个类应该都是对execute进行了简单的重写，因而此处execute跟java包里的ExecuteService没有任何关系，调用execute仅相当于调用一个普通的方法。</p>
<h5 id="Executor到底有什么用"><a href="#Executor到底有什么用" class="headerlink" title="Executor到底有什么用"></a>Executor到底有什么用</h5><blockquote>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1hL4y1c7KV/">java线程池其实不难，只要搞清楚来龙去脉</a></p>
</blockquote>
<h6 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h6><p>Executor作为一个接口，其核心思想便是<strong>“解耦”</strong>。</p>
<p>如果没有Executor的话，我们要创建并运行一个任务，一般都得这样用：<code>new Thread(....).start()</code>，或者是比如说串行的<code>new Runnable(...).run()</code>。也就是我们将任务的创建和任务的执行都混在一起了。而假定说，如果以后要改变该线程池的执行方式，比如说从<u>单任务单线程的并行</u>改成<u>全部任务都串行</u>或者反之，那么就需要每个地方都改掉。但如果使用Executor框架将任务创建和任务具体执行解耦开来，那么我们就仅需修改任务具体执行了。</p>
<h6 id="Java的线程管理框架"><a href="#Java的线程管理框架" class="headerlink" title="Java的线程管理框架"></a>Java的线程管理框架</h6><p>JUC（<code>java.util.concurrent</code>）其实就只是分为三个部分。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124145444084.png" class>

<h6 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h6><ol>
<li><p>ExecutorService</p>
<p>ThreadPoolExecutor继承了该接口。</p>
<p>是Executor接口的加强版，包含了更多方法，具体为：</p>
<p>① 自身生命周期的管理  shutdown、isshutdown等等</p>
<p>② 对异步任务的支持  返回Future的submit方法</p>
<p>③ 对批处理任务的支持  invokeall</p>
</li>
<li><p>内部原理</p>
<p>当空闲的线程足够多，直接执行；当线程不够多，进入阻塞队列；当阻塞队列满，使用拒绝策略。</p>
<p>内部的线程池分为救急线程和核心线程。核心线程一直存在，当阻塞队列和核心线程都不够用，就会新开几个救急线程。</p>
</li>
</ol>
<h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123224703727.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123224720389.png" class>



<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123225159600.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123225214708.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123225232404.png" class>

<p>说得非常全面</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123225332798.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123225402837.png" class>

<p>66666</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123225453632.png" class>



<h3 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123225428260.png" class>

<p>我们结束executor，可以采取或温和或粗暴的方法：可以让它不接受新的，慢慢执行完全部再结束；也可以让它直接全部结束，管它有没有执行完或者有没有还没被执行，就跟断电一样。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123225613946.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123225630894.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123225937903.png" class>

<blockquote>
<p>此处疑问：不应该先shutdown再awaitTermination吗？我百度了，也都是说先shutdown。毕竟awaitTermination方法是阻塞的。</p>
</blockquote>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123230804208.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支持关闭操作的Web服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifecycleWebServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">80</span>);</span><br><span class="line">        <span class="comment">//服务器没被关闭就一直接受请求</span></span><br><span class="line">        <span class="keyword">while</span> (!exec.isShutdown())&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">conn</span> <span class="operator">=</span> socket.accept();</span><br><span class="line">                exec.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        handleRequest(conn);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!exec.isShutdown())</span><br><span class="line">                    <span class="comment">//异常地拒绝了</span></span><br><span class="line">                    log(<span class="string">&quot;task submission rejected.&quot;</span>,e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;exec.shutdown();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Socket connection)</span>&#123;</span><br><span class="line">        <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> readRequest(connection);</span><br><span class="line">        <span class="comment">//是否是代表关闭的特定HTTP请求</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdownRequest(req))</span><br><span class="line">            stop();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dispatchRequest(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="延迟任务与周期任务"><a href="#延迟任务与周期任务" class="headerlink" title="延迟任务与周期任务"></a>延迟任务与周期任务</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123230854733.png" class>

<h4 id="Timer类的缺陷"><a href="#Timer类的缺陷" class="headerlink" title="Timer类的缺陷"></a>Timer类的缺陷</h4><h5 id="单线程带来的精确性问题"><a href="#单线程带来的精确性问题" class="headerlink" title="单线程带来的精确性问题"></a>单线程带来的精确性问题</h5><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123230924612.png" class>

<h5 id="线程泄漏"><a href="#线程泄漏" class="headerlink" title="线程泄漏"></a>线程泄漏</h5><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123231001628.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123231358135.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221123231407198.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutOfTime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">            timer.schedule(<span class="keyword">new</span> <span class="title class_">ThrowTask</span>(),<span class="number">1</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            timer.schedule(<span class="keyword">new</span> <span class="title class_">ThrowTask</span>(),<span class="number">1</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThrowTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="找出可利用的并行性"><a href="#找出可利用的并行性" class="headerlink" title="找出可利用的并行性"></a>找出可利用的并行性</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124141730750.png" class>

<p>所以并发编程最难的其实还是建模，如何从串行中挖掘出并行性。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124141815703.png" class>

<h3 id="串行的页面渲染器"><a href="#串行的页面渲染器" class="headerlink" title="串行的页面渲染器"></a>串行的页面渲染器</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124142221038.png" class>

<p>这个把文字的render和图片的render都归结进图像缓存的统一化思想很有意思。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124142254018.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串行地渲染页面元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleThreadRenderer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">renderPage</span><span class="params">(CharSequence source)</span>&#123;</span><br><span class="line">        renderText(source);</span><br><span class="line">        List&lt;ImageData&gt; imageData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ImageInfo imageInfo : scanForImageInfo(source))&#123;</span><br><span class="line">            imageData.add(imageInfo.downloadImage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ImageData data : imageData)&#123;</span><br><span class="line">            renderImage(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，图像的IO需要耗费大量时间，这段时间内CPU都处于空闲状态，可以说利用率非常低下。</p>
<h3 id="携带结果的Callable与Future"><a href="#携带结果的Callable与Future" class="headerlink" title="携带结果的Callable与Future"></a>携带结果的Callable与Future</h3><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124142403690.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124142417423.png" class>

<p>意思就是Callable比Runnable有时候更灵活，因为Callable可以抛出异常，也可以有返回值。</p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124142523227.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124142549408.png" class>

<p>这个Future的说法很棒，只能说比起前面那个含糊的“表示一个异步执行的结果”，这个“任务的生命周期”方法更加醍醐灌顶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>

<p>其中，get的方法<strong>取决于任务的状态</strong>。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124143812121.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124143855525.png" class>

<p>可以利用返回的Future实例来对任务线程进行管理。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124143938883.png" class>



<h3 id="Future实现并行渲染"><a href="#Future实现并行渲染" class="headerlink" title="Future实现并行渲染"></a>Future实现并行渲染</h3><p>将要求分解为两个任务：渲染文本和渲染图像。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124153708025.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Future等待图像下载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureRenderer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">renderPage</span><span class="params">(CharSequence source)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class="line">        <span class="comment">//单独开启下载图像的任务</span></span><br><span class="line">        Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;List&lt;ImageData&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;ImageData&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                List&lt;ImageData&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (ImageInfo imageInfo : imageInfos)</span><br><span class="line">                    result.add(imageInfo.downloadImage(source));</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//在本线程中执行文字的渲染任务</span></span><br><span class="line">        renderText(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//阻塞方法</span></span><br><span class="line">            List&lt;ImageData&gt; imageData = future.get();</span><br><span class="line">            <span class="keyword">for</span> (ImageData data : imageData)</span><br><span class="line">                renderImage(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//重新设置线程的中断状态</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="comment">//不需要结果了，因而取消任务</span></span><br><span class="line">            future.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="在异构任务并行化中存在的局限"><a href="#在异构任务并行化中存在的局限" class="headerlink" title="在异构任务并行化中存在的局限"></a>在异构任务并行化中存在的局限</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124215942150.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124215953246.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124220006632.png" class>

<p>所以难点还是分解同构任务。</p>
<h3 id="CompletionServiceExecutor和BlockingQueue"><a href="#CompletionServiceExecutor和BlockingQueue" class="headerlink" title="CompletionServiceExecutor和BlockingQueue"></a>CompletionServiceExecutor和BlockingQueue</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124220255951.png" class>

<p>CompletionService的思想其实和这个差不多。它主要就是多包装一层，数据结构的管理不用你写，更加方便。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124220354517.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124220553386.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124220608567.png" class>

<p>也就是说ExecutorCompletionService将CompletionService的计算部分交给了传进来的线程池Executor，然后自己管理一个阻塞队列，类似生产者-消费者模式，把线程池里出来的结果放进去。</p>
<h3 id="使用CompletionService实现页面渲染器"><a href="#使用CompletionService实现页面渲染器" class="headerlink" title="使用CompletionService实现页面渲染器"></a>使用CompletionService实现页面渲染器</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124221302485.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Renderer</span> &#123;</span><br><span class="line">    <span class="comment">//为什么这里的线程池要变成包内外界给的呢？</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">    Renderer(ExecutorService executor)&#123;<span class="built_in">this</span>.executor = executor;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">renderPage</span><span class="params">(CharSequence source)</span>&#123;</span><br><span class="line">        List&lt;ImageInfo&gt; info = scanForImageInfo(source);</span><br><span class="line">        <span class="comment">//传入委托计算的线程池</span></span><br><span class="line">        CompletionService&lt;ImageData&gt; completionService</span><br><span class="line">                = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(executor);</span><br><span class="line">        <span class="comment">//提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ImageInfo imageInfo : info)</span><br><span class="line">            completionService.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;ImageData&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> ImageData <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> imageInfo.downloadImage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        </span><br><span class="line">        renderText(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>, n = info.size(); t &lt; n; t++)&#123;</span><br><span class="line">                <span class="comment">//得到下载结果</span></span><br><span class="line">                Future&lt;ImageData&gt; f = completionService.take();</span><br><span class="line">                <span class="type">ImageData</span> <span class="variable">imageData</span> <span class="operator">=</span> f.get();</span><br><span class="line">                renderImage(imageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221124221406773.png" class>

<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>我这里写了一个自己用list来保存Future结果的。不知道为什么这个不行，有待说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRenderer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">renderPage</span><span class="params">(CharSequence source)</span>&#123;</span><br><span class="line">        List&lt;Future&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;ImageInfo&gt; info = scanForImageInfo(source);</span><br><span class="line">        <span class="comment">//提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ImageInfo imageInfo : info)&#123;</span><br><span class="line">            res.add(executor.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> imageInfo.downloadImage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        renderText(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>, n = info.size(); t &lt; n; t++)&#123;</span><br><span class="line">                Future&lt;ImageData&gt; f = res.get(t);</span><br><span class="line">                <span class="type">ImageData</span> <span class="variable">imageData</span> <span class="operator">=</span> f.get();</span><br><span class="line">                renderImage(imageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="为任务设置时限"><a href="#为任务设置时限" class="headerlink" title="为任务设置时限"></a>为任务设置时限</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221126153515063.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221126153538022.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221126153555573.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Page <span class="title function_">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endNanos</span> <span class="operator">=</span> System.nanoTime()+TIME_BUDGET;</span><br><span class="line">    <span class="comment">//提交下载广告的任务</span></span><br><span class="line">    Future&lt;Ad&gt; f = exec.submit(<span class="keyword">new</span> <span class="title class_">FetchAdTask</span>());</span><br><span class="line">    <span class="comment">//在等待广告的同时显示页面</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> renderPageBody();</span><br><span class="line">    Ad ad;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//相当于timeleft=TIME_BUDGET-经过的时间，只不过进行了运算的化简</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timeLeft</span> <span class="operator">=</span> endNanos- System.nanoTime();</span><br><span class="line">        ad=f.get(timeLeft, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        ad = DEFAULT_AD;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        <span class="comment">//超时取消</span></span><br><span class="line">        ad = DEFAULT_AD;</span><br><span class="line">        f.cancel(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page.setAd(ad);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221126153734647.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221126153744085.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Attempts to cancel execution of this task.  This attempt will</span></span><br><span class="line"><span class="comment">    * fail if the task has already completed, has already been cancelled,</span></span><br><span class="line"><span class="comment">    * or could not be cancelled for some other reason.</span></span><br><span class="line"><span class="comment">      If successful,</span></span><br><span class="line"><span class="comment">    * and this task has not started when &#123;<span class="doctag">@code</span> cancel&#125; is called,</span></span><br><span class="line"><span class="comment">    * this task should never run.  </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">      If the task has already started,</span></span><br><span class="line"><span class="comment">    * then the mayInterruptIfRunning parameter determines</span></span><br><span class="line"><span class="comment">    * whether the thread executing this task should be interrupted in</span></span><br><span class="line"><span class="comment">    * an attempt to stop the task.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也就是说，如果mayInterruptIfRunning==false，就需要等该任务完成；如果==true，就直接中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="示例：旅行预定门户网站"><a href="#示例：旅行预定门户网站" class="headerlink" title="示例：旅行预定门户网站"></a>示例：旅行预定门户网站</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221126154306285.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221126154321716.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221126154355913.png" class>

<p>也就是说，跟前面的CompletionService的优化目的是一致的，都是为了方便管理这一组future，这也跟我上面写的那个list管理版本是一样的。只不过区别在于，CompletionService还可以共用任务池，因而功能更强。invokeAll用法更简便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">QuoteTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;TravelQuote&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelCompany company;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo travelInfo;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TravelQuote <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//solicit：征求、招揽  quote：报价</span></span><br><span class="line">        <span class="keyword">return</span> company.solicitQuote(travelInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到排序的报价表</span></span><br><span class="line"><span class="keyword">public</span> List&lt;TravelQuote&gt; <span class="title function_">getRankedTravleQuotes</span><span class="params">(</span></span><br><span class="line"><span class="params">    ThravelInfo travelInfo, Set&lt;TravelCompany&gt; companies, Comparator&lt;TravelQuote&gt; ranking, <span class="type">long</span> time, TimeUnit unit</span></span><br><span class="line"><span class="params">)</span><span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (TravelCompany company:companies)&#123;</span><br><span class="line">        tasks.add(<span class="keyword">new</span> <span class="title class_">QuoteTask</span>(company,travelInfo));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用invokeAll，一键定时任务，非常方便</span></span><br><span class="line">    List&lt;Future&lt;TravelQuote&gt;&gt; futures =</span><br><span class="line">        exec.invokeAll(tasks,time,unit);</span><br><span class="line"></span><br><span class="line">    List&lt;TravelQuote&gt; quotes =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tasks.size());</span><br><span class="line">    Iterator&lt;QuoteTask&gt; taskIterator = tasks.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Future&lt;TravelQuote&gt; f : futures)&#123;</span><br><span class="line">        <span class="type">QuoteTask</span> <span class="variable">task</span> <span class="operator">=</span> taskIterator.next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//只需调用get就行，不用传时间参数</span></span><br><span class="line">            quotes.add(f.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            quotes.add(task.getFailureQuote(e.getCause()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancellationException e)&#123;</span><br><span class="line">            quotes.add(task.getTimeoutQuote(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    Collections.sort(quotes,ranking);</span><br><span class="line">    <span class="keyword">return</span> quotes;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221126160129232.png" class>





<h1 id="第七章-取消与关闭"><a href="#第七章-取消与关闭" class="headerlink" title="第七章  取消与关闭"></a>第七章  取消与关闭</h1><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128171337144.png" class>

<p>中断是个重要概念，也算是老朋友了</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128171520903.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128171532202.png" class>

<h2 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h2><h3 id="取消的原因"><a href="#取消的原因" class="headerlink" title="取消的原因"></a>取消的原因</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128171550405.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128171606015.png" class>



<h3 id="使用volatile标志取消"><a href="#使用volatile标志取消" class="headerlink" title="使用volatile标志取消"></a>使用volatile标志取消</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>Java并没有提供取消某个线程的安全抢占方法，仅有约定俗成的协作机制。</p>
<p>比如说，可以设置一个volatile类型的取消标志，并且让线程定期查看该标志。【这是volatile的经典用途】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimGenerator</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; prims</span><br><span class="line">            = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//使用volatile域保护取消状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">p</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">        <span class="comment">//任务执行时定期检查取消状态</span></span><br><span class="line">        <span class="keyword">while</span> (!cancelled)&#123;</span><br><span class="line">            p=p.nextProbablePrime();</span><br><span class="line">            <span class="comment">//这里用同步可能是因为下面的getPrim方法使用了同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                prims.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>&#123;cancelled = <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(prims);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrimGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrimGenerator</span>();</span><br><span class="line"><span class="comment">//使用Executor代替Thread</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">exec.execute(generator);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    generator.cancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(generator.get());</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128172155396.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128172203863.png" class>



<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128172239659.png" class>

<p>比如下面程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">cancelled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue)&#123;</span><br><span class="line">        <span class="built_in">this</span>.queue=queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BigInteger</span> <span class="variable">p</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span> (! cancelled)&#123;</span><br><span class="line">                <span class="comment">//如果一直阻塞在这，便永远不会检查cancelled标志</span></span><br><span class="line">                queue.put(p=p.nextProbablePrime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>&#123;cancelled = <span class="literal">true</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128172343359.png" class>

<p>所以解决方法其实很简单，只要让阻塞状态下我们还能知道要取消任务就行。这靠我们在表层写代码是做不到的，需要用到Java提供的另一种协作机制：线程中断。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128172553141.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128172603325.png" class>

<p>所以说中断其实就是为取消而量身定做的。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128172651932.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128172817019.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128172848148.png" class>

<p>所以作为上层开发者，我们仅需捕获中断异常即可。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128195833742.png" class>

<p>也就是说，打断阻塞状态下的线程会清空中断状态，打断正常状态的线程会保持中断状态。而正常状态的线程如果不对中断状态处理，就会一直保持中断状态然后继续运行，也就是屏蔽中断状态。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221129112944609.png" class>

<p>具体检查方法还是定期看标记。在看到标记后可以做善后工作再决定停不停。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128200001019.png" class>

<p>程序清单5-10：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221128200048095.png" class>

<p>恢复中断状态的示例：</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221129113703582.png" class>

<p>捕获睡眠时的中断异常，然后重新设置打断标志为true，进入下一次循环时再对标记进行处理。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221129114139660.png" class>



<h4 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意此处继承自Thread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimeProducer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line"></span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue)&#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BigInteger</span> <span class="variable">p</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">            <span class="comment">//put本就可以检测中断，为啥还要外层包装一层检测的while呢？书中说是为了提高相应度。</span></span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//此时catch完之后自动退出</span></span><br><span class="line">            <span class="comment">/* 允许线程退出 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>&#123;interrupt();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是我为了方便调试自己加的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(BigInteger i : queue)&#123;</span><br><span class="line">            System.out.println(i.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试主函数部分如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrimeProducer</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrimeProducer</span>(<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">generator.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    generator.cancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generator.get();</span><br></pre></td></tr></table></figure>



<h4 id="一个有待解决的疑问"><a href="#一个有待解决的疑问" class="headerlink" title="一个有待解决的疑问"></a>一个有待解决的疑问</h4><p>此处编写主函数运行时，不小心产生了一个错误：<a href="https://stackoverflow.com/questions/74581025/why-does-the-threadpoolexecutor-code-never-stop-running">Why does the ThreadpoolExecutor code never stop running?</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">PrimeProducer</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrimeProducer</span>(<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    exec.execute(generator);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        generator.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//generator.get();</span></span><br><span class="line">    exec.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码跑起来的最终结果就是进程永远无法终止。至于为什么：</p>
<p>PrimeProducer类继承自Thread，而execute的参数是一个Runnable。也就是说，Executor会把传进来的这个Thread当成一个Runnable，然后再把它包装成一个新的Thread。所以你的generator里的cancel方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>&#123;interrupt();&#125;</span><br></pre></td></tr></table></figure>

<p>调用的就不是本线程的中断方法，而是一个全新的毫无关系的线程的中断方法了。</p>
<p>所以其实应该这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">PrimeProducer</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrimeProducer</span>(<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">    generator.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        generator.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    generator.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但我还是有个奇思妙想。可不可以沿用一开始那个错误的主方法版本，然后修改PrimeProducer类为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处修改为Runnable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimeProducer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>&#123;Thread.currentThread().interrupt();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果还是跑不起来，不知道为什么，有待解答。</p>
<h3 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h3><img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221130102819989.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221130102923834.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221130103244135.png" class>

<p>意思就是，单个的任务是非线程所有者，因为它们是被分配到线程池所有的线程执行的。所以它们不能直接对中断进行处理，需要把中断异常抛给那个目前还不知道是谁的所有者线程，让调用者决定自己该怎么做。</p>
<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221130104203841.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221130104315056.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221130104407288.png" class>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221130104418619.png" class>





<p>以下的地方一个字也看不懂，写自己的思考也没什么意义。就附上正确代码模板吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过future定时取消任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">taskExec</span> <span class="operator">=</span> 		</span><br><span class="line">    				Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">timeRun</span><span class="params">(Runnable r,</span></span><br><span class="line"><span class="params">                           <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Future&lt;?&gt; task = taskExec.submit(r);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.get(timeout,unit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        <span class="comment">//接下来任务将被取消</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        task.cancel(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/image-20221130164236408.png" class>



]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb</title>
    <url>/2022/12/21/JavaWeb/</url>
    <content><![CDATA[<h1 id="第一部分-Java基础"><a href="#第一部分-Java基础" class="headerlink" title="第一部分  Java基础"></a>第一部分  Java基础</h1><h2 id="JUnit单元测试"><a href="#JUnit单元测试" class="headerlink" title="JUnit单元测试"></a>JUnit单元测试</h2><p>JUnit是白盒测试。</p>
<h3 id="简要使用步骤"><a href="#简要使用步骤" class="headerlink" title="简要使用步骤"></a>简要使用步骤</h3><h4 id="定义测试类"><a href="#定义测试类" class="headerlink" title="定义测试类"></a>定义测试类</h4><p>包含各种测试用例。</p>
<p>一般放在包名xxx.xxx.xx.test里，类名为“被测试类名Test”。</p>
<h4 id="定义测试方法"><a href="#定义测试方法" class="headerlink" title="定义测试方法"></a>定义测试方法</h4><p>测试方法可以独立运行。</p>
<p>方法名一般为“test测试的方法”，void，空参。</p>
<h4 id="给方法加-Test标签"><a href="#给方法加-Test标签" class="headerlink" title="给方法加@Test标签"></a>给方法加@Test标签</h4><h4 id="加入JUnit依赖包"><a href="#加入JUnit依赖包" class="headerlink" title="加入JUnit依赖包"></a>加入JUnit依赖包</h4><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Assert.assertEquals(<span class="number">3</span>,result);</span><br></pre></td></tr></table></figure>

<h4 id="Before-After"><a href="#Before-After" class="headerlink" title="@Before  @After"></a>@Before  @After</h4><p>@Before在所有测试方法执行前自动执行，常用于资源申请。</p>
<p>@After在所有测试方法执行完后自动执行，常用于释放资源。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是框架设计的灵魂。</p>
<h3 id="Java对象创建的三个阶段"><a href="#Java对象创建的三个阶段" class="headerlink" title="Java对象创建的三个阶段"></a>Java对象创建的三个阶段</h3><p><img src="/2022/12/21/JavaWeb/image-20221205194807395.png" alt="image-20221205194807395"></p>
<p>类加载器把硬盘中的字节流文件装载进内存，并且翻译封装为Class类对象。通过Class类对象才能创建Person对象。</p>
<p>而这也就是说，如果我们有了Class对象，我们就可以创建该类对象。</p>
<h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>有三种方式。</p>
<h4 id="Class-forName-“类的全名”"><a href="#Class-forName-“类的全名”" class="headerlink" title="Class.forName(“类的全名”)"></a>Class.forName(“类的全名”)</h4><p>将字节码文件加载进内存，返回class对象。多用于配置文件【将类名定义在配置文件】</p>
<p>注意：类的全名指的是包.类，包含包名。</p>
<h4 id="类型-class"><a href="#类型-class" class="headerlink" title="类型.class"></a>类型.class</h4><p>通过类名的属性class获取。多用于参数传递。</p>
<h4 id="对象-getClass"><a href="#对象-getClass" class="headerlink" title="对象.getClass()"></a>对象.getClass()</h4><p>getClass()是Object类的方法。多用于对象的获取字节码的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">System.out.println(class1);</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">class2</span> <span class="operator">=</span> Student.class;</span><br><span class="line">System.out.println(class2);</span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">class3</span> <span class="operator">=</span> stu.getClass();</span><br><span class="line">System.out.println(class3);</span><br><span class="line"></span><br><span class="line">System.out.println((class1==class2)+<span class="string">&quot;  &quot;</span>+(class2==class3));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">class Student</span></span><br><span class="line"><span class="comment">class Student</span></span><br><span class="line"><span class="comment">class Student</span></span><br><span class="line"><span class="comment">true  true*/</span></span><br></pre></td></tr></table></figure>

<p>同一个字节码文件（*.class）在一次程序运行过程中只会被加载一次，不管是以哪种方式得到的Class对象，都是同一个。</p>
<h3 id="使用Class对象"><a href="#使用Class对象" class="headerlink" title="使用Class对象"></a>使用Class对象</h3><p>可以通过class对象得到其字段、构造方法、方法等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="type">int</span> birthday;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> birthday, <span class="type">int</span> money, <span class="type">double</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, birthday=&quot;</span> + birthday +</span><br><span class="line">                <span class="string">&quot;, money=&quot;</span> + money +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">haha</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,&quot;</span>+name+<span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my money is yours...&quot;</span>);</span><br><span class="line">        money = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">321</span>,<span class="number">1000</span>,<span class="number">57.7</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">stuC</span> <span class="operator">=</span> stu.getClass();</span><br></pre></td></tr></table></figure>

<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><h5 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h5><p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有公有字段</span></span><br><span class="line">Field[] fs = stuC.getFields();</span><br><span class="line"><span class="comment">//获取某个公有字段</span></span><br><span class="line"><span class="type">Filed</span> <span class="variable">f</span> <span class="operator">=</span> stuC.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//获取所有字段</span></span><br><span class="line">Field[] fs = stuC.getDeclaredFields();</span><br><span class="line"><span class="comment">//获取某个字段</span></span><br><span class="line"><span class="type">Filed</span> <span class="variable">f</span> <span class="operator">=</span> stuC.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">public java.lang.String Student.name</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public java.lang.String Student.name</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public java.lang.String Student.name</span></span><br><span class="line"><span class="comment">int Student.birthday</span></span><br><span class="line"><span class="comment">protected int Student.money</span></span><br><span class="line"><span class="comment">private double Student.weight*/</span></span><br></pre></td></tr></table></figure>

<h5 id="使用字段"><a href="#使用字段" class="headerlink" title="使用字段"></a>使用字段</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> stuC.getDeclaredField(<span class="string">&quot;money&quot;</span>);</span><br><span class="line"><span class="comment">//由于money protected，故应该先设置其为可访问，否则会抛出异常。</span></span><br><span class="line"><span class="comment">//这是暴力反射，不推荐。</span></span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//获取成员变量的值</span></span><br><span class="line"><span class="comment">//注意此处是要用field.get(该类型对象)的。想想也有道理，Filed字段是属于Class对象的，因而你想获取某个对象的值当然得传入该对象。</span></span><br><span class="line">System.out.println(f.get(stu));</span><br><span class="line"><span class="comment">//设置对象的值</span></span><br><span class="line">f.set(stu,<span class="number">0</span>);</span><br><span class="line">System.out.println(stu);</span><br><span class="line"><span class="comment">/* Student&#123;name=&#x27;张三&#x27;, birthday=321, money=0, weight=57.7&#125;  */</span></span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>获取方法跟上面格式差不多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取构造方法</span></span><br><span class="line"><span class="comment">//获取无参私有构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> stuC.getDeclaredConstructor();</span><br><span class="line">cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">System.out.println(cons.newInstance());</span><br><span class="line"><span class="comment">//获取有参构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">cons2</span> <span class="operator">=</span> stuC.getConstructor(String.class,<span class="type">int</span>.class,<span class="type">int</span>.class,<span class="type">double</span>.class);</span><br><span class="line">System.out.println(cons2.newInstance(<span class="string">&quot;李四&quot;</span>,<span class="number">102</span>,<span class="number">100</span>,<span class="number">90.9</span>));</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">Student&#123;name=&#x27;null&#x27;, birthday=0, money=0, weight=0.0&#125;</span></span><br><span class="line"><span class="comment">Student&#123;name=&#x27;李四&#x27;, birthday=102, money=100, weight=90.9&#125;*/</span></span><br></pre></td></tr></table></figure>

<p>如果想要获取公有的无参构造器，还可以使用Class类提供的更简单的方法，不用先创造构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(stuC.newInstance());</span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取方法</span></span><br><span class="line"><span class="comment">//可以获取静态方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> stuC.getMethod(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">System.out.println(m);</span><br><span class="line"><span class="comment">//获取带参方法，自动根据参数推断</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> stuC.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">m3</span> <span class="operator">=</span> stuC.getMethod(<span class="string">&quot;hello&quot;</span>,String.class);</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">m2.invoke(stu);</span><br><span class="line">m3.invoke(stu,<span class="string">&quot;琳琳&quot;</span>);</span><br><span class="line"><span class="comment">//获取私有方法并调用</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m4</span> <span class="operator">=</span> stuC.getDeclaredMethod(<span class="string">&quot;giveMoney&quot;</span>);</span><br><span class="line">m4.setAccessible(<span class="literal">true</span>);</span><br><span class="line">m4.invoke(stu);</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">public static void Student.haha()</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello,琳琳!</span></span><br><span class="line"><span class="comment">my money is yours...*/</span></span><br></pre></td></tr></table></figure>

<h3 id="使用反射的案例"><a href="#使用反射的案例" class="headerlink" title="使用反射的案例"></a>使用反射的案例</h3><p><img src="/2022/12/21/JavaWeb/image-20221205205122805.png" alt="image-20221205205122805"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 加载配置文件 */</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//获取字节码文件加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ReflectTest.class.getClassLoader();</span><br><span class="line">        pro.load(cl.getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 获取配置文件中的数据并执行 */</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cla</span> <span class="operator">=</span> Class.forName(pro.getProperty(<span class="string">&quot;className&quot;</span>));</span><br><span class="line">        cla.getMethod(pro.getProperty(<span class="string">&quot;methodName&quot;</span>)).invoke(cla.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><img src="/2022/12/21/JavaWeb/image-20221205211932790.png" alt="image-20221205211932790"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221205212028989.png" alt="image-20221205212028989"></p>
<p>①和③都是jdk预定义的。自定义主要是②。</p>
<h3 id="生成doc文档"><a href="#生成doc文档" class="headerlink" title="生成doc文档"></a>生成doc文档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javadoc XXX.java</span><br></pre></td></tr></table></figure>

<p>会自动根据里面的注解生成文档</p>
<h3 id="JDK预定义注解"><a href="#JDK预定义注解" class="headerlink" title="JDK预定义注解"></a>JDK预定义注解</h3><p><img src="/2022/12/21/JavaWeb/image-20221205212443918.png" alt="image-20221205212443918"></p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><h4 id="注解类的本质"><a href="#注解类的本质" class="headerlink" title="注解类的本质"></a>注解类的本质</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.annotation.Annotation&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h4><p>注解的属性就是接口中的成员方法。要求无参，且返回类型有固定取值：</p>
<p><img src="/2022/12/21/JavaWeb/image-20221205213135522.png" alt="image-20221205213135522"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnno(name = &quot;haha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>描述注解的注解</p>
<p><img src="/2022/12/21/JavaWeb/image-20221205213324052.png" alt="image-20221205213324052"></p>
<p>RetentionPolicy的三个取值：SOURCE、CLASS、RUNTIME，正对应着java对象的三个阶段。</p>
<p>SOURCE：不保留到字节码文件，会被编译器扔掉</p>
<p>CLASS：保留到字节码文件</p>
<p>RUNTIME：被读到</p>
<p><strong>自定义的注解一般都取RUNTIME</strong>。</p>
<h3 id="在程序中获取注解属性"><a href="#在程序中获取注解属性" class="headerlink" title="在程序中获取注解属性"></a>在程序中获取注解属性</h3><p>相当于用注解替换配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Pro &#123;</span><br><span class="line">    String <span class="title function_">className</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">methodName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保留在runtime应该是因为运行时要动态获取值。我试了一下换成CLASS或者SOURCE，会有NullPointerException</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pro(className = &quot;Student&quot;,methodName = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Pro</span> <span class="variable">pro</span> <span class="operator">=</span> ReflectTest.class.getAnnotation(Pro.class);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Class</span> <span class="variable">cla</span> <span class="operator">=</span> Class.forName(pro.className());</span><br><span class="line">        cla.getMethod(pro.methodName()).invoke(cla.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>class.getAnnotation(Pro.class);</code>这句话实质上是创建了一个实例，继承了Pro接口，重载了里面的抽象方法。</p>
<h3 id="使用案例：测试框架"><a href="#使用案例：测试框架" class="headerlink" title="使用案例：测试框架"></a>使用案例：测试框架</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在要测试的每个方法上面加上此标签。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221205215017285.png" alt="image-20221205215017285"></p>
<p>然后编写test方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCheck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="comment">//获取所有方法</span></span><br><span class="line">        Method[] methods = c.getClass().getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入文件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//异常次数</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;bug.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查每个方法是否有注解。有的话则执行。</span></span><br><span class="line">        <span class="keyword">for</span> (Method m : methods)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m.isAnnotationPresent(Check.class))&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    m.invoke(c);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//记录文件信息</span></span><br><span class="line">                    number++;</span><br><span class="line">                    bf.write(m.getName()+<span class="string">&quot;出异常了。&quot;</span>);</span><br><span class="line">                    bf.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    bf.write(e.getCause().getClass().getSimpleName()+<span class="string">&quot; &quot;</span>+e.getCause().getMessage());</span><br><span class="line">                    bf.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    bf.write(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">                    bf.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bf.write(<span class="string">&quot;共出现&quot;</span>+number+<span class="string">&quot;次异常&quot;</span>);</span><br><span class="line">        bf.flush();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">haha出异常了。</span></span><br><span class="line"><span class="comment">ArithmeticException / by zero</span></span><br><span class="line"><span class="comment">-------------</span></span><br><span class="line"><span class="comment">共出现1次异常</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/12/21/JavaWeb/image-20221205220053258.png" alt="image-20221205220053258"></p>
<h1 id="第二部分-数据库"><a href="#第二部分-数据库" class="headerlink" title="第二部分 数据库"></a>第二部分 数据库</h1><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="登录方式"><a href="#登录方式" class="headerlink" title="登录方式"></a>登录方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h[IP地址] -u[用户名] -p</span><br></pre></td></tr></table></figure>

<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>本地的一个文件夹就代表一个数据库，文件夹里的一个文件代表一张表。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221205221041508.png" alt="image-20221205221041508"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221205221055114.png" alt="image-20221205221055114"></p>
<h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><p><img src="/2022/12/21/JavaWeb/image-20221205221216882.png" alt="image-20221205221216882"></p>
<p>SQL有四种语句类型</p>
<p><img src="/2022/12/21/JavaWeb/image-20221205221246672.png" alt="image-20221205221246672"></p>
<h3 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL  操作数据库、表"></a>DDL  操作数据库、表</h3><h4 id="操纵数据库"><a href="#操纵数据库" class="headerlink" title="操纵数据库"></a>操纵数据库</h4><h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create datebase 数据库名称;</span><br><span class="line">create datebase if not exists 数据库名称;</span><br><span class="line">create datebase if not exists 数据库名称 character set gbk;</span><br></pre></td></tr></table></figure>

<h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database 数据库名称;</span><br><span class="line">drop database if exists 数据库名称;</span><br></pre></td></tr></table></figure>

<h5 id="改"><a href="#改" class="headerlink" title="改"></a>改</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter database 数据库名称 charactor set 修改后新值;</span><br></pre></td></tr></table></figure>

<h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;# 查询所有数据库名称</span><br><span class="line">show create database 数据库名称;# 显示指定数据库创建时的指令内容</span><br></pre></td></tr></table></figure>

<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select database();# 查询正在使用的数据库名称</span><br><span class="line">use 数据库名称;</span><br></pre></td></tr></table></figure>

<h4 id="操纵表"><a href="#操纵表" class="headerlink" title="操纵表"></a>操纵表</h4><h5 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table students(</span><br><span class="line">    name varchar(20),</span><br><span class="line">    age int,</span><br><span class="line">    score double(3,1),</span><br><span class="line">    birthday date,</span><br><span class="line">    insert_time timestamp</span><br><span class="line">);# 创建表</span><br><span class="line">create table students2 like students;# 复制表</span><br></pre></td></tr></table></figure>

<p>*注：</p>
<ol>
<li><p>mysql的数据类型表</p>
<p><img src="/2022/12/21/JavaWeb/image-20221205222127740.png" alt="image-20221205222127740"></p>
<p>其中：</p>
<p>① double(3,1)表示XXX.X，最大值为99.9.</p>
<p>② 关于三个时间类型</p>
<p><img src="/2022/12/21/JavaWeb/image-20221205222307284.png" alt="image-20221205222307284"></p>
<p>所以timestamp常用作插入时间。</p>
<p>③ varchar(20)表示二十个字符长的字符串。</p>
<p>注意，是“二十个字符”而不是“二十个字节”。如果使用的<strong>字符集</strong>每个字符占3个字节，则varchar(20)占60个字节。</p>
<p>④ BLOB、CLOB、二进制这些用于存储大数，不常用</p>
</li>
</ol>
<h5 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure>

<h5 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改表名</span><br><span class="line">alter table students rename to new_students;</span><br><span class="line"># 修改表的字符集</span><br><span class="line">alter table students character set 字符集名称;</span><br><span class="line"># 修改表的列名/类型</span><br><span class="line">alter table students change name new_name varchar(20);# 新列名 新数据类型</span><br><span class="line">alter table students modify name varchar(15);# 新数据类型</span><br><span class="line"># 添加一列</span><br><span class="line">alter table students add ID double(10);</span><br><span class="line"># 删除一列</span><br><span class="line">alter table students drop ID;</span><br></pre></td></tr></table></figure>

<h5 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;# 查询数据库中所有表的名字</span><br><span class="line">desc 表名;# 查询某个表的结构</span><br></pre></td></tr></table></figure>



<h3 id="DML-增删改表中数据"><a href="#DML-增删改表中数据" class="headerlink" title="DML  增删改表中数据"></a>DML  增删改表中数据</h3><h4 id="增-2"><a href="#增-2" class="headerlink" title="增"></a>增</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into students(name,age,score,birthday) values(&#x27;张三&#x27;,15,99.9,&quot;2022-12-5&quot;);</span><br><span class="line">insert into students values(&quot;张三&quot;,15,99.9,&quot;2022-12-5&quot;,NULL);</span><br></pre></td></tr></table></figure>

<h4 id="删-2"><a href="#删-2" class="headerlink" title="删"></a>删</h4><p>如果不加条件，会把表中所有数据删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from students where name=&quot;张三&quot;;</span><br><span class="line">truncate table students;# 删除表，然后创建一张一模一样的新表</span><br></pre></td></tr></table></figure>

<p><img src="/2022/12/21/JavaWeb/image-20221205224600869.png" alt="image-20221205224600869"></p>
<h4 id="改-2"><a href="#改-2" class="headerlink" title="改"></a>改</h4><p>如果不加条件，会把表中所有记录全部修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update students set name=&quot;1&quot;, age=10 where name=&quot;张三&quot;;</span><br></pre></td></tr></table></figure>



<h3 id="DQL-查询表中记录"><a href="#DQL-查询表中记录" class="headerlink" title="DQL 查询表中记录"></a>DQL 查询表中记录</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><img src="/2022/12/21/JavaWeb/image-20221205224802814.png" alt="image-20221205224802814"></p>
<h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select # 多字段查询</span><br><span class="line">	name,</span><br><span class="line">	age </span><br><span class="line">from </span><br><span class="line">	students;</span><br><span class="line">	</span><br><span class="line">select distinct # 去重</span><br><span class="line">	address</span><br><span class="line">from</span><br><span class="line">	students;</span><br><span class="line"></span><br><span class="line"># 有NULL参与的计算结果都为NULL</span><br><span class="line">select name,math,english,math+english from students;</span><br><span class="line"># ifnull函数不会修改原表中的数据</span><br><span class="line">select name,math,english,IFNULL(math,0)+IFNULL(english,0) from students;</span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">	name,</span><br><span class="line">	math,</span><br><span class="line">	english,</span><br><span class="line">	IFNULL(math,0)+IFNULL(english,0)  total_score # 起别名</span><br><span class="line">from </span><br><span class="line">	students;</span><br></pre></td></tr></table></figure>

<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><ol>
<li><p>基本运算符</p>
<p>&lt;、&gt;、=、&lt;=、&gt;=、&lt;&gt;(不等于，也可以用!=)</p>
</li>
<li><p>逻辑运算符</p>
<p>AND、OR</p>
</li>
<li><p>BETWEEN AND</p>
</li>
<li><p>IN后跟集合</p>
<p><img src="/2022/12/21/JavaWeb/image-20221205230824086.png" alt="image-20221205230824086"></p>
</li>
<li><p>IS、IS NOT</p>
<p><img src="/2022/12/21/JavaWeb/image-20221205230902110.png" alt="image-20221205230902110"></p>
</li>
<li><p>LIKE 模糊查询</p>
<p>类似正则使用占位符匹配</p>
<p><img src="/2022/12/21/JavaWeb/image-20221205231037021.png" alt="image-20221205231037021"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where name like &quot;马%&quot;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="各种函数一样的东西"><a href="#各种函数一样的东西" class="headerlink" title="各种函数一样的东西"></a>各种函数一样的东西</h4><h5 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by 排序字段1 排序方式1,排序字段2 排序方式2;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>默认升序。</p>
</li>
<li><p>ASC、DESC</p>
</li>
<li><p>多关键字排序</p>
<p><img src="/2022/12/21/JavaWeb/image-20221205231606255.png" alt="image-20221205231606255"></p>
<p>第二条件仅当第一条件一样才使用。</p>
</li>
</ol>
<h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><p>将一列数据作为整体，纵向计算</p>
<p>注意，<strong>聚合函数的计算会排除NULL值</strong>。如果不想让空置排除，可以尝试该方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(ifnull(math,0)) from students;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>count 计算个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(name) from students;# 有多少条记录</span><br></pre></td></tr></table></figure>

<p>一般如果要看有多少记录，可以用count(主键)，因为主键不为空。</p>
</li>
<li><p>max、min</p>
</li>
<li><p>sum 求和</p>
</li>
<li><p>avg 平均值</p>
</li>
</ol>
<h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h5><p>分组之后查询的字段只能是两种：① 分组字段 ② 聚合函数。因为分组了之后再查具有个人特色的东西就没意义了。【高版本的mysql如果查询别的字段会报错】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sex,avg(math) from students group by sex;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/12/21/JavaWeb/image-20221207212103151.png" alt="image-20221207212103151"></p>
<h6 id="对分组结果进行条件限制"><a href="#对分组结果进行条件限制" class="headerlink" title="对分组结果进行条件限制"></a>对分组结果进行条件限制</h6><p>还可以在分组前对条件限定，使用WHERE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sex,avg(math) from students where math &gt;= 70 group by sex;</span><br></pre></td></tr></table></figure>

<p>或者在分组后限定，使用HAVING</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sex,avg(math),count(id) from students group by sex having count(id)&gt;2;</span><br><span class="line"># 或</span><br><span class="line">select sex,avg(math),count(id) total from students group by sex having total&gt;2;</span><br></pre></td></tr></table></figure>

<h6 id="WHERE和HAVING的区别"><a href="#WHERE和HAVING的区别" class="headerlink" title="WHERE和HAVING的区别"></a>WHERE和HAVING的区别</h6><ol>
<li>WHERE在分组前限定，不满足where则不参与分组；HAVING在分组后限定，不满足having则不会被查询出来。</li>
<li>WHERE条件里不能有聚合函数，HAVING可以。</li>
</ol>
<h5 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h5><p><img src="/2022/12/21/JavaWeb/image-20221207213958848.png" alt="image-20221207213958848"></p>
<p>这种就是分页查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 开始的索引,每页查询的条数;</span><br></pre></td></tr></table></figure>

<p><code>limit</code>只能在mysql使用。</p>
<h3 id="DCL-管理用户，授权操作"><a href="#DCL-管理用户，授权操作" class="headerlink" title="DCL 管理用户，授权操作"></a>DCL 管理用户，授权操作</h3><h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><h5 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h5><p><img src="/2022/12/21/JavaWeb/image-20221219223932789.png" alt="image-20221219223932789"></p>
<p>用户表存放地点↑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">SELECT * FROM USER;</span><br></pre></td></tr></table></figure>

<h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p>注意，以下出现的”用户名”@”主机名” IDENTIFIED BY “密码”，不能在@两侧加空格，否则报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &quot;用户名&quot;@&quot;主机名&quot; IDENTIFIED BY &quot;密码&quot;;</span><br></pre></td></tr></table></figure>

<h5 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP USER &quot;用户名&quot;@&quot;主机名&quot;;</span><br></pre></td></tr></table></figure>

<h5 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 使用mysql自带的密码加密函数PASSWORD</span><br><span class="line">-- 1</span><br><span class="line">UPDATE USER SET PASSWORD = PASSWORD(&quot;新密码&quot;) WHERE USER = &quot;用户名&quot;;</span><br><span class="line">-- 2</span><br><span class="line">SET PASSWORD FOR &quot;用户名&quot;@&quot;主机名&quot; = PASSWORD(&quot;新密码&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/12/21/JavaWeb/image-20221219225036633.png" alt="image-20221219225036633"></p>
<h4 id="授权操作"><a href="#授权操作" class="headerlink" title="授权操作"></a>授权操作</h4><h5 id="查询权限"><a href="#查询权限" class="headerlink" title="查询权限"></a>查询权限</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &quot;root&quot;@&quot;%&quot;;</span><br></pre></td></tr></table></figure>

<h5 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant 权限列表 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/12/21/JavaWeb/image-20221219225715075.png" alt="image-20221219225715075"></p>
<h5 id="撤销权限"><a href="#撤销权限" class="headerlink" title="撤销权限"></a>撤销权限</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke 权限列表 on 数据库名.表名 from &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><h4 id="添加非空约束"><a href="#添加非空约束" class="headerlink" title="添加非空约束"></a>添加非空约束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	id INT,</span><br><span class="line">	name VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br><span class="line">ALTER TABLE stu MODIFY name VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure>

<h4 id="删除非空约束"><a href="#删除非空约束" class="headerlink" title="删除非空约束"></a>删除非空约束</h4><p>如果要去掉该约束，可以这么做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY name VARCHAR(20);</span><br></pre></td></tr></table></figure>

<p>由于我们没写“NOT NULL ”，所以非空约束就被去掉了。感觉这点的解释挺有意思的。</p>
<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><h4 id="添加唯一约束"><a href="#添加唯一约束" class="headerlink" title="添加唯一约束"></a>添加唯一约束</h4><p>某列值不能重复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	id INT,</span><br><span class="line">	phone_number VARCHAR(20) UNIQUE</span><br><span class="line">);</span><br><span class="line">ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</span><br></pre></td></tr></table></figure>

<p>但是注意，唯一约束<strong>允许多个NULL存在</strong>。</p>
<h4 id="删除唯一约束"><a href="#删除唯一约束" class="headerlink" title="删除唯一约束"></a>删除唯一约束</h4><p>唯一约束的删除方法跟前面的非空约束就完全不一样了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stu DROP INDEX phone_number;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建唯一约束时会自动创建唯一索引，需要删除索引</p>
</blockquote>
<h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><p>一张表只能有一个主键。主键非空且唯一。</p>
<h4 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	id INT PRIMARY KEY,</span><br><span class="line">	name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">ALTER TABLE stu MODIFY id INT PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<h4 id="删除主键约束"><a href="#删除主键约束" class="headerlink" title="删除主键约束"></a>删除主键约束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stu DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<h4 id="自动增长"><a href="#自动增长" class="headerlink" title="自动增长"></a>自动增长</h4><p>这东西一般都跟主键结合使用。</p>
<p>若某一列是数值类型，可以使用auto_increment关键字来完成值的自动增长。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO stu VALUES(NULL,&#x27;111&#x27;);# 设NULL或自己指派都行。</span><br></pre></td></tr></table></figure>

<p>自动增长的数据只跟上一个记录有关系。</p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p><img src="/2022/12/21/JavaWeb/image-20221207222232057.png" alt="image-20221207222232057"></p>
<p>表中dep_name和dep_location有数据冗余，修改或者插入都不方便，不符合数据库设计准则，所以需要创造两张表。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221207222418827.png" alt="image-20221207222418827"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221207222439652.png" alt="image-20221207222439652"></p>
<p>但要是你想裁员了，直接在第二个表删研发部是没用的，第一个表数据还在，还得麻烦地一个个删。这时候外键就起作用了。</p>
<h4 id="添加外键约束"><a href="#添加外键约束" class="headerlink" title="添加外键约束"></a>添加外键约束</h4><p>外键只能关联唯一约束或者主键约束的列。一般外键都是去关联主表的主键。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221207223758950.png" alt="image-20221207223758950"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE employee(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(20),</span><br><span class="line">	age INT,</span><br><span class="line">	dep_id INT, -- 外键列</span><br><span class="line">	CONSTRAINT emp_dept_fk FOREIGN KEY (dep_id) REFERENCES department(id) -- 外键声明</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE employee ADD CONSTRAINT emp_dept_fk FOREIGN KEY (dep_id) REFERENCES department(id) -- 外键声明</span><br></pre></td></tr></table></figure>

<p>此时不能删除department的行【要是该行在employee表没出现过的话就可以删掉】，也不能在employee添加一个不存在的外键值。</p>
<h4 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a>删除外键约束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE employee DROP FOREIGN KEY emp_dept_fk;</span><br></pre></td></tr></table></figure>

<h4 id="外键级联"><a href="#外键级联" class="headerlink" title="外键级联"></a>外键级联</h4><p>如果你想修改外表主键值，就需要用到级联更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE employee ADD CONSTRAINT emp_dept_fk FOREIGN KEY (dep_id) REFERENCES department(id) ON UPDATE CASCADE ;-- 外键声明+级联更新声明</span><br></pre></td></tr></table></figure>

<p>如果你想达到删除一个主键值就能删除表中的所有与该主键值关联的数据，就需要用到级联删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE employee ADD CONSTRAINT emp_dept_fk FOREIGN KEY (dep_id) REFERENCES department(id) ON DELETE CASCADE ;-- 外键声明+级联删除声明</span><br></pre></td></tr></table></figure>

<p>级联使用应该要谨慎。一是它不大安全，二是它涉及多表操作，效率低下</p>
<h2 id="多表关系与范式"><a href="#多表关系与范式" class="headerlink" title="多表关系与范式"></a>多表关系与范式</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><p><img src="/2022/12/21/JavaWeb/image-20221219161901631.png" alt="image-20221219161901631"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221219161847190.png" alt="image-20221219161847190"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221219161853190.png" alt="image-20221219161853190"></p>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p><img src="/2022/12/21/JavaWeb/image-20221219162311785.png" alt="image-20221219162311785"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221219162646556.png" alt="image-20221219162646556"></p>
<h4 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h4><p><img src="/2022/12/21/JavaWeb/image-20221219162034996.png" alt="image-20221219162034996"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221219162047446.png" alt="image-20221219162047446"></p>
<h4 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h4><p>1NF中的主属性为学号和课程名称。可以看到，分数完全依赖于码，但是姓名、系名、系主任都只是部分依赖于码，这不符合2NF的条件。因而，我们就可以选择拆分表，把完全依赖的部分和部分依赖的部分分开：</p>
<p>由于分数-&gt;（学号，课程名称），因而可以把学号、课程名称、分数放在一张表</p>
<p>由于姓名、系名、系主任 -&gt;(学号)，因而可以把学号、姓名、系名、系主任放在一张表</p>
<p>如下图所示。这样就消除了部分依赖。</p>
<p><img src="/2022/12/21/JavaWeb/%E5%9B%BE%E7%89%872.png" alt="图片2"></p>
<h4 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h4><p>2NF中选课表的主属性为学号和课程名称，学生表的主属性为学号。可以看到，学生表中，存在着系主任-&gt;系名-&gt;学号这样的传递依赖，不符合3NF的规定。因而，我们需要对学生表进行进一步的拆分。</p>
<p>我们为了破坏系主任-&gt;系名-&gt;学号这个传递链，可以拆分成系主任-&gt;系名和系名-&gt;学号两个传递关系。</p>
<p>因而，可以把学生表拆分为如下图两张表：</p>
<p><img src="/2022/12/21/JavaWeb/image-20221219162231385.png" alt="image-20221219162231385"></p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><h4 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h4><p>使用where条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询所有员工信息和对应的部门信息</span><br><span class="line">SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;</span><br><span class="line">-- 进行去重就成为了自然连接：</span><br><span class="line">SELECT emp.*,dept.`NAME` FROM emp,dept WHERE emp.`dept_id` = dept.`id`;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此在书中称为“等值连接和非等值连接”。</p>
</blockquote>
<h4 id="显式内连接"><a href="#显式内连接" class="headerlink" title="显式内连接"></a>显式内连接</h4><p>语法： select 字段列表 from 表名1 <strong>[inner] join</strong> 表名2 <strong>on</strong> 条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;	</span><br></pre></td></tr></table></figure>

<h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><blockquote>
<p>关于外连接和内连接的区别，以及左外连接与右外连接的区别：</p>
<p><img src="/2022/12/21/JavaWeb/image-20221219155724391.png" alt="image-20221219155724391"></p>
<p>![屏幕截图 2022-12-19 155750](./JavaWeb/屏幕截图 2022-12-19 155750.png)</p>
<p><img src="/2022/12/21/JavaWeb/image-20221219155846157.png" alt="image-20221219155846157"></p>
</blockquote>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>语法：select 字段列表 from 表1 <strong>left [outer] join</strong> 表2 <strong>on</strong> 条件；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 	t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;</span><br></pre></td></tr></table></figure>

<h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>语法：select 字段列表 from 表1 <strong>right [outer] join</strong> 表2 <strong>on</strong> 条件；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 	* FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;</span><br></pre></td></tr></table></figure>

<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>查询嵌套</p>
<blockquote>
<p>子查询中不允许使用ORDER BY </p>
<p>在实际运用中，内连接比子查询的效率更高</p>
</blockquote>
<h4 id="不相关子查询"><a href="#不相关子查询" class="headerlink" title="不相关子查询"></a>不相关子查询</h4><blockquote>
<p><img src="/2022/12/21/JavaWeb/image-20221219160800762.png" alt="image-20221219160800762"></p>
</blockquote>
<h5 id="子查询结果单行单列"><a href="#子查询结果单行单列" class="headerlink" title="子查询结果单行单列"></a>子查询结果单行单列</h5><p>可用于WHERE条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询工资最高的员工信息</span><br><span class="line">SELECT * FROM emp WHERE emp.salary = (SELECT MAX(salary) FROM emp);</span><br></pre></td></tr></table></figure>

<h5 id="子查询结果多行单列"><a href="#子查询结果多行单列" class="headerlink" title="子查询结果多行单列"></a>子查询结果多行单列</h5><p>可以作为条件用IN关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询&#x27;财务部&#x27;和&#x27;市场部&#x27;所有的员工信息</span><br><span class="line">SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE name = &quot;财务部&quot; OR name = &quot;市场部&quot;);</span><br></pre></td></tr></table></figure>

<h5 id="子查询结果多行多列"><a href="#子查询结果多行多列" class="headerlink" title="子查询结果多行多列"></a>子查询结果多行多列</h5><p>可以当做一个新表，可以转化为普通内连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息</span><br><span class="line">-- 嵌套查询</span><br><span class="line">SELECT *</span><br><span class="line">FROM dept, (</span><br><span class="line">	SELECT *</span><br><span class="line">    FROM emp</span><br><span class="line">    WHERE emp.join_data &gt; &#x27;2011-11-11&#x27;</span><br><span class="line">)</span><br><span class="line">WHERE dept.id = emp.dept_id;</span><br><span class="line">-- 内连接</span><br><span class="line">SELECT * FROM emp,dept WHERE emp.join_data &gt; &#x27;2011-11-11&#x27; AND emp.dep_id = dept.id;</span><br></pre></td></tr></table></figure>

<h4 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h4><blockquote>
<p><img src="/2022/12/21/JavaWeb/image-20221219160653496.png" alt="image-20221219160653496"></p>
<p>子查询内部使用了父查询的东西</p>
<p><img src="/2022/12/21/JavaWeb/image-20221219161626542.png" alt="image-20221219161626542"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221219161637827.png" alt="image-20221219161637827"></p>
</blockquote>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>一个包含多个步骤的业务操作被事务管理，操作要么同时成功，要么同时失败。【有种原子操作的感觉？】</p>
<p><img src="/2022/12/21/JavaWeb/image-20221219214157761.png" alt="image-20221219214157761"></p>
<p>当操作失败时，会<strong>回滚</strong>到执行前的状态。</p>
<h4 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h4><p>事实上就是类似有个缓冲区，得到commit指令就把缓冲区内容更新，得到rollback指令就把缓冲区内容丢弃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 操作序列：转账500元</span><br><span class="line">UPDATE usr SET money = money - 500 WHERE uname = &quot;Mary&quot;;</span><br><span class="line">UPDATE usr SET money = money + 500 WHERE uname = &quot;Lily&quot;;</span><br><span class="line"></span><br><span class="line">-- 提交</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 操作序列：转账500元</span><br><span class="line">UPDATE usr SET money = money - 500 WHERE uname = &quot;Mary&quot;;</span><br><span class="line">出错了</span><br><span class="line">UPDATE usr SET money = money + 500 WHERE uname = &quot;Lily&quot;;</span><br><span class="line"></span><br><span class="line">-- 出错则回滚</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<h5 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br></pre></td></tr></table></figure>

<h5 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<h5 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>一条DML（增删改表中数据）语句默认会自动提交。但如果手动开启了事务，那么事务内保护的原子序列就需要手动提交。</p>
<p>如果想将默认提交给kill了，也即不论是否开启事务都得手动提交，那么就需要用如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @@autocommit = 0;</span><br></pre></td></tr></table></figure>

<h3 id="事务的四大特征"><a href="#事务的四大特征" class="headerlink" title="事务的四大特征"></a>事务的四大特征</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>一旦事务提交/回滚，会持久性更新数据库表。</p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>多个事务之间应该相互独立。为了保障这一点，需要设置事务的隔离级别。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务操作前后数据总量不变。</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。【有点并发的感觉】</p>
<p><img src="/2022/12/21/JavaWeb/image-20221219221141605.png" alt="image-20221219221141605"></p>
<p>隔离级别越高，安全性越高，效率越来越差。</p>
<p>mysql默认的是3，oracle默认的是2.</p>
<p>可以设置隔离级别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level  &quot;级别字符串&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过之后老师说的内容，感觉有了点个人的感悟：</p>
<p>级别1寻找数据可能优先从缓冲区找；级别2相当于不能读到缓冲区内容；级别3可能相当于在开启事务前对表做了个快照？级别4应该就是直接上了把互斥锁，同一时刻只能一个事务读写。</p>
</blockquote>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>Java Database Connectivity  Java语言操作数据库</p>
<p><img src="/2022/12/21/JavaWeb/image-20221220141025613.png" alt="image-20221220141025613"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221220141214259.png" alt="image-20221220141214259"></p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol>
<li><p>导入驱动jar包</p>
<p>① 新建libs目录</p>
<p>② 把jar包复制到libs目录下</p>
<p>③ 右键libs目录  add as library</p>
</li>
<li><p>注册驱动</p>
</li>
<li><p>获取数据库连接对象 Connection</p>
</li>
<li><p>定义sql语句</p>
</li>
<li><p>获取执行sql语句的对象 Statement</p>
</li>
<li><p>执行sql，接收返回的结果</p>
</li>
<li><p>处理结果</p>
</li>
<li><p>释放资源</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        <span class="comment">//1 注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2 获取数据库连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/helloworld&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="comment">//3 定义sql语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update usr set money = 5000 where id = 1&quot;</span>;</span><br><span class="line">        <span class="comment">//4 获取执行对象 Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="comment">//5 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">        <span class="comment">//6 处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//7 释放资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化版【增加try-catch-finally】：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1 注册驱动</span></span><br><span class="line">        <span class="comment">//提升作用域，放在try外面</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2 获取数据库连接对象</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/helloworld&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">			<span class="comment">//3 定义sql语句</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from usr&quot;</span>;</span><br><span class="line">			<span class="comment">//4 获取执行对象 Statement</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">			<span class="comment">//5 执行sql</span></span><br><span class="line">            resultSet = stmt.executeQuery(sql);</span><br><span class="line">			<span class="comment">//6 处理结果</span></span><br><span class="line">            <span class="keyword">if</span> (resultSet == <span class="literal">null</span>)</span><br><span class="line">                System.out.println(<span class="string">&quot;修改失败&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">                    System.out.println(resultSet.getInt(<span class="number">1</span>)+<span class="string">&quot; &quot;</span></span><br><span class="line">                            +resultSet.getString(<span class="number">2</span>)+<span class="string">&quot; &quot;</span></span><br><span class="line">                            +resultSet.getInt(<span class="number">3</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resultSet.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//为了避免空指针异常</span></span><br><span class="line">            <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="详解各个类"><a href="#详解各个类" class="headerlink" title="详解各个类"></a>详解各个类</h3><h4 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h4><h5 id="注册驱动"><a href="#注册驱动" class="headerlink" title="注册驱动"></a>注册驱动</h5><p>目的是告诉程序该使用哪一个数据库驱动jar包</p>
<p>在快速入门中，我们使用这一行来注册驱动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>表面上看跟DriverManager类可以说是毫无关系。</p>
<p>但其实，类加载器加载类的时候，<strong>其实是会自动执行类中的静态代码块的</strong>。Driver类中有一段静态代码块如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，注册驱动其实主要任务是由DriverManager类干的。这个静态块仅仅用于简化代码书写。</p>
<blockquote>
<p>注意：mysql5之后的版本，这一步注册驱动可以省略。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221220151045275.png" alt="image-20221220151045275"></p>
<p>配置文件里自动帮你注册了。我想原理应该是让本文件的类自动加载。</p>
</blockquote>
<h5 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/helloworld&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>url的语法：”jdbc:mysql://IP地址:端口号/数据库名称”</p>
<p><img src="/2022/12/21/JavaWeb/image-20221220151425953.png" alt="image-20221220151425953"></p>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>数据库连接对象。</p>
<h5 id="获取Statement对象"><a href="#获取Statement对象" class="headerlink" title="获取Statement对象"></a>获取Statement对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement <span class="title function_">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">PreparedStatement <span class="title function_">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure>

<h5 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h5><h6 id="开启事务-1"><a href="#开启事务-1" class="headerlink" title="开启事务"></a>开启事务</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAutoCommit</span><span class="params">(<span class="type">boolean</span> autoCommit)</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure>

<p>设置参数为<strong>false</strong>即开启事务。也即关闭自动提交。</p>
<h6 id="提交事务-1"><a href="#提交事务-1" class="headerlink" title="提交事务"></a>提交事务</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure>

<h6 id="回滚事务-1"><a href="#回滚事务-1" class="headerlink" title="回滚事务"></a>回滚事务</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure>

<h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h4><blockquote>
<p>The object used for executing a static SQL statement and returning the results it produces.执行静态sql</p>
</blockquote>
<h5 id="执行sql"><a href="#执行sql" class="headerlink" title="执行sql"></a>执行sql</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行任意语句</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">execute</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  执行DML（增删改表中数据）和DDL（表和库）语句</span></span><br><span class="line"><span class="comment">  返回值：影响到的行数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">executeUpdate</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"><span class="comment">//执行DQL（查询表记录）语句</span></span><br><span class="line">ResultSet <span class="title function_">executeQuery</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure>

<h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h4><p>封装查询结果集。</p>
<p>具体取数方法就是类似迭代器原理。next移动迭代器指针，getXxx()方法，Xxx是数据类型，得到该行表记录中对应列对应数据类型的值。可以传入列数或者列名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">String <span class="title function_">getString</span><span class="params">(<span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">getBoolean</span><span class="params">(<span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getLong</span><span class="params">(<span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">/*@param:</span></span><br><span class="line"><span class="comment">columnLabel – the label for the column specified with the SQL AS clause.</span></span><br><span class="line"><span class="comment">		If the SQL AS clause was not specified, then the label is the name of the column</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String <span class="title function_">getString</span><span class="params">(String columnLabel)</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure>

<p>使用实例：</p>
<p><img src="/2022/12/21/JavaWeb/image-20221220164414363.png" alt="image-20221220164414363"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Client&gt; <span class="title function_">query</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Client&gt; clients = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///helloworld&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line">        resultSet = stmt.executeQuery(<span class="string">&quot;select * from usr&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resultSet == <span class="literal">null</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;查询失败&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span>(resultSet.next())</span><br><span class="line">                clients.add(<span class="keyword">new</span> <span class="title class_">Client</span>(resultSet.getInt(<span class="number">1</span>),</span><br><span class="line">                                       resultSet.getString(<span class="number">2</span>),</span><br><span class="line">                                       resultSet.getInt(<span class="number">3</span>)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了避免空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p><strong>这东西也得Close</strong>。</p>
</li>
<li><p>如果想做“查询到了结果则返回true”这样的操作，不应该使用这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (resultSet != <span class="literal">null</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>而应该这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> resultSet.next();</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//An object that represents a precompiled SQL statement.</span></span><br><span class="line"><span class="comment">//表示预编译的sql语句的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PreparedStatement</span> <span class="keyword">extends</span> <span class="title class_">Statement</span></span><br></pre></td></tr></table></figure>

<p>Statement的子类。可以用来解决<strong>sql注入</strong>问题。</p>
<p>它是预编译的sql语句，也即sql语句中的参数使用“？”占位符，需要传入参数。</p>
<h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><p>如下面的验证密码程序。键盘输入账号密码，从数据库查询该用户是否存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Login</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//输入账号密码</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        System.out.println(<span class="string">&quot;Please enter the user name.&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;Please enter the password.&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        <span class="comment">//验证账号密码</span></span><br><span class="line">        System.out.println(checkPassword(uname,password));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkPassword</span><span class="params">(String uname,String password)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uname == <span class="literal">null</span> | password == <span class="literal">null</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            stmt = conn.prepareStatement(</span><br><span class="line">                <span class="string">&quot;select * from user where name = ? and password = ?&quot;</span>);</span><br><span class="line">            <span class="comment">//这跟resultset的获取表值的那个是一样的，都是需要指定列数和要设定的值。</span></span><br><span class="line">            <span class="comment">//并且下标都是以1开始。</span></span><br><span class="line">            stmt.setString(<span class="number">1</span>,uname);</span><br><span class="line">            stmt.setString(<span class="number">2</span>,password);</span><br><span class="line">            resultSet = stmt.executeQuery();</span><br><span class="line"><span class="comment">//            stmt = conn.createStatement();</span></span><br><span class="line"><span class="comment">//            resultSet = stmt.executeQuery(&quot;select * from user where name = &#x27;&quot;</span></span><br><span class="line"><span class="comment">//            								+uname+&quot;&#x27; and password = &#x27;&quot;+password+&quot;&#x27;&quot;);</span></span><br><span class="line">            <span class="keyword">return</span> resultSet.next();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(conn,stmt,resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用PreparedStatement替代Statement"><a href="#用PreparedStatement替代Statement" class="headerlink" title="用PreparedStatement替代Statement"></a>用PreparedStatement替代Statement</h5><p>它更安全且效率更高。</p>
<h3 id="JDBC工具类"><a href="#JDBC工具类" class="headerlink" title="JDBC工具类"></a>JDBC工具类</h3><h4 id="书写"><a href="#书写" class="headerlink" title="书写"></a>书写</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="comment">//获取连接时不想传参，且需要保证通用性，使用配置文件</span></span><br><span class="line">    <span class="comment">//配置文件只需读取一次，可以用静态代码块完成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties pro;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        pro = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ClassLoader类可以获取src路径下的文件。使用ClassLoader获取文件时，只用传入相对于src的相对路径就行</span></span><br><span class="line"><span class="comment">            此处如果使用FileReader，需要以下写法：</span></span><br><span class="line"><span class="comment">            pro.load(new FileReader(</span></span><br><span class="line"><span class="comment">                    JDBCUtils.class.getClassLoader()</span></span><br><span class="line"><span class="comment">                            .getResource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="comment">                            .getPath())</span></span><br><span class="line"><span class="comment">            );</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;./jdbc.properties&quot;</span>));</span><br><span class="line">            url = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            user = pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            driver = pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">            <span class="comment">//在静态块里注册驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载机制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn)</span>&#123;</span><br><span class="line">        close(conn,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement stmt)</span>&#123;</span><br><span class="line">        close(conn,stmt,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement stmt, ResultSet resultSet)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Client&gt; <span class="title function_">query</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Client&gt; clients = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line">        resultSet = stmt.executeQuery(<span class="string">&quot;select * from usr&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resultSet == <span class="literal">null</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;查询失败&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span>(resultSet.next())</span><br><span class="line">                clients.add(<span class="keyword">new</span> <span class="title class_">Client</span>(resultSet.getInt(<span class="number">1</span>),resultSet.getString(<span class="number">2</span>),resultSet.getInt(<span class="number">3</span>)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.close(conn,stmt,resultSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h3><p>使用Connection对象的管理事务的方法。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221220214249168.png" alt="image-20221220214249168"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221220224401302.png" alt="image-20221220224401302"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">stmt2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            stmt = conn.prepareStatement(</span><br><span class="line">                    <span class="string">&quot;update usr set money = money - 500 where id = 1&quot;</span>);</span><br><span class="line">            stmt.executeUpdate();</span><br><span class="line"><span class="comment">//            int i = 3/0;</span></span><br><span class="line">            stmt2 = conn.prepareStatement(</span><br><span class="line">                    <span class="string">&quot;update usr set money = money + 500 where id = 2&quot;</span>);</span><br><span class="line">                stmt2.executeUpdate();</span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(conn,stmt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>其实就是上面的JDBC中的Connection的对象池。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221222212904151.png" alt="image-20221222212904151"></p>
<h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>非常简单，就是改一下Connection的获取，写一下xml就行。</p>
<h5 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h5><p>固定放在src目录下。名字必须为c3p0-config.xml或者c3p0.properties</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用默认的配置读取连接池对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/helloworld<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果超过此超时时间，就说明数据库连接失败 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;otherc3p0&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/day25<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以注意到，xml文件里面可以保存多套配置，比如上面的示例代码就保存了两套配置，default-config和name=”otherc3p0”的config。</p>
<p>ComboPooledDataSource有一个含参构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ComboPooledDataSource</span><span class="params">(String configName)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(configName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以传入config的名称指定要用的配置信息。</p>
<h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    conn = cpds.getConnection();</span><br><span class="line">	<span class="comment">//正常使用......</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//正常使用关闭方法</span></span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="设置配置文件-1"><a href="#设置配置文件-1" class="headerlink" title="设置配置文件"></a>设置配置文件</h5><p>Druid的配置文件可以放在任意路径下，随便取名字。因为到时候需要指定配置文件。使用的是Properties文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/helloworld</span></span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line">initialSize=<span class="number">5</span></span><br><span class="line">maxActive=<span class="number">10</span></span><br><span class="line">maxWait=<span class="number">3000</span></span><br></pre></td></tr></table></figure>

<h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入配置文件</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pro.load(Main.class.getClassLoader().getResourceAsStream(<span class="string">&quot;./druid.properties&quot;</span>));</span><br><span class="line"><span class="comment">//使用工厂方法获取连接池对象</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    conn = cpds.getConnection();</span><br><span class="line">	<span class="comment">//正常使用......</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//正常使用关闭方法</span></span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义工具类"><a href="#定义工具类" class="headerlink" title="定义工具类"></a>定义工具类</h4><p>一般使用的时候还是会自定义一个工具类的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;./druid.properties&quot;</span>));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载机制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn)</span>&#123;</span><br><span class="line">        close(conn,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement stmt)</span>&#123;</span><br><span class="line">        close(conn,stmt,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement stmt, ResultSet resultSet)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用同上的JDBCUtils</p>
<h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><p>Spring框架对JDBC的简单封装，提供JDBCTemplate对象。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="带参（PreparedStatement）"><a href="#带参（PreparedStatement）" class="headerlink" title="带参（PreparedStatement）"></a>带参（PreparedStatement）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbcTemplate.update(<span class="string">&quot;update usr set money = ? where uname = ?&quot;</span>,<span class="number">10</span>,<span class="string">&quot;Mary&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><h5 id="update"><a href="#update" class="headerlink" title="update"></a>update</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(JDBCUtils.getDataSource());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;insert into usr values (null,&#x27;Jack&#x27;,3000),(null,&#x27;LiMing&#x27;,500000)&quot;</span>);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    <span class="comment">//删</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;delete from usr where uname = &#x27;Jack&#x27;&quot;</span>);</span><br><span class="line">    System.out.println(count2);</span><br><span class="line">    <span class="comment">//改</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count3</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;update usr set money = ? where uname = ?&quot;</span>,<span class="number">10</span>,<span class="string">&quot;Mary&quot;</span>);</span><br><span class="line">    System.out.println(count3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><p>提供了三种方法。</p>
<h5 id="queryForMap"><a href="#queryForMap" class="headerlink" title="queryForMap"></a>queryForMap</h5><p>将得到的结果（只能是一行）封装为一个Map&lt;String,Object&gt;，其中key为列名，value为该行该列的值。</p>
<p>如果得到的结果不为1行（=0 or &gt;1），会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(JDBCUtils.getDataSource());</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Object&gt; m = jdbcTemplate.queryForMap(<span class="string">&quot;select * from usr where id = 2&quot;</span>);</span><br><span class="line">    System.out.println(m);</span><br><span class="line"><span class="comment">//输出：&#123;id=2, uname=Lily, money=2000&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="queryForList"><a href="#queryForList" class="headerlink" title="queryForList"></a>queryForList</h5><p>将得到的结果封装为List&lt;Map&lt;String,Object&gt;&gt;，其中一个Map为一行，多个Map表示多行，存储在List中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; res = jdbcTemplate.queryForList(<span class="string">&quot;select * from usr&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map&lt;String,Object&gt; m : res)&#123;</span><br><span class="line">        System.out.println(m.hashCode());</span><br><span class="line">        System.out.println(m.keySet().toString());</span><br><span class="line">        System.out.println(m.values().toString());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">213151839</span></span><br><span class="line"><span class="comment">[id, uname, money]</span></span><br><span class="line"><span class="comment">[1, Mary, 10]</span></span><br><span class="line"><span class="comment">213143443</span></span><br><span class="line"><span class="comment">[id, uname, money]</span></span><br><span class="line"><span class="comment">[2, Lily, 2000]</span></span><br><span class="line"><span class="comment">-2022948335</span></span><br><span class="line"><span class="comment">[id, uname, money]</span></span><br><span class="line"><span class="comment">[4, LiMing, 500000]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="query"><a href="#query" class="headerlink" title="query"></a>query</h5><p>可以把查询回的结果封装为自己想要的对象而不是Map。如示例就封装为了Client对象。</p>
<h6 id="原始一点的"><a href="#原始一点的" class="headerlink" title="原始一点的"></a>原始一点的</h6><p>可以看到，里面的包装内容还是得自己写，有点麻烦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(JDBCUtils.getDataSource());</span><br><span class="line"></span><br><span class="line">        List&lt;Client&gt; clients = jdbcTemplate.query(</span><br><span class="line">            <span class="string">&quot;select * from usr where money &gt; 1000&quot;</span>, </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RowMapper</span>&lt;Client&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Client <span class="title function_">mapRow</span><span class="params">(ResultSet resultSet, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Client</span>(</span><br><span class="line">                    resultSet.getInt(<span class="number">1</span>),</span><br><span class="line">                    resultSet.getString(<span class="number">2</span>),</span><br><span class="line">                    resultSet.getInt(<span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(clients.toString());</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">[Client&#123;id=2, name=&#x27;Lily&#x27;, money=2000&#125;, Client&#123;id=4, name=&#x27;LiMing&#x27;, money=500000&#125;, Client&#123;id=6, name=&#x27;LiMing&#x27;, money=500000&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h6 id="常用的"><a href="#常用的" class="headerlink" title="常用的"></a>常用的</h6><p>使用包装好的BeanPropertyRowMapper类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(JDBCUtils.getDataSource());</span><br><span class="line"></span><br><span class="line">        List&lt;Client&gt; clients = jdbcTemplate.query(<span class="string">&quot;select * from usr where money &gt; 1000&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Client&gt;(Client.class));</span><br><span class="line">        System.out.println(clients.toString());</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">[Client&#123;id=2, uname=&#x27;Lily&#x27;, money=2000&#125;, Client&#123;id=4, uname=&#x27;LiMing&#x27;, money=500000&#125;, Client&#123;id=6, uname=&#x27;LiMing&#x27;, money=500000&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>要求包装的class，比如说Client，必须要有public的<strong>无参构造器</strong>。</li>
<li>Java的那个被包装类的字段最好<strong>不</strong>使用基本数据类型，而使用引用类型，如Integer，Double等等等。因为如果使用基本数据类型，当表中数据为null时会报错。</li>
<li>要求被包装的class的字段名称一定要与数据库的<strong>一模一样</strong>，大小写可以不一样。</li>
<li>要求被包装的class的字段一定要是可以修改的。也就是说，要么public，要么提供set方法。</li>
</ol>
<h5 id="queryForObject"><a href="#queryForObject" class="headerlink" title="queryForObject"></a>queryForObject</h5><p>返回查到的某个东西。可以用于聚合函数的查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select money from usr where uname = &#x27;Mary&#x27;&quot;</span>,Integer.class);</span><br><span class="line">System.out.println(money);</span><br></pre></td></tr></table></figure>

<h1 id="第三部分-Web概述和静态网页技术"><a href="#第三部分-Web概述和静态网页技术" class="headerlink" title="第三部分 Web概述和静态网页技术"></a>第三部分 Web概述和静态网页技术</h1><h2 id="Web概述"><a href="#Web概述" class="headerlink" title="Web概述"></a>Web概述</h2><ul>
<li><p>JavaWeb：</p>
<ul>
<li>使用Java语言开发基于互联网的项目</li>
</ul>
</li>
<li><p>软件架构：</p>
<ol>
<li>C/S: Client/Server 客户端/服务器端<ul>
<li>在用户本地有一个客户端程序，在远程有一个服务器端程序</li>
<li>如：QQ，迅雷…</li>
<li>优点：<ol>
<li>用户体验好</li>
</ol>
</li>
<li>缺点：<ol>
<li>开发、安装，部署，维护 麻烦</li>
</ol>
</li>
</ul>
</li>
<li>B/S: Browser/Server 浏览器/服务器端<ul>
<li>只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序</li>
<li>优点：<ol>
<li>开发、安装，部署，维护 简单</li>
</ol>
</li>
<li>缺点：<ol>
<li>如果应用过大，用户的体验可能会受到影响</li>
<li>对硬件要求过高</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>B/S架构详解</p>
<ul>
<li><p>资源分类：</p>
<ol>
<li>静态资源：<ul>
<li>使用静态网页开发技术发布的资源。</li>
<li>特点：<ul>
<li>所有用户访问，得到的结果是一样的。</li>
<li>如：文本，图片，音频、视频, HTML,CSS,JavaScript</li>
<li>如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源</li>
</ul>
</li>
</ul>
</li>
<li>动态资源：<ul>
<li>使用动态网页及时发布的资源。</li>
<li>特点：<ul>
<li>所有用户访问，得到的结果可能不一样。</li>
<li>如：jsp/servlet,php,asp…</li>
<li>如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>我们要学习动态资源，必须先学习静态资源！</p>
</li>
<li><p>静态资源：</p>
<ul>
<li>HTML：用于搭建基础网页，展示页面的内容</li>
<li>CSS：用于美化页面，布局页面</li>
<li>JavaScript：控制页面的元素，让页面有一些动态的效果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="静态网页概述"><a href="#静态网页概述" class="headerlink" title="静态网页概述"></a>静态网页概述</h2><h3 id="练习：用纯HTML写旅游网站首页"><a href="#练习：用纯HTML写旅游网站首页" class="headerlink" title="练习：用纯HTML写旅游网站首页"></a>练习：用纯HTML写旅游网站首页</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>旅游网站<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/top_banner.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;亲子周边旅游节&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">&quot;25%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/logo.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/search.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;search&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">&quot;25%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/hotel_tel.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;hotel&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">bgcolor</span>=<span class="string">&quot;orange&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">height</span> = <span class="string">&quot;45&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>门票<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>酒店<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>香港车票<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>出境游<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>国内游<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>港澳游<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>抱团定制<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>全球自由行<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>收藏排行榜<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/banner_3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;亲子周边旅游节&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span> <span class="attr">width</span>=<span class="string">&quot;20%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/icon_5.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;亲子周边旅游节&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span>&gt;</span>黑马精选<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">hr</span> <span class="attr">color</span>=<span class="string">&quot;orange&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span> <span class="attr">width</span>=<span class="string">&quot;20%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/icon_6.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;亲子周边旅游节&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span>&gt;</span>国内游<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">hr</span> <span class="attr">color</span>=<span class="string">&quot;orange&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">width</span>=<span class="string">&quot;95%&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span> = <span class="string">&quot;25%&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/guonei_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;亲子周边旅游节&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span> <span class="attr">width</span>=<span class="string">&quot;20%&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/icon_7.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;亲子周边旅游节&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span>&gt;</span>境外游<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">hr</span> <span class="attr">color</span>=<span class="string">&quot;orange&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">width</span>=<span class="string">&quot;95%&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span> = <span class="string">&quot;25%&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangwai_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;亲子周边旅游节&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/footer_service.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span> <span class="attr">bgcolor</span>=<span class="string">&quot;orange&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span> = <span class="string">75</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;gray&quot;</span> <span class="attr">size</span> = <span class="string">2</span>&gt;</span>江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018<span class="symbol">&amp;copy;</span>, All Rights Reserved 苏ICP备16007882<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol>
<li><p>布局</p>
<p>页面布局使用table标签。这点让我感觉非常新奇。</p>
<p>而且表格布局可以嵌套，也即每一行可以是一个新的表格。</p>
</li>
<li><p>图片适应屏幕宽度</p>
<p>只需在img标签加个width=”100%”的属性即可。如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/top_banner.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li><p>表项中的数据要被提交的话，必须指定其名称</p>
<p><img src="/2022/12/21/JavaWeb/image-20221223161847622.png" alt="image-20221223161847622"></p>
<p>也即一定要有属性name。</p>
</li>
<li><p>关于from的属性</p>
<p><img src="/2022/12/21/JavaWeb/image-20221223162035569.png" alt="image-20221223162035569"></p>
</li>
<li><p>一般都这么写</p>
<p><img src="/2022/12/21/JavaWeb/image-20221223165046277.png" alt="image-20221223165046277"></p>
</li>
</ol>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><img src="/2022/12/21/JavaWeb/image-20221223171603366.png" alt="image-20221223171603366"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>注册界面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>邮箱：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入邮箱&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;phone_number&quot;</span>&gt;</span>手机号：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;phone_number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;phone_number&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入手机号&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    性别：</span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>女</span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>男</span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span>出生日期：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">id</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;certification&quot;</span>&gt;</span>验证码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;certification&quot;</span> <span class="attr">id</span>=<span class="string">&quot;certification&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/verify_code.jpg&quot;</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./image/regbtn.jpg&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><h5 id="盒"><a href="#盒" class="headerlink" title="盒"></a>盒</h5><p><img src="/2022/12/21/JavaWeb/image-20221223204733649.png" alt="image-20221223204733649"></p>
<h4 id="练习：注册页面"><a href="#练习：注册页面" class="headerlink" title="练习：注册页面"></a>练习：注册页面</h4><p><img src="/2022/12/21/JavaWeb/image-20221223223128861.png" alt="image-20221223223128861"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>注册界面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./2.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_text1&quot;</span>&gt;</span></span><br><span class="line">            新用户注册</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_text2&quot;</span>&gt;</span></span><br><span class="line">            USER REGISTER</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_text3&quot;</span>&gt;</span></span><br><span class="line">        已有账号？<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span> = <span class="string">red</span>&gt;</span>立即登录<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_table&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入邮箱&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tel&quot;</span>&gt;</span>手机号<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入手机号&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;choice&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;choice&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span>出生日期<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">id</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入出生日期&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkcode&quot;</span> &gt;</span>验证码<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;checkcode&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkcode&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入验证码&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img_check&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img/verify_code.jpg&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="comment">/*防止大小因padding变化*/</span></span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;./img/login_bg.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#log_in_box</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">9px</span> solid darkgray;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">987px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">590px</span>;</span><br><span class="line">    <span class="comment">/*让div水平居中*/</span></span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#log_in_table</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">96px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#log_in_text3</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#log_in_text</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#log_in_text</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">color</span>: darkgray;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">17px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Arial Black&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#log_in_text</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">display</span>:inline;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*此处一定得是选择input，不能是选择.td_right，因为这样才能覆盖掉input原有的那个丑边框*/</span></span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid lightgrey;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="comment">/*解决了radio的选框和文本不对齐。*/</span></span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.td_left</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: slategrey;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.choice</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#checkcode</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#img_check</span>&#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#submit</span>&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">155px</span>;</span><br><span class="line">    <span class="attribute">color</span>: transparent;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;./img/regbtn.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><h5 id="function"><a href="#function" class="headerlink" title="function"></a>function</h5><pre><code>1. 创建：
   1. var fun = new Function(形式参数列表,方法体);  //忘掉吧
   2. function 方法名称(形式参数列表)&#123;
          方法体
      &#125;

   3. var 方法名 = function(形式参数列表)&#123;
           方法体
      &#125;
2. 方法：

3. 属性：
   length:代表形参的个数
4. 特点：
   1. 方法定义是，形参的类型不用写,返回值类型也不写。
   2. 方法是一个对象，如果定义名称相同的方法，会覆盖
   3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关
   4. 在方法声明中有一个隐藏的内置对象（数组），**arguments**,封装所有的实际参数
5. 调用：
   方法名称(实际参数列表);
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 求任意个数的和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> ()&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum += <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="title function_">alert</span>(sum);</span><br></pre></td></tr></table></figure>

<h5 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h5><ol>
<li><p>特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();</p>
</li>
<li><p>方法：<br>encodeURI():url编码<br>decodeURI():url解码</p>
<p>encodeURIComponent():url编码,编码的字符更多<br>decodeURIComponent():url解码</p>
<p>parseInt():将字符串转为数字</p>
<ul>
<li>逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number<br>isNaN():判断一个值是否是NaN<ul>
<li>NaN六亲不认，连自己都不认。NaN参与的==比较全部问false</li>
</ul>
</li>
</ul>
<p>eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;http://www.baidu.com?wd=传智播客&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> encode = <span class="built_in">encodeURI</span>(str);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(encode +<span class="string">&quot;&lt;br&gt;&quot;</span>);<span class="comment">//%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">decodeURI</span>(encode);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(s +<span class="string">&quot;&lt;br&gt;&quot;</span>);<span class="comment">//传智播客</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;http://www.baidu.com?wd=传智播客&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> encode1 = <span class="built_in">encodeURIComponent</span>(str1);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(encode1 +<span class="string">&quot;&lt;br&gt;&quot;</span>);<span class="comment">//%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">decodeURIComponent</span>(encode);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(s1 +<span class="string">&quot;&lt;br&gt;&quot;</span>);<span class="comment">//传智播客</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jscode = <span class="string">&quot;alert(123)&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span>(jscode);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p><img src="/2022/12/21/JavaWeb/image-20221224162341993.png" alt="image-20221224162341993"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221224162540306.png" alt="image-20221224162540306"></p>
<h5 id="document"><a href="#document" class="headerlink" title="document"></a>document</h5><h6 id="获取元素对象"><a href="#获取元素对象" class="headerlink" title="获取元素对象"></a>获取元素对象</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getElementById</span>();</span><br><span class="line"><span class="title function_">getElementsByTagName</span>();<span class="comment">//通过标签名</span></span><br><span class="line"><span class="title function_">getElementsByClassName</span>();</span><br><span class="line"><span class="title function_">getElementsByName</span>();<span class="comment">//注意是数组</span></span><br></pre></td></tr></table></figure>

<h6 id="创建DOM对象"><a href="#创建DOM对象" class="headerlink" title="创建DOM对象"></a>创建DOM对象</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">createAttribute</span>(name);</span><br><span class="line"><span class="title function_">createComment</span>();</span><br><span class="line"><span class="title function_">createElement</span>();</span><br><span class="line"><span class="title function_">createTextNode</span>();</span><br></pre></td></tr></table></figure>

<h5 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">removeAttribute</span>();</span><br><span class="line"><span class="title function_">setAttribute</span>(属性名,属性值);</span><br></pre></td></tr></table></figure>

<h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>说了树结构后，这个就好理解多了。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221224164239507.png" alt="image-20221224164239507"></p>
<h5 id="练习：动态表格"><a href="#练习：动态表格" class="headerlink" title="练习：动态表格"></a>练习：动态表格</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>动态表格<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#input</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">60%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">table</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">70%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入编号&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入性别&quot;</span> <span class="attr">id</span>=<span class="string">&quot;gender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add_but&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px solid black&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;table&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>学生信息表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//获取表对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> table = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;table&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//最后那列删除要用很多次，所以这里只写一份原始的，之后要用再copy del_col对象即可。</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//但是要注意，js的深拷贝 object.cloneNode(true)是不会拷贝事件绑定的</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//所以事件绑定不得不放在下面的函数里做了</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> del_col = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> del_col_a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        del_col_a.<span class="property">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        del_col_a.<span class="property">innerHTML</span>=<span class="string">&quot;删除&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        del_col.<span class="title function_">appendChild</span>(del_col_a);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//删除列</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">del_row</span>(<span class="params">obj</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> target = obj.<span class="property">parentNode</span>.<span class="property">parentNode</span>;</span></span><br><span class="line"><span class="language-javascript">            table.<span class="title function_">removeChild</span>(target);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//添加行</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">add_row</span>(<span class="params">id,name,gender</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (id==<span class="string">&quot;&quot;</span> || name==<span class="string">&quot;&quot;</span> || gender==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> row = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> col1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> col2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> col3 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            col1.<span class="property">innerHTML</span> = id;</span></span><br><span class="line"><span class="language-javascript">            col2.<span class="property">innerHTML</span> = name;</span></span><br><span class="line"><span class="language-javascript">            col3.<span class="property">innerHTML</span> = gender;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//为“删除”绑定事件</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> col4 = del_col.<span class="title function_">cloneNode</span>(<span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">            col4.<span class="property">lastChild</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//通过this定位。此时this指代a标签。</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//如果在del_row内把obj换成this反倒是不行的，因为那时候的this会指代的是window</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">del_row</span>(<span class="variable language_">this</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            row.<span class="title function_">appendChild</span>(col1);</span></span><br><span class="line"><span class="language-javascript">            row.<span class="title function_">appendChild</span>(col2);</span></span><br><span class="line"><span class="language-javascript">            row.<span class="title function_">appendChild</span>(col3);</span></span><br><span class="line"><span class="language-javascript">            row.<span class="title function_">appendChild</span>(col4);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            table.<span class="title function_">appendChild</span>(row);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//为“添加”按钮绑定事件</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;add_but&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">add_row</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id&quot;</span>).<span class="property">value</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>).<span class="property">value</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;gender&quot;</span>).<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>老师标答值得学习借鉴的点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用innerHTML添加</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn_add&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//2.获取文本框的内容</span></span><br><span class="line">    <span class="keyword">var</span> id = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id&quot;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">var</span> gender = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;gender&quot;</span>).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取table</span></span><br><span class="line">    <span class="keyword">var</span> table = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;table&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//追加一行</span></span><br><span class="line">    table.<span class="property">innerHTML</span> += <span class="string">&quot;&lt;tr&gt;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        &lt;td&gt;&quot;</span>+id+<span class="string">&quot;&lt;/td&gt;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        &lt;td&gt;&quot;</span>+name+<span class="string">&quot;&lt;/td&gt;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        &lt;td&gt;&quot;</span>+gender+<span class="string">&quot;&lt;/td&gt;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        &lt;td&gt;&lt;a href=\&quot;javascript:void(0);\&quot; onclick=\&quot;delTr(this);\&quot; &gt;删除&lt;/a&gt;&lt;/td&gt;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    &lt;/tr&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><h6 id="练习：全选-全不选-反选-行变色"><a href="#练习：全选-全不选-反选-行变色" class="headerlink" title="练习：全选/全不选/反选+行变色"></a>练习：全选/全不选/反选+行变色</h6><p><img src="/2022/12/21/JavaWeb/image-20221225192124809.png" alt="image-20221225192124809"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>动态表格<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#input</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">60%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">table</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">70%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入编号&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入性别&quot;</span> <span class="attr">id</span>=<span class="string">&quot;gender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add_but&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px solid black&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;table&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>选择<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Lily<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>female<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> &gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>male<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> &gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Peterson<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>male<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> &gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Mary<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>female<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> &gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;margin-top: 20px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;select_all&quot;</span> <span class="attr">value</span>=<span class="string">&quot;全选&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;select_none&quot;</span> <span class="attr">value</span>=<span class="string">&quot;全不选&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;select_aside&quot;</span> <span class="attr">value</span>=<span class="string">&quot;反选&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//行变色</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> rows = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;tr&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rows.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">            rows[i].<span class="property">onmouseover</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                rows[i].<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>,<span class="string">&quot;background: pink&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">            rows[i].<span class="property">onmouseout</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                rows[i].<span class="title function_">removeAttribute</span>(<span class="string">&quot;style&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//三个按钮</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> select_all = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;select_all&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> select_none = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;select_none&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> select_aside = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;select_aside&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> boxes = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;box&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        select_all.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxes.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                boxes[i].<span class="property">checked</span> = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        select_none.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxes.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                boxes[i].<span class="property">checked</span> = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        select_aside.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxes.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                boxes[i].<span class="property">checked</span> = !(boxes[i].<span class="property">checked</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="练习：表单校验"><a href="#练习：表单校验" class="headerlink" title="练习：表单校验"></a>练习：表单校验</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>注册界面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./2.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_text1&quot;</span>&gt;</span></span><br><span class="line">            新用户注册</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_text2&quot;</span>&gt;</span></span><br><span class="line">            USER REGISTER</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_text3&quot;</span>&gt;</span></span><br><span class="line">        已有账号？<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span> = <span class="string">red</span>&gt;</span>立即登录<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log_in_table&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入邮箱&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tel&quot;</span>&gt;</span>手机号<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入手机号&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;choice&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;choice&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span>出生日期<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">id</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入出生日期&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkcode&quot;</span> &gt;</span>验证码<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;td_right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;checkcode&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkcode&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入验证码&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img_check&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img/verify_code.jpg&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//在开始加载的时候绑定事件的好习惯</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;form&quot;</span>).<span class="property">onsubmit</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title function_">checkUsername</span>()&amp;&amp;<span class="title function_">checkPassword</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">onblur</span> = checkUsername;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password&quot;</span>).<span class="property">onblur</span> = checkPassword;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> password = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">checkUsername</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> reg_username = <span class="regexp">/^\w&#123;6,12&#125;$/</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> flag = reg_username.<span class="title function_">test</span>(username.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (flag)&#123;</span></span><br><span class="line"><span class="language-javascript">            username.<span class="property">parentNode</span>.<span class="property">parentNode</span>.<span class="property">lastElementChild</span>.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;img src=\&quot;./img/gou.png\&quot; alt=\&quot;\&quot;&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            username.<span class="property">parentNode</span>.<span class="property">parentNode</span>.<span class="property">lastElementChild</span>.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;font color=\&quot;red\&quot;&gt;格式错误！&lt;/font&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> flag;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">checkPassword</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> reg_username = <span class="regexp">/^\w&#123;6,12&#125;$/</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> flag = reg_username.<span class="title function_">test</span>(password.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (flag)&#123;</span></span><br><span class="line"><span class="language-javascript">            password.<span class="property">parentNode</span>.<span class="property">parentNode</span>.<span class="property">lastElementChild</span>.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;img src=\&quot;./img/gou.png\&quot; alt=\&quot;\&quot;&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            password.<span class="property">parentNode</span>.<span class="property">parentNode</span>.<span class="property">lastElementChild</span>.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;font color=\&quot;red\&quot;&gt;格式错误！&lt;/font&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> flag;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><p>浏览器对象模型，将浏览器各个组成部分封装成对象。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221224152804747.png" alt="image-20221224152804747"></p>
<p>Window对象包含DOM对象。</p>
<p>组成：Window、Navigator、Screen、History、Location</p>
<h5 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h5><p>不需要创建，直接用window.使用，也可以直接用方法名。比如alert</p>
<h6 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h6><ol>
<li><p>与弹出有关的方法</p>
<p>alert：弹出警告框； confirm：确认取消对话框。确定返回true；prompt：输入框。参数为输入提示，返回值为输入值。</p>
</li>
<li><p>与开关有关的方法</p>
<p>close：关闭<strong>调用的window对象</strong>的浏览器窗口；open：打开新窗口，可传入URL，返回新的window对象</p>
</li>
<li><p>定时器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只执行一次</span></span><br><span class="line"><span class="built_in">setTimeout</span>();</span><br><span class="line"><span class="built_in">clearTimeout</span>();</span><br><span class="line"><span class="comment">//间隔执行多次</span></span><br><span class="line"><span class="built_in">setInterval</span>();</span><br><span class="line"><span class="built_in">clearInterval</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一次性定时器</span></span><br><span class="line"><span class="comment">//setTimeout(&quot;fun();&quot;,2000);</span></span><br><span class="line"><span class="keyword">var</span> id = <span class="built_in">setTimeout</span>(fun,<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//取消</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(id);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;boom~~&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环定时器</span></span><br><span class="line"><span class="keyword">var</span> id = <span class="built_in">setInterval</span>(fun,<span class="number">2000</span>);</span><br><span class="line"><span class="built_in">clearInterval</span>(id);</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><ol>
<li><p>获取其他BOM对象</p>
<p>history、location、navigator、screen</p>
</li>
<li><p>获取DOM对象</p>
<p>document</p>
</li>
</ol>
<h6 id="练习：轮播图"><a href="#练习：轮播图" class="headerlink" title="练习：轮播图"></a>练习：轮播图</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>轮播图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/banner_1.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">id</span>=<span class="string">&quot;picture&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> pictures = [<span class="string">&quot;./img/banner_1.jpg&quot;</span>,<span class="string">&quot;./img/banner_2.jpg&quot;</span>,<span class="string">&quot;./img/banner_3.jpg&quot;</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> i = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;picture&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">change_picture</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        img.<span class="property">src</span> = pictures[(++i)%<span class="number">3</span>];</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setInterval</span>(change_picture,<span class="number">2000</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h5><ol>
<li><p>刷新</p>
<p>location.reload方法</p>
</li>
<li><p>设置或返回完整的url</p>
<p>location.href属性</p>
</li>
</ol>
<h6 id="练习：自动返回首页"><a href="#练习：自动返回首页" class="headerlink" title="练习：自动返回首页"></a>练习：自动返回首页</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>自动跳转<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 235px; height: 100px; margin: auto&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span> <span class="attr">id</span>=<span class="string">&quot;second&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">span</span>&gt;</span>秒后，自动跳转首页</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> num = <span class="number">5</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> second = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;second&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">dao_ji_shi</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                location.<span class="property">href</span> = <span class="string">&quot;https://www.baidu.com/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="built_in">clearInterval</span>(id);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            second.<span class="property">innerHTML</span> = (num--);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> id = <span class="built_in">setInterval</span>(dao_ji_shi,<span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><p>web前端框架</p>
<p><img src="/2022/12/21/JavaWeb/image-20221225160246028.png" alt="image-20221225160246028"></p>
<h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p><img src="/2022/12/21/JavaWeb/image-20221225161243229.png" alt="image-20221225161243229"></p>
<p>基本模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap 101 Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;./css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>实现依赖于栅格系统。</p>
<h4 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h4><p>将一行平均分成12个格子，可以指定元素占几个格子</p>
<p>可以感受到，其实跟我们之前那个纯纯HTML做页面的思想是差不多的，都是把整个页面看做一个表，表有很多行，每行有不同的格子。</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><ol>
<li>定义容器。相当于之前的table</li>
</ol>
<ul>
<li><p><strong>容器分类</strong>：</p>
<ol>
<li>container：两边留白</li>
<li>container-fluid：每一种设备都是100%宽度</li>
</ol>
</li>
</ul>
<ol start="2">
<li>定义行。相当于之前的tr   <strong>样式：row</strong></li>
<li>定义元素。指定该元素在不同的设备上，所占的格子数目。样式：<strong>col-设备代号-格子数目</strong></li>
</ol>
<ul>
<li><p>设备代号：</p>
<ol>
<li>xs：超小屏幕 手机 (&lt;768px)：col-xs-12</li>
<li>sm：小屏幕 平板 (≥768px)</li>
<li>md：中等屏幕 桌面显示器 (≥992px)</li>
<li>lg：大屏幕 大桌面显示器 (≥1200px)</li>
</ol>
</li>
</ul>
<h5 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap HelloWorld<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.2.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.定义容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--2.定义行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--3.定义元素</span></span><br><span class="line"><span class="comment">                在大显示器一行12个格子</span></span><br><span class="line"><span class="comment">                在pad上一行6个格子</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--超出12个格子的部分自动换行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-1 col-sm-2 inner&quot;</span>&gt;</span>栅格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>看文档。</p>
<h3 id="练习：用bootstrap优化旅游网站首页"><a href="#练习：用bootstrap优化旅游网站首页" class="headerlink" title="练习：用bootstrap优化旅游网站首页"></a>练习：用bootstrap优化旅游网站首页</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap 101 Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;./css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./3.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/top_banner.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img-responsive&quot;</span> <span class="attr">id</span>=<span class="string">&quot;top&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span> <span class="attr">id</span>=<span class="string">&quot;top_2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-3&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/logo.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img-responsive&quot;</span> <span class="attr">id</span>=<span class="string">&quot;logo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6&quot;</span> <span class="attr">id</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search&quot;</span> <span class="attr">id</span>=<span class="string">&quot;search_text&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;search_but&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-3&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/hotel_tel.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;hotel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar navbar-default&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Brand and toggle get grouped for better mobile display --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;navbar-header&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navbar-toggle collapsed&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;collapse&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#bs-example-navbar-collapse-1&quot;</span> <span class="attr">aria-expanded</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span>&gt;</span>Toggle navigation<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;icon-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;icon-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;icon-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;navbar-brand&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>传智播客<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Collect the nav links, forms, and other content for toggling --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;collapse navbar-collapse&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bs-example-navbar-collapse-1&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav navbar-nav&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Android <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span>&gt;</span>(current)<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Android<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Android<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Android<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Android<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Android<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Android<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- /.navbar-collapse --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- /.container-fluid --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--  轮播图--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;carousel-example-generic&quot;</span> <span class="attr">class</span>=<span class="string">&quot;carousel slide&quot;</span> <span class="attr">data-ride</span>=<span class="string">&quot;carousel&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Indicators --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">&quot;carousel-indicators&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-target</span>=<span class="string">&quot;#carousel-example-generic&quot;</span> <span class="attr">data-slide-to</span>=<span class="string">&quot;0&quot;</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-target</span>=<span class="string">&quot;#carousel-example-generic&quot;</span> <span class="attr">data-slide-to</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-target</span>=<span class="string">&quot;#carousel-example-generic&quot;</span> <span class="attr">data-slide-to</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- Wrapper for slides --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-inner&quot;</span> <span class="attr">role</span>=<span class="string">&quot;listbox&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        注意只能有其中一张的class是active的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item active&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/banner_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-caption&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/banner_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-caption&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/banner_3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel-caption&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- Controls --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;left carousel-control&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#carousel-example-generic&quot;</span> <span class="attr">role</span>=<span class="string">&quot;button&quot;</span> <span class="attr">data-slide</span>=<span class="string">&quot;prev&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;glyphicon glyphicon-chevron-left&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span>&gt;</span>Previous<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;right carousel-control&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#carousel-example-generic&quot;</span> <span class="attr">role</span>=<span class="string">&quot;button&quot;</span> <span class="attr">data-slide</span>=<span class="string">&quot;next&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;glyphicon glyphicon-chevron-right&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span>&gt;</span>Next<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/icon_5.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;亲子周边旅游节&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text1&quot;</span>&gt;</span>黑马精选<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row block&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xuanchuan col-md-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xuanchuan col-md-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xuanchuan col-md-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xuanchuan col-md-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/icon_6.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;亲子周边旅游节&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text1&quot;</span>&gt;</span>国内游<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/guonei_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;亲子周边旅游节&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xuanchuan col-md-4&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xuanchuan col-md-4&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xuanchuan col-md-4&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xuanchuan col-md-4&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xuanchuan col-md-4&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xuanchuan col-md-4&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/jiangxuan_1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">br</span>&gt;</span>上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">3</span> <span class="attr">color</span>=<span class="string">&quot;#8b0000&quot;</span>&gt;</span>￥899<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/footer_service.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img-responsive&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foot_text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;gray&quot;</span> <span class="attr">size</span> = <span class="string">2</span>&gt;</span>江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018<span class="symbol">&amp;copy;</span>, All Rights Reserved 苏ICP备16007882<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./jquery-3.2.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#search</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#top_2</span>&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#search_text</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid orange;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#search_but</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">background</span>: orange;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">vertical-align</span>: top;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">13px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#search_but</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text1</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hr&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid orange;</span><br><span class="line">    <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.xuanchuan</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">244px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid dimgray;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.xuanchuan</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#foot_text</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: orange;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.row</span>&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h4><p>这东西写了我还挺久的。。。不过收获也挺多。</p>
<ol>
<li><p>text-align</p>
<p>是一个css属性，我觉得挺好用的（。我不知道它精确是什么意思，但我发现它好像有种能让该元素下的子元素水平居中的效果。</p>
</li>
<li><p>关于“容器”的理解</p>
<p>上面说过，Bootstrap有个容器的概念，跟我们上面纯HTML的表格概念其实是很类似的。</p>
<p>HTML的容器是表格标签，Bootsrap的容器是container-fluid和container类的标签。</p>
<p>与HTML的表格相同，“容器”也是可以嵌套的。这点在本案例体现为一下两点：</p>
<p>① container中可以嵌套container-fluid。</p>
<p>​    案例中，页首-轮播图和页尾这两段是两边不留白的，轮播图-页尾这段是两边留白的。所以，我们就可以让整体为一个container容器，中间一段再用container-fluid容器包装起来。也即：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，此处不要作死为了优雅统一性这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也即多加一个row类。要不row的属性会覆盖掉container的。</p>
<p>② 对于“col-md-4”这些的理解</p>
<p><img src="/2022/12/21/JavaWeb/image-20221225183910393.png" alt="image-20221225183910393"></p>
<p>在做这样的包含row-span元素的行时，之前的解决方案是采用表格嵌套。同样的，这里也可以采用容器嵌套。而此时，列的书写方式就比较特殊了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span></span><br><span class="line">       row-span的图片</span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-8&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实是非常直观的，相信以后你看到这段应该也能理解（。提示一点，栅格系统其实好像是相对于父类的。也就是说，不是“把整个页面分成12个格子”，而是，“把父类占有的空间分成12个格子”。</p>
</li>
<li><p>关于hr标签</p>
<p>使用css改颜色时应该写<code>background: orange;</code>而不是<code>color: orange;</code>。</p>
</li>
</ol>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>xml叫做可扩展标签语言。它的全部标签都是自定义的。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221225220356932.png" alt="image-20221225220356932"></p>
<h3 id="快速入门-2"><a href="#快速入门-2" class="headerlink" title="快速入门"></a>快速入门</h3><ul>
<li>基本语法：<pre><code>  1. xml文档的后缀名 .xml
  2. xml第一行必须定义为文档声明
  3. xml文档中有且仅有一个根标签
  4. 属性值必须使用引号(单双都可)引起来
  5. 标签必须正确关闭
  6. xml标签名称区分大小写
</code></pre>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="细说"><a href="#细说" class="headerlink" title="细说"></a>细说</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><h5 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h5><p>常见属性：version[必须]、encoding、standalone[取值为yes和no，yes为依赖其他文件]</p>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><p>id属性值唯一</p>
<h5 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h5><p><img src="/2022/12/21/JavaWeb/image-20221225222029698.png" alt="image-20221225222029698"></p>
<p>这种要转义来转义去的显然很麻烦。所以就需要用到CDATA区。</p>
<p>CDATA区的文本会被原样展示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">            if(1 == 1 &amp;&amp; 2 == 2)&#123;&#125;</span><br><span class="line">    ]]&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="约束-1"><a href="#约束-1" class="headerlink" title="约束"></a>约束</h4><p>只能写约束文件内的标签</p>
<h5 id="dtd"><a href="#dtd" class="headerlink" title="dtd"></a>dtd</h5><h6 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//students标签里可以包含若干个student标签</span><br><span class="line">&lt;!ELEMENT students (student*) &gt;</span><br><span class="line">//student标签必须按顺序出现name，age，sex标签</span><br><span class="line">&lt;!ELEMENT student (name,age,sex)&gt;</span><br><span class="line">//name、age、sex都为字符串类型</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT age (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sex (#PCDATA)&gt;</span><br><span class="line">//student标签有一个属性叫number，类型为ID,并且必须要有。类型为ID表示该属性值唯一。</span><br><span class="line">&lt;!ATTLIST student number ID #REQUIRED&gt;</span><br></pre></td></tr></table></figure>

<h6 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//外部引入</span><br><span class="line">&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;</span><br><span class="line">&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>或者可以直接在xml内部写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">students</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;student.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">students</span> [</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		<span class="meta">&lt;!ELEMENT <span class="keyword">students</span> (<span class="keyword">student</span>+) &gt;</span></span></span><br><span class="line"><span class="meta">		<span class="meta">&lt;!ELEMENT <span class="keyword">student</span> (<span class="keyword">name</span>,<span class="keyword">age</span>,<span class="keyword">sex</span>)&gt;</span></span></span><br><span class="line"><span class="meta">		<span class="meta">&lt;!ELEMENT <span class="keyword">name</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">		<span class="meta">&lt;!ELEMENT <span class="keyword">age</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">		<span class="meta">&lt;!ELEMENT <span class="keyword">sex</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">		<span class="meta">&lt;!ATTLIST <span class="keyword">student</span> <span class="keyword">number</span> <span class="keyword">ID</span> <span class="keyword">#REQUIRED</span>&gt;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;s001&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">age</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sex</span>&gt;</span>hehe<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;s002&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>lisi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sex</span>&gt;</span>female<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;s001&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">age</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">sex</span>&gt;</span>hehe<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;s002&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>lisi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">sex</span>&gt;</span>female<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h5><h6 id="文档-1"><a href="#文档-1" class="headerlink" title="文档"></a>文档</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.itcast.cn/xml&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.itcast.cn/xml&quot;</span> <span class="attr">elementFormDefault</span>=<span class="string">&quot;qualified&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;students&quot;</span> <span class="attr">type</span>=<span class="string">&quot;studentsType&quot;</span>/&gt;</span></span><br><span class="line">    //定义类型</span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;studentsType&quot;</span>&gt;</span></span><br><span class="line">        //类型里面有有序序列</span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">type</span>=<span class="string">&quot;studentType&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;studentType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ageType&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">type</span>=<span class="string">&quot;sexType&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span> <span class="attr">type</span>=<span class="string">&quot;numberType&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;sexType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">            //枚举类型</span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;ageType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:integer&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:minInclusive</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:maxInclusive</span> <span class="attr">value</span>=<span class="string">&quot;256&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">&quot;numberType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">            //正则匹配</span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:pattern</span> <span class="attr">value</span>=<span class="string">&quot;heima_\d&#123;4&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<h6 id="引入方式-1"><a href="#引入方式-1" class="headerlink" title="引入方式"></a>引入方式</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	1.填写xml文档的根元素</span></span><br><span class="line"><span class="comment">	2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line"><span class="comment">	3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;</span></span><br><span class="line"><span class="comment">	4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot; </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">xmlns</span>=<span class="string">&quot;http://www.itcast.cn/xml&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.itcast.cn/xml  student.xsd&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;heima_0001&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>tom<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它这意识就是，每个schema文件都要起一个别名，比如<code>xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;</code>这行代码实际上就是把<code>student.xsd</code>的别名起为了<code>http://www.itcast.cn/xml</code>。</p>
<p>为什么要起名呢？这就类似于命名空间这种东西，你要用到一个标签需要指明这个标签从哪来的，比如<code>std::vector</code>，<code>Class.toString</code>这种。这种命名空间在xml里叫前缀。所以，实际上完整写法应该是<code>&lt;http://www.itcast.cn/xml:students&gt;</code>。</p>
<p>但这样显然太麻烦了，别名一般都是这种网址，写起来太长了。所以我们选择给别名起别名，设置方法为<code>xmlns:a=&quot;http://www.itcast.cn/xml&quot;</code>，这样一来，以后就不用写<code>&lt;http://www.itcast.cn/xml:students&gt;</code>，只用写<code>&lt;a:students&gt;</code>了。</p>
<p>但是如果每个都写一个前缀还是有点难顶。所以就引入了一个空前缀。这样写<code>&lt;students&gt;</code>这样没有前缀的标签，就相当于从空前缀那个命名空间里拿出来的了。当然如果有多个命名空间，还是得区分一下的。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><img src="/2022/12/21/JavaWeb/image-20221225234106078.png" alt="image-20221225234106078"></p>
<p>解析方式有两种方法。</p>
<h5 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h5><h6 id="DOM-1"><a href="#DOM-1" class="headerlink" title="DOM"></a>DOM</h6><p>将标记语言文档一次性加载进内存，形成DOM树</p>
<p>操作方便，可以进行CRUD所有操作；但占内存</p>
<h6 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h6><p>逐行读取，基于事件驱动</p>
<p>不占内存；但只能读取</p>
<h5 id="解析工具"><a href="#解析工具" class="headerlink" title="解析工具"></a>解析工具</h5><p><img src="/2022/12/21/JavaWeb/image-20221225234649287.png" alt="image-20221225234649287"></p>
<p>主要学习Jsoup。</p>
<h6 id="快速入门-3"><a href="#快速入门-3" class="headerlink" title="快速入门"></a>快速入门</h6><p><img src="/2022/12/21/JavaWeb/image-20221225234813135.png" alt="image-20221225234813135"></p>
<p>跟前面html的DOM是差不多的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsoupDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取Document对象，根据xml文档</span></span><br><span class="line">        <span class="comment">//解析xml文档（加载进内存且获取dom树）</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(JsoupDemo.class.getClassLoader()</span><br><span class="line">                .getResource(<span class="string">&quot;student.xml&quot;</span>).getPath()),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//获取元素对象</span></span><br><span class="line">        <span class="comment">//Elements extends ArrayList&lt;Element&gt;</span></span><br><span class="line">        <span class="type">Elements</span> <span class="variable">ele</span> <span class="operator">=</span> doc.getElementsByTag(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//获取元素里的数据</span></span><br><span class="line">        System.out.println(ele.get(<span class="number">0</span>).text());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="细说-1"><a href="#细说-1" class="headerlink" title="细说"></a>细说</h6><ol>
<li><p>Jsoup：工具类，可以解析html或xml文档，返回Document</p>
<ul>
<li>parse：解析html或xml文档，返回Document<ul>
<li>parse(File in, String charsetName)：解析xml或html文件的。</li>
<li>parse(String html)：解析xml或html字符串</li>
<li>parse(URL url, int timeoutMillis)：通过<strong>网络路径</strong>获取指定的html或xml的文档对象</li>
</ul>
</li>
</ul>
</li>
<li><p>Document：文档对象。代表内存中的dom树</p>
<ul>
<li>获取Element对象<ul>
<li>getElementById(String id)：根据id属性值获取唯一的element对象</li>
<li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li>
<li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li>
<li>getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合</li>
</ul>
</li>
</ul>
</li>
<li><p>Elements：元素Element对象的集合。可以当做 ArrayList<Element>来使用</Element></p>
</li>
<li><p>Element：元素对象</p>
<ol>
<li>获取子元素对象 </li>
</ol>
<p>   这一点很好理解。因为Document和Element对象的获取元素方法都继承自Node结点，本意就是获取子元素对象。只不过Document是根节点，所以就变成了获取所有元素对象。</p>
<ul>
<li>getElementById(String id)：根据id属性值获取唯一的element对象</li>
<li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li>
<li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li>
<li>getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合</li>
</ul>
<ol start="2">
<li>获取属性值</li>
</ol>
<ul>
<li>String attr(String key)：根据属性名称获取属性值</li>
</ul>
<ol start="3">
<li>获取文本内容</li>
</ol>
<ul>
<li>String text():获取字标签的<strong>所有纯文本</strong>内容</li>
<li>String html():获取标签体的所有内容(包括<strong>字标签</strong>的字符串内容)</li>
</ul>
</li>
<li><p>Node：节点对象</p>
<ul>
<li>是Document和Element的父类</li>
</ul>
</li>
</ol>
<h6 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h6><ol>
<li><p>使用选择器selector</p>
<p>其实语法格式跟css的那个选择器差不多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *选择器查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsoupDemo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取student.xml的path</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> JsoupDemo5.class.getClassLoader().getResource(<span class="string">&quot;student.xml&quot;</span>).getPath();</span><br><span class="line">        <span class="comment">//2.获取Document对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(path), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.查询name标签</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            div&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Elements</span> <span class="variable">elements</span> <span class="operator">=</span> document.select(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(elements);</span><br><span class="line">        System.out.println(<span class="string">&quot;=----------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4.查询id值为itcast的元素</span></span><br><span class="line">        <span class="type">Elements</span> <span class="variable">elements1</span> <span class="operator">=</span> document.select(<span class="string">&quot;#itcast&quot;</span>);</span><br><span class="line">        System.out.println(elements1);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">        <span class="comment">//5.获取student标签并且number属性值为heima_0001的age子标签</span></span><br><span class="line">        <span class="comment">//5.1.获取student标签并且number属性值为heima_0001</span></span><br><span class="line">        <span class="type">Elements</span> <span class="variable">elements2</span> <span class="operator">=</span> document.select(<span class="string">&quot;student[number=\&quot;heima_0001\&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(elements2);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.2获取student标签并且number属性值为heima_0001的age子标签</span></span><br><span class="line">        <span class="type">Elements</span> <span class="variable">elements3</span> <span class="operator">=</span> document.select(<span class="string">&quot;student[number=\&quot;heima_0001\&quot;] &gt; age&quot;</span>);</span><br><span class="line">        System.out.println(elements3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用XPath</p>
<p>XPath：xml路径语言。</p>
<p><a href="http://www.51gjie.com/java/747.html">XPath API文档</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *XPath查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsoupDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, XpathSyntaxErrorException &#123;</span><br><span class="line">        <span class="comment">//1.获取student.xml的path</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> JsoupDemo6.class.getClassLoader().getResource(<span class="string">&quot;student.xml&quot;</span>).getPath();</span><br><span class="line">        <span class="comment">//2.获取Document对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(path), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.根据document对象，创建JXDocument对象</span></span><br><span class="line">        <span class="type">JXDocument</span> <span class="variable">jxDocument</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JXDocument</span>(document);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.结合xpath语法查询</span></span><br><span class="line">        <span class="comment">//4.1查询所有student标签</span></span><br><span class="line">        List&lt;JXNode&gt; jxNodes = jxDocument.selN(<span class="string">&quot;//student&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (JXNode jxNode : jxNodes) &#123;</span><br><span class="line">            System.out.println(jxNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.2查询所有student标签下的name标签</span></span><br><span class="line">        List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(<span class="string">&quot;//student/name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (JXNode jxNode : jxNodes2) &#123;</span><br><span class="line">            System.out.println(jxNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.3查询student标签下带有id属性的name标签</span></span><br><span class="line">        List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(<span class="string">&quot;//student/name[@id]&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (JXNode jxNode : jxNodes3) &#123;</span><br><span class="line">            System.out.println(jxNode);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast</span></span><br><span class="line"></span><br><span class="line">        List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(<span class="string">&quot;//student/name[@id=&#x27;itcast&#x27;]&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (JXNode jxNode : jxNodes4) &#123;</span><br><span class="line">            System.out.println(jxNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第四部分-JavaWeb核心"><a href="#第四部分-JavaWeb核心" class="headerlink" title="第四部分 JavaWeb核心"></a>第四部分 JavaWeb核心</h1><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><img src="/2022/12/21/JavaWeb/image-20221226154531990.png" alt="image-20221226154531990"></p>
<p>Tomcat是Java相关的web服务器软件。</p>
<h4 id="tomcat目录结构"><a href="#tomcat目录结构" class="headerlink" title="tomcat目录结构"></a>tomcat目录结构</h4><p><img src="/2022/12/21/JavaWeb/image-20221226155107723.png" alt="image-20221226155107723"></p>
<p><img src="/2022/12/21/JavaWeb/image-20221226155143920.png" alt="image-20221226155143920">启动</p>
<h4 id="启动时出现的问题"><a href="#启动时出现的问题" class="headerlink" title="启动时出现的问题"></a>启动时出现的问题</h4><p><strong>省流</strong>：看系统环境变量有没有CATALINA_HOME这一项，并且看这个CATALINA_HOME的值是否与当前版本安装路径相符合。</p>
<p>我电脑上本来也有了一个tomcat，只不过跟老师版本不一样。我把这两个都安到同一个目录了。然后我启动了老师版本，却发现输入localhost:8080没有任何响应。我首先去看了一下tomcat的config下的server.xml，发现端口号确实是8080没问题。然后试图访问localhost，发现没有响应，故推测是此处发生了问题。因而我上网按照该教程做了一遍：</p>
<p><a href="https://blog.csdn.net/weixin_45773603/article/details/104559570">127.0.0.1 拒绝了我们的连接请求–访问本地IP时显示拒绝访问</a></p>
<p>我重启电脑后，再次启动老师版本，发现还是不行。这时我开始怀疑是否我的tomcat没有正常启动，或者是否是因为8080这个端口号冲突了。所以我又找了一下如何查看端口号占用情况：</p>
<p><a href="http://www.taici.com/xuanchuankouhao/86121.html">如何查看端口号是否被占用</a></p>
<p>用<code>netstat -a</code>命令即可。我便发现，在我开着tomcat的情况下，8080这个端口没有被使用。说明好像启动不大正常。于是我打开了另一篇回答：</p>
<p><a href="https://www.zhihu.com/question/552679375">tomcat 启动了，为什么没打开 8080 端口？</a></p>
<p>按照它说的去查看日志文件。发现老师版本的tomcat下的log目录为空。我就去我本安装的版本下的log目录去看了，惊奇地发现，原来我在使用老师版本的tomcat时，tomcat用的是老版本的log目录。也就是说，很有可能config目录也是用的老版本的。我去查看老版本的config，发现端口是8888。于是我把老师版本的tomcat卸载了，去访问localhost:8888，成功力。</p>
<p>我探寻了以下原因，发现tomcat的startup里面如此写道：</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> &quot;<span class="variable">%CATALINA_HOME%</span>&quot; == &quot;&quot; <span class="keyword">goto</span> gotHome</span><br><span class="line">:gotHome</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">exist</span> &quot;<span class="variable">%CATALINA_HOME%</span>\bin\catalina.bat&quot; <span class="keyword">goto</span> okHome</span><br><span class="line">:okHome</span><br><span class="line"><span class="comment">rem ....</span></span><br><span class="line"><span class="keyword">call</span> &quot;<span class="variable">%EXECUTABLE%</span>&quot; <span class="built_in">start</span> <span class="variable">%CMD_LINE_ARGS%</span></span><br><span class="line">:end</span><br></pre></td></tr></table></figure>

<p>这一段大概是在找到tomcat这个软件的位置。如果我们在环境变量里面设置了CATALINA_HOME，那么就会直接把软件位置定位到CATALINA_HOME的值的地方，随后之后的逻辑都在那边执行。</p>
<p>我发现我确实设置了这个CATALINA_HOME，并且：</p>
<p><img src="/2022/12/21/JavaWeb/image-20221226170930763.png" alt="image-20221226170930763"></p>
<p>它的值是我电脑原本有的老版本的目录！</p>
<p>故而，这也就说明了为什么老师的版本不去用自己的log，不去用自己的config，而用的是我电脑上的老版本的log，config了。。。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221226172653916.png" alt="image-20221226172653916"></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul>
<li><p>部署项目的方式：</p>
<ol>
<li><p>直接将项目放到webapps目录下即可。    * /hello：项目的访问路径–&gt;虚拟目录    * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。</p>
<ul>
<li>war包会自动解压缩</li>
</ul>
</li>
<li><p>配置conf/server.xml文件<br> 在<code>&lt;Host&gt;</code>标签体中配置<br> <code>&lt;Context docBase=&quot;C:\aWorkSpace\Projects\Java\JavaWeb&quot; path=&quot;/web&quot; /&gt;</code></p>
</li>
</ol>
<pre><code>然后之后访问时输入`localhost/web/JavaWeb.html`即可

* docBase:项目存放的路径
* path：虚拟目录
</code></pre>
<ol start="3">
<li>在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写<br> <code>&lt;Context docBase=&quot;C:\aWorkSpace\Projects\Java\JavaWeb&quot; /&gt;</code><ul>
<li>虚拟目录：xml文件的名称</li>
</ul>
</li>
</ol>
<pre><code>注意，该方法是热部署的。也就是说，可以不关闭服务器的情况下，去增删xml文件，会马上变化，而不是像上面两种方式一样重启生效。
</code></pre>
</li>
</ul>
<h4 id="动态项目目录结构"><a href="#动态项目目录结构" class="headerlink" title="动态项目目录结构"></a>动态项目目录结构</h4><p>项目都存放在webapp里。打开webapp中的任一个。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221226221811747.png" alt="image-20221226221811747"></p>
<p>WEB-INF下是动态资源，也就是Java控制的一些文件【大概这个意思】。有这个文件夹的项目是动态项目。</p>
<p>WEB-INF以外的都是静态资源。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221226221933346.png" alt="image-20221226221933346"></p>
<h4 id="tomcat集成到IDEA"><a href="#tomcat集成到IDEA" class="headerlink" title="tomcat集成到IDEA"></a>tomcat集成到IDEA</h4><h5 id="使用maven创建Web项目"><a href="#使用maven创建Web项目" class="headerlink" title="使用maven创建Web项目"></a>使用maven创建Web项目</h5><h6 id="更换maven镜像源"><a href="#更换maven镜像源" class="headerlink" title="更换maven镜像源"></a>更换maven镜像源</h6><p><a href="https://blog.csdn.net/qq_49172635/article/details/127761526">idea中Maven镜像源详细配置步骤（对所有项目）</a></p>
<h6 id="创造项目"><a href="#创造项目" class="headerlink" title="创造项目"></a>创造项目</h6><p><img src="/2022/12/21/JavaWeb/image-20221226235520519.png" alt="image-20221226235520519"></p>
<p>然后等着它开始下载就行了。</p>
<p>最后的目录结构：</p>
<p><img src="/2022/12/21/JavaWeb/image-20221226235607604.png" alt="image-20221226235607604"></p>
<p>如果java或者resources目录没有，自己建就行。</p>
<h5 id="加入tomcat"><a href="#加入tomcat" class="headerlink" title="加入tomcat"></a>加入tomcat</h5><p>1.</p>
<p><a href="https://blog.csdn.net/m0_62976227/article/details/128450916?spm=1001.2014.3001.5501">TOMCAT -＞ IDEA</a></p>
<p>2.</p>
<p>还有另一种更便捷的方式，就是直接添加maven的tomcat插件。在pom.xml文件里加入此段：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>即可，可用alt+insert自动补全。</p>
<p>这里我出现了一个飘红报错问题，用这个可以解决：</p>
<p><a href="https://blog.csdn.net/clover_oreo/article/details/128338117">maven学习 &amp; Plugin ‘org.apache.tomcat.maven:tomcat7-maven-plugin:2.2’ not found报错解决【问题及解决过程记录】</a></p>
<p>然后，右键项目就可以run了：</p>
<p><img src="/2022/12/21/JavaWeb/image-20221227003805955.png" alt="image-20221227003805955"></p>
<p>如果没有此选项，就去下载maven helper插件。</p>
<h5 id="修改tomcat配置参数"><a href="#修改tomcat配置参数" class="headerlink" title="修改tomcat配置参数"></a>修改tomcat配置参数</h5><h6 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h6><p>run-edit configuration-tomcat</p>
<h6 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h6><p><img src="/2022/12/21/JavaWeb/image-20221230221339275.png" alt="image-20221230221339275"></p>
<p>启动服务器时控制台前几句输出有一句这样的。对应目录下的就可以找到tomcat配置文件。</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>server applet运行在服务器端的小程序</p>
<p>servlet是java编写的服务器端的程序，运行在web服务器中。作用：接收用户端发来的请求，调用其他java程序来处理请求，将处理结果返回到服务器中 </p>
<p><img src="/2022/12/21/JavaWeb/image-20221227154053743.png" alt="image-20221227154053743"></p>
<p>servlet是接口，定义了Java类被tomcat执行、被浏览器访问的规则。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221227154222612.png" alt="image-20221227154222612"></p>
<h3 id="快速入门-4"><a href="#快速入门-4" class="headerlink" title="快速入门"></a>快速入门</h3><p><img src="/2022/12/21/JavaWeb/image-20221227154841102.png" alt="image-20221227154841102"></p>
<p>这里的配置用的是注解，具体原理在第一部分的JavaSE基础里有详细描述了。</p>
<blockquote>
<p>使用maven创建web项目见上面的tomcat-tomcat集成到IDEA-使用maven创建web项目</p>
</blockquote>
<blockquote>
<p>如果已经导入依赖坐标却还未生效，就点击右侧侧边栏的maven刷新。</p>
<p><a href="https://blog.csdn.net/qq_44939973/article/details/108718028">Maven导入依赖后还不出现Servlet的问题</a></p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4><ul>
<li>执行原理：<ol>
<li>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</li>
<li>查找web.xml文件，是否有对应的<url-pattern>标签体内容。</url-pattern></li>
<li>如果有，则在找到对应的<servlet-class>全类名【注意：在下面，url-pattern都使用注解配置方法了，所以这两步应该是不用了，应该会变成这样：① 逐个遍历注册的servlet实现类，查看其注解属性是否为对应的url-pattern。② 如果有，则找到类名，步骤继续】</servlet-class></li>
<li>tomcat会将字节码文件加载进内存，并且创建其对象</li>
<li>调用其方法</li>
</ol>
</li>
</ul>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="/2022/12/21/JavaWeb/image-20221227161516964.png" alt="image-20221227161516964"></p>
<h4 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h4><p>Servlet的init方法只执行一次，一种Servlet在内存中只存在一个对象，Servlet是单例的。因而，当多线程同时访问同一个Servlet对象时，就会产生线程安全问题。所以有需要的话，就要采取手段保障Servlet类的线程安全性。</p>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>为了简化开发，我们可以用提供的servlet的实现类。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221227163713317.png" alt="image-20221227163713317"></p>
<h4 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h4><p>除了service方法之外的方法，差不多都只做了空实现。所以只需写service方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servletdemo2</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h4><h5 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h5><p>比如httpservlet，就只用重写里面的doGet和doPost两个方法就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servletdemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两个方法的区别就是，当使用get方式提交表单，就会执行第一个方法；使用post则会执行第二个方法。</p>
<p>比方说post时：</p>
<p>网页代码如下（放在webapp目录下）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello,World!</span><br><span class="line">    <span class="comment">&lt;!--  action内写Servlet的资源路径  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/webdemo4_war/demo2&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>servlet代码同上。</p>
<p>最终在网页中点击提交</p>
<p><img src="/2022/12/21/JavaWeb/image-20221230172048250.png" alt="image-20221230172048250"></p>
<p>会跳转到\demo页面【也即servlet的访问路径】，并且在console打印“post!!!”</p>
<blockquote>
<p>为啥会这样呢？</p>
<p>之前在讲表单的时候说过，form的action属性代表着提交时这个表单会提交给谁，值为一个URL。所以，这里action的值设置为Servlet的路径，意思就是把表单数据发送给了Servelet，由于使用的是post方式，因此触发了Servlet的doPost方法。Servlet对得到的数据进行各种处理，并且通过req和resp进行交互。</p>
</blockquote>
<blockquote>
<p>为什么此处写的是“\demo”这样的路径？</p>
<p>事实上这是一个相对路径。</p>
<p><img src="/2022/12/21/JavaWeb/image-20221230215927404.png" alt="image-20221230215927404"></p>
<p>部署的根路径可以在 run-edit configuration-tomcat-deployment中找到。</p>
</blockquote>
<h5 id="深层一些的问题"><a href="#深层一些的问题" class="headerlink" title="深层一些的问题"></a>深层一些的问题</h5><h6 id="分成get和post"><a href="#分成get和post" class="headerlink" title="分成get和post"></a>分成get和post</h6><p>之所以这两种方法需要分别处理，是因为在Servlet的service方法中，其实是要对req对象进行参数分解，这两种方法分解方式不一样。</p>
<p>按照以往，我们需要这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> ((HttpServletRequest)servletRequest).getMethod();</span><br><span class="line">     <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method))&#123;</span><br><span class="line"><span class="comment">//执行get的逻辑</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method))&#123;</span><br><span class="line"><span class="comment">//执行post的逻辑</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>就类似于可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> ((HttpServletRequest)servletRequest).getMethod();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method))&#123;</span><br><span class="line">        doGet(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method))&#123;</span><br><span class="line">        doPost(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是最后就融合入httpservlet了。</p>
<h3 id="url-pattern配置"><a href="#url-pattern配置" class="headerlink" title="url-pattern配置"></a>url-pattern配置</h3><ol>
<li><p>一个Servlet可以定义多个访问路径 ： @WebServlet({“/d4”,”/dd4”,”/ddd4”})</p>
</li>
<li><p>路径定义规则：</p>
<ol>
<li>/xxx：路径匹配如/demo、/*【第一个优先级大于第二个】</li>
<li>/xxx/xxx:多层路径，目录结构</li>
<li>*.do：扩展名匹配不能在前面加’/‘。也即：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span></span><br></pre></td></tr></table></figure>

url访问填写<code>http://localhost/webdemo4_war/*.do</code>。</li>
</ol>
</li>
</ol>
<h3 id="service参数"><a href="#service参数" class="headerlink" title="service参数"></a>service参数</h3><p><img src="/2022/12/21/JavaWeb/image-20230102005833327.png" alt="image-20230102005833327"></p>
<h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>概念：Hyper Text Transfer Protocol 超文本传输协议</p>
<ul>
<li><p>传输协议：定义了客户端和服务器端通信时发送数据的格式</p>
</li>
<li><p>特点：</p>
<ol>
<li>基于TCP/IP的高级协议需要先经历三次握手，可靠传输</li>
<li>默认端口号:80<blockquote>
<p>如果说域名是ip地址的简化表示，ip地址又表示着一台主机，那么使用http协议访问一个网址，相当于访问一台主机，并且端口号为80.</p>
</blockquote>
</li>
<li>基于请求/响应模型的:一次请求对应一次响应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据</li>
</ol>
<p>  历史版本：</p>
<ul>
<li>1.0：每一次请求响应都会建立新的连接</li>
<li>1.1：复用连接</li>
</ul>
</li>
</ul>
<h5 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h5><h6 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h6><p>客户端发送给服务器端的消息</p>
<p>数据格式：</p>
<ol>
<li><p>请求行<br> 请求方式 请求url 请求协议/版本<br> GET /login.html    HTTP/1.1</p>
<ul>
<li>请求方式：<ul>
<li>HTTP协议有7中请求方式，常用的有2种<ul>
<li>GET：<ol>
<li>请求参数<strong>在请求行中【在url后】</strong>。</li>
<li>请求的url长度有限制的</li>
<li>不太安全</li>
</ol>
</li>
<li>POST：<ol>
<li>请求参数在请求体中</li>
<li>请求的url长度没有限制的</li>
<li>相对安全</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求头：客户端浏览器告诉服务器一些信息<br> 请求头名称: 请求头值</p>
<ul>
<li><p>常见的请求头：</p>
<ol>
<li><p>User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息    * 可以在服务器端获取该头的信息，解决浏览器的<strong>兼容性</strong>问题</p>
</li>
<li><p>Accept：可以支持的响应格式</p>
</li>
<li><p>Accept-language：可以支持的语言环境</p>
</li>
<li><p>Referer：<a href="http://localhost/login.html">http://localhost/login.html</a>    * 告诉服务器，我(当前请求)从哪里来？</p>
<ul>
<li>作用：</li>
</ul>
<ol>
<li>防盗链：<img src="/2022/12/21/JavaWeb/image-20230101235437317.png" alt="image-20230101235437317">如果ref头非合法就不播放</li>
<li>统计工作：看从哪个网站来的人数多</li>
</ol>
</li>
<li><p>Connection：连接是否活着</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>请求空行<br> 空行，就是用于分割POST请求的请求头，和请求体的。</p>
</li>
<li><p>请求体(正文)：</p>
<ul>
<li>封装POST请求消息的请求参数的</li>
</ul>
</li>
</ol>
<p>字符串格式：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">//请求行</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">/login.html	HTTP/1.1</span></span><br><span class="line"><span class="attr">//请求头</span></span><br><span class="line"><span class="attr">Host</span>: <span class="string">localhost</span></span><br><span class="line"><span class="attr">User-Agent</span>: <span class="string">Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0</span></span><br><span class="line"><span class="attr">Accept</span>: <span class="string">text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span></span><br><span class="line"><span class="attr">Accept-Language</span>: <span class="string">zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span></span><br><span class="line"><span class="attr">Accept-Encoding</span>: <span class="string">gzip, deflate</span></span><br><span class="line"><span class="attr">Referer</span>: <span class="string">http://localhost/login.html</span></span><br><span class="line"><span class="attr">Connection</span>: <span class="string">keep-alive</span></span><br><span class="line"><span class="attr">Upgrade-Insecure-Requests</span>: <span class="string">1</span></span><br><span class="line"><span class="attr">//请求空行</span></span><br><span class="line"></span><br><span class="line"><span class="attr">//请求体</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">zhangsan	</span></span><br></pre></td></tr></table></figure>



<h6 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h6><p>响应消息：服务器端发送给客户端的数据</p>
<p>数据格式：</p>
<ol>
<li><p>响应行</p>
<ol>
<li><p>组成：协议/版本 响应状态码 状态码描述    <code>HTTP/1.1 200 OK</code></p>
</li>
<li><p>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态, 状态码都是3位数字. 分类:</p>
<ol>
<li><p>1xx：服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx多状态码，询问是否还要继续发</p>
</li>
<li><p>2xx：成功。代表：200</p>
</li>
<li><p>3xx：重定向。代表：302(重定向)，304(访问缓存)</p>
<p><img src="/2022/12/21/JavaWeb/image-20230103151112791.png" alt="image-20230103151112791"></p>
<p>需要自动重定向到另一个C去</p>
<p><img src="/2022/12/21/JavaWeb/image-20230103151237984.png" alt="image-20230103151237984"></p>
<p>发现资源未变化且本地有缓存</p>
</li>
<li><p>4xx：由客户端造成的错误</p>
<p>代表：</p>
<ol>
<li><p> 404（请求路径没有对应的资源，可能路径输错了）</p>
</li>
<li><p>405：请求方式没有对应的doXxx方法</p>
<p>当我们在Servlet中未重写doXXX方法，就默认不能用此方法进行访问。因为doXXX方法的默认实现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> req.getProtocol();</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_get_not_supported&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">    resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>5xx：服务器端错误。</p>
<p>代表：500(服务器内部出现Exception)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>/<span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>响应头：</p>
<ol>
<li><p>格式：    [头名称 : 值]</p>
</li>
<li><p>常见的响应头：</p>
<ol>
<li><p>Content-Type：服务器告诉客户端本次<strong>响应体</strong> <u>数据格式以及编码格式</u></p>
<p>浏览器依照编码格式来对该页面进行解码。</p>
</li>
<li><p>Content-disposition：服务器告诉客户端以什么格式打开响应体数据</p>
<ul>
<li>值：<ul>
<li>in-line：<strong>默认值</strong>，在当前页面内打开</li>
<li>attachment;filename=xxx：以附件形式打开响应体。也即点击超链接后开始文件下载</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>响应空行</p>
</li>
<li><p>响应体：传输的数据</p>
</li>
</ol>
<p>字符串格式:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">//响应行</span></span><br><span class="line"><span class="attr">HTTP/1.1</span> <span class="string">200 OK</span></span><br><span class="line"><span class="attr">//响应头</span></span><br><span class="line"><span class="attr">Content-Type</span>: <span class="string">text/html;charset=UTF-8</span></span><br><span class="line"><span class="attr">Content-Length</span>: <span class="string">101</span></span><br><span class="line"><span class="attr">Date</span>: <span class="string">Wed, 06 Jun 2018 07:08:42 GMT</span></span><br><span class="line"><span class="attr">//响应空行</span></span><br><span class="line"></span><br><span class="line"><span class="attr">//响应体</span></span><br><span class="line"><span class="attr">&lt;html&gt;</span></span><br><span class="line">    <span class="attr">&lt;head&gt;</span></span><br><span class="line">        <span class="attr">&lt;title&gt;$Title$&lt;/title&gt;</span></span><br><span class="line">    <span class="attr">&lt;/head&gt;</span></span><br><span class="line">    <span class="attr">&lt;body&gt;</span></span><br><span class="line">        <span class="attr">hello</span> <span class="string">, response</span></span><br><span class="line">    <span class="attr">&lt;/body&gt;</span></span><br><span class="line"><span class="attr">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><h5 id="继承体系结构"><a href="#继承体系结构" class="headerlink" title="继承体系结构"></a>继承体系结构</h5><p>ServletRequest(I) - HttpServletRequest(I) - RequestFacade(C)[tomcat创建] </p>
<h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><h6 id="获取请求行"><a href="#获取请求行" class="headerlink" title="获取请求行"></a>获取请求行</h6><ol>
<li><p>获取请求方式  POST</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getMethod</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>获取虚拟目录  /webdemo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getContextPath</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取Servlet路径 /demo1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getServletPath</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取get方式请求参数 name=zhangsan</p>
<p>&amp;分割每个键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getQueryString</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>获取请求URI和URL</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  /webdemo/demo1</span></span><br><span class="line">String <span class="title function_">getRequestURI</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  http://localhost/webdemo/demo1</span></span><br><span class="line">StringBuffer <span class="title function_">getRequestURL</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>URL:统一资源定位符 ： <a href="http://localhost/day14/demo1">http://localhost/day14/demo1</a>    中华人民共和国<br>URI：统一资源标识符 : /day14/demo1                    共和国</p>
<p>URI的代表范围更大</p>
</blockquote>
</li>
<li><p>获取协议及版本  HTTP/1.1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getProtocol</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取访问的客户机的IP地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getRemoteAddr</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="获取请求头"><a href="#获取请求头" class="headerlink" title="获取请求头"></a>获取请求头</h6><ol>
<li><p><strong>通过请求头的名称获取请求头的值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getHeader</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取所有的请求头名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enumeration&lt;String&gt; <span class="title function_">getHeaderNames</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>返回的是一个迭代器</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servletdemo2</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        Enumeration&lt;String&gt; enumerator = req.getHeaderNames();</span><br><span class="line">        <span class="keyword">while</span>(enumerator.hasMoreElements())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> enumerator.nextElement();</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            <span class="comment">//System.out.println(name+&quot;-----&quot;+req.getHeader(name));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">host</span><br><span class="line">connection</span><br><span class="line">sec-ch-ua</span><br><span class="line">sec-ch-ua-mobile</span><br><span class="line">sec-ch-ua-platform</span><br><span class="line">upgrade-insecure-requests</span><br><span class="line">user-agent</span><br><span class="line">accept</span><br><span class="line">purpose</span><br><span class="line">sec-fetch-site</span><br><span class="line">sec-fetch-mode</span><br><span class="line">sec-fetch-user</span><br><span class="line">sec-fetch-dest</span><br><span class="line">accept-encoding</span><br><span class="line">accept-language</span><br><span class="line">cookie</span><br></pre></td></tr></table></figure>

<p>这些请求头名称正是上面的键值对里的键。</p>
<h6 id="获取请求体"><a href="#获取请求体" class="headerlink" title="获取请求体"></a>获取请求体</h6><p>request将请求体中的数据封装成了流。如果数据是字符，那就是字符流；是视频这种的字节，那就是字节流。</p>
<pre><code>* 步骤：
    1. 获取流对象
  *  BufferedReader getReader()：获取字符输入流，只能操作字符数据
  *  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据
    2. 操作流获取数据
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servletdemo2</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bfr</span> <span class="operator">=</span> req.getReader();</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = bfr.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.print(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求体中键值对会在一行里，用&amp;分割</p>
<blockquote>
<p>获取时中文乱码</p>
<ul>
<li><p>get方式：tomcat 8 已经将get方式乱码问题解决了</p>
</li>
<li><p>post方式：会乱码</p>
<pre><code>                   * 解决：在获取参数前，设置流的编码:

    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<h6 id="获取请求参数通用的方法（通用指对get和post通用）"><a href="#获取请求参数通用的方法（通用指对get和post通用）" class="headerlink" title="获取请求参数通用的方法（通用指对get和post通用）"></a>获取请求参数通用的方法（通用指对get和post通用）</h6><p>这里的请求参数应该是指上面Post的请求体、Get的请求行里的参数，请求头里的参数是获取不到的。</p>
<ol>
<li><p>根据参数名称获取参数值  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getParameter</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure>

<p>如  username=zs&amp;password=123，getParameter(“username”)会得到zs。</p>
</li>
<li><p>根据参数名称获取参数值的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] getParameterValues(String name)</span><br></pre></td></tr></table></figure>

<p>如  hobby=xx&amp;hobby=game，会得到{xx,game}</p>
</li>
<li><p>获取所有请求的参数名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enumeration&lt;String&gt; <span class="title function_">getParameterNames</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
<li><p>取所有参数的map集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String[]&gt; getParameterMap()</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h6><p>在服务器内部<strong>资源跳转</strong>。</p>
<p><img src="/2022/12/21/JavaWeb/image-20230102195615676.png" alt="image-20230102195615676"></p>
<p>AServlet做了一部分事情，把剩余的事情交给BServlet去做</p>
<p>步骤：</p>
<ol>
<li><p>通过request对象获取请求转发器对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestDispatcher <span class="title function_">getRequestDispatcher</span><span class="params">(String path)</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用RequestDispatcher对象来进行转发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">requestDispatcher.forward(ServletRequest request, ServletResponse response) </span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servletdemo2</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am &quot;</span>+Servletdemo2.class.getName());</span><br><span class="line">        <span class="comment">//进行转发</span></span><br><span class="line">        servletRequest.getRequestDispatcher(<span class="string">&quot;/demo3&quot;</span>)</span><br><span class="line">            .forward(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo3</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am &quot;</span>+ServletDemo3.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>浏览器地址栏路径不变</li>
<li>只能在服务器内部跳转，只能转发到服务器内部的资源中</li>
<li>转发是一次请求，多个资源使用的是同一次请求</li>
</ol>
<h6 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h6><p>接力工作的两个Servlet可以通过request对象进行数据通信。</p>
<pre><code>* 方法：
</code></pre>
<ol>
<li><p>存储键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name,Object obj)</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">getAttitude</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure></li>
<li><p>移除键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="获取ServletContext"><a href="#获取ServletContext" class="headerlink" title="获取ServletContext"></a>获取ServletContext</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletContext <span class="title function_">getServletContext</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h5 id="练习：结合数据库与Servlet进行用户登录"><a href="#练习：结合数据库与Servlet进行用户登录" class="headerlink" title="练习：结合数据库与Servlet进行用户登录"></a>练习：结合数据库与Servlet进行用户登录</h5><blockquote>
<p>要求：</p>
<p>1.编写login.html登录页面<br>    username &amp; password 两个输入框<br>2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表<br>3.使用JdbcTemplate技术封装JDBC<br>4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您<br>5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误</p>
</blockquote>
<h6 id="文件结构-1"><a href="#文件结构-1" class="headerlink" title="文件结构"></a>文件结构</h6><p>![屏幕截图 2023-01-02 235207](./JavaWeb/屏幕截图 2023-01-02 235207.png)</p>
<blockquote>
<p>错误历程</p>
<ol>
<li><p>lib目录位置错误</p>
<p><a href="https://blog.csdn.net/weixin_41500775/article/details/124592583">NoClassDefFoundError解决方案</a>一开始lib目录没放进web-inf，通过此文章得知错误为包未引入，再由下面这篇文章得知lib目录放置错误</p>
<p><a href="https://blog.csdn.net/doubleguy/article/details/104987101">JDBC Template报错：java.lang.ClassNotFoundException: org.springframework.jdbc.core.RowMapper</a></p>
</li>
<li><p>druid.properties文件位置错误</p>
<p>报错</p>
<p><code>java.lang.NullPointerException at java.util.Properties$LineReader.readLine(Properties.java:434)</code></p>
<p>，报错位置在<code>pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));</code></p>
<p>由文章</p>
<p> <a href="https://blog.csdn.net/qq_45849364/article/details/116563115">关于java.lang.NullPointerException at java.util.Properties$LineReader.readLine(Properties.java:434)问题</a></p>
<p>回忆到，由于是使用类加载器获取文件流，故而要求druid.properties文件应该放在resource文件下。对于以前的项目，resource文件都默认是src文件夹。</p>
<p>但是这次放在src目录下还是不行。定睛一看它web项目文件结构中有一个硕大的resources……放在下面果然就好了。</p>
</li>
</ol>
</blockquote>
<h6 id="druid-properties"><a href="#druid-properties" class="headerlink" title="druid.properties"></a>druid.properties</h6><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/helloworld</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>

<h6 id="html界面"><a href="#html界面" class="headerlink" title="html界面"></a>html界面</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  action内写Servlet的资源路径  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/webdemo4_war/check&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">  password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value = &quot;/fail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FailServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 设置字符集，防止中文乱码</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;登录失败，用户名或密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value = &quot;/success&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuccessServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;登录成功！&quot;</span>+req.getAttribute(<span class="string">&quot;uname&quot;</span>)+<span class="string">&quot;,欢迎您&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value = &quot;/check&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用BeanUtils把Map转化为对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanUtils.populate(tmp,req.getParameterMap());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">res</span> <span class="operator">=</span> UserDao.login(tmp);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="literal">null</span>)</span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;/fail&quot;</span>).forward(req,resp);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            req.setAttribute(<span class="string">&quot;uname&quot;</span>,res.getUname());</span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;/success&quot;</span>).forward(req,resp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于BeanUtils</p>
<p>BeanUtils工具类，简化数据封装, 用于封装JavaBean的</p>
<ol>
<li><p>JavaBean：标准的Java类</p>
<pre><code> 1. 要求：
     1. 类必须被public修饰
     2. 必须提供空参的构造器
     3. 成员变量必须使用private修饰
     4. 提供公共setter和getter方法
 2. 功能：封装数据
</code></pre>
</li>
<li><p>概念：</p>
<p>​    成员变量：<br>​    属性：setter和getter方法截取后的产物</p>
<pre><code>           例如：getUsername() --&gt; Username--&gt; username
</code></pre>
</li>
<li><p>方法：</p>
<pre><code>1. setProperty()
1. getProperty()
1. populate(Object obj , Map map):
</code></pre>
<p>   ​        将map集合的键值对信息，封装到对应的JavaBean对象中</p>
</li>
</ol>
</blockquote>
<h6 id="JDBCUtils"><a href="#JDBCUtils" class="headerlink" title="JDBCUtils"></a>JDBCUtils</h6><p>原封不动地照搬了：第二部分-数据库连接池-Druid-定义工具类 部分的代码。</p>
<h6 id="UserDao"><a href="#UserDao" class="headerlink" title="UserDao"></a>UserDao</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(JDBCUtils.getDataSource());</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">login</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        List&lt;User&gt; users = jdbcTemplate.query(<span class="string">&quot;select * from usr where uname = ? and pass = ?&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class),</span><br><span class="line">                        user.getUname(),user.getPass());</span><br><span class="line">        <span class="keyword">if</span> (users.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> users.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><h5 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h5><p>设置响应消息。</p>
<h6 id="设置响应行"><a href="#设置响应行" class="headerlink" title="设置响应行"></a>设置响应行</h6><p>设置状态码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setStatus(<span class="type">int</span> sc);</span><br></pre></td></tr></table></figure>

<h6 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setHeader(String name, String value) </span><br></pre></td></tr></table></figure>

<h6 id="设置响应体"><a href="#设置响应体" class="headerlink" title="设置响应体"></a>设置响应体</h6><p>以流的方式传输数据。</p>
<p>使用步骤：</p>
<ol>
<li><p>获取输出流</p>
<ol>
<li><p>字节输出流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletOutputStream <span class="title function_">getOutputStream</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符输出流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter <span class="title function_">getWriter</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>使用输出流，将数据输出到客户端浏览器</p>
</li>
</ol>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><h6 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h6><p>资源跳转的一种方式。</p>
<p><img src="/2022/12/21/JavaWeb/image-20230103153445565.png" alt="image-20230103153445565"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am demo1  &quot;</span>+req.hashCode());</span><br><span class="line">        <span class="comment">/* 重定向 */</span></span><br><span class="line">        <span class="comment">//设置状态码</span></span><br><span class="line">        resp.setStatus(<span class="number">302</span>);</span><br><span class="line">        <span class="comment">//要填的是完整资源路径。</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;/practice_war/demo2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am demo2  &quot;</span>+req.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">I am demo1  1675674230</span><br><span class="line">I am demo2  1675674230</span><br></pre></td></tr></table></figure>

<p>重定向的这几行代码其实是可以简化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 重定向 */</span></span><br><span class="line">      <span class="comment">//设置状态码</span></span><br><span class="line">      resp.setStatus(<span class="number">302</span>);</span><br><span class="line">      <span class="comment">//要填的是完整资源路径。</span></span><br><span class="line">      resp.setHeader(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;/practice_war/demo2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resp.sendRedirect(<span class="string">&quot;/practice_war/demo2&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于req对象不一样，但hashcode值相同的解释：</p>
<p>hashcode很大程度与对象内存空间相关，与对象的具体内容没什么关系。两个对象拥有相同的hashcode有可能只是因为存储的内存空间位置大小都相同导致的。所以是因为两次的req对象都占用了同一个内存空间【JVM调度问题】，所以才让hashcode值相同。这两个对象实质上是不一样的。</p>
</blockquote>
<p>重定向的特点（与请求转发完全相反）：</p>
<ol>
<li>浏览器地址栏路径改变</li>
<li>可以访问其他站点的资源</li>
<li>使用多次请求，不能使用request对象共享数据</li>
</ol>
<p>路径写法：</p>
<ol>
<li><p>相对路径：通过相对路径不可以确定唯一资源</p>
<ul>
<li>规则：<strong>找到当前资源和目标资源之间的相对位置关系</strong></li>
</ul>
</li>
<li><p>绝对路径：通过绝对路径可以确定唯一资源</p>
<ul>
<li><p>如：<a href="http://localhost/day15/responseDemo2">http://localhost/day15/responseDemo2</a>        /day15/responseDemo2</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/webdemo4_war/check&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>以/开头的路径</p>
</li>
<li><p>规则：判断定义的路径是给谁用的？<strong>判断请求将来从哪儿发出</strong></p>
<ul>
<li><p>给<strong>客户端</strong>浏览器使用：需要加虚拟目录(项目的访问路径)</p>
<p>比如说在页面中弄了个a标签，将来是要给客户端点的，那么这个a标签的href就要用绝对路径。</p>
<p>再比如说重定向：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要填的是完整资源路径。</span></span><br><span class="line">      resp.setHeader(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;/practice_war/demo2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个路径将来是给客户端将来要使用的路径，是客户端路径，所以要加虚拟目录。</p>
<ul>
<li>建议虚拟目录动态获取：request.getContextPath()</li>
<li><a> , <form>，重定向…</form></a></li>
</ul>
</li>
<li><p>给<strong>服务器</strong>使用：不需要加虚拟目录</p>
<p>比如说之前的请求转发</p>
<ul>
<li>转发路径    </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h6 id="服务器输出字符数据到浏览器"><a href="#服务器输出字符数据到浏览器" class="headerlink" title="服务器输出字符数据到浏览器"></a>服务器输出字符数据到浏览器</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/responseDemo4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取流对象之前，设置流的默认编码：ISO-8859-1 设置为：GBK</span></span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//告诉浏览器，服务器发送的消息体数据的编码。建议浏览器使用该编码解码</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 也有设置编码的简单形式</span></span><br><span class="line"><span class="comment">        //简单的形式，设置编码</span></span><br><span class="line"><span class="comment">        response.setContentType(&quot;text/html;charset=utf-8&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取字符输出流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="comment">//2.输出数据</span></span><br><span class="line">        <span class="comment">//pw.write(&quot;&lt;h1&gt;hello response&lt;/h1&gt;&quot;);</span></span><br><span class="line">        pw.write(<span class="string">&quot;你好啊啊啊 response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="服务器输出字节数据到浏览器"><a href="#服务器输出字节数据到浏览器" class="headerlink" title="服务器输出字节数据到浏览器"></a>服务器输出字节数据到浏览器</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/responseDemo5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo5</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//依然要保证编码一致</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取字节输出流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">sos</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//2.输出数据</span></span><br><span class="line">        sos.write(<span class="string">&quot;你好&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//验证码图片大小</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 绘制验证码 */</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(width,height,BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        <span class="type">Graphics</span> <span class="variable">pen</span> <span class="operator">=</span> image.getGraphics();</span><br><span class="line">        <span class="comment">//绘制背景</span></span><br><span class="line">        pen.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>((<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>)));</span><br><span class="line">        pen.fillRect(<span class="number">0</span>,<span class="number">0</span>,width,height);</span><br><span class="line">        <span class="comment">//绘制边框</span></span><br><span class="line">        pen.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>((<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>)));</span><br><span class="line">        pen.drawRect(<span class="number">0</span>,<span class="number">0</span>,width-<span class="number">1</span>,height-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//随机填充字母数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()*source.length());</span><br><span class="line">            pen.drawString(source.substring(index,index+<span class="number">1</span>),<span class="number">20</span>*i,<span class="number">27</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//画干扰色线</span></span><br><span class="line">        pen.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>((<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            pen.drawLine((<span class="type">int</span>)(Math.random()*width),(<span class="type">int</span>)(Math.random()*height),(<span class="type">int</span>)(Math.random()*width),(<span class="type">int</span>)(Math.random()*height));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将图片输出</span></span><br><span class="line">        ImageIO.write(image,<span class="string">&quot;jpg&quot;</span>,resp.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/practice_war/demo1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span> = <span class="string">&quot;a&quot;</span>&gt;</span>看不清？换一张<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    img.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//加时间戳作为请求参数，为了防止浏览器不更换图片缓存</span></span></span><br><span class="line"><span class="language-javascript">      img.<span class="property">src</span> = <span class="string">&quot;/practice_war/demo1?&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    a.<span class="property">onclick</span> = img.<span class="property">onclick</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>代表整个web应用，可以和servlet容器（服务器）通信</p>
<h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><h5 id="通过request对象获取"><a href="#通过request对象获取" class="headerlink" title="通过request对象获取"></a>通过request对象获取</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletContext <span class="title function_">getServletContext</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h5 id="通过HttpServlet获取"><a href="#通过HttpServlet获取" class="headerlink" title="通过HttpServlet获取"></a>通过HttpServlet获取</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.getContext();</span><br></pre></td></tr></table></figure>

<h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><h5 id="获取MIME类型"><a href="#获取MIME类型" class="headerlink" title="获取MIME类型"></a>获取MIME类型</h5><p>MIME是在互联网通信过程中定义的一种文件数据类型</p>
<pre><code>        * 格式： 大类型/小类型   text/html        image/jpeg
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: 文件的后缀扩展名，如.txt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String <span class="title function_">getMimeType</span><span class="params">(String file)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/12/21/JavaWeb/image-20230107010006874.png" alt="image-20230107010006874"></p>
<p>mime映射存在了服务器的xml文件中。</p>
<p>使用案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="built_in">this</span>.getServletContext().getMimeType(<span class="string">&quot;a.txt&quot;</span>));</span><br></pre></td></tr></table></figure>



<h5 id="共享数据-1"><a href="#共享数据-1" class="headerlink" title="共享数据"></a>共享数据</h5><p>ServletContext是一个域对象，可以用来共享数据。</p>
<p>ServletContext代表着服务器，因而它的生命周期跟随服务器关闭而灭亡。ServletContext可以共享所有请求的数据。也就是说，任何一次请求，任何用户，看到的ServletContext域都是同一个。</p>
<p>这样大的效果也使得我们需要更加谨慎地使用它。一旦数据存入ServletContext域，就只会在服务器关闭后才会消亡，很耗内存。</p>
<h5 id="获取文件的真实（服务器）路径"><a href="#获取文件的真实（服务器）路径" class="headerlink" title="获取文件的真实（服务器）路径"></a>获取文件的真实（服务器）路径</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getRealPath</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>经测试发现，这东西只是起了一个字符串拼接的作用，是<strong>不会</strong>帮忙检查文件是否存在的。</p>
<p>学到这我顺便看了看文件放在不同的地方最后应该如何访问：</p>
<p><img src="/2022/12/21/JavaWeb/image-20230107012903495.png" alt="image-20230107012903495"></p>
<p>这是最终部署项目文件夹的结构：</p>
<p><img src="/2022/12/21/JavaWeb/image-20230107013010276.png" alt="image-20230107013010276"></p>
<p>可以看到只有bcd被保留了。它们的目录要这样获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getRealPath(<span class="string">&quot;/WEB-INF/classes/b.txt&quot;</span>));</span><br><span class="line">        System.out.println(context.getRealPath(<span class="string">&quot;/c.txt&quot;</span>));</span><br><span class="line">        System.out.println(context.getRealPath(<span class="string">&quot;/WEB-INF/d.txt&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">D:\aWorkStorage\etc\apache-tomcat-8.5.83\webapps\practice_war\WEB-INF\classes\b.txt</span></span><br><span class="line"><span class="comment">D:\aWorkStorage\etc\apache-tomcat-8.5.83\webapps\practice_war\c.txt</span></span><br><span class="line"><span class="comment">D:\aWorkStorage\etc\apache-tomcat-8.5.83\webapps\practice_war\WEB-INF\d.txt</span></span><br><span class="line"><span class="comment">是我的电脑里tomcat的目录</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="案例：文件下载"><a href="#案例：文件下载" class="headerlink" title="案例：文件下载"></a>案例：文件下载</h4><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><ul>
<li>文件下载需求：<ol>
<li>页面显示超链接</li>
<li>点击超链接后弹出下载提示框</li>
<li>完成图片文件下载，那种会存到你电脑download目录下，而不是直接加载出来的</li>
</ol>
</li>
</ul>
<p><img src="/2022/12/21/JavaWeb/image-20230201170701909.png" alt="image-20230201170701909"></p>
<p>用户点击下载-&gt;请求发送给某个servlet，servlet修改response-&gt;tomcat响应用户，传递的图片资源按照response的方法打开</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><p>说实话看了感觉有点难以下手，主要还是完全不知道html和servlet怎么交互造成的，看了老师讲解才有点恍然大悟。</p>
<p>我们可以把a标签以重定向的角度去看。它会新建一个request，然后发送到它的href中的那个url。在此处我们将url设置为<code>/practice_war/download?filename=1.jpg</code>，也即要以GET的方式发送给download，请求体为<code>filename=1.jpg</code>。然后servlet执行结束后，就会将信息存储在resp中返回给tomcat，由tomcat发送给用户。</p>
<h6 id="html"><a href="#html" class="headerlink" title="html"></a>html</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/practice_war/download?filename=1.jpg&quot;</span> <span class="attr">id</span> = <span class="string">&quot;a&quot;</span>&gt;</span>点击下载图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h6><p>思路：</p>
<p>获取要下载的资源，并且将其输入到resp的stream中。</p>
<p>有一点需要非常注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resp.setContentType(<span class="built_in">this</span>.getServletContext().getMimeType(path));</span><br><span class="line">resp.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span>+name);</span><br></pre></td></tr></table></figure>

<p>必须要在把资源输入到resp的stream前设置好，精确来说是调用<code>sos.write</code>前设置好，不然无法起作用。</p>
<p>猜测是因为可能resp会根据disposition方式的不同而自动决策write的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//获取要下载的资源名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext().getRealPath(<span class="string">&quot;/img/&quot;</span>+name);</span><br><span class="line">    <span class="comment">//使用字节流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">    <span class="comment">//输出数据</span></span><br><span class="line"></span><br><span class="line">    resp.setContentType(<span class="built_in">this</span>.getServletContext().getMimeType(path));</span><br><span class="line">    resp.setHeader(<span class="string">&quot;content-disposition&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;attachment;filename=&quot;</span>+</span><br><span class="line">                   <span class="comment">// 为了防止中文乱码，需要针对不同的浏览器来进行编码</span></span><br><span class="line">                   DownLoadUtils.getFileName(req.getHeader(<span class="string">&quot;user-agent&quot;</span>),name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取字节输出流</span></span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">sos</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">    <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(buff))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        sos.write(buff,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    fis.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        resp.setContentType(this.getServletContext().getMimeType(path));</span></span><br><span class="line">    <span class="comment">//        resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot;+name);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话：一次会话中包含多次请求和响应。</p>
<ul>
<li><p>一次会话：浏览器第一次给服务器资源发送请求，<strong>会话建立</strong>，直到有一方<strong>断开</strong>为止</p>
</li>
<li><p>功能：请求之间本来是相互独立的。将多次请求组织在一次会话中，就可以让请求之间进行数据的共享。</p>
</li>
<li><p>方式：</p>
<ul>
<li><p>客户端会话技术    Cookie</p>
<p>把数据存进客户端</p>
</li>
<li><p>服务器端会话技术 Session</p>
<p>把数据存进服务器端</p>
</li>
</ul>
</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>客户端会话技术，将数据保存到客户端</p>
<h4 id="快速入门-5"><a href="#快速入门-5" class="headerlink" title="快速入门"></a>快速入门</h4><ul>
<li><p>使用步骤：</p>
<ol>
<li>创建Cookie对象，绑定数据【为了从服务器端发送cookie给客户端】<ul>
<li>new Cookie(String name, String value) </li>
<li>可以看到，Cookie其实就是一种name-value这样的键值对对象</li>
</ul>
</li>
<li>发送Cookie对象【因为要发送给客户端，所以应该在response里存】<ul>
<li>response.addCookie(Cookie cookie) </li>
</ul>
</li>
<li>获取Cookie，拿到数据【因为是来自客户端，所以要从request里要】<ul>
<li>Cookie[]  request.getCookies()  </li>
</ul>
</li>
</ol>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;abc123&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(request.getCookies());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>得到效果</p>
<p>运行服务器，首先访问/demo，然后在同一个浏览器再次访问/demo2，就可以在控制台看到输出。</p>
<p>这个过程发生了什么呢？</p>
<p>首先，访问/demo就相当于建立了会话。/demo的Servlet获取到请求之后，在response中将cookie填入。</p>
<p>保持浏览器窗口不变，会话也不变。</p>
<p>再次访问/demo2，cookie信息自动保存在request对象中。/demo2的Servlet获取到请求之后，在控制台中打印输出了cookie。</p>
</li>
</ul>
<h4 id="细节学习"><a href="#细节学习" class="headerlink" title="细节学习"></a>细节学习</h4><h5 id="一次发送多个cookie"><a href="#一次发送多个cookie" class="headerlink" title="一次发送多个cookie"></a>一次发送多个cookie</h5><p>你看它那个API叫add，就知道数据结构差不多是个list，所以多次add就行。</p>
<h5 id="保存时间"><a href="#保存时间" class="headerlink" title="保存时间"></a>保存时间</h5><p>默认情况下，浏览器关闭则cookie就马上被销毁。</p>
<p>如果需要持久化存储：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cookie.setMaxAge(<span class="type">int</span> seconds)</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ol>
<li>正数：将Cookie数据写到硬盘的文件中。持久化存储。并<strong>指定cookie存活时间</strong>，时间到后，cookie文件自动失效</li>
<li>负数：默认值</li>
<li>零：删除cookie信息</li>
</ol>
<h5 id="中文问题"><a href="#中文问题" class="headerlink" title="中文问题"></a>中文问题</h5><p>在tomcat 8 之前 cookie中不能直接存储中文数据，需要将中文数据转码——一般采用<strong>URL编码</strong>(%E3)</p>
<p>在tomcat 8 之后，cookie支持中文数据。</p>
<h5 id="获取范围"><a href="#获取范围" class="headerlink" title="获取范围"></a>获取范围</h5><ol>
<li><p>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？</p>
<ul>
<li><p>默认情况下cookie不能共享</p>
</li>
<li><p>共享方法：</p>
<p><code>setPath(String path)</code>:<strong>设置cookie的获取范围</strong>。默认情况下，设置当前的虚拟目录</p>
<p>如果要共享，则可以将path设置为”/“</p>
</li>
</ul>
</li>
<li><p>不同的tomcat服务器间cookie共享问题？</p>
<p>比如说：</p>
<img src="/2022/12/21/JavaWeb/aWorkStorage\hexo\blog\source\_posts\JavaWeb\image-20230221225514567.png" alt="image-20230221225514567" style="zoom:50%;">

<ul>
<li><p><code>setDomain(String path)</code>:如果设置一级域名相同，那么多个服务器之间cookie可以共享</p>
<p>（<code>setDomain(&quot;.baidu.com&quot;)</code>,那么tieba.baidu.com和news.baidu.com中cookie可以共享）</p>
</li>
</ul>
</li>
</ol>
<h4 id="作用和特点"><a href="#作用和特点" class="headerlink" title="作用和特点"></a>作用和特点</h4><p>特点：</p>
<ol>
<li><p>cookie存储数据在客户端浏览器</p>
<p>因而它相对不安全</p>
</li>
<li><p>浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)</p>
</li>
</ol>
<p>作用：</p>
<ol>
<li><p>cookie一般用于存出少量的不太敏感的数据</p>
</li>
<li><p>在不登录的情况下，完成服务器对客户端的身份识别</p>
<p>比如说，以不登录情况下对某个网页进行属性设置，你下次打开的时候属性设置依然在，这是因为你的属性设置的cookie在设置后被存入到你的电脑中，下次访问该网页发出请求，服务器端就能根据请求中cookie里的属性设置信息来做出响应了。</p>
</li>
</ol>
<h4 id="案例：记住上一次访问时间"><a href="#案例：记住上一次访问时间" class="headerlink" title="案例：记住上一次访问时间"></a>案例：记住上一次访问时间</h4><p>需求：<br>        1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。<br>        2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取流对象之前，设置流的默认编码：ISO-8859-1 设置为：GBK</span></span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//告诉浏览器，服务器发送的消息体数据的编码。建议浏览器使用该编码解码</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(request.getCookies() != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">for</span>(Cookie c : request.getCookies())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c.getName().equals(<span class="string">&quot;isfirst&quot;</span>))&#123;</span><br><span class="line">                    response.getWriter()</span><br><span class="line">                        .write(<span class="string">&quot;&lt;h1&gt;欢迎回来，您上次访问的时间为&lt;h1&gt;&quot;</span>+c.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            response.getWriter().write(<span class="string">&quot;&lt;h1&gt;你好！欢迎你！&lt;h1&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd-HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> dateFormat.format(date1);</span><br><span class="line"></span><br><span class="line">        response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;isfirst&quot;</span>,currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。<code>HttpSession</code></p>
<h4 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h4><p>比如说购物网站的购物车这种，就会存在session。想想也是（</p>
<ol>
<li><p>session用于存储一次会话的多次请求的数据，存在服务器端</p>
<p>比如说，当我们做<strong>重定向</strong>的时候，就可以选择用session共享数据（会话域）而非使用<code>ServletContext</code>（此范围过大）</p>
</li>
<li><p>session可以存储<strong>任意类型，任意大小</strong>的数据</p>
</li>
<li><p>session与Cookie的区别：</p>
<ol>
<li>session存储数据在服务器端，Cookie在客户端</li>
<li>session没有数据大小限制，Cookie有</li>
<li>session数据安全，Cookie相对于不安全</li>
</ol>
</li>
</ol>
<h4 id="快速入门-6"><a href="#快速入门-6" class="headerlink" title="快速入门"></a>快速入门</h4><ol>
<li><p>获取<code>HttpSession</code>对象：<br> <code>HttpSession session = request.getSession();</code></p>
</li>
<li><p>使用<code>HttpSession</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  Object <span class="title function_">getAttribute</span><span class="params">(String name)</span>  </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name, Object value)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span></span><br><span class="line"></span><br><span class="line">#### 原理</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20230223102722575</span>](./JavaWeb/image-<span class="number">20230223102722575.</span>png)</span><br><span class="line"></span><br><span class="line">实现依赖于Cookie</span><br><span class="line"></span><br><span class="line">#### 细节</span><br><span class="line"></span><br><span class="line">前面说到，当客户端和服务器端有任何一端关闭之后，会话结束，在这种情况下，session在客户端和服务器端的保留情况不同。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？</span><br><span class="line">  * 默认情况下。不是。</span><br><span class="line">  * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。</span><br><span class="line">  	 ```java</span><br><span class="line">     <span class="type">Cookie</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;JSESSIONID&quot;</span>,session.getId());</span><br><span class="line">     c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">     response.addCookie(c);</span><br></pre></td></tr></table></figure></li>
<li><p>客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</p>
</li>
</ol>
<ul>
<li>不是同一个，但是要确保数据不丢失。tomcat<strong>自动</strong>（IDEA不会活化）完成以下工作<ul>
<li>session的钝化：（序列化）<pre><code>    * 在服务器正常关闭之前，将session对象序列化到硬盘上
</code></pre>
</li>
</ul>
</li>
</ul>
<pre><code>        * 具体是会放在这里：

      ![image-20230223104447097](./JavaWeb/image-20230223104447097.png)
    
* session的活化：（反序列化
    * 在服务器启动后，将session文件转化为内存中的session对象即可。

我想，cookie应该在这点上不会像session这么做，因为cookie本质上是保存在客户端的数据，按理来说服务器端把cookie发出去之后就可以销毁了，在服务器序列化一点意义都没有。
</code></pre>
<ol start="3">
<li><p>销毁时间</p>
<ol>
<li><p>服务器关闭</p>
</li>
<li><p>session对象调用invalidate() 。</p>
</li>
<li><p>session默认失效时间 30分钟<br>选择性配置修改    </p>
<p>可以在每个项目的子配置文件（如下图）或者总的项目的父配置文件<code>apache-tomcat-8.5.83\conf\web.xml</code>中配置</p>
<p><img src="/2022/12/21/JavaWeb/image-20230223105053170.png" alt="image-20230223105053170"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><blockquote>
<p>需求：</p>
<ol>
<li>访问带有验证码的登录页面login.jsp</li>
<li>用户输入用户名，密码以及验证码。<ul>
<li>如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误</li>
<li>如果验证码输入有误，跳转登录页面，提示：验证码错误</li>
<li>如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h5><p>我们可以在服务器端使用session存储password和username的map，存储验证码图片编号和图片的map，然后用cookie携带验证码图片编号，在req中存储用户名和密码。</p>
<h5 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h5><p>感觉我上面的思路是没有充分利用到session的性质，仅仅把它作为在服务器端存储数据的工具，</p>
<p>“在服务器端存储password和username的map，存储验证码图片编号和图片的map，然后用cookie携带验证码图片编号，在req中存储用户名和密码。”</p>
<p>这样也依然成立，跟session没半毛钱关系。我们可以这样使用session：</p>
<ol>
<li>在服务器端存储password和username的map，存储验证码图片编号和图片的map</li>
<li>当会话建立，由于没有cookie，故而session第一次创建。我们在session内写入验证码对应的编号，把图片通过response发送给客户端。</li>
<li>会话端输入图片验证码后，按下submit按键，验证码存入request域，向服务器端发送请求</li>
<li>服务器端Servlet从请求中get到验证码，然后在session中get到当前验证码的图片编号，向一开始存储的map查询数据，这样就能验证验证码是否正确了</li>
</ol>
<p>那么在这里为什么不用Cookie而使用session呢？大概是因为cookie不安全罢（慌乱）</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><h6 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h6><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;/practice_war/loginServlet&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    name: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> id=<span class="string">&quot;username&quot;</span> placeholder=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span><br><span class="line">    password: &lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> id=<span class="string">&quot;password&quot;</span> placeholder=<span class="string">&quot;请输入密码&quot;</span>&gt;</span><br><span class="line">    verifycode:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;verifycode&quot;</span> id=<span class="string">&quot;verifycode&quot;</span> placeholder=<span class="string">&quot;请输入验证码&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;img id=<span class="string">&quot;img&quot;</span> src=<span class="string">&quot;/practice_war/check&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        document.getElementById(<span class="string">&quot;img&quot;</span>).onclick = function()&#123;</span><br><span class="line">            <span class="built_in">this</span>.src = <span class="string">&quot;/practice_war/check?&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h6 id="checkcode"><a href="#checkcode" class="headerlink" title="checkcode"></a>checkcode</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/check&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//验证码图片大小</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 绘制验证码 */</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(width,height,BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        <span class="type">Graphics</span> <span class="variable">pen</span> <span class="operator">=</span> image.getGraphics();</span><br><span class="line">        <span class="comment">//绘制背景</span></span><br><span class="line">        pen.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>((<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>)));</span><br><span class="line">        pen.fillRect(<span class="number">0</span>,<span class="number">0</span>,width,height);</span><br><span class="line">        <span class="comment">//绘制边框</span></span><br><span class="line">        pen.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>((<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>)));</span><br><span class="line">        pen.drawRect(<span class="number">0</span>,<span class="number">0</span>,width-<span class="number">1</span>,height-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//随机填充字母数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">verifyAnswer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()*source.length());</span><br><span class="line">            verifyAnswer = verifyAnswer.append(source.charAt(index));</span><br><span class="line">            pen.drawString(source.substring(index,index+<span class="number">1</span>),<span class="number">20</span>*i,<span class="number">27</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//画干扰色线</span></span><br><span class="line">        pen.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>((<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>),(<span class="type">int</span>)(Math.random()*<span class="number">255</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            pen.drawLine((<span class="type">int</span>)(Math.random()*width),(<span class="type">int</span>)(Math.random()*height),(<span class="type">int</span>)(Math.random()*width),(<span class="type">int</span>)(Math.random()*height));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.getSession().setAttribute(<span class="string">&quot;verifycode&quot;</span>,verifyAnswer.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;verify:&quot;</span>+verifyAnswer.toString());</span><br><span class="line">        <span class="comment">//将图片输出</span></span><br><span class="line">        ImageIO.write(image,<span class="string">&quot;jpg&quot;</span>,response.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="login"><a href="#login" class="headerlink" title="login"></a>login</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/loginServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">loginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="type">String</span> <span class="variable">verifycode</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;verifycode&quot;</span>);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;verifycode&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="literal">null</span>||!ans.equals(verifycode))&#123;</span><br><span class="line">            session.removeAttribute(<span class="string">&quot;verifycode&quot;</span>);</span><br><span class="line">            <span class="comment">// 重定向到错误界面</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/fail_code&quot;</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        session.removeAttribute(<span class="string">&quot;verifycode&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行密码账号匹配处理</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(username+<span class="string">&quot;  &quot;</span>+password);</span><br><span class="line">        <span class="keyword">if</span>(UserDao.login(<span class="keyword">new</span> <span class="title class_">User</span>(username,password)))&#123;</span><br><span class="line">            <span class="comment">// 成功界面</span></span><br><span class="line">            request.setAttribute(<span class="string">&quot;uname&quot;</span>,username);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/success&quot;</span>).forward(request,response);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 失败界面</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/fail&quot;</span>).forward(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老师的写法是将错误信息直接写在原登录界面，和我的略有不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in loginServlet</span></span><br><span class="line"><span class="keyword">if</span> (!session.getAttribute(<span class="string">&quot;verifycode&quot;</span>).equals(verifycode))&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;checkcode_fail&quot;</span>);</span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).forward(request,response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in login.jsp</span></span><br><span class="line">    &lt;%</span><br><span class="line">       <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> (String) request.getAttribute(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span>(message != <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(message.equals(<span class="string">&quot;checkcode_fail&quot;</span>))&#123;</span><br><span class="line">               out.write(<span class="string">&quot;验证码错误！&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(message.equals(<span class="string">&quot;pass_fail&quot;</span>))&#123;</span><br><span class="line">               out.write(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    %&gt;</span><br></pre></td></tr></table></figure>

<p>以及<code>success.jsp</code></p>
<p><img src="/2022/12/21/JavaWeb/image-20230302233110661.png" alt="image-20230302233110661"></p>
<h6 id="成功-两个失败"><a href="#成功-两个失败" class="headerlink" title="成功/两个失败"></a>成功/两个失败</h6><p>仅以成功为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value = &quot;/success&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuccessServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;登录成功！&quot;</span>+req.getAttribute(<span class="string">&quot;uname&quot;</span>)+<span class="string">&quot;,欢迎您&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><blockquote>
<p>现在都用 Thymeleaf ，更符合 MVC 的执行过程，也没有 JSP 这种耦合杂乱的页面代码，但是模板引擎的思路大致相同，还是可以看一看的</p>
</blockquote>
<p>改动之后无需重启服务器，刷新界面即可。</p>
<blockquote>
<p>关于热更新的机制可以看看这篇文章，水平有限还看不懂就先放在这了：</p>
<p><a href="https://cloud.tencent.com/developer/article/2089272">JSP热部署的实现原理[通俗易懂]</a></p>
</blockquote>
<h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>JSP(Java Server Pages) Java服务器端页面，用于简化书写</p>
<p>可以理解为：一个特殊的页面，其中<strong>既可以定义html标签，又可以定义java代码</strong></p>
<p>比如说，上一个案例的Servlet代码就可以直接写入到JSP中，而且response和request这些对象可以直接用</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.text.SimpleDateFormat&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Date&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//获取流对象之前，设置流的默认编码：ISO-8859-1 设置为：GBK</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//告诉浏览器，服务器发送的消息体数据的编码。建议浏览器使用该编码解码</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(request.getCookies() != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">for</span>(Cookie c : request.getCookies())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c.getName().equals(<span class="string">&quot;isfirst&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问的时间为&lt;h1&gt;&quot;+c.getValue());</span></span><br><span class="line">                response.getWriter().write(<span class="string">&quot;&lt;h1&gt;Welcome!The last time you visit is &lt;h1&gt;&quot;</span>+c.getValue());</span><br><span class="line">                <span class="comment">//System.out.println(&quot;欢迎回来，您上次访问的时间为&quot;+c.getValue());</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;h1&gt;Hello!Welcome!&lt;h1&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd-HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> dateFormat.format(date1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//response.getWriter().write(&quot;&lt;h1&gt;你好！欢迎你！&lt;h1&gt;&quot;);</span></span><br><span class="line">    <span class="comment">//System.out.println(&quot;你好！欢迎你！&quot;);</span></span><br><span class="line">    response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;isfirst&quot;</span>,currentTime));</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>最终效果：</p>
<img src="/2022/12/21/JavaWeb/aWorkStorage\hexo\blog\source\_posts\JavaWeb\image-20230222230929893.png" alt="image-20230222230929893">

<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>JSP本质上是Servlet</p>
<p><img src="/2022/12/21/JavaWeb/image-20230222233533332.png" alt="image-20230222233533332"></p>
<h3 id="JSP的脚本"><a href="#JSP的脚本" class="headerlink" title="JSP的脚本"></a>JSP的脚本</h3><p>JSP定义Java代码的方式</p>
<ol>
<li><p>&lt;%  代码 %&gt;</p>
<p>定义的java代码，在<strong>service</strong>方法中。service方法中可以定义什么，该脚本中就可以定义什么。</p>
<p>也即最后会构成Servlet体</p>
</li>
<li><p>&lt;%! 代码 %&gt;</p>
<p>定义的java代码，在jsp转换后的java类的<strong>成员</strong>位置。可以是成员变量，或者是成员方法。</p>
<p>注：最好不要在Servlet中定义成员变量，否则容易引发线程安全问题。</p>
</li>
<li><p>&lt;%= 代码 %&gt;</p>
<p>定义的java代码，会<strong>输出到页面</strong>上。输出语句中可以定义什么，该脚本中就可以定义什么。</p>
<p><img src="/2022/12/21/JavaWeb/image-20230223000057595.png" alt="image-20230223000057595"></p>
<p>比如说可以用来输出某个变量的值。注意这东西由于本质上是写在Servlet的service方法中的，因而当成员变量和service方法的局部变量重名，会依据就近原则优先使用局部变量的值。</p>
</li>
</ol>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>也就是jsp开头那些东西，比如说这个：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>

<p>用来配置jsp的资源页面信息</p>
<ul>
<li>分类：<ol>
<li>page        ： 配置JSP页面的<ul>
<li>contentType：等同于response.setContentType()  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>设置响应体的mime类型以及字符集</li>
<li>设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）</li>
</ol>
</li>
<li>import：导包</li>
<li>errorPage：当前页面发生异常后，会自动跳转到指定的错误页面</li>
<li>isErrorPage：标识当前页面是否是错误页面。<ul>
<li>true：是，可以使用内置对象exception【用来获取异常名称/信息等】</li>
<li>false：否。默认值。不可以使用内置对象exception</li>
</ul>
</li>
</ul>
</li>
<li>include    ： 页面包含的。导入页面的资源文件，可以引入其它的jsp或者html，引入之后就会展示同样的内容。<ul>
<li>&lt;%@include file=”top.jsp”%&gt;</li>
</ul>
</li>
<li>taglib导入资源。用来导入标签库<pre><code>    * &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
        * prefix：前缀，自定义的。之后就可以用`&lt;c:XXX&gt;`了。相当于什么std::。
</code></pre>
</li>
</ol>
</li>
</ul>
<h4 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h4><p>但是注意一点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取流对象之前，设置流的默认编码：ISO-8859-1 设置为：GBK</span></span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//告诉浏览器，服务器发送的消息体数据的编码。建议浏览器使用该编码解码</span></span><br><span class="line">response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样做在Servlet不会导致中文乱码，但JSP不行，这个大概是因为两者原理不一样。</p>
<p>Servlet的中文乱码：</p>
<img src="/2022/12/21/JavaWeb/aWorkStorage\hexo\blog\source\_posts\JavaWeb\image-20230222231756277.png" alt="image-20230222231756277">

<p>JSP的：</p>
<p><img src="/2022/12/21/JavaWeb/image-20230222231820358.png" alt="image-20230222231820358"></p>
<p>Servlet乱码是因为客户端和response请求体编码不一致，JSP乱码与JSP的原理有关，是只跟服务器端有关</p>
<blockquote>
<p>编译jsp有以下几个步骤：<br>(1)把jsp转化为<strong>java源码</strong>。pageEncoding=xxx指定以xxx编码格式读取jsp文件，因此，jsp文件的编码格式应与pageEncoding值一致。<br>(2)把java源码编译为字节码，即.class文件。转化后的java源码为utf-8编码格式，字节码也为utf-8编码，我们无需干预。<br>(3)执行.class文件。在此过程，需向浏览器发送中文字符，contentType=xxx指定了jsp以xxx编码显示字符。也就是在浏览器中查看页面编码，其值为contentType指定的编码。</p>
<p>因此，在1、3环节，**只要指定一致的编码格式(jsp文件编码格式=pageEncoding=contentType)**，即可保证jsp页面不出现乱码。<br>举例：jsp文件以utf-8格式编写，那么pageEncoding=utf-8, contentType=utf-8，就保证了jsp页面不出现乱码。<br>————————————————<br>版权声明：本文为CSDN博主「liuhaidl」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/liuhaidl/article/details/84012372">https://blog.csdn.net/liuhaidl/article/details/84012372</a></p>
</blockquote>
<p>指定方法是在JSP开头添加：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>在jsp页面中不需要获取和创建，可以直接使用的对象。</p>
<p>jsp一共有9个内置对象。</p>
<ol>
<li><p>request     <code>HttpServletRequest</code>    一次请求访问的多个资源(转发)</p>
</li>
<li><p>response   <code>HttpServletResponse</code>        响应对象</p>
</li>
<li><p>out：   <code>JspWriter</code>    字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似</p>
<ul>
<li>response.getWriter()和out.write()的<strong>区别</strong>：  在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。因而response.getWriter()数据输出永远在out.write()之前  所以说，用out更好，因为它<strong>跟随你布局变化</strong>，你out写在哪，这句话最终就会输出在哪</li>
</ul>
</li>
<li><p>pageContext    <code>PageContext</code>    当前页面共享数据，<strong>还可以获取其他八个内置对象</strong></p>
</li>
<li><p>session    <code>HttpSession</code>    一次会话的多个请求间</p>
</li>
<li><p>application    <code>ServletContext</code>    所有用户间共享数据</p>
</li>
<li><p>page    <code>Object</code>    当前页面(Servlet)的对象，相当于<code>this</code></p>
</li>
<li><p>config    <code>ServletConfig</code>    Servlet的配置对象</p>
</li>
<li><p>exception    <code>Throwable</code>    异常对象。只在page指令的<code>isErrorPage</code>为true的情况下才能使用此对象。</p>
</li>
</ol>
<p>其中，</p>
<p><img src="/2022/12/21/JavaWeb/image-20230307144539506.png" alt="image-20230307144539506"></p>
<p>这四个为用来共享数据的域对象</p>
<h3 id="演变：MVC开发模式"><a href="#演变：MVC开发模式" class="headerlink" title="演变：MVC开发模式"></a>演变：MVC开发模式</h3><h4 id="jsp的演变"><a href="#jsp的演变" class="headerlink" title="jsp的演变"></a>jsp的演变</h4><p><img src="/2022/12/21/JavaWeb/image-20230307145442383.png" alt="image-20230307145442383"></p>
<h4 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h4><p>将程序分成三个部分，分别是M-V-C。</p>
<ol>
<li>M：Model，模型。JavaBean<ul>
<li>完成具体的业务操作，如：查询数据库，封装对象</li>
</ul>
</li>
<li>V：View，视图。<strong>JSP</strong><ul>
<li><strong>展示数据</strong></li>
</ul>
</li>
<li>C：Controller，控制器。Servlet<ul>
<li>获取用户的输入</li>
<li>调用模型</li>
<li>将数据交给视图进行展示【域对象共享数据】</li>
</ul>
</li>
</ol>
<p><img src="/2022/12/21/JavaWeb/image-20230307150845273.png" alt="image-20230307150845273"></p>
<p>服务器将接收的请求给控制器处理，控制器控制model完成必要的运算，model把算出的东西返回给控制器，控制器再把数据交给视图展示，数据最终就回到了浏览器客户端。</p>
<p>这就算是一个微型CPU了吧，控制器就是CU，模型就是ALU，也许客户端和视图什么的可以视为IO接口。</p>
<ul>
<li><p>优缺点：</p>
<ol>
<li><p>优点：</p>
<ol>
<li>耦合性低，方便维护，可以利于分工协作</li>
<li>重用性高</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>使得项目架构变得复杂，对开发人员要求高</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>那么，我们可以知道，jsp就只需负责数据的展示了。那怎么展示数据呢？这就需要用到jsp的几个技术了：</p>
<h3 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h3><blockquote>
<p>注意，servlet3.0以来默认关闭el表达式解析，需要手动在page上加属性打开，详见 <a href="https://blog.csdn.net/mfysss/article/details/128358262">jsp文件中的el表达式失效问题解决</a></p>
</blockquote>
<p>Expression language，替换和简化jsp上java代码的书写</p>
<p>语法：${表达式}</p>
<p>jsp会执行里面的表达式，然后把结果输出。</p>
<p><img src="/2022/12/21/JavaWeb/image-20230307151706211.png" alt="image-20230307151706211"></p>
<p>加反斜杠可忽略。</p>
<p>使用场景：</p>
<ol>
<li><p>运算</p>
<pre><code>      1. 算数运算符： + - *  / %
      2. 比较运算符： &gt; &lt; &gt;= &lt;= == !=
      3. 逻辑运算符： &amp;&amp; || !
      4. 空运算符： empty
   * 功能：用于判断字符串、集合、数组对象是否为null**或者**长度是否为0
   * `$&#123;empty 变量名&#125;`: 判断字符串、集合、数组对象是否为null或者长度为0
   * `$&#123;not empty 变量名&#125;`: 表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0
</code></pre>
</li>
<li><p>获取值</p>
<ol>
<li><p>el表达式只能从域对象中获取值</p>
<p><img src="/2022/12/21/JavaWeb/image-20230307144539506.png" alt="image-20230307144539506"></p>
</li>
<li><p>语法：</p>
<ol>
<li><code>$&#123;域名称.键名&#125;</code>：从指定域中获取指定键的值</li>
</ol>
<ul>
<li>域名称：<ol>
<li><code>pageScope</code>        –&gt; pageContext</li>
<li><code>requestScope</code>     –&gt; request</li>
<li><code>sessionScope</code>     –&gt; session</li>
<li><code>applicationScope</code> –&gt; application（ServletContext）</li>
</ol>
</li>
<li>举例：在request域中存储了name=张三，获取：<code>$&#123;requestScope.name&#125;</code></li>
</ul>
<ol start="2">
<li><code>$&#123;键名&#125;</code>：表示<u>依次从最小的域中</u>查找是否有该键对应的值，直到找到为止。</li>
</ol>
</li>
<li><p>案例</p>
<p>这样一来，访问<code>/demo</code>就能转发到<code>index.jsp</code>，显示出属性值</p>
<ol>
<li><p>Servlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xiunian&quot;</span>);</span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/index.jsp&quot;</span>).forward(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>index.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span> isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">$&#123;requestScope.name&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>获取非字符串类型的值</p>
<ol>
<li><p>对象</p>
</li>
<li><p>集合（List、Map等）</p>
</li>
</ol>
</li>
<li></li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读JDK容器部分源码的心得体会1【Collection部分】</title>
    <url>/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/</url>
    <content><![CDATA[<blockquote>
<p>idea 替换注释正则表达式<code>/\*&#123;1,2&#125;[\s\S]*?\*/</code></p>
<p>typora 替换图片asset</p>
<p>  <code>\!\[.*\]\(D:\\aWorkStorage\\hexo\\blog\\source\\_posts\\阅读JDK容器部分源码的心得体会1【Collection部分】\\(.*)\.png\)</code>，</p>
<p>替换结果<code>&#123;% asset_img $1.png %&#125;</code></p>
</blockquote>
<img src="/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/2243690-9cd9c896e0d512ed.gif" class> 

<img src="/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/format,png.png" class> 

<h2 id="迭代器相关接口"><a href="#迭代器相关接口" class="headerlink" title="迭代器相关接口"></a>迭代器相关接口</h2><h3 id="Iterable-I"><a href="#Iterable-I" class="headerlink" title="Iterable(I)"></a>Iterable(I)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*实现这个接口的类可用于for-each循环*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">      </span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*对Iterator内每个元素实施此操作，直到遍历完或者抛出异常。*/</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引入迭代器的目的是为了**<u>统一</u>**“对容器里的元素进行遍历”这一操作。</p>
</blockquote>
<h3 id="Iterator-I"><a href="#Iterator-I" class="headerlink" title="Iterator(I)"></a>Iterator(I)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//之后还有没有元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回当前所指元素，并且将iterator指针下移</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//This call can be made only if neither remove nor add have been called after the last call to next or previous.</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><u>注意，iterator并不指向具体元素，它指向的是元素的间隙</u></strong></p>
<p>这些^就是iterator所指的位置。这样就能理解iterator的next和previous了吧2333</p>
<img src="/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/image-20221016135757094.png" class> 

<p>而set()所修改的元素，是其上一次调用next()或者previous()方法所返回的元素。</p>
<p><a href="https://stackoverflow.com/questions/74010115/whats-the-meaning-of-this-source-code-of-interface-collection-in-java">What’s the meaning of this source code of interface Collection in JAVA?</a></p>
</blockquote>
<h3 id="ListIterator-I"><a href="#ListIterator-I" class="headerlink" title="ListIterator(I)"></a>ListIterator(I)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">	E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//newly added as iterator below:</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回后续调用 next 将返回的元素的索引。[应该就是当前元素索引]</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//This call can be made only if neither remove nor add have been called after the last call to next or previous.</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The element is inserted immediately before the element that would be returned by next, if any, and after the element that would be returned by previous, if any.</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note that the <u>remove</u> and <u>set</u>(Object) methods are not defined in terms of the cursor position; <strong>they are defined to operate on the last element returned by a call to <u>next</u> or <u>previous</u>().</strong></p>
</blockquote>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="Collection-I"><a href="#Collection-I" class="headerlink" title="Collection(I)"></a>Collection(I)</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">无直接实现类，一般用于需要使用多态传递参数的场合</span></span><br><span class="line"><span class="comment">其所有子类都必须有两个构造器： a void (no arguments) constructor, which creates an empty collection, and a constructor with a single argument of type Collection, which creates a new collection with the same elements as its argument. 这点语法上不会强制实现（因为接口不能强制构造方法），但其实是约定成俗的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有关“safe”的问题讨论见下</span></span><br><span class="line">    Object[] toArray();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Like the toArray() method, this method acts as bridge between array-based and 	</span></span><br><span class="line"><span class="comment">    collection-based APIs. Further, this method allows precise control over the runtime </span></span><br><span class="line"><span class="comment">    type of the output array, and may, under certain circumstances, be used to save </span></span><br><span class="line"><span class="comment">    allocation costs.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Suppose x is a collection known to contain only strings. The following code can be </span></span><br><span class="line"><span class="comment">    used to dump the collection into a newly allocated array of String:</span></span><br><span class="line"><span class="comment">      String[] y = x.toArray(new String[0]);</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      说明还是有类型限制的</span></span><br><span class="line"><span class="comment">      ArrayStoreException – if the runtime type of the specified array is not a supertype</span></span><br><span class="line"><span class="comment">      of the runtime type of every element in this collection</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    给集合增加一个元素。</span></span><br><span class="line"><span class="comment">    If a collection refuses to add a particular element for any reason other than that it </span></span><br><span class="line"><span class="comment">    already contains the element, it must throw an exception (rather than returning </span></span><br><span class="line"><span class="comment">    false). </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重复了怎么办</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重复的会全弄走吗</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    删除此集合中满足给定谓词的所有元素。 </span></span><br><span class="line"><span class="comment">    在迭代期间或由谓词引发的错误或运行时异常将转发给调用者。</span></span><br><span class="line"><span class="comment">    @return true if any elements were removed</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">        <span class="comment">//非空filter</span></span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//迭代该集合</span></span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();</span><br><span class="line">        <span class="keyword">while</span> (each.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter.test(each.next())) &#123;</span><br><span class="line">                each.remove();</span><br><span class="line">                removed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    把集合c中没有的元素全部移除</span></span><br><span class="line"><span class="comment">    @return true if this collection changed as a result of the call</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Any class that overrides the Object.equals method must also override the</span></span><br><span class="line"><span class="comment">    Object.hashCode method.</span></span><br><span class="line"><span class="comment">    c1.equals(c2) 相当于 c1.hashCode()==c2.hashCode().</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其中，"><a href="#其中，" class="headerlink" title="其中，"></a>其中，</h4><ol>
<li><h5 id="“Bags-or-multisets-unordered-collections-that-may-contain-duplicate-elements-should-implement-this-interface-directly-”"><a href="#“Bags-or-multisets-unordered-collections-that-may-contain-duplicate-elements-should-implement-this-interface-directly-”" class="headerlink" title="“Bags or multisets (unordered collections that may contain duplicate elements) should implement this interface directly.”"></a>“Bags or multisets (unordered collections that may contain duplicate elements) should implement this interface directly.”</h5><p>Set是不允许重复的元素集合的ADT,【ADT：抽象数据结构】</p>
<p>Bag是元素集合的ADT,允许重复.</p>
<p>通常,任何包含元素的东西都是Collection.</p>
<p>任何允许重复的集合都是Bag,否则就是Set.</p>
<p>通过索引访问元素的任何包都是List.</p>
<p>在最后一个之后附加新元素并且具有从头部(第一索引)移除元素的方法的Bag是Queue.</p>
<p>在最后一个之后附加新元素并且具有从尾部(最后一个索引)移除元素的方法的Bag是Stack.<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/weixin_34239718/article/details/114036886">https://blog.csdn.net/weixin_34239718/article/details/114036886</a></p>
</li>
<li><h5 id="“destructive”-methods-和”undestructive”-methods"><a href="#“destructive”-methods-和”undestructive”-methods" class="headerlink" title="“destructive” methods 和”undestructive” methods"></a>“destructive” methods 和”undestructive” methods</h5><p>这回答里写得很清楚：<a href="https://stackoverflow.com/questions/42827733/what-are-destructive-and-non-destructive-methods-in-java">What are destructive and non-destructive methods in java?</a></p>
</li>
<li><h5 id="recursive-traversal-of-the-collection"><a href="#recursive-traversal-of-the-collection" class="headerlink" title="recursive traversal of the collection"></a>recursive traversal of the collection</h5><blockquote>
<p>Some collection operations which perform recursive traversal of the collection may fail with an exception for self-referential instances where the collection directly or indirectly contains itself.</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/45743814/java-8-vs-java-7-collection-interface-self-referential-instance">Java 8 vs Java 7 Collection Interface: self-referential instance</a></p>
<p>这个的第二个回答【较长的那个】写得很棒，较短的那个似乎是错误的。</p>
<p>正如描述所说的，“directly or indirectly contains itself”，回答里那个例子正是因为“indirectly contains itself”。</p>
<p>不仅仅是集合，每个Object都可能出现这样的错误（因为都包含有toString）</p>
<p>但是注意一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">l1.add(l1);</span><br><span class="line">System.out.println(l1.toString());</span><br><span class="line"><span class="comment">//输出：[(this Collection)]</span></span><br></pre></td></tr></table></figure>

<p>这段代码是正常的，是因为ArrayList里面toString的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="comment">//注意此句</span></span><br><span class="line">    sb.append(e == <span class="built_in">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);</span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">    <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规避了这种风险。</p>
<p>下面的hashcode是不正常的，因为hashcode实现没有规避这种风险。</p>
</li>
<li><h5 id="关于toArray的讨论"><a href="#关于toArray的讨论" class="headerlink" title="关于toArray的讨论"></a>关于toArray的讨论</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For toArray() :</span><br><span class="line">The returned array will be &quot;safe&quot; in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>);</span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">array[<span class="number">0</span>] = <span class="string">&quot;qux&quot;</span>;</span><br><span class="line"><span class="comment">//修改数组不会修改列表</span></span><br><span class="line">System.out.println(list.get(<span class="number">0</span>));  <span class="comment">// still &quot;foo&quot;</span></span><br><span class="line">list.set(<span class="number">0</span>,<span class="string">&quot;haha&quot;</span>);</span><br><span class="line"><span class="comment">//修改列表也跟修改数组无关了</span></span><br><span class="line">System.out.println(list.get(<span class="number">0</span>)+array[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Student&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Sarah&quot;</span>,<span class="number">17</span>));</span><br><span class="line">Student[] s = a.toArray(<span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//换一个引用对象</span></span><br><span class="line">s[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lily&quot;</span>,<span class="number">20</span>);</span><br><span class="line">System.out.println(a.get(<span class="number">0</span>)==s[<span class="number">0</span>]);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Student&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Sarah&quot;</span>,<span class="number">17</span>));</span><br><span class="line">Student[] s = a.toArray(<span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//修改引用对象</span></span><br><span class="line">s[<span class="number">0</span>].name = <span class="string">&quot;Lily&quot;</span>;</span><br><span class="line">System.out.println(a.get(<span class="number">0</span>).name);<span class="comment">//Lily</span></span><br></pre></td></tr></table></figure>

<p>这也就说明，toArray()实际上是把list的元素复制一份弄成array，直接把值粘贴进去。</p>
<p>对于引用对象，list的元素实际上应该存的是对象在堆中的地址。所谓的“安全”指的是，修改array中的元素的值【也即对象地址】，也就是换一个气球牵，是不会影响原来list的元素的值的。</p>
<p>因而，对于样例1和2，我们其实给array的元素换了个气球牵，或者是把list换了个气球牵，相互对象不同，没什么影响。</p>
<p>对于样例3，我们修改了list和array共同指向的对象【就像C语言的指针那样】</p>
<p>以上参考自<a href="https://stackoverflow.com/questions/18638847/what-does-safe-mean-in-the-collections-toarray-javadoc">What does “Safe” mean in the Collections.toArray() JavaDoc?</a></p>
</li>
<li><h5 id="关于default关键字"><a href="#关于default关键字" class="headerlink" title="关于default关键字"></a>关于default关键字</h5><p><a href="https://blog.csdn.net/weixin_54438368/article/details/121875361">java中default关键字</a></p>
<p>starkoverflow关于为什么要设立default的讨论：</p>
<p><a href="https://stackoverflow.com/questions/31578427/what-is-the-purpose-of-the-default-keyword-in-java">What is the purpose of the default keyword in Java</a></p>
<p><code>Default methods were added to Java 8 primarily to support lambda expressions.</code></p>
</li>
</ol>
<h3 id="AbstractCollection-A"><a href="#AbstractCollection-A" class="headerlink" title="AbstractCollection(A)"></a>AbstractCollection(A)</h3><blockquote>
<p>To implement an <strong>unmodifiable</strong> collection, the programmer needs only to <strong>extend</strong> this class and provide implementations for the <strong>iterator</strong> and <strong>size</strong> methods.<br>To implement a <strong>modifiable</strong> collection, the programmer must <strong>additionally[也要搞上面的]</strong> <strong>override</strong> this class’s <strong>add</strong> method (which otherwise throws an UnsupportedOperationException), and the <strong>iterator</strong> returned by the iterator method must additionally implement its <strong>remove</strong> method.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//唯一的构造函数。 （用于子类构造函数的调用，通常是隐式的。）</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractCollection</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">if</span> (o==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">                <span class="keyword">if</span> (it.next()==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">                <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="comment">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class="line">        Object[] r = <span class="keyword">new</span> <span class="title class_">Object</span>[size()];</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! it.hasNext()) <span class="comment">// fewer elements than expected</span></span><br><span class="line">                <span class="keyword">return</span> Arrays.copyOf(r, i);</span><br><span class="line">            r[i] = it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="comment">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> size();</span><br><span class="line">        <span class="comment">//通过反射得到a同类型的数组实例</span></span><br><span class="line">        T[] r = a.length &gt;= size ? a :</span><br><span class="line">                (T[])java.lang.reflect.Array</span><br><span class="line">                        .newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! it.hasNext()) &#123; <span class="comment">// fewer elements than expected</span></span><br><span class="line">                <span class="keyword">if</span> (a == r) &#123;</span><br><span class="line">                    r[i] = <span class="literal">null</span>; <span class="comment">// null-terminate用null来标记数组结束。但如果数组里也有null该怎么办？从前面的contains来看也是有可能的</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.length &lt; i) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Arrays.copyOf(r, i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.arraycopy(r, <span class="number">0</span>, a, <span class="number">0</span>, i);</span><br><span class="line">                    <span class="keyword">if</span> (a.length &gt; i) &#123;</span><br><span class="line">                        a[i] = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">            r[i] = (T)it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// more elements than expected</span></span><br><span class="line">        <span class="keyword">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为啥要-8？</span></span><br><span class="line"><span class="comment">    Some VMs reserve some header words in an array. Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">    好像是因为要给8个字节保留作为数组的头标题。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//Reallocates the array being used within toArray when the iterator returned more elements than expected, and finishes filling it from the iterator.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r.length;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> r.length;</span><br><span class="line">            <span class="comment">//说明此时需要扩容</span></span><br><span class="line">            <span class="keyword">if</span> (i == cap) &#123;</span><br><span class="line">                <span class="comment">//每次扩当前大小的1/2</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">newCap</span> <span class="operator">=</span> cap + (cap &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// overflow-conscious code 溢出</span></span><br><span class="line">                <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//cap+1 扩容后至少应该比原大小大1</span></span><br><span class="line">                    newCap = hugeCapacity(cap + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//申请一个船新数组空间</span></span><br><span class="line">                r = Arrays.copyOf(r, newCap);</span><br><span class="line">            &#125;</span><br><span class="line">            r[i++] = (T)it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果过度扩容了就缩小回刚刚好</span></span><br><span class="line">        <span class="keyword">return</span> (i == r.length) ? r : Arrays.copyOf(r, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//如果最小扩容也失败，说明要的东西太多了，救不了</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span></span><br><span class="line">                    (<span class="string">&quot;Required array size too large&quot;</span>);</span><br><span class="line">        <span class="comment">//否则</span></span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">                Integer.MAX_VALUE :</span><br><span class="line">                MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改操作</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">if</span> (o==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it.next()==<span class="literal">null</span>) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(it.next())) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量操作</span></span><br><span class="line">	<span class="comment">//O(n^2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : c)</span><br><span class="line">            <span class="keyword">if</span> (!contains(e))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c)</span><br><span class="line">            <span class="keyword">if</span> (add(e))</span><br><span class="line">                modified = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        Iterator&lt;?&gt; it = iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.contains(it.next())) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                modified = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!c.contains(it.next())) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                modified = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">            sb.append(e == <span class="built_in">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);</span><br><span class="line">            <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">                <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">            sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol>
<li><h5 id="在toArray方法中，为什么需要写这么奇怪的代码？"><a href="#在toArray方法中，为什么需要写这么奇怪的代码？" class="headerlink" title="在toArray方法中，为什么需要写这么奇怪的代码？"></a>在toArray方法中，为什么需要写这么奇怪的代码？</h5><p><a href="https://stackoverflow.com/questions/8401644/whats-the-usage-of-the-code-in-the-implementation-of-abstractcollections-toarr">what’s the usage of the code in the implementation of AbstractCollection’s toArray Method</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes, you&#x27;re right, as the javadoc sais, this method is prepared to return correctlly even if the Collection has been modified in the mean time.【并发安全】 That&#x27;s why the initial size is just a hint. The usage of the iterator also ensures avoidance from the &quot;concurrent modification&quot; exception.</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="Queue-I"><a href="#Queue-I" class="headerlink" title="Queue(I)"></a>Queue(I)</h3><blockquote>
<img src="/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/image-20221014220036842.png" class> 

<p>The Queue interface does not define the <strong>blocking queue methods</strong>, which are common in <strong>concurrent</strong> programming. These methods, which wait for elements to appear or for space to become available, are defined in the <strong>java.util.concurrent.BlockingQueue</strong> interface, which extends this interface.</p>
<p>Queue implementations generally <strong>do not define element-based versions</strong> of methods <strong>equals</strong> and <strong>hashCode</strong>【就是不会像之前的list一样遍历一遍通过单个元素的hashcode计算整体的hashcode】 but instead inherit the identity based versions from class Object【hashcode由对象决定】, because element-based equality is not always well-defined for queues with the same elements but different ordering properties.</p>
<p>Each of these methods exists in <strong>two forms</strong>: one throws an <strong>exception</strong> if the operation fails, the other returns a <strong>special value</strong> (either null or false, depending on the operation). 容量受限的队列推荐使用第二种form</p>
</blockquote>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The offer method inserts an element if possible, otherwise returning false. </span></span><br><span class="line"><span class="comment">    不同于Collection的add方法，offer添加失败时不会抛出异常，而是直接return false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">     The remove() and poll() methods differ only in their behavior </span></span><br><span class="line"><span class="comment">     when the queue is empty: </span></span><br><span class="line"><span class="comment">     the remove() method throws an exception, while the poll() method returns null.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The element() and peek() methods return, </span></span><br><span class="line"><span class="comment">	but do not remove, the head of the queue.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Deque-I"><a href="#Deque-I" class="headerlink" title="Deque(I)"></a>Deque(I)</h3><blockquote>
<p>双端队列。</p>
<p>The name deque is short for “double ended queue” and is usually pronounced “deck”.</p>
<img src="/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/image-20221014221328185.png" class> 

<p>This interface provides two methods to remove interior elements, removeFirstOccurrence and removeLastOccurrence.</p>
<img src="/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/image-20221014221450351.png" class> 

<img src="/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/image-20221014221511718.png" class> 


</blockquote>
<h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">removeFirst</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">pollFirst</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">pollLast</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">peekFirst</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">peekLast</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeLastOccurrence</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Queue methods ***</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Stack methods ***</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">pop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Collection methods ***</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//Returns an iterator over the elements in this deque in reverse sequential order. </span></span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><blockquote>
<p><strong>Resizable-array</strong> implementation of the Deque interface. </p>
<p>不允许空</p>
<p>Array deques have <u>no capacity restrictions</u>; they grow as necessary to support usage.</p>
<p>not thread-safe【相比于由vector实现的线程安全的Stack】</p>
<p><u>This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue.</u>【6】</p>
<p>fail-fast</p>
</blockquote>
<h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;E&gt;, Cloneable, Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//非private以让内部类能够访问到</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The capacity of the deque is the length of this array, </span></span><br><span class="line"><span class="comment">    which is always a power of two. capacity只能是2的幂次</span></span><br><span class="line"><span class="comment">    不能满【原理应该跟循环队列差不多，是怕头尾混淆】</span></span><br><span class="line"><span class="comment">    但允许短暂的满之后马上扩容</span></span><br><span class="line"><span class="comment">    所有不包含元素的数组单元为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elements; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//The index of the element at the head of the deque</span></span><br><span class="line">    <span class="comment">//(which is the element that would be removed by remove() or pop());</span></span><br><span class="line">    <span class="comment">//or an arbitrary number equal to tail if the deque is empty.</span></span><br><span class="line">    <span class="comment">//head在下标大的地方</span></span><br><span class="line">	<span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The index at which the 【next】 element would be added to the tail of the deque </span></span><br><span class="line">    <span class="comment">//(via addLast(E), add(E), or push(E)).</span></span><br><span class="line">    <span class="comment">//tail在下标小的地方</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ******  Array allocation and resizing utilities ******</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateSize</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">initialCapacity</span> <span class="operator">=</span> MIN_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// Find the best power of two to hold elements.</span></span><br><span class="line">        <span class="comment">// Tests &quot;&lt;=&quot; because arrays aren&#x27;t kept full.</span></span><br><span class="line">        <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">            <span class="comment">//原理类似HashMap.tableSizeFor</span></span><br><span class="line">            <span class="comment">//这一通操作可以得到比cap大的，且离cap最近的2的幂次方数</span></span><br><span class="line">            initialCapacity = numElements;</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            initialCapacity++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">                initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> initialCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">allocateElements</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[calculateSize(numElements)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doubleCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> head == tail;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - p; <span class="comment">// number of elements to the right of p</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">        Object[] a = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">        <span class="comment">//以head==tail为分界线，右边那段移到开头，左边那段移到后面</span></span><br><span class="line">        System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">        System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">        elements = a;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T[] copyElements(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head &lt; tail) &#123;</span><br><span class="line">            System.arraycopy(elements, head, a, <span class="number">0</span>, size());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head &gt; tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">headPortionLen</span> <span class="operator">=</span> elements.length - head;</span><br><span class="line">            System.arraycopy(elements, head, a, <span class="number">0</span>, headPortionLen);</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, a, headPortionLen, tail);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">16</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">        allocateElements(numElements);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        allocateElements(c.size());</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The main insertion and extraction methods are addFirst,</span></span><br><span class="line">    <span class="comment">// addLast, pollFirst, pollLast. The other methods are defined in</span></span><br><span class="line">    <span class="comment">// terms of these.就是说这几个最重要，别的方法都是这四个的附庸</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">if</span> (head == tail)</span><br><span class="line">            <span class="comment">//队列满</span></span><br><span class="line">            doubleCapacity();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        elements[tail] = e;</span><br><span class="line">        <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">            <span class="comment">//队列满</span></span><br><span class="line">            doubleCapacity();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> pollFirst();</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> pollLast();</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[h];</span><br><span class="line">        <span class="comment">// Element is null if deque empty</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        elements[h] = <span class="literal">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">        head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[t];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        elements[t] = <span class="literal">null</span>;</span><br><span class="line">        tail = t;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[head];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// elements[head] is null if deque empty</span></span><br><span class="line">        <span class="keyword">return</span> (E) elements[head];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//掩码</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> elements.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head;</span><br><span class="line">        Object x;</span><br><span class="line">        <span class="keyword">while</span> ( (x = elements[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x)) &#123;</span><br><span class="line">                delete(i);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//头-&gt;尾</span></span><br><span class="line">            i = (i + <span class="number">1</span>) &amp; mask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeLastOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> elements.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (tail - <span class="number">1</span>) &amp; mask;</span><br><span class="line">        Object x;</span><br><span class="line">        <span class="keyword">while</span> ( (x = elements[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x)) &#123;</span><br><span class="line">                delete(i);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尾-&gt;头</span></span><br><span class="line">            i = (i - <span class="number">1</span>) &amp; mask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Queue methods ***</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> offerLast(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">element</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Stack methods ***</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查队列情况正常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkInvariants</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> elements[tail] == <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果成立，只能是队列空；不成立的话，不能有空元素</span></span><br><span class="line">        <span class="keyword">assert</span> head == tail ? elements[head] == <span class="literal">null</span> :</span><br><span class="line">                (elements[head] != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">assert</span> elements[(head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Returns: true if elements moved backwards而不是操作是否成功</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        checkInvariants();</span><br><span class="line">        <span class="keyword">final</span> Object[] elements = <span class="built_in">this</span>.elements;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> elements.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">front</span> <span class="operator">=</span> (i - h) &amp; mask;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">back</span>  <span class="operator">=</span> (t - i) &amp; mask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invariant: head &lt;= i &lt; tail mod circularity</span></span><br><span class="line">        <span class="keyword">if</span> (front &gt;= ((t - h) &amp; mask))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optimize for least element motion</span></span><br><span class="line">        <span class="keyword">if</span> (front &lt; back) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h &lt;= i) &#123;</span><br><span class="line">                <span class="comment">//把i覆盖掉了</span></span><br><span class="line">                System.arraycopy(elements, h, elements, h + <span class="number">1</span>, front);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Wrap around</span></span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, elements, <span class="number">1</span>, i);</span><br><span class="line">                elements[<span class="number">0</span>] = elements[mask];</span><br><span class="line">                System.arraycopy(elements, h, elements, h + <span class="number">1</span>, mask - h);</span><br><span class="line">            &#125;</span><br><span class="line">            elements[h] = <span class="literal">null</span>;</span><br><span class="line">            head = (h + <span class="number">1</span>) &amp; mask;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; t) &#123; <span class="comment">// Copy the null tail as well</span></span><br><span class="line">                System.arraycopy(elements, i + <span class="number">1</span>, elements, i, back);</span><br><span class="line">                <span class="comment">//注意没设置空，因为确实不用</span></span><br><span class="line">                tail = t - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Wrap around</span></span><br><span class="line">                System.arraycopy(elements, i + <span class="number">1</span>, elements, i, mask - i);</span><br><span class="line">                elements[mask] = elements[<span class="number">0</span>];</span><br><span class="line">                System.arraycopy(elements, <span class="number">1</span>, elements, <span class="number">0</span>, t);</span><br><span class="line">                tail = (t - <span class="number">1</span>) &amp; mask;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Collection Methods ***</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (tail - head) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//The elements will be ordered from first (head) to last (tail).</span></span><br><span class="line">    <span class="comment">//This is the same order that elements would be dequeued </span></span><br><span class="line">    <span class="comment">//(via successive calls to remove or popped (via successive calls to pop).</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DeqIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DescendingIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DeqIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Tail recorded at construction (also in remove), to stop iterator[怪不得叫fence]</span></span><br><span class="line">        <span class="comment">//and also to check for comodification[检查并发].</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fence</span> <span class="operator">=</span> tail;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != fence;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor == fence)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[cursor];</span><br><span class="line">            <span class="comment">// This check doesn&#x27;t catch all possible comodifications,</span></span><br><span class="line">            <span class="comment">// but does catch the ones that corrupt traversal【破坏遍历的】</span></span><br><span class="line">            <span class="comment">//tail!=fence说明迭代时修改。</span></span><br><span class="line">            <span class="keyword">if</span> (tail != fence || result == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            lastRet = cursor;</span><br><span class="line">            cursor = (cursor + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> (delete(lastRet)) &#123; <span class="comment">// if left-shifted, undo increment in next()</span></span><br><span class="line">                cursor = (cursor - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//update</span></span><br><span class="line">                fence = tail;</span><br><span class="line">            &#125;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">            Objects.requireNonNull(action);</span><br><span class="line">            Object[] a = elements;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> a.length - <span class="number">1</span>, f = fence, i = cursor;</span><br><span class="line">            <span class="comment">//4执行完后直接迭代结束</span></span><br><span class="line">            cursor = f;</span><br><span class="line">            <span class="keyword">while</span> (i != f) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E)a[i];</span><br><span class="line">                i = (i + <span class="number">1</span>) &amp; m;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">                action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DescendingIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">//终点为fence，此时终点为head</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fence</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != fence;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor == fence)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            cursor = (cursor - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[cursor];</span><br><span class="line">            <span class="keyword">if</span> (head != fence || result == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            lastRet = cursor;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            <span class="keyword">if</span> (!delete(lastRet)) &#123;</span><br><span class="line">                cursor = (cursor + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">                fence = head;</span><br><span class="line">            &#125;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不支持for-each了吧233</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> elements.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head;</span><br><span class="line">        Object x;</span><br><span class="line">        <span class="keyword">while</span> ( (x = elements[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            i = (i + <span class="number">1</span>) &amp; mask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirstOccurrence(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (h != t) &#123; <span class="comment">// clear all cells</span></span><br><span class="line">            head = tail = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> elements.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                elements[i] = <span class="literal">null</span>;</span><br><span class="line">                i = (i + <span class="number">1</span>) &amp; mask;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> copyElements(<span class="keyword">new</span> <span class="title class_">Object</span>[size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> size();</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                    a.getClass().getComponentType(), size);</span><br><span class="line">        copyElements(a);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Object methods ***</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayDeque&lt;E&gt; <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            ArrayDeque&lt;E&gt; result = (ArrayDeque&lt;E&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">            result.elements = Arrays.copyOf(elements, elements.length);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2340985798034038923L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> java.io.IOException &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DeqSpliterator</span>&lt;E&gt;(<span class="built_in">this</span>, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DeqSpliterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;E&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其中："><a href="#其中：" class="headerlink" title="其中："></a>其中：</h4><ol>
<li><h5 id="默认容量"><a href="#默认容量" class="headerlink" title="默认容量"></a>默认容量</h5><p>空构造器的默认容量为16</p>
</li>
<li><h5 id="head-1-amp-elements-length-1"><a href="#head-1-amp-elements-length-1" class="headerlink" title="(head - 1) &amp; (elements.length - 1)"></a>(head - 1) &amp; (elements.length - 1)</h5><p>是一个便捷的截位取余操作，这跟hashmap一个原理，详见hashmap第二点。</p>
</li>
<li><h5 id="if-delete-lastRet"><a href="#if-delete-lastRet" class="headerlink" title="if (delete(lastRet))"></a>if (delete(lastRet))</h5><p>delete方法返回true，说明右移数组，此时next指针需要++</p>
<p>delete方法返回false，说明左移数组，此时next指针不变</p>
</li>
<li><h5 id="forEachRemaining"><a href="#forEachRemaining" class="headerlink" title="forEachRemaining"></a>forEachRemaining</h5><p>跟差不多所有的迭代器实现一样，此方法执行完毕之后，cursor直接跳到数组最末，相当于迭代结束</p>
</li>
</ol>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="List-I"><a href="#List-I" class="headerlink" title="List(I)"></a>List(I)</h3><p>有序、支持随机访问</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">List 接口提供了一个特殊的迭代器，称为 ListIterator，</span></span><br><span class="line"><span class="comment">除了 Iterator 接口提供的正常操作之外，它还允许元素插入和替换以及双向访问。</span></span><br><span class="line"><span class="comment">List 接口提供了两种方法来搜索指定的对象。 从性能的角度来看，应谨慎使用这些方法。</span></span><br><span class="line"><span class="comment">在许多实现中，它们将执行代价高昂的线性搜索。</span></span><br><span class="line"><span class="comment">Note: While it is permissible for lists to contain themselves as elements, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a list.【这跟上面的引用点4是一样的。】</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    <span class="comment">//Returns true if and only if the specified object is also a list, </span></span><br><span class="line">    <span class="comment">//both lists have the same size, and all corresponding pairs of elements in the two lists are equal. </span></span><br><span class="line">    <span class="comment">//In other words, two lists are defined to be equal if they contain the same elements in the same order. </span></span><br><span class="line">    <span class="comment">//注意，对于未重载equal方法的类，引用对象的相等指的是地址相等也就是说必须是一模一样的对象，两个不同对象但值相同，这种情况是不算equal的。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//newly add or change below</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将此列表的每个元素替换为将运算符应用于该元素的结果。</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        <span class="keyword">final</span> ListIterator&lt;E&gt; li = <span class="built_in">this</span>.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (li.hasNext()) &#123;</span><br><span class="line">            li.set(operator.apply(li.next()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@SuppressWarings注解 作用:用于抑制编译器产生警告信息。 </span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = <span class="built_in">this</span>.toArray();</span><br><span class="line">        <span class="comment">//借助Arrays的sort方法</span></span><br><span class="line">        Arrays.sort(a, (Comparator) c);</span><br><span class="line">        ListIterator&lt;E&gt; i = <span class="built_in">this</span>.listIterator();</span><br><span class="line">        <span class="comment">//再线性逐一替换</span></span><br><span class="line">        <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            <span class="comment">// set:</span></span><br><span class="line">            <span class="comment">// Replaces the last element returned by next or previous </span></span><br><span class="line">            <span class="comment">// with the specified element </span></span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素，把当前位及其以后的元素都往后挪一位</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除元素，把当前位及其以后的元素都往前挪一位</span></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1 if this list does not contain the element</span></span><br><span class="line">    <span class="comment">//ClassCastException:if the type of the specified element</span></span><br><span class="line">    <span class="comment">//is incompatible with this list</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>;</span><br><span class="line">    </span><br><span class="line">    ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定的索引指示初始调用next将返回的第一个元素.对 previous 的初始调用将返回具有指定索引减一的元素。</span></span><br><span class="line">    ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[fromIndex,toIndex).If fromIndex==toIndex then return==null.</span></span><br><span class="line">    List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其中：-1"><a href="#其中：-1" class="headerlink" title="其中："></a>其中：</h4><ol>
<li><h5 id="hashcode不允许自环"><a href="#hashcode不允许自环" class="headerlink" title="hashcode不允许自环"></a>hashcode不允许自环</h5><p>Note: While it is permissible for lists to contain themselves as elements, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a list.【这跟上面的引用点4是差不多的。】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">l1.add(l1);</span><br><span class="line">System.out.println(l1.hashCode());</span><br><span class="line"><span class="comment">//输出：Stack Overflow</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="structural-and-non-structural-change-in-list"><a href="#structural-and-non-structural-change-in-list" class="headerlink" title="structural and non-structural change in list"></a>structural and non-structural change in list</h5><p><a href="https://stackoverflow.com/questions/59107018/difference-between-structural-and-non-structural-for-lists">Difference between structural and non-structural for lists</a></p>
</li>
<li><h5 id="关于sublist"><a href="#关于sublist" class="headerlink" title="关于sublist"></a>关于sublist</h5><h6 id="①-view"><a href="#①-view" class="headerlink" title="① view"></a>① view</h6><p>sublist的document有一个很有趣的点，就是把sublist称为原list的视图view，这不禁让人想起了数据库里的表和表的视图。</p>
<p>但是还是有差别的。</p>
<p>在数据库中，视图仅仅是表或表的一部分的快照，修改视图对原表没有影响。但此处，对sublist的结构性修改和非结构性修改都会使原list的对应元素发生改变。</p>
<p>但有一点是相同的。如果对原表/原list修改，那么视图就会没用/会寄掉。</p>
<p>可以像这样来对主list指定范围内的元素进行操作，免去复杂的下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//For example, the following idiom removes a range of elements from a list:</span></span><br><span class="line">list.subList(from, to).clear();</span><br></pre></td></tr></table></figure>

<h6 id="②-留下一个问题"><a href="#②-留下一个问题" class="headerlink" title="② 留下一个问题"></a>② 留下一个问题</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Student&gt; a=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lily&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Sam&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mary&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mark&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;John&quot;</span>,<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; suba=a.subList(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Firstly,suba:&quot;</span>);</span><br><span class="line">        printall(suba);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Change the value of age:&quot;</span>);</span><br><span class="line">        suba.get(<span class="number">1</span>).age=<span class="number">300</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;suba:&quot;</span>);</span><br><span class="line">        printall(suba);</span><br><span class="line">        System.out.println(<span class="string">&quot;a:&quot;</span>);</span><br><span class="line">        printall(a);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Change the address:&quot;</span>);</span><br><span class="line">        suba.set(<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;haha&quot;</span>,<span class="number">200</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;suba:&quot;</span>);</span><br><span class="line">        printall(suba);</span><br><span class="line">        System.out.println(<span class="string">&quot;a:&quot;</span>);</span><br><span class="line">        printall(a);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Change the structure of sublist:&quot;</span>);</span><br><span class="line">        suba.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;suba:&quot;</span>);</span><br><span class="line">        printall(suba);</span><br><span class="line">        System.out.println(<span class="string">&quot;a:&quot;</span>);</span><br><span class="line">        printall(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printall</span><span class="params">(List&lt;Student&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Student a : list)&#123;</span><br><span class="line">            System.out.print(a+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Firstly,suba:</span></span><br><span class="line"><span class="comment">name :Tomage :16	name :Maryage :16	name :Markage :16	</span></span><br><span class="line"><span class="comment">Change the value of age:</span></span><br><span class="line"><span class="comment">suba:</span></span><br><span class="line"><span class="comment">name :Tomage :16	name :Maryage :300	name :Markage :16	</span></span><br><span class="line"><span class="comment">a:</span></span><br><span class="line"><span class="comment">name :Lilyage :16	name :Samage :16	name :Tomage :16	name :Maryage :300	name :Markage :16	name :Johnage :16	</span></span><br><span class="line"><span class="comment">Change the address:</span></span><br><span class="line"><span class="comment">suba:</span></span><br><span class="line"><span class="comment">name :Tomage :16	name :hahaage :200	name :Markage :16	</span></span><br><span class="line"><span class="comment">a:</span></span><br><span class="line"><span class="comment">name :Lilyage :16	name :Samage :16	name :Tomage :16	name :hahaage :200	name :Markage :16	name :Johnage :16	</span></span><br><span class="line"><span class="comment">Change the structure of sublist:</span></span><br><span class="line"><span class="comment">suba:</span></span><br><span class="line"><span class="comment">name :hahaage :200	name :Markage :16	</span></span><br><span class="line"><span class="comment">a:</span></span><br><span class="line"><span class="comment">name :Lilyage :16	name :Samage :16	name :hahaage :200	name :Markage :16	name :Johnage :16	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>为什么之前的toArray得到的array换了个对象，原list不会变【详见Collection说明第五点】；而这里的sublist得到的子list换了个对象，原list也会变呢？</p>
<p>也许这跟间接寻址的级数有关？之后看过ArrayList的具体实现再来解答。</p>
<blockquote>
<p>穿越回来：</p>
<p>​    toArray得到array，是新开辟了存储空间，里面存放了原list对象的地址。因而，修改新存储空间的地址内容，原list是不变的。</p>
<p>​    但sublist连新开辟存储空间也没有，其差不多所有操作都是从list进行的。因而它换了个对象，具体实现就是让原list也换了个对象。</p>
<p>​    所以说其实前者更像是数据库里面的“视图”概念。</p>
</blockquote>
<h6 id="③-关于sublis和原list、non-structral和structural的区别："><a href="#③-关于sublis和原list、non-structral和structural的区别：" class="headerlink" title="③ 关于sublis和原list、non-structral和structural的区别："></a>③ 关于sublis和原list、non-structral和structural的区别：</h6><p><a href="https://stackoverflow.com/questions/74012620/can-structural-changes-in-sublist-reflected-in-the-original-list-in-java">Can structural changes in sublist reflected in the original list, in JAVA?</a></p>
<blockquote>
<p>In the document of List class:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>;</span><br></pre></td></tr></table></figure>

<p>Can structural changes in sublist reflected in the original list in JAVA? </p>
</blockquote>
<p>答案是会改变的。实例可看问题中代码，或者point3的代码。</p>
<p>但是既然都会变的话，为什么文档里面要特意强调“non-structural”呢？这是因为，对sublist进行结构性改变会让原list也正常地一起变，但是对原list进行结构性改变却会让sublist寄掉：</p>
<p>文档下面接着写道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)</span><br><span class="line">/*</span><br><span class="line">sublist会寄，如果其原list被结构性改变了，且是以除了通过sublist结构性改变的方式外的其他方式改变的。（结构性改变是指那些会改变list的长度，或者会使迭代失败的那些改变）</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>通过代码验证可得，确实寄了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Student&gt; a=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lily&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Sam&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mary&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mark&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;John&quot;</span>,<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; suba=a.subList(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Firstly,suba:&quot;</span>);</span><br><span class="line">        printall(suba);</span><br><span class="line">        printall(a);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Change the origin structure:&quot;</span>);</span><br><span class="line">        a.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a:&quot;</span>);</span><br><span class="line">        printall(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;suba:&quot;</span>);</span><br><span class="line">        printall(suba);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Firstly,suba:</span></span><br><span class="line"><span class="comment">name :Tomage :16	name :Maryage :16	name :Markage :16	</span></span><br><span class="line"><span class="comment">name :Lilyage :16	name :Samage :16	name :Tomage :16	name :Maryage :16	name :Markage :16	name :Johnage :16	</span></span><br><span class="line"><span class="comment">Change the origin structure:</span></span><br><span class="line"><span class="comment">a:</span></span><br><span class="line"><span class="comment">name :Lilyage :16	name :Samage :16	name :Tomage :16	name :Markage :16	name :Johnage :16	</span></span><br><span class="line"><span class="comment">suba:</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">	at java.util.ArrayList$SubList.checkForComodification(ArrayList.java:1241)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>通过以上可以感觉，估计sublist和原list的元素是共享存储空间的，只不过可能对象里有相关维护的变量。<code>Any method accessing the list through the sub list effectively does index + offset.</code>故而要是list变了，sublist的相关维护变量不变，就会依然傻傻地进行offset+index操作，这样就会寄。此猜想有待验证23333</p>
<blockquote>
<p>穿越回来：</p>
<ol>
<li>确实是共享存储空间的，不如说sublist就直接引用了原list的变量，所有操作实质上都是在原list上进行。</li>
<li>sublist傻傻地进行offset+index操作，这样体现在原list上，可能导致下标越界或者结果并非我们想要的。</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="AbstractList-A"><a href="#AbstractList-A" class="headerlink" title="AbstractList(A)"></a>AbstractList(A)</h3><blockquote>
<p>提供随机访问list的基本骨架</p>
<p>To implement an <strong>unmodifiable</strong> list, the programmer needs only to <strong>extend</strong> this class and provide implementations for the <strong>get(int)</strong> and <strong>size()</strong> methods.</p>
<p>To implement a <strong>modifiable</strong> list, the programmer must <strong>additionally</strong> <strong>override</strong> the <strong>set(int, Object)</strong>  method </p>
<p>If the list is <strong>variable-size</strong>，the programmer must additionally override the <strong>add(int, E)</strong> and <strong>remove(int)</strong> methods.</p>
<p>Unlike the other abstract collection implementations, the programmer <strong>does not have to provide an iterator implementation;</strong> the iterator and list iterator are implemented by this class, on top of the “<strong>random access</strong>“ methods: get(int), set(int, E), add(int, E) and remove(int).这里的迭代器反而是通过类里面的方法来实现的</p>
</blockquote>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//重写add方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">//此为下面的public void add(int index, E element);</span></span><br><span class="line">        add(size(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交给具体实现</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">    <span class="comment">//假设不能修改</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search Operations</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ListIterator&lt;E&gt; it = listIterator();</span><br><span class="line">        <span class="keyword">if</span> (o==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">                <span class="keyword">if</span> (it.next()==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">                <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                    <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//从后往前遍历</span></span><br><span class="line">        ListIterator&lt;E&gt; it = listIterator(size());</span><br><span class="line">        <span class="keyword">if</span> (o==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">                <span class="keyword">if</span> (it.previous()==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">                <span class="keyword">if</span> (o.equals(it.previous()))</span><br><span class="line">                    <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bulk Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        removeRange(<span class="number">0</span>, size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            add(index++, e);</span><br><span class="line">            modified = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterators</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部类诶 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="comment">//Index of element to be returned by subsequent call to next.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//Index of element returned by most recent call to next or previous. Reset to -1 if this element is deleted by a call to remove.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">                <span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> get(i);</span><br><span class="line">                lastRet = i;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AbstractList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                    cursor--;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">extends</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">        ListItr(<span class="type">int</span> index) &#123;</span><br><span class="line">            cursor = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor - <span class="number">1</span>;</span><br><span class="line">                <span class="type">E</span> <span class="variable">previous</span> <span class="operator">=</span> get(i);</span><br><span class="line">                <span class="comment">//lastRet=i;cursor=i;</span></span><br><span class="line">                lastRet = cursor = i;</span><br><span class="line">                <span class="keyword">return</span> previous;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AbstractList.<span class="built_in">this</span>.set(lastRet, e);</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">                AbstractList.<span class="built_in">this</span>.add(i, e);</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器定义结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//Sublist和RandomAccessSubList在后面都作为内部类定义</span></span><br><span class="line">        <span class="comment">//这俩的分支主要是能否支持高性能随机访问，而这点在Java是依靠是否实现RandomAccess接口</span></span><br><span class="line">        <span class="comment">//来体现的，要实现接口必须得是一个类。因此，为了分歧，这里不得不创建两个类来表示两种情况。</span></span><br><span class="line">        <span class="comment">//这两个类的方法应该是大致相同的。</span></span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RandomAccessSubList</span>&lt;&gt;(<span class="built_in">this</span>, fromIndex, toIndex) :</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SubList</span>&lt;&gt;(<span class="built_in">this</span>, fromIndex, toIndex));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Comparison and hashing</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">        ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">        <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">o1</span> <span class="operator">=</span> e1.next();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> e2.next();</span><br><span class="line">            <span class="comment">//如果这东西没有重载equals方法，那此处就是单纯object对象是否相同了</span></span><br><span class="line">            <span class="keyword">if</span> (!(o1==<span class="literal">null</span> ? o2==<span class="literal">null</span> : o1.equals(o2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为啥size不一样不在一开始就比呢？那样不是更省花销吗</span></span><br><span class="line">        <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : <span class="built_in">this</span>)</span><br><span class="line">            hashCode = <span class="number">31</span>*hashCode + (e==<span class="literal">null</span> ? <span class="number">0</span> : e.hashCode());</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The number of times this list has been structurally modified.</span></span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//这大概是对父list的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; l;</span><br><span class="line">    <span class="comment">//这大概是在父list的起始偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="comment">//sublist的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    SubList(AbstractList&lt;E&gt; list, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;fromIndex = &quot;</span> + fromIndex);</span><br><span class="line">        <span class="keyword">if</span> (toIndex &gt; list.size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;toIndex = &quot;</span> + toIndex);</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;fromIndex(&quot;</span> + fromIndex +</span><br><span class="line">                    <span class="string">&quot;) &gt; toIndex(&quot;</span> + toIndex + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        l = list;</span><br><span class="line">        offset = fromIndex;</span><br><span class="line">        size = toIndex - fromIndex;</span><br><span class="line">        <span class="built_in">this</span>.modCount = l.modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">//改变sublist也会改变父list，是否成功取决于对父list的改变是否成功</span></span><br><span class="line">        <span class="keyword">return</span> l.set(index+offset, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">//直接取父类值</span></span><br><span class="line">        <span class="keyword">return</span> l.get(index+offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        l.add(index+offset, element);</span><br><span class="line">        <span class="built_in">this</span>.modCount = l.modCount;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> l.remove(index+offset);</span><br><span class="line">        <span class="built_in">this</span>.modCount = l.modCount;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        l.removeRange(fromIndex+offset, toIndex+offset);</span><br><span class="line">        <span class="built_in">this</span>.modCount = l.modCount;</span><br><span class="line">        size -= (toIndex-fromIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cSize</span> <span class="operator">=</span> c.size();</span><br><span class="line">        <span class="keyword">if</span> (cSize==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        checkForComodification();</span><br><span class="line">        l.addAll(offset+index, c);</span><br><span class="line">        <span class="built_in">this</span>.modCount = l.modCount;</span><br><span class="line">        size += cSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//改变迭代器实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListIterator</span>&lt;E&gt;() &#123;</span><br><span class="line">            <span class="comment">//子类迭代器=父类迭代器+offset</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> ListIterator&lt;E&gt; i = l.listIterator(index+offset);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nextIndex() &lt; size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasNext())</span><br><span class="line">                    <span class="keyword">return</span> i.next();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> previousIndex() &gt;= <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasPrevious())</span><br><span class="line">                    <span class="keyword">return</span> i.previous();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i.nextIndex() - offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i.previousIndex() - offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">                i.remove();</span><br><span class="line">                SubList.<span class="built_in">this</span>.modCount = l.modCount;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> &#123;</span><br><span class="line">                i.set(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">                i.add(e);</span><br><span class="line">                SubList.<span class="built_in">this</span>.modCount = l.modCount;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//层层套娃啊</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubList</span>&lt;&gt;(<span class="built_in">this</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.modCount != l.modCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确实实现上没什么区别，主要是多了个RandomAccess的约定。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomAccessSubList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">SubList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">    RandomAccessSubList(AbstractList&lt;E&gt; list, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex) &#123;</span><br><span class="line">        <span class="built_in">super</span>(list, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomAccessSubList</span>&lt;&gt;(<span class="built_in">this</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="其中：-2"><a href="#其中：-2" class="headerlink" title="其中："></a>其中：</h4><ol>
<li><h5 id="内部类ListItr和Itr的实现"><a href="#内部类ListItr和Itr的实现" class="headerlink" title="内部类ListItr和Itr的实现"></a>内部类ListItr和Itr的实现</h5><p>Itr的实现需要用到AbstratcList类的get和set方法，而显然不同Collection的get和set不一样。为了避免混淆，Itr就只能作为私有类。为了避免胡乱引用，Itr就可以直接作为内部类，共享其外部类的所有资源。</p>
<p>ListItr作为内部私有类很容易理解，毕竟只有list才需要它。</p>
</li>
<li><h5 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h5><p>RandomAccess是一个空接口，它应该代表一个约定俗成的规定，即它的implementations的随机访问都是性能较高的。这个空接口思想很常见，源码带给我们的智慧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">按经验来说, a List implementation should implement <span class="built_in">this</span> interface, <span class="keyword">if</span> <span class="built_in">this</span> loop:</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, n=list.size(); i &lt; n; i++)</span><br><span class="line">          list.get(i);</span><br><span class="line">  </span><br><span class="line">runs faster than <span class="built_in">this</span> loop:</span><br><span class="line">      <span class="keyword">for</span> (Iterator i=list.iterator(); i.hasNext(); )</span><br><span class="line">          i.next();</span><br></pre></td></tr></table></figure></li>
<li><h5 id="关于modCount字段与fail-fast机制"><a href="#关于modCount字段与fail-fast机制" class="headerlink" title="关于modCount字段与fail-fast机制"></a>关于modCount字段与fail-fast机制</h5><p><a href="https://www.bilibili.com/video/BV1nU4y117WL?share_source=copy_web">你真的知道集合中modCount字段作用吗？</a></p>
<p>modCount字段就是保证一定程度并发安全的变量，fail-fast就是指马上抛出异常。</p>
<img src="/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/image-20221012193831742.png" class> 

<p>modCount不能保证绝对的并发安全，因为它只负责防范结构改变，而不负责看某位置的数据更新。</p>
<p>在现实中要实现对集合的边迭代边修改，下面三种方式都是错的：</p>
<img src="/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/image-20221012193303762.png" class> 

<p>第一种方法也可以把for里的size换成list.size()</p>
<p>其中乐观锁与悲观锁可见：<a href="https://www.jianshu.com/p/766093f59687">乐观锁</a></p>
<blockquote>
<ul>
<li><strong>乐观锁</strong>：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，只在更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>
</ul>
<blockquote>
<p>注意“在此期间”的含义是拿到数据到更新数据的这段时间。因为没有加锁，所以别的线程可能会更改。还有一点那就是乐观锁其实是不加锁的来保证某个变量一系列操作原子性的一种方法。</p>
</blockquote>
<ul>
<li><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞，直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</li>
</ul>
</blockquote>
</li>
</ol>
<p>AbstractList帮我们实现了差不多所有方法，除了T<strong>get(int)</strong> 、<strong>size()</strong> 、<strong>set(int, Object)</strong>  、<strong>add(int, E)</strong> 、<strong>remove(int)</strong> 。因而，接下来的两个实现中，重点关注这些就行。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><blockquote>
<p>Implements all optional list operations, and permits <strong>all elements</strong>, including null.</p>
<p>This class is roughly equivalent to <strong>Vector</strong>, except that it is <strong><u>unsynchronized</u></strong>.</p>
<p>size()，isEmpty()，get()，set()，iterator()，listIterator()的时间复杂符是**常量级别(constant time)<strong>，add()方法的时间复杂度是</strong>可变常量级别(amortized constant time)<strong>，即为O(n)。大致上说，剩余方法的时间复杂度都是</strong>线性时间(linear time)<strong>。相较于LinkedList的实现，ArrayList的</strong>常量因子(constant factor)**较低。</p>
<p>An application can increase the capacity of an ArrayList instance <strong>before</strong> adding a large number of elements using the <strong><u>ensureCapacity</u></strong> operation. This may reduce the amount of incremental reallocation.</p>
<p>本身是线程不安全的，但可以通过封装类来实现线程同步。可以使用Collections.synchronizedList method. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(...));</span><br></pre></td></tr></table></figure>
</blockquote>
<p>总体来说实现的很多方法跟想象中差别不大，有几个比较惊艳</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 cloneable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以注意一下，初始=10.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Shared empty array instance used for empty instances.</span></span><br><span class="line">    <span class="comment">//7</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、6</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The array buffer into which the elements of the ArrayList are stored.缓冲</span></span><br><span class="line"><span class="comment">    ArrayList的容量=此数组的length</span></span><br><span class="line"><span class="comment">    Any empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                    initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//in the order they are returned by c&#x27;s iterator.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//size==0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把容量缩小为当前size。An application can use this operation to minimize the storage of an ArrayList instance.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//涉及List的结构性改变</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">                    ? EMPTY_ELEMENTDATA</span><br><span class="line">                    : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">//如果原size！=0，除非minCapacity=0，否则必须是要扩容一次的【函数要求】，</span></span><br><span class="line">            <span class="comment">//因此设置为最小值0，以确保下面的if条件一定为true。</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">//如果为默认大小0，此处是必须扩为默认大小的</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//修改list结构</span></span><br><span class="line">        <span class="comment">//若minCapacity&lt;elementData.length,本句modCount++始终执行。</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//capacity=length of elementData</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//每次扩1/2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">                Integer.MAX_VALUE :</span><br><span class="line">                MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//from Object.clone():</span></span><br><span class="line">            <span class="comment">//the returned object should be obtained by calling super.clone.</span></span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">//浅拷贝，只拷贝地址</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里我挺迷惑的，为什么还要再套一层elementData？？</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">//既增加了modcount，也保证了capacity够用</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                size - index);<span class="comment">//src dest  移动数组</span></span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work，自动清除无引用对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这不是跟上面一模一样吗，为啥还要再写一遍？</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9 我能不能直接猛一点：elementData=new Object[elementData.length]?</span></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                    numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个complement做得很漂亮，兼顾实际意义又统一了代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="type">boolean</span> complement)</span> &#123;</span><br><span class="line">        <span class="comment">//局部变量</span></span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = <span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">                <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                    <span class="comment">//原地平移，nice</span></span><br><span class="line">                    <span class="comment">//如果是removeall，此条件成立说明c不含有该元素，则保留该元素</span></span><br><span class="line">                    <span class="comment">//如果是retainall，此条件成立说明c含有该元素，则保留该元素</span></span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">            <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">            <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                        elementData, w,</span><br><span class="line">                        size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">                <span class="comment">// clear to let GC do its work</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = <span class="literal">null</span>;</span><br><span class="line">                modCount += size - w;</span><br><span class="line">                size = w;</span><br><span class="line">                modified = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">        <span class="comment">/*from ObjectOutputStream:</span></span><br><span class="line"><span class="comment">        Write the non-static and non-transient fields of the current class </span></span><br><span class="line"><span class="comment">        to this stream.*/</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为啥要特地强调write size？</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保证一定基础的序列化同步</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        <span class="comment">//不大懂为什么这里的值被ignore了？</span></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> calculateCapacity(elementData, size);</span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AbstractList.Itr的优化版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="comment">//内部类访问外部类this的方法</span></span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//change here</span></span><br><span class="line">                <span class="comment">//确实AbstractList的那个remove应该更适用于LinkedList</span></span><br><span class="line">                ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.size;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="comment">//这里不抛异常吗</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="comment">//好像确实是并发修改了，毕竟上面已经test过i&lt;size&lt;capacity了</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            <span class="comment">//10</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AbstractList.ListItr的优化版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">extends</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">        ListItr(<span class="type">int</span> index) &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            cursor = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="comment">//11 防止并发修改，比如在这期间进行了trim</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="built_in">this</span>.set(lastRet, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">                ArrayList.<span class="built_in">this</span>.add(i, e);</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubList</span>(<span class="built_in">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subListRangeCheck</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;fromIndex = &quot;</span> + fromIndex);</span><br><span class="line">        <span class="keyword">if</span> (toIndex &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;toIndex = &quot;</span> + toIndex);</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;fromIndex(&quot;</span> + fromIndex +</span><br><span class="line">                    <span class="string">&quot;) &gt; toIndex(&quot;</span> + toIndex + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依然内部类。不过这里应该用了个作用域的性质。相比于AbstractList定义在List类外部的</span></span><br><span class="line">    <span class="comment">//Sublist,应该会更优先使用定义在内部的Sublist</span></span><br><span class="line">    <span class="comment">//12 注意，这里的sublist没有直接extends ArrayList</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SubList</span> <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent;</span><br><span class="line">        <span class="comment">//新增成员</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parentOffset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">        SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">                <span class="type">int</span> offset, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex) &#123;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">            <span class="comment">//这个parentOffset应该是指相较于最近的父亲的偏移量，offset应该就是相较于最底层的父亲的偏移量</span></span><br><span class="line">            <span class="built_in">this</span>.parentOffset = fromIndex;</span><br><span class="line">            <span class="built_in">this</span>.offset = offset + fromIndex;</span><br><span class="line">            <span class="built_in">this</span>.size = toIndex - fromIndex;</span><br><span class="line">            <span class="built_in">this</span>.modCount = ArrayList.<span class="built_in">this</span>.modCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E e)</span> &#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.elementData(offset + index);</span><br><span class="line">            ArrayList.<span class="built_in">this</span>.elementData[offset + index] = e;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">return</span> ArrayList.<span class="built_in">this</span>.elementData(offset + index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E e)</span> &#123;</span><br><span class="line">            rangeCheckForAdd(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">//13</span></span><br><span class="line">            parent.add(parentOffset + index, e);</span><br><span class="line">            <span class="built_in">this</span>.modCount = parent.modCount;</span><br><span class="line">            <span class="built_in">this</span>.size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> parent.remove(parentOffset + index);</span><br><span class="line">            <span class="built_in">this</span>.modCount = parent.modCount;</span><br><span class="line">            <span class="built_in">this</span>.size--;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            parent.removeRange(parentOffset + fromIndex,</span><br><span class="line">                    parentOffset + toIndex);</span><br><span class="line">            <span class="built_in">this</span>.modCount = parent.modCount;</span><br><span class="line">            <span class="built_in">this</span>.size -= toIndex - fromIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> addAll(<span class="built_in">this</span>.size, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">            rangeCheckForAdd(index);</span><br><span class="line">            <span class="type">int</span> <span class="variable">cSize</span> <span class="operator">=</span> c.size();</span><br><span class="line">            <span class="keyword">if</span> (cSize==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            checkForComodification();</span><br><span class="line">            parent.addAll(parentOffset + index, c);</span><br><span class="line">            <span class="built_in">this</span>.modCount = parent.modCount;</span><br><span class="line">            <span class="built_in">this</span>.size += cSize;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> listIterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> index)</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            rangeCheckForAdd(index);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="built_in">this</span>.offset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListIterator</span>&lt;E&gt;() &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> index;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.modCount;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//内部内部类还可以访问外部类和外部外部类</span></span><br><span class="line">                    <span class="keyword">return</span> cursor != SubList.<span class="built_in">this</span>.size;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                    checkForComodification();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= SubList.<span class="built_in">this</span>.size)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">                    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">                    <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">                    cursor = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">                    checkForComodification();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">                    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">                    <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">                    cursor = i;</span><br><span class="line">                    <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;</span><br><span class="line">                    Objects.requireNonNull(consumer);</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> SubList.<span class="built_in">this</span>.size;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">                    <span class="keyword">if</span> (offset + i &gt;= elementData.length) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                        consumer.accept((E) elementData[offset + (i++)]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">                    lastRet = cursor = i;</span><br><span class="line">                    checkForComodification();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> cursor;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">                    checkForComodification();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        SubList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">                        cursor = lastRet;</span><br><span class="line">                        lastRet = -<span class="number">1</span>;</span><br><span class="line">                        expectedModCount = ArrayList.<span class="built_in">this</span>.modCount;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                        <span class="comment">//确实要是IndexOutOfBounds的话，就说明lastRet改了，说明Concurrent了</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">                    checkForComodification();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ArrayList.<span class="built_in">this</span>.set(offset + lastRet, e);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">                    checkForComodification();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">                        SubList.<span class="built_in">this</span>.add(i, e);</span><br><span class="line">                        cursor = i + <span class="number">1</span>;</span><br><span class="line">                        lastRet = -<span class="number">1</span>;</span><br><span class="line">                        expectedModCount = ArrayList.<span class="built_in">this</span>.modCount;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (expectedModCount != ArrayList.<span class="built_in">this</span>.modCount)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">            subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubList</span>(<span class="built_in">this</span>, offset, fromIndex, toIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayListSpliterator</span>&lt;E&gt;(ArrayList.<span class="built_in">this</span>, offset,</span><br><span class="line">                    offset + <span class="built_in">this</span>.size, <span class="built_in">this</span>.modCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">final</span> E[] elementData = (E[]) <span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">        <span class="comment">//一修改就会寄</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            action.accept(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayListSpliterator</span>&lt;&gt;(<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Index-based split-by-two, lazily initialized Spliterator */</span></span><br><span class="line">    <span class="comment">//基于索引的二分法，懒加载的 Spliterator</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ArrayListSpliterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;E&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">removeCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//666，用了类似掩码的思想，这样就能避免多次移动数组了，实现O(n)，很不错</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">BitSet</span> <span class="variable">removeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(size);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> (E) elementData[i];</span><br><span class="line">            <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">                <span class="comment">//set:Sets the bit at the specified index to true.</span></span><br><span class="line">                removeSet.set(i);</span><br><span class="line">                removeCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// shift surviving elements left over the spaces left by removed elements</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">anyToRemove</span> <span class="operator">=</span> removeCount &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - removeCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">                <span class="comment">//nextClearBit：Returns the index of the first bit that is set to false</span></span><br><span class="line">                <span class="comment">//false表示不移走，true表示移走</span></span><br><span class="line">                i = removeSet.nextClearBit(i);</span><br><span class="line">                elementData[j] = elementData[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">                elementData[k] = <span class="literal">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.size = newSize;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            modCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> anyToRemove;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">        Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其中：-3"><a href="#其中：-3" class="headerlink" title="其中："></a>其中：</h4><ol>
<li><h5 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h5><p>与RandomAccess一样，都是一个规定性质的接口。</p>
<blockquote>
<p>A class implements the Cloneable interface to indicate to the Object.clone() method that <strong><u>it is legal</u></strong> for that method to make a field-for-field copy of instances of that class.</p>
<p>Classes that implement this interface <strong>should override</strong> Object.clone (which is protected) with a <strong><u>public</u></strong> method.</p>
</blockquote>
</li>
<li><h5 id="clone与浅拷贝（shallow-copy）"><a href="#clone与浅拷贝（shallow-copy）" class="headerlink" title="clone与浅拷贝（shallow copy）"></a>clone与浅拷贝（shallow copy）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Student&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arr.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lylt&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        ArrayList&lt;Student&gt; cl = (ArrayList)arr.clone();</span><br><span class="line">        System.out.println(cl.get(<span class="number">0</span>).toString());</span><br><span class="line">        cl.get(<span class="number">0</span>).name=<span class="string">&quot;Sam&quot;</span>;</span><br><span class="line">        System.out.println(cl.get(<span class="number">0</span>).toString());</span><br><span class="line">        System.out.println(arr.get(<span class="number">0</span>).toString());</span><br><span class="line">        cl.set(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;HWX&quot;</span>,<span class="number">19</span>));</span><br><span class="line">        System.out.println(cl.get(<span class="number">0</span>).toString());</span><br><span class="line">        System.out.println(arr.get(<span class="number">0</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">name :lyltage :15</span></span><br><span class="line"><span class="comment">name :Samage :15</span></span><br><span class="line"><span class="comment">name :Samage :15</span></span><br><span class="line"><span class="comment">name :HWXage :19</span></span><br><span class="line"><span class="comment">name :Samage :15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>结合内部代码可知，确实跟上面那个toArray的原理是一样的，只拷贝地址。</p>
<p>clone是浅拷贝。</p>
<p><a href="https://blog.csdn.net/SSophia/article/details/123964733">浅拷贝与深拷贝的区别</a></p>
<img src="/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/image-20221013182706272.png" class> </li>
<li><h5 id="关于子类继承到的父类内部类"><a href="#关于子类继承到的父类内部类" class="headerlink" title="关于子类继承到的父类内部类"></a>关于子类继承到的父类内部类</h5><p>本来在犹豫，子类默认继承到的内部类里面用到的外部类方法的版本是取父还是取子，经过以下实验可知，是取能访问到的最新版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChildOuter</span> <span class="variable">chldot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildOuter</span>();</span><br><span class="line">        chldot.printname();</span><br><span class="line">        chldot.in.printall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果：子类声明为private的成员字段不能被从父类继承而来的方法访问到</span></span><br><span class="line"><span class="comment">Father</span></span><br><span class="line"><span class="comment">I am father!*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FatherOuter</span>&#123;</span><br><span class="line">    String name=<span class="string">&quot;Father&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am father!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> haha=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">printall</span><span class="params">()</span>&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printname</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildOuter</span> <span class="keyword">extends</span> <span class="title class_">FatherOuter</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;Child&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;I am child!&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如若把Father和Child内的print类都换成public：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FatherOuter</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am father!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildOuter</span> <span class="keyword">extends</span> <span class="title class_">FatherOuter</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;I am child!&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果：访问最新版本</span></span><br><span class="line"><span class="comment">I am child!*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结论：内部类可以访问外部类所有不论私有还是公有的资源；会优先访问最新版本【父子类而言】</span></span><br><span class="line"><span class="comment">//子类声明为private的成员字段不能被从父类继承而来的方法访问到，只会访问能访问到的最新版本</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="序列化versionID"><a href="#序列化versionID" class="headerlink" title="序列化versionID"></a>序列化versionID</h5><p>ArrayList实现了java.io.Serializable接口，故而可以被序列化和反序列化，就需要有个序列化版本ID</p>
<p><a href="https://stackoverflow.com/questions/285793/what-is-a-serialversionuid-and-why-should-i-use-it">What is a serialVersionUID and why should I use it?</a></p>
<blockquote>
<p>这东西是用来在反序列化的时候保证收到的对象和发送的对象的类是相同的。If the receiver has loaded a class for the object that has a different <code>serialVersionUID</code> than that of the corresponding sender’s class, then deserialization will result in an <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InvalidClassException.html"><code>InvalidClassException</code></a>. </p>
<p>The field serialVersionUID must be <strong>static</strong>, <strong>final</strong>, and of <strong>type</strong> <code>long</code>.</p>
<p>If a serializable class does not explicitly declare a <code>serialVersionUID</code>, then the serialization runtime will calculate a default <code>serialVersionUID</code> value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification.</p>
</blockquote>
</li>
<li><h5 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h5><p><a href="https://blog.csdn.net/u012723673/article/details/80699029">Java中transient关键字的详细总结</a></p>
<blockquote>
<p>transient是短暂的意思。对于transient 修饰的成员变量，在类的实例对象的<strong>序列化处理过程中会被忽略</strong>。 因此，transient变量不会贯穿对象的序列化和反序列化，生命周期<strong>仅存于调用者的内存</strong>中而不会写到磁盘里进行持久化。</p>
<p>在持久化对象时，对于一些特殊的数据成员（如用户的密码，银行卡号等），我们不想用序列化机制来保存它。为了<strong>在一个特定对象的一个成员变量上关闭序列化</strong>，可以在这个成员变量前加上关键字transient。</p>
<p><strong>注意static修饰的静态变量天然就是不可序列化的。</strong>一个静态变量不管是否被transient修饰，均不能被序列化(如果反序列化后类中static变量还有值，则值为当前JVM中对应static变量的值)。序列化保存的是对象状态，静态变量保存的是类状态，因此序列化并不保存静态变量。</p>
<p>使用场景<br>（1）类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性长度、宽度、面积，面积不需要序列化。<br>（2） 一些安全性的信息，一般情况下是不能离开JVM的。<br>（3）如果类中使用了Logger实例，那么Logger实例也是不需要序列化的</p>
</blockquote>
<p>但其实还有一个问题，它这边源码对这个transient的注释是：<code>non-private to simplify nested class access</code>，“非私有以简化嵌套类访问”。问题是这个transient和类的公有还是私有有什么关系呢？</p>
<p><a href="https://stackoverflow.com/questions/67312572/why-is-the-data-array-in-java-util-arraylist-package-private">Why is the data array in java.util.ArrayList package-private?</a></p>
<p>其实没怎么看懂23333</p>
</li>
<li><h5 id="ArrayList的elementData虽然被transient修饰，但仍然能够序列化"><a href="#ArrayList的elementData虽然被transient修饰，但仍然能够序列化" class="headerlink" title="ArrayList的elementData虽然被transient修饰，但仍然能够序列化"></a>ArrayList的elementData虽然被transient修饰，但仍然能够序列化</h5><p><a href="http://www.javashuo.com/article/p-moiudvqi-gy.html">ArrayList中elementData为何被transient修饰？</a></p>
</li>
<li><h5 id="关于static的空数组"><a href="#关于static的空数组" class="headerlink" title="关于static的空数组"></a>关于static的空数组</h5><p>EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA这两个空数组可用于表示两种情况：</p>
<p>new ArrayList(0)  -&gt;EMPTY_ELEMENTDATA</p>
<p>new ArrayList()    -&gt;DEFAULTCAPACITY_EMPTY_ELEMENTDATA</p>
<p>之所以用静态，是提取了共性：不论是需要什么ArrayList，其空形态不都一样吗（</p>
<p>这样可以避免了制造对象的浪费。very good。</p>
</li>
<li><h5 id="关于扩容的连环计"><a href="#关于扩容的连环计" class="headerlink" title="关于扩容的连环计"></a>关于扩容的连环计</h5><p>我其实觉得不必写那么麻烦……</p>
<p><a href="https://stackoverflow.com/questions/74063754/in-the-java-arraylist-source-code-why-does-array-expansion-should-be-divided-in">In the JAVA ArrayList source code, why does array expansion should be divided into ensureCapacityInternal and ensureCapacity two sides?</a></p>
<p>经过测试替换可得，确实可以像我那样写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//此处的ArrayList是魔改过的</span></span><br><span class="line">		<span class="comment">//now the capacity is 0</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        System.out.println(a.getCapacity());</span><br><span class="line">        <span class="comment">//扩容到DEFAULT</span></span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lily&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        System.out.println(a.getCapacity());</span><br><span class="line">        addStudent(a);</span><br><span class="line">        System.out.println(a.getCapacity());</span><br><span class="line"><span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">33</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="关于clear我的写法"><a href="#关于clear我的写法" class="headerlink" title="关于clear我的写法"></a>关于clear我的写法</h5><p><a href="https://stackoverflow.com/questions/74065099/in-the-java-arraylist-source-code-in-the-clear-function-can-my-rewrite-more-ef">In the Java ArrayList source code, in the clear function, can my rewrite more efficient than the origin source code? </a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">addStudent(a);</span><br><span class="line"><span class="type">long</span> sum1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    a.clear1();</span><br><span class="line">    addStudent(a);</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    sum1+=endTime-startTime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sum1/=500;</span></span><br><span class="line">System.out.println(<span class="string">&quot;clear1: &quot;</span>+sum1);</span><br><span class="line">sum1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    a.clear2();</span><br><span class="line">    addStudent(a);</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    sum1+=endTime-startTime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sum1/=500;</span></span><br><span class="line">System.out.println(<span class="string">&quot;clear2: &quot;</span>+sum1);</span><br></pre></td></tr></table></figure>

<p>经测试发现不分伯仲（）也确实差距应该很小2333</p>
<p>不过依照一个回答：</p>
<blockquote>
<p>Your approach explicitly throws the backing array away. The existing implementation attempts to reuse it. So even if your approach is faster in isolation, in practice it will almost certainly be less performant. Since calling <code>clear()</code> is a sign you intend to reuse the <code>ArrayList</code>. </p>
</blockquote>
<p>其实感觉我的clear说不定花销更大，毕竟要创建一个新对象（</p>
</li>
<li><h5 id="heap-write-traffic"><a href="#heap-write-traffic" class="headerlink" title="heap write traffic"></a>heap write traffic</h5><p><a href="https://stackoverflow.com/questions/49075220/what-is-heap-write-traffic-and-why-it-is-required-in-arraylist">What is heap write traffic and why it is required in ArrayList?</a></p>
<p>详见第二个答案。</p>
<img src="/2022/10/16/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A1%E3%80%90Collection%E9%83%A8%E5%88%86%E3%80%91/Cadte.png" class> 

<p>栈放在一级缓存，堆放在二级缓存</p>
<p>总之意思就是成员变量写在堆里，局部变量写在栈里，做</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">    consumer.accept((E) elementData[i++]);</span><br><span class="line">    <span class="comment">// Update cursor while iterating</span></span><br><span class="line">    cursor = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比做</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cursor != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">    consumer.accept((E) elementData[cursor++]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>花销更小</p>
</li>
<li><h5 id="if-i-gt-elementData-length"><a href="#if-i-gt-elementData-length" class="headerlink" title="if (i &gt;= elementData.length)"></a>if (i &gt;= elementData.length)</h5><p><a href="https://stackoverflow.com/questions/38239985/is-i-elementdata-length-in-arraylistiterator-redundant">is i &gt;= elementData.length in ArrayList::iterator redundant?</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    cursor = i;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 user invoke trimToSize method ，就会导致在<code>checkForComodification();</code>和<code>if (i &gt;= elementData.length)</code>之间发生<code>ArrayIndexOutOfBounds</code>。而在<code>if (i &gt;= elementData.length)</code>之后trim没有影响，因为我们的局部变量已经保存了原来的elementData，此时再trim只是修改成员变量的elementData，局部变量依然不变。</p>
</li>
<li><h5 id="sublist不可序列化，且not-cloneable"><a href="#sublist不可序列化，且not-cloneable" class="headerlink" title="sublist不可序列化，且not cloneable"></a>sublist不可序列化，且not cloneable</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SubList</span> <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">RandomAccess</span> </span><br></pre></td></tr></table></figure>

<p>sublist没有extends Cloneable, java.io.Serializable这两个接口</p>
</li>
<li><h5 id="parent和ArrayList-this"><a href="#parent和ArrayList-this" class="headerlink" title="parent和ArrayList.this"></a>parent和ArrayList.this</h5><p>首先，这两个是同一个吗？其次，这俩是否是同一个跟sub的级数有关系吗，就比如一级sub都是同一个，多级sub就不是同一个了？</p>
<p>经过对ArrayList的一些public和以下代码的测试，得出结论：这两个只有在第一级sub的时候是同一个。parent指向直系父亲，ArrayList.this指向root父亲。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In ArrayList:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent;</span><br><span class="line"><span class="keyword">public</span> ArrayList <span class="title function_">getRoot</span><span class="params">()</span>&#123;<span class="keyword">return</span> ArrayList.<span class="built_in">this</span>;&#125;</span><br><span class="line"><span class="comment">//In test main:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList a=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        addStudent(a);</span><br><span class="line">        System.out.println(a.hashCode());</span><br><span class="line"></span><br><span class="line">        ArrayList.SubList suba= (ArrayList.SubList) a.subList(<span class="number">1</span>,<span class="number">7</span>);</span><br><span class="line">        System.out.println(suba.getRoot().hashCode()+<span class="string">&quot;\t&quot;</span>+suba.parent.hashCode());</span><br><span class="line">        System.out.println(suba.hashCode());</span><br><span class="line"></span><br><span class="line">        ArrayList.SubList subsuba=(ArrayList.SubList) suba.subList(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(subsuba.getRoot().hashCode()+<span class="string">&quot;\t&quot;</span>+subsuba.parent.hashCode());</span><br><span class="line">        System.out.println(subsuba.hashCode());</span><br><span class="line"></span><br><span class="line">        ArrayList.SubList subsubsuba=(ArrayList.SubList) subsuba.subList(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(subsubsuba.getRoot().hashCode()+<span class="string">&quot;\t&quot;</span>+subsubsuba.parent.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">779301330</span></span><br><span class="line"><span class="comment">779301330	779301330</span></span><br><span class="line"><span class="comment">-954172011</span></span><br><span class="line"><span class="comment">779301330	-954172011</span></span><br><span class="line"><span class="comment">-95519366</span></span><br><span class="line"><span class="comment">779301330	-95519366</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>总之，ArrayList的sublist实现方式相当于串成了一条父子继承串，多级sub，至于这么干相比原来的只有两级父子关系的方法好在哪就不知道了</p>
</li>
</ol>
<h3 id="AbstractSequentialList-A"><a href="#AbstractSequentialList-A" class="headerlink" title="AbstractSequentialList(A)"></a>AbstractSequentialList(A)</h3><blockquote>
<p>提供顺序访问list的基本骨架</p>
<p>To implement a list the programmer needs only to extend this class and provide implementations for the listIterator and size methods. For an unmodifiable list, the programmer need only implement the list iterator’s hasNext, next, hasPrevious, previous and index methods.<br>For a modifiable list the programmer should additionally implement the list iterator’s set method. For a variable-size list the programmer should additionally implement the list iterator’s remove and add methods.</p>
</blockquote>
<h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractSequentialList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> listIterator(index).next();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ListIterator&lt;E&gt; e = listIterator(index);</span><br><span class="line">            <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> e.next();</span><br><span class="line">            e.set(element);</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listIterator(index).add(element);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ListIterator&lt;E&gt; e = listIterator(index);</span><br><span class="line">            <span class="type">E</span> <span class="variable">outCast</span> <span class="operator">=</span> e.next();</span><br><span class="line">            e.remove();</span><br><span class="line">            <span class="keyword">return</span> outCast;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bulk Operations</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            ListIterator&lt;E&gt; e1 = listIterator(index);</span><br><span class="line">            Iterator&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; e2 = c.iterator();</span><br><span class="line">            <span class="keyword">while</span> (e2.hasNext()) &#123;</span><br><span class="line">                e1.add(e2.next());</span><br><span class="line">                modified = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> modified;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Iterators</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其中：-4"><a href="#其中：-4" class="headerlink" title="其中："></a>其中：</h4><ol>
<li><h5 id="get和set方法通过Iterator实现"><a href="#get和set方法通过Iterator实现" class="headerlink" title="get和set方法通过Iterator实现"></a>get和set方法通过Iterator实现</h5><p>随机访问的AbstractList的iterator的方法借助了主类的get和set，跟这里正好反过来。但注意哈，下面的LinkedList实现把以上差不多所有的方法都重写了，因而get和set之类的方法，LinkedList并不是依靠迭代器的。</p>
</li>
</ol>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><blockquote>
<p>双向链表，实现List和Deque</p>
<p>并发不安全。List list = Collections.synchronizedList(new LinkedList(…));</p>
<p>印象：漂亮的指针操作，以及好像很少抛出异常，还有很多很多繁琐的方法（</p>
</blockquote>
<h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//怎么连size也是transient？这不是代表着该对象的信息吗（</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//调用空构造器</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把e接在链表头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts element e before non-null Node succ.</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="comment">//这里就只靠注释会不会危险了（）不过也确实会自动帮我们抛出NullPointerException的</span></span><br><span class="line">        <span class="comment">//而且我在想，不是first已经指向头结点了吗，那你为什么还要把头结点作为参数传进来。。。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="literal">null</span>;</span><br><span class="line">        f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> &#123;</span><br><span class="line">        <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> l.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="literal">null</span>;</span><br><span class="line">        l.prev = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">            first = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> f.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> l.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;linkFirst(e);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;linkLast(e);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;<span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;<span class="keyword">return</span> size;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分成两段</span></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="literal">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往中间加料</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合起来</span></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">        <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">        <span class="comment">//   more than one generation</span></span><br><span class="line">        <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; ) &#123;</span><br><span class="line">            Node&lt;E&gt; next = x.next;</span><br><span class="line">            x.item = <span class="literal">null</span>;</span><br><span class="line">            x.next = <span class="literal">null</span>;</span><br><span class="line">            x.prev = <span class="literal">null</span>;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        first = last = <span class="literal">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = node(index);</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">        <span class="comment">//所以为啥不能check一下？</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//做了个小小的优化，如果在前半就从开头找，在后半就从最后往前找</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search Operations</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue operations.</span></span><br><span class="line">    <span class="comment">//部分省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//always return true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deque operations</span></span><br><span class="line">   	<span class="comment">//省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//666</span></span><br><span class="line">        <span class="keyword">return</span> remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeLastOccurrence</span><span class="params">(Object o)</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非常聪明非常漂亮的指针操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> nextIndex;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        ListItr(<span class="type">int</span> index) &#123;</span><br><span class="line">            <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">            next = (index == size) ? <span class="literal">null</span> : node(index);</span><br><span class="line">            nextIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (!hasNext())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line"></span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">            <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意这个next是内部类里的成员变量，last是外部类的成员变量</span></span><br><span class="line">            lastReturned = next = (next == <span class="literal">null</span>) ? last : next.prev;</span><br><span class="line">            nextIndex--;</span><br><span class="line">            <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line"></span><br><span class="line">            Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">            unlink(lastReturned);</span><br><span class="line">            <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">                next = lastNext;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextIndex--;</span><br><span class="line">            lastReturned = <span class="literal">null</span>;</span><br><span class="line">            expectedModCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            checkForComodification();</span><br><span class="line">            lastReturned.item = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            lastReturned = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                linkLast(e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                linkBefore(e, next);</span><br><span class="line">            nextIndex++;</span><br><span class="line">            expectedModCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">            Objects.requireNonNull(action);</span><br><span class="line">            <span class="keyword">while</span> (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;</span><br><span class="line">                action.accept(next.item);</span><br><span class="line">                lastReturned = next;</span><br><span class="line">                next = next.next;</span><br><span class="line">                nextIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点类，平平无奇链表捏</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DescendingIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 降序迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DescendingIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="comment">//借助升序迭代器实现</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ListItr</span> <span class="variable">itr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(size());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> itr.previous();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            itr.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title function_">superClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        clone.first = clone.last = <span class="literal">null</span>;</span><br><span class="line">        clone.size = <span class="number">0</span>;</span><br><span class="line">        clone.modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize clone with our elements</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">            clone.add(x.item);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">876323262645176354L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> java.io.IOException &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LLSpliterator</span>&lt;E&gt;(<span class="built_in">this</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LLSpliterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;E&gt; &#123;...&#125;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其中"><a href="#其中" class="headerlink" title="其中"></a>其中</h4><ol>
<li><h5 id="关于分代GC"><a href="#关于分代GC" class="headerlink" title="关于分代GC"></a>关于分代GC</h5><p>In the <code>clear()</code> function：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line"><span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line"><span class="comment">//   more than one generation</span></span><br><span class="line"><span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br></pre></td></tr></table></figure>

<p>还没看懂，插个眼</p>
</li>
<li><h5 id="降序迭代器"><a href="#降序迭代器" class="headerlink" title="降序迭代器"></a>降序迭代器</h5><p>一切都反过来了，也没有升序迭代器恁多方法：</p>
<p>不支持foreach循环，只支持单向遍历，没有add set 只有remove。</p>
</li>
<li><h5 id="关于unlinkLast-First的参数问题"><a href="#关于unlinkLast-First的参数问题" class="headerlink" title="关于unlinkLast/First的参数问题"></a>关于unlinkLast/First的参数问题</h5><p><a href="https://stackoverflow.com/questions/74079433/in-java-linkedlist-source-code-why-the-unlinkfirst-function-should-have-a-param">In Java LinkedList source code, why the unlinkFirst function should have a param pointing to the first node?</a></p>
<p>事实证明确实人家也觉得无参比较合理（</p>
</li>
<li><h5 id="sublist"><a href="#sublist" class="headerlink" title="sublist"></a>sublist</h5><p>LinkedList用了从AbstractList继承来的sublist相关类和方法，没有特别的优化，其sublist不可序列化，且not cloneable。</p>
</li>
<li><h5 id="transient的三个成员变量"><a href="#transient的三个成员变量" class="headerlink" title="transient的三个成员变量"></a>transient的三个成员变量</h5><p><a href="https://stackoverflow.com/questions/74080097/in-java-linkedlist-why-the-first-last-and-size-variable-are-transient">In Java LinkedList, why the “first”, “last” and “size” variable are transient?</a></p>
<blockquote>
<p>LinkedList provide its own method for serializing and de-serializing. </p>
<p>When serializing, it only writes the size, and the values of the list.</p>
<p>When deserializing, it reads the size, then <strong>build</strong> the list from scratch, each node for each value at a time. </p>
<p>If the author <strong>did not provide their own read and write methods,</strong> then they would need to make size, first, and last non-transient. They would also need to make the Node class serializable.</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/25926012/as-all-the-member-variables-of-java-linkedlist-is-transient-what-will-be-the-us">As all the member variables of java LinkedList is transient, what will be the use of implementing Serializable?</a></p>
<blockquote>
<p>Otherwise serializing would be by default, which would be recursive, and for a large list would easily blow the stack. </p>
</blockquote>
<p>意思就是序列化时不记录这些信息，反序列化时会重新构建。还有说如果用默认的序列化方法是递归的可能爆栈？还有我觉得有一点可能是如果把所有node都序列化了，可能反序列化后，本来分配到那段内存空间要是被占用了，但指针值不变还是会有问题？等待之后解答。</p>
</li>
</ol>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><blockquote>
<p>Unlike the new collection implementations, Vector is <strong>synchronized</strong>. If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector.</p>
</blockquote>
<h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Object[] elementData;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> elementCount;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> capacityIncrement;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2767605614048989439L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                    initialCapacity);</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        elementCount = a.length;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elementData = Arrays.copyOf(a, elementCount, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">copyInto</span><span class="params">(Object[] anArray)</span> &#123;</span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, anArray, <span class="number">0</span>, elementCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="keyword">if</span> (elementCount &lt; oldCapacity) &#123;</span><br><span class="line">            elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            ensureCapacityHelper(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Sets the size of this vector. If the new size is greater than the current size, new null items are added to the end of the vector. If the new size is less than the current size, all components at index newSize and greater are discarded.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> newSize)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (newSize &gt; elementCount) &#123;</span><br><span class="line">            ensureCapacityHelper(newSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> newSize ; i &lt; elementCount ; i++) </span><br><span class="line">                <span class="comment">//3 GC帮大忙，注意这里没有trim。</span></span><br><span class="line">                elementData[i] = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount = newSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//capacity 、size 、isEmpty省略</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//4</span></span><br><span class="line">    <span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title function_">elements</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Enumeration</span>&lt;E&gt;() &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasMoreElements</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> count &lt; elementCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">nextElement</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Vector.<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count &lt; elementCount) &#123;</span><br><span class="line">                        <span class="keyword">return</span> elementData(count++);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;Vector Enumeration&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//contains、indexof、lastIndexOf省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">elementAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span> + elementCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">firstElement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elementData(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">lastElement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elementData(elementCount - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setElementAt</span><span class="params">(E obj, <span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeElementAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">insertElementAt</span><span class="params">(E obj, <span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(E obj)</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">removeElement</span><span class="params">(Object obj)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//clear    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeAllElements</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// Let gc do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elementCount; i++)</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        elementCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; T[] toArray(T[] a) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line">	<span class="comment">//add set get remove clear省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bulk Operations</span></span><br><span class="line">	<span class="comment">// xxxAll省略</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//用了AbstractList的equal、hashcode、tostring，省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.synchronizedList(<span class="built_in">super</span>.subList(fromIndex, toIndex),</span><br><span class="line">                <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跟AL不一样</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream.<span class="type">GetField</span> <span class="variable">gfields</span> <span class="operator">=</span> in.readFields();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> gfields.get(<span class="string">&quot;elementCount&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        Object[] data = (Object[])gfields.get(<span class="string">&quot;elementData&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span> || data == <span class="literal">null</span> || count &gt; data.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(<span class="string">&quot;Inconsistent vector internals&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount = count;</span><br><span class="line">        elementData = data.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">        <span class="keyword">final</span> java.io.ObjectOutputStream.<span class="type">PutField</span> <span class="variable">fields</span> <span class="operator">=</span> s.putFields();</span><br><span class="line">        <span class="keyword">final</span> Object[] data;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            fields.put(<span class="string">&quot;capacityIncrement&quot;</span>, capacityIncrement);</span><br><span class="line">            fields.put(<span class="string">&quot;elementCount&quot;</span>, elementCount);</span><br><span class="line">            data = elementData.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        fields.put(<span class="string">&quot;elementData&quot;</span>, data);</span><br><span class="line">        s.writeFields();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">extends</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VectorSpliterator</span>&lt;&gt;(<span class="built_in">this</span>, <span class="literal">null</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">VectorSpliterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;E&gt; &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其中：-5"><a href="#其中：-5" class="headerlink" title="其中："></a>其中：</h4><ol>
<li><h5 id="默认容量-1"><a href="#默认容量-1" class="headerlink" title="默认容量"></a>默认容量</h5><p>空构造器Vector()创建出来的默认容量为10，不同于ArrayList是个空集合。</p>
</li>
<li><h5 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h5><p>与ArrayList基本上是雷同的，就是都是synchronized。</p>
</li>
<li><h5 id="setsize不改变容量"><a href="#setsize不改变容量" class="headerlink" title="setsize不改变容量"></a>setsize不改变容量</h5><p>实现中只是把东西设置为空，并没有trim，因而容量不变</p>
</li>
<li><h5 id="Vector可生成枚举类"><a href="#Vector可生成枚举类" class="headerlink" title="Vector可生成枚举类"></a>Vector可生成枚举类</h5></li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set（I）"><a href="#Set（I）" class="headerlink" title="Set（I）"></a>Set（I）</h3><h4 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1</span></span><br><span class="line"><span class="comment">Note: 当set里包含可变的对象时，要多加小心。 </span></span><br><span class="line"><span class="comment">The behavior of a set is not specified if the value of a set object is changed in a manner that affects equals comparisons.</span></span><br><span class="line"><span class="comment">A special case of this prohibition is that it is not permissible for a set to contain itself as an element.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// Query Operations </span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="comment">/*Returns an iterator over the elements in this set. </span></span><br><span class="line"><span class="comment">    The elements are returned in no particular order </span></span><br><span class="line"><span class="comment">    (unless this set is an instance of some class that provides a guarantee).*/</span></span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    Object[] toArray();</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modification Operations</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If this set already contains the element, </span></span><br><span class="line"><span class="comment">    the call leaves the set unchanged and returns false. </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bulk Operations</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Returns true if this set contains all of the elements of the specified collection.</span></span><br><span class="line"><span class="comment">    If the specified collection is also a set,</span></span><br><span class="line"><span class="comment">    this method returns true if it is a subset of this set.[这个subset的定义有点意思]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="comment">//取并集</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取交集</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//集合差</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Comparison and hashing</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其中：-6"><a href="#其中：-6" class="headerlink" title="其中："></a>其中：</h4><ol>
<li><h5 id="set中包含可变对象"><a href="#set中包含可变对象" class="headerlink" title="set中包含可变对象"></a>set中包含可变对象</h5><p>需要规避可修改对象，使其与集合中另一个元素重复的问题</p>
<p>详见此：</p>
<p><a href="https://stackoverflow.com/questions/13114043/java-hashset-contains-duplicates-if-contained-element-is-modified">Java HashSet contains duplicates if contained element is modified</a></p>
<blockquote>
<p>The correct solution is to <strong>stick to the contract</strong> of <code>Set</code> and <strong>not modify</strong> objects after adding them to the collection.</p>
<p><strong>You can avoid this problem by either:</strong></p>
<ul>
<li>using an <strong>immutable</strong> type for your set elements,</li>
<li>making a <strong>copy</strong> of the objects as you put them into the set and / or pull them out of the set,</li>
<li>writing your code so that it “<strong>knows</strong>“ not to change the objects for the duration …</li>
</ul>
<p>From the perspective of correctness and robustness, <strong>the first option is clearly best</strong>.</p>
</blockquote>
</li>
<li><h5 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h5><p>set抽象自数学的集合，因此有很多对应的集合操作：</p>
<blockquote>
<p>addAll    ∪</p>
<p>retainAll    ∩</p>
<p>removeAll    -</p>
</blockquote>
</li>
</ol>
<h3 id="AbstratcSet（A）"><a href="#AbstratcSet（A）" class="headerlink" title="AbstratcSet（A）"></a>AbstratcSet（A）</h3><blockquote>
<p>Note that this class <strong>does not override</strong> any of the implementations from the AbstractCollection class. It <strong>merely adds implementations for equals and hashCode</strong>.</p>
</blockquote>
<h4 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractSet</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Comparison and hashing</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Set))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</span><br><span class="line">        <span class="keyword">if</span> (c.size() != size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> containsAll(c);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException unused)   &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Iterator&lt;E&gt; i = iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">obj</span> <span class="operator">=</span> i.next();</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">null</span>)</span><br><span class="line">                h += obj.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不大明白为啥要修改实现，用AbstractCollection的不好吗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size() &gt; c.size()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); )</span><br><span class="line">                modified |= remove(i.next());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;?&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                    i.remove();</span><br><span class="line">                    modified = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><blockquote>
<p>In particular, <strong>it does not guarantee that the order will remain constant over time</strong>.</p>
<p>Iterating over this set requires time proportional to the sum of the HashSet instance’s size (the number of elements) plus the “capacity” of the backing HashMap instance (the number of buckets). </p>
<p>Thus, it’s very important <strong>not to</strong> set the initial capacity <strong>too high</strong> (or the load factor too low) if iteration performance is important.</p>
<p>This implementation is <strong>not synchronized</strong>. <code>Set s = Collections.synchronizedSet(new HashSet(...));</code></p>
</blockquote>
<h4 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过hashmap实现</span></span><br><span class="line">    <span class="comment">//map不可序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">	<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Constructs a new, empty set; </span></span><br><span class="line">    <span class="comment">//the backing HashMap instance has default initial capacity (16) </span></span><br><span class="line">    <span class="comment">//and load factor (0.75).</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The HashMap is created with default load factor (0.75) </span></span><br><span class="line">    <span class="comment">//and an initial capacity sufficient to contain the elements in c</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//看来这个load factor=size/0.75</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//This package private constructor is only used by LinkedHashSet.</span></span><br><span class="line">    <span class="comment">//@param: dummy – ignored (distinguishes this constructor from other constructor.)</span></span><br><span class="line">    HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">        <span class="comment">//此处为LinkeHashMap</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;<span class="keyword">return</span> map.keySet().iterator();&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;<span class="keyword">return</span> map.size();&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;<span class="keyword">return</span> map.isEmpty();&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;<span class="keyword">return</span> map.containsKey(o);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@return  true if this set did not already contain the specified element</span></span><br><span class="line">    <span class="comment">//map.put返回已有的oldValue，返回空表示没有oldValue，插入成功；否则失败</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">            <span class="keyword">return</span> newSet;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> java.io.IOException &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>.KeySpliterator&lt;E,Object&gt;(map, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其中：-7"><a href="#其中：-7" class="headerlink" title="其中："></a>其中：</h4><ol>
<li><h5 id="PRESENT"><a href="#PRESENT" class="headerlink" title="PRESENT"></a>PRESENT</h5><p>正如它的解释：</p>
<blockquote>
<p>Dummy value to associate with an Object in the backing Map</p>
</blockquote>
<p>set 以map作为内部支持，其实主要用的是map对于key的高效去重。也就是说，set其实只需要用map的key这一半就好了。所以我们另一半value就都统一用一个new Object【也就是PRESENT】来统一就行。</p>
<p>不得不说这点很聪明，值得学习。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="SortedSet（I）"><a href="#SortedSet（I）" class="headerlink" title="SortedSet（I）"></a>SortedSet（I）</h3><blockquote>
<p>A Set that further provides a total <strong>ordering</strong> on its elements. </p>
<p>The set’s iterator will traverse the set in <strong>ascending element order</strong>. </p>
<p>All elements inserted into a sorted set must implement the <strong>Comparable</strong> interface (or be accepted by the specified <strong>comparator</strong>).否则导致<strong>ClassCastException</strong></p>
<p>Note that the ordering maintained by a sorted set (whether or not an explicit comparator is provided) must be <strong>consistent with equals</strong> if the sorted set is to correctly implement the Set interface.</p>
<p>【consistent with equals：if and only if c.compare(e1, e2)==0 has the same boolean value as e1.equals(e2) for every e1 and e2 in S.】</p>
<p>//2</p>
<p><strong><u>Note</u></strong>: several methods return subsets with restricted ranges. 区间是前闭后开的。</p>
<p>If you <strong>need a closed range</strong> , and the element type allows for calculation of the <strong>successor</strong> of a given value, merely request the subrange from lowEndpoint to successor(highEndpoint).</p>
<p>For example, suppose that s is a sorted set of strings. [low,hight]<br> <code>SortedSet&lt;String&gt; sub = s.subSet(low, high+&quot;\0&quot;);</code><br>A similar technique can be used to generate an open range (low,hight)<br> <code>SortedSet&lt;String&gt; sub = s.subSet(low+&quot;\0&quot;, high);</code></p>
<p>66666</p>
</blockquote>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortedSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//null if this set uses the natural ordering</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> E&gt; comparator();</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, E toElement)</span>;</span><br><span class="line">    </span><br><span class="line">    SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement)</span>;</span><br><span class="line">    </span><br><span class="line">    SortedSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement)</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">first</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">last</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Spliterators</span>.IteratorSpliterator&lt;E&gt;(</span><br><span class="line">                <span class="built_in">this</span>, Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Comparator&lt;? <span class="built_in">super</span> E&gt; getComparator() &#123;</span><br><span class="line">                <span class="keyword">return</span> SortedSet.<span class="built_in">this</span>.comparator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其中：-8"><a href="#其中：-8" class="headerlink" title="其中："></a>其中：</h4><ol>
<li><h5 id="subset"><a href="#subset" class="headerlink" title="subset"></a>subset</h5><p>只有sorted set才有subset，想想也确实</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Throws:</span></span><br><span class="line"><span class="comment">	ClassCastException – if fromElement and toElement cannot be compared to one another using this set&#x27;s comparator </span></span><br><span class="line"><span class="comment">	NullPointerException – if fromElement or toElement is null and this set does not permit null elements</span></span><br><span class="line"><span class="comment">	IllegalArgumentException – if fromElement is greater than toElement; or fromElement or toElement lies outside the bounds of the restricted range of the set</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//The returned set will throw an IllegalArgumentException </span></span><br><span class="line"><span class="comment">//on an attempt to insert an element outside its range.</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, E toElement)</span>;</span><br></pre></td></tr></table></figure>

<p>以及注意此处是Element，不是Index</p>
</li>
<li><h5 id="subSet-low-high-”-0”"><a href="#subSet-low-high-”-0”" class="headerlink" title="subSet(low, high+”\0”);"></a>subSet(low, high+”\0”);</h5><p>为什么加个”\0”就可以，具体可以看看这个：</p>
<p><a href="https://stackoverflow.com/questions/17380051/adding-0-to-a-subset-range-end">Adding “\0” to a subset range end</a></p>
<p>原因就是sub的这个range取的是在此区间的元素，low和high这两个param不一定要包含在这个set里面。因此，按照set的排序，high+”\0”比high大，因而high就落入此区间，也就可以被包含在range中了。</p>
</li>
</ol>
<h3 id="NavigableSet（I）"><a href="#NavigableSet（I）" class="headerlink" title="NavigableSet（I）"></a>NavigableSet（I）</h3><blockquote>
<p>比起sorted set，navigable set最特殊的点在于它提供了对某一元素附近元素的导航。</p>
<p>Method    usage</p>
<p>lower         less than最大的，比所给ele小的元素</p>
<p>floor            less than or equal最大的，比所给ele小或者等于的元素</p>
<p>ceiling        greater than or equal最小的，比所给ele大或者等于的元素</p>
<p>higher         greater than最小的，比所给ele大的元素</p>
<p>The <strong>descendingSet</strong> method returns a view of the set with the senses of all relational and directional methods <strong>inverted</strong>. </p>
<p>This interface additionally defines methods <strong>pollFirst</strong> and <strong>pollLast</strong> that return and remove the lowest and highest element, if one exists, else returning null. 有点堆的感觉</p>
<p>Methods <strong>subSet</strong>, <strong>headSet</strong>, and <strong>tailSet</strong> <strong>differ from</strong> the like-named SortedSet methods in accepting <strong>additional arguments</strong> describing whether lower and upper bounds are inclusive versus exclusive. </p>
</blockquote>
<h4 id="代码：-9"><a href="#代码：-9" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NavigableSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">SortedSet</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//Returns the greatest element in this set strictly less than the given element</span></span><br><span class="line">    E <span class="title function_">lower</span><span class="params">(E e)</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">floor</span><span class="params">(E e)</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">ceiling</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">higher</span><span class="params">(E e)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Removes the first (lowest) element, or returns null if this set is empty.</span></span><br><span class="line">    E <span class="title function_">pollFirst</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    E <span class="title function_">pollLast</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//in ascending order</span></span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The returned set has an ordering equivalent to </span></span><br><span class="line"><span class="comment">    Collections.reverseOrder(comparator()). </span></span><br><span class="line"><span class="comment">    The expression s.descendingSet().descendingSet() </span></span><br><span class="line"><span class="comment">    returns a view of s essentially equivalent(基本等价) to s</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    NavigableSet&lt;E&gt; <span class="title function_">descendingSet</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Equivalent in effect to descendingSet().iterator()</span></span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    NavigableSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, <span class="type">boolean</span> fromInclusive,</span></span><br><span class="line"><span class="params">                           E toElement,   <span class="type">boolean</span> toInclusive)</span>;</span><br><span class="line">    </span><br><span class="line">    NavigableSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement, <span class="type">boolean</span> inclusive)</span>;</span><br><span class="line">    </span><br><span class="line">    NavigableSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement, <span class="type">boolean</span> inclusive)</span>;</span><br><span class="line">    </span><br><span class="line">    SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, E toElement)</span>;</span><br><span class="line">    </span><br><span class="line">    SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement)</span>;</span><br><span class="line">    </span><br><span class="line">    SortedSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><blockquote>
<p>This implementation provides guaranteed <strong>log(n)</strong> time cost for the basic operations (<strong>add</strong>, <strong>remove</strong> and <strong>contains</strong>).</p>
<p><strong>Note that this implementation is not synchronized.</strong></p>
<p><code>SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));</code></p>
</blockquote>
<h4 id="代码：-10"><a href="#代码：-10" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//依然用了个map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(s.comparator());</span><br><span class="line">        addAll(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.navigableKeySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.descendingKeySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//确实直接让map倒序就可以了</span></span><br><span class="line">    <span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title function_">descendingSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(m.descendingMap());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        m.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">// Use linear-time version if applicable</span></span><br><span class="line">        <span class="keyword">if</span> (m.size()==<span class="number">0</span> &amp;&amp; c.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                c <span class="keyword">instanceof</span> SortedSet &amp;&amp;</span><br><span class="line">                m <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">            SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; set = (SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt;) c;</span><br><span class="line">            TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;</span><br><span class="line">            Comparator&lt;?&gt; cc = set.comparator();</span><br><span class="line">            Comparator&lt;? <span class="built_in">super</span> E&gt; mc = map.comparator();</span><br><span class="line">            <span class="keyword">if</span> (cc==mc || (cc != <span class="literal">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class="line">                map.addAllForTreeSet(set, PRESENT);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, <span class="type">boolean</span> fromInclusive,</span></span><br><span class="line"><span class="params">                                  E toElement,   <span class="type">boolean</span> toInclusive)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(m.subMap(fromElement, fromInclusive,</span><br><span class="line">                toElement,   toInclusive));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement, <span class="type">boolean</span> inclusive)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement, <span class="type">boolean</span> inclusive)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, E toElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subSet(fromElement, <span class="literal">true</span>, toElement, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> headSet(toElement, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意此处为true。严格遵循左闭右开</span></span><br><span class="line">    <span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tailSet(fromElement, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Comparator&lt;? <span class="built_in">super</span> E&gt; comparator() &#123;</span><br><span class="line">        <span class="keyword">return</span> m.comparator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">first</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.firstKey();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">last</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.lastKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NavigableSet API methods</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">lower</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">floor</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">ceiling</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">higher</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="literal">null</span>) ? <span class="literal">null</span> : e.getKey();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">        Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="literal">null</span>) ? <span class="literal">null</span> : e.getKey();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        TreeSet&lt;E&gt; clone;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clone = (TreeSet&lt;E&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clone.m = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(m);</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> java.io.IOException &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> TreeMap.keySpliteratorFor(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2479143000061671589L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读JDK容器部分源码的心得体会2【Map部分】</title>
    <url>/2022/10/22/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A2%E3%80%90Map%E9%83%A8%E5%88%86%E3%80%91/</url>
    <content><![CDATA[<blockquote>
<p>idea 替换注释正则表达式<code>/\*&#123;1,2&#125;[\s\S]*?\*/</code></p>
<p>typora 替换图片asset</p>
<p><code>\!\[.*\]\(D:\\aWorkStorage\\hexo\\blog\\source\\_posts\\阅读JDK容器部分源码的心得体会2【Map部分】\\(.*)\.png\)</code>，</p>
<p>替换结果<code>&#123;% asset_img $1.png %&#125;</code></p>
</blockquote>
<h2 id="Map-I"><a href="#Map-I" class="headerlink" title="Map(I)"></a>Map(I)</h2><blockquote>
<p>A map cannot contain duplicate keys; each key can map to at most one value.</p>
<p>This interface takes the place of the Dictionary class.</p>
<p>The Map interface provides three <strong><u>collection views</u></strong>, which allow a map’s contents to be viewed as a set of keys, collection of values, or set of key-value mappings.</p>
<p>The order of a map is defined as the order in which the iterators on the map’s collection views return their elements.  map的元素顺序取决于集合元素顺序的意思？</p>
<p>Note: great care must be exercised if <strong>mutable</strong> objects are used as map <strong>keys</strong>. The behavior of a map is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is a key in the map. 【这个跟set的那个是一样的】</p>
</blockquote>
<p>map没有迭代器</p>
<img src="/2022/10/22/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A2%E3%80%90Map%E9%83%A8%E5%88%86%E3%80%91/image-20221022111020996.png" class>

<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// Query Operations</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//This operation will probably require time linear in the map size </span></span><br><span class="line">    <span class="comment">//for most implementations of the Map interface.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(Object key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modification Operations</span></span><br><span class="line">    </span><br><span class="line">    V <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line">    </span><br><span class="line">    V <span class="title function_">remove</span><span class="params">(Object key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bulk Operations</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Views</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Returns a Set view of the keys contained in this map.</span></span><br><span class="line">    <span class="comment">//The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. </span></span><br><span class="line">    <span class="comment">//The set supports element removal, </span></span><br><span class="line">    <span class="comment">//which removes the corresponding mapping from the map, </span></span><br><span class="line">    <span class="comment">//via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. </span></span><br><span class="line">    <span class="comment">//It does not support the add or addAll operations.</span></span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//跟上面一样，也只支持remove，不支持add</span></span><br><span class="line">    Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="comment">//跟上面一样，也只支持remove，不支持add</span></span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The only way to obtain a reference to a map entry is from the iterator of this collection-view.</span></span><br><span class="line">    <span class="comment">//These Map.Entry objects are valid only for the duration of the iteration;</span></span><br><span class="line">    <span class="comment">//more formally, the behavior of a map entry is undefined if the backing map has been</span></span><br><span class="line">    <span class="comment">//modified after the entry was returned by the iterator, </span></span><br><span class="line">    <span class="comment">//except through the setValue operation on the map entry.迭代器也不行了</span></span><br><span class="line">    <span class="comment">//可见度为default，包内可见</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">        </span><br><span class="line">        V <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">        </span><br><span class="line">        V <span class="title function_">setValue</span><span class="params">(V value)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123;</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                    (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                    (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? <span class="built_in">super</span> K&gt; cmp) &#123;</span><br><span class="line">            Objects.requireNonNull(cmp);</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                    (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? <span class="built_in">super</span> V&gt; cmp) &#123;</span><br><span class="line">            Objects.requireNonNull(cmp);</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                    (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Comparison and hashing</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defaultable methods</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">default</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">return</span> (((v = get(key)) != <span class="literal">null</span>) || containsKey(key))</span><br><span class="line">                ? v</span><br><span class="line">                : defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                k = entry.getKey();</span><br><span class="line">                v = entry.getValue();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalStateException ise) &#123;</span><br><span class="line">                <span class="comment">// this usually means the entry is no longer in the map.</span></span><br><span class="line">                <span class="comment">//确实说明这时候应该并发修改异常了</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>(ise);</span><br><span class="line">            &#125;</span><br><span class="line">            action.accept(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; function)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(function);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                k = entry.getKey();</span><br><span class="line">                v = entry.getValue();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalStateException ise) &#123;</span><br><span class="line">                <span class="comment">// this usually means the entry is no longer in the map.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>(ise);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ise thrown from function is not a cme.</span></span><br><span class="line">            v = function.apply(k, v);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                entry.setValue(v);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalStateException ise) &#123;</span><br><span class="line">                <span class="comment">// this usually means the entry is no longer in the map.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>(ise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//If the specified key 没有mapping或者对应值为空</span></span><br><span class="line">    <span class="comment">//associates it with the given value and returns null, </span></span><br><span class="line">    <span class="comment">//else returns the current value.</span></span><br><span class="line">    <span class="keyword">default</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> get(key);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">            v = put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当所给的key对应的curValue==value时，就remove掉这对mapping</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">curValue</span> <span class="operator">=</span> get(key);</span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(curValue, value) ||</span><br><span class="line">                (curValue == <span class="literal">null</span> &amp;&amp; !containsKey(key))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        remove(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">curValue</span> <span class="operator">=</span> get(key);</span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(curValue, oldValue) ||</span><br><span class="line">                (curValue == <span class="literal">null</span> &amp;&amp; !containsKey(key))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果映射存在就replace，返回旧值</span></span><br><span class="line">    <span class="keyword">default</span> V <span class="title function_">replace</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        V curValue;</span><br><span class="line">        <span class="keyword">if</span> (((curValue = get(key)) != <span class="literal">null</span>) || containsKey(key)) &#123;</span><br><span class="line">            curValue = put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过mappingFunction来用key计算value</span></span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">default</span> V <span class="title function_">computeIfAbsent</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                              Function&lt;? <span class="built_in">super</span> K, ? extends V&gt; mappingFunction)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(mappingFunction);</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">if</span> ((v = get(key)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            V newValue;</span><br><span class="line">            <span class="keyword">if</span> ((newValue = mappingFunction.apply(key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                put(key, newValue);</span><br><span class="line">                <span class="keyword">return</span> newValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.</span></span><br><span class="line">	<span class="comment">//If the function returns null, the mapping is removed.【此时传入的function计算得出value=NULL】</span></span><br><span class="line">    <span class="comment">//If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</span></span><br><span class="line">    <span class="keyword">default</span> V <span class="title function_">computeIfPresent</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                               BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(remappingFunction);</span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="keyword">if</span> ((oldValue = get(key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">newValue</span> <span class="operator">=</span> remappingFunction.apply(key, oldValue);</span><br><span class="line">            <span class="keyword">if</span> (newValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                put(key, newValue);</span><br><span class="line">                <span class="keyword">return</span> newValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                remove(key);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//跟上面那个的差别好像在，当oldValue==NULL，newValue不等于NULL时，下面这个会放入mapp(key,new)</span></span><br><span class="line">    <span class="comment">//上面那个什么也不做。毕竟上面的叫computeIfPresent嘛</span></span><br><span class="line">    <span class="keyword">default</span> V <span class="title function_">compute</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                      BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(remappingFunction);</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(key);</span><br><span class="line"></span><br><span class="line">        <span class="type">V</span> <span class="variable">newValue</span> <span class="operator">=</span> remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (newValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// delete mapping</span></span><br><span class="line">            <span class="comment">//新value==NULL，就delete</span></span><br><span class="line">            <span class="keyword">if</span> (oldValue != <span class="literal">null</span> || containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// something to remove</span></span><br><span class="line">                remove(key);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// nothing to do. Leave things as they were.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// add or replace old mapping</span></span><br><span class="line">            put(key, newValue);</span><br><span class="line">            <span class="keyword">return</span> newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把新旧值通过function合并</span></span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">default</span> V <span class="title function_">merge</span><span class="params">(K key, V value,</span></span><br><span class="line"><span class="params">                    BiFunction&lt;? <span class="built_in">super</span> V, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(remappingFunction);</span><br><span class="line">        Objects.requireNonNull(value);</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(key);</span><br><span class="line">        <span class="comment">//传入function的必定非空</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">newValue</span> <span class="operator">=</span> (oldValue == <span class="literal">null</span>) ? value :</span><br><span class="line">                remappingFunction.apply(oldValue, value);</span><br><span class="line">        <span class="keyword">if</span>(newValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            put(key, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6 迭代</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其中："><a href="#其中：" class="headerlink" title="其中："></a>其中：</h3><ol>
<li><h4 id="get-return-null时的情况"><a href="#get-return-null时的情况" class="headerlink" title="get return null时的情况"></a>get return null时的情况</h4><p>get return null when value==NULL or key不存在。</p>
<p>为了区分这两种情况，写代码时可以用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if !containsKey(key)&#123;</span><br><span class="line">	key不存在</span><br><span class="line">&#125;</span><br><span class="line">Obj obj=get(key);</span><br></pre></td></tr></table></figure>

<p>其实源码中的getordefault方法就给出了应用典范</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">return</span> (((v = get(key)) != <span class="literal">null</span>) || containsKey(key))</span><br><span class="line">        ? v</span><br><span class="line">        : defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="view"><a href="#view" class="headerlink" title="view"></a>view</h4><blockquote>
<p>//Returns a Set view of the keys contained in this map.</p>
<p>//The set is backed by the map, so changes to the map are reflected in the set, and vice-versa.</p>
</blockquote>
<p>如下代码测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Lily&quot;</span>,<span class="number">15</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Sam&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Mary&quot;</span>,<span class="number">11</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Lee&quot;</span>,<span class="number">111</span>);</span><br><span class="line">        Set set=map.keySet();</span><br><span class="line">        <span class="keyword">for</span>( Object str : set)&#123;</span><br><span class="line">            System.out.print((String) str+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        set.remove(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line">        <span class="comment">//set.add(&quot;haha&quot;);</span></span><br><span class="line">        <span class="keyword">for</span>( Object str : set)&#123;</span><br><span class="line">            System.out.print((String) str+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (Object str : map.keySet())&#123;</span><br><span class="line">            System.out.print((String) str+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;Lee&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Lee Lily Sam Mary </span></span><br><span class="line"><span class="comment">Lily Sam Mary </span></span><br><span class="line"><span class="comment">Lily Sam Mary </span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可得，与之前的List一样，这个view都是纯粹基于原数组的，实时变化的。</p>
<p>在应用中可发现，可以通过map的key和value的set来对map进行遍历。</p>
</li>
<li><h4 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet"></a>entrySet</h4><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//The map can be modified while an iteration over the set is in progress </span></span><br><span class="line"><span class="comment">//when using the setValue operation on a map entry returned by the iterator</span></span><br><span class="line"><span class="comment">//or through the iterator&#x27;s own remove operation</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>相比于其它的view，多了第二句话</p>
</li>
<li><h4 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent"></a>computeIfAbsent</h4><blockquote>
<p>If the function returns null no mapping is recorded. </p>
<p>If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. </p>
<p>The most <strong>common usage</strong> is to construct a new object serving as an initial mapped value or memoized result, as in:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> <span class="title class_">Value</span>(f(k)));</span><br></pre></td></tr></table></figure>

<p>Or to implement a multi-value map, Map&lt;K,Collection<V>&gt;, supporting multiple values per key:</V></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;V&gt;()).add(v);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它这说的还是很抽象的，下面给出一个使用computeIfAbsent的优雅实例：</p>
<p><a href="https://stackoverflow.com/questions/65421001/treemapstring-new-treemapstring-integer-treemap-with-object">TreeMap()) Treemap With Object</a></p>
<blockquote>
<p><code>computeIfAbsent</code> returns the value that is already present in the map, or otherwise evaluates the lambda and puts that into the map, and returns that value.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;line&quot;</span>;      </span><br><span class="line"><span class="type">var</span> <span class="variable">mp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;String,TreeMap&lt;String,Integer&gt;&gt;();     </span><br><span class="line"><span class="type">var</span> <span class="variable">m</span> <span class="operator">=</span> mp.computeIfAbsent(line, k -&gt; <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;());</span><br><span class="line">m.put(<span class="string">&quot;content&quot;</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(mp);</span><br><span class="line"><span class="comment">//output:&#123;line=&#123;content=5&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>computIfAbsent发现此时map里面没有这个“line”key，就执行第二个参数的lambda表达式，把一个new TreeMap&lt;&gt;以line为关键字放入，并且返回该TreeMap。</p>
</li>
<li><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><blockquote>
<p>看起来非常实用：</p>
<p>This method may be of use when <strong>combining multiple mapped values for a key</strong>【相同key不同value合并】. For example, to either create or append a String msg to a value mapping:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.merge(key, msg, String::concat)</span><br></pre></td></tr></table></figure>

<p>所举代码段意为把新值通过字符串拼接接在旧值后面。</p>
<p>应该也可以用于集合合并。总之具体实现方法取决于传入的function参数，非常实用</p>
</blockquote>
</li>
<li><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><strong>map本身没有迭代器。</strong></p>
<p>因而在对map进行遍历时，只能通过其keyset、valueset以及entryset来实现。</p>
<p>具体详见：<a href="https://wenku.baidu.com/view/fae0592875c66137ee06eff9aef8941ea76e4b6b.html">HashMap的四种遍历方式</a></p>
</li>
</ol>
<h2 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="AbstractMap"></a>AbstractMap</h2><blockquote>
<p>To implement an <strong>unmodifiable</strong> map, the programmer needs only to extend this class and provide an implementation for the <strong>entrySet</strong> method, <u>which returns a set-view of the map’s mappings</u>. Typically, the returned set will, in turn, be implemented atop AbstractSet. This set <strong>should not</strong> support the add or remove methods, and its iterator should not support the remove method.</p>
<p>To implement a <strong>modifiable</strong> map, the programmer must <strong>additionally</strong> override this class’s <strong>put</strong> method (which otherwise throws an UnsupportedOperationException), and the iterator returned by entrySet().iterator() must <strong>additionally</strong> implement its <strong>remove</strong> method.</p>
</blockquote>
<img src="/2022/10/22/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A2%E3%80%90Map%E9%83%A8%E5%88%86%E3%80%91/image-20221019214258632.png" class>

<p>最核心的还是entrySet。其余所有的方法，都是通过enrtSet实现的。而给定了enrty这个数据结构的实现方式，剩下的就是entrySet具体怎么实现了。AbstractMap把entrySet的实现抽象了出来，交给了其实现类去具体实现。</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractMap</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query Operations</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//还真确实是set的大小</span></span><br><span class="line">        <span class="keyword">return</span> entrySet().size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">if</span> (value==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//entrySet的元素是Entry</span></span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span> (e.getValue()==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span> (value.equals(e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">if</span> (key==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span> (e.getKey()==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">if</span> (key==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span> (e.getKey()==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> e.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                    <span class="keyword">return</span> e.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modification Operations</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为啥unmodifiable map还可以remove</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        Entry&lt;K,V&gt; correctEntry = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (key==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (correctEntry==<span class="literal">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span> (e.getKey()==<span class="literal">null</span>)</span><br><span class="line">                    correctEntry = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (correctEntry==<span class="literal">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                    correctEntry = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (correctEntry !=<span class="literal">null</span>) &#123;</span><br><span class="line">            oldValue = correctEntry.getValue();</span><br><span class="line">            i.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bulk Operations</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet())</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//还真是</span></span><br><span class="line">        entrySet().clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Views</span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;K&gt;        keySet;</span><br><span class="line">    <span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//The set supports element removal via </span></span><br><span class="line">    <span class="comment">//the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. </span></span><br><span class="line">    <span class="comment">//It does not support the add or addAll operations.</span></span><br><span class="line">    <span class="comment">//只删不加</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//引用成员变量，减少访问堆次数</span></span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="comment">//首次建立视图</span></span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> <span class="title class_">AbstractSet</span>&lt;K&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;K&gt;() &#123;</span><br><span class="line">                        <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">public</span> K <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> i.next().getKey();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">                            i.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//AbtractMap的这些方法都是通过其entryset实现的。因此其实最主要的还是entryset怎么实现的</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.size();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.isEmpty();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">                    AbstractMap.<span class="built_in">this</span>.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.containsKey(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//赋值回给成员变量</span></span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">        Collection&lt;V&gt; vals = values;</span><br><span class="line">        <span class="keyword">if</span> (vals == <span class="literal">null</span>) &#123;</span><br><span class="line">            vals = <span class="keyword">new</span> <span class="title class_">AbstractCollection</span>&lt;V&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Iterator&lt;V&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;V&gt;() &#123;</span><br><span class="line">                        <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> V <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> i.next().getValue();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">                            i.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.size();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.isEmpty();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">                    AbstractMap.<span class="built_in">this</span>.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.containsValue(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            values = vals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有待不同的数据结构实现了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;Entry&lt;K,V&gt;&gt; <span class="title function_">entrySet</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Comparison and hashing</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line">        <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">            h += i.next().hashCode();</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            <span class="comment">//经典防自环</span></span><br><span class="line">            sb.append(key   == <span class="built_in">this</span> ? <span class="string">&quot;(this Map)&quot;</span> : key);</span><br><span class="line">            sb.append(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            sb.append(value == <span class="built_in">this</span> ? <span class="string">&quot;(this Map)&quot;</span> : value);</span><br><span class="line">            <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">                <span class="keyword">return</span> sb.append(<span class="string">&#x27;&#125;&#x27;</span>).toString();</span><br><span class="line">            sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        AbstractMap&lt;?,?&gt; result = (AbstractMap&lt;?,?&gt;)<span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">//也就只有这两个成员变量了</span></span><br><span class="line">        result.keySet = <span class="literal">null</span>;</span><br><span class="line">        result.values = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">eq</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1 == <span class="literal">null</span> ? o2 == <span class="literal">null</span> : o1.equals(o2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implementation Note: SimpleEntry and SimpleImmutableEntry</span></span><br><span class="line">    <span class="comment">// are distinct unrelated classes, even though they share</span></span><br><span class="line">    <span class="comment">// some code. Since you can&#x27;t add or subtract final-ness</span></span><br><span class="line">    <span class="comment">// of a field in a subclass, they can&#x27;t share representations,</span></span><br><span class="line">    <span class="comment">// and the amount of duplicated code is too small to warrant</span></span><br><span class="line">    <span class="comment">// exposing a common abstract class.</span></span><br><span class="line">    <span class="comment">//意思就是说，这两个类一个表示key不可变value可变的entry，也就是可变map，</span></span><br><span class="line">    <span class="comment">//另一个表示key和value都不可变的entry，也就是固定map，</span></span><br><span class="line">    <span class="comment">//这俩有很多重复代码，但不能统一到一起，是因为前者有一个final字段，后者有两个，</span></span><br><span class="line">    <span class="comment">//无法对这个final字段做一个统一，因此只能分成两个了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="comment">//对Entry接口的一个简单实现【key不可变，value可变】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleEntry</span>&lt;K,V&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Entry</span>&lt;K,V&gt;, java.io.Serializable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8499721149061103585L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key不可修改，value可修改</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SimpleEntry</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key   = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SimpleEntry</span><span class="params">(Entry&lt;? extends K, ? extends V&gt; entry)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key   = entry.getKey();</span><br><span class="line">            <span class="built_in">this</span>.value = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="built_in">this</span>.value;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">return</span> eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//注意这里是异或</span></span><br><span class="line">            <span class="keyword">return</span> (key   == <span class="literal">null</span> ? <span class="number">0</span> :   key.hashCode()) ^</span><br><span class="line">                    (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="comment">//对Entry接口的一个简单实现【key不可变，value不可变】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleImmutableEntry</span>&lt;K,V&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Entry</span>&lt;K,V&gt;, java.io.Serializable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7138329143949025153L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SimpleImmutableEntry</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key   = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SimpleImmutableEntry</span><span class="params">(Entry&lt;? extends K, ? extends V&gt; entry)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key   = entry.getKey();</span><br><span class="line">            <span class="built_in">this</span>.value = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">            <span class="comment">//exception</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">return</span> eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (key   == <span class="literal">null</span> ? <span class="number">0</span> :   key.hashCode()) ^</span><br><span class="line">                    (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其中：-1"><a href="#其中：-1" class="headerlink" title="其中："></a>其中：</h3><ol>
<li><h4 id="view-1"><a href="#view-1" class="headerlink" title="view"></a>view</h4><blockquote>
<p>Each of these fields are initialized to contain an instance of the appropriate view the first time this view is requested. The views are stateless, so there’s no reason to create more than one of each.</p>
</blockquote>
<p>不同于之前List的sublist和sorted set的subset，它俩是调用创建view方法时才构造出一个新的对象，map是直接把values和keys视图放入成员变量了，因为Collection的视图从实用角度来说有起始和终点更实用，map不需要这个性质，因此作为成员变量花费更小</p>
</li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>哈希表+链表/红黑树</p>
<blockquote>
<p>permits null values and the null key允许空，其hash应该是0</p>
<p>The HashMap class is roughly equivalent to <strong><u>Hashtable</u></strong>, except that it is <strong>unsynchronized</strong> and permits <strong>nulls</strong>.不同步</p>
<p>This class makes <strong>no guarantees as to the order</strong> of the map; in particular, it does not guarantee that the order will remain constant over time.无序</p>
<p>这应该差不多就是个桶链表</p>
<p>An instance of HashMap has two parameters that affect its performance: initial <strong>capacity</strong> and <strong>load factor</strong>.</p>
<p>The capacity is the number of <strong>buckets</strong> in the hash table.桶数量=capacity</p>
<p>The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. 如果装载百分比达到load factor，hashmap的capacity就会自动增长。</p>
<p>When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed.如果元素数量&gt;=load factor*capacity，就会自动增长并且重新hash。</p>
<p>默认的load factor是0.75.【我其实觉得这个数很有意思。它是二进制意义上的整除数，因而计算应该很方便：它可以被整整表示，并且计算时可以拆成“2^-1+2^-2”以供移位简化】</p>
<p>我们设置capacity和load factor的意图应该是要尽量减少rehash的次数。</p>
<p>Note that using many keys with the same hashCode() is a sure way to slow down performance of any hash table使用多个相同的key【指hashcode相同】会降低性能【？】</p>
<p><a href="https://stackoverflow.com/questions/43911369/hashmap-java-8-implementation%E7%AD%89%E4%BC%9A%E7%9C%8B%E7%9C%8B">https://stackoverflow.com/questions/43911369/hashmap-java-8-implementation等会看看</a></p>
</blockquote>
<p>总之意思差不多就是，hashmap的数据结构：</p>
<p>table数组，每个成员都是一个桶，桶里面装着结点。table默认长度为16</p>
<p>每个桶内结点的结构依具体情况（该桶内元素多少）来决定，桶内元素多则用树状结构，少就用简单的线性表结构。线性结构为Node&lt;K,V&gt;，树状结构为TreeNode&lt;K,V&gt;。</p>
<p>当一个线性表桶内结点多于临界值，就需要进行树化，会从链表变成红黑树；当整个hashmap结点数多于临界值，就需要增长capacity并且进行rehash。</p>
<p>hashmap的桶的装配：首先通过key的hashcode算出一个hash值，然后再把该hash值与n-1相与就能得到桶编号。接下来再在桶内找到应插入的结点就行。</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此映射通常充当分箱（分桶）哈希表，但当箱变得太大时，它们会转换为 TreeNode 的箱，</span></span><br><span class="line"><span class="comment">    每个结构类似于 java.util.TreeMap 中的结构。 </span></span><br><span class="line"><span class="comment">    大多数方法尝试使用正常的 bin，但出于实用性有时候会过渡到 TreeNode 方法（只需检查节点的实例）。</span></span><br><span class="line"><span class="comment">    TreeNode 的 bin 可以像任何其他 bin 一样被遍历和使用，但在填充过多时还支持更快的查找。 </span></span><br><span class="line"><span class="comment">    但是，由于绝大多数正常使用的 bin 并没有过度填充，</span></span><br><span class="line"><span class="comment">    因此在 table 方法的过程中检查树 bin 的存在可能会白花时间。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    因为 TreeNode 的大小大约是常规节点的两倍，</span></span><br><span class="line"><span class="comment">    所以我们仅在 bin 包含足够的节点以保证使用时才使用它们（请参阅 TREEIFY_THRESHOLD）。 </span></span><br><span class="line"><span class="comment">    当它们变得太小（由于移除或调整大小）时，它们会被转换回plain bins。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The bin count 临界值 for using a tree rather than list for a bin. </span></span><br><span class="line"><span class="comment">    当桶内节点数大于等于该值时，桶将由链表连接转化为树状结构。 </span></span><br><span class="line"><span class="comment">    该值必须大于 2 并且应该至少为 8，以便与树移除中关于在收缩时转换回普通 bin 的假设相吻合。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//The bin count threshold for untreeifying a (split) bin during a resize operation. </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">    (Otherwise the table is resized if too many nodes in a bin.) </span></span><br><span class="line"><span class="comment">    Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts between </span></span><br><span class="line"><span class="comment">    resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="comment">//一旦被构造器初始化，就不可变。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="comment">//结点的键不变，但值可变</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">//链表结构</span></span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也就是说它自己的hashcode和构造时给它的hash是不一样的</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                        Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ----------------静态共用方法-------------- */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//hash的计算方法</span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="comment">//逻辑右移</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">            <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            <span class="comment">//检查所有接口</span></span><br><span class="line">            <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                            ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                                    Comparable.class) &amp;&amp;</span><br><span class="line">                            (as = p.getActualTypeArguments()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                            as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="literal">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">                <span class="comment">//会调用最新版本的方法</span></span><br><span class="line">                ((Comparable)k).compareTo(x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这一通操作可以得到比cap大的，且离cap最近的2的幂次方数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The table, initialized on first use, and resized as necessary. </span></span><br><span class="line"><span class="comment">    长度是2的幂次或者0【初始】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始为0，每put一次元素就++。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//达到此值时hashmap需要增长capacity并且rehash</span></span><br><span class="line">    <span class="comment">// (可序列化</span></span><br><span class="line">    <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">    <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ---------------- Public operations -------------- */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                    initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                    loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Implements Map.putAll and 上面的Map constructor的辅助方法</span></span><br><span class="line">    <span class="comment">//evict – false when initially constructing this map, else true </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="comment">//+1保证了至少比m大</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">                <span class="comment">//延迟resize，随处可见的懒汉思想，很聪明</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">                <span class="comment">//就地resize</span></span><br><span class="line">                resize();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                    ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put方法的实现</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">//计算key的哈希值</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//evict – false when initially constructing this map, else true </span></span><br><span class="line">    <span class="comment">//Implements Map.put and related methods.</span></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//此处调用resize初始化</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">//n为table大小</span></span><br><span class="line">        <span class="comment">//首先先找到所在桶</span></span><br><span class="line">        <span class="comment">//如果所在桶不存在，就直接申请一个新桶（结点）放</span></span><br><span class="line">        <span class="comment">//2此处找桶的方式</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//所在桶存在</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//e为要塞进去value的结点，k为临时变量，用于存储key值</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//如果p的哈希值为key的哈希值，并且p的key==key，说明键本来就存在，并且正好是桶内第一个元素，只需修改旧键值对的value就行</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//e=旧结点</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//否则需要沿着桶的结构继续往下找，这时候就需要看桶内用的是树状结构还是顺序结构了</span></span><br><span class="line">            <span class="comment">//如果此时用的是树状结构</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">//用的是顺序结构</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//走到桶尽头，此时e==NULL</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//到达临界点，需要树化</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//一直走，直到找到</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//两个指针来回交替往下走</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上面可以看到，只有原来就存在键值对才会满足此条件</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="comment">//onlyIfAbsent – if true, don&#x27;t change existing value 除非旧值为空</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">//空操作，方便LinkedHashMap的后续实现</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">//存在旧键值对的情况至此结束</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这说明是新建了一个结点</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">//空操作，方便LinkedHashMap的后续实现</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initializes or doubles table size. </span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//决定newCap和newThr</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//扩容两倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">//因为此时capacity已经需要向threshold转变了，因而newThr需要再计算</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//需要复制原oldTab中的每个结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//该桶只有一个结点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">//5</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//树化桶</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">//如果表的一个桶结点数大于8（TREEIFY_THRESHOLD），但是表的总结点数小于64（MIN_TREEIFY_CAPACITY）也是不会树化的，只会resize重新hash</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">//需要树化</span></span><br><span class="line">        <span class="comment">//取得该桶的头结点e</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//replacementTreeNode return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span></span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//此时有0个结点</span></span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//只树化该桶</span></span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于重复键需替换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        putMapEntries(m, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Returns:the previous value</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">                <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//matchValue – if true only remove if value is equal</span></span><br><span class="line">    <span class="comment">//value – the value to match if matchValue, else ignored</span></span><br><span class="line">    <span class="comment">//movable – if false do not move other nodes while removing用于树</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">        <span class="comment">//table和键都存在</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//node为要移走的结点</span></span><br><span class="line">            Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">//检查头结点</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((k = e.key) == key ||</span><br><span class="line">                                        (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//需要移走</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                    (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">                <span class="comment">//由上文可知，此时node==p==头结点</span></span><br><span class="line">                <span class="comment">//能找到这个差异点也是真牛逼</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="comment">//此时p.next=node</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="literal">null</span>;<span class="comment">//我知道你要说什么：let GC do its work</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历。有树优化的话可以减少时间开销。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                            (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//是HashMap自己实现的keyset</span></span><br><span class="line">            ks = <span class="keyword">new</span> <span class="title class_">KeySet</span>();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeySpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> K&gt; action)</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">if</span> (vs == <span class="literal">null</span>) &#123;</span><br><span class="line">            vs = <span class="keyword">new</span> <span class="title class_">Values</span>();</span><br><span class="line">            values = vs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Values</span> <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ValueIterator</span>(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ValueSpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="literal">null</span> ? (entrySet = <span class="keyword">new</span> <span class="title class_">EntrySet</span>()) : es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntrySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntryIterator</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不如直接用map的contains、remove等等等</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="literal">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="comment">//只在值相等的时候remove</span></span><br><span class="line">                <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntrySpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overrides of JDK8 Map extension methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Returns the value to which the specified key is mapped, </span></span><br><span class="line">    <span class="comment">//or defaultValue if this map contains no mapping for the key.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? defaultValue : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//If the specified key is not already associated with a value (or is mapped to null)</span></span><br><span class="line">    <span class="comment">//associates it with the given value and returns null, </span></span><br><span class="line">    <span class="comment">//else returns the current value.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有在curVal==value且key存在的情况下才remove掉键值对</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; V v;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                ((v = e.value) == oldValue || (v != <span class="literal">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">            e.value = newValue;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">replace</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果key对应键值对不存在，就创建一个新的，并把它的值置为paramFunction(key)</span></span><br><span class="line">    <span class="comment">//返回的是修改后的值。</span></span><br><span class="line">    <span class="comment">//其他详见Map的第4点</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">computeIfAbsent</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                             Function&lt;? <span class="built_in">super</span> K, ? extends V&gt; mappingFunction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappingFunction == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="literal">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="literal">null</span> ||</span><br><span class="line">                (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="literal">null</span> &amp;&amp; (oldValue = old.value) != <span class="literal">null</span>) &#123;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> mappingFunction.apply(key);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="built_in">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//++size后不用再check是否&gt;threshold吗 ?为啥要交给上面一开始的时候判断</span></span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return 新值</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">computeIfPresent</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                              BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (oldValue = e.value) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> remappingFunction.apply(key, oldValue);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = v;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                     BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="literal">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="literal">null</span> ||</span><br><span class="line">                (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> (old == <span class="literal">null</span>) ? <span class="literal">null</span> : old.value;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="built_in">this</span>, tab, hash, key, v);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, v, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">merge</span><span class="params">(K key, V value,</span></span><br><span class="line"><span class="params">                   BiFunction&lt;? <span class="built_in">super</span> V, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="literal">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="literal">null</span> ||</span><br><span class="line">                (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">if</span> (old.value != <span class="literal">null</span>)</span><br><span class="line">                v = remappingFunction.apply(old.value, value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                v = value;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, value, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; function)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                    e.value = function.apply(e.key, e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Cloning and serialization</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (HashMap&lt;K,V&gt;)<span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        result.reinitialize();</span><br><span class="line">        result.putMapEntries(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These methods are also used when serializing HashSets</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="title function_">loadFactor</span><span class="params">()</span> &#123; <span class="keyword">return</span> loadFactor; &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (table != <span class="literal">null</span>) ? table.length :</span><br><span class="line">                (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">                        DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Support for resetting final field during deserializing</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UnsafeHolder</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//7</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HashIterator</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">        <span class="type">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">        <span class="type">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] t = table;</span><br><span class="line">            current = next = <span class="literal">null</span>;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//指向第一个非空表项</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] t;</span><br><span class="line">            Node&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="comment">//移动桶内指针</span></span><br><span class="line">            <span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果桶内表到达尽头，则移动选择桶的指针</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            current = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> p.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ValueIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntryIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Map.Entry&lt;K,V&gt; <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spliterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HashMapSpliterator</span>&lt;K,V&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySpliterator</span>&lt;K,V&gt;</span><br><span class="line">            <span class="keyword">extends</span> <span class="title class_">HashMapSpliterator</span>&lt;K,V&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;K&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ValueSpliterator</span>&lt;K,V&gt;</span><br><span class="line">            <span class="keyword">extends</span> <span class="title class_">HashMapSpliterator</span>&lt;K,V&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;V&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntrySpliterator</span>&lt;K,V&gt;</span><br><span class="line">            <span class="keyword">extends</span> <span class="title class_">HashMapSpliterator</span>&lt;K,V&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LinkedHashMap support</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a regular (non-tree) node</span></span><br><span class="line">    Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For conversion from TreeNodes to plain nodes</span></span><br><span class="line">    Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a tree bin node</span></span><br><span class="line">    TreeNode&lt;K,V&gt; <span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For treeifyBin</span></span><br><span class="line">    TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reinitialize</span><span class="params">()</span> &#123;</span><br><span class="line">        table = <span class="literal">null</span>;</span><br><span class="line">        entrySet = <span class="literal">null</span>;</span><br><span class="line">        keySet = <span class="literal">null</span>;</span><br><span class="line">        values = <span class="literal">null</span>;</span><br><span class="line">        modCount = <span class="number">0</span>;</span><br><span class="line">        threshold = <span class="number">0</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called only from writeObject, to ensure compatible ordering.</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Tree bins</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6红黑树介绍，此部分具体的红黑树实现省略</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其中：-2"><a href="#其中：-2" class="headerlink" title="其中："></a>其中：</h3><ol>
<li><h4 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h4><img src="/2022/10/22/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A2%E3%80%90Map%E9%83%A8%E5%88%86%E3%80%91/image-20221021103042383.png" class>

<p>hash=原hashcode^（原hashcode逻辑右移16位)</p>
<p>这样的话，由于右移16位补零，此时高位的所有比特位都跟原来一样，低位的比特位变成了融合高低位特点的东西，这样就可以减少冲突，增加均匀性</p>
</li>
<li><h4 id="table-n-1-amp-hash"><a href="#table-n-1-amp-hash" class="headerlink" title="table[(n-1)&amp;hash]"></a>table[(n-1)&amp;hash]</h4><p>具体看这个视频，讲得非常不错</p>
<p><a href="https://www.bilibili.com/video/BV1DF41177uD/">【Java面试必问】HashMap中是如何计算数组下标的？</a></p>
<p>假设table此时为默认长度16.则n-1=15</p>
<p>写出15的二进制形式：0000 1111，可以发现，任何数跟它相与，结果都一定为0000 xxxx，永不越界。</p>
<p>写出16的二进制形式：0001 0000，可以发现，任何数跟它相与，结果都一定为16或者0.</p>
<p>可以发现15有非常好的性质。</p>
<p>而扩展出来，任何2的幂次方-1都具有这样的良好的性质。**<u>这也是为什么hashmap要求表的长度应该为2的幂次。</u>**</p>
<p>而且，除了不会越界，还有一点就是，<u><strong>这个任何数与15相与的与操作就相当于，任何数对16取余的取余操作。</strong>这点实在是佩服啊，把复杂的取余操作在该场景下直接用一个位运算就搞定了。</u></p>
</li>
<li><h4 id="comparableClassFor"><a href="#comparableClassFor" class="headerlink" title="comparableClassFor"></a>comparableClassFor</h4><p>树状结构时结点的默认排序方式是by hashCode。但如果两个结点元素之间是同一个class C，并且这个C实现了Comparable方法，那么就不会按照它们的hashCode比较，而是会调用class C的compareTo方法。</p>
<p>(We conservatively（保守地） check generic types via reflection to validate（证实） this – see method comparableClassFor).</p>
<p>也就是说这个comparableClassFor方法的意图就是，如果这个类是comparable的，就返回它具体类型，如果不是返回null。</p>
</li>
<li><h4 id="entrySet-1"><a href="#entrySet-1" class="headerlink" title="entrySet"></a>entrySet</h4><p>不同于AbstractMap中entrySet的核心作用，HashMap的put、get、clear等等等核心函数都不依赖于entrySet了，毕竟结构改变得比较多了。因而这里的entrySet字段保留，只是为了呼应AbstractMap中keyset和valueset的实现，以及补充AbstractMap中未给出的EntrySet实现。</p>
</li>
<li><h4 id="resize-扩容旧表到新表的转移"><a href="#resize-扩容旧表到新表的转移" class="headerlink" title="resize()扩容旧表到新表的转移"></a>resize()扩容旧表到新表的转移</h4><p>此时需要复制oldTab中的所有结点。但注意，由于此时发生了扩容，hash的计算发生了变化，因而不能全部照搬不动oldTab中的下标，否则产生错误。因而我们需要了解一下如何调整下标。</p>
<p>首先由代码可得，<u>对于oldTab!=NULL的情况下</u>，<strong>newCap一定是扩为原来的两倍的。因而以下只需讨论扩容为两倍的情况。</strong></p>
<p>由第2点可知，假设现在容量为16，扩容为原来的两倍，则hash掩码应该为0000 1111，扩容后，hash掩码应该为0001 1111，可见就只是多了一位，因而，oldTab中，若这一位的值为0，则在新表和旧表中位置的下标应该是一样的；若这一位的值为1，则新表下标=旧表下标+offset，offset正是等于0001 0000.而这个“0001 0000”，正是oldCap！</p>
<p>对于容量为其他值，全部道理都是一样的。</p>
<p>因而我们要做的，<u>是对旧表的每一个桶内的所有结点，把它们分成两类，一类为(e.hash &amp; oldCap) == 0【也就是这一位值为0 情况】和(e.hash &amp; oldCap) == 1，然后对这两类进行在新表中分别映射即可</u>。这段代码便做了这样的事。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">                  <span class="comment">//5</span></span><br><span class="line"><span class="comment">//low index head，下标保持不变</span></span><br><span class="line">                  Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//high index head,下标需要增长偏移量</span></span><br><span class="line">                  Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                  Node&lt;K,V&gt; next;</span><br><span class="line">                  <span class="keyword">do</span> &#123;</span><br><span class="line">                      next = e.next;</span><br><span class="line">                      <span class="comment">//第一类</span></span><br><span class="line">                      <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="comment">//一个简单的队列操作</span></span><br><span class="line">                          <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                              loHead = e;</span><br><span class="line">                          <span class="keyword">else</span></span><br><span class="line">                              loTail.next = e;</span><br><span class="line">                          loTail = e;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">//第二类</span></span><br><span class="line">                      <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                              hiHead = e;</span><br><span class="line">                          <span class="keyword">else</span></span><br><span class="line">                              hiTail.next = e;</span><br><span class="line">                          hiTail = e;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//对于第一类</span></span><br><span class="line">                  <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                      loTail.next = <span class="literal">null</span>;</span><br><span class="line">                      newTab[j] = loHead;</span><br><span class="line">                  &#125;</span><br><span class="line"><span class="comment">//对于第二类</span></span><br><span class="line">                  <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                      hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                      newTab[j + oldCap] = hiHead;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><a href="https://www.bilibili.com/video/BV18y4y1m721/?spm_id_from=333.337.search-card.all.click">红黑树快速入门</a></p>
<p>这篇文章也写得很好：</p>
<p><a href="https://baijiahao.baidu.com/s?id=1720012494395938651&wfr=spider&for=pc">算法：基于红黑树的 TreeMap</a></p>
</li>
<li><h4 id="HashIterator"><a href="#HashIterator" class="headerlink" title="HashIterator"></a>HashIterator</h4><p>注意点有二：</p>
<p>①不继承Iterator接口</p>
<p>②抽象，具体实现类为EntryIterator、KeyIterator和ValueIterator</p>
<p>③map的接口定义是没有iterator的，因此map不能通过hashiterator迭代，只能通过其vie来实现【三个具体实现类】</p>
</li>
</ol>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>哈希表+链表/红黑树+有序队列</p>
<blockquote>
<p>Hash table and linked list implementation of the Map interface, with predictable iteration order. </p>
<p>This implementation <strong>differs from HashMap</strong> in that it maintains a doubly-linked list running through all of its entries.</p>
<p>This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order).有序，顺序为元素插入的顺序</p>
<p>Note that insertion order is not affected if a key is re-inserted into the map. 当修改key的value值时，key的插入序不变</p>
<p>此实现既让hashmap变得有序，又不会像TreeMap一样有高成本。</p>
<p><u>It can be used to produce a copy of a map that has the same order as the original,</u> regardless of the original map’s implementation.</p>
<img src="/2022/10/22/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A2%E3%80%90Map%E9%83%A8%E5%88%86%E3%80%91/image-20221021202242838.png" class>

<p>这样可以保持copymap的原有顺序</p>
<p>A special constructor is provided to create a linked hash map whose order of iteration is the order in which its entries were last accessed, from least-recently accessed to most-recently (access-order). This kind of map is well-suited to building <strong>LRU caches</strong>. 可以有一个排序方式，顺序为最近最少访问-&gt;最近访问，这可以用来构建LRU cache【<em>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。</em>】</p>
<p>至于这个“access”怎么定义：</p>
<blockquote>
<p>Invoking the <strong><u>put, putIfAbsent, get, getOrDefault, compute, computeIfAbsent, computeIfPresent, or merge</u></strong> methods results in an access to the corresponding entry (assuming it exists after the invocation completes). The <strong><u>replace</u></strong> methods <u>only</u> result in an access of the entry if the value is replaced. The <strong><u>putAll</u></strong> method generates one entry access for each mapping in the specified map, in the order that key-value mappings are provided by the specified map’s entry set iterator. </p>
<p>注意没有remove</p>
</blockquote>
<p>也因此，<strong>对map视图【各个set】的访问不算access</strong>。【因为不调用任意一个上面方法】</p>
<p>可以重写 removeEldestEntry(Map.Entry) 方法，以在将新映射添加到映射时自动删除陈旧映射的策略。</p>
<img src="/2022/10/22/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A2%E3%80%90Map%E9%83%A8%E5%88%86%E3%80%91/image-20221021211657486.png" class>



<p>//1</p>
<p><strong>Iteration</strong> over the collection-views of a LinkedHashMap requires time proportional to the size of the map, <strong>regardless of its capacity</strong>.不同于hashmap，迭代时间与容量无关。</p>
<p>In access-ordered linked hash maps, merely querying the map with get is a structural modification.注意，对于access-ordered的lhm来说，**<u>get也是一个structural modification，因为可能会修改排序顺序</u>**。所以迭代时只能使用Iterator的next方法来得到结点，<u>迭代器访问不会对accessorder有影响</u>。</p>
<p>代码测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        LinkedHashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="literal">true</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Lily&quot;</span>,<span class="number">15</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Sam&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Mary&quot;</span>,<span class="number">11</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Lee&quot;</span>,<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> map.entrySet().iterator();i.hasNext();)&#123;</span><br><span class="line">            map.get(<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">            System.out.println(i.next().toString());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">	at java.util.LinkedHashMap$LinkedHashIterator.nextNode(LinkedHashMap.java:719)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>总之意思就是，LinkedHashMap的数据结构：</p>
<p>在HashMap哈希表+链表/红黑树的基础上，添加一个双端队列，该双端队列的作用是来维持内部的有序，因而开销比较大。应该只提供插入序和LRU序，其他需要用到compare的排序方法需要对某些方法（如afternodeXXX）进行重写，或者直接使用sorted map。</p>
<p>LHM的一个很特殊的地方就是，它可以实现一个LRU这样的cache结构，只需要你重载removeEldestEntry return true。还可以在LHM的基础上实现有限长度map，只需要你重载removeEldestEntry 当元素&gt;=某值时返回true。总而言之，你可以建造一个类在LHM的基础上，如果需要对map的长度有限制。</p>
<p>LHM对LRU的实现是，一旦某个结点用到了，就立刻把他移到最队尾，然后每次淘汰淘汰队首。</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt;</span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="comment">//原来只有next的</span></span><br><span class="line">        <span class="comment">//双端队列</span></span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3801124242820219131L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The head (eldest) of the doubly linked list.</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The tail (youngest) of the doubly linked list.</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//true:access顺序  false:插入顺序</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// internal utilities</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// link at the end of list</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply src&#x27;s links to dst</span></span><br><span class="line">    <span class="comment">//相当于用dst把src取代了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span><br><span class="line"><span class="params">                               LinkedHashMap.Entry&lt;K,V&gt; dst)</span> &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = dst;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = dst;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">            tail = dst;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = dst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overrides of HashMap hook methods</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reinitialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.reinitialize();</span><br><span class="line">        head = tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        linkNodeLast(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; t =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">        transferLinks(q, t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; <span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">        linkNodeLast(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">        transferLinks(q, t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于reove结点之后，之所以要存在就是因为LHM和HM的Node结构不一样，前者多了after和before</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">            tail = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用于put、各种compute、merge</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">        <span class="comment">//head是最老的结点</span></span><br><span class="line">        <span class="comment">//如果需要插入新节点同时移去旧结点</span></span><br><span class="line">        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last把用到的结点移到队尾</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                    (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after) &#123;</span><br><span class="line">            s.writeObject(e.key);</span><br><span class="line">            s.writeObject(e.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity);</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用以构造accessOrder==true的情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                         <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历构造的队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (v == value || (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            <span class="comment">//structural modification</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> defaultValue;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            <span class="comment">//structural modification</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.clear();</span><br><span class="line">        head = tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Returns true if this map should remove its eldest entry. </span></span><br><span class="line"><span class="comment">    It provides the implementor with the opportunity to remove the eldest entry each time a new one is added.</span></span><br><span class="line"><span class="comment">    This is useful if the map represents a LRU cache or other interesting implementations</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> <span class="title class_">LinkedKeySet</span>();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HashMap中这几个类都是final，所以继承不了了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedKeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; LinkedHashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedKeyIterator</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title function_">spliterator</span><span class="params">()</span>  &#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.SIZED |</span><br><span class="line">                    Spliterator.ORDERED |</span><br><span class="line">                    Spliterator.DISTINCT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> K&gt; action)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="comment">//遍历队列</span></span><br><span class="line">            <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">                action.accept(e.key);</span><br><span class="line">            <span class="comment">//保证此间代码同步</span></span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">if</span> (vs == <span class="literal">null</span>) &#123;</span><br><span class="line">            vs = <span class="keyword">new</span> <span class="title class_">LinkedValues</span>();</span><br><span class="line">            values = vs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedValues</span> <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; LinkedHashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedValueIterator</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.SIZED |</span><br><span class="line">                    Spliterator.ORDERED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">                action.accept(e.value);</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="literal">null</span> ? (entrySet = <span class="keyword">new</span> <span class="title class_">LinkedEntrySet</span>()) : es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedEntrySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; LinkedHashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedEntryIterator</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="literal">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.SIZED |</span><br><span class="line">                    Spliterator.ORDERED |</span><br><span class="line">                    Spliterator.DISTINCT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">                action.accept(e);</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map overrides</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">            action.accept(e.key, e.value);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; function)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">            e.value = function.apply(e.key, e.value);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LinkedHashIterator</span> &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class="line">        <span class="type">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">        LinkedHashIterator() &#123;</span><br><span class="line">            next = head;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            current = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LinkedHashMap.Entry&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            current = e;</span><br><span class="line">            next = e.after;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            current = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> p.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedKeyIterator</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashIterator</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextNode().getKey(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedValueIterator</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashIterator</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedEntryIterator</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashIterator</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Map.Entry&lt;K,V&gt; <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其中：-3"><a href="#其中：-3" class="headerlink" title="其中："></a>其中：</h3><ol>
<li><h4 id="迭代时间与容量无关"><a href="#迭代时间与容量无关" class="headerlink" title="迭代时间与容量无关"></a>迭代时间与容量无关</h4><p>LinkedHashMap的结构跟HashMap是一样的，也就是都baked by array。此处为什么“迭代时间与容量无关”，是因为LinkedHashMap内部维护了一个简单的链表队列【包含所有元素】，迭代的时候是对这个队列进行迭代，而不是像HashMap一样通过表迭代。</p>
<p>怪不得读源码时觉得有些地方明明不重写HashMap也可以它却重写了。原来是因为这个性能问题啊</p>
</li>
</ol>
<h2 id="SortedMap-I"><a href="#SortedMap-I" class="headerlink" title="SortedMap(I)"></a>SortedMap(I)</h2><blockquote>
<p>A Map that further provides a total ordering on its keys. </p>
<p>The map is ordered according to the <strong>natural ordering</strong> of its keys, or by a <strong>Comparator</strong> typically provided at sorted map <strong>creation</strong> time. </p>
<p>All keys inserted into a sorted map must implement the Comparable interface (or be accepted by the specified comparator). </p>
<img src="/2022/10/22/%E9%98%85%E8%AF%BBJDK%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A2%E3%80%90Map%E9%83%A8%E5%88%86%E3%80%91/image-20221022105420424.png" class>

<p>关于这部分，详细见sorted set</p>
</blockquote>
<p><strong><u>最大的特点就是可以人为定义有序并且有sub map</u></strong></p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortedMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; comparator();</span><br><span class="line">    </span><br><span class="line">    SortedMap&lt;K,V&gt; <span class="title function_">subMap</span><span class="params">(K fromKey, K toKey)</span>;</span><br><span class="line">    </span><br><span class="line">    SortedMap&lt;K,V&gt; <span class="title function_">headMap</span><span class="params">(K toKey)</span>;</span><br><span class="line">    </span><br><span class="line">    SortedMap&lt;K,V&gt; <span class="title function_">tailMap</span><span class="params">(K fromKey)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也是默认第一个是低的最后一个是高的，就跟LHM的第一个是最少使用，最后一个是最近使用一样</span></span><br><span class="line">    <span class="comment">//Returns the first (lowest) key currently in this map.</span></span><br><span class="line">    K <span class="title function_">firstKey</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Returns the last (highest) key currently in this map.</span></span><br><span class="line">    K <span class="title function_">lastKey</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NavigableMap"><a href="#NavigableMap" class="headerlink" title="NavigableMap"></a>NavigableMap</h2><blockquote>
<p>A SortedMap extended with navigation methods returning the closest matches for given search targets.</p>
<p>The performance of ascending operations and views is likely to be faster than that of descending ones. </p>
<p>submap都多加了几个参数：inclusive or exclusive</p>
<p>其entry不支持setValue，只能通过map自身的put方法改变value。因为要求前者只是map的快照</p>
</blockquote>
<p>跟navigable set差不多的定义</p>
<h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">SortedMap</span>&lt;K,V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    Map.Entry&lt;K,V&gt; <span class="title function_">lowerEntry</span><span class="params">(K key)</span>;</span><br><span class="line">    </span><br><span class="line">    K <span class="title function_">lowerKey</span><span class="params">(K key)</span>;</span><br><span class="line">    </span><br><span class="line">    Map.Entry&lt;K,V&gt; <span class="title function_">floorEntry</span><span class="params">(K key)</span>;</span><br><span class="line">    </span><br><span class="line">    K <span class="title function_">floorKey</span><span class="params">(K key)</span>;</span><br><span class="line">    </span><br><span class="line">    Map.Entry&lt;K,V&gt; <span class="title function_">ceilingEntry</span><span class="params">(K key)</span>;</span><br><span class="line">    </span><br><span class="line">    K <span class="title function_">ceilingKey</span><span class="params">(K key)</span>;</span><br><span class="line">    </span><br><span class="line">    Map.Entry&lt;K,V&gt; <span class="title function_">higherEntry</span><span class="params">(K key)</span>;</span><br><span class="line">    </span><br><span class="line">    K <span class="title function_">higherKey</span><span class="params">(K key)</span>;</span><br><span class="line">    </span><br><span class="line">    Map.Entry&lt;K,V&gt; <span class="title function_">firstEntry</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    Map.Entry&lt;K,V&gt; <span class="title function_">lastEntry</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    Map.Entry&lt;K,V&gt; <span class="title function_">pollFirstEntry</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    Map.Entry&lt;K,V&gt; <span class="title function_">pollLastEntry</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    NavigableMap&lt;K,V&gt; <span class="title function_">descendingMap</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    NavigableSet&lt;K&gt; <span class="title function_">navigableKeySet</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    NavigableSet&lt;K&gt; <span class="title function_">descendingKeySet</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    NavigableMap&lt;K,V&gt; <span class="title function_">subMap</span><span class="params">(K fromKey, <span class="type">boolean</span> fromInclusive,</span></span><br><span class="line"><span class="params">                             K toKey,   <span class="type">boolean</span> toInclusive)</span>;</span><br><span class="line">    </span><br><span class="line">    NavigableMap&lt;K,V&gt; <span class="title function_">headMap</span><span class="params">(K toKey, <span class="type">boolean</span> inclusive)</span>;</span><br><span class="line">   </span><br><span class="line">    NavigableMap&lt;K,V&gt; <span class="title function_">tailMap</span><span class="params">(K fromKey, <span class="type">boolean</span> inclusive)</span>;</span><br><span class="line">    </span><br><span class="line">    SortedMap&lt;K,V&gt; <span class="title function_">subMap</span><span class="params">(K fromKey, K toKey)</span>;</span><br><span class="line">    </span><br><span class="line">    SortedMap&lt;K,V&gt; <span class="title function_">headMap</span><span class="params">(K toKey)</span>;</span><br><span class="line">    </span><br><span class="line">    SortedMap&lt;K,V&gt; <span class="title function_">tailMap</span><span class="params">(K fromKey)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><blockquote>
<p>NavigableMap的红黑树实现</p>
<p>key不允许空，空会抛出异常</p>
<p>Note that this implementation is not synchronized. </p>
<p>fail-fast</p>
<p>All Map.Entry pairs returned by methods in this class and its views represent snapshots of mappings at the time they were produced. They do not support the Entry.setValue method. (Note however that it is possible to change mappings in the associated map using put.)【navigable map的性质】</p>
</blockquote>
<p>具体代码就不看了</p>
<h2 id="对Collection和Map的总结"><a href="#对Collection和Map的总结" class="headerlink" title="对Collection和Map的总结"></a>对Collection和Map的总结</h2><ol>
<li><h3 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h3><blockquote>
<p>The iterators returned by all of this class’s “collection view methods” are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator’s own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.</p>
<p>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.</p>
</blockquote>
<p>都使用了modcount进行并发检查，都具有fail-fast的特点（关于此的详细解说，可见AbstractList第四点和List第二点），因而只允许在迭代中使用迭代器的remove方法进行结构性改变。【注意：对于LinkedHashMap中access order排序，get方法也是structural modification，因而也只能通过迭代器的next方法获取元素】</p>
</li>
<li><h3 id="not-synchronized"><a href="#not-synchronized" class="headerlink" title="not synchronized"></a>not synchronized</h3><p>上面介绍到的几个类，除了Vector外，都是线程不同步的。可以用此方式让其线程同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(...));</span><br></pre></td></tr></table></figure></li>
<li><h3 id="是否允许null"><a href="#是否允许null" class="headerlink" title="是否允许null"></a>是否允许null</h3><p>除了TreeSet、TreeMap、ArrayDeque之外，都是允许空（key/value）的</p>
</li>
<li><h3 id="是否有序"><a href="#是否有序" class="headerlink" title="是否有序"></a>是否有序</h3><p>List都是插入序，HashSet无需，HashMap也无序（但其实算是有内部桶序的），LinkedHashMap有插入序和LRU序（依靠内部增加简单队列的消耗），TreeSet有序，TreeMap有序【这俩靠红黑树的遍历顺序（二叉搜索树嘛）】。</p>
</li>
<li><h3 id="实现的约定接口"><a href="#实现的约定接口" class="headerlink" title="实现的约定接口"></a>实现的约定接口</h3><p>都Cloneable，Serializable</p>
<p>ArrayList/Vector：RandomAccess</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6</title>
    <url>/2023/01/10/xv6/</url>
    <content><![CDATA[<blockquote>
<p>总耗时：120h  约27天</p>
<p>部分地方的翻译和表格来源参考：<a href="http://xv6.dgs.zone/">xv6指导书翻译</a></p>
<p>实验官网：<a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">6.S081</a></p>
<p>记得结合书本的笔记阅读，这里只记录了一点看心情觉得想记就记的东西以及实验感想。</p>
<p>笔记的结构【以第一章Operating system interface为例】：</p>
<p><img src="/2023/01/10/xv6/image-20230124235649128.png" alt="image-20230124235649128"></p>
</blockquote>
<h3 id="Operating-system-interface"><a href="#Operating-system-interface" class="headerlink" title="Operating system interface"></a><a href="https://xiunianjun.github.io/2023/01/10/xv6$chap1">Operating system interface</a></h3><h3 id="Operating-system-oganization"><a href="#Operating-system-oganization" class="headerlink" title="Operating system oganization"></a><a href="https://xiunianjun.github.io/2023/01/10/xv6$chap2">Operating system oganization</a></h3><h3 id="Page-tables"><a href="#Page-tables" class="headerlink" title="Page tables"></a><a href="https://xiunianjun.github.io/2023/01/10/xv6$chap3">Page tables</a></h3><h3 id="Traps-and-system-calls"><a href="#Traps-and-system-calls" class="headerlink" title="Traps and system calls"></a><a href="https://xiunianjun.github.io/2023/01/10/xv6$chap4">Traps and system calls</a></h3><h3 id="Interrupts-and-device-drivers"><a href="#Interrupts-and-device-drivers" class="headerlink" title="Interrupts and device drivers"></a><a href="https://xiunianjun.github.io/2023/01/10/xv6$chap5">Interrupts and device drivers</a></h3><h3 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a><a href="https://xiunianjun.github.io/2023/01/10/xv6$chap6">Locking</a></h3><h3 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a><a href="https://xiunianjun.github.io/2023/01/10/xv6$chap7">Scheduling</a></h3><h3 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a><a href="https://xiunianjun.github.io/2023/01/10/xv6$chap8">File system</a></h3><h3 id="其他的对实验未涉及的思考"><a href="#其他的对实验未涉及的思考" class="headerlink" title="其他的对实验未涉及的思考"></a><a href="https://xiunianjun.github.io/2023/01/10/xv6$chap9">其他的对实验未涉及的思考</a></h3>]]></content>
      <tags>
        <tag>labs</tag>
      </tags>
  </entry>
  <entry>
    <title>哈工大操作系统实验</title>
    <url>/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.lanqiao.cn/courses/115">实验入口</a><br>主要参考文章<br><a href="https://www.dotcpp.com/course/461">lseek()函数:用于移动打开文件的指针</a><br><a href="https://cloud.tencent.com/developer/article/1425052">linux系统调用之write源码解析（基于linux0.11）</a><br><a href="https://blog.csdn.net/yuanren201/article/details/103207910">get_fs_bytes解析</a><br><a href="https://blog.csdn.net/to_free/article/details/115187981">VIM与系统剪贴板的复制粘贴</a><br><a href="https://zhuanlan.zhihu.com/p/428283092">操作系统实验六 信号量的实现和应用(哈工大李治军)</a><br><a href="https://blog.csdn.net/weixin_43987915/article/details/108949942">哈工大操作系统实验6 信号量的实现 pc.c 编译时报错 对‘sem_open‘未定义的引用</a><br><a href="https://blog.csdn.net/qq_59804059/article/details/120634348">Linux 文件编程 open函数</a><br><a href="https://blog.csdn.net/qq_42518941/article/details/119757885">哈工大-操作系统-HitOSlab-李治军-实验5-信号量的实现和应用</a></p>
</blockquote>
<h1 id="地址映射与共享"><a href="#地址映射与共享" class="headerlink" title="地址映射与共享"></a>地址映射与共享</h1><blockquote>
<p>参考文章</p>
<p><a href="https://www.cnblogs.com/52php/p/5861372.html">Linux进程间通信（六）：共享内存 shmget()、shmat()、shmdt()、shmctl() </a></p>
<p><a href="https://blog.csdn.net/leoabcd12/article/details/121581308">操作系统实验七 地址映射与共享(哈工大李治军)</a></p>
</blockquote>
<h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><h3 id="要点1-共享内存"><a href="#要点1-共享内存" class="headerlink" title="要点1 共享内存"></a>要点1 共享内存</h3><p>顾名思义，共享内存就是<u>允许两个不相关的进程访问同一个逻辑内存</u>。共享内存是在两个正在运行的进程之间<u>共享和传递数据</u>的一种非常有效的方式。不同进程之间共享的内存通常安排为<u>同一段物理内存</u>。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p>
<p>注：共享内存并未提供同步机制，所以我们需要用信号量来实现同步。</p>
<p>Linux提供了一组接口用于使用共享内存，它们声明在头文件 sys/shm.h 中。</p>
<h4 id="1-shmget"><a href="#1-shmget" class="headerlink" title="1.shmget"></a>1.shmget</h4><p>程序先通过调用shmget()函数并提供一个键，再由系统生成一个相应的共享内存标识符（shmget()函数的返回值）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p>key为共享内存段名字，size为大小，shmflg是权限标志</p>
<p>注：</p>
<p>① key：<u><strong>非0整数</strong></u>，共享内存段的命名</p>
<p>② shmflag：作用与open函数的mode参数一样，比如IPC_CREAT，或连接</p>
<p>共享内存的权限标志与文件的读写权限一样，举例来说，0644表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存</p>
<p>③ return：成功时返回一个与key相关的<u>共享内存标识符</u>（非负整数）。调用失败返回-1</p>
<p>不相关的进程可以<u>返回值（共享内存标识符）访问同一共享内存</u>。</p>
<h4 id="2-shmat"><a href="#2-shmat" class="headerlink" title="2.shmat"></a>2.shmat</h4><p>第一次创建完共享内存时，它还不能被任何进程访问，需要shmat启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span> *shm_addr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p>① shm_id：共享内存标识符</p>
<p>② shm_addr：指定共享内存连接到当前进程中的地址位置，通常为空，表示<u>让系统来选择</u>共享内存的地址</p>
<p>③ shm_flg：一组标志位，通常为0</p>
<p>④ return：成功时返回一个<u><strong>指向共享内存第一个字节</strong></u>的指针，失败返回-1</p>
<h4 id="3-shmdt"><a href="#3-shmdt" class="headerlink" title="3.shmdt"></a>3.shmdt</h4><p>用于将共享内存从当前进程中分离，使该共享内存对当前进程不再可用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure>

<p>① shmaddr：shmat返回的共享内存指针</p>
<p>② return：成功0，失败1</p>
<h4 id="4-shmctl"><a href="#4-shmctl" class="headerlink" title="4.shmctl"></a>4.shmctl</h4><p>用来控制共享内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>① shm_id：共享内存标识符</p>
<p>② command：要采取的操作，它可以取下面的三个值 ：</p>
<ul>
<li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。</li>
<li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值</li>
<li>IPC_RMID：删除共享内存段</li>
</ul>
<p>③ buf：结构指针</p>
<p>shmid_ds结构 至少包括以下成员：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uid_t</span> shm_perm.uid;</span><br><span class="line">    <span class="type">uid_t</span> shm_perm.gid;</span><br><span class="line">    <span class="type">mode_t</span> shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="实验1-在Ubuntu下编写程序“基于共享内存的生产者消费者模型”"><a href="#实验1-在Ubuntu下编写程序“基于共享内存的生产者消费者模型”" class="headerlink" title="实验1 在Ubuntu下编写程序“基于共享内存的生产者消费者模型”"></a>实验1 在Ubuntu下编写程序“基于共享内存的生产者消费者模型”</h2><blockquote>
<p>本项实验在 Ubuntu 下完成，与信号量实验中的 <code>pc.c</code> 的功能要求基本一致，仅有两点不同：</p>
<ul>
<li>不用文件做缓冲区，而是使用共享内存；</li>
<li>生产者和消费者分别是不同的程序。生产者是 producer.c，消费者是 consumer.c。两个程序都是单进程的，通过信号量和缓冲区进行通信。</li>
</ul>
<p>Linux 下，可以通过 <code>shmget()</code> 和 <code>shmat()</code> 两个系统调用使用共享内存。</p>
</blockquote>
<p>直接上代码。感觉比文件操作简单多了2333</p>
<p>consumer.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span>* empty;</span><br><span class="line"><span class="type">sem_t</span>* full;</span><br><span class="line"><span class="type">sem_t</span>* mutex;</span><br><span class="line"><span class="type">char</span>* p;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Consumer</span><span class="params">()</span>&#123;</span><br><span class="line">	sem_wait(full);</span><br><span class="line">	sem_wait(mutex);</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="comment">//there read s from buffer...</span></span><br><span class="line">	<span class="built_in">memcpy</span>(s,p,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">4</span>);</span><br><span class="line">	p+=<span class="number">4</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d : %s&quot;</span>,getpid(),s);</span><br><span class="line">	sem_post(mutex);</span><br><span class="line">	sem_post(empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	empty=sem_open(<span class="string">&quot;empty&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">10</span>);</span><br><span class="line">	full=sem_open(<span class="string">&quot;full&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">0</span>);</span><br><span class="line">	mutex=sem_open(<span class="string">&quot;mutex&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> shm_id=shmget(<span class="number">521</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">4</span>*<span class="number">600</span>,<span class="number">0644</span>|IPC_CREAT);</span><br><span class="line">	<span class="type">char</span>* shm=(<span class="type">char</span>*)shmat(shm_id,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	p=shm;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">500</span>;</span><br><span class="line">	<span class="keyword">while</span>(cnt--)&#123;</span><br><span class="line">		Consumer();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shmdt(shm);</span><br><span class="line">	shmctl(shm_id,IPC_RMID,<span class="number">0</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;mutex&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;full&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;empty&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>producer.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span>* empty;</span><br><span class="line"><span class="type">sem_t</span>* full;</span><br><span class="line"><span class="type">sem_t</span>* mutex;</span><br><span class="line"><span class="type">char</span>* p;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Producer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">500</span>;i++)&#123;</span><br><span class="line">		sem_wait(empty);</span><br><span class="line">		sem_wait(mutex);</span><br><span class="line">		<span class="built_in">sprintf</span>(s,<span class="string">&quot;%03d\n&quot;</span>,i);</span><br><span class="line">		<span class="comment">//there write s into buffer...</span></span><br><span class="line">		<span class="built_in">memcpy</span>(p,s,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">4</span>);</span><br><span class="line">		p+=<span class="number">4</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Write into success!%s\n&quot;</span>,s);</span><br><span class="line">		sem_post(mutex);</span><br><span class="line">		sem_post(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	empty=sem_open(<span class="string">&quot;empty&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">10</span>);</span><br><span class="line">	full=sem_open(<span class="string">&quot;full&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">0</span>);</span><br><span class="line">	mutex=sem_open(<span class="string">&quot;mutex&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> shm_id=shmget(<span class="number">521</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">4</span>*<span class="number">600</span>,<span class="number">0644</span>|IPC_CREAT);</span><br><span class="line">	<span class="type">char</span>* shm=(<span class="type">char</span>*)shmat(shm_id,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	p=shm;</span><br><span class="line"></span><br><span class="line">	Producer();</span><br><span class="line"></span><br><span class="line">	shmdt(shm);</span><br><span class="line">	shmctl(shm_id,IPC_RMID,<span class="number">0</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;mutex&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;full&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;empty&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -o producer producer.c -pthread</span><br><span class="line">gcc -o consumer consumer.c -pthread</span><br><span class="line">./producer &gt; p.txt &amp;</span><br><span class="line">./consumer &gt; c.txt</span><br></pre></td></tr></table></figure>

<p>运行结果c.txt（仅展示部分）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">27696 : 000</span><br><span class="line">27696 : 001</span><br><span class="line">27696 : 002</span><br><span class="line">27696 : 003</span><br><span class="line">27696 : 004</span><br><span class="line">27696 : 005</span><br><span class="line">27696 : 006</span><br><span class="line">27696 : 007</span><br><span class="line">27696 : 008</span><br><span class="line">27696 : 009</span><br><span class="line">27696 : 010</span><br><span class="line">27696 : 011</span><br><span class="line">27696 : 012</span><br></pre></td></tr></table></figure>



<h2 id="实验2-在Linux0-11实现共享内存"><a href="#实验2-在Linux0-11实现共享内存" class="headerlink" title="实验2 在Linux0.11实现共享内存"></a>实验2 在Linux0.11实现共享内存</h2><blockquote>
<p>进程之间可以通过页共享进行通信，被共享的页叫做共享内存，结构如下图所示：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/userid19614labid573time1424086247964.png" class> 

<p>本部分实验内容是在 Linux 0.11 上实现上述页面共享，并将上一部分实现的 producer.c 和 consumer.c 移植过来，验证页面共享的有效性。</p>
</blockquote>
<blockquote>
<p>具体要求在 <code>mm/shm.c</code> 中实现 <code>shmget()</code> 和 <code>shmat()</code> 两个系统调用。它们能支持 <code>producer.c</code> 和 <code>consumer.c</code> 的运行即可，不需要完整地实现 POSIX 所规定的功能。</p>
<ul>
<li>shmget()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p><code>shmget()</code> 会新建/打开一页内存，并返回该页共享内存的 shmid（该块共享内存在操作系统内部的 id）。</p>
<p>所有使用同一块共享内存的进程都要使用相同的 key 参数。</p>
<p>如果 key 所对应的共享内存已经建立，则直接返回 <code>shmid</code>。如果 size 超过一页内存的大小，返回 <code>-1</code>，并置 <code>errno</code> 为 <code>EINVAL</code>。如果系统无空闲内存，返回 -1，并置 <code>errno</code> 为 <code>ENOMEM</code>。</p>
<p><code>shmflg</code> 参数可忽略。</p>
<ul>
<li>shmat()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p><code>shmat()</code> 会将 <code>shmid</code> 指定的共享页面映射到当前进程的虚拟地址空间中，并将其首地址返回。</p>
<p>如果 <code>shmid</code> 非法，返回 <code>-1</code>，并置 <code>errno</code> 为 <code>EINVAL</code>。</p>
<p><code>shmaddr</code> 和 <code>shmflg</code> 参数可忽略。</p>
</blockquote>
<p>思路：</p>
<p>1.shmget：由其论述，我们可以知道，我们需要建立一个映射表，其中成员为结构体({key_t key,size_t size,unsigned long page})，每次只需查找映射表，如果有对应key则返回下标，如果没有则新建页表，填入映射体，再返回对应下标。</p>
<p>以下为了图省事，对映射表的实现进行了简化，把key直接当做int类型，作为映射表下标，映射表成员为page，unsigned long。</p>
<p>2.shmat：</p>
<p>首先由指导书的提示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立线性地址和物理地址的映射</span></span><br><span class="line">put_page(tmp, address);</span><br></pre></td></tr></table></figure>

<p>我们知道在shmat中，要建立shmget得到的共享物理页面与其虚拟地址的映射，就需要使用这个put_page函数。</p>
<p>但是put_page函数的参数为页和address。页就是我们的shm_map[key]，address=虚拟地址+段基址。那么如何得到虚拟地址呢？</p>
<p>通过指导书的提示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">code_base = get_base(current-&gt;ldt[<span class="number">1</span>]);</span><br><span class="line">data_base = code_base;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据段基址 = 代码段基址</span></span><br><span class="line">set_base(current-&gt;ldt[<span class="number">1</span>],code_base);</span><br><span class="line">set_limit(current-&gt;ldt[<span class="number">1</span>],code_limit);</span><br><span class="line">set_base(current-&gt;ldt[<span class="number">2</span>],data_base);</span><br><span class="line">set_limit(current-&gt;ldt[<span class="number">2</span>],data_limit);</span><br><span class="line">__asm__(<span class="string">&quot;pushl $0x17\n\tpop %%fs&quot;</span>:: );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数据段的末尾开始</span></span><br><span class="line">data_base += data_limit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向前处理</span></span><br><span class="line"><span class="keyword">for</span> (i=MAX_ARG_PAGES<span class="number">-1</span> ; i&gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">    <span class="comment">// 一次处理一页</span></span><br><span class="line">    data_base -= PAGE_SIZE;</span><br><span class="line">    <span class="comment">// 建立线性地址到物理页的映射</span></span><br><span class="line">    <span class="keyword">if</span> (page[i]) put_page(page[i],data_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再结合所学知识，我们可以知道几点：</p>
<p>① 数据段的基址可由current-&gt;ldt[2]给出 ② address=虚拟地址+段基址 ③ 我们需要分配给当前共享内存一段空闲的虚拟地址段</p>
<p>则该小段空闲数据段的虚拟地址就是我们的return值，address=return+data_base。</p>
<p>问题就转化成了如何获取一段空闲数据段。</p>
<p>我们由下图：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/d3d839723b44d3e6a9407cbbd684d976.png" class> 

<p>可知，brk指针指向堆区顶部，即空闲堆的起始位置。因而我们可以用这段空间作为我们要的空闲数据段，当前brk即为虚拟地址。</p>
<p>我们的页有PAGE_SIZE那么大，因而自然也就要用PAGE_SIZE那么大的空闲数据段了。</p>
<p>解说完毕，以下上代码~</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> shm_map[<span class="number">600</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_shmget</span><span class="params">(<span class="type">int</span> key,<span class="type">size_t</span> size,<span class="type">int</span> shmflg)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(key&lt;<span class="number">0</span>||key&gt;=<span class="number">600</span>)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(shm_map[key]!=<span class="number">0</span>)	<span class="keyword">return</span> key;</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tmp=get_free_page();</span><br><span class="line">	shm_map[key]=tmp;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">sys_shmat</span><span class="params">(<span class="type">int</span> shmid,<span class="type">const</span> <span class="type">void</span>* shmaddr,<span class="type">int</span> shmflg)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(shmid&lt;<span class="number">0</span>||shmid&gt;=<span class="number">600</span>)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> page=shm_map[shmid];</span><br><span class="line">	<span class="comment">//得到数据段的基址 </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data_base=get_base(current-&gt;ldt[<span class="number">2</span>]);</span><br><span class="line">	<span class="comment">//brk指针指向空闲数据段的开始 </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> brk=current-&gt;brk+data_base;</span><br><span class="line">	current-&gt;brk+=PAGE_SIZE;</span><br><span class="line">	<span class="comment">//建立内存映射 </span></span><br><span class="line">	put_page(page,brk);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*)(brk-data_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><h2 id="任务一-实现pc-c"><a href="#任务一-实现pc-c" class="headerlink" title="任务一  实现pc.c"></a>任务一  实现pc.c</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 Ubuntu 上编写应用程序“pc.c”，解决经典的生产者—消费者问题，完成下面的功能：</span><br><span class="line"></span><br><span class="line">1.建立一个生产者进程，N 个消费者进程（N&gt;1）；</span><br><span class="line">2.用文件建立一个共享缓冲区；</span><br><span class="line">3.生产者进程依次向缓冲区写入整数 0,1,2,...,M，M&gt;=500；</span><br><span class="line">4.消费者进程从缓冲区读数，每次读一个，并将读出的数字从缓冲区删除，然后将本进程 ID 和 + 数字输出到标准输出；</span><br><span class="line">5.缓冲区同时最多只能保存 10 个数。</span><br><span class="line">其中 ID 的顺序会有较大变化，但冒号后的数字一定是从 0 开始递增加一的。</span><br></pre></td></tr></table></figure>

<p>先附上我的代码吧【注：我没做到从缓冲区删除，但其他都完成了】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* filename=<span class="string">&quot;buffer.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span>* empty;</span><br><span class="line"><span class="type">sem_t</span>* full;</span><br><span class="line"><span class="type">sem_t</span>* mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Producer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">500</span>;i++)&#123;</span><br><span class="line">		sem_wait(empty);</span><br><span class="line">		sem_wait(mutex);</span><br><span class="line">		<span class="type">int</span> tmp=lseek(fd,<span class="number">0</span>,SEEK_CUR);</span><br><span class="line">		lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">		<span class="built_in">sprintf</span>(s,<span class="string">&quot;%03d\n&quot;</span>,i);</span><br><span class="line">		write(fd,s,<span class="number">4</span>);</span><br><span class="line">		lseek(fd,tmp,SEEK_SET);</span><br><span class="line">		sem_post(mutex);</span><br><span class="line">		sem_post(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Consumer</span><span class="params">()</span>&#123;</span><br><span class="line">	sem_wait(full);</span><br><span class="line">	sem_wait(mutex);</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	read(fd,s,<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d : %s&quot;</span>,getpid(),s);</span><br><span class="line">	sem_post(mutex);</span><br><span class="line">	sem_post(empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sem_unlink(<span class="string">&quot;empty&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;full&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;mutex&quot;</span>);</span><br><span class="line">	fd=open(filename,O_RDWR|O_CREAT);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,errno);	</span><br><span class="line">	empty=sem_open(<span class="string">&quot;empty&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">10</span>);</span><br><span class="line">	full=sem_open(<span class="string">&quot;full&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">0</span>);</span><br><span class="line">	mutex=sem_open(<span class="string">&quot;mutex&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">		Producer();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)	Consumer();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20220928205823674.png" class> 

<h3 id="要点1-系统调用的IO读写"><a href="#要点1-系统调用的IO读写" class="headerlink" title="要点1 系统调用的IO读写"></a>要点1 系统调用的IO读写</h3><p>这部分耗费了我海量时间，主要原因还是因为我没有好好学就直接上手写导致很多地方都因为不清楚而寄了。。。</p>
<p><u>先大致讲讲文件读写的原理吧。打开一个文件作为数据流，有一个文件指针，该指针指向的地方就是之后读写开始的地方，读写还有lseek都可以让指针移动。</u></p>
<p>再放个各个系统调用的签名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@param 文件名 模式</span><br><span class="line"></span><br><span class="line">@<span class="keyword">return</span> 所需文件描述符</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> open(<span class="type">char</span>* filename,<span class="type">int</span> flag);</span><br></pre></td></tr></table></figure>

<p>其中flag的可能取值：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20220928201814131.png" class> 

<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20220928201821476.png" class> 

<p>如果想要多个方式并行，则可以用|连接。【联系一下原理，这大概是用了标志位吧，每个标志只有一位是1】</p>
<p><strong>这部分踩过的坑：</strong></p>
<p>① 选择O_CREAT，如果文件已经存在，居然是会报错？【表现为errno=13，还会输出一堆奇怪的东西】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@param 文件描述符  写入字符串  写入长度</span><br><span class="line">@<span class="keyword">return</span> 报错信息</span><br><span class="line"><span class="type">int</span> read(<span class="type">int</span> fd,<span class="type">char</span>* <span class="built_in">string</span>,<span class="type">size_t</span> size);</span><br></pre></td></tr></table></figure>

<p>read会读出size个字节然后存进string里面，同时也会移动文件指针向前size个字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@param 文件描述符  写入字符串  写入长度</span><br><span class="line">@<span class="keyword">return</span> 报错信息</span><br><span class="line"><span class="type">int</span> write(<span class="type">int</span> fd,<span class="type">char</span>* <span class="built_in">string</span>,<span class="type">size_t</span> size);</span><br></pre></td></tr></table></figure>

<p>基本同write。</p>
<p><strong>这部分踩过的坑：</strong></p>
<p>write(fd,NULL,0)  ——合法</p>
<p>write(fd,NULL,a),a&gt;0  ——寄！</p>
<p>这还是因为write的具体实现了。</p>
<p>write里面有个判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd,<span class="type">char</span> *buf,<span class="type">int</span> count)</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">if</span>(!count)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">while</span>(c--&gt;<span class="number">0</span>)	*(p++)=get_fs_byte(buf++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而get_fs_byte：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20220928204140436.png" class> 

<p>确实感觉空的话挺危险的【】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@param 文件描述符</span><br><span class="line">@<span class="keyword">return</span> 报错信息</span><br><span class="line"><span class="type">int</span> close(fd);</span><br></pre></td></tr></table></figure>

<p>这个没啥好说的，记得关就是了</p>
<h3 id="要点2-信号量的调用"><a href="#要点2-信号量的调用" class="headerlink" title="要点2  信号量的调用"></a>要点2  信号量的调用</h3><p>这方面看linux自带的man文档就行，写得很清楚。</p>
<p>输入指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man sem_overview</span><br></pre></td></tr></table></figure>

<p><strong>这部分踩过的坑：</strong></p>
<p>千万注意最后不使用信号量时要释放，使用sem_unlink。不然最后的输出结果会非常诡异。</p>
<h3 id="要点3-编写程序"><a href="#要点3-编写程序" class="headerlink" title="要点3 编写程序"></a>要点3 编写程序</h3><p>以上差不多就是涉及到的需要自己了解的课外知识点了，接下来就需要自己编写程序。</p>
<p>总体框架就按它给的差不多：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Producer()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 空闲缓存资源</span></span><br><span class="line">    P(Empty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥信号量</span></span><br><span class="line">    P(Mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产并放一个item进缓冲区</span></span><br><span class="line">    </span><br><span class="line">    V(Mutex);</span><br><span class="line">    V(Full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer()</span><br><span class="line">&#123;</span><br><span class="line">    P(Full);</span><br><span class="line">    P(Mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从缓存区取出一个赋值给item并消费;</span></span><br><span class="line">    </span><br><span class="line">    V(Mutex);</span><br><span class="line">    V(Empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个点挺有趣的，就是它实际上把文件指针也看成一种资源了，因此也需要在同步段对其进行更新。</p>
<p>printf的stdout也是资源。</p>
<p>故以上两者都只能在锁内同步段进行更新。</p>
<p>main函数就照本宣科地用fork建立子进程就行。</p>
<h2 id="任务二-自己实现信号量"><a href="#任务二-自己实现信号量" class="headerlink" title="任务二 自己实现信号量"></a>任务二 自己实现信号量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux 在 0.11 版还没有实现信号量，Linus 把这件富有挑战的工作留给了你。如果能实现一套山寨版的完全符合 POSIX 规范的信号量，无疑是很有成就感的。但时间暂时不允许我们这么做，所以先弄一套缩水版的类 POSIX 信号量，它的函数原型和标准并不完全相同，而且只包含如下系统调用：</span><br><span class="line">sem_t *sem_open(const char *name, unsigned int value);</span><br><span class="line">int sem_wait(sem_t *sem);</span><br><span class="line">int sem_post(sem_t *sem);</span><br><span class="line">int sem_unlink(const char *name);</span><br><span class="line"></span><br><span class="line">sem_open() 的功能是创建一个信号量，或打开一个已经存在的信号量。</span><br><span class="line">sem_t 是信号量类型，根据实现的需要自定义。</span><br><span class="line">name 是信号量的名字。不同的进程可以通过提供同样的 name 而共享同一个信号量。如果该信号量不存在，就创建新的名为 name 的信号量；如果存在，就打开已经存在的名为 name 的信号量。</span><br><span class="line">value 是信号量的初值，仅当新建信号量时，此参数才有效，其余情况下它被忽略。当成功时，返回值是该信号量的唯一标识（比如，在内核的地址、ID 等），由另两个系统调用使用。如失败，返回值是 NULL。</span><br><span class="line">sem_wait() 就是信号量的 P 原子操作。如果继续运行的条件不满足，则令调用进程等待在信号量 sem 上。返回 0 表示成功，返回 -1 表示失败。</span><br><span class="line">sem_post() 就是信号量的 V 原子操作。如果有等待 sem 的进程，它会唤醒其中的一个。返回 0 表示成功，返回 -1 表示失败。</span><br><span class="line">sem_unlink() 的功能是删除名为 name 的信号量。返回 0 表示成功，返回 -1 表示失败。</span><br><span class="line">在 kernel 目录下新建 sem.c 文件实现如上功能。然后将 pc.c 从 Ubuntu 移植到 0.11 下，测试自己实现的信号量。</span><br></pre></td></tr></table></figure>

<p>由于不小心写完的实验代码被销毁了，因此差不多参考的是这篇文章【<a href="https://blog.csdn.net/qq_42518941/article/details/119757885">戳这里</a>】，修改了一些地方，构成了我的回忆版代码。</p>
<h3 id="要点1-系统调用修改"><a href="#要点1-系统调用修改" class="headerlink" title="要点1 系统调用修改"></a>要点1 系统调用修改</h3><p>详见文章，写得很清楚。</p>
<h3 id="要点2-sem-c文件的编写"><a href="#要点2-sem-c文件的编写" class="headerlink" title="要点2  sem.c文件的编写"></a>要点2  sem.c文件的编写</h3><p>sem_t定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义的信号量数据结构: */</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> _SEM_H_</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _SEM_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">semaphore_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];<span class="comment">/* 信号量的名称 */</span></span><br><span class="line">	<span class="type">int</span> value;    <span class="comment">/* 信号量的值 */</span></span><br><span class="line">    <span class="type">int</span> active;<span class="comment">//我自己加的，是对象池思想，感觉写得还挺好的2333</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tast_struct</span> *<span class="title">queue</span>;</span><span class="comment">/* 指向阻塞队列的指针 */</span></span><br><span class="line">&#125; <span class="type">sem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sem.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/segment.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_LIST_LENGTH 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量表</span></span><br><span class="line"><span class="type">sem_t</span> sem_list[SEM_LIST_LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">str_cmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1,<span class="type">const</span> <span class="type">char</span>* s2)</span>&#123;</span><br><span class="line">	<span class="type">char</span>* p=s1;</span><br><span class="line">	<span class="type">int</span> i,len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(*p!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">		p++;</span><br><span class="line">		len1++;</span><br><span class="line">	&#125;</span><br><span class="line">	p=s2;</span><br><span class="line">	<span class="keyword">while</span>(*p!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">		p++;</span><br><span class="line">		len2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(len1!=len2)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s1[i]!=s2[i])	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sem_open</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sem_open()的功能是创建一个信号量，或打开一个已经存在的信号量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> *<span class="title function_">sys_sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name,<span class="type">unsigned</span> <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (name == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 首先将信号量的名称赋值到新建的缓冲区中 */</span></span><br><span class="line">    <span class="type">char</span> nbuf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	nbuf[i] = get_fs_byte(name+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 然后开始遍历已有的信号量数组，如果有该名字的信号量，直接返回信号量的地址 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SEM_LIST_LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sem_list[i].active==<span class="number">1</span>&amp;&amp;!str_cmp(sem_list[i].name, nbuf))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;sem_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果找不到信号量，就开始新建一个名字为name的信号量 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SEM_LIST_LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sem_list[i].active==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(sem_list[i].name, nbuf);</span><br><span class="line">    		sem_list[i].value = value;</span><br><span class="line">            sem_list[i].active=<span class="number">1</span>;</span><br><span class="line">   			sem_list[i].<span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> &amp;sem_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表已满</span></span><br><span class="line">    errno = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>sem_wait</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> sem_wait()就是信号量的P原子操作。</span></span><br><span class="line"><span class="comment"> 如果继续运行的条件不满足，则令调用进程等待在信号量sem上。</span></span><br><span class="line"><span class="comment"> 返回0表示成功，返回-1表示失败。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sem_wait</span><span class="params">(<span class="type">sem_t</span> * sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 判断:如果传入的信号量是无效信号量，P操作失败，返回-1 */</span></span><br><span class="line">    <span class="keyword">if</span>(sem == <span class="literal">NULL</span> || sem &lt; sem_list || sem &gt; sem_list + SEM_LIST_LENGTH)</span><br><span class="line">    &#123;</span><br><span class="line">        errno=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 关中断 */</span></span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">while</span>(sem-&gt;value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep_on(&amp;(sem-&gt;<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    sem-&gt;value--; </span><br><span class="line">    <span class="comment">/* 开中断 */</span></span><br><span class="line">    sti();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sem_post</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sem_post()就是信号量的V原子操作。</span></span><br><span class="line"><span class="comment">如果有等待sem的进程，它会唤醒其中的一个。</span></span><br><span class="line"><span class="comment">返回0表示成功，返回-1表示失败。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sem_post</span><span class="params">(<span class="type">sem_t</span> * sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 判断:如果传入的信号量是无效信号量，V操作失败，返回-1 */</span></span><br><span class="line">    <span class="keyword">if</span>(sem == <span class="literal">NULL</span> || sem &lt; sem_list || sem &gt; sem_list + SEM_LIST_LENGTH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 关中断 */</span></span><br><span class="line">    cli();</span><br><span class="line">    sem-&gt;value++;</span><br><span class="line">    <span class="comment">/* 如果有等待sem的进程，它会唤醒其中的一个。 */</span></span><br><span class="line">    <span class="keyword">if</span>(sem-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	wake_up(&amp;(sem-&gt;<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 开中断 */</span></span><br><span class="line">    sti();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sem_unlink</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sem_unlink()的功能是删除名为name的信号量。</span></span><br><span class="line"><span class="comment">返回0表示成功，返回-1表示失败。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sem_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        errno = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 首先将信号量的名称赋值到新建的缓冲区中 */</span></span><br><span class="line">    <span class="type">char</span> nbuf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nbuf[i] = get_fs_byte(name + i);</span><br><span class="line">        <span class="keyword">if</span> (nbuf[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SEM_LIST_LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str_cmp(sem_list[i].name, nbuf)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_list[i].active=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>pc.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">sem_t</span> *, sem_open, <span class="type">const</span> <span class="type">char</span> *, name, <span class="type">unsigned</span> <span class="type">int</span>, value);</span><br><span class="line">_syscall1(<span class="type">int</span>, sem_wait, <span class="type">sem_t</span> *, sem);</span><br><span class="line">_syscall1(<span class="type">int</span>, sem_post, <span class="type">sem_t</span> *, sem);</span><br><span class="line">_syscall1(<span class="type">int</span>, sem_unlink, <span class="type">const</span> <span class="type">char</span> *, name);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* filename=<span class="string">&quot;buffer.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span>* empty;</span><br><span class="line"><span class="type">sem_t</span>* full;</span><br><span class="line"><span class="type">sem_t</span>* mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Producer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">500</span>;i++)&#123;</span><br><span class="line">		sem_wait(empty);</span><br><span class="line">		sem_wait(mutex);</span><br><span class="line">		tmp=lseek(fd,<span class="number">0</span>,SEEK_CUR);</span><br><span class="line">		lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">		<span class="built_in">sprintf</span>(s,<span class="string">&quot;%03d\n&quot;</span>,i);</span><br><span class="line">		write(fd,s,<span class="number">4</span>);</span><br><span class="line">		lseek(fd,tmp,SEEK_SET);</span><br><span class="line">		sem_post(mutex);</span><br><span class="line">		sem_post(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Consumer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	sem_wait(full);</span><br><span class="line">	sem_wait(mutex);</span><br><span class="line">	read(fd,s,<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d : %s&quot;</span>,getpid(),s);</span><br><span class="line">	sem_post(mutex);</span><br><span class="line">	sem_post(empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	fd=open(filename,O_RDWR|O_CREAT);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,errno);	</span><br><span class="line">	empty=sem_open(<span class="string">&quot;empty&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	full=sem_open(<span class="string">&quot;full&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	mutex=sem_open(<span class="string">&quot;mutex&quot;</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">		Producer();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">			<span class="type">int</span> c=<span class="number">50</span>;</span><br><span class="line">			<span class="keyword">while</span>(c--)	Consumer();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	sem_unlink(<span class="string">&quot;empty&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;full&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;mutex&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>这部分踩过的坑：</strong></p>
<ol>
<li><p>在用户态和核心态之间传递参数【这个我没考虑到】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指针参数传递的是应用程序所在地址空间的逻辑地址，</span><br><span class="line">在内核中如果直接访问这个地址，访问到的是内核空间中的数据，不会是用户空间的。</span><br><span class="line">所以这里还需要一点儿特殊工作，才能在内核中从用户空间得到数据。</span><br></pre></td></tr></table></figure>

<p>这段代码就是在做这个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先将信号量的名称赋值到新建的缓冲区中 */</span></span><br><span class="line">    <span class="type">char</span> nbuf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	nbuf[i] = get_fs_byte(name+i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这一段代码值得学习</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> _SEM_H_</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _SEM_H_</span></span><br></pre></td></tr></table></figure></li>
<li><p>一个第一眼看傻掉了的问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sleep函数的签名</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span>;</span><br><span class="line"><span class="comment">//一开始初始化队列为空</span></span><br><span class="line">sem_list[i].<span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//使用sleep</span></span><br><span class="line">sleep_on(&amp;(sem-&gt;<span class="built_in">queue</span>));</span><br></pre></td></tr></table></figure>

<p>如果队列为空的时候，传入sleep_on的是不是NULL呢？</p>
<p>其实这个本质上是type* p=NULL,&amp;p是不是NULL的问题。虽然知道不是，但还是写个程序测试一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">&#125;haha;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">isNULL</span><span class="params">(haha** a)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a==<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	haha *h=<span class="literal">NULL</span>;</span><br><span class="line">	isNULL(&amp;h);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result：0</span></span><br></pre></td></tr></table></figure></li>
<li><p>sem_post签名与实现矛盾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wake_up() 的功能是唤醒链表上睡眠的所有进程。</span><br><span class="line">sem_post() 就是信号量的 V 原子操作。如果有等待 sem 的进程，它会唤醒其中的一个。</span><br></pre></td></tr></table></figure>

<p>以上都是指导书的内容。这个“所有”和“一个”的用意我不大明白。也许唤醒所有进程，其中一个抢到了锁，其他的全睡了，这个也被认为是唤醒其中一个吧（）</p>
</li>
<li><p>聪明的越界处理【未考虑到】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 判断:如果传入的信号量是无效信号量，V操作失败，返回-1 */</span></span><br><span class="line"><span class="keyword">if</span>(sem == <span class="literal">NULL</span> || sem &lt; sem_list || sem &gt; sem_list + SEM_LIST_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毕竟有效的信号量都是引用的信号量表的信号量。所以地址越界的自然无效。</p>
</li>
<li><p>最坑的一点</p>
<p>其实指导书提醒了</p>
<blockquote>
<p>下面描述的问题未必具有普遍意义，仅做为提醒，请实验者注意。</p>
<p>include/string.h 实现了全套的 C 语言字符串操作，而且都是采用汇编 + inline 方式优化。</p>
<p>但在使用中，某些情况下可能会遇到一些奇怪的问题。比如某人就遇到 <code>strcmp()</code> 会破坏参数内容的问题。如果调试中遇到有些 “诡异” 的情况，可以试试不包含头文件，一般都能解决。不包含 <code>string.h</code>，就不会用 inline 方式调用这些函数，它们工作起来就趋于正常了。</p>
</blockquote>
<p>但是具体表现跟它说的差距有点大（）</p>
<p>我是全部检查没问题了，然后上linux0.11真机运行。PID:number这样的信息全部打印出来了，没啥问题，但是打印完操作系统就会寄，大多数极端情况就直接重启了，小部分还会温和地提醒以下报错信息然后死循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernel panic: trying to free up swapper memory space</span><br><span class="line">in swapper task - not syncing</span><br></pre></td></tr></table></figure>

<p>最后尝试着修改去掉string.h，才得到了正确的结果，泪目。</p>
</li>
</ol>
<h1 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="proc文件系统"></a>proc文件系统</h1><blockquote>
<p>参考文章：</p>
<h6 id="操作系统实验08-proc文件系统的实现"><a href="#操作系统实验08-proc文件系统的实现" class="headerlink" title="操作系统实验08-proc文件系统的实现"></a><a href="https://www.cnblogs.com/mirage-mc/p/13036570.html">操作系统实验08-proc文件系统的实现</a></h6></blockquote>
<blockquote>
<p>在 Linux 0.11 上实现 procfs（proc 文件系统）内的 psinfo 结点。当读取此结点的内容时，可得到系统当前所有进程的状态信息。例如，用 cat 命令显示 <code>/proc/psinfo</code> 和<code>/proc/hdinfo</code>的内容，可得到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/psinfo</span><br><span class="line">pid    state    father    counter    start_time</span><br><span class="line">0    1    -1    0    0</span><br><span class="line">1    1    0    28    1</span><br><span class="line">4    1    1    1    73</span><br><span class="line">3    1    1    27    63</span><br><span class="line">6    0    4    12    817</span><br><span class="line">$ <span class="built_in">cat</span> /proc/hdinfo</span><br><span class="line">total_blocks:    62000;</span><br><span class="line">free_blocks:    39037;</span><br><span class="line">used_blocks:    22963;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>procfs</code> 及其结点要在内核启动时自动创建。</p>
<p>相关功能实现在 <code>fs/proc.c</code> 文件内。</p>
</blockquote>
<h2 id="必备知识-1"><a href="#必备知识-1" class="headerlink" title="必备知识"></a>必备知识</h2><h3 id="要点1-procfs简介"><a href="#要点1-procfs简介" class="headerlink" title="要点1 procfs简介"></a>要点1 procfs简介</h3><blockquote>
<p>正式的 Linux 内核实现了 <code>procfs</code>，它是一个**<u>虚拟文件系统</u>**，通常被 mount（挂载） 到 <code>/proc</code> 目录上，通过<u>虚拟文件和虚拟目录的方式</u>提供<u><strong>访问系统参数</strong></u>的机会，所以有人称它为 “了解系统信息的一个窗口”。</p>
<p>这些虚拟的文件和目录**<u>并没有真实地存在在磁盘</u>**上，而是内核中各种数据的一种直观表示。虽然是虚拟的，但它们都可以通过标准的系统调用（<code>open()</code>、<code>read()</code> 等）访问。</p>
<p>其实，Linux 的很多系统命令就是通过读取 <code>/proc</code> 实现的。例如 <code>uname -a</code> 的部分信息就来自 <code>/proc/version</code>，而 <code>uptime</code> 的部分信息来自 <code>/proc/uptime</code> 和 <code>/proc/loadavg</code>。</p>
</blockquote>
<h3 id="要点2-基本思路"><a href="#要点2-基本思路" class="headerlink" title="要点2 基本思路"></a>要点2 基本思路</h3><blockquote>
<p>Linux 是<u><strong>通过文件系统接口</strong></u>实现 <code>procfs</code>，并在启动时自动将其 mount 到 <code>/proc</code> 目录上。</p>
<p>此目录下的所有内容都是<u>随着系统的运行自动建立、删除和更新</u>的，而且<u><strong>它们完全存在于内存中</strong></u>，不占用任何外存空间。</p>
<p>Linux 0.11 还没有实现虚拟文件系统，也就是，还没有提供增加新文件系统支持的接口。所以本实验只能在现有文件系统的基础上，通过打补丁的方式模拟一个 <code>procfs</code>。</p>
<p>Linux 0.11 使用的是 Minix 的文件系统，这是一个典型的基于 <code>inode</code> 的文件系统，《注释》一书对它有详细描述。它的每个文件都要对应至少一个 inode，而 inode 中记录着文件的各种属性，包括文件类型。文件类型有<u><strong>普通文件、目录、字符设备文件和块设备文件</strong></u>等。在内核中，每种类型的文件都有不同的处理函数与之对应。我们可以<u><strong>增加一种新的文件类型——proc 文件</strong></u>，并在<u>相应的处理函数内实现 procfs 要实现的功能</u>。</p>
</blockquote>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="要点1-新增proc文件类型"><a href="#要点1-新增proc文件类型" class="headerlink" title="要点1 新增proc文件类型"></a>要点1 新增proc文件类型</h3><p>include/sys/stat.h  新增：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IFPROC 0050000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_ISPROC(m)	(((m) &amp; S_IFMT) == S_IFPROC)</span></span><br></pre></td></tr></table></figure>

<h3 id="要点2-修改mknod-函数和init-函数"><a href="#要点2-修改mknod-函数和init-函数" class="headerlink" title="要点2 修改mknod()函数和init()函数"></a>要点2 修改mknod()函数和init()函数</h3><blockquote>
<p>psinfo 结点要通过 <code>mknod()</code> 系统调用建立，所以要让它支持新的文件类型。</p>
</blockquote>
<p>直接修改 <code>fs/namei.c</code> 文件中的 <code>sys_mknod()</code> 函数中的一行代码，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (S_ISBLK(mode) || S_ISCHR(mode) || S_ISPROC(mode))</span><br><span class="line">     inode-&gt;i_zone[<span class="number">0</span>] = dev;</span><br><span class="line"><span class="comment">// 文件系统初始化</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>内核初始化的全部工作是在 <code>main()</code> 中完成，而 <code>main()</code> 在最后从内核态切换到用户态，并调用 <code>init()</code>。</p>
<p><code>init()</code> 做的第一件事情就是挂载根文件系统：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line"><span class="comment">//    ……    </span></span><br><span class="line">setup((<span class="type">void</span> *) &amp;drive_info); </span><br><span class="line"><span class="comment">//    …… </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>procfs</code> 的初始化工作**<u>应该在根文件系统挂载之后开始</u>**。它包括两个步骤：</p>
<ul>
<li><p>（1）建立 <code>/proc</code> 目录；建立 <code>/proc</code> 目录下的各个结点。本实验只建立 <code>/proc/psinfo</code>。</p>
</li>
<li><p>（2）建立目录和结点分别需要调用 <code>mkdir()</code> 和 <code>mknod()</code> 系统调用。因为初始化时已经在用户态，所以不能直接调用 <code>sys_mkdir()</code> 和 <code>sys_mknod()</code>。必须在初始化代码所在文件中实现这两个系统调用的用户态接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      </span><br><span class="line">_syscall2(<span class="type">int</span>,mkdir,<span class="type">const</span> <span class="type">char</span>*,name,<span class="type">mode_t</span>,mode);</span><br><span class="line">_syscall3(<span class="type">int</span>,mknod,<span class="type">const</span> <span class="type">char</span>*,filename,<span class="type">mode_t</span>,mode,<span class="type">dev_t</span>,dev);</span><br></pre></td></tr></table></figure>

<p><code>mkdir()</code> 时 mode 参数的值可以是 “0755”（对应 <code>rwxr-xr-x</code>），表示只允许 root 用户改写此目录，其它人只能进入和读取此目录。</p>
<p>procfs 是一个只读文件系统，所以用 <code>mknod()</code> 建立 psinfo 结点时，必须通过 mode 参数将其设为只读。建议使用 <code>S_IFPROC|0444</code> 做为 mode 值，表示这是一个 proc 文件，权限为 0444（r–r–r–），对所有用户只读。</p>
<p><code>mknod()</code> 的第三个参数 dev 用来说明结点所代表的设备编号。对于 procfs 来说，此编号可以完全自定义。proc 文件的处理函数将通过这个编号决定对应文件包含的信息是什么。<u><strong>例如，可以把 0 对应 psinfo，1 对应 meminfo，2 对应 cpuinfo。</strong></u></p>
</li>
</ul>
</blockquote>
<p>也就是说，打开linux-0.11/init/main.c</p>
<p>加入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">int</span>,mkdir,<span class="type">const</span> <span class="type">char</span>*,name,<span class="type">mode_t</span>,mode);</span><br><span class="line">_syscall3(<span class="type">int</span>,mknod,<span class="type">const</span> <span class="type">char</span>*,filename,<span class="type">mode_t</span>,mode,<span class="type">dev_t</span>,dev);</span><br></pre></td></tr></table></figure>

<p>在init函数中，添加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/proc&quot;</span>,<span class="number">0755</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/psinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//其余文件以此类推...</span></span><br></pre></td></tr></table></figure>

<p>编译运行即可看到：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20221006141358458.png" class> 

<blockquote>
<p>这些信息至少说明，psinfo 被正确 <code>open()</code> 了。所以我们不需要对 <code>sys_open()</code> 动任何手脚，唯一要打补丁的，是 <code>sys_read()</code>。</p>
</blockquote>
<h3 id="要点3-修改read-，让proc可读"><a href="#要点3-修改read-，让proc可读" class="headerlink" title="要点3 修改read()，让proc可读"></a>要点3 修改read()，让proc可读</h3><blockquote>
<p>首先分析 <code>sys_read</code>（在文件 <code>fs/read_write.c</code> 中）</p>
<p>要在这里一群 if 的排比中，加上 <code>S_IFPROC()</code> 的分支，进入对 proc 文件的处理函数。需要传给处理函数的参数包括：</p>
<ul>
<li><code>inode-&gt;i_zone[0]</code>，这就是 <code>mknod()</code> 时指定的 <code>dev</code> ——设备编号</li>
<li><code>buf</code>，指向用户空间，就是 <code>read()</code> 的第二个参数，用来接收数据</li>
<li><code>count</code>，就是 <code>read()</code> 的第三个参数，说明 <code>buf</code> 指向的缓冲区大小</li>
<li><code>&amp;file-&gt;f_pos</code>，<code>f_pos</code> 是上一次读文件结束时“文件位置指针”的指向。这里必须传指针，因为处理函数需要根据传给 <code>buf</code> 的数据量修改 <code>f_pos</code> 的值。</li>
</ul>
</blockquote>
<p>依照指导书，在read_write.c添加如下语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">proc_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> dev,<span class="type">char</span>* buf,<span class="type">int</span> count,<span class="type">off_t</span>* f_pos)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(...)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISPROC(inode-&gt;i_mode))&#123;</span><br><span class="line">        <span class="keyword">return</span> proc_handler(inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要点4-编写pro文件的处理函数"><a href="#要点4-编写pro文件的处理函数" class="headerlink" title="要点4 编写pro文件的处理函数"></a>要点4 编写pro文件的处理函数</h3><blockquote>
<p>proc 文件的处理函数的功能是<u><strong>根据设备编号</strong></u>，把不同的内容写入到用户空间的 buf。写入的数据要从 <code>f_pos</code> 指向的位置开始，每次最多写 count 个字节，并根据实际写入的字节数调整 <code>f_pos</code> 的值，最后返回实际写入的字节数。当设备编号表明要读的是 psinfo 的内容时，就要按照 psinfo 的形式组织数据。</p>
<p>实现此函数可能要用到如下几个函数：</p>
<ul>
<li>malloc() 函数</li>
<li>free() 函数</li>
</ul>
<p>包含 <code>linux/kernel.h</code> 头文件后，就可以使用 <code>malloc()</code> 和 <code>free()</code> 函数。它们是可以被核心态代码调用的，唯一的限制是一次申请的内存大小不能超过一个页面。</p>
</blockquote>
<blockquote>
<p>进程的信息就来源于内核全局结构数组 <code>struct task_struct * task[NR_TASKS]</code> 中，具体读取细节可参照 <code>sched.c</code> 中的函数 <code>schedule()</code>。</p>
<p>可以借鉴一下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*p)</span><br><span class="line">(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>)+...;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>cat 是 Linux 下的一个常用命令，功能是将文件的内容打印到标准输出。</p>
<p>它核心实现大体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">513</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> nread;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(argv[<span class="number">1</span>], O_RDONLY, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(nread = read(fd, buf, <span class="number">512</span>))</span><br><span class="line">&#123;</span><br><span class="line">  buf[nread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在cat的代码中，open函数返回了psinfo的文件描述符，read函数读到该文件描述符，就会识别出我们要读写的文件是PROC类型的，因此就会跳转到我们的proc_handler去执行，再进一步跳转到psinfo_handler执行。根据cat的代码和指导书的提示，不难得出，我们的目标就是把进程的信息按照格式给弄进buf里面，就可以了。</p>
<p>而这也正体现了proc作为“**<u>虚拟文件</u>**”的特点。对它进行读写，它的信息并非存放在磁盘中，而是全部由放在内存中的逻辑和数据【由task_struct提供】来完成。</p>
<p>在fs文件夹下创建文件proc_dev.c，编写proc文件的处理函数。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_bit(nr,addr) (&#123;\</span></span><br><span class="line"><span class="meta">register int res ; \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;btsl %2,%3\n\tsetb %%al&quot;</span>: \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;=a&quot;</span> (res):<span class="string">&quot;0&quot;</span> (0),<span class="string">&quot;r&quot;</span> (nr),<span class="string">&quot;m&quot;</span> (*(addr))); \</span></span><br><span class="line"><span class="meta">res;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>** <span class="title">p</span>=</span>&amp;FIRST_TASK;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">psinfo_handler</span><span class="params">(<span class="type">off_t</span>* f_pos,<span class="type">char</span>* buf)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">hdinfo_handler</span><span class="params">(<span class="type">off_t</span>* f_pos,<span class="type">char</span>* buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">proc_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> dev,<span class="type">char</span>* buf,<span class="type">int</span> count,<span class="type">off_t</span>* f_pos)</span>&#123;</span><br><span class="line">    <span class="comment">//根据设备编号，把不同的内容写入到用户空间的 buf</span></span><br><span class="line">	<span class="keyword">switch</span>(dev)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> psinfo_handler(f_pos,buf);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> hdinfo_handler(f_pos,buf);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内核态和用户态间传递数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">put_into_buf</span><span class="params">(<span class="type">char</span>* buf,<span class="type">char</span>* s)</span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(s[cnt]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">		put_fs_byte(s[cnt++],buf++);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* fmt,...)</span>&#123;</span><br><span class="line">	va_list args;<span class="type">int</span> i;</span><br><span class="line">	va_start(args,fmt);</span><br><span class="line">	i=<span class="built_in">vsprintf</span>(buf,fmt,args);</span><br><span class="line">	va_end(args);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">psinfo_handler</span><span class="params">(<span class="type">off_t</span>* f_pos,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//初始化字符串</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)	s[i]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果是第一次read，需要在屏幕上打印列表头，并且重置p指针为进程队列头</span></span><br><span class="line">	<span class="keyword">if</span>((*f_pos)==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(s,<span class="string">&quot;pid\tstate\tfather\tcounter\tstart_time\n&quot;</span>);</span><br><span class="line">		p=&amp;FIRST_TASK;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//到达文件末尾</span></span><br><span class="line">	<span class="keyword">if</span>((*p)==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次仅输出一行</span></span><br><span class="line">	<span class="keyword">if</span>((*f_pos)!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(s,<span class="string">&quot;%ld\t%ld\t%ld\t%ld\t%ld\n&quot;</span>,(*p)-&gt;pid,(*p)-&gt;state,(*p)-&gt;father,(*p)-&gt;counter,(*p)-&gt;start_time);</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> cnt=put_into_buf(buf,s);</span><br><span class="line">	*f_pos+=cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可参考fs/super.c mount_root()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hdinfo_handler</span><span class="params">(<span class="type">off_t</span>* f_pos,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">    <span class="comment">//防止循环多次打印</span></span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">sb</span>;</span></span><br><span class="line">	sb=get_super(<span class="number">0x301</span>);<span class="comment">/*磁盘设备号 3*256+1*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i=sb-&gt;s_nzones;</span><br><span class="line">	<span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,sb-&gt;s_zmap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">			<span class="built_in">free</span>++;</span><br><span class="line">	<span class="built_in">sprintf</span>(s,<span class="string">&quot;total_blocks:\t%d\nfree_blocks:\t%d\nused_blocks:\t%d\n&quot;</span>,sb-&gt;s_nzones,<span class="built_in">free</span>,sb-&gt;s_nzones-<span class="built_in">free</span>);</span><br><span class="line">	<span class="type">int</span> cnt=put_into_buf(buf,s);</span><br><span class="line">	flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20221006210732995.png" class> 

<h4 id="这部分踩过的坑："><a href="#这部分踩过的坑：" class="headerlink" title="这部分踩过的坑："></a>这部分踩过的坑：</h4><p>1.LAST_TASK 的定义</p>
<p>对于LAST_TASK，我本来的理解是，当前所有进程的最后一个。</p>
<p>本来我设的是跟schedule一样，另p=LAST_TASK，从末尾开始打印。我那时其余代码跟上面一样，就只是把上面的FIRST改成LAST，结果输出为空，调试发现LAST_TASK==NULL。</p>
<p>然后打开sched.h，看到LAST_TASK的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_TASK task[NR_TASKS-1]</span></span><br></pre></td></tr></table></figure>

<p>原来它就是单纯简单粗暴地指“最后一个”进程23333</p>
<p>我们目前当前的进程数量远远小于进程的最大数量，因此最大数量编号的那个进程自然也就是空的了。</p>
<p>2.char s[100]={0};</p>
<p>用这个的时候编译报错：undefined reference to ’memset‘</p>
<p>说明这个简略写法其实本质是用的memset，而要用memset的话需要包含头文件string.h。经测试得包含了string.h后确实就好使了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s_imap_blocks、ns_zmap_blocks、</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//total_blocks、free_blocks、used_blocks、total_inodes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;is_zmap_blocks;i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    bh=sb-&gt;s_zmap[i];</span><br><span class="line"></span><br><span class="line">    db=(<span class="type">char</span>*)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1024</span>;j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=<span class="number">8</span>;k++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((used_blocks+free_blocks)&gt;=total_blocks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( *(db+j) &amp; k)</span><br><span class="line">    used_blocks++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">free_blocks++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.我发现一件事</p>
<p>我第一次把init/main.c写错了，写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/proc&quot;</span>,<span class="number">0755</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/psinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">0</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/hdinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">0</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/inodeinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>设别号忘了改了。然后进行了一次编译，运行。</p>
<p>之后我发现错了，就改成了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/proc&quot;</span>,<span class="number">0755</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/psinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">0</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/hdinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">1</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/inodeinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>再次编译运行，结果上面的那个错还是没改回来</p>
<p>直到我手动把proc文件夹删了，再重新读一次磁盘加载proc文件夹，才回归正常。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>本次实验耗时：下午一点到晚上九点半（）</p>
<p>本实验通过对proc虚拟文件的编写流程，实际上让我们体会到了“一切皆文件”的思想。</p>
<p>什么东西都可以是文件，只不过它们有不同的文件类型和不同的read/write处理函数。</p>
<p>对于终端设备和磁盘，其read/write函数本质上是在用out指令跟它的缓冲区交互，只不过磁盘比终端设备抽象层次更深，包含了文件系统的层层封装。</p>
<p>对于虚拟文件，其read/write函数本质上就是与内存交互，通过一段逻辑【处理函数】将内存存储的当前操作系统信息实时显示出来，而不需要存储。</p>
<p>还有，参考文章那篇的代码写的很好，快去看！</p>
]]></content>
      <tags>
        <tag>labs</tag>
      </tags>
  </entry>
  <entry>
    <title>cs144</title>
    <url>/2023/02/25/cs144/</url>
    <content><![CDATA[<blockquote>
<p>总耗时：65h  约17天</p>
<p><a href="https://cs144.github.io/">实验官网</a></p>
<p><a href="https://github.com/shootfirst/CS144/">感恩</a></p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本实验总体思维和代码上的难度还是不难的（至少比xv6简单），我认为其难点主要集中在TCP协议本身就很复杂很多的细节问题，以及需要我们有一种面向测试用例编程、直面自己往日写过的屎山的勇气（。</p>
<p>下面，我将对本实验的完成情况即心得进行一个总结，也算是本篇博客/本次实验的一个<strong>导读</strong>。</p>
<blockquote>
<p><strong>类似于这样的块引用中的部分是我自认为的精华部分哦</strong>。</p>
</blockquote>
<p>本实验对TCP-IP-ETH协议栈的实验是自顶向下的，其中对TCP协议的实现是由内而外的。</p>
<p>后者很容易导致，当你写完了lab0-3，你<strong>还是不知道自己到底写了个啥</strong>，以及TCP又究竟怎么通过你写的那几个类run起来。直到lab4结束，你完成了对TCP状态机的组织，并且出于debug目的钻研过部分socket的代码、熟悉了（其实差不多已经背下来了）TCP的三握手四挥手的过程，至此你才会对TCP的实现<strong>有较为清晰的理解</strong>。这个过程很痛苦，但是也真的非常爽。</p>
<blockquote>
<p>关于TCP状态机的理解总结，请参见<code>Lab3 TCPConnection——心得——总结：状态机</code>部分。</p>
</blockquote>
<p>然而，实现了TCP协议之后，我们还是不知道，在<code>TCPConnection</code>中发送的数据包，又是如何到达网络上的另一个host处的。是时，官方贴心地为我们指了条明路：它告诉我们，我们在lab0-4实现的是TCP-IP协议栈，其中运输层和网络层由用户实现，其他更底层则由内核实现，二者通过操作系统提供的TUN接口进行交互。而我们接下来的学习目标，就是从内核中夺走一些权力：数据链路层也要由我们自己实现！</p>
<blockquote>
<p>关于此处的TCP-IP架构等，请参见<code>Lab5 NetworkInterface——Overview——承上启下</code></p>
</blockquote>
<p>故而，接下来，我们将实现TCP-IP-ETH协议栈。在lab5，我们将目光投向TCP层以下的数据链路层(没有网络层是因为官方已经帮我们实现了)，实现ETH协议和ARP协议；在lab6，我们则需要实现路由查找的功能。</p>
<p>至此，所有实验已经结束。写完了上述实验，我们对协议栈已经具有了很深刻的了解，对TCP—IP—ETH—TAN—Internet—TAN—ETH—IP—TCP的这个数据传输过程也已经是懂王了。</p>
<p>然而，我们在<code>TCPConnection</code>，只知道会有好心人，在上层app有数据传进来的时候调用<code>write</code>、在下层协议栈有segment传进来的时候调用<code>segment_received</code>、取出<code>_segment_out</code>的segment向底层协议栈发送、读走<code>outputstream</code>的内容。但是这个所谓的“好心人”具体是怎么做到的，怎么实现的，我们一概不知。</p>
<p>答案是，这个所谓的“好心人”，其实就是我们的<code>TCPSpongeSocket</code>。它向上将协议栈与上层app连接，向下又将协议栈与TAN接口结合。</p>
<blockquote>
<p>发送数据时，数据流向：上层app→（通过<code>TCPSpongeSocket</code>）<code>TCPConnection</code>→（通过<code>write</code>方法）<code>ByteStream</code>→<code>TCPSender</code>→（通过从<code>_sender.segments_out</code>读）<code>TCPConnection</code>→（通过<code>TCPSpongeSocket</code>的adapter）<code>TAN</code></p>
<p>接收数据时，数据流向：<code>TAN</code>→（通过<code>TCPSpongeSocket</code>的adapter）<code>TCPConnection</code>→<code>TCPReceiver</code>→（中间经过<code>StreamAssembler</code>）<code>BYteStream</code>→（通过<code>TCPSpongeSocket</code>读）上层app</p>
<p>在<code>TCPSpongeSocket</code>的adapter中：TCPsegment←→IP数据报←→ETH帧</p>
<p>至于ETH帧进入TAN之后的过程？在xv6的网卡驱动那一节我们事实上已经实现过了！</p>
</blockquote>
<p><code>CS144TCPSocket</code>和<code>FullStackTCPSokect</code>都继承自<code>TCPSpongeSocket</code>。<code>TCPSpongeSocket</code>通过一个包装了操作系统提供的socket的包装类<code>_thread_data</code>来与上层app进行交互，通过adapter<code>_datagram_adapter</code>来与协议栈进行交互。由于<code>_thread_data</code>和<code>_datagram_adapter</code>本质上都是文件描述符【牛逼吧】，因而，<code>TCPSpongeSocket</code>需要对上下层进行交互的需求，就可以通过操作系统提供的POLL机制来实现，也即，app←→TCP、TCP←→协议栈的这四种数据交互情况，都用<strong>事件监听</strong>来实现！这样就能做到“及时”“高效”了。</p>
<blockquote>
<p>关于此处<code>TCPSpongeSocket</code>的事件监听机制以及其它实现细节，详见<code>其它的对...——Socket实现——TCPSpongeSocket</code></p>
</blockquote>
<p>至此以来，我们的协议栈才算真正完整了。</p>
<h3 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a><a href="https://xiunianjun.github.io/2023/02/25/cs144$lab0">Lab0</a></h3><h3 id="Lab1-StreamReassembler"><a href="#Lab1-StreamReassembler" class="headerlink" title="Lab1   StreamReassembler"></a><a href="https://xiunianjun.github.io/2023/02/25/cs144$lab1">Lab1   StreamReassembler</a></h3><h3 id="Lab2-TCPReceiver"><a href="#Lab2-TCPReceiver" class="headerlink" title="Lab2   TCPReceiver"></a><a href="https://xiunianjun.github.io/2023/02/25/cs144$lab2">Lab2   TCPReceiver</a></h3><h3 id="Lab3-TCPSender"><a href="#Lab3-TCPSender" class="headerlink" title="Lab3   TCPSender"></a><a href="https://xiunianjun.github.io/2023/02/25/cs144$lab3">Lab3   TCPSender</a></h3><h3 id="Lab4-TCPConnection"><a href="#Lab4-TCPConnection" class="headerlink" title="Lab4   TCPConnection"></a><a href="https://xiunianjun.github.io/2023/02/25/cs144$lab4">Lab4   TCPConnection</a></h3><h3 id="Lab5-NetworkInterface"><a href="#Lab5-NetworkInterface" class="headerlink" title="Lab5   NetworkInterface"></a><a href="https://xiunianjun.github.io/2023/02/25/cs144$lab5">Lab5   NetworkInterface</a></h3><h3 id="Lab6-Router"><a href="#Lab6-Router" class="headerlink" title="Lab6   Router"></a><a href="https://xiunianjun.github.io/2023/02/25/cs144$lab6">Lab6   Router</a></h3><h3 id="其他的对实验未涉及的思考"><a href="#其他的对实验未涉及的思考" class="headerlink" title="其他的对实验未涉及的思考"></a><a href="https://xiunianjun.github.io/2023/02/25/cs144$else">其他的对实验未涉及的思考</a></h3>]]></content>
      <tags>
        <tag>labs</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating system interface</title>
    <url>/2023/01/10/xv6$chap1/</url>
    <content><![CDATA[<h1 id="Operating-system-interface"><a href="#Operating-system-interface" class="headerlink" title="Operating system interface"></a>Operating system interface</h1><p>本节大概是在讲操作系统的接口，系统调用占了很大一部分。</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>int fork()</code></td>
<td>创建一个进程，返回子进程的PID</td>
</tr>
<tr>
<td><code>int exit(int status)</code></td>
<td>终止当前进程，并将状态报告给wait()函数。无返回</td>
</tr>
<tr>
<td><code>int wait(int *status)</code></td>
<td>等待一个子进程退出; 将退出状态存入*status; 返回子进程PID。</td>
</tr>
<tr>
<td><code>int kill(int pid)</code></td>
<td>终止对应PID的进程，返回0，或返回-1表示错误</td>
</tr>
<tr>
<td><code>int getpid()</code></td>
<td>返回当前进程的PID</td>
</tr>
<tr>
<td><code>int sleep(int n)</code></td>
<td>暂停n个时钟节拍</td>
</tr>
<tr>
<td><code>int exec(char *file, char *argv[])</code></td>
<td>加载一个文件并使用参数执行它; 只有在出错时才返回</td>
</tr>
<tr>
<td><code>char *sbrk(int n)</code></td>
<td>按n 字节增长进程的内存。返回新内存的开始</td>
</tr>
<tr>
<td><code>int open(char *file, int flags)</code></td>
<td>打开一个文件；flags表示read/write；返回一个fd（文件描述符）</td>
</tr>
<tr>
<td><code>int write(int fd, char *buf, int n)</code></td>
<td>从buf 写n 个字节到文件描述符fd; 返回n</td>
</tr>
<tr>
<td><code>int read(int fd, char *buf, int n)</code></td>
<td>将n 个字节读入buf；返回读取的字节数；如果文件结束，返回0</td>
</tr>
<tr>
<td><code>int close(int fd)</code></td>
<td>释放打开的文件fd</td>
</tr>
<tr>
<td><code>int dup(int fd)</code></td>
<td>返回一个新的文件描述符，指向与fd 相同的文件</td>
</tr>
<tr>
<td><code>int pipe(int p[])</code></td>
<td>创建一个管道，把read/write文件描述符放在p[0]和p[1]中</td>
</tr>
<tr>
<td><code>int chdir(char *dir)</code></td>
<td>改变当前的工作目录</td>
</tr>
<tr>
<td><code>int mkdir(char *dir)</code></td>
<td>创建一个新目录</td>
</tr>
<tr>
<td><code>int mknod(char *file, int, int)</code></td>
<td>创建一个设备文件</td>
</tr>
<tr>
<td><code>int fstat(int fd, struct stat *st)</code></td>
<td>将打开文件fd的信息放入*st</td>
</tr>
<tr>
<td><code>int stat(char *file, struct stat *st)</code></td>
<td>将指定名称的文件信息放入*st</td>
</tr>
<tr>
<td><code>int link(char *file1, char *file2)</code></td>
<td>为文件file1创建另一个名称(file2)</td>
</tr>
<tr>
<td><code>int unlink(char *file)</code></td>
<td>删除一个文件</td>
</tr>
</tbody></table>
<p> 表1.2：xv6系统调用（除非另外声明，这些系统调用返回0表示无误，返回-1表示出错）</p>
<h2 id="Process-and-memory"><a href="#Process-and-memory" class="headerlink" title="Process and memory"></a>Process and memory</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child&#x27;s pid = %d\n&quot;</span>,pid);</span><br><span class="line">    pid = wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done.\n&quot;</span>,pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child : exiting\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个利用fork的返回值对于父子进程来说不同这一特点进行编写的例程。其中比较不熟的还是wait(0)这一句的用法。这点具体可以看书中笔记和上面的系统调用表。</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>exec是一个系统调用，它跟exe文件被执行的原理密切相关。当程序调用exec，就会跳转到exec参数文件去执行，原程序exec下面的指令都不再被执行，除非exec因错误而退出。</p>
<h3 id="exec与fork"><a href="#exec与fork" class="headerlink" title="exec与fork"></a>exec与fork</h3><p>由shell的源码中main函数这一段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read and run input commands.</span></span><br><span class="line"><span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">    <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">    runcmd(parsecmd(buf));</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(cmd-&gt;type)&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> EXEC:</span><br><span class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</span><br><span class="line">    exec(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;exec %s failed\n&quot;</span>, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到shell其实本质上就是这样的架构架构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(读到了command&amp;&amp;fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        exec(command);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;失败信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即父进程创建出子进程来执行command，并且父进程等待子进程执行完再继续等待输入。</p>
<p>可以看到，fork和exec的使用是非常紧密的，联合使用也是非常顺理成章的。那么，如果干从fork的exec的对于内存管理的原理来讲，就会不免产生一点问题。</p>
<blockquote>
<p>问题描述：</p>
<p>fork的内存原理，实质上是开辟一片新的与父进程等大的内存空间，然后把父进程的数据都copy一份进这个新内存空间。exec的原理是用一片可以容纳得下文件指令及其所需空间的内存空间去替代调用进程原有的那片内存空间。</p>
<p>可以看到，如果fork和exec接连使用，理论上其实是会产生一点浪费的，fork创建子进程复制完了一片内存空间，这片新复制的内存空间又马上被扔掉了，取而代之的用的是exec的内存空间。</p>
</blockquote>
<p>为了解决这个问题，kernel使用了copy-on-write技术优化。</p>
<h2 id="I-O-and-File-descriptors"><a href="#I-O-and-File-descriptors" class="headerlink" title="I/O and File descriptors"></a>I/O and File descriptors</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>句柄就是一个int值，它代表了一个由内核管理的，可以被进程读写的对象.</p>
<blockquote>
<p>A process may obtain a file descriptor by opening a <strong>file</strong>, <strong>directory</strong>, or <strong>device</strong>, or by creating a <strong>pipe</strong>, or by <strong>duplicating</strong> an existing descriptor.</p>
</blockquote>
<p>每个进程的其三个句柄有默认值：</p>
<blockquote>
<p>By convention, a process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error). </p>
</blockquote>
<p>句柄0对应着standard input，1对应着standard output，2对应着standard error。</p>
<h3 id="read、write"><a href="#read、write" class="headerlink" title="read、write"></a>read、write</h3><p>read和write的参数都是句柄，buf，读/写长度。都会导致文件指针的移动。使用如下例程【类似cat的原理】：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    n = read(<span class="number">0</span>);<span class="comment">//从标准输入读</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(write(<span class="number">1</span>,buf,n) != n)&#123;<span class="comment">//向标准输出写</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>close函数释放了一个句柄，以后它释放掉的这个句柄就可以被用来表示别的文件了。</p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p>open函数会给参数的file分配一个句柄。这个句柄通常是目前空闲的句柄中值最小的那个。</p>
<h3 id="重定向的实现"><a href="#重定向的实现" class="headerlink" title="重定向的实现"></a>重定向的实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argc[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>,argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xv6的重定向实现跟这个原理差不多：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> REDIR:</span><br><span class="line">  rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">  close(rcmd-&gt;fd);</span><br><span class="line">  <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;open %s failed\n&quot;</span>, rcmd-&gt;file);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  runcmd(rcmd-&gt;cmd);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="共享偏移量"><a href="#共享偏移量" class="headerlink" title="共享偏移量"></a>共享偏移量</h3><p>fork出来的父子进程同一个句柄对同一个文件的偏移量是相同的，这个原理应该是因为，父子进程共享的是文件句柄这个结构体对象本身，也就是拷贝的时候是浅拷贝而不是深拷贝。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	wait(<span class="number">0</span>);</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p><code>dup</code>系统调用复制一个现有的文件描述符，返回一个引用自同一个底层I/O对象的新文件描述符。</p>
<p>dup和open一样，都是会占用一个新的句柄的，而且都是优先分配数值小的。比如说fd = dup(3)，得到fd=4，那么结果就是句柄3和句柄4指向同一个文件，并且偏移量一样。</p>
<p>dup可以让这样的指令变得可以实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个指令的意思是，先把stderr的结果重定向到stdout，再把stdout的结果重定向到tmp1中。</p>
<p>关于2&gt;&amp;1的解释，可以看这个 <a href="https://blog.csdn.net/qq_38500662/article/details/84973518">shell中的”2&gt;&amp;1”是什么意思？</a></p>
</blockquote>
<p>这个的实现就要用到dup了。我们会fork一个子进程，在子进程里面close(2)，然后再dup(1)。这样一来，我们就成功实现了句柄1和2指向同一个文件</p>
<h2 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>int pipe(int p[]) 创建一个管道，把read/write文件描述符放在p[0]和p[1]中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span>* argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>],<span class="string">&quot;hello world\n&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成了父进程-pipe-子进程的一个重定向。</p>
<p>pipe是阻塞的生产者消费者模式。对管道的read，在没有数据输入时会阻塞，直到读到数据，或者所有的write方向都被关闭。示例代码中，如果不使用pipe就需要显示close(p[0]) close(p[1])，正是为了防止没有数据输入时write方向不为0导致死锁的情况出现。</p>
<h3 id="实现管道命令"><a href="#实现管道命令" class="headerlink" title="实现管道命令"></a>实现管道命令</h3><p>管道命令的实现正是通过pipe。</p>
<p>执行原理就是，创建两个子进程分别执行左右两侧的句子，然后左侧子进程的out重定向到pip的write，右侧子进程的in重定向到pip的read。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">case</span> PIPE:</span><br><span class="line">   pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">   <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">     panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line"><span class="comment">//左</span></span><br><span class="line">   <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">     close(<span class="number">1</span>);</span><br><span class="line">     dup(p[<span class="number">1</span>]);</span><br><span class="line">     close(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">1</span>]);</span><br><span class="line">     runcmd(pcmd-&gt;left);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//右</span></span><br><span class="line">   <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">     close(<span class="number">0</span>);</span><br><span class="line">     dup(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">1</span>]);</span><br><span class="line">     runcmd(pcmd-&gt;right);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中</span></span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line">   close(p[<span class="number">1</span>]);</span><br><span class="line">   <span class="comment">//wait</span></span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">   wait(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这实际上是二叉树的左右中递归过程。</p>
<blockquote>
<p>附：对于管道命令的解读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat a.txt | echo</span><br></pre></td></tr></table></figure>

<p>我的本意是觉得，这意思就是把cat a.txt的输出连到echo的输入，这个命令结果跟cat a.txt是没什么差的。但具体执行出来发现最后的结果却是跟：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo</span><br></pre></td></tr></table></figure>

<p>这个指令的效果是一样的，也就是cat a.txt的output，即echo的input完全被丢弃了。</p>
<p>我想这是因为，echo这个命令的执行过程并没有用到stdin，仅仅用到了参数，也就是说管道read端的接入对它并没有什么影响。</p>
<p>这也是为啥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sleep 10 | echo hi</span><br></pre></td></tr></table></figure>

<p>这个命令最后的结果是，秒速出hi，然后等待10s后结束，了。由于echo的输出与stdin没有关系，所以，echo不会阻塞读入stdin，等待管道关闭，而是会即刻输出hi。</p>
</blockquote>
<p>管道实际上就相当于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo hello world | wc</span><br><span class="line">echo hello world &gt; /tmp/xyz; wc &lt; /tmp/xyz</span><br></pre></td></tr></table></figure>

<p>在这种情况下，管道相比临时文件至少有四个优势</p>
<ul>
<li>首先，不用删文件</li>
<li>其次，管道可以任意传递长的数据流</li>
<li>第三，管道允许一定程度上的并行</li>
<li>第四，如果实现进程间通讯，管道的块读写比文件的非块语义更有效率。</li>
</ul>
<h2 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h2><p>inode：代表文件本体，包括文件类型、文件长度、文件内容在磁盘位置、文件的链接数</p>
<p>link：指向文件的链接，一个文件可以有多个link，link内包含文件名和对inode的引用</p>
<p>当链接数=0，且句柄数=0，文件的磁盘空间和inode索引就会被释放</p>
<h2 id="Lab-Xv6-and-Unix-utilities"><a href="#Lab-Xv6-and-Unix-utilities" class="headerlink" title="Lab Xv6 and Unix utilities"></a>Lab Xv6 and Unix utilities</h2><h3 id="虚拟机准备"><a href="#虚拟机准备" class="headerlink" title="虚拟机准备"></a>虚拟机准备</h3><h4 id="vmware"><a href="#vmware" class="headerlink" title="vmware"></a>vmware</h4><p>使用的是rcore给的盘：</p>
<p>D:\aWorkStorage\etc\ubuntu\oslab.vmdk</p>
<p>过程还是几经波折的。在这里记录下我踩的坑和解决办法吧。</p>
<h5 id="账号密码"><a href="#账号密码" class="headerlink" title="账号密码"></a>账号密码</h5><blockquote>
<p>账号：oslab</p>
<p>密码：oslab</p>
</blockquote>
<h5 id="怎么使用vmdk文件"><a href="#怎么使用vmdk文件" class="headerlink" title="怎么使用vmdk文件"></a>怎么使用vmdk文件</h5><p><a href="http://t.zoukankan.com/lxml-p-13879978.html">新建虚拟机（.vmdk）导入Vmware</a></p>
<p>看这个就够了。</p>
<h4 id="阿里云服务器-XShell"><a href="#阿里云服务器-XShell" class="headerlink" title="阿里云服务器+XShell"></a>阿里云服务器+XShell</h4><p><a href="https://blog.csdn.net/weixin_45851575/article/details/122987929">手把手系列–Xshell连接阿里云服务器</a></p>
<h4 id="ubuntu系统忘记密码了怎么办"><a href="#ubuntu系统忘记密码了怎么办" class="headerlink" title="ubuntu系统忘记密码了怎么办"></a>ubuntu系统忘记密码了怎么办</h4><p>需要进入grub模式修改密码。</p>
<h5 id="如何进入grub模式"><a href="#如何进入grub模式" class="headerlink" title="如何进入grub模式"></a>如何进入grub模式</h5><p><a href="https://blog.csdn.net/weixin_44488927/article/details/125793756">VMware虚拟机忘记Linux用户登陆密码，重置密码解决办法</a></p>
<p>尤其注意需要在重新启动的那次才能按E，而且按的是shift+E大写E。</p>
<h5 id="进入grub模式后按什么"><a href="#进入grub模式后按什么" class="headerlink" title="进入grub模式后按什么"></a>进入grub模式后按什么</h5><p>先按个advance-recovery mod，接下来按这个操作：</p>
<p><a href="https://blog.csdn.net/liranke/article/details/25203927">操作系统实践-在Ubuntu recovery模式下找回密码</a></p>
<p>就ok了。</p>
<h4 id="连不了网"><a href="#连不了网" class="headerlink" title="连不了网"></a>连不了网</h4><p><a href="https://blog.csdn.net/jiesunliu3215/article/details/125021892">Ubuntu连接不了网络的解决方法（第二种亲测可行)</a></p>
<h3 id="配置实验环境"><a href="#配置实验环境" class="headerlink" title="配置实验环境"></a>配置实验环境</h3><blockquote>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/qq_25356929/article/details/113747023">xv6环境搭建</a></p>
<p><a href="https://www.bbsmax.com/A/nAJvZNWoJr/">【MIT6.S081/6.828】手把手教你搭建开发环境</a></p>
</blockquote>
<h4 id="下载工具链"><a href="#下载工具链" class="headerlink" title="下载工具链"></a>下载工具链</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span> </span><br></pre></td></tr></table></figure>

<p>测试安装ok：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 --version</span></span><br><span class="line">QEMU emulator version 5.1.0</span><br><span class="line">//下面其中之一正常就行</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-linux-gnu-gcc --version</span></span><br><span class="line">riscv64-linux-gnu-gcc (Debian 10.3.0-8) 10.3.0</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-unknown-elf-gcc --version</span></span><br><span class="line">riscv64-unknown-elf-gcc (GCC) 10.1.0</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-unknown-linux-gnu-gcc --version</span></span><br><span class="line">riscv64-unknown-linux-gnu-gcc (GCC) 10.1.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注，这里出现了一个问题，<code>qemu-system-riscv64 --version</code>打出来发现qemu-system-riscv64 command not found。似乎是我的ubuntu16.04版本太低了【悲】去看了下网上，可以按照这个来做：</p>
<p><a href="https://blog.csdn.net/m0_49270962/article/details/118052926">rCore qemu risc-v 实验环境配置</a></p>
</blockquote>
<h4 id="下载编译xv6源码"><a href="#下载编译xv6源码" class="headerlink" title="下载编译xv6源码"></a>下载编译xv6源码</h4><p>随后，进入一个你喜欢的文件夹clone xv6的实验源码，输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> xv6-labs-2020</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout util</span></span><br></pre></td></tr></table></figure>

<p>然后进行编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br></pre></td></tr></table></figure>

<p>如果此处发生错误：<code>unrecognized command line option -mno-relax</code>，则按照此说法 <a href="https://blog.csdn.net/qq_25356929/article/details/113747023">xv6环境搭建</a>更新gcc版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install gcc-8-riscv64-linux-gnu</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo update-alternatives --install /usr/bin/riscv64-linux-gnu-gcc riscv64-linux-gnu-gcc /usr/bin/riscv64-linux-gnu-gcc-8 8</span></span><br></pre></td></tr></table></figure>

<p>再执行一次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br></pre></td></tr></table></figure>

<p>就ok了。</p>
<h4 id="关闭qemu"><a href="#关闭qemu" class="headerlink" title="关闭qemu"></a>关闭qemu</h4><p><a href="https://blog.csdn.net/qq_67090393/article/details/126975993">qemu退出操作</a></p>
<p>在这里记个强制方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -elf | grep qemu</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/10/xv6/image-20230105153458808.png" alt="image-20230105153458808"></p>
<p>记住第二个的pid</p>
<p>然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill 3303</span><br></pre></td></tr></table></figure>

<h4 id="测试gdb是否ok"><a href="#测试gdb是否ok" class="headerlink" title="测试gdb是否ok"></a>测试gdb是否ok</h4><p>见该文章最后一部分</p>
<p><a href="https://www.bbsmax.com/A/nAJvZNWoJr/">【MIT6.S081/6.828】手把手教你搭建开发环境</a></p>
<h4 id="自测方法"><a href="#自测方法" class="headerlink" title="自测方法"></a>自测方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make grade</span><br></pre></td></tr></table></figure>

<p>或者如果只想测其中一个，可以：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./grade-lab-util sleep</span><br></pre></td></tr></table></figure>

<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><h4 id="编写sleep-c"><a href="#编写sleep-c" class="headerlink" title="编写sleep.c"></a>编写sleep.c</h4><blockquote>
<p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p>
<p><img src="/2023/01/10/xv6/image-20230105164146100.png" alt="image-20230105164146100.png"></p>
</blockquote>
<h5 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h5><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><p>注意，他要求我们实现的sleep的参数是<strong>ticks的数量</strong>，不是秒数。我花了半天找时钟周期大小这个参数在哪，找了许久没找到，估计是没考虑到这一点。</p>
<p>比如说，我翻了一下linux0.11的源码，在include/linux/time.h下有这句：</p>
<p><img src="/2023/01/10/xv6/image-20230105162505574.png" alt="image-20230105162505574.png"></p>
<p>说明了时钟频率大小。在xv6好像没有看到对这个的显式说明。</p>
<h6 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h6><p>感受了一下xv6的系统调用过程，跟linux0.11还是很相像的。</p>
<p>这个好像是lab2的内容，我暂且先在此放下我体会到的感受。</p>
<ol>
<li><p>xv6</p>
<p>首先是从用户态到内核态的切换。</p>
<p>在user/user.h中有各个系统调用外化的函数签名。在用户程序中调用里面的函数签名，就会执行【说实话，我没看懂为什么这里会知道要从user.h跳到usys.S中执行，也许是Makefile里有写？】user/usys.S中对应的汇编代码，比如说这种：</p>
<p><img src="/2023/01/10/xv6/image-20230105170701334.png" alt="image-20230105170701334"></p>
<p>然后这个SYS_close这种，其实是系统调用号宏，被定义在kernel/syscall.h中：</p>
<p><img src="/2023/01/10/xv6/image-20230105171327076.png" alt="image-20230105171327076.pn"></p>
<p><code>li a7,SYS_call</code>就是把SYS_call的值放入a7寄存器，大概就是传参的意思。<code>ecall</code>是从用户态转到内核态的指令。这样一来，就完成了从用户态到内核态的切换。</p>
<p>然后是在内核态的执行。</p>
<p>切换到内核态之后的执行步骤跟linux0.11可以说是完全一样。</p>
<p>首先应该是会去执行kernel/syscall.c中的syscall函数，具体应该是通过ecall引发0x80中断，然后查表得知这个syscall是中断处理函数</p>
<p><img src="/2023/01/10/xv6/image-20230105172110475.png" alt="image-20230105172110475.pn"></p>
<p>可以看到，syscall获取了a7里的参数，然后查了系统调用表</p>
<p><img src="/2023/01/10/xv6/image-20230105173019159.png" alt="image-20230105173019159"></p>
<p>然后去sysproc.c文件下执行相应的sys_xxx函数。这个函数指针用得真是牛逼。</p>
<p>再然后，sys_xxx函数中会从栈中取出调用参数，再跳转到xxx(args)函数中去（这些xxx函数一般在kernel中以单独文件形式出现）。</p>
<p>这样一来，就完成了一次系统调用。</p>
</li>
<li><p>linux0.11</p>
<p>首先是用户态到内核态的切换。</p>
<p>在用户态中比方说调用system call close()，则会调用lib/close.c下的：</p>
<p><img src="/2023/01/10/xv6/image-20230105173820813.png" alt="image-20230105173820813"></p>
<p>展开这个宏之后，是这样的：</p>
<p><img src="/2023/01/10/xv6/image-20230105173845317.png" alt="image-20230105173845317"></p>
<p>具体意思就是把close的系统调用号存入参数寄存器，然后引发0x80中断，进入内核态。</p>
<p>然后是在内核态的执行。</p>
<p>查表会得知sys_call函数是0x80中断的中断处理函数，然后就会根据参数里的系统调用名字去找系统调用表执行</p>
<p><img src="/2023/01/10/xv6/image-20230105174832400.png" alt="image-20230105174832400"></p>
<p>这部分跟xv6差不多，不再赘述</p>
</li>
</ol>
<p>可见，这两个系统在内核态的实现是差不多的，只是在用户态有点稍稍不一样。感觉linux0.11会更加精妙一些。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>附上代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//argc应该指的是arg count，包含了arg[0]（命令名称）</span></span><br><span class="line">  <span class="comment">//如果命令为“sleep”，那么就输出“sleep: missing operand”</span></span><br><span class="line">  <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;sleep:missing operand\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sleep(atoi(argv[i]))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;sleep:there has something wromng.Stop running.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写pingpong程序"><a href="#编写pingpong程序" class="headerlink" title="编写pingpong程序"></a>编写pingpong程序</h4><blockquote>
<p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a <strong>pair of pipes</strong>, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</pid></pid></pid></p>
</blockquote>
<h5 id="体会-1"><a href="#体会-1" class="headerlink" title="体会"></a>体会</h5><p>思路很简单，我之所以写了那么久是因为走了好大的弯路……</p>
<p>题目要求输出格式为”<pid>: received ping”，我的思路固化为：先把pid化成数字，再用字符串拼接串成整个。为了实现我的思路，我就需要额外再写两个工具函数，一个是itoa，一个是strcat。而又由于malloc函数暂待实现，itoa和strcat的实现就仍然不够优雅。折腾了半天终于OK了，结果看到别人是怎么做到这个输出格式的呢？↓</pid></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%d: received ping\n&quot;</span>,getpid());</span><br></pre></td></tr></table></figure>

<p>这下是真的尴尬了23333</p>
<p>但总而言之，自己写了那俩不够优雅的函数还算是有点用【大概】。以下是我的代码</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><h6 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h6><p>这三个函数都在<code>user/ulib.c</code>下。记得要在<code>user/user.h</code>中登记它们的签名。</p>
<p>由于使用不了malloc，所以实现会稍显复杂。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ensure_itoa_capacity</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        num = -num;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itoa</span><span class="params">(<span class="type">int</span> num,<span class="type">char</span>* res)</span>&#123;</span><br><span class="line">    <span class="type">char</span> res_tmp[<span class="built_in">strlen</span>(res)+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp = num;</span><br><span class="line">    <span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        tmp = -tmp;</span><br><span class="line">        res[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">        res_tmp[j++] = tmp%<span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        tmp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=j<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        res[i++] = res_tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">    res[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* s1,<span class="type">const</span> <span class="type">char</span>* s2)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">memcpy</span>(buf,s1,<span class="built_in">strlen</span>(s1));</span><br><span class="line">    <span class="built_in">memcpy</span>(buf+<span class="built_in">strlen</span>(s1),s2,<span class="built_in">strlen</span>(s2)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> byte[<span class="number">1</span>];</span><br><span class="line">    byte[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> p2[<span class="number">2</span>];</span><br><span class="line">    pipe(p1);</span><br><span class="line">    pipe(p2);</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">//接收ping的一个byte</span></span><br><span class="line">	close(p1[<span class="number">1</span>]);</span><br><span class="line">	read(p1[<span class="number">0</span>],byte,<span class="number">1</span>);</span><br><span class="line">	close(p1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造输出字符串并输出</span></span><br><span class="line">	<span class="type">int</span> pid = getpid();</span><br><span class="line">        <span class="type">char</span> pid_str[ensure_itoa_capacity(pid)];</span><br><span class="line">	itoa(pid,pid_str);	</span><br><span class="line">	<span class="type">char</span> meg_str[] = <span class="string">&quot;: received ping\n&quot;</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="built_in">strlen</span>(pid_str)+<span class="built_in">strlen</span>(meg_str)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcat</span>(buf,pid_str,meg_str);		</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="number">1</span>,buf);</span><br><span class="line">	<span class="comment">//fprintf(1,&quot;%d: received ping\n&quot;,getpid());</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//子进程发送pong</span></span><br><span class="line">	close(p2[<span class="number">0</span>]);</span><br><span class="line">	write(p2[<span class="number">1</span>],byte,<span class="number">1</span>);</span><br><span class="line">	close(p2[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	close(p1[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//p1的write端由父进程拿着</span></span><br><span class="line">	write(p1[<span class="number">1</span>],byte,<span class="number">1</span>);</span><br><span class="line">	close(p1[<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">//读取pong</span></span><br><span class="line">	close(p2[<span class="number">1</span>]);</span><br><span class="line">	read(p2[<span class="number">0</span>],byte,<span class="number">1</span>);</span><br><span class="line">	close(p2[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//构造</span></span><br><span class="line">	<span class="type">int</span> pid = getpid();</span><br><span class="line">        <span class="type">char</span> pid_str[ensure_itoa_capacity(pid)];</span><br><span class="line">	itoa(pid,pid_str);	</span><br><span class="line">	<span class="type">char</span> meg_str[] = <span class="string">&quot;: received pong\n&quot;</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="built_in">strlen</span>(pid_str)+<span class="built_in">strlen</span>(meg_str)+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcat</span>(buf,pid_str,meg_str);		</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="number">1</span>,buf);</span><br><span class="line">	<span class="comment">//fprintf(1,&quot;%d: received pong\n&quot;,getpid());</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写primes"><a href="#编写primes" class="headerlink" title="编写primes"></a>编写primes</h4><blockquote>
<p>参考：</p>
<p><a href="https://www.ewbang.com/community/article/details/960672708.html">MIT操作系统实验lab1（案例：primes（质数筛选）附代码、详解）</a></p>
<p><a href="https://blog.csdn.net/frost5/article/details/114933307">XV6实验-Lab0 Utilities</a></p>
</blockquote>
<blockquote>
<p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p>
</blockquote>
<p>其实就是用生产者消费者模式来写素数计算的并发版本，这个我熟</p>
<p>……以上是第一印象。然后我看着超链接文章里的素数筛的图片，以及指导书给的提示：</p>
<blockquote>
<p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p>
<ul>
<li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li>
</ul>
</blockquote>
<p>义无反顾地……使用了35个管道hhhhh</p>
<p>然后不知道为什么不行，也焦头烂额地感觉我思路太离谱了，去看了下发现大家都是只用一个管道……</p>
<p>我也搞了个单管道的出来，但是思路受第一篇的影响非常地串行，也即先筛完再创建子进程。看到</p>
<p><a href="https://blog.csdn.net/frost5/article/details/114933307">XV6实验-Lab0 Utilities</a></p>
<p>这篇文章，才发现还可以那样双管道并行……我虽然也考虑过双管道，但是觉得实现不了【因为我是用循环的思路，如果要双管道的话切换会很麻烦】就没写了，没想到还可以向他那样【他选择的是一个在外部定义的p，和一个作用域更小在每次循环内定义的p1，再加上递归传递参数这个技巧，就可以接连不断递归下去了】，深感佩服。写得是真好，可以去参考学习一下，我懒得改了（</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">	pipe(p);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="type">char</span> buf[<span class="number">3</span>];</span><br><span class="line">			<span class="comment">//读入第一个数字 </span></span><br><span class="line">			read(p[<span class="number">0</span>],buf,<span class="number">3</span>);</span><br><span class="line">			<span class="type">int</span> prime = atoi(buf);</span><br><span class="line">			<span class="keyword">if</span>(prime == <span class="number">36</span>)&#123;</span><br><span class="line">				close(p[<span class="number">0</span>]);</span><br><span class="line">				close(p[<span class="number">1</span>]);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;prime %d\n&quot;</span>,prime);</span><br><span class="line">			<span class="comment">//读入其他数字 </span></span><br><span class="line">			<span class="type">int</span> tmp = atoi(buf);</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">				read(p[<span class="number">0</span>],buf,<span class="number">3</span>);</span><br><span class="line">				tmp = atoi(buf);</span><br><span class="line">                <span class="comment">//输入结束</span></span><br><span class="line">				<span class="keyword">if</span>(tmp == <span class="number">36</span>)&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(tmp%prime!=<span class="number">0</span>)&#123;</span><br><span class="line">					write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//作为标记，标志着输入序列结束</span></span><br><span class="line">			itoa(<span class="number">36</span>,buf);</span><br><span class="line">			write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">			<span class="keyword">if</span>(fork())&#123;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				close(p[<span class="number">0</span>]);</span><br><span class="line">				close(p[<span class="number">1</span>]);</span><br><span class="line">				wait(<span class="number">0</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		close(p[<span class="number">0</span>]);</span><br><span class="line">		<span class="type">char</span> buf[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)&#123;</span><br><span class="line">			itoa(i,buf);</span><br><span class="line">			write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//作为标记，标志着输入序列结束</span></span><br><span class="line">		itoa(<span class="number">36</span>,buf);</span><br><span class="line">		write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">		close(p[<span class="number">1</span>]);</span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写find"><a href="#编写find" class="headerlink" title="编写find"></a>编写find</h4><blockquote>
<p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p>
</blockquote>
<h5 id="初始版"><a href="#初始版" class="headerlink" title="初始版"></a>初始版</h5><p>直接照着ls的模板改，改成递归就ok了。值得注意的是，目录也是一种文件，也可以通过read读取。目录文件的内容就是目录里的所有文件的名字。因而，我们在递归时可以忽略文件，只对目录处理，因为目录中就包含着所有文件名的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取出类似/root/home/a.txt中的a.txt</span></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27;\0&#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path,<span class="type">char</span>* key)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(st.type == T_DIR)&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">	  close(fd);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fmtname(buf),<span class="string">&quot;.&quot;</span>)!=<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(fmtname(buf),<span class="string">&quot;..&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">    	find(buf,key);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fmtname(buf),key) == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;find: have no arg.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="附加题：支持正则表达式"><a href="#附加题：支持正则表达式" class="headerlink" title="附加题：支持正则表达式"></a>附加题：支持正则表达式</h5><p>把user/grep.c里面的匹配函数拿来就行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">matchstar</span><span class="params">(<span class="type">int</span> c, <span class="type">char</span> *re, <span class="type">char</span> *text)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">matchhere</span><span class="params">(<span class="type">char</span> *re, <span class="type">char</span> *text)</span>;</span><br><span class="line"><span class="comment">//正則匹配函數</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">match</span><span class="params">(<span class="type">char</span> *re, <span class="type">char</span> *text)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> matchhere(re+<span class="number">1</span>, text);</span><br><span class="line">  <span class="keyword">do</span>&#123;  <span class="comment">// must look at empty string</span></span><br><span class="line">    <span class="keyword">if</span>(matchhere(re, text))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(*text++ != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchhere: search for re at beginning of text</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">matchhere</span><span class="params">(<span class="type">char</span> *re, <span class="type">char</span> *text)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> matchstar(re[<span class="number">0</span>], re+<span class="number">2</span>, text);</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">&#x27;$&#x27;</span> &amp;&amp; re[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> *text == <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span>(*text!=<span class="string">&#x27;\0&#x27;</span> &amp;&amp; (re[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span> || re[<span class="number">0</span>]==*text))</span><br><span class="line">    <span class="keyword">return</span> matchhere(re+<span class="number">1</span>, text+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchstar: search for c*re at beginning of text</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">matchstar</span><span class="params">(<span class="type">int</span> c, <span class="type">char</span> *re, <span class="type">char</span> *text)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;  <span class="comment">// a * matches zero or more instances</span></span><br><span class="line">    <span class="keyword">if</span>(matchhere(re, text))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(*text!=<span class="string">&#x27;\0&#x27;</span> &amp;&amp; (*text++==c || c==<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出类似/root/home/a.txt中的a.txt</span></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27;\0&#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path,<span class="type">char</span>* key)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(st.type == T_DIR)&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fmtname(buf),<span class="string">&quot;.&quot;</span>)!=<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(fmtname(buf),<span class="string">&quot;..&quot;</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(match(fmtname(buf),key))&#123;</span><br><span class="line">	    	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">      	&#125;</span><br><span class="line"></span><br><span class="line">    	find(buf,key);</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">//if(strcmp(fmtname(buf),key) == 0)&#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;find: have no arg.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写xargs"><a href="#编写xargs" class="headerlink" title="编写xargs"></a>编写xargs</h4><blockquote>
<p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p>
</blockquote>
<h5 id="体会-2"><a href="#体会-2" class="headerlink" title="体会"></a>体会</h5><p>思路还是很直观的，就是从stdin一行一行读入数据，然后把这数据处理成参数，最后调用exec就行。就是中间有很多小细节值得注意。</p>
<p>有一点比较坑的是，main方法的那个argc的计算方法是这样的，不是直接用数组的长度：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) </span><br></pre></td></tr></table></figure>

<p>可以看到，合格的argv的形式应该是：参1 参2 参3 “\0”，最后一个元素要以”\0”标志结束。</p>
<p>这个应该是编写者约定俗成的。在user/sh.c的parseexec，大概445行左右：</p>
<p><img src="/2023/01/10/xv6/image-20230106172133338.png" alt="image-20230106172133338"></p>
<p>shell处理命令时是会默认把最后一个清零的。</p>
<blockquote>
<p>确实，后面在学内存的时候，用户空间的构成如图所示：</p>
<p><img src="/2023/01/10/xv6/image-20230109234930690.png" alt="image-20230109234930690"></p>
<p>可以看到栈那边，参数列完了之后是会有一个用以terminate的空指针的</p>
</blockquote>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// for(int i=0;i&lt;argc;i++)	fprintf(1,&quot;argv[%d] = %s\n&quot;,i,argv[i]);</span></span><br><span class="line">    <span class="comment">//之所以写得这么曲折，是因为数组是const指针不能变值</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line">    <span class="type">char</span>* buf = buffer; </span><br><span class="line">    <span class="type">char</span>* start = buf;</span><br><span class="line">    <span class="comment">//如果xargs没有参数，就开启复读模式</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="keyword">while</span>((n = read(<span class="number">0</span>,buf,<span class="number">512</span>)))&#123;</span><br><span class="line">	    	write(<span class="number">1</span>,buf,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个必须写在外面，不能定义在下面的if体里，不然出了作用域就会被回收，不能作为参数的一员参与进exec，会变成很可怕的乱码。</span></span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">512</span>];</span><br><span class="line">    <span class="comment">//MAXARG为定义在kernel/param.h下的参数，代表参数最多值</span></span><br><span class="line">    <span class="type">char</span>* new_argv[MAXARG] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    argc--;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++)&#123;</span><br><span class="line">		new_argv[i] = argv[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(read(<span class="number">0</span>,buf,<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="comment">//fprintf(1,&quot;buf[0] is : %c\n&quot;,buf[0]);</span></span><br><span class="line">        <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(tmp,start,buf-start);</span><br><span class="line">            tmp[buf-start] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            new_argv[i++] = tmp;</span><br><span class="line">            argc++;</span><br><span class="line">            buf = start;</span><br><span class="line">           <span class="comment">// fprintf(1,&quot;tmp is :%s\n&quot;,tmp);</span></span><br><span class="line">            <span class="comment">//fprintf(1,&quot;new_argv[i-1] is :%s\n&quot;,new_argv[i-1]);</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            buf ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// fprintf(1,&quot;argc = %d\n&quot;,argc);</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    	exec(new_argv[<span class="number">0</span>],new_argv);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="附加题：改善shell"><a href="#附加题：改善shell" class="headerlink" title="附加题：改善shell"></a>附加题：改善shell</h4><p>看起来又难又多所以我先摸了【润】等之后有时间再回来弄吧</p>
<h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;utils&quot;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Operating system oganization</title>
    <url>/2023/01/10/xv6$chap2/</url>
    <content><![CDATA[<h1 id="Operating-system-oganization"><a href="#Operating-system-oganization" class="headerlink" title="Operating system oganization"></a>Operating system oganization</h1><blockquote>
<p>Before you start coding, read Chapter 2 of the <a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev1.pdf">xv6 book</a>, and Sections 4.3 and 4.4 of Chapter 4, and related source files:</p>
<ul>
<li>The user-space code for systems calls is in <code>user/user.h</code> and <code>user/usys.pl</code>.</li>
<li>The kernel-space code is <code>kernel/syscall.h</code>, kernel/syscall.c.</li>
<li>The process-related code is <code>kernel/proc.h</code> and <code>kernel/proc.c</code>.</li>
</ul>
</blockquote>
<p>这章主要是讲了操作系统为了兼顾并发性、隔离性、交互性做出的基本架构。</p>
<h2 id="Kernel-organization"><a href="#Kernel-organization" class="headerlink" title="Kernel organization"></a>Kernel organization</h2><h3 id="宏内核与微内核"><a href="#宏内核与微内核" class="headerlink" title="宏内核与微内核"></a>宏内核与微内核</h3><p>操作系统一个很重要的设计问题就是，哪部分的代码需要run在内核态，哪部分的需要run在用户态。</p>
<p>如果将操作系统所有系统调用统统都在内核态run，这种设计方式就叫宏内核<em>monolithic kernel</em>。</p>
<p>如果仅将系统调用中必要的部分在内核态run，其他部分都在用户态run，并且采取Client/Server这样的异步通信方式，这种设计方式就叫微内核<em>microkernel</em>。</p>
<p><img src="/2023/01/10/xv6/image-20230107232802540.png" alt="image-20230107232802540"></p>
<blockquote>
<p>由于客户/服务器（Client/Server）模式，具有非常多的优点，故在单机<a href="https://baike.baidu.com/item/%E5%BE%AE%E5%86%85%E6%A0%B8">微内核</a>操作系统中几乎无一例外地都采用客户/服务器模式，将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B">进程</a>)中实现。</p>
</blockquote>
<p>在微内核中，内核接口由一些用于启动应用程序、发送消息、访问设备硬件等的低级功能组成。这种组织允许内核相对简单，因为大多数操作系统驻留在用户级服务器中。</p>
<p>像大多数Unix操作系统一样，Xv6是作为一个宏内核实现的。因此，xv6内核接口对应于操作系统接口，内核实现了完整的操作系统。</p>
<h3 id="Code-xv6-organization"><a href="#Code-xv6-organization" class="headerlink" title="Code: xv6 organization"></a>Code: xv6 organization</h3><p>XV6的源代码位于<code>kernel</code>子目录中，源代码按照模块化的概念划分为多个文件，图2.2列出了这些文件，模块间的接口都被定义在了<code>def.h</code>（<code>kernel/defs.h</code>）。</p>
<table>
<thead>
<tr>
<th><strong>文件</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>bio.c</strong></td>
<td>文件系统的磁盘块缓存</td>
</tr>
<tr>
<td><strong>console.c</strong></td>
<td>连接到用户的键盘和屏幕</td>
</tr>
<tr>
<td><strong>entry.S</strong></td>
<td>首次启动指令</td>
</tr>
<tr>
<td><strong>exec.c</strong></td>
<td><code>exec()</code>系统调用</td>
</tr>
<tr>
<td><strong>file.c</strong></td>
<td>文件描述符支持</td>
</tr>
<tr>
<td><strong>fs.c</strong></td>
<td>文件系统</td>
</tr>
<tr>
<td><strong>kalloc.c</strong></td>
<td>物理页面分配器</td>
</tr>
<tr>
<td><strong>kernelvec.S</strong></td>
<td>处理来自内核的陷入指令以及计时器中断</td>
</tr>
<tr>
<td><strong>log.c</strong></td>
<td>文件系统日志记录以及崩溃修复</td>
</tr>
<tr>
<td><strong>main.c</strong></td>
<td>在启动过程中控制其他模块初始化</td>
</tr>
<tr>
<td><strong>pipe.c</strong></td>
<td>管道</td>
</tr>
<tr>
<td><strong>plic.c</strong></td>
<td>RISC-V中断控制器</td>
</tr>
<tr>
<td><strong>printf.c</strong></td>
<td>格式化输出到控制台</td>
</tr>
<tr>
<td><strong>proc.c</strong></td>
<td>进程和调度</td>
</tr>
<tr>
<td><strong>sleeplock.c</strong></td>
<td>Locks that yield the CPU</td>
</tr>
<tr>
<td><strong>spinlock.c</strong></td>
<td>Locks that don’t yield the CPU.</td>
</tr>
<tr>
<td><strong>start.c</strong></td>
<td>早期机器模式启动代码</td>
</tr>
<tr>
<td><strong>string.c</strong></td>
<td>字符串和字节数组库</td>
</tr>
<tr>
<td><strong>swtch.c</strong></td>
<td>线程切换</td>
</tr>
<tr>
<td><strong>syscall.c</strong></td>
<td>Dispatch system calls to handling function.</td>
</tr>
<tr>
<td><strong>sysfile.c</strong></td>
<td>文件相关的系统调用</td>
</tr>
<tr>
<td><strong>sysproc.c</strong></td>
<td>进程相关的系统调用</td>
</tr>
<tr>
<td><strong>trampoline.S</strong></td>
<td>用于在用户和内核之间切换的汇编代码</td>
</tr>
<tr>
<td><strong>trap.c</strong></td>
<td>对陷入指令和中断进行处理并返回的C代码</td>
</tr>
<tr>
<td><strong>uart.c</strong></td>
<td>串口控制台设备驱动程序</td>
</tr>
<tr>
<td><strong>virtio_disk.c</strong></td>
<td>磁盘设备驱动程序</td>
</tr>
<tr>
<td><strong>vm.c</strong></td>
<td>管理页表和地址空间</td>
</tr>
</tbody></table>
<p> <strong>图2.2：XV6内核源文件</strong></p>
<h2 id="Process-overview"><a href="#Process-overview" class="headerlink" title="Process overview"></a>Process overview</h2><p>内核用来实现进程的机制包括用户态内核态标志、地址空间和进程的时间切片。</p>
<p>为了帮助加强隔离，进程抽象给程序提供了一种错觉，即它有自己的专用机器。进程为程序提供了一个看起来像是私有内存系统或地址空间的东西，其他进程不能读取或写入。进程还为程序提供了看起来像是自己的CPU来执行程序的指令。</p>
<p>Xv6使用页表（由硬件实现）为每个进程提供自己的地址空间。RISC-V页表将虚拟地址（RISC-V指令操纵的地址）转换（或“映射”）为物理地址（CPU芯片发送到主存储器的地址）。</p>
<p>每个进程也有自己的页表，页表中记录了以虚拟地址0开始的内存区域。</p>
<p><img src="/2023/01/10/xv6/image-20230107233741922.png" alt="image-20230107233741922"></p>
<p>xv6内核为每个进程维护许多状态片段，并将它们聚集到一个<code>proc</code>(*<strong>kernel/proc.h*</strong>:86)结构体中。一个进程最重要的内核状态片段是它的页表、内核栈区和运行状态。我们将使用符号<code>p-&gt;xxx</code>来引用<code>proc</code>结构体的元素；例如，<code>p-&gt;pagetable</code>是一个指向该进程页表的指针。</p>
<blockquote>
<p>这应该相当于pcb表。</p>
</blockquote>
<h2 id="Code-starting-xv6-and-the-fifirst-process"><a href="#Code-starting-xv6-and-the-fifirst-process" class="headerlink" title="Code: starting xv6 and the fifirst process"></a>Code: starting xv6 and the fifirst process</h2><p>看完一遍说实话还乱乱的。。。。我整理整理跟linux的对比学习一下吧。</p>
<h3 id="xv6"><a href="#xv6" class="headerlink" title="xv6"></a>xv6</h3><h4 id="加载操作系统"><a href="#加载操作系统" class="headerlink" title="加载操作系统"></a>加载操作系统</h4><p>系统加电，启动BIOS初始化硬件 -&gt; BIOS从<u>引导扇区</u>将加载程序读入内存 -&gt; 加载程序将操作系统镜像读入内存RAM。</p>
<blockquote>
<p>这个过程由qemu模拟。</p>
<p>首先会通过<code>mkfs</code>造出操作系统镜像。然后由qemu将引导扇区，也即下面的filesys这图里的第0块：</p>
<p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<p>读入到主存中，然后开始执行引导扇区的程序，下同。</p>
</blockquote>
<p><code>boot loader</code>目的是把xv6加载进内存到<code>0x8000 0000</code>，然后跳转到xv6初始化程序。</p>
<blockquote>
<p>The reason it places the kernel at <code>0x80000000</code> rather than <code>0x0</code> is because the address range <code>0x0:0x80000000</code> contains <strong>I/O devices</strong>.</p>
</blockquote>
<h4 id="操作系统初始化"><a href="#操作系统初始化" class="headerlink" title="操作系统初始化"></a>操作系统初始化</h4><h5 id="entry-S配置栈空间"><a href="#entry-S配置栈空间" class="headerlink" title="entry.S配置栈空间"></a>entry.S配置栈空间</h5><p>此时，目前的机器状态是，1.没有开启地址映射，也即虚拟地址=真实物理地址。2.运行在machine mode</p>
<p>xv6会在<code>kernel/entry.S</code>下的这里开始执行，目的是<strong>配置好栈</strong>，以开始C语言代码<code>start.c</code>的执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # 这段主要是在计算栈顶指针sp</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">        # 已经有栈了，就可以开始执行C语言代码了</span><br><span class="line">        # jump to start()</span><br><span class="line">        call start</span><br></pre></td></tr></table></figure>

<p>其中start0：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br></pre></td></tr></table></figure>

<h5 id="start-c"><a href="#start-c" class="headerlink" title="start.c"></a>start.c</h5><p>在start.c中，我们的任务是在machine mode下，获取machine mode才能访问到的硬件参数，做在machine mode 下才能做的时钟初始化【 it programs the clock chip to generate timer interrupts】，然后进行machine mode到内核态的切换，最后跳转到main.c进行操作系统的初始化和第一个进程的启动。</p>
<p>而其中，如果想从machine mode切换到内核态，就需要使用<code>mret</code>指令。但是mret指令除了会切换mode之外，还有一个“ret”的作用，并且是从machine mode ret到内核态。</p>
<blockquote>
<p>This instruction( mret ) is most often used to return from a previous call from supervisor mode to machine mode.</p>
</blockquote>
<p>所以，我们实际上可以把最后两步连起来，用mret一个指令就完成。也即，mret指令既完成了从machine mode到内核态的切换，又完成了从start.c到main.c的跳转。</p>
<p>这其实很容易，只需在栈中将调用者（此时应该是entry.S）的地址替换为main.c的地址，并且将调用者的mode改为内核态，这样就ok了。</p>
<blockquote>
<p> it sets the <strong>previous privilege mode</strong> to supervisor in the register mstatus, it sets the <strong>return address</strong> to main by writing main’s address into the register mepc, <strong>disables virtual address translation in supervisor mode</strong> by writing 0 into the page-table register satp, and <strong>delegates all interrupts and exceptions to supervisor mode</strong></p>
<p> 后面两点不大明白。为什么为了mret，就还得让内核态跟machine mode一样关闭虚拟地址映射，还得把什么中断和异常委托给内核态【这个委托是完全没搞懂是什么意思】？？</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//修改调用者为内核态</span></span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h5><p>main.c的作用是做很多很多init。其中，它通过<code>userinit();</code>来创建第一个进程，这个第一个进程再由main调用<code>scheduler()</code>来被调度执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//...很多很多init</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    RISC-V的处理器对底层提供了一种特殊的抽象,Hardware Thread,简称为Hart。简单来说,Hart是真实物理CPU(bare metal)提供的一种模拟</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用第一个scheduler，完成对scheduler线程的初始化，并且调度去执行第一个进程</span></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：关于里面的cpuid，我查了一下，指的是CPU的序列号，用来唯一标识cpu的。我想这个if架构的目的应该跟<code>fork()==0</code>差不多。也就是说，一开始的那个init仅有<code>cpuid==0</code>的CPU执行，其他的CPU就乖乖wait，只有CPU0执行初始化的程序。等到CPU0执行完所有init，才置标记位start=1，然后通过锁<code>__sync_synchronize();</code>开始抢占调度，轮流初始化自己。</p>
</blockquote>
<h5 id="proc-c中的userinit"><a href="#proc-c中的userinit" class="headerlink" title="proc.c中的userinit()"></a>proc.c中的userinit()</h5><p>userinit的作用就是新创建一个进程信息proc，然后开始给第一个程序（initcode）填信息填入proc。这个进程创建完后，在main中的scheduler被调度执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请一页，将initcode的指令和数据放进去</span></span><br><span class="line">  <span class="comment">// allocate one user page and copy initcode&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvmfirst(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为内核态到用户态的转变做准备</span></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Trap Frame是指中断、自陷、异常进入内核后,在堆栈上形成的一种数据结构</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改进程名</span></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个也许是为了能被优先调度</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="initcode-S"><a href="#initcode-S" class="headerlink" title="initcode.S"></a>initcode.S</h5><p>以上程序都位于<code>kernel/</code>下。这个位于<code>user/</code>下。</p>
<p>它调用exec系统调用进入了内核态。当exec完成后，它就跳转到了用户态<code>user/init.c</code>中。【这里估计又用了修改返回地址的trick】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure>

<h5 id="init-c"><a href="#init-c" class="headerlink" title="init.c"></a>init.c</h5><p>在init.c中，创建了console设备文件，打开了012文件描述符，并且fork了一个子进程，开始执行shell。这样一来，操作系统就完成了全部的启动。</p>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><blockquote>
<p>我的疑点有三个：</p>
<ol>
<li>见start.c</li>
<li>是怎么完成从内核态到用户态的切换的？是执行了return就会自动切换吗？userinit中设置了initcode的信息为用户态的，然后就直接能进入用户态，这里感觉有点模糊。</li>
<li>什么时候开启地址映射的？</li>
</ol>
<p>除了这些外，都是很清晰明了的，步骤十分直接且有理由：</p>
<p>加载操作系统——为了能执行C语言需要一个栈，所以得执行造一个的代码，然后再进入C语言zone——做点machine mode才能做的事，然后从machine mode切换到内核态——做点内核态才能做的事，从内核态切换到用户态</p>
</blockquote>
<h3 id="linux0-11"><a href="#linux0-11" class="headerlink" title="linux0.11"></a>linux0.11</h3><p>bootsect -&gt; setup -&gt; head.s -&gt;main.c</p>
<h4 id="加载操作系统-1"><a href="#加载操作系统-1" class="headerlink" title="加载操作系统"></a>加载操作系统</h4><p>系统加电，启动BIOS初始化硬件 -&gt; BIOS从<u>引导扇区</u>将加载程序读入内存 -&gt; 加载程序将操作系统镜像读入内存RAM。</p>
<p>其中，第二三步做进一步的细化。</p>
<h5 id="读入bootsect-s"><a href="#读入bootsect-s" class="headerlink" title="读入bootsect.s"></a>读入bootsect.s</h5><p>加载程序的512个字节被读入到内存从<code>0x7c00</code>开始的一段内存中，并且BIOS设置<code>CS=07c0,ip=0</code>，开始执行加载程序的每一条指令。</p>
<h5 id="bootsect-s"><a href="#bootsect-s" class="headerlink" title="bootsect.s"></a>bootsect.s</h5><p>加载程序的代码为<code>bootsect.s</code>。在<code>bootsect.s</code>中，首先将自身从<code>7c00</code>处移动到了<code>9000</code>处【留下空间放操作系统】，然后分别依次读取磁盘的<u>setup</u>和<u>system</u>模块，最后bootsect将控制权转交给setup。</p>
<h5 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h5><p>setup首先获取操作系统运行的<strong>必要硬件参数</strong>。</p>
<p><img src="/2023/01/10/xv6/image-20230108011824655.png" alt="image-20230108011824655"></p>
<p>再然后，<u>将system代码移到0地址</u>。然后，我们就需要进入system代码块。</p>
<p><img src="/2023/01/10/xv6/image-20230108012316631.png" alt="image-20230108012316631"></p>
<p>最后一句jmpi指令本来应该是要跳到system代码段首0地址处的的，可此处却跳到了80处，这显然不合理。但它写的肯定是没错的。之所以会有这样的矛盾，是因为setup在此之前，还做了一件事情：<strong>改变寻址方式</strong>。jmpi上面的那条mov指令便做了这点。</p>
<p>我们之前的寻址方式一直是<code>cs&lt;&lt;4+ip</code>。但是这东西只能是16位的内存，<u>无法满足寻址需求</u>。故而setup要从16位切换到32位。32位模式也叫保护模式。</p>
<blockquote>
<p>至于怎么切的呢？要注意到一点，改变寻址方式也即改变cs和ip的地址计算方法，也即换一条硬件电路实现。计算机给我们提供了一个简单的方式操纵保护模式的转变，即修改cr0寄存器的内容。</p>
</blockquote>
<p>在保护模式下，寻址方式发生了改变。此时cs不再代表基址，而是表示地址在gdb表<code>global description table</code>中的偏移下标。真正的基址放在表项中。cs被称为selector，从表中取得基址，再和ip加在一起得到地址。</p>
<blockquote>
<p>gdt表的内容由setup初始化</p>
<p><img src="/2023/01/10/xv6/image-20230108013156116.png" alt="image-20230108013156116"></p>
</blockquote>
<p>这样一来，就正确跳到了system模块。</p>
<h4 id="操作系统初始化-1"><a href="#操作系统初始化-1" class="headerlink" title="操作系统初始化"></a>操作系统初始化</h4><h5 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h5><p>跳到system第一个文件，也就是head.s去执行。</p>
<p>head.s也是在保护模式下进行的，是在保护模式下的初始化。</p>
<p>head.s建立了真正的gdt表，然后就要跳转到main.c执行初始化和Shell的启动。此处有汇编语言和C语言的转化，也就是push参数然后push main的地址。</p>
<h5 id="main-c-1"><a href="#main-c-1" class="headerlink" title="main.c"></a>main.c</h5><p>对各种东西的初始化。</p>
<p><img src="/2023/01/10/xv6/image-20230108013849664.png" alt="image-20230108013849664"></p>
<p>最后完成从内核态到用户态的切换。</p>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><blockquote>
<p>linux0.11的启动的具体思路是：</p>
<p>加载操作系统，获取硬件参数，进入保护模式，跳转到操作系统第一行代码——操作系统初始化，切换到用户态</p>
<p>linux0.11相比于xv6更加复杂，上课的时候隐藏了很多实现细节但依旧理解很费劲（。</p>
<p>这两个步骤思路其实都是差不多的，区别在于linux0.11好像没有machine mode这个概念。感觉也不能锐评什么，因为看完了感觉两个都很有道理，两个都一样很难懂（。</p>
<p>【注：为什么没有machine mode呢？是因为这个mode的划分是RISC-V架构做的，而linux0.11是基于X86架构。】</p>
<p>不过linux0.11这里进入保护模式后改变寻址方式是因为机器问题（好像是），xv6难道也是因为硬件问题吗？因为一开始的时候操作系统还未进行内存分页页表初始化，所以用不了地址映射？有待学习。</p>
<p>关于保护模式，可以看看这篇文章，今天太晚了先睡了：</p>
<p><a href="https://blog.51cto.com/u_15082498/5527746"><strong>Linux从头学08：Linux 是如何保护内核代码的？【从实模式到保护模式】</strong></a></p>
</blockquote>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><p>现实中，大多数操作系统都会兼顾宏内核与微内核。</p>
<p>大多数操作系统都支持与xv6类似的process进程概念，也有很多系统还支持线程概念。</p>
<h2 id="Lab-system-calls"><a href="#Lab-system-calls" class="headerlink" title="Lab system calls"></a>Lab system calls</h2><blockquote>
<p>To start the lab, switch to the syscall branch:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout syscall</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><blockquote>
<p>In this assignment you will add a system call tracing feature that may help you when debugging later labs.</p>
<p>You’ll create a new <code>trace</code> system call that will control tracing. It should take <strong>one argument,</strong> an integer “mask”, whose bits specify which system calls to trace. </p>
<p>For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>. You have to modify the xv6 kernel to <strong>print out a line when each system call is about to return</strong>. The line should contain the <strong>process id</strong>, the <strong>name</strong> of the system call and the <strong>return value</strong>; you don’t need to print the system call arguments. </p>
<p>The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p>
</blockquote>
<h4 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h4><p>一开始为了把trace做得封装性良好一些尽量不改别的代码，想了好久好久，最后就只能想出，在syscall.c获取系统调用返回值处加个条件打印，在trace中维护一个map，映射进程pid和进程当前的mask，并且给外界提供查询当前进程是否对某个系统调用有mask作为syscall条件打印的接口。</p>
<p>这个最后还是失败了，失败的点在于不知道要创建多大的数组来作为map映射所有进程，因为pid分配估计是递增的，是会超过最大进程数的，所以pid会是多少是不确定的。还有一点就是fork之后子进程不能自动继承父进程的mask，还得手动调用一下trace，这更加不封装了（。</p>
<p>总之先放上我原来的代码吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/syscall.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* tmp)</span>&#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((*tmp)!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">    buf[i++] = *tmp;</span><br><span class="line">    tmp++;</span><br><span class="line">  &#125;  </span><br><span class="line">  buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getname</span><span class="params">(<span class="type">int</span> callid,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(callid)&#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_fork: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fork&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exit: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exit&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_wait: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;wait&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_pipe: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;pipe&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_read: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;read&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_kill: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;kill&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exec: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exec&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_fstat: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fstat&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_chdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;chdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_dup: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;dup&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getpid: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;getpid&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sbrk: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sbrk&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sleep: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sleep&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_uptime: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;uptime&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_open: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;open&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_write: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;write&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mknod: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mknod&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_unlink: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;unlink&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_link: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;link&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mkdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mkdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_close: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;close&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_trace: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;trace&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    getname(num,buf);</span><br><span class="line">    <span class="comment">// 在此处添加条件打印</span></span><br><span class="line">    <span class="keyword">if</span>(istraced(num))</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;syscall %s -&gt; %d\n&quot;</span>,buf,p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trace.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_mask[NPROC];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    m_mask[p-&gt;pid] = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供给外界查询的接口</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">istraced</span><span class="params">(<span class="type">int</span> callid)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">//printf(&quot;from trace ,pid = %d\n&quot;,p-&gt;pid);</span></span><br><span class="line">    <span class="keyword">if</span>(((m_mask[p-&gt;pid] &gt;&gt; callid) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是按照hints修改后的正确代码。</p>
<h4 id="代码步骤"><a href="#代码步骤" class="headerlink" title="代码步骤"></a>代码步骤</h4><p>实际上，标答跟我的思路差不多，只不过它没有像我一样创建数组作为map，而是在proc结构体里添加了一个属性，这本质上也是利用了map。</p>
<h5 id="在各种文件添加签名"><a href="#在各种文件添加签名" class="headerlink" title="在各种文件添加签名"></a>在各种文件添加签名</h5><h6 id="user-user-h"><a href="#user-user-h" class="headerlink" title="user/user.h"></a>user/user.h</h6><h6 id="user-usys-pl"><a href="#user-usys-pl" class="headerlink" title="user/usys.pl"></a>user/usys.pl</h6><h6 id="syscall-h"><a href="#syscall-h" class="headerlink" title="syscall.h"></a>syscall.h</h6><p>添加系统调用号</p>
<h6 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h6><p>添加系统调用号和sys_trace映射</p>
<h6 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改Makefile</h6><ol>
<li>在第一个OBJS添加trace.o</li>
<li>在UPROGS添加user中的trace</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><h6 id="修改proc-h"><a href="#修改proc-h" class="headerlink" title="修改proc.h"></a>修改proc.h</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> mask; <span class="comment">//记录trace的mask</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="编写trace-c"><a href="#编写trace-c" class="headerlink" title="编写trace.c"></a>编写trace.c</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;mask = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">istraced</span><span class="params">(<span class="type">int</span> callid)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span>(((p-&gt;mask &gt;&gt; callid) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="修改syscall-c"><a href="#修改syscall-c" class="headerlink" title="修改syscall.c"></a>修改syscall.c</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/syscall.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* tmp)</span>&#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((*tmp)!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">    buf[i++] = *tmp;</span><br><span class="line">    tmp++;</span><br><span class="line">  &#125;  </span><br><span class="line">  buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getname</span><span class="params">(<span class="type">int</span> callid,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(callid)&#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_fork: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fork&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exit: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exit&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_wait: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;wait&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_pipe: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;pipe&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_read: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;read&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_kill: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;kill&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exec: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exec&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_fstat: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fstat&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_chdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;chdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_dup: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;dup&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getpid: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;getpid&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sbrk: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sbrk&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sleep: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sleep&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_uptime: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;uptime&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_open: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;open&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_write: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;write&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mknod: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mknod&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_unlink: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;unlink&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_link: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;link&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mkdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mkdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_close: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;close&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_trace: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;trace&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    getname(num,buf);</span><br><span class="line">    <span class="comment">// 在此处添加条件打印</span></span><br><span class="line">    <span class="keyword">if</span>(istraced(num))</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;syscall %s -&gt; %d\n&quot;</span>,buf,p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="在sysproc-c中添加系统调用"><a href="#在sysproc-c中添加系统调用" class="headerlink" title="在sysproc.c中添加系统调用"></a>在sysproc.c中添加系统调用</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>,&amp;mask)&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  trace(mask);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="在defs-h中添加需要public的函数签名"><a href="#在defs-h中添加需要public的函数签名" class="headerlink" title="在defs.h中添加需要public的函数签名"></a>在defs.h中添加需要public的函数签名</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trace.c</span></span><br><span class="line"><span class="type">int</span>		<span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span>		<span class="title function_">istraced</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="sysinfotest"><a href="#sysinfotest" class="headerlink" title="sysinfotest"></a>sysinfotest</h3><blockquote>
<p>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. </p>
<p>The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). </p>
<p>The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code> field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. </p>
<p>We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysinfo.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> &#123;</span></span><br><span class="line">  uint64 freemem;   <span class="comment">// amount of free memory (bytes)</span></span><br><span class="line">  uint64 nproc;     <span class="comment">// number of process</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="感想-3"><a href="#感想-3" class="headerlink" title="感想"></a>感想</h4><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>系统调用要做的事情同上。</p>
<p>有一个我在hit实验没想到，在这里<strong>依然没有想到</strong>的点是，参数的指针来自用户空间，所以不能直接对其指向的空间进行写入，需要借助copyout函数。</p>
<p>还有一件事，就是不知道该怎么统计free mem的数量，后来在hints提示下才知道要去kalloc.c中找。【之前只找过了vm.c】这里其实是很后悔提前看了提示的。我应该先去看一下上面关于kernel各个文件用途的笔记，再去继续自己找的，不能太过依赖提示。</p>
<p>还有一点做的不好的地方是，标答是选择了将两个计数函数放在各自的文件中，我是选择直接将成员变量在头文件中extern 公开出来，比如说在proc.h中这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br></pre></td></tr></table></figure>

<p>hints采取了比我封装性更好的操作，这也是非常顺理成章的，我没有想到这样真是有点惭愧（。</p>
<p>总而言之，这个还是挺简单的，就是我很后悔我心浮气躁看了提示，要不然收获会更多。</p>
<h5 id="sysinfo-c"><a href="#sysinfo-c" class="headerlink" title="sysinfo.c"></a>sysinfo.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysinfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo* info)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">res</span>;</span></span><br><span class="line">  res.nproc = countproc();</span><br><span class="line">  res.freemem = countfree();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, (uint64)info,(<span class="type">char</span> *)(&amp;res), <span class="keyword">sizeof</span>(res)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sysproc-c中"><a href="#sysproc-c中" class="headerlink" title="sysproc.c中"></a>sysproc.c中</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> sysinfo((<span class="keyword">struct</span> sysinfo*)addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="kalloc-c中"><a href="#kalloc-c中" class="headerlink" title="kalloc.c中"></a>kalloc.c中</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用的是链表结构，run代表一页</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="comment">// 指向第一个空闲页</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">countfree</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> npage = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span>* <span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">    npage++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> npage*PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="proc-c中"><a href="#proc-c中" class="headerlink" title="proc.c中"></a>proc.c中</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">countproc</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NPROC;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(proc[i].state != UNUSED)&#123;</span><br><span class="line">	  nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nproc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h4><h5 id="trace-plus"><a href="#trace-plus" class="headerlink" title="trace plus"></a>trace plus</h5><blockquote>
<p>Print the system call arguments for traced system calls.</p>
</blockquote>
<p>这个实现起来要说简单也简单，麻烦也麻烦。这里就先摆了【实际上尝试了半小时发现太烦了看别人写的也不大满意就放弃了】</p>
<h5 id="sysinfo-plus"><a href="#sysinfo-plus" class="headerlink" title="sysinfo plus"></a>sysinfo plus</h5><blockquote>
<p>Compute the load average and export it through sysinfo</p>
</blockquote>
<p>说实话没太看懂，不就加个 running process/ncpu就行了吗？</p>
]]></content>
  </entry>
  <entry>
    <title>Page tables</title>
    <url>/2023/01/10/xv6$chap3/</url>
    <content><![CDATA[<h1 id="Page-tables"><a href="#Page-tables" class="headerlink" title="Page tables"></a>Page tables</h1><blockquote>
<p>页表学完后，还有一个点就是，xv6有没有实现内存的换入换出呢？</p>
<p>印象中，xv6从操作系统读入，一直到目前写程序，似乎一直都是获得虚拟地址，通过虚拟地址访问物理内存地址，好像从来没有考虑过物理内存和磁盘间的换入换出。</p>
<p>是xv6没有实现这个机制，还是还没讲到呢？此处有待发掘。</p>
</blockquote>
<h2 id="Paging-hardware"><a href="#Paging-hardware" class="headerlink" title="Paging hardware"></a>Paging hardware</h2><h3 id="为什么需要页表"><a href="#为什么需要页表" class="headerlink" title="为什么需要页表"></a>为什么需要页表</h3><p>将主存储器以及各种外设接口卡里面内置的存储器连接起来，就形成了内存地址空间。内存地址空间中的地址是真实的物理地址。RISC-V架构的指令使用的地址是虚拟地址。为了通过指令中的虚拟地址访问到真实的物理内存，需要进行从虚拟地址到物理地址的转换。从虚拟地址到物理地址的转换，就需要通过页表来实现。</p>
<h3 id="页表组成"><a href="#页表组成" class="headerlink" title="页表组成"></a>页表组成</h3><h4 id="页表项"><a href="#页表项" class="headerlink" title="页表项"></a>页表项</h4><p>页表由页表项PTE（Page Table Entries）构成，每个页表项由44位的PPN（Physical Page Number）和一些参数flag组成。</p>
<p><img src="/2023/01/10/xv6/image-20230109153937459.png" alt="image-20230109153937459"></p>
<blockquote>
<p>Each PTE contains flflag bits that tell the paging hardware how the associated virtual address is allowed to be used. <strong>PTE_V</strong> indicates whether the PTE is <u>present</u>: if it is not set, a reference to the page causes an exception (i.e. is not allowed). <strong>PTE_R</strong> controls whether instructions are allowed to <u>read</u> to the page. PTE_W controls whether instructions are allowed to write to the page. <strong>PTE_X</strong> controls whether the CPU may interpret the content of the page <u>as instructions and execute them</u>. <strong>PTE_U</strong> controls whether instructions in <u>user</u> mode are allowed to <u>access</u> the page; if PTE_U is not set, the PTE can be used only in supervisor mode.</p>
<p>这个表项的几个参数定义在kernel/riscv.h中的341行左右。</p>
</blockquote>
<p>虚拟地址有64bit，其中25bits未使用，39bits包含了27位的PTE索引号以及12位的offset。</p>
<p>物理地址有56位，由PPN和offset拼接组成。</p>
<h4 id="单页表和多级页表"><a href="#单页表和多级页表" class="headerlink" title="单页表和多级页表"></a>单页表和多级页表</h4><p>以单页表为例，物理地址形成过程如下图所示。</p>
<p><img src="/2023/01/10/xv6/pagetable.png" alt="image"></p>
<p><u>每个页表项PTE索引着一页</u>。因而，每一页的大小为2^12=4096B。单页表中PTE的索引号有2^27个，因而单页表中表项有134217728个，即可以代表134217728页。页表实际上也是以页的形式存储的。因而单页表需要的存储空间为(2^27x7)/2^12=2^15x7=229376页。</p>
<p>RISC-V架构中真实情况是会有三级页表。三级页表结构相比于单级页表结构，会占据更多的<strong>物理存储空间</strong>。</p>
<p><img src="/2023/01/10/xv6/image-20230109151346780.png" alt="image-20230109151346780"></p>
<p><u>每个页表项PTE索引着一页，这一页可能代表着另一个页表，也可能代表着内存中需要的指令和数据</u>。因而，每一页的大小为2^12=4096B。三页表中，一级页表中PTE的索引号有512个，可以代表的物理内存页数有512x515x512=2^27页，即可以代表134217728页。页表实际上也是以页的形式存储的，一个页表有2^9x7个字节，可以存储在1页中。因而三页表需要的存储空间为1+2^9+2^18 = 262657页。</p>
<p>三级页表结构相比于单级页表结构，可以节省更多<strong>内存空间</strong>。</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/fuyuande/article/details/117616433">页表是啥以及为啥多级页表能够节省空间</a></p>
</blockquote>
<p>考虑到这样一个进程：</p>
<p><img src="/2023/01/10/xv6/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1eXVhbmRl,size_16,color_FFFFFF,t_70.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1eXVhbmRl,size_16,color_FFFFFF,t_70"></p>
<p>进程使用页表时，需要将整个页表读入内存。</p>
<p>如果使用单级页表，尽管一个进程仅使用到页表中的某两项，也需要把整个页表都读入内存，光是页表就占据了2^15x7x4k/2^20 约为1G的内存空间。</p>
<p>如果使用三级页表，一个进程需要用到某两页。假设这两页存储在不同的二级页表中，则只需要读入1+2+2=5页 约为20K的内存空间。</p>
<p>两者相对比，显然用三级页表比单级页表顶多了。三级页表相较于一级页表，多用了13%的物理空间，却可以节省99.998%的空间。</p>
<h3 id="页表使用"><a href="#页表使用" class="headerlink" title="页表使用"></a>页表使用</h3><p>每个进程会保留自己的一份用户级别的页表地址。当轮到自己使用CPU时，会将CPU的satp寄存器更换为自己的页表地址。</p>
<h2 id="Kernel-address-space"><a href="#Kernel-address-space" class="headerlink" title="Kernel address space"></a>Kernel address space</h2><p>介绍了xv6中内核的页表结构。</p>
<blockquote>
<p>这里为了方便，就把三级页表省略了，只留下va和pa的对比</p>
</blockquote>
<p>每个进程都有一个用户级别的页表。xv6给内核提供了一个单独的内核地址空间的页表。其层级映射关系如下：</p>
<p><img src="/2023/01/10/xv6/p3.png" alt="p3"></p>
<p>在kernel/memlayout.h中正记录了这些参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Physical memory layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu -machine virt is set up like this,</span></span><br><span class="line"><span class="comment">// based on qemu&#x27;s hw/riscv/virt.c:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 00001000 -- boot ROM, provided by qemu</span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT</span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC</span></span><br><span class="line"><span class="comment">// 10000000 -- uart0 </span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk </span></span><br><span class="line"><span class="comment">// 80000000 -- boot ROM jumps here in machine mode</span></span><br><span class="line"><span class="comment">//             -kernel loads the kernel here</span></span><br><span class="line"><span class="comment">// unused RAM after 80000000.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel uses physical memory thus:</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S, then kernel text and data</span></span><br><span class="line"><span class="comment">// end -- start of kernel page allocation area</span></span><br><span class="line"><span class="comment">// PHYSTOP -- end RAM used by the kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// core local interruptor (CLINT), which contains the timer.</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>由图可知，一直从0x0到0x86400000，都是采取的<strong>直接映射</strong>的方式，虚拟地址=物理地址，这段是内核使用的空间。在0x0-0x800000000阶段，物理地址代表着各种IO设备的存储器。</p>
<p>但是注意，在0x86400000（PHYSTOP）以上的地址都不是直接映射，这些非直接映射的层级包含两类：</p>
<ol>
<li><p>trampoline</p>
<blockquote>
<p>It is mapped at the top of the virtual address space; user page tables have this same mapping. </p>
</blockquote>
<p>它有一点很特殊的是，它实际对应的物理内存是0x80000000开始的一段。也就是说，0x80000000开始的这段内存，既被直接映射了，也被trampoline通过虚拟地址映射了。它被映射了两次。</p>
</li>
<li><p>内核栈</p>
<blockquote>
<p>Each process has its own kernel stack, which is mapped high so that below it xv6 can leave an unmapped <em>guard page</em>. The guard page’s PTE is invalid (i.e., <u>PTE_V is not set</u>), so that if the kernel <strong>overflflows</strong> a kernel stack, it will likely cause an exception and the kernel will panic.</p>
<p>guard page可以用来防止内核栈溢出。</p>
</blockquote>
</li>
</ol>
<p>内核使用PTE_R和PTE_X权限映射trampoline和kernel text。这表明这份内存段可以读，可以被当做指令块执行，但不能写。其他的块都是可读可写的，除了guard page被设置为不可访问。</p>
<h2 id="Code-creating-an-address-space"><a href="#Code-creating-an-address-space" class="headerlink" title="Code: creating an address space"></a>Code: creating an address space</h2><h3 id="vm-c"><a href="#vm-c" class="headerlink" title="vm.c"></a>vm.c</h3><p>操作地址空间和页表部分的代码都在<code>kernel/vm.c</code>中。代表页表的数据结构是<code>pagetable_t</code>。</p>
<p>vm.c的主要函数有walk、mappages等。walk用来在三级页表中找到某个虚拟地址表项，或者创建一个新的表项。mappages用来新建一个表项，主要用到了walk函数。</p>
<p>vm.c中，以kvm开头的代表操纵内核页表，以uvm开头的代表操纵进程里的用户页表。</p>
<h4 id="以初始化为例介绍各个函数"><a href="#以初始化为例介绍各个函数" class="headerlink" title="以初始化为例介绍各个函数"></a>以初始化为例介绍各个函数</h4><h5 id="创建页表"><a href="#创建页表" class="headerlink" title="创建页表"></a>创建页表</h5><p>一开始操作系统初始化时，会调用vm.c中的kvminit来创建内核页表。主要就是在以内核地址空间的页表结构在填写页表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//内核页表</span></span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line">  <span class="comment">//申请新的一页</span></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//给内核页表初始化表项，结构详见上面的内核地址空间部分</span></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，kvmmap用来在内核页表中添加一个新的表项。其函数形式为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现主要逻辑的是mappages函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">//walk函数通过虚拟地址新建一个第三级页表的表项并返回其指针，之后只需要填这个表项即可</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果pte存在并且标记为已使用，说明该虚拟地址映射已经存在</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    <span class="comment">//填写表项：物理地址 flags</span></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//每两个表项间隔PGSIZE个字节</span></span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过虚拟地址获取表项主要是通过walk实现的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="comment">// 虚拟地址的格式：UNUSED 页表索引 offset，其中页表索引在三级页表中被划分为了三个，分别是</span></span><br><span class="line"><span class="comment">// level0-level2，分别代表了第三级、第二级、第一级页表的索引【具体可见页表组成中的图】</span></span><br><span class="line"><span class="comment">// walk的目的就是要在这三级页表中找到虚拟地址对应的页表项。当alloc!=0时，则要求找不到就新建一个</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// 取出PTE中表示下一级页表地址的字节</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 页表不存在的情况，要么返回0，要么新建一页</span></span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终返回第三级页表的对应表项</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="装上页表"><a href="#装上页表" class="headerlink" title="装上页表"></a>装上页表</h5><p>使用的是kvminithart函数。它将内核页表的root page table的物理地址写入了satp寄存器。从这个函数之后，就<strong>开启了内存映射</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// wait for any previous writes to the page table memory to finish.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line"></span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flush stale entries from the TLB.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中sfence_vma()的用途是强制更新TLB的旧页表，类似于Java volatile的作用。</p>
<h6 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h6><p>附上书里的详细解释：</p>
<p><img src="/2023/01/10/xv6/image-20230109222917346.png" alt="image-20230109222917346"></p>
<p>TLB与页表类似于cache与主存的关系。TLB保存了页表的一部分。</p>
<h6 id="我的错误想法"><a href="#我的错误想法" class="headerlink" title="我的错误想法"></a>我的错误想法</h6><p>我怎么感觉怪怪的啊？因为TLB既然是高速缓存，那么读写页表也应该优先从TLB读写【注：应该就是从这里开始错的hhh写应该是直接写入页表】。所以说，会陈旧的应该是主存中的页表，而不是TLB中的页表。但是，书里是说，改完页表必须通知TLB更改。也就是说，读写页表不是从TLB读写的，那该是从哪里？是TLB以外的free memory吗？</p>
<p>不过，要是从多CPU的角度思考，说不定他这个意思是某个CPU的TLB变了，需要通知其他所有CPU的TLB也变。虽然不同CPU当前执行的进程是不一样的，使用的页表项不一样，切换进程的时候也会把用户地址空间的页表项flush掉。但是内核地址空间的页表项一般是不会随着进程切换而flush掉的。所以内核页表修改就需要手动多CPU同步。</p>
<p>我认为多CPU角度考虑更加合理，因为它最后说了，xv6会在内核页表init后flush，以及在从内核态切换回用户态的时候flush。这两个（好像）都影响内核页表比较多，所以就需要手动flush一下。</p>
<h6 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h6><p>之后学了缺页异常后，可以发现这里其实是没问题的。</p>
<p><a href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq">计算机体系结构 – 虚拟内存</a></p>
<p><img src="/2023/01/10/xv6/v2-e15454bf032baa4dc088b6e41ed4f4a4_1440w.jpg" alt="v2-e15454bf032baa4dc088b6e41ed4f4a4_1440w"></p>
<p>页表的管理（创建、更新、删除等）是由操作系统负责的。地址转换时，页表检索是由硬件内存管理单元（Memory Management Unit, MMU）负责的。MMU通常由两部分构成：表查找单元（Table Walk Unit, TWU）和转换旁路缓冲（Translation Lookaside Buffer, TLB）[<a href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_2">2]</a>。TWU负责链式的访问PDE、PTE，完成上述的查表过程。</p>
<p>应用多级页表之后，想要完成一次地址转换，需要访问多级目录和页表，这么多次的内存访问会严重降低性能。</p>
<p>为了优化地址转换速度，人们在MMU中增加了一块高速cache，专门用来缓存虚拟地址到物理地址的映射，这块cache就是TLB[<a href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_7">7]</a>[<a href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_8">8]</a>。MMU在做地址转换的时候，会先检索TLB，如果命中则直接返回对应的物理地址，如果不命中则会调用TWU查找页表。</p>
<p>TLB中缓存的是虚拟地址到物理地址映射。然而，多级页表的查找是一个链式的过程，对于在虚拟地址空间中连续的两个页，它们的各级目录项可能都是一样的，只有最后一级页号不一样。查找完第一个虚拟页之后，我们可以将相同的前级目录项都缓存起来。查找第二个虚拟页时，可以直接使用缓存好的前几级目录项，节省查找时间。这种缓存叫做Page Structure Cache[<a href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_9">9]</a>。</p>
<p>而当TLB和MMU中都没有该物理页，就会发生缺页异常。但是<strong>操作系统仅会对页表更新</strong>，而不会被TLB更新。故而，TBL中数据可能陈旧，需要手动flush。</p>
<h2 id="Physical-memory-allocation"><a href="#Physical-memory-allocation" class="headerlink" title="Physical memory allocation"></a>Physical memory allocation</h2><p>在内核运行的时候，需要申请很多空间用来存放各种数据。</p>
<blockquote>
<p>The kernel must allocate and free physical memory at run-time for page tables, user memory, kernel stacks, and pipe buffers.</p>
</blockquote>
<p>用的是这段空闲内存：</p>
<p><img src="/2023/01/10/xv6/image-20230109225700837.png" alt="image-20230109225700837"></p>
<blockquote>
<p> It keeps track of which pages are free by threading a <strong>linked list</strong> through the pages themselves.</p>
</blockquote>
<p>kalloc.c中就是这么实现的。</p>
<h2 id="Code-Physical-memory-allocator"><a href="#Code-Physical-memory-allocator" class="headerlink" title="Code: Physical memory allocator"></a>Code: Physical memory allocator</h2><p>内核运行时申请释放空闲物理空间是通过<code>kernel/kalloc.c</code>完成的。它为内核栈、用户进程、页表和管道buffer服务。</p>
<blockquote>
<p>kalloc.c用来在运行时申请分配新的一页，上面的vm.c正是用了kalloc申请一页，要么作为页表，要么作为存储数据的第三级页表指向的物理内存。</p>
</blockquote>
<p>最后应该会在空闲内存内形成这样的结构：</p>
<p>内存分成一页一页的，每页内存中的前几个字节存储着其对应队列中下一块内存的物理地址。不一定是从小地址到大地址顺序连接。</p>
<blockquote>
<p>It store each free page’s run structure in the free page itself, since there’s nothing else stored there. </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Physical memory allocator, for user processes,</span></span><br><span class="line"><span class="comment">// kernel stacks, page-table pages,</span></span><br><span class="line"><span class="comment">// and pipe buffers. Allocates whole 4096-byte pages.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放在这范围内的物理内存空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也就是上面说的free memory的起始位置</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[]; <span class="comment">// first address after kernel.</span></span><br><span class="line">                   <span class="comment">// defined by kernel.ld.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// run代表的是一页内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表了整个内核空闲的物理空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="comment">// init的时候先清空空闲空间，建立空闲页队列</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="comment">// PGROUNDUP和PGROUNDDOWN是用于将地址四舍五入到PGSIZE</span></span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// pa得是整数页，并且得在内核物理内存范围之间</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 之后将在pa对应的那一页的前几个字节写入next字段</span></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这意思就是在空闲内存的链表队列中新增一块</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Process-address-space"><a href="#Process-address-space" class="headerlink" title="Process address space"></a>Process address space</h2><p>当用户进程叫xv6分配内存时，xv6会用kalloc去取，然后登记在页表上。</p>
<blockquote>
<p>The stack is a single page, and is shown with the initial contents as created by exec. Strings containing the command-line arguments, as well as an array of pointers to them, are at the very top of the stack. Just under that are values that allow a program to start at main as if the function main(argc, argv) had just been called.</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230109234930690.png" alt="image-20230109234930690"></p>
<h2 id="Code-sbrk"><a href="#Code-sbrk" class="headerlink" title="Code: sbrk"></a>Code: sbrk</h2><blockquote>
<p>Sbrk is the <strong>system call</strong> for a process to <strong>shrink or grow</strong> its memory. The system call is implemented by the function growproc (kernel/proc.c:239).</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.注意单位是bytes，grow n+，shrink n-</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// 主要逻辑还是通过vm.c实现</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sz;<span class="comment">//size</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n, PTE_W)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate PTEs and physical memory to grow process from oldsz to</span></span><br><span class="line"><span class="comment">// newsz, which need not be page aligned.不需要页对齐  Returns new size or 0 on error.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// oldsz向上取整</span></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="comment">// 每页alloc</span></span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 说明失败，恢复到原状</span></span><br><span class="line">      <span class="comment">// 这里不用像下面一样kfree是因为这里压根没有alloc成功</span></span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除去junk data</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 放入页表</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 不成功</span></span><br><span class="line">      <span class="comment">// dealloc原理是顺着页表一个个free的。由于mem此处没有成功放入页表，所以就得单独free掉</span></span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-exec"><a href="#Code-exec" class="headerlink" title="Code:exec"></a>Code:exec</h2><blockquote>
<p>Exec is the system call that creates the user part of an address space. It initializes the user part of an address space from a fifile stored in the fifile system.</p>
<p><code>exec</code>是创建地址空间的用户部分的系统调用。它使用一个存储在文件系统中的文件初始化地址空间的用户部分。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s, *last;</span><br><span class="line">  <span class="type">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//开始打开文件的意思吧（</span></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//ip是一个inode</span></span><br><span class="line">  <span class="comment">//打开路径为path的文件</span></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暂时锁住文件，别人不许动</span></span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//之后应该就是把文件读入内存吧</span></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//分配新页表</span></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//elfhd应该指的是可执行文件头</span></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//总之顺利读到了</span></span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="comment">//读到了就给它分配新空间并且填入页表</span></span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在这里解锁</span></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读完文件，开始造一个新的用户栈【fork之后用户栈是不会清空的】</span></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Make the first inaccessible as a stack guard.</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack.</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE, PTE_W)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  <span class="comment">// mark a PTE invalid for user access.造guard page</span></span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  <span class="comment">// sp为栈顶</span></span><br><span class="line">  sp = sz;</span><br><span class="line">  <span class="comment">// 应该指的是栈尾</span></span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始往栈中填入执行参数</span></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//argv来自用户空间，所以需要使用copyout</span></span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//这什么东西</span></span><br><span class="line">    <span class="comment">//exec一次将参数中的一个字符串复制到栈顶，并在ustack中记录指向它们的指针</span></span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//放置空指针</span></span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="type">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//只有成功了才会来到这，才会覆盖掉旧的内存镜像</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="comment">//释放新镜像，不改变旧镜像</span></span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><p><img src="/2023/01/10/xv6/image-20230110010651653.png" alt="image-20230110010651653"></p>
<p>xv6内核缺少一个类似<code>malloc</code>可以为小对象提供内存的分配器，这使得内核无法使用需要动态分配的复杂数据结构。【确实，感觉一分配就是一页（】</p>
<p>内存分配是一个长期的热门话题，基本问题是有效使用有限的内存并为将来的未知请求做好准备。今天，人们更关心速度而不是空间效率。此外，一个更复杂的内核可能会分配许多不同大小的小块，而不是（如xv6中）只有4096字节的块；一个真正的内核分配器需要处理小分配和大分配。</p>
<h2 id="Lab：Pagetable"><a href="#Lab：Pagetable" class="headerlink" title="Lab：Pagetable"></a>Lab：Pagetable</h2><blockquote>
<p>In this lab you will explore page tables and modify them to to speed up certain system calls and to detect which pages have been accessed.</p>
</blockquote>
<h3 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h3><blockquote>
<p>When each process is created, map one read-only page at USYSCALL (a VA defined in <code>memlayout.h</code>). At the start of this page, store a <code>struct usyscall</code> (also defined in <code>memlayout.h</code>), and initialize it to store the PID of the current process. For this lab, <code>ugetpid()</code> has been provided on the userspace side and will automatically use the USYSCALL mapping. You will receive full credit for this part of the lab if the <code>ugetpid</code> test case passes when running <code>pgtbltest</code>.</p>
<p>参考文章：<a href="https://zhuanlan.zhihu.com/p/429304672">MIT 6.S081 2021: Lab page tables</a></p>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><h5 id="乌龙"><a href="#乌龙" class="headerlink" title="乌龙"></a>乌龙</h5><p>这里好像是因为实验改版了，我下的是2020年的实验包，在memlayout压根找不到USYSCALL和struct usyscall这俩东西。最后翻了下网上的总算找到了。</p>
<p>我一开始没找到，还以为USYSCALL以及usyscall这两个都得自己写在memlayout里面，想了很久都没想出来USYSCALL的值应该设置为多少。我认为只需满足两个条件即可：1.所处内存段应该是free memory那段，也即自kernel结束（PHYSTOP）到MAXVA这一大块。2.得确保能被用户和内核都能访问到。</p>
<p>前者意为虚拟地址在MAXVA和PHYSTOP之间，后者意为那段内存应该标记为PTE_U。这个范围是很宽泛的，我实在不知道要分配这期间的哪块内存，感觉也不大可能是真的自由度那么大。所以我就偷偷看了hints【悲】，想看它对这个USYSCALL应该写什么值有没有建议。结果发现这东西是实验给我们定的。遂去网上找到了它给的真正的USYSCALL值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户的ugetpid只找到了一个截图：</p>
<p><img src="/2023/01/10/xv6/v2-0c2603da4c8102e46ae390a0d0b1191d_1440w.jpg" alt="v2-0c2603da4c8102e46ae390a0d0b1191d_1440w"></p>
<p>恕我愚钝实在不知道该把这段代码放在哪orz于是接下来写的东西就没有自测。</p>
<h5 id="panic-freewalk-leaf"><a href="#panic-freewalk-leaf" class="headerlink" title="panic:freewalk leaf"></a>panic:freewalk leaf</h5><p>一开始写好代码准备启动xv6的时候爆出了这么一个panic，搜了一下得到如下解答：</p>
<blockquote>
<p>来源：<a href="http://t.zoukankan.com/YuanZiming-p-14270600.html">MIT-6.S081-2020实验（xv6-riscv64）十：mmap</a></p>
<p>这时运行会发现freewalk函数panic：<code>freewalk: leaf</code>，这是因为freewalk希望所有虚拟地址已经被解绑并释放对应的物理空间了，该函数只负责释放页表。</p>
</blockquote>
<p>让我得知freewalk在vm.c下面【吐槽，我一开始还以为是自由自在地走（，看到这个才反应过来是free walk，跟页表有关的】。结合freewalk的代码</p>
<p><img src="/2023/01/10/xv6/image-20230110225359361.png" alt="image-20230110225359361"></p>
<p>可以知道，造成这个panic的原因是需要手动释放页表项。而在这里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c  freeproc()</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>仅仅是释放掉了对应的物理页，<strong>页表项并没有被释放</strong>。</p>
<p>对比了一下别人写的，才发现原来这里也需要修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//添加此句</span></span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，问题就解决了。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>因而，可以看到，如果进程想使用页的话，需要经历以下四步：</p>
<ol>
<li>通过kalloc获取物理页地址（可以通过该地址对页进行读写），并且记录在进程proc结构中（否则之后就获取不了了）</li>
<li>建立mappages映射</li>
<li>释放物理页</li>
<li>释放PTE映射</li>
</ol>
<p>可见12和34都是分别一一对应的。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//有线程池那味了</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Allocate a usyscall page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在USYSCALL写入usyscall结构体</span></span><br><span class="line">  p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a user page table for a given process,</span></span><br><span class="line"><span class="comment">// with no user memory, but with trampoline pages.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 映射USYSCALL</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;usyscall), PTE_R|PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><blockquote>
<p>Which other xv6 system call(s) could be made faster using this shared page? Explain how.</p>
</blockquote>
<p>我觉得如果能在fork的父子进程用shared page共享页表应该会节省很多时间和空间，用个读时写。其他的倒是想不到了。不过这题会不会问的是那些在内核态和用户态穿梭频繁的system call呢？这个的话我就想不出来了。</p>
<h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><blockquote>
<p>write a function that prints the contents of a page table.</p>
<p>Define a function called <code>vmprint()</code>. </p>
<p>It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. </p>
<p>Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process’s page table. </p>
<p><img src="/2023/01/10/xv6/image-20230110231020570.png" alt="image-20230110231020570"></p>
<p>The first line displays the argument to <code>vmprint</code>. After that there is a <strong>line for each PTE</strong>, including PTEs that refer to page-table pages deeper in the tree. Each PTE line is indented by a number of <code>&quot; ..&quot;</code> that indicates its depth in the tree. </p>
<p>Each PTE line shows the PTE <strong>index</strong> in its page-table page, the <strong>pte bits</strong>, and the <strong>physical address extracted from the PTE</strong>. <u>Don’t print PTEs that are not valid</u>. </p>
<p>In the above example, the top-level page-table page has mappings for entries 0 and 255. The next level down for entry 0 has only index 0 mapped, and the bottom-level for that index 0 has entries 0, 1, and 2 mapped.</p>
</blockquote>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><p><img src="/2023/01/10/xv6/image-20230111000329475.png" alt="image-20230111000329475"></p>
<p>很可惜，我在上面检索<code>freewalk leaf</code>到底是什么东西的时候，不小心看到了这题需要去参照freewalk这个提示【悲】其实我觉得这点还是需要绕点弯才能想到的，可能直接想到有点难【谁知道呢，世界线已经变动了】。</p>
<p>它这个打印页表其实最主要是考查如何遍历页表，这让人想起了walk这样的东西。但是walk是根据虚拟地址一级级找PTE的，中间很多地方会被跳过。有没有一个过程会在做事的时候遍历整个页表呢？答案是，这个过程就是释放页表的过程。释放页表才会一个个地看是否需要释放。释放页表的函数是freewalk，因而这道题参考freewalk的代码即可。</p>
<p>我觉得从“遍历页表”联想到“释放页表”这点是很巧的。不过也不会很突兀，毕竟学数据结构时就知道释放就需要遍历，逆向思维有点难但问题不大。</p>
<p>其他的就都挺简单的，不多赘述。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>记得在defs.h中添加声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在vm.c下</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint_helper</span><span class="params">(<span class="type">pagetable_t</span> pagetable,<span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;level;j++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>,i,(uint64)pte,(uint64)(PTE2PA(pte)));</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        vmprint_helper((<span class="type">pagetable_t</span>)child,level+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印页表</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// typedef uint64 *pagetable_t;所以pagetable可以以%p形式打印</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>,(uint64)pagetable);</span><br><span class="line">  vmprint_helper(pagetable,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问答题-1"><a href="#问答题-1" class="headerlink" title="问答题"></a>问答题</h4><blockquote>
<p>Explain the output of <code>vmprint</code> in terms of Fig 3-4 from the text. </p>
<p>What does page 0 contain? </p>
<p>What is in page 2? When running in user mode, could the process read/write the memory mapped by page 1? </p>
<p>What does the third to last page contain?</p>
</blockquote>
<p>从上面操作系统的启动来看，进程1应该是在main.c中的userinit()中创建的进程，也是shell的父进程。【确实，经实践可得shell的pid为2】</p>
<p>可以来看一下userint的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请一页，将initcode的指令和数据放进去</span></span><br><span class="line">  <span class="comment">// allocate one user page and copy initcode&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  uvminit的注释：</span></span><br><span class="line"><span class="comment">  	// Load the user initcode into address 0 of pagetable,</span></span><br><span class="line"><span class="comment">	// for the very first process.</span></span><br><span class="line"><span class="comment">	// sz must be less than a page.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为内核态到用户态的转变做准备</span></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Trap Frame是指中断、自陷、异常进入内核后,在堆栈上形成的一种数据结构</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改进程名</span></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个也许是为了能被优先调度</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，page0是initcode的代码和数据，page1和page2用作了进程的栈，其中page1应该是guard page，page2是stack。</p>
<p><strong>不过这里从exec的角度解释其实更通用</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//分配新页表</span></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//elfhd应该指的是可执行文件头</span></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="comment">//总之顺利读到了</span></span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="comment">//读到了就给它分配新空间并且填入页表</span></span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读完文件，开始造一个新的用户栈【fork之后用户栈是不会清空的】</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE, PTE_W)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  <span class="comment">// mark a PTE invalid for user access.造guard page</span></span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  <span class="comment">// sp为栈顶</span></span><br><span class="line">  sp = sz;</span><br><span class="line">  <span class="comment">// 应该指的是栈尾</span></span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page0就填程序。这里重点说明一下为什么page1和page2分别是guard page和stack。</p>
<p>按照它的那个算术关系，stack和guard page的虚拟内存位置关系应该是这样的：</p>
<p><img src="/2023/01/10/xv6/image-20230111004330079.png" alt="image-20230111004330079"></p>
<p>那为什么最后在页表中，变成了page1是gurad page，page2是stack这样上下颠倒了呢？看vm.c中的uvmalloc就能明白。</p>
<p><img src="/2023/01/10/xv6/image-20230111004500827.png" alt="image-20230111004500827"></p>
<p>在253行设置了新映射。可以看到，这里设置映射的顺序是sz-&gt;sz+PGSIZE，也即先设置guard page的映射，再设置stack的映射。所以，这两位才会上下颠倒了。</p>
<h3 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h3><blockquote>
<p>Some garbage collectors (a form of automatic memory management) can benefit from information about <strong>which pages have been accessed (read or write)</strong>. In this part of the lab, you will add a new feature to xv6 that detects and reports this information to userspace by inspecting <strong>the access bits in the RISC-V page table.</strong> The RISC-V hardware page walker marks these bits in the <strong>PTE</strong> whenever it resolves a TLB miss.</p>
</blockquote>
<blockquote>
<p>Your job is to implement <code>pgaccess()</code>, a system call that reports which pages have been accessed. </p>
<p>The system call takes three arguments. First, it takes the <strong>starting virtual address</strong> of the first user page to check. Second, it takes the <strong>number of pages</strong> to check. Finally, it takes a <strong>user address to a buffer to store the results into a bitmask</strong> (a datastructure that uses one bit per page and where the first page corresponds to the least significant bit). </p>
<p>You will receive full credit for this part of the lab if the <code>pgaccess</code> test case passes when running <code>pgtbltest</code>.</p>
</blockquote>
<h4 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h4><p>实验内容：</p>
<p>实现<code>void pgaccess(uint64 sva,int pgnum,int* bitmask);</code>，一个系统调用。在这里面，我们要做的是，访问从<code>sva</code>到<code>sva+pgnum*PGSIZE</code>这一范围内的虚拟地址对应的PTE，然后查看PTE的标记项是否有<code>PTE_A</code>。有的话则在bitmask对应位标记为1.</p>
<p>应该注意的点：</p>
<p>1.需要进行内核态到用户态的参数传递  2.需要进行系统调用的必要步骤  3.PTE_A需要自己定义</p>
<p>以上是初见。做完了发现，确实就是那么简单，我主要时间花费在下的实验版本不对，折腾来折腾去了可能有一个小时，最后还是选择了直接把测试函数搬过来手工调用。已经换到正确的年份版本了【泪目】</p>
<p>有一点我忽视了，看了提示才知道：</p>
<blockquote>
<p>Be sure to clear <code>PTE_A</code> after checking if it is set. Otherwise, it won’t be possible to determine if the page was accessed since the last time <code>pgaccess()</code> was called (i.e., the bit will be set forever).</p>
</blockquote>
<p>也就是说每次检查到一个，就需要手动清除掉PTE_A标记。</p>
<p>还有一点以前一直没注意到的，<strong>头文件的引用需要注意次序</strong>。比如说要是把<code>spinlock.h</code>放在<code>proc.h</code>后面，就会寄得很彻底。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>那些系统调用的登记步骤就先省略了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sva;</span><br><span class="line">  <span class="type">int</span> pgnum;</span><br><span class="line">  uint64 bitmask;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;sva) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;pgnum) &lt; <span class="number">0</span> || argaddr(<span class="number">2</span>, &amp;bitmask) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> pgaccess((<span class="type">void</span>*)sva,pgnum,(<span class="type">void</span>*)bitmask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/pgaccess.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pgaccess</span><span class="params">(<span class="type">void</span>* sva,<span class="type">int</span> pgnum,<span class="type">void</span>* bitmask)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pgnum &gt; <span class="number">32</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pgaccess: range too big.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> kmask = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pgnum;i++)&#123;</span><br><span class="line">        <span class="type">pte_t</span>* pte = walk(p-&gt;pagetable,(uint64)sva+i*PGSIZE,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 映射不存在，或者没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!pte || !(*pte &amp; PTE_A))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        kmask = (kmask | (<span class="number">1</span>&lt;&lt;i));</span><br><span class="line">        *pte = (*pte &amp; (~PTE_A));</span><br><span class="line">    &#125;</span><br><span class="line">    copyout(p-&gt;pagetable,(uint64)bitmask,(<span class="type">char</span>*)(&amp;kmask),<span class="keyword">sizeof</span>(<span class="type">int</span>)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h3><blockquote>
<p>The goal of this section and the next is to allow the kernel to directly dereference user pointers.</p>
</blockquote>
<blockquote>
<p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. </p>
<p>Modify <code>struct proc</code> to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if <code>usertests</code> runs correctly.</p>
</blockquote>
<h4 id="感想-3"><a href="#感想-3" class="headerlink" title="感想"></a>感想</h4><p>这个其实平心而论不难，思路很简单。写着不难是不难，但想明白花费了我很多时间。</p>
<p>它这个要求我们修改kernel，使得每个进程都有一份自己的kernel page。至于要改什么，围绕着proc.c中，参照pagetable的生命周期摁改就行。还有一个地方它也提示了，就是要在swtch之前更换一下satp的值。</p>
<p>接下来，我说说我思考的几个点以及犯错的地方。</p>
<h5 id="为什么要这么干"><a href="#为什么要这么干" class="headerlink" title="为什么要这么干"></a>为什么要这么干</h5><p>看完题目，我的第一印象是，这么干有啥用。。。因为我觉得以前那个所有进程共用内核栈确实很好了，没有必要每个进程配一个后来才发现，这个跟下面那个是连在一起的，目的是<code> allow the kernel to directly dereference user pointers.</code>。所以，我们下面会把用户的pgtbl和这里dump出来的kpgtbl合在一起。</p>
<h5 id="关于myproc"><a href="#关于myproc" class="headerlink" title="关于myproc()"></a>关于myproc()</h5><p>在allocproc中初始化的时候，我一开始是这么写的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c allocproc()</span></span><br><span class="line">perproc_kvminit();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">perproc_kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(p-&gt;kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  pkvmmap(p-&gt;kpgtbl,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样会死得很惨，爆出如下panic：</p>
<p><img src="/2023/01/10/xv6/image-20230114011100370.png" alt="image-20230114011100370"></p>
<p>通过hints的调试贴士</p>
<blockquote>
<p>A missing page table mapping will likely cause the kernel to encounter a page fault. It will print an error that includes <code>sepc=0x00000000XXXXXXXX</code>. You can find out where the fault occurred by searching for <code>XXXXXXXX</code> in <code>kernel/kernel.asm</code>.</p>
</blockquote>
<p>我发现程序在这里绷掉了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br></pre></td></tr></table></figure>

<p>而且显而易见，是系统启动时崩的。</p>
<p>经过了漫长的思考，我震惊地发现了它为什么崩了（）</p>
<p>首先，这段代码语法上是没有问题的。它固然犯了发布未初始化完成的对象这样的并发错误【我有罪】，也破坏了proc的封装性【proc中的很多私有属性本来应该作用域仅在proc.c中的。此处为了能让vm.c访问到proc中的属性，不得不给vm.c添上了proc.h的头文件】，但是它<u>并不是语法错误</u>，还是能用的。我做了这样的测试样例证明它没有问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">pagetable_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span>&#123;</span></span><br><span class="line">	<span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">processes</span>[<span class="title">MAX</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> proc* <span class="title function_">myproc</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;processes[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminit</span><span class="params">()</span>&#123;</span><br><span class="line">	myproc()-&gt;kpgtbl = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> &amp;processes[<span class="number">0</span>];</span><br><span class="line">	kvminit();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;kpgtbl);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我一路顺着os启动的路径找，也想不出来这能有什么错，因而非常迷茫。</p>
<p>此时我灵光一闪，会不会是myproc()在os刚启动的时候是发挥不了作用的？于是我一路顺着myproc的代码看下去：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，mycpu()获得的cpu的proc是怎么得到的呢？</p>
<p>我搜寻了一下os启动代码，发现了cpu的proc得到的路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//...很多很多init</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调度执行第一个进程</span></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完进程后，就进入scheduler进行进程的调度：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">        <span class="comment">//在这里！！！！</span></span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>因而，c-&gt;proc是在创建进程的第一次调度后初始化的，也即，myproc只有在执行第一次scheduler之后才可以调用。而！！！</p>
<p>当执行调度前的userinit时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br></pre></td></tr></table></figure>

<p>它进行了allocproc。我们亲爱的allocproc接下来就会调用perproc_kvminit，然后perproc_kvminit中调用myproc。此时尚未进行初次调度，因而c-&gt;proc未初始化，myproc返回的是0，也即null。这样一来，<code>myproc()-&gt;kpgtbl</code>就发生了空指针异常，也即scause = 15——写入页错误。</p>
<p>因而，对于myproc()的调用需要慎之又慎。</p>
<h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><p>系统调用时，是如何知道要用的是p中的内核页表而非global内核页表呢？</p>
<p>依然还是从os的启动说起。</p>
<p>在main.c中，kvminithart开启了页表，此时的页表为全局的内核页表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当userinit被调度时，全局的内核页表被换成了proc中的内核页表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c scheduler()</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpgtbl));</span><br><span class="line">sfence_vma();</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br></pre></td></tr></table></figure>

<p>但是这样还没有结束。因为我们除了得更换目前的页表，还得更换trapframe中的内核页表相关的东西：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为啥还要更换trapframe中的呢？因为以后系统调用的时候，uservec是从这里读取值来作为内核栈和内核页表的来源的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># in uservec</span><br><span class="line">		# restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        # 完成了内核栈的切换</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">		# 完成了页表的切换</span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br></pre></td></tr></table></figure>

<p>所以，为了以后系统调用能顺利自发进行，我们需要把栈帧也一起换掉。怎么换呢？我们是否还要在一些地方人工把trapframe的值设置为我们自己的内核栈内核页表？答案是，不用！这些会由其他代码自动完成。</p>
<p>前面说到userinit的进程p被调度，<strong>satp换成了我们自己的内核页表</strong>。那么，在之后的内核态，satp都将保持我们自己的内核页表。当要返回用户态时，会执行如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in usertrapret</span></span><br><span class="line">  <span class="comment">// 重置trapframe</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br></pre></td></tr></table></figure>

<p>satp内的值为我们自己的内核页表，而非全局页表。因而这样栈帧中的页表就会被自然而然地写入为进程的内核页表。之后返回用户态，以及之后之后的各种中断，就都会一直使用自己的内核页表了。【试了一下，这里如果改成非即时从satp读，而是默认的kernel_pagetable的话，会一直死循环】</p>
<p>不得不说，真是设计精妙啊！！！不过我觉得，要是这里写成kernel_pagetable，然后让我们自己改的话将是薄纱（。当然它应该也不会这么做，因为，kernel_pagetable事实上是不对外发布的。它这里这么写热读，最直接的原因还是因为读不到kernel_pagetable。这算是无心插柳柳成荫吗233</p>
<h5 id="释放页表但不释放物理内存"><a href="#释放页表但不释放物理内存" class="headerlink" title="释放页表但不释放物理内存"></a>释放页表但不释放物理内存</h5><p>其实答案就在它给的<code>proc_freepagetable</code>里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uvmfree</code>遍历页表，对每个存在的页表项，都试图找到其物理内存，并且释放物理内存和表项。如果页表项存在，但页表项对应的物理内存不存在，就会抛出<code>freewalk leaf</code>的异常。</p>
<p><code>uvmunmap</code>会释放掉参数给的va的页表项，最后一个参数表示释放or不释放。</p>
<p>在这里，使用这两个的组合技，就可以达到不释放<code>TRAMPOLINE</code>和<code>TRAPFRAME</code>的物理内存，又不会让uvmfree出错的效果。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化kpgtbl。由于现在内核栈存在各自的内核页表而非global内核页表中，所以在procinit中的对内核栈的初始化也得放在这：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c allocproc()</span></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p-&gt;kpgtbl = perproc_kvminit();</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">  uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">  pkvmmap(p-&gt;kpgtbl,va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">perproc_kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pt = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(pt, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  pkvmmap(pt,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  pkvmmap(pt,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  pkvmmap(pt,CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  pkvmmap(pt,PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  pkvmmap(pt,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  pkvmmap(pt,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  pkvmmap(pt,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pkvmmap</span><span class="params">(<span class="type">pagetable_t</span> pgtbl,uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当第一个进程开始时，mycpu-&gt;proc = null,所以这里不能调用myproc</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="swtch时切换页表"><a href="#swtch时切换页表" class="headerlink" title="swtch时切换页表"></a>swtch时切换页表</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c scheduler()</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpgtbl));</span><br><span class="line">sfence_vma();</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有进程运行时使用全局kernel_pagetable</span></span><br><span class="line">      kvminithart();</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改kvmpa"><a href="#修改kvmpa" class="headerlink" title="修改kvmpa"></a>修改kvmpa</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">kvmpa</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  pte = walk(myproc()-&gt;kpgtbl, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel.proc.c freeproc()</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpgtbl)</span><br><span class="line">    proc_freekpgtbl(p-&gt;kpgtbl,p-&gt;kstack);</span><br><span class="line">  p-&gt;kpgtbl = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freekpgtbl</span><span class="params">(<span class="type">pagetable_t</span> pagetable,uint64 <span class="built_in">stack</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, UART0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, VIRTIO0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, CLINT, <span class="number">0x10000</span>/(uint64)PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, PLIC, <span class="number">0X400000</span>/(uint64)PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, KERNBASE, (uint64)((uint64)etext-KERNBASE)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, (uint64)etext,(PHYSTOP-(uint64)etext)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span></span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, <span class="built_in">stack</span>, <span class="number">1</span>,<span class="number">1</span> );</span><br><span class="line">  uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin/copyinstr</code></h3><blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/qq_41822154/article/details/124898399">6.S081学习记录-lab3</a></p>
</blockquote>
<blockquote>
<p>The kernel’s <code>copyin</code> function reads memory pointed to by user pointers. It does this by translating them to physical addresses, which the kernel can directly dereference. It performs this translation by walking the process page-table in software. Your job in this part of the lab is to add user mappings to each process’s kernel page table (created in the previous section) that allow <code>copyin</code> (and the related string function <code>copyinstr</code>) to directly dereference user pointers.</p>
</blockquote>
<blockquote>
<p>Replace the body of <code>copyin</code> in <code>kernel/vm.c</code> with a call to <code>copyin_new</code> (defined in <code>kernel/vmcopyin.c</code>); do the same for <code>copyinstr</code> and <code>copyinstr_new</code>. Add mappings for user addresses to each process’s kernel page table so that <code>copyin_new</code> and <code>copyinstr_new</code> work.</p>
</blockquote>
<h4 id="感想-4"><a href="#感想-4" class="headerlink" title="感想"></a>感想</h4><p>这题很直观的思路是，在每个user pagetable添加映射的地方也添加kpgtbl的映射。但问题是，“每个user pagetable添加映射的地方”都是哪？</p>
<h5 id="误入幻想"><a href="#误入幻想" class="headerlink" title="误入幻想"></a>误入幻想</h5><p>我一开始想着偷偷懒，直接在proc.c和vm.c中每个操纵pagetable的地方都加上对kpgtbl的操纵。但很快我就给搞晕了。这时候，我心中萌生一计【PS：下面说的最后都没成功】：我直接快进到把proc结构中的pagetable属性给删了，然后每个出现p-&gt;pagetable的地方，都用p-&gt;kpgtbl代替，直接让两表合为一表，然后之后make的时候哪里报错改哪里，这不就一劳永逸地把所有出现pagetable的地方都改为kpgtbl了嘛。我振奋地去试了一下，将所有地方出现的pagetable都替换成了kpgtbl，把proc.c中的<code>proc_pagetable()</code>和<code>proc_freepagetable()</code>的出现的地方都换成了<code>perproc_kvminit()</code>以及<code>proc_freekpgtbl()</code>，还做了一个小细节，就是在userinit中调用的uvminit中，我把这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvminit</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uchar *src, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sz &gt;= PGSIZE)</span><br><span class="line">    panic(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">  mem = kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  mappages(pagetable, <span class="number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);</span><br><span class="line">  memmove(mem, src, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>换成了这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvminit</span><span class="params">(<span class="keyword">struct</span> proc* p, uchar *src, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sz &gt;= PGSIZE)</span><br><span class="line">    panic(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">  mem = kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  mappages(p-&gt;kpgtbl, <span class="number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);</span><br><span class="line">  memmove(mem, src, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在启动的时候，卡在了初次调度切换不到initcode这边，没有调用exec。没有panic，似乎只在死循环。我也实在想不出是什么原因，最后把代码删了【悲】想想我应该用git保存一下改前改后的。这下实在是难受了，我的想法也暂时没有机会实践了。等到明年大三说不定还得再交一次这玩意，到时候再探究探究吧hhh</p>
<h5 id="走上正途"><a href="#走上正途" class="headerlink" title="走上正途"></a>走上正途</h5><p>发现这个最后没成还改了半天的我最后非常沮丧地去看了hints【又一心浮气躁耐心不足的表现，但确实绷不住了】，发现它居然说只用修改三个地方：fork、exec以及sbrk。</p>
<p>我把kernel/下的每个文件都搜了一遍，发现确实，只有这三个，以及proc.c，vm.c，涉及到对页表项的增删。而在用户态中，想要对进程的内存进行管理，似乎只能通过系统调用sbrk。而proc.c和vm.c中确实没什么好改的。因为里面增加的映射，都是trapframe、trampoline、inicode这种不会一般在copyin中用到的虚拟地址。所以，要改的地方，确确实实，<u>只有fork、exec以及sbrk</u>。</p>
<blockquote>
<p> Xv6 applications ask the kernel for heap memory using the sbrk() system call. </p>
</blockquote>
<p>很悲伤，我的初见思路是错误的（）</p>
<p>而这三个地方的共同点，就是都会对页表进行大量的copy。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in proc.c fork()</span></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in exec.c</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in syscall.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//in proc.c growproc()</span></span><br><span class="line">uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>所以，我们要做的事情很简单：写一个坐收渔翁之利的函数，内容为把一个页表的所有内容复制到另一个页表。然后再在这几个地方调用这个函数即可。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><blockquote>
<p>注意：由于我写得实在是太烦了，已经思考不下去了。为了<strong>放过我自己</strong>，我写了个虽然能过得去测试但是其实毛病重重的代码。垃圾点为以下几点：</p>
<ol>
<li><p>需要去掉freewalk中的panic</p>
<p>我的kvmcopy的实现是，user pagetable（下面简称up）和tp的相同虚拟地址共用同一页物理内存。也就是说，页表不一样，但所指向的物理内存是同一个。这样设计的目的是为了能够让tp及时用到up的更新后的数据。</p>
<p>这会导致啥呢？在进程释放时，需要一起调用<code>proc_freepagetable</code>和<code>proc_freekpgtbl</code>。<code>proc_freepagetable</code>调用完后，所指向的那堆物理内存已经寄完了，如果再调用<code>proc_freekpgtbl</code>，显然，就会发生页表未释放但页表对应内存已经释放的问题，freewalk就会panic。因此，我简单粗暴地直接把freewalk的panic删掉了【抖】也许有别的解决方法，但我真是烦得不想想了放过我吧（</p>
</li>
<li><p>好像暂时没有第二点了（）</p>
</li>
</ol>
</blockquote>
<h5 id="渔翁之利函数"><a href="#渔翁之利函数" class="headerlink" title="渔翁之利函数"></a>渔翁之利函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="comment">// 效仿的是vm.c中的uvmcopy</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kvmcopy</span><span class="params">(<span class="type">pagetable_t</span> up, <span class="type">pagetable_t</span> kp, uint64 sz)</span></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123; </span><br><span class="line">    <span class="keyword">if</span>((pte = walk(up, i, <span class="number">0</span>)) == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(walk(kp,i,<span class="number">0</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果up不存在此项，kp存在，就直接删了</span></span><br><span class="line">            uvmunmap(kp,i,PGSIZE,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// 注意去除PTE_U，否则内核态无法访问</span></span><br><span class="line">    flags = (flags &amp; (~PTE_U));</span><br><span class="line">    <span class="keyword">if</span>(mappages(kp, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(kp, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改fork、exec、sbrk"><a href="#修改fork、exec、sbrk" class="headerlink" title="修改fork、exec、sbrk"></a>修改fork、exec、sbrk</h5><h6 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c fork()</span></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(kvmcopy(np-&gt;pagetable, np-&gt;kpgtbl, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h6 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in exec.c</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line"></span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添上此句</span></span><br><span class="line">  kvmcopy(p-&gt;pagetable, p-&gt;kpgtbl, p-&gt;sz);</span><br></pre></td></tr></table></figure>

<h6 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a>sbrk</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(addr+n &gt;= PLIC)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c</span></span><br><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="comment">// 加这个</span></span><br><span class="line">  kvmcopy(p-&gt;pagetable, p-&gt;kpgtbl, p-&gt;sz);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="userinit"><a href="#userinit" class="headerlink" title="userinit"></a>userinit</h5><blockquote>
<p>这一步不能忽视，因为内核启动的时候就需要用到copyinstr。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c userinit()</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  <span class="comment">// 加这个！</span></span><br><span class="line">  kvmcopy(p-&gt;pagetable, p-&gt;kpgtbl, p-&gt;sz);</span><br></pre></td></tr></table></figure>

<h5 id="删掉freewalk的panic（我特有的缺点）"><a href="#删掉freewalk的panic（我特有的缺点）" class="headerlink" title="删掉freewalk的panic（我特有的缺点）"></a>删掉freewalk的panic（我特有的缺点）</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c freewalk()    </span></span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="comment">//panic(&quot;freewalk: leaf&quot;);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Traps and system calls</title>
    <url>/2023/01/10/xv6$chap4/</url>
    <content><![CDATA[<h1 id="Traps-and-system-calls"><a href="#Traps-and-system-calls" class="headerlink" title="Traps and system calls"></a>Traps and system calls</h1><p>traps=系统调用+异常+中断。本章着重讲traps概述以及traps中的系统调用。</p>
<p>对trap的处理包含四个部分：硬件处理、中断向量、trap handler、对应的处理函数</p>
<h2 id="RISC-V-trap-machinery"><a href="#RISC-V-trap-machinery" class="headerlink" title="RISC-V trap machinery"></a>RISC-V trap machinery</h2><h3 id="control-register"><a href="#control-register" class="headerlink" title="control register"></a>control register</h3><p>risc-v为trap提供了一组寄存器：</p>
<ol>
<li><p>stvec</p>
<p>trap handler的入口地址</p>
</li>
<li><p>sepc</p>
<p>原程序PC</p>
</li>
<li><p>scause</p>
<p>中断号</p>
</li>
<li><p>sscratch</p>
<p>TRAPFRAME地址</p>
</li>
<li><p>sstatus</p>
<p>是否允许中断，以及中断来自内核态还是用户态</p>
</li>
</ol>
<blockquote>
<p>The above registers relate to traps <strong>handled in supervisor mode</strong>, and they cannot be read or written in user mode. </p>
<p>There is an equivalent set of control registers for traps handled <strong>in machine mode</strong>; xv6 uses them <strong>only</strong> for the special case of <u>timer interrupts</u>.</p>
</blockquote>
<p>每个CPU都有自己的一套这样的控制寄存器。</p>
<h3 id="硬件处理步骤"><a href="#硬件处理步骤" class="headerlink" title="硬件处理步骤"></a>硬件处理步骤</h3><p>时钟中断、device interrupt以及关中断的情况下，不会做以下步骤。</p>
<blockquote>
<p>\1. If the trap is a device interrupt, and the sstatus SIE bit is clear, <strong>don’t</strong> do any of the following.</p>
<p>\2. Disable interrupts by clearing SIE.关中断</p>
<p>\3. Copy the pc to sepc.保存PC</p>
<p>\4. Save the current mode (user or supervisor) in the SPP bit in sstatus.保存mode</p>
<p>\5. Set scause to reflflect the trap’s cause.保存中断号</p>
<p>\6. Set the mode to supervisor.切换到内核态</p>
<p>\7. Copy stvec to the pc.将trap handler写入pc，开始执行trap handler</p>
</blockquote>
<p>切换到内核页表、切换内核栈、保存寄存器现场这些工作交给操作系统完成。</p>
<h2 id="Traps-from-user-space"><a href="#Traps-from-user-space" class="headerlink" title="Traps from user space"></a>Traps from user space</h2><p>从用户态来的trap会经历怎么样的过程？</p>
<p>前面说到，下面需要进行页表的切换，页表的切换必然是接下来要做的指令的某个环节。那么为了让页表切换之后，CPU还知道要从哪里取指执行，<strong>就要让某段物理内存在内核空间和用户空间的虚拟地址一样</strong>。这样，不论页表是用户的还是内核的，都可以通过同样的虚拟地址访问到该段存放指令的物理内存从而继续执行。</p>
<p>这段虚拟地址就是<strong>trampoline</strong>。它在内核页表和用户页表都位于MAXVA的位置。</p>
<p><img src="/2023/01/10/xv6/p3.png" alt="p3"></p>
<p>stevc存储的正是trampoline段中的uservec。</p>
<h3 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h3><p>sscratch里面存的是trapframe的值。</p>
<p>trapframe存在于用户空间中，并且每个进程的trapframe所处位置固定是在trampoline下方。</p>
<p><img src="/2023/01/10/xv6/image-20230111203357767.png" alt="image-20230111203357767"></p>
<p>首先将寄存器的值都存入trapframe中；然后，再从trapframe中读取内核栈指针、当前CPUid，下一步要跳转的usertrap的地址，以及内核页表。最后，uservec切换到内核页表，并且jmp到usertrap。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#in kernel/trampoline.S</span><br><span class="line">	.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process&#x27;s p-&gt;trapframe is</span><br><span class="line">        # mapped into user space, at TRAPFRAME.</span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">		# swap a0 and sscratch</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        # ...</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">		# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        # 完成了内核栈的切换</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        # 这里完成了页表的切换</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：trampoline和trapframe有一些相通点。</p>
<p>trampoline为了保障某段物理内存的虚拟地址在内核栈和用户栈中不变，做出的努力是，在内核栈和用户栈都分配同一位置的PTE。</p>
<p>trapframe用于保护现场、用户态向内核态传递参数等等，做出的努力是，在用户栈分配同一位置的PTE，在内核态的局部变量中保存了自己的物理地址。</p>
<p>这两个说实话有点容易混起来，因为我想了半天trampoline可不可以用类似trapframe一样的方法，结论是不行。因为你trampoline的作用是维持指令序列依然不变，不会突然没掉；而trapframe段是用来存储数据而非执行的，对其的控制也是需要指令的。如果trampoline使用第二种方法，指令流就会断掉，更别说别的了。</p>
</blockquote>
<h3 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h3><p>作用是得到trap发生的原因，并且执行对应的处理程序，然后返回结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  <span class="comment">//首先把trap handler切换到kernel的，这样一来如果在kernel中发生trap就会由kernel的handler处理</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在当前进程中再次保存用户程序的原PC，防止之后sepc被覆盖</span></span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//根据cause号不同处理</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="comment">//注意，在此处开启了中断</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用syscall处理</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行对应的处理函数"><a href="#执行对应的处理函数" class="headerlink" title="执行对应的处理函数"></a>执行对应的处理函数</h3><p>比如说system call会修改trapframe中的a0为返回的结果，会获取trapframe中的各个参数。这个“保护现场“感觉是非常微妙的，它兼顾了保护现场和传递参数两个作用</p>
<h3 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h3><p>回到用户态。之前陷入内核态对stvec、satp、sp、hartid、trap handler都做了适应内核态的改变，因而这里就需要改回原来适应用户态的样子，然后返回用户态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关中断</span></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置trapframe</span></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">		# 切换为用户页表</span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        # ...</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h2 id="Code-calling-system-calls"><a href="#Code-calling-system-calls" class="headerlink" title="Code: calling system calls"></a>Code: calling system calls</h2><blockquote>
<p>Chapter 2 ended with initcode.S invoking the exec system call (user/initcode.S:11). Let’s look at how the user call makes its way to the exec system call’s implementation in the kernel.要讲如何从用户态找到exec的代码了。</p>
</blockquote>
<h2 id="Code-system-call-arguments"><a href="#Code-system-call-arguments" class="headerlink" title="Code: system call arguments"></a>Code: system call arguments</h2><p>讲的是系统调用时，是如何把用户态传递的地址转化为内核态地址的。</p>
<p>这个部分可以看看hit实验的实验3 6.7，讲得很详细，而且流程是差不多的。linux0.11的<code>get_fs_byte()</code>就相当于xv6的<code>copyinstr</code>。</p>
<h2 id="Traps-from-kernel-space"><a href="#Traps-from-kernel-space" class="headerlink" title="Traps from kernel space"></a>Traps from kernel space</h2><h3 id="kernelvec"><a href="#kernelvec" class="headerlink" title="kernelvec"></a>kernelvec</h3><p>不同于用户态还得先潜入内核再潜出内核，内核的trap可简单多了，省去了切来切去各种东西的步骤，只需当做一个普通的函数调用就行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># in kernel/kernelvec.S</span><br><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        // make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        // save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)</span><br><span class="line">		# ...</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">	// call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        // restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        # ...</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        // return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h3 id="kerneltrap"><a href="#kerneltrap" class="headerlink" title="kerneltrap"></a>kerneltrap</h3><blockquote>
<p>kerneltrap is prepared for two types of traps: device interrrupts and exceptions. </p>
<p>It calls devintr (kernel/trap.c:177) to check for and handle the <strong>former</strong>. If the trap isn’t a device interrupt, it must be an exception, and that is always a fatal error if it occurs in the xv6 kernel; the kernel calls panic and stops executing.</p>
<p>If kerneltrap was called due to a timer interrupt, and a process’s kernel thread is running (rather than a scheduler thread), kerneltrap calls yield to give other threads a chance to run.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c</span></span><br><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在此处的devintr对不同的设备进行不同的处理方式</span></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Page-fault-exceptions"><a href="#Page-fault-exceptions" class="headerlink" title="Page-fault exceptions"></a>Page-fault exceptions</h2><p>似乎xv6是没有这个缺页exception的。这里主要讲解了三个可以利用缺页中断实现的优化：COW fork、lazy allocation、paging from disk。还提及了automatically extending stacks 以及memory-mapped fifiles。</p>
<h2 id="Lab：Trap"><a href="#Lab：Trap" class="headerlink" title="Lab：Trap"></a>Lab：Trap</h2><blockquote>
<p>This lab explores how system calls are implemented using traps. You will first do a warm-up exercises with stacks and then you will implement an example of user-level trap handling.</p>
</blockquote>
<h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>刚刚上去ubuntu突然发现寄了打不开。。。。看了这篇文章找到了恢复方法：</p>
<p><a href="https://blog.csdn.net/rdw1246010462/article/details/109632296">ubuntu开机出现started gnome Display manager等错误的方法</a></p>
<p>但是我的<code>apt autoremove --purge snapd</code>指令没有用，好像是因为缺少依赖包，但又没空间下载了。折腾了一下重启发现好了，好了的话那就先凑合着用吧（</p>
<h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><h4 id="题目和答案"><a href="#题目和答案" class="headerlink" title="题目和答案"></a>题目和答案</h4><blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/qq_53111905/article/details/120996446">Lab4: traps</a></p>
<p>There is a file <code>user/call.c</code> in your xv6 repo. make fs.img compiles it and also produces a readable assembly version of the program in <code>user/call.asm</code>.</p>
<p>Read the code in call.asm for the functions <code>g</code>, <code>f</code>, and <code>main</code>. Here are some questions that you should answer:</p>
</blockquote>
<ol>
<li><p>a2</p>
</li>
<li><p>被inline掉了</p>
</li>
<li><p>0x64A</p>
<p><img src="/2023/01/10/xv6/image-20230111224927837.png" alt="image-20230111224927837"></p>
<p>auipc的作用是把立即数左移12位，低12位补0，和pc相加赋给指定寄存器。这里立即数是0，指定寄存器是ra，即ra=pc=0x30=48。jalr作用是跳转到立即数+指定寄存器处并且把ra的值+8。因此jalr会跳转1562+48=1594=0x64A处，观察汇编代码可知确实在000000000000064a处。</p>
</li>
<li><p>0x38</p>
</li>
<li><blockquote>
<p>Run the following code.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the RISC-V is <strong>little-endian</strong>. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<p><img src="/2023/01/10/xv6/format,png.png" alt="format,png"></p>
</blockquote>
</li>
<li><p>取决于寄存器a2（第3个参数）的值。</p>
</li>
</ol>
<h4 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h4><p>我超。。差不多都不会（2345），更可怕的是不会查文档，不知道从哪里看RISC-V指令集的内容，救。果然真的太弱了。</p>
<h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><blockquote>
<p>For debugging it is often useful to have a backtrace: a list of the function calls on the stack above the point at which the error occurred.</p>
<p><img src="/2023/01/10/xv6/image-20230111232323444.png" alt="image-20230111232323444"></p>
<p>The compiler puts in each stack frame a frame pointer that holds the address of the caller’s frame pointer. Your <code>backtrace</code> should use these frame pointers to walk up the stack and print the saved return address in each stack frame.</p>
</blockquote>
<blockquote>
<p>Some hints:</p>
<ul>
<li><p>Add the prototype for backtrace to <code>kernel/defs.h</code> so that you can invoke <code>backtrace</code> in <code>sys_sleep</code>.</p>
</li>
<li><p>The GCC compiler stores the frame pointer of the currently executing function in the register s0. Add the following function to kernel/riscv.h:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and call this function in backtrace to read the current frame pointer. This function uses in-line assembly to read s0.</p>
</li>
<li><p>These <a href="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">lecture notes</a> have a picture of the layout of stack frames. Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.</p>
</li>
<li><p>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. You can compute the top and bottom address of the stack page by using <code>PGROUNDDOWN(fp)</code> and <code>PGROUNDUP(fp)</code> (see <code>kernel/riscv.h</code>. These number are helpful for <code>backtrace</code> to terminate its loop.</p>
</li>
</ul>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>我超，这题真的是那怎能只叫一个拷打……</p>
<h5 id="存储在s0中的栈帧指针"><a href="#存储在s0中的栈帧指针" class="headerlink" title="存储在s0中的栈帧指针"></a>存储在s0中的栈帧指针</h5><p>这个应该是risc-v的约定成俗的特性。我搜了一下risc-v的栈帧指针保存在哪个寄存器，看到了这样一篇文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/dai_xiangjun/article/details/126541174">risc-v 栈分析</a></p>
<p><img src="/2023/01/10/xv6/image-20230112012358601.png" alt="image-20230112012358601"></p>
</blockquote>
<p>这个信息没有放在题干提示，是在考察信息检索能力吗（</p>
<blockquote>
<p>首先，我看完题目就麻了，不知道从何下手。我知道首先得知道栈的结构，比如说<code>The compiler puts in each stack frame a frame pointer that holds the address of the caller&#39;s frame pointer.</code>这句话说的那个pointer到底存在了栈的哪块位置，又存在了哪个寄存器。我看了提示才知道，是存在s0寄存器的。这是怎么看出来的？我完全想不到怎么就拐到s0了。</p>
</blockquote>
<h5 id="栈的结构与栈帧的理解"><a href="#栈的结构与栈帧的理解" class="headerlink" title="栈的结构与栈帧的理解"></a>栈的结构与栈帧的理解</h5><p><img src="/2023/01/10/xv6/image-20230112010749756.png" alt="image-20230112010749756"></p>
<p>这是来自hint的栈结构。整个栈存储在一页中，由高地址向低地址增长。栈帧代表了一次函数调用，其中会存储如函数名、函数参数、局部变量等等信息。有几次函数调用就有几个栈帧，栈由栈帧组成。</p>
<p>s0中存储的栈帧指针fp指向的是栈帧的最高地址，如图fp所示。</p>
<blockquote>
<p>我理解错了栈帧的定义，都怪我基础不大牢固也不认真思考【悲】我一开始以为stack frame指的是一个栈，也即一页空间【我知道栈帧这个中文名词，但遇到英语就短路了】。老师画的这个图也被我理解为多个栈，也即多页拼在一起，要打印的Return Address处于页的最顶部。我就在这个思路上一去不复返了，压根没有意识到一个进程tmd只有一个栈啊！！！【大悲】然后顺带脑补把r_fp()也曲解了，以为它的意思是读取当前栈【非常自然地认为有很多个栈←】的下一个栈的最低地址【因为栈换掉了，所以s0也会变成父亲的栈的地址】。于是就写出了这样的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">   uint64 kstack = PGROUNDUP((uint64)(myproc()-&gt;kstack)+<span class="number">1</span>);</span><br><span class="line">   uint64 nstack = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>((nstack=(uint64)r_fp())!=<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*((uint64*)(kstack<span class="number">-8</span>)));</span><br><span class="line">         kstack = nstack;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果最后死循环了。去看了别人的代码发现他们写的结构就跟我完全不一样。琢磨着画着图，最后找了stack frame的定义，才恍然大悟（</p>
</blockquote>
<h5 id="思路形成"><a href="#思路形成" class="headerlink" title="思路形成"></a>思路形成</h5><p>我们只需遍历栈中所有栈帧，打印每个栈帧的Return Address部分就行。通过r_fp()获取第一个栈帧的位置，其他栈帧的位置由Prev.Frame获取。循环的界限是PGROUNDUP(r_fp())，因为栈只有一页的空间。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  uint64 <span class="built_in">stack</span> = r_fp();</span><br><span class="line">  uint64 nstack = <span class="number">0</span>;</span><br><span class="line">  uint64 top = PGROUNDUP(<span class="built_in">stack</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">stack</span>!=top)&#123;</span><br><span class="line">    nstack=*((uint64*)(<span class="built_in">stack</span><span class="number">-16</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*((uint64*)(<span class="built_in">stack</span><span class="number">-8</span>)));</span><br><span class="line">    <span class="built_in">stack</span> = nstack;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><blockquote>
<p>In this exercise you’ll add a feature to xv6 that <u>periodically alerts a process as it uses CPU time</u>. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. </p>
<p>More generally, you’ll be implementing a primitive form of user-level interrupt/fault handlers; you could use something similar to handle page faults in the application, for example. </p>
<p>You should add a new <code>sigalarm(interval, handler)</code> system call. If an application calls <code>sigalarm(n, fn)</code>, then after every <code>n</code> “ticks” of CPU time that the program consumes, the kernel should cause application function <code>fn</code> to be called. When <code>fn</code> returns, the application should resume where it left off.</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h5><p>思路：sigalarm需要在用户程序在用户态运行的情况下，监测到用户程序已经运行了n个时间片，然后发出中断请求。我们会新设置一个中断类型alarm。kerneltrap接收到sigalarm的中断请求，检测到中断类型为alarm，就会在处理的时候调用fn。fn调用完就自然而然利用中断恢复到原来的现场了。所以要做的可以分为两部分。但问题是，如何让sigalarm在用户程序运行的同时监测n个时间片呢？难道得fork一个新的进程吗？然后父进程返回，子进程执行类似sleep里面那样的监测，直到时间片到了，就发送一个中断请求，让父进程停止，执行完fn回来之后就exit。</p>
<h5 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h5><p>可以看到，初见思路很多地方跟最后是不一样的。其中错得最离谱的，也是比较隐坑很容易因为想不明白就寄了的，是handler是个用户态的函数（。你不可能在内核态中调用fn，然后fn执行完后再自然而然地通过中断机制返回，因为你想要执行fn就必须进入用户态。这一点是需要一开始明确的。</p>
<p>明确了这一点后，让人更加不知道该怎么办了。那就一步步跟着指导书的脚步来思考吧。</p>
<h6 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h6><p>首先，明确你需要实现什么。你需要实现两个系统调用，一个是sigalarm，一个是sigreturn。它们会被这样调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in user/alarmtest.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  test0();</span><br><span class="line">  test1();</span><br><span class="line">  test2();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">periodic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  count = count + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;alarm!\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 此处调用sigreturn</span></span><br><span class="line">  sigreturn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tests whether the kernel calls</span></span><br><span class="line"><span class="comment">// the alarm handler even a single time.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;test0 start\n&quot;</span>);</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 此处调用sigalarm</span></span><br><span class="line">  sigalarm(<span class="number">2</span>, periodic);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>*<span class="number">500000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((i % <span class="number">1000000</span>) == <span class="number">0</span>)</span><br><span class="line">      write(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此处调用sigalarm</span></span><br><span class="line">  sigalarm(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test0 passed\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ntest0 failed: the kernel never called the alarm handler\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__ ((noinline)) foo(<span class="type">int</span> i, <span class="type">int</span> *j) &#123;</span><br><span class="line">  <span class="keyword">if</span>((i % <span class="number">2500000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    write(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *j += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// tests that the kernel calls the handler multiple times.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// tests that, when the handler returns, it returns to</span></span><br><span class="line"><span class="comment">// the point in the program where the timer interrupt</span></span><br><span class="line"><span class="comment">// occurred, with all registers holding the same values they</span></span><br><span class="line"><span class="comment">// held when the interrupt occurred.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;test1 start\n&quot;</span>);</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  sigalarm(<span class="number">2</span>, periodic);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">500000000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">10</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    foo(i, &amp;j);</span><br><span class="line">  &#125;</span><br><span class="line">  sigalarm(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line">  <span class="keyword">if</span>(count &lt; <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ntest1 failed: too few calls to the handler\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">    <span class="comment">// the loop should have called foo() i times, and foo() should</span></span><br><span class="line">    <span class="comment">// have incremented j once per call, so j should equal i.</span></span><br><span class="line">    <span class="comment">// once possible source of errors is that the handler may</span></span><br><span class="line">    <span class="comment">// return somewhere other than where the timer interrupt</span></span><br><span class="line">    <span class="comment">// occurred; another is that that registers may not be</span></span><br><span class="line">    <span class="comment">// restored correctly, causing i or j or the address ofj</span></span><br><span class="line">    <span class="comment">// to get an incorrect value.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ntest1 failed: foo() executed fewer times than it was called\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1 passed\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再结合提示，可知实验设计者给我们的思路是，通过sigalarm设置定时函数，通过sigalarm(0,0)取消定时函数。每次时钟中断检测当前定时时间是否达到，若已达到，则跳到定时函数执行。定时函数执行完后，需要借助sigreturn，才能正确返回时钟中断前的程序点。</p>
<h6 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h6><p>这又可拆解为几个要点：</p>
<ol>
<li>如何实现“定时”？</li>
<li>时钟中断在内核态的usertrap被检测。怎么从usertrap出来跳到定时函数而非原程序执行点？</li>
<li>执行完定时函数后，怎么样才能回到原程序执行点？</li>
</ol>
<h6 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a>part 3</h6><p>一个个来说，首先是如何实现定时。这个很简单。参照sys_sleep的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  backtrace();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，我们可以用ticks表示当前系统滴答数。这样，我们就可以在proc域里维护一个变量lasttick，记录上一次执行handler时的滴答数。每次在时钟中断时检测，所以需要写在<code>kernel/trap.c</code>中的<code>usertrap</code>中。</p>
<h6 id="part-4"><a href="#part-4" class="headerlink" title="part 4"></a>part 4</h6><p>然后，是怎么从usertrap出来跳到指定程序结束点。在书中，我们知道，sepc寄存器保存了中断前原程序的下一个执行点，sepc的备份存储在了proc域中的栈帧中。当中断返回时（在usertrapret中），会从栈帧中的epc字段读取sepc的备份赋值给sepc，再由sret帮助我们跳转到原程序点。因而，如果想要改变跳转点，我们只需要修改<code>p-&gt;trapframe-&gt;epc</code>就行。</p>
<h6 id="part-5"><a href="#part-5" class="headerlink" title="part 5"></a>part 5</h6><p>最后，是如何从periodic回到原程序执行点。</p>
<p><img src="/2023/01/10/xv6/image-20230113002057893.png" alt="image-20230113002057893"></p>
<p>这是每次进行时钟中断时的栈情况和执行代码链：t1-&gt;trampoline-&gt;usertrap-&gt;handler。</p>
<p>再然后，handler调用了sigreturn，用户栈中就会产生sigreturn的栈帧：</p>
<p><img src="/2023/01/10/xv6/image-20230113002434093.png" alt="image-20230113002434093"></p>
<p>此时，如果sigreturn执行完，就会在这样的情况下执行handler的ret指令：</p>
<p><img src="/2023/01/10/xv6/image-20230113002542335.png" alt="image-20230113002542335"></p>
<p>ret指令会把栈帧弄走，也就是说会直接回到某个错误的地方去。这显然不大合适。所以，我们要做的，就是在sigreturn之后，<u>不执行handler的ret指令，也不执行sigreturn的ret指令，而是直接恢复到时钟中断前的上下文</u>。时钟中断前的上下文，会因在handler中调用sigreturn系统调用，而被<strong>覆盖</strong>，因而，我们就需要记录时钟中断前的上下文，也即在proc域中保存trapframe的一份拷贝savedtrap，每次时钟中断都更新一次savedtrap，然后在sigreturn调用的时候将proc原本的trapframe替换为savedtrap即可。这样一来，就完成了这道题。</p>
<h5 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h5><p>这题目确实最终代码看起来完全不难，但是非常地拷打。。。。我前前后后修修补补差不多一共花了五个小时之久。</p>
<p>计时怎么计，以及使用trapframe-&gt;epc来跳转这两点还是很容易想到的【话虽如此，其实也很曲折】。主要难点还是在怎么恢复现场。怎么说呢，我花了这么久做实验，但是实际笔记却写不出个鬼来，足以看出其复杂程度。</p>
<p>我主要还是思维固化了点，一直在想，怎么确保它正确返回现场。我一开始以为proc域保存一个寄存器状态，且只用在一开始设置定时函数也即sigalarm的时候保存一次就行了，并且认为其是epc。然而实际操作后发现usertrap崩了，并且epc中存储的并不是程序被时钟中断的地方，而是各种神奇的地方，具体我也忘了，反正不能行。我印象最深刻的是有一次停在了usys.S中的sigreturn的最后一个ret处。我就在想，也许是栈出了问题。于是我就想着直接在sigreturn的时候把epc指向栈帧中的return address，直接回到原执行段。我百度了一下，确实有这么个寄存器ra，存储着return address。于是我就把proc域的状态换成了ra，依然仅保存一次，最后发现还是不行，程序在test0之后就异常终止了，main也回不去，十分古怪，十分匪夷所思。我实在没忍住，百度了一下大家怎么做的，发现大家压根没有我这样的二选一的烦恼，是直接保存整个栈帧。而且也不是仅保存一次，而是每次时钟中断触发都保存一次。我觉得十分奇怪震惊，但此时已是差不多晚饭时间，我就先去吃了个饭（）</p>
<p>回来之后，我细细画了图【向正确思路part5中的那样】，发现我原来那个只保存两者之一，且都只保存一次的方式，确实完全不能行。但是，我发现两个一起保存，并且每次时钟中断保存的方法，似乎能行，而且，比保存一整个栈帧要聪明得多。于是我就去试了，发现还是不行。我再细想了一遍，发现，如果想回去原程序的现场，除了ra和epc，还有一个很重要的东西需要保存，那就是——用户栈指针sp！</p>
<p>也就是说，<strong>只需保存ra、epc、sp，就可以保证回到正确的时钟中断前的位置</strong>：</p>
<p><img src="/2023/01/10/xv6/image-20230113005100895.png" alt="image-20230113005100895"></p>
<p>此为handler中sigreturn执行完要返回时的状态。</p>
<p>当处在handler中时，sp的值为sigreturn处的栈帧。执行系统调用时，proc域中的上下文被覆盖，也即时钟中断前的上下文被覆盖。如果此时不对栈帧中的sp进行恢复，仅恢复ra和epc，在从sigreturn返回到epc对应处也即t1，t1执行ret想回到main的时候，就会回不去，而是回到了sigreturn要回的位置，也即handler的位置，然后不知不觉就寄了。所以，就需要防止sp被覆盖。因而，再保存一个状态sp，就可以保障回到正确的地方了。测试出来，kernel确实不再会panic了。</p>
<p>但是由于运行时很多除这三个以外的寄存器都被改过了，回是回得去，接下来干的活就不一定对了。因此为了保险以及通用性以及便利性来看，还是像别人那样直接保存栈帧比较ok。</p>
<p>还有一件事，就是上述错误中经常会出现的一个输出结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">usertrap:unexpected cause scause = <span class="number">0x0c</span></span><br></pre></td></tr></table></figure>

<p>我留意了一下是什么意思。网上搜索得，scause=12，说明这是一个instruction page fault，而这个缺页错误说明了什么？：</p>
<p><img src="/2023/01/10/xv6/image-20230113012355740.png" alt="image-20230113012355740"></p>
<p>这样，一切都明朗了。出现了scause=0x0c的意思就是说pc里的值不恰当，也就是说上面错误的方法都会跳转到错误的地方去。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h5 id="sigalarm-c"><a href="#sigalarm-c" class="headerlink" title="sigalarm.c"></a>sigalarm.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> intervel,<span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;interval = intervel;</span><br><span class="line">    p-&gt;handler = handler;</span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    p-&gt;lasttick = ticks;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">if</span>(handler == <span class="number">0</span> &amp;&amp; intervel == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(p-&gt;savetrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sigreturn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    memmove(p-&gt;trapframe,p-&gt;savetrap,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="trap-c"><a href="#trap-c" class="headerlink" title="trap.c"></a>trap.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">    yield();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;interval!=<span class="number">0</span>&amp;&amp;p-&gt;flag!=<span class="number">1</span>)&#123;</span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      uint tmp = ticks-p-&gt;lasttick;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">if</span>(tmp &gt;= p-&gt;interval&amp;&amp;p-&gt;flag!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          memmove(p-&gt;savetrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">          p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;	</span><br><span class="line">          p-&gt;flag=<span class="number">1</span>;</span><br><span class="line">          p-&gt;lasttick = ticks;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab：xv6-lazy-page-allocation"><a href="#Lab：xv6-lazy-page-allocation" class="headerlink" title="Lab：xv6 lazy page allocation"></a>Lab：xv6 lazy page allocation</h2><blockquote>
<p>来自书本：</p>
<p>Another widely-used feature is called <em>lazy allocation</em>, which has two parts:</p>
<ol>
<li>First, when an application calls sbrk, the kernel grows the address space, but marks the new addresses as not valid in the page table. </li>
<li>Second, on a page fault on one of those new addresses, the kernel allocates physical memory and maps it into the page table. </li>
</ol>
<p>The kernel allocates memory only when the application actually uses it. </p>
</blockquote>
<h3 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk()"></a>Eliminate allocation from sbrk()</h3><blockquote>
<p>Your first task is to delete page allocation from the sbrk(n).</p>
<p>The sbrk(n) system call grows the process’s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process’s size (myproc()-&gt;sz) by n and return the old size. It should not allocate memory – so you should delete the call to growproc() (but you still need to increase the process’s size!).</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> sz = myproc()-&gt;sz;</span><br><span class="line">  addr = sz;</span><br><span class="line">  myproc()-&gt;sz = sz + n;</span><br><span class="line">  <span class="comment">//if(growproc(n) &lt; 0)</span></span><br><span class="line">  <span class="comment">//  return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h3><blockquote>
<p>Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. </p>
<p>You should add your code just before the <code>printf</code> call that produced the “usertrap(): …” message. Modify <strong>whatever</strong> other xv6 kernel code you need to in order to get <code>echo hi</code> to work.【不择手段地前进！&lt;- 既视感】</p>
</blockquote>
<h4 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>首先，要知道缺页中断的scause为13或15.【论我怎么知道的：被以前的实验逼出来的hhh】然后，要写在if条件的第二个分支。在该分支内，我们需要先获取出问题的地方的虚拟地址的值，然后申请新的一页，再map到当前页表中。</p>
<h5 id="一个难以察觉的错误"><a href="#一个难以察觉的错误" class="headerlink" title="一个难以察觉的错误"></a>一个难以察觉的错误</h5><p>思路是很简单的，就是有小细节需要格外注意。</p>
<p>trap.c在<code>mappages</code>时，一定不能直接传入va，必须传入<code>PGROUNDDOWN(va)</code>。如果直接传入va，会爆出如下错误：</p>
<p><img src="/2023/01/10/xv6/image-20230116154004538.png" alt="image-20230116154004538"></p>
<p>但是，查看<code>mappages</code>的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，它在里面已经对va进行了处理了，使它变成了page-align的a变量。那么为什么，我们还要在外面再对va处理一次呢？</p>
<p>其实问题不是出在<code>mappages</code>中的a变量上，而是出现在<code>mappages</code>中的last变量上。比如，令va=PGSIZE+200，则a=PGSIZE，last=2*PGSIZE。这样一来，在下面的循环中，除了添加了刚刚申请的那页的映射以外，我们还多添加了新的一页，其物理地址为mem+PGSIZE。</p>
<p>这十分地危险！假设你要申请的va为proc-&gt;size的最后一页，那么，经过本次缺页中断之后，你事实上申请了两页，两页的地址分别为va和va+PGSIZE。而va+PGSIZE大于proc-&gt;size。也就是说，地址溢出了！</p>
<p>这会导致<strong>页表释放</strong>的时候出问题。以下是页表释放的路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">    uvmunmap(pagetable, <span class="number">0</span>, PGROUNDUP(sz)/PGSIZE, <span class="number">1</span>);</span><br><span class="line">  freewalk(pagetable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap walk: %p\n&quot;</span>,a);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap: %p\n&quot;</span>,a);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap OK: %p\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freewalk要求在uvmunmap中已经释放完所有的叶子结点。而由于uvmunmap中释放结点的va是从0递增到proc-&gt;size的，也因而，前面的那个大于proc-&gt;size的那页虽然还在页表中存在，但是不会被uvmunmap释放！这也就导致，接下来调用freewalk的时候，会发现该页的叶子结点仍然存在，从而导致<code>freewalk: leaf</code>。</p>
<p>可以结合uvmunmap和trap.c中的调试语句看下图的过程，可以看到非常清晰明了，0x14000这一页并没有在uvmunmap中释放！</p>
<p>trap.c中的调试语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap: %p,+PGSIZE = %p\n&quot;</span>,PGROUNDDOWN(va),PGROUNDDOWN(va)+PGSIZE);</span><br><span class="line">   <span class="keyword">if</span>(mappages(p-&gt;pagetable,va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">     kfree(mem);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>图：</p>
<p><img src="/2023/01/10/xv6/image-20230116165910356.png" alt="image-20230116165910356"></p>
<h5 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h5><p>看到<code>freewalk: leaf</code>这一错误，很容易联想到跟页表的释放有关。并且加上PGGROUNDDOWN就没问题，不加上才有问题，也很容易联想到跟mappages中多申请的那一页有关。但是具体是什么关系，这一点想要想到对我来说还是非常曲折的。</p>
<p>我一开始，以为是因为多申请的那一页（下面简称为B页好了）很有可能是其他进程在使用的，然后其他进程在echo进程释放页表前释放了页表，从而导致B页已经free了，这样一来<code>uvmunmap</code>说不定就能监测到对应物理页已经free，然后爆出panic。我一开始认为<code>uvmunmap</code>的这句话是用来监测物理页是否free的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">   <span class="comment">//panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>然后顺理成章地，这边条件==0成立，然后continue，然后直到freewalk才发现该pte未释放。</p>
<p>但是，我仔细过脑子想了想，发现，就算物理页已经free了，但是，*pte依然存在，PTE_V也依然为1，这个条件是不成立的。也就是说，B页不会continue，而是会继续下面的正常释放的流程。也就是说，B页是可以正常释放的，我们的“B页已经free导致uvmunmap释放失败”的推论是错误的。</p>
<p>但究竟是为什么呢？肯定跟B页有关系，但是又不是这种关系，这让我十分地苦恼且烦躁，于是我就去打了会儿游戏。边玩的时候突然注意到一件非常可疑的事情。</p>
<p><img src="/2023/01/10/xv6/image-20230116154004538.png" alt="image-20230116154004538"></p>
<p>这是发生错误时退出的截图。有一个点引起了我的注意，就是echo hi并没有打印hi在console上。也就是说，这个panic是在echo执行前产生的！那么这个执行前是在哪呢？答案就是在exec中！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in exec.c</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  <span class="comment">// 这里！！！！！</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure>

<p>可以看到，这里调用了<code>proc_freetable</code>，从而跟freewalk有了联系。</p>
<p>但是，如果我们还坚持是因为B页错的，就需要找到一个可能会产生B页的地方，也就是验证shell准备执行echo命令，fork出一个子进程之后，又在exec free页表前，已经调用过sbrk函数，并且已经触发过缺页中断。这个验证其实很简单，只需要找sbrk在哪被调用过，哪边使用过heap内存【也即哪边涉及了指针赋值】就行了。</p>
<p>通过全局搜索，可知sbrk在<code>user/umalloc.c</code>下的<code>malloc()</code>被使用过，而在<code>user/sh.c</code>中，fork子进程之后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">  runcmd(parsecmd(buf));</span><br></pre></td></tr></table></figure>

<p>这其中的<code>parsecmd()</code>中malloc被使用过，并且发生了指针赋值！！也就是说，“是因为B页错的”这个结论是对的。</p>
<p>虽然这一段debug没有改变我们要证明“是B页在释放内存中出错的”的这个目的，但是确实带给了我很多这种执行时申请内存的知识，并且也让我突然想起了可以用printf debug。于是，我就去做了上面那个在trap.c中和uvmunmap中printf的调试语句，最终成功发现了结论。</p>
<p>实在是太艰苦了（）这告诉我们以后千万千万要注意，是否需要用到PGGROUNDDOWN。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><h5 id="trap-c-1"><a href="#trap-c-1" class="headerlink" title="trap.c"></a>trap.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c usertrap()</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">13</span> || scause == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="type">char</span>* mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U|PTE_V) != <span class="number">0</span>)&#123;</span><br><span class="line">        kfree(mem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h5 id="vm-c"><a href="#vm-c" class="headerlink" title="vm.c"></a>vm.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/vm.c uvmunmap()</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmunmap: not mapped&quot;);</span></span><br></pre></td></tr></table></figure>

<h3 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h3><blockquote>
<p>We’ve supplied you with <code>lazytests</code>, an xv6 user program that tests some specific situations that may stress your lazy memory allocator. Modify your kernel code so that all of both <code>lazytests</code> and <code>usertests</code> pass.</p>
</blockquote>
<h4 id="感想-3"><a href="#感想-3" class="headerlink" title="感想"></a>感想</h4><h5 id="一个绷不住的错误"><a href="#一个绷不住的错误" class="headerlink" title="一个绷不住的错误"></a>一个绷不住的错误</h5><p>其实很简单，按照提示一步步做就行了。为什么我做得那么久那么崩溃呢？知道原因后我都笑嘻了。</p>
<p>在第一步修改<code>sys_sbrk()</code>的时候，我一下子没多想，使用了一句<code>int sz = myproc()-&gt;sz</code>，其实本来应该使用uint64的，使用int会溢出。这个伏笔就一直隐含到这里，然后大坑了我一笔。</p>
<p>一开始是发现<code>lazytests</code>的第二个，也就是oom过不去。我想了很久，也去网上找了别人的代码一步步对比下来看了，没有发现特别大的问题。于是我就在walk和sys_sbrk分别留下了调试信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in walk()</span></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;walk:va=%p,p-&gt;sz=%p,MAXVA=%p,pgva=%p\n&quot;</span>,va,myproc()-&gt;sz,MAXVA,PGROUNDDOWN(va));</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in sys_sbrk()</span></span><br><span class="line">  <span class="keyword">if</span>(n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    uint64 tmp = n + sz;</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; MAXVA || n + sz &lt; n)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    myproc()-&gt;sz = tmp;</span><br><span class="line">    <span class="comment">//printf(&quot;haha sb!sz=%p,n=%p\n&quot;,myproc()-&gt;sz,n);</span></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>然后发现了这样的输出：</p>
<p><img src="/2023/01/10/xv6/image-20230116225124363.png" alt="image-20230116225124363"></p>
<p>可以看到，最后一次sz发生了数值溢出。</p>
<p>但是，此时我并没有悔改。我反而认为，“原本代码就是这么写的”。也就是说，我认为<code>int sz</code>是它原本内核代码给的。。。。。。在这样的情况下，我选择加上这样的条件判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(tmp &gt; MAXVA || ((tmp &gt;&gt; <span class="number">31</span>)&amp; <span class="number">1</span>) == <span class="number">1</span>)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>之后确实没有溢出了，但是test fail了。此时我想，为什么非要用int而不用uint64呢？一阵令人不寒而栗的预感袭来，我连忙去看了<code>proc.h</code>里的sz的定义，发现，sz原本就应该是uint64类型的，是我错辣【悲】</p>
<p>只能说起到一种很好的教训。主要是这种问题实在没有想过自己会犯</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><blockquote>
<ul>
<li>Handle the parent-to-child memory copy in fork() correctly.</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c uvmcopy()</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Handle negative sbrk() arguments.</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  uint64 sz = myproc()-&gt;sz;</span><br><span class="line">  addr = sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    uint64 tmp = n + sz;</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; MAXVA || n + sz &lt; n)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    myproc()-&gt;sz = tmp;</span><br><span class="line">    <span class="comment">//printf(&quot;haha sb!sz=%p,n=%p\n&quot;,myproc()-&gt;sz,n);</span></span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n + sz &gt; <span class="number">0</span>)</span><br><span class="line">      myproc()-&gt;sz = uvmdealloc(myproc()-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//if(growproc(n) &lt; 0)</span></span><br><span class="line">  <span class="comment">//  return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</p>
</li>
<li><p>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</p>
</li>
<li><p>Handle faults on the invalid page below the user stack.</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">13</span> || scause == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= p-&gt;sz ||  va &lt; PGROUNDUP(p-&gt;trapframe-&gt;sp) ||PGROUNDDOWN(va) &gt;= MAXVA)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;va=%p stack=%p\n&quot;,va,PGROUNDUP(r_sp()));</span></span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">char</span>* mem = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(mem != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">//printf(&quot;trap: %d %p\n&quot;,p-&gt;pid,PGROUNDDOWN(va));</span></span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">          kfree(mem);</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li>
</ul>
<p>我认为这里要是引起一个缺页中断可能会更酷，可能可以像lazytests里面这么做：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *i, *prev_end, *new_end;</span><br><span class="line"></span><br><span class="line">prev_end = sbrk(REGION_SZ);</span><br><span class="line">new_end = prev_end + REGION_SZ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里触发了多次缺页中断</span></span><br><span class="line"><span class="keyword">for</span> (i = prev_end + PGSIZE; i &lt; new_end; i += PGSIZE * PGSIZE)</span><br><span class="line">  *(<span class="type">char</span> **)i = i;</span><br></pre></td></tr></table></figure>

<p>之后有机会再试试233</p>
<p>【试了一下，发现是可以的。在COW fork的  <code>感想—一些错误和思考—在内核态中引发并处理缺页中断</code>  这部分内容中详细说明了具体要怎么做。】</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 缺页中断</span></span><br><span class="line">    <span class="keyword">if</span>(va &gt;= p-&gt;sz ||  va &lt; PGROUNDUP(p-&gt;trapframe-&gt;sp) ||PGROUNDDOWN(va) &gt;= MAXVA)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;va=%p stack=%p\n&quot;,va,PGROUNDUP(r_sp()));</span></span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">char</span>* mem = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(mem != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">//printf(&quot;trap: %d %p\n&quot;,p-&gt;pid,PGROUNDDOWN(va));</span></span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">          kfree(mem);</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab-Copy-on-Write-Fork-for-xv6"><a href="#Lab-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab: Copy-on-Write Fork for xv6"></a>Lab: Copy-on-Write Fork for xv6</h2><blockquote>
<p>Parent and child can safely share phyical memory using copy-on-write fork, driven by page faults. </p>
<p>RISC-V has <u>three different kinds of page fault</u>: <strong>load</strong> page faults (when a load instruction cannot translate its virtual address), <strong>store</strong> page faults (when a store instruction cannot translate its virtual address), and <strong>instruction</strong> page faults (when the address for an instruction doesn’t translate). </p>
<p>The <strong>basic plan</strong> in COW fork is for the parent and child to initially share all physical pages, but to map them <strong>read-only</strong>. Thus, when the child or parent executes a store instruction, the RISC-V CPU raises a page-fault exception. In response to this exception, the kernel makes a copy of the page that contains the faulted address. It maps one copy read/write in the child’s address space and the other copy read/write in the parent’s address space. After updating the page tables, the kernel resumes the faulting process at the instruction that caused the fault.</p>
<p>PS【这个很重要】: COW fork() makes freeing of the physical pages that implement user memory a little trickier. A given physical page may be referred to by multiple processes’ page tables, and should be freed only when the last reference disappears.</p>
</blockquote>
<h3 id="感想-4"><a href="#感想-4" class="headerlink" title="感想"></a>感想</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>思路还是很直观的。</p>
<p>我们只需要在fork的时候，标记父子进程的所有PTE都为read-only，然后之后就会遇到不同scause的缺页中断，针对特定的scause，新建物理页面，拷贝物理页面，然后重新设置映射即可。而对于其提出的需要标记某页是否能够释放，则需要统计每页的ref数，当ref==1的时候才可以释放。</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><h5 id="总分析"><a href="#总分析" class="headerlink" title="总分析"></a>总分析</h5><p>其实可以把任务简单拆分为三部分。第一部分是实现基本的cow fork的逻辑，第二部分是引用计数释放内存，第三部分是解决copyin/copyout时在内核态发生的缺页中断。我认为本实验的难点事实上在第二部分【悲】我可能有大于3/4的时间都花在第二部分上了吧。</p>
<p>第一部分是实现cow fork的基本逻辑，也就是修改fork中对页表的拷贝以及在usertrap中添加对缺页中断的处理，这很直观，没什么好说的。</p>
<p>第三部分要么跟上面的lazy allocation一样，在<code>kernel/vm.c walkaddr()</code>中把缺页中断搬过去，要么向我在<code>主要难点与错误—在内核态中引发并处理缺页中断</code>这一部分那样做。</p>
<p>我们分析这一部分主要讲的是我认为最难的地方，也就是第二部分。其实第二部分的思路也很直观：创建一个数组，index为所有能用的内存的<code>address/PGSIZE</code>，用来记录引用数；然后在每次增加引用时，对应元素++；每次减少引用时，对应元素–。</p>
<p>虽然思路很简单很直观，但是实现起来非常地非常地非常地考验细节（我就非常不擅长这一点）。下面，我就先阐述一下<strong>第二部分的这个方法</strong>需要分割为哪几部分，其他我遇到的印象较深的bug和对一些地方的思考，都放在了下一部分，也即<code>主要难点与错误</code>。</p>
<h5 id="引用数实现分析"><a href="#引用数实现分析" class="headerlink" title="引用数实现分析"></a>引用数实现分析</h5><blockquote>
<p>创建一个数组，index为所有能用的内存的<code>address/PGSIZE</code>，用来记录引用数；然后在每次增加引用时，对应元素++；每次减少引用时，对应元素–。</p>
</blockquote>
<h6 id="数组的大小和数据类型"><a href="#数组的大小和数据类型" class="headerlink" title="数组的大小和数据类型"></a>数组的大小和数据类型</h6><p>由<code>kernel/kalloc.c</code>中的<code>kinit()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="comment">// freerange用来把参数地址范围内的物理页加入freelist中</span></span><br><span class="line">  <span class="comment">// end是内核的结束地址</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，事实上，我们整个程序，包括用户和内核，能用的内存空间为0~PHYSTOP。因而，我们事实上只需要建一个<code>PHYSTOP/PGSIZE</code>这么大的数组就行。我算了一下大概是2^19次方。</p>
<p>然后，我感觉这种小系统应该不会有过多的对某一页的重复引用，因而，为了节省空间，我将数据类型定为了char。最好还是别定成uchar，因为这东西要是0–的话会溢出变为255，很可怕。</p>
<h6 id="什么时候增减引用"><a href="#什么时候增减引用" class="headerlink" title="什么时候增减引用"></a>什么时候增减引用</h6><blockquote>
<p>我认为这里是非常考验细节和头脑清晰度的，也就是我卡了很久最后也没弄出来的部分【悲】</p>
</blockquote>
<p>可以分为三种情况来讲。我们的引用计数必须完美适应这三种情况：</p>
<ol>
<li><p>不经由页表，通过kalloc和kfree直接使用物理页</p>
<p>这就要求我们在kalloc的时候置引用数为1，然后kfree的时候对引用数先-1，再判断是否归零。</p>
</li>
<li><p>经由页表，但与cow fork无关</p>
<p>增加页表项：mappages-&gt;kalloc，因而满足要求1即可。</p>
<p>删除页表项：uvmunmap。当do_free==1时，满足要求1即可。</p>
</li>
<li><p>经由页表，与cow fork有关</p>
<p>copy父进程页表时：在cowcopy中，每增加一次子进程的映射，就需要增加一次引用数</p>
<p>在用户态/内核态发生缺页中断：发生缺页中断后，对原来物理页的引用数需要-1【我就是漏了这一点……】</p>
<p>删除页表项：uvmunmap。当do_free==0时，当对应页表项有COW标记，则减少引用数</p>
</li>
</ol>
<p>所以，我们需要在三个文件进行修改：</p>
<ol>
<li><p>kalloc.c</p>
<p>增加数组定义，在kalloc和kfree中增加引用数修改</p>
</li>
<li><p>vm.c</p>
<p>在cowcopy和uvmunmap中增加引用数修改</p>
</li>
<li><p>trap.c</p>
<p>在usertrap的缺页中断中增加引用计数修改</p>
</li>
</ol>
<h6 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h6><blockquote>
<p>这里我也没想到【悲】</p>
</blockquote>
<p>由于我们的pages数组会在多个文件、多个进程间使用，所以它必须在被锁保护的区域中被使用。</p>
<h4 id="主要难点与错误"><a href="#主要难点与错误" class="headerlink" title="主要难点与错误"></a>主要难点与错误</h4><h5 id="scause-2"><a href="#scause-2" class="headerlink" title="scause=2"></a>scause=2</h5><p><img src="/2023/01/10/xv6/image-20230117161404719.png" alt="image-20230117161404719"></p>
<p>这个发生在我还没有实现第二部分的时候。搜索了一下，scause=2为<code>Illegal instruction</code>，而且sepc的这个1004的值也非常诡异。这应该是因为fork子进程释放了指令段内存，导致主进程执行错误</p>
<h5 id="kernel无法启动"><a href="#kernel无法启动" class="headerlink" title="kernel无法启动"></a>kernel无法启动</h5><p>在kinit中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;pages_lock,<span class="string">&quot;pages&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(pages, <span class="number">0</span>, (<span class="number">2</span>&lt;&lt;<span class="number">19</span>));</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会通过freerange初始化freelist。在freerange中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会对每一项进行一次kfree。因而，我们需要在kfree前先增加一次引用，要不然会寄。</p>
<h5 id="在缺页中断时减少对物理页的引用数"><a href="#在缺页中断时减少对物理页的引用数" class="headerlink" title="在缺页中断时减少对物理页的引用数"></a>在缺页中断时减少对物理页的引用数</h5><p><img src="/2023/01/10/xv6/image-20230117213903706.png" alt="image-20230117213903706"></p>
<p>注意此处不能直接让pages[pa/PGSIZE]–，一定要借助kfree。当此进程为引用pa的最后一个进程的时候，如果仅减少引用数，就会造成内存泄漏。kfree可以既减少引用数，又在适当的时候对物理页释放，可谓一举两得。kfree的这个双重作用思想也在uvmunmap中体现了。</p>
<h5 id="在内核态中引发并处理缺页中断"><a href="#在内核态中引发并处理缺页中断" class="headerlink" title="在内核态中引发并处理缺页中断"></a>在内核态中引发并处理缺页中断</h5><blockquote>
<p>Modify copyout() to use the same scheme as page faults when it encounters a COW page.</p>
</blockquote>
<p>我们所做的第一第二部分仅仅是完成了对来自用户态的缺页中断的完美处理，还尚未处理来自内核态的缺页中断。因而，这个修改copyin和copyout的点实际上就是要我们处理内核态的缺页中断。</p>
<p>这次实验跟上次的lazy allocation一样，都可以直接在walkaddr进行特殊处理，并且差不多要把usertrap的全部代码挪过来【具体见lazy allocation的代码】，我认为这样做非常不优雅。于是，我选择直接引发一个缺页中断，然后处理这个中断，就像usertrap一样。</p>
<p>但由于在<code>walkaddr</code>中发生的中断处于内核状态下，所以就进不了usertrap。我们应该在kerneltrap中再次添加和usertrap一样的中断处理。我们会像这样引发一个中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">    *(<span class="type">char</span>*)va = <span class="number">1</span>;<span class="comment">// 此处不能用pa哦</span></span><br></pre></td></tr></table></figure>

<p>然后在kerneltrap中这样处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 只要写入引起的缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line">    uint flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sepc += <span class="number">4</span>;</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">            memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">            <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">            *pte = PA2PTE(mem);</span><br><span class="line">            kfree((<span class="type">void</span>*)pa);</span><br><span class="line">            <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">            flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">            *pte = ((*pte) | flags);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br></pre></td></tr></table></figure>

<p>但是，这样做是不行的。</p>
<blockquote>
<p>会在这里卡住，会无限次不断进入kerneltrap。</p>
<p><img src="/2023/01/10/xv6/image-20230117235028133.png" alt="image-20230117235028133"></p>
</blockquote>
<p>造成这个的原因，经过一番曲折的debug之后，我发现，只要像usertrap中的syscall分支一样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重点是这里</span></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>加上这句话就行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sepc += <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>所以，结果就非常显而易见了，是因为一直卡在这句话执行不下去：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">char</span>*)va = <span class="number">1</span>;<span class="comment">// 此处不能用pa哦</span></span><br></pre></td></tr></table></figure>

<p>而为什么会卡在这呢？答案是我也不明白，调了很久还是不知道问题在哪。我注意到了很奇怪的一点放在块引用里了。</p>
<blockquote>
<p>经过调试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %p %p\n&quot;</span>,pages[pa/PGSIZE],pa,mem);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/10/xv6/image-20230118003118745.png" alt="image-20230118003118745"></p>
</blockquote>
<p>除了这一点外，还有一点很重要的是，由于<code>walkaddr</code>是需要返回一个pa的，因而我们需要手动再把pa在缺页中断后更新一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pa = PTE2PA(*pte);</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">    *(<span class="type">char</span>*)va = <span class="number">1</span>;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pa;</span><br></pre></td></tr></table></figure>

<p>总之，做了这<strong>两个</strong>关键步骤后，也能启动了，也能过cowtest了。所以下面的代码也就贴上了这里的版本。</p>
<h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>本次实验耗时经典五小时（包含笔记时间就是六个半小时了hhh），算是平均水平。很遗憾也很难受的一点是，我的错误最终还是没有自己想出来，而是参考了别人的代码才改对的。思路很简单，但是细节也依然非常多非常坑，还是得再加把劲。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>我们只需要在fork的时候，标记父子进程的所有PTE都为read-only，然后之后就会遇到不同scause的缺页中断，针对特定的scause，新建物理页面，拷贝物理页面，然后重新设置映射即可。而对于其提出的需要标记某页是否能够释放，则需要统计每页的ref数，当ref==1的时候才可以释放。</p>
<h4 id="定义COW标记"><a href="#定义COW标记" class="headerlink" title="定义COW标记"></a>定义COW标记</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) </span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 5)</span></span><br></pre></td></tr></table></figure>

<h4 id="引用数组初始化"><a href="#引用数组初始化" class="headerlink" title="引用数组初始化"></a>引用数组初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/kalloc.c</span></span><br><span class="line"><span class="type">char</span> pages[(<span class="number">2</span>&lt;&lt;<span class="number">19</span>)];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">pages_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;pages_lock,<span class="string">&quot;pages&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(pages, <span class="number">0</span>, (<span class="number">2</span>&lt;&lt;<span class="number">19</span>));</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    pages[(uint64)p/PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="申请和释放页时增删引用"><a href="#申请和释放页时增删引用" class="headerlink" title="申请和释放页时增删引用"></a>申请和释放页时增删引用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    acquire(&amp;pages_lock);</span><br><span class="line">    <span class="comment">// 在这</span></span><br><span class="line">    pages[(uint64)r/PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;pages_lock);</span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP || pages[(uint64)pa/PGSIZE] &lt;= <span class="number">0</span> )</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  <span class="comment">// 每次kfree都会减少引用</span></span><br><span class="line">  pages[(uint64)pa/PGSIZE]--;</span><br><span class="line">  <span class="comment">// 说明此时页面还被其他东西引用着，不能释放</span></span><br><span class="line">  <span class="keyword">if</span>(pages[((uint64)pa)/PGSIZE] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pages_lock);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改fork时对页表的复制操作，并标记引用数增加"><a href="#修改fork时对页表的复制操作，并标记引用数增加" class="headerlink" title="修改fork时对页表的复制操作，并标记引用数增加"></a>修改fork时对页表的复制操作，并标记引用数增加</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/proc.c fork()</span></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(cowcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// in kernel/vm.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cowcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;cowcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;cowcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// 去除flag中的PTE_W，并且给父子的都安上没有PTE_W的flag</span></span><br><span class="line">    flags = (flags &amp; (~PTE_W));</span><br><span class="line">    flags = (flags | PTE_COW);</span><br><span class="line">    *pte = ((*pte) &amp; (~PTE_W));</span><br><span class="line">    *pte = ((*pte) | PTE_COW);</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记物理页的引用数增加</span></span><br><span class="line">    acquire(&amp;pages_lock);</span><br><span class="line">    pages[pa/PGSIZE]++;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> err:</span><br><span class="line">  <span class="comment">// 失败了不能释放物理内存</span></span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理缺页中断，标记引用数减少"><a href="#处理缺页中断，标记引用数减少" class="headerlink" title="处理缺页中断，标记引用数减少"></a>处理缺页中断，标记引用数减少</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  <span class="comment">// 只要求写入引起的缺页中断</span></span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">      flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span>* mem;</span><br><span class="line">      <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">          memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">          <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">          *pte = PA2PTE(mem);</span><br><span class="line">          <span class="comment">// 减少引用，引用归零时释放</span></span><br><span class="line">          kfree((<span class="type">void</span>*)pa);</span><br><span class="line">          <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">          flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">          *pte = ((*pte) | flags);</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uvmunmap时减少引用数"><a href="#uvmunmap时减少引用数" class="headerlink" title="uvmunmap时减少引用数"></a>uvmunmap时减少引用数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint64 pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      acquire(&amp;pages_lock);</span><br><span class="line">      <span class="keyword">if</span>(((*pte) &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">          pages[pa/PGSIZE]--;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;pages_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改walkaddr"><a href="#修改walkaddr" class="headerlink" title="修改walkaddr"></a>修改walkaddr</h4><h5 id="在walkaddr中触发缺页中断"><a href="#在walkaddr中触发缺页中断" class="headerlink" title="在walkaddr中触发缺页中断"></a>在walkaddr中触发缺页中断</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="comment">// 在这里</span></span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 触发缺页中断</span></span><br><span class="line">      *(<span class="type">char</span>*)va = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 更新pa值</span></span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在kerneltrap内补上对缺页中断的处理"><a href="#在kerneltrap内补上对缺页中断的处理" class="headerlink" title="在kerneltrap内补上对缺页中断的处理"></a>在kerneltrap内补上对缺页中断的处理</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 只要写入引起的缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line">    uint flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注意，这个很重要！！！！！</span></span><br><span class="line">        sepc += <span class="number">4</span>;</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line">                                 </span><br><span class="line">        <span class="type">char</span>* mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">            memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">            <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">            *pte = PA2PTE(mem);</span><br><span class="line">            kfree((<span class="type">void</span>*)pa);</span><br><span class="line">            <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">            flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">            *pte = ((*pte) | flags);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Interrupts and device drivers</title>
    <url>/2023/01/10/xv6$chap5/</url>
    <content><![CDATA[<h1 id="Interrupts-and-device-drivers"><a href="#Interrupts-and-device-drivers" class="headerlink" title="Interrupts and device drivers"></a>Interrupts and device drivers</h1><blockquote>
<p>A <em>driver</em> is the code in an operating system that manages a particular device: </p>
<ol>
<li><strong>configures</strong> the device hardware</li>
<li>tells the device to perform <strong>operations</strong></li>
<li>handles the resulting <strong>interrupts</strong></li>
<li><strong>interacts</strong> with <strong>processes</strong> that may be waiting for I/O from the device</li>
</ol>
<p>Driver code can be tricky because a driver executes <strong>concurrently</strong> with the device that it manages. </p>
<p>In addition, the driver must understand the device’s <strong>hardware interface</strong>, which can be complex and poorly documented.</p>
</blockquote>
<p>如果devices需要让操作系统对某些事情做出响应，就要采取中断的方法。在<code>kerneltrap</code>中，内核响应中断，并且根据设备类型来决定中断处理函数。</p>
<blockquote>
<p><img src="/2023/01/10/xv6/image-20230115160523827.png" alt="image-20230115160523827"></p>
<p>这段对设备中断的概述总结得非常到位</p>
<p>也就是说，一个device driver可以分为两部分实现，一部分是接收请求，然后开启read/write；另一部分是接收中断，这个中断有可能是设备完成IO，也可能是设备需要IO，它会通知设备具体怎么做，它也会唤醒恰当的进程。</p>
</blockquote>
<h2 id="Code-Console-input"><a href="#Code-Console-input" class="headerlink" title="Code: Console input"></a>Code: Console input</h2><p>console driver是driver structure的一个实现案例。</p>
<h3 id="上层逻辑"><a href="#上层逻辑" class="headerlink" title="上层逻辑"></a>上层逻辑</h3><p>shell获取用户输入console的信息是通过系统调用<code>read()</code>实现的。read通过文件描述符，最终转向<code>consoleread()</code>来实现具体的逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in file.c fileread()</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);<span class="comment">// 在这里转向console</span></span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">// in console.c consoleinit()</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, <span class="string">&quot;cons&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uartinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里完成devsw的初始化</span></span><br><span class="line">  <span class="comment">// connect read and write system calls</span></span><br><span class="line">  <span class="comment">// to consoleread and consolewrite.</span></span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对console的读写事实上是对cons结构体里buf的读写。这个buf则是由底层逻辑管理的。<code>consoleread()</code>每次读取buf中的一行，当未读满一行且无字符输入时会阻塞，直到底层逻辑将字符放入buf。读满了一行后，<code>consoleread</code>将该行copy进用户空间，随后返回<code>read</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/console.c </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_BUF_SIZE 128</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> buf[INPUT_BUF_SIZE];</span><br><span class="line">  uint r;  <span class="comment">// Read index</span></span><br><span class="line">  uint w;  <span class="comment">// Write index</span></span><br><span class="line">  uint e;  <span class="comment">// Edit index</span></span><br><span class="line">&#125; cons;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user read()s from the console go here.</span></span><br><span class="line"><span class="comment">// copy (up to) a whole input line to dst.</span></span><br><span class="line"><span class="comment">// user_dist indicates whether dst is a user</span></span><br><span class="line"><span class="comment">// or kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint target;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">  target = n;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// wait until interrupt handler has put some</span></span><br><span class="line">    <span class="comment">// input into cons.buffer.</span></span><br><span class="line">    <span class="comment">// read和write的index一样，说明此时没有数据输入，阻塞</span></span><br><span class="line">    <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">      <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">        release(&amp;cons.lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 产生数据输入，接收数据</span></span><br><span class="line">    c = cons.buf[cons.r++ % INPUT_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == C(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file</span></span><br><span class="line">      <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">        <span class="comment">// Save ^D for next time, to make sure</span></span><br><span class="line">        <span class="comment">// caller gets a 0-byte result.</span></span><br><span class="line">        <span class="comment">// 这样下一次也能访问到eof</span></span><br><span class="line">        cons.r--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line">    cbuf = c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    dst++;</span><br><span class="line">    --n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">      <span class="comment">// the user-level read().</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="底层逻辑"><a href="#底层逻辑" class="headerlink" title="底层逻辑"></a>底层逻辑</h3><p>底层逻辑维护了与上层逻辑交互的buf。</p>
<p>console接收数据对buf的读，是通过中断来实现的。</p>
<p>当用户输入字符，UART硬件检测到读，会向操作系统发送中断。中断在<code>kerneltrap()</code>中被接收处理，然后通过<code>devintr()</code>对该中断分门别类地进行转发。console的转发路径为devintr-&gt;uartintr-&gt;consoleintr。</p>
<h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4><p> UART的全称是Universal Asynchronous Receiver and Transmitter，即异步发送和接收。它的软件上的表示形式是<em>a set of memory-mapped control registers</em>。CPU通过物理地址与这些寄存器交互，也即它们跟RAM是同一个地址空间。在xv6中，UART的地址空间从<code>UART0</code>(0x1000 0000)开始。这些寄存器地址关于<code>UART0</code>的偏移量定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the UART control registers.</span></span><br><span class="line"><span class="comment">// some have different meanings for read vs write.</span></span><br><span class="line"><span class="comment">// see http://byterunner.com/16550.html</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RHR 0                 <span class="comment">// 接收寄存器receive holding register (for input bytes)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THR 0                 <span class="comment">// 发送寄存器transmit holding register (for output bytes)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER 1                 <span class="comment">// 开关中断寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_RX_ENABLE (1&lt;&lt;0)  <span class="comment">// 如果该位被设置，则在接收寄存器有数据，即想向外界发送数据时，UART会搓出一个中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_TX_ENABLE (1&lt;&lt;1)  <span class="comment">// 如果该位被设置，则在发送寄存器有数据，即外界向硬件发送数据时，UART会搓出一个中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR 2                 <span class="comment">// FIFO control register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_ENABLE (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_CLEAR (3&lt;&lt;1) <span class="comment">// clear the content of the two FIFOs</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR 3                 <span class="comment">// line control register</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5                 <span class="comment">// line status register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="comment">// input is waiting to be read from RHR</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="comment">// THR can accept another character to send</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="/2023/01/10/xv6/image-20230115170107044.png" alt="image-20230115170107044"></p>
<p>例如，LSR寄存器包含指示输入字符是否正在等待软件读取的位。这些字符（如果有的话）可用于从RHR寄存器读取。每次读取一个字符，UART硬件都会从等待字符的内部FIFO寄存器中删除它，并在FIFO为空时清除LSR中的“就绪”位。UART传输硬件在很大程度上独立于接收硬件；如果软件向THR写入一个字节，则UART传输该字节。</p>
</blockquote>
<h4 id="kerneltrap"><a href="#kerneltrap" class="headerlink" title="kerneltrap"></a>kerneltrap</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kerneltrap()</span></span><br><span class="line">  <span class="comment">// 在此处的devintr对不同的设备进行不同的处理方式</span></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="devintr"><a href="#devintr" class="headerlink" title="devintr"></a>devintr</h4><p>devintr处在<code>trap.c</code>中，作用是对中断归类，然后分门别类地转发到下一层级的handler。</p>
<blockquote>
<p>注：</p>
<ol>
<li><p>外中断和内中断</p>
<p><a href="https://blog.csdn.net/Cheatscat/article/details/77869600">外部中断和内部中断详解</a></p>
<p>根据中断源的不同，可以把中断分为硬件中断和软件中断两大类，而硬件中断又可以分为外部中断和内部中断两类。</p>
<p>外部中断一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可以屏蔽的中断，也就是说，利用中断控制器<strong>可以屏蔽</strong>这些外部设备的中断请求。</p>
<p>内部中断是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断是<strong>不可屏蔽</strong>的中断。</p>
<p> 软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序。例如：ROM BIOS中的各种外部设备管理中断服务程序（键盘管理中断、显示器管理中断、打印机管理 中断等，）以及DOS的系统功能调用（INT 21H）等都是软件中断。【比如说系统调用之类的】</p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt,</span></span><br><span class="line"><span class="comment">// and handle it.</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt,</span></span><br><span class="line"><span class="comment">// 1 if other device,</span></span><br><span class="line"><span class="comment">// 0 if not recognized.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取scause，辨析中断类型</span></span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果来自外中断（在这里应该只指device interrupt）</span></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// irq indicates which device interrupted.</span></span><br><span class="line">    <span class="comment">// 通过PLIC硬件获取中断设备信息</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别转发</span></span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断处理完成了，可以再次开启中断</span></span><br><span class="line">    <span class="comment">// the PLIC allows each device to raise at most one</span></span><br><span class="line">    <span class="comment">// interrupt at a time; tell the PLIC the device is</span></span><br><span class="line">    <span class="comment">// now allowed to interrupt again.</span></span><br><span class="line">    <span class="keyword">if</span>(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 来自时钟中断</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uartintr"><a href="#uartintr" class="headerlink" title="uartintr"></a>uartintr</h4><p>这代码其实乍一看是看不懂的，这是因为uartintr不止负责读中断。它还负责另一个中断（发送区空余中断），下面会细说。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handle a uart interrupt, raised because input has</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or</span></span><br><span class="line"><span class="comment">// both. called from devintr().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="comment">// return -1 if none is waiting,说明读完了</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 每读入一个字符就转交给console</span></span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters.</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="consoleintr"><a href="#consoleintr" class="headerlink" title="consoleintr"></a>consoleintr</h4><p>向buf中放入字符c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;P&#x27;</span>)</span>:  <span class="comment">// Print process list.</span></span><br><span class="line">      <span class="comment">// ...一堆特殊情况处理...</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="title function_">if</span><span class="params">(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)</span>&#123;</span><br><span class="line">          c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// echo back to the user.</span></span><br><span class="line">          consputc(c);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">          cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;</span><br><span class="line">            <span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line">            <span class="comment">// has arrived.</span></span><br><span class="line">            <span class="comment">// 中断处理并不会做很多事情，只是会与缓冲区交互</span></span><br><span class="line">            <span class="comment">// 涉及到复杂的事情，比如说将数据拷贝到用户空间</span></span><br><span class="line">            <span class="comment">//就唤醒上层逻辑来做</span></span><br><span class="line">            cons.w = cons.e;</span><br><span class="line">            wakeup(&amp;cons.r);</span><br><span class="line">          &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Console-output"><a href="#Code-Console-output" class="headerlink" title="Code: Console output"></a>Code: Console output</h2><p>外部通过write这个系统调用来对console写。</p>
<h3 id="uartputc"><a href="#uartputc" class="headerlink" title="uartputc"></a>uartputc</h3><p>最先到达这里。</p>
<p>uart内置了一个缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> uart_tx_buf[UART_TX_BUF_SIZE];</span><br></pre></td></tr></table></figure>

<p>用户仅需通过uartputc对buf进行写入即可，具体的buf数据向UART转移由uartputc通过调用uartstart实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add a character to the output buffer and tell the</span></span><br><span class="line"><span class="comment">// UART to start sending if it isn&#x27;t already.</span></span><br><span class="line"><span class="comment">// blocks if the output buffer is full.缓冲区满则阻塞</span></span><br><span class="line"><span class="comment">// because it may block, it can&#x27;t be called</span></span><br><span class="line"><span class="comment">// from interrupts; it&#x27;s only suitable for use</span></span><br><span class="line"><span class="comment">// by write().这段话很有意思，说它由于会阻塞所以最好别在中断的时候用。</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 阻塞</span></span><br><span class="line">  <span class="keyword">while</span>(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE)&#123;</span><br><span class="line">    <span class="comment">// buffer is full.</span></span><br><span class="line">    <span class="comment">// wait for uartstart() to open up space in the buffer.</span></span><br><span class="line">    sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;</span><br><span class="line">  uart_tx_w += <span class="number">1</span>;</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uartstart"><a href="#uartstart" class="headerlink" title="uartstart"></a>uartstart</h3><p>uartstart的作用是从缓冲区取数据向UART硬件发送。不阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if the UART is idle, and a character is waiting</span></span><br><span class="line"><span class="comment">// in the transmit buffer, send it.</span></span><br><span class="line"><span class="comment">// caller must hold uart_tx_lock.</span></span><br><span class="line"><span class="comment">// called from both the top- and bottom-half.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartstart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the UART transmit holding register is full,</span></span><br><span class="line">      <span class="comment">// so we cannot give it another byte.</span></span><br><span class="line">      <span class="comment">// it will interrupt when it&#x27;s ready for a new byte.</span></span><br><span class="line">      <span class="comment">// 当缓冲区满没有选择阻塞，而是先结束</span></span><br><span class="line">      <span class="comment">// 当UART硬件准备好继续接收的时候，UART会发送transmit complete中断，到时候会再继续从buf读取</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个字符一个字符写</span></span><br><span class="line">    <span class="type">int</span> c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];</span><br><span class="line">    uart_tx_r += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maybe uartputc() is waiting for space in the buffer.</span></span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    </span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当传输过程非常流畅，UART硬件没有阻塞时，以上的代码就能完美阐述发送的过程。但是当UART硬件的transmit阻塞时，过程就会有许多改动。</p>
<h3 id="transmit-complete-interrupt"><a href="#transmit-complete-interrupt" class="headerlink" title="transmit complete interrupt"></a>transmit complete interrupt</h3><p>在<code>uartstart</code>中，当UART硬件的transmit满，<code>uartstart</code>就直接return了。</p>
<p>当UART硬件的transmit空，就会发送transmit complete中断。中断在kerneltrap被接收，经过devintr转发，最终来到了uartintr：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handle a uart interrupt, raised because input has</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or</span></span><br><span class="line"><span class="comment">// both. called from devintr().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters.</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，第一个while循环会直接退出，因为压根没有get到字符。所以，这时候，就会去执行uartstart，然后继续读未完成读取的缓冲区。</p>
<p>等到所有都读完了，最后一次发送transmit complete中断时，会在uartstart进入该分支：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">  <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就不会再发送transmit中断了。</p>
<p>感觉这点是真的牛逼。uartintr这个函数完美兼顾了两种情况【这也归功于uartstart做得很健壮】：1. 外部输入数据到console，2. 接收数据未结束，继续接收</p>
<h2 id="Concurrency-in-drivers"><a href="#Concurrency-in-drivers" class="headerlink" title="Concurrency in drivers"></a>Concurrency in drivers</h2><p>用户进程与设备之间的读写交流，比如说上面的console，重点依靠于<code>uart_tx_buf</code>和<code>cons.buf</code>这两个的正确性。因而，就需要保障它们的并发安全。在上面的代码中，使用到这两个的地方都被锁保护着。</p>
<p>在kernel中还需要格外注意的一点并发是，一个进程A在等待来自设备的中断，但此时另一个进程B在运行。这时候设备发出中断信号，CPU转入中断处理程序处理中断。此时，中断处理程序的执行不应该涉及到当前被中断进程的代码。例如，中断处理程序不能安全地使用当前进程的页表调用<code>copyout</code>（页表正是跟当前进程息息相关的）。中断处理程序通常做相对较少的工作（例如，只需将输入数据复制到缓冲区），并唤醒上半部分代码来完成其余工作。</p>
<h2 id="Timer-interrupts"><a href="#Timer-interrupts" class="headerlink" title="Timer interrupts"></a>Timer interrupts</h2><blockquote>
<p>Xv6 uses timer interrupts to maintain its clock and to enable it to switch among compute-bound processes; the <strong>yield</strong> calls in usertrap and kerneltrap cause this switching.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c usertrap()</span></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c kerneltrap()</span></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RISC-V requires that timer interrupts be taken in machine mode, not supervisor mode. As a result, xv6 handles timer interrupts completely separately from the trap mechanism laid out above.</p>
</blockquote>
<p>xv6启动时调用过<code>start.c</code>。<code>start.c</code>处于机器态，并准备向内核态过渡。<code>start.c</code>中就对时钟进行了初始化<code>timeinit()</code>。要做的有以下几件事：</p>
<ol>
<li>program the <strong>CLINT</strong> hardware (core-local interruptor) to generate an interrupt after a certain delay. </li>
<li>set up a <strong>scratch</strong> area  to help the timer interrupt handler save registers and the address of the CLINT registers</li>
<li>start sets mtvec to timervec and <strong>enables</strong> timer interrupts.</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arrange to receive timer interrupts.</span></span><br><span class="line"><span class="comment">// they will arrive in machine mode at</span></span><br><span class="line"><span class="comment">// at timervec in kernelvec.S,</span></span><br><span class="line"><span class="comment">// which turns them into software interrupts for</span></span><br><span class="line"><span class="comment">// devintr() in trap.c.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">timerinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// each CPU has a separate source of timer interrupts.</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask the CLINT for a timer interrupt.</span></span><br><span class="line">  <span class="type">int</span> interval = <span class="number">1000000</span>; <span class="comment">// cycles; about 1/10th second in qemu.</span></span><br><span class="line">  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare information in scratch[] for timervec.</span></span><br><span class="line">  <span class="comment">// scratch[0..2] : space for timervec to save registers.</span></span><br><span class="line">  <span class="comment">// scratch[3] : address of CLINT MTIMECMP register.</span></span><br><span class="line">  <span class="comment">// scratch[4] : desired interval (in cycles) between timer interrupts.</span></span><br><span class="line">  uint64 *scratch = &amp;timer_scratch[id][<span class="number">0</span>];</span><br><span class="line">  scratch[<span class="number">3</span>] = CLINT_MTIMECMP(id);</span><br><span class="line">  scratch[<span class="number">4</span>] = interval;</span><br><span class="line">  w_mscratch((uint64)scratch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the machine-mode trap handler.</span></span><br><span class="line">  w_mtvec((uint64)timervec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode interrupts.</span></span><br><span class="line">  w_mstatus(r_mstatus() | MSTATUS_MIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode timer interrupts.</span></span><br><span class="line">  w_mie(r_mie() | MIE_MTIE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>计时器中断处理程序必须保证不干扰中断的内核代码。基本策略是处理程序要求RISC-V发出“软件中断”并立即返回。RISC-V用普通陷阱机制将软件中断传递给内核，并允许内核禁用它们。处理由定时器中断产生的软件中断的代码可以在<code>devintr</code> (<strong>kernel/trap.c</strong>:204)中看到：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c devintr()</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">    <span class="comment">// forwarded by timervec in kernelvec.S.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只看其中一个CPU的时钟中断计数的意思吗？确实，要是好几个一起来加倍了非常不合理</span></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>w_sip(r_sip() &amp; ~2);</code>就对应着“RISC-V用普通陷阱机制将软件中断传递给内核”。【应该吧个人理解】</p>
<blockquote>
<p>来源：<a href="https://www.bookstack.cn/books/rCore_tutorial_doc">rCore 手册（rCore tutorial doc）</a></p>
<p><strong>riscv 中的中断寄存器</strong></p>
<p>S 态的中断寄存器主要有 <strong>sie</strong>（Supervisor Interrupt Enable，监管中断使能）, <strong>sip</strong> （Supervisor Interrupt Pending，监管中断待处理）两个，其中 s 表示 S 态，i 表示中断， e/p 表示 enable (使能)/ pending (提交申请)。 处理的中断分为三种：</p>
<ol>
<li>SI(Software Interrupt)，软件中断</li>
<li>TI(Timer Interrupt)，时钟中断</li>
<li>EI(External Interrupt)，外部中断</li>
</ol>
<p>比如 <code>sie</code> 有一个 <code>STIE</code> 位， 对应 <code>sip</code> 有一个 <code>STIP</code> 位，与时钟中断 TI 有关。当硬件决定触发时钟中断时，会将 <code>STIP</code> 设置为 1，当一条指令执行完毕后，如果发现 <code>STIP</code> 为 1，此时如果时钟中断使能，即 <code>sie</code> 的 <code>STIE</code> 位也为 1 ，就会进入 S 态时钟中断的处理程序。</p>
<p>可能SSIP跟这里的STIP差不多吧，都是时钟中断的标志。如果把SSIP clear掉，那么则说明不是时钟中断了，而是软中断了。</p>
</blockquote>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>UART驱动程序读取UART控制寄存器，一次检索一字节的数据；因为软件驱动数据移动，这种模式被称为程序I/O（<strong>Programmed I/O</strong>）。程序I/O很简单，但速度太慢，无法在高数据速率下使用。需要高速移动大量数据的设备通常使用直接内存访问（<strong>DMA</strong>）。DMA设备硬件直接将传入数据写入内存，并从内存中读取传出数据。现代磁盘和网络设备使用DMA。DMA设备的驱动程序将在RAM中准备数据，然后使用对控制寄存器的单次写入来告诉设备处理准备好的数据。</p>
<p>当一个设备在不可预知的时间需要注意时，中断是有意义的，而且不是太频繁。但是中断有很高的CPU开销。因此，如网络和磁盘控制器的高速设备，使用一些技巧减少中断需求。一个技巧是对整批传入或传出的请求发出单个中断。另一个技巧是驱动程序完全禁用中断，并定期检查设备是否需要注意。这种技术被称为轮询（<strong>polling</strong>）。如果设备执行操作非常快，轮询是有意义的，但是如果设备大部分空闲，轮询会浪费CPU时间。一些驱动程序根据当前设备负载在轮询和中断之间动态切换。</p>
<p>UART驱动程序首先将传入的数据复制到内核中的缓冲区，然后复制到用户空间。这在低数据速率下是可行的，但是这种双重复制会显著降低快速生成或消耗数据的设备的性能。一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常带有DMA。</p>
</blockquote>
<h2 id="Lab-networking"><a href="#Lab-networking" class="headerlink" title="Lab: networking"></a>Lab: networking</h2><blockquote>
<p>In this lab you will write an xv6 device driver for a network interface card (NIC).</p>
<p>这个概述光是听起来就让人觉得热血沸腾。网络的本质其实就是IO设备，这一点我一直觉得很牛逼，而现在我居然要亲手实现网络……That’s very cool.</p>
</blockquote>
<blockquote>
<p>On this emulated LAN, xv6 (the “guest”) has an IP address of 10.0.2.15. </p>
<p>Qemu also arranges for the computer running qemu to appear on the LAN with IP address 10.0.2.2. </p>
<p>When xv6 uses the E1000 to send a packet to 10.0.2.2, qemu delivers the packet to the appropriate application on the (real) computer on which you’re running qemu (the “host”).</p>
</blockquote>
<blockquote>
<p>We’ve added some files to the xv6 repository for this lab. </p>
<p>The file <code>kernel/e1000.c</code> contains <strong>initialization</strong> code for the E1000 as well as empty functions for transmitting and receiving packets, which <strong>you’ll fill in</strong>. </p>
<p><code>kernel/e1000_dev.h</code> contains definitions for registers and flag bits defined by the E1000 and described in the Intel E1000 <a href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">Software Developer’s Manual</a>. </p>
<p><code>kernel/net.c</code> and <code>kernel/net.h</code> contain a simple network stack that implements the <a href="https://en.wikipedia.org/wiki/Internet_Protocol">IP</a>, <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>, and <a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP</a> protocols. </p>
<p>These files also contain code for a flexible data structure to hold packets, called an <code>mbuf</code>. </p>
<p>Finally, <code>kernel/pci.c</code> contains code that searches for an E1000 card on the PCI bus when xv6 boots.</p>
</blockquote>
<blockquote>
<p>Your job：</p>
<p>Your job is to complete <code>e1000_transmit()</code> and <code>e1000_recv()</code>, both in <code>kernel/e1000.c</code>, so that the driver can transmit and receive packets. You are done when <code>make grade</code> says your solution passes all the tests. </p>
</blockquote>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>说实话，一开始看题的时候真是感觉非常地哈人……但其实文档看着看着，心中也逐渐有了个大概，最后再结合下指导书的提示【当然不是后面那些保姆级的Hints】，最后写的也就八九不离十了。总体上来说，我觉得这次实验的代码还是很简单的，它主要难在<strong>探究过程</strong>，也就是从一开始什么也不懂，然后去阅读硬件设备的文档，结合代码尝试去理解，最后一步步写出来的过程。本次实验耗时六小时，我觉得肯定有不少于一半，甚至可能达到2/3的时间都耗费在理解上。这种从零开始探究的过程给了我很大的收获，同时也稍微提高了我面对挫折的能力。</p>
<p>这个实验确实设计得很有教育意义。除了我上面说的它锻炼了我的能力以外，它其实还具有比较深刻的<strong>工业意义</strong>。在看书的时候，书中这么写道：</p>
<blockquote>
<p>In addition, the driver must understand the device’s <strong>hardware interface</strong>, which can be complex and poorly documented.</p>
</blockquote>
<p>本次实验正是上述描述的简化版：E1000的文档很详细，并且我们只用掌握一部分它的功能就行了。但虽然简化了，其探究过程的内在逻辑还是不会改变的。</p>
<p>总之，我很喜欢这次实验的设计。我的评价是牛逼。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>Hints写得很详细，不做赘述了。主要就是明确一下数据结构的问题：</p>
<ol>
<li><p>rx_ring和tx_ring是两个分开的队列</p>
<p>它们只是结构一模一样，都是阴影部分表示software持有，白色部分表示硬件持有。</p>
<p>因而，对于rx来说，白色部分表示需要传给协议栈的包，因而我们需要把白色部分转化为阴影部分；对于tx来说，白色部分表示网卡将要发送的包，因而我们需要把阴影部分转化为白色部分。</p>
<p><img src="/2023/01/10/xv6/image-20230220234406239.png" alt="image-20230220234406239"></p>
</li>
<li><p>rx_mbufs和tx_mbufs</p>
<p>一开始不知道这俩是啥，后来才意识到，这俩和第1点的那俩其实是下标一一对应的关系。也就是说rx_ring[i]这个descriptor接收到的数据存在rx_mbufs[i]，tx_ring[i]要发送的数据存在tx_mbufs[i]。知道了这个之后，代码就简单了。</p>
<blockquote>
<p>忏悔：我一开始真没反应过来。计网我记得是有一模一样的结构的，看来算是白做了2333</p>
</blockquote>
</li>
</ol>
<h4 id="个人的推理过程"><a href="#个人的推理过程" class="headerlink" title="个人的推理过程"></a>个人的推理过程</h4><p>一开始就先懵懵懂懂地看指导书，直到看到这句话：</p>
<blockquote>
<p>Browse the E1000 <a href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">Software Developer’s Manual</a>. </p>
</blockquote>
<p>然后我这时连自己要干什么都迷迷糊糊，但姑且还是按他下面说的，准备先浏览第二章了。然而，我发现要我看我也还是看不懂啊，所以我就直接放弃了。【<strong>经验1：看不懂就算了，别死磕了</strong>】</p>
<p>我放弃了第二章后，就再次从头开始细细看了一遍这句话之前的指导书，也结合了一下它给的代码。这次总算是差不多弄懂这次要做什么了：</p>
<p>实现<strong>driver</strong>的两个函数，从而实现对网卡进行数据的取出和送入。数据是eth frame。数据取出后要通过<code>net_rx</code>传递给上层协议栈。数据是<code>mbuf</code>类型的。</p>
<p>所以我们只需实现协议栈最底下的部分，也即从网卡读写数据，其他一些别的东西比如协议栈什么的都已经写好了。</p>
<p>但是那些什么<code>rx_ring</code>，还有各种奇奇怪怪的寄存器，我都看不懂，所以我就去看第三章了。初次略过一遍感觉还是一脸懵逼不知道干什么，但我带着“我们要做的是driver”这样的想法，在第二遍细看的时候有意区分开什么是网卡硬件帮我们做的，什么是我们的driver软件需要做的（<strong>经验2：明确要做什么。我们需要做的是软件部分，它的文档一般会说Software should XXX，密切关注这部分就行</strong>），就差不多有了点实现的雏形：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> recv:</span><br><span class="line">  <span class="comment">// 通过net_rx，网络包可以发送到udp顶层.</span></span><br><span class="line">  <span class="comment">// 所以说，我们在这里的目的就是，通过与硬件网卡e1000进行交互，</span></span><br><span class="line">  <span class="comment">// 取出e1000所接收到的数据包，检查数据的完整性，然后再把数据封装进mbuf结构体中，再通过net_rx传到上层</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出数据包</span></span><br><span class="line">  <span class="comment">// 数据包存储在网卡的缓冲区中</span></span><br><span class="line">  <span class="comment">// 一是获取网卡缓冲区长度的长度</span></span><br><span class="line">  <span class="comment">// 网卡缓冲区长度存储在RCTL.BSIZE &amp; RCTL.BSEX中</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *RCTL.BSEX = 0b:</span></span><br><span class="line"><span class="comment">00b = 2048 Bytes.</span></span><br><span class="line"><span class="comment">01b = 1024 Bytes.</span></span><br><span class="line"><span class="comment">10b = 512 Bytes.</span></span><br><span class="line"><span class="comment">1b1 = 256 Bytes.</span></span><br><span class="line"><span class="comment">RCTL.BSEX = 1b:</span></span><br><span class="line"><span class="comment">00b = Reserved; software should not program this value.</span></span><br><span class="line"><span class="comment">01b = 16384 Bytes.</span></span><br><span class="line"><span class="comment">10b = 8192 Bytes.</span></span><br><span class="line"><span class="comment">11b = 4096 Bytes</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="comment">// 二是获取数据包存放在哪个地址</span></span><br><span class="line">  <span class="comment">// 数据包的buffer cache的地址存储在descriptor的字段中</span></span><br><span class="line">  <span class="comment">// 必须读取多个descriptor以确定跨越多个接收缓冲区的数据包的完整长度。</span></span><br><span class="line">  <span class="comment">// 那么我们要读取的这些descriptor存放在哪呢？</span></span><br><span class="line">  <span class="comment">// 看文档，似乎差不多意思是这些descriptor被以环形队列的形式组织在一起，也许正是</span></span><br><span class="line">  <span class="comment">// 本文件内的rx_ring这个数组。</span></span><br><span class="line">  <span class="comment">// 当有descriptor到达e1000，e1000就会把它从host memory中取出来，存入到descriptor ring</span></span><br><span class="line">  <span class="comment">// 也即我们rx_ring数组</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 所以我们要做的，就是遍历rx_ring数组，如果rx_ring数组中的元素是used的，那么表明它就是数据包的一部分</span></span><br><span class="line">  <span class="comment">// 也即它地址所指向的buf里存放的是数据包的一部分数据</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// 那么我们怎么知道这个rx_ring的元素有没有used，以及它是第几个呢?</span></span><br><span class="line">  <span class="comment">// 检查descriptor有没有used：status字段不为全0则为used</span></span><br><span class="line">  <span class="comment">// 并且硬件要求，我们在发现这个descriptor的status不为0，并且用完这个descriptor之后，需要将</span></span><br><span class="line">  <span class="comment">// 其status字段置零，以供硬件使用</span></span><br><span class="line">  <span class="comment">// Status information indicates whether the descriptor has been used and whether the referenced </span></span><br><span class="line">  <span class="comment">// buffer is the last one for the packet.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 三是获取数据包的数据</span></span><br><span class="line">  <span class="comment">// 我们需要获取decriptor的该字段，然后再从这个地址读取数据包数据</span></span><br><span class="line">  <span class="comment">// 网卡和内存统一编址，这个数据实际上就是网卡的buffer</span></span><br><span class="line">  <span class="comment">// 我们应该直接通过read这个系统调用就可以对其进行读写了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// check数据包</span></span><br><span class="line">  <span class="comment">// 检查RDESC.ERRORS位，如果包发生了错误，再检查，如果发现RCTL.SBP、RCTL.UPE/MPE都被标记，</span></span><br><span class="line">  <span class="comment">// 就接收这个包，否则直接丢弃</span></span><br></pre></td></tr></table></figure>

<p>可以看到，跟正确思路虽然很多细节理解上有点问题，但是大体框架还是大差不差。然后再阅读指导书：</p>
<blockquote>
<p>When the E1000 receives each packet from the ethernet, <strong>it first DMAs the packet to the mbuf pointed to by the next RX (receive) ring descriptor, and then generates an interrupt</strong>. 【这句话可得知，<code>descriptor</code>们存放在代码中的<code>rx_ring</code>中。】</p>
<p>Your <code>e1000_recv()</code> code must <strong>scan</strong> the RX ring and <strong>deliver each</strong> new packet’s mbuf to the network stack (in <code>net.c</code>) by calling <code>net_rx()</code>. You will then need to <strong>allocate</strong> a new mbuf and place it into the descriptor, so that when the E1000 reaches that point in the RX ring again it finds a fresh buffer into which to DMA a new packet.</p>
</blockquote>
<p>就差不多是正确思路了。<code>transmit</code>的实现也是同理</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><blockquote>
<p>以下代码不知道为什么过不了test，我跟别人的逻辑一模一样也还是不行emmm</p>
<p>它的问题是，不会接收到外界的返ping，导致进程一直等待网卡IO，所以kerneltrap一直触发不了，无法正常网卡读写，从而导致<code>fileread</code>会一直处于sleep等待状态，整个系统就沉睡了【】我感觉应该是<code>transmit</code>没发成功。</p>
<p>等以后有精力再来看看吧。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> <span class="title">tx</span> =</span> tx_ring[regs[E1000_TDT]];</span><br><span class="line">  <span class="keyword">if</span>((tx.status &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(tx_mbufs[regs[E1000_TDT]] != <span class="number">0</span>)    mbuffree(tx_mbufs[regs[E1000_TDT]]);</span><br><span class="line">  tx.addr = (uint64) m-&gt;head;</span><br><span class="line">  tx.length = m-&gt;len;</span><br><span class="line">  tx.status |= <span class="number">1</span>;<span class="comment">// EOP</span></span><br><span class="line">  tx.cmd |= <span class="number">1</span>;<span class="comment">//EOP</span></span><br><span class="line">  tx.cmd |= <span class="number">8</span>;<span class="comment">//RS</span></span><br><span class="line">  tx_mbufs[regs[E1000_TDT]] = m;</span><br><span class="line">  regs[E1000_TDT] = (regs[E1000_TDT]+<span class="number">1</span>)%TX_RING_SIZE;</span><br><span class="line">  <span class="comment">// printf(&quot;send successful!\n&quot;);</span></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;go into e1000_recv\n&quot;</span>);</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//while(regs[E1000_RDT]!=regs[E1000_RDH])&#123;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;go into while\n&quot;</span>);</span><br><span class="line">    regs[E1000_RDT] = (regs[E1000_RDT] + <span class="number">1</span>)%RX_RING_SIZE;</span><br><span class="line">    <span class="type">int</span> i=regs[E1000_RDT];</span><br><span class="line">    <span class="keyword">if</span>(rx_ring[i].status != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 包含所需数据包</span></span><br><span class="line">      <span class="comment">// 检查是否发生了错误</span></span><br><span class="line">      <span class="comment">//if((rx_ring[i].status &amp; 1) !=0 &amp;&amp; (rx_ring[i].status &amp; 2) != 0)&#123;</span></span><br><span class="line">  <span class="comment">//      // error字段有效</span></span><br><span class="line">  <span class="comment">//    if(rx_ring[i].errors != 0)&#123;</span></span><br><span class="line">          <span class="comment">// 发生错误，直接丢弃</span></span><br><span class="line">  <span class="comment">//      goto end;</span></span><br><span class="line">  <span class="comment">//    &#125;</span></span><br><span class="line">      <span class="keyword">if</span>((rx_ring[i].status &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">      release(&amp;e1000_lock);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将地址对应数据包发送</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>* <span class="title">m</span> =</span> rx_mbufs[i];</span><br><span class="line">      m-&gt;len = rx_ring[i].length;</span><br><span class="line">      net_rx(m);</span><br><span class="line">    rx_ring[i].status = <span class="number">0</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>* <span class="title">mbuf</span> =</span> mbufalloc(MBUF_DEFAULT_HEADROOM);</span><br><span class="line">      rx_ring[i].addr = (uint64) mbuf-&gt;head;</span><br><span class="line">      rx_mbufs[i] = mbuf;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Locking</title>
    <url>/2023/01/10/xv6$chap6/</url>
    <content><![CDATA[<h1 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h1><p>很多概念在看Java并发的时候都学习过，这些重复的地方就不做赘述了。</p>
<h2 id="Code-spinlock"><a href="#Code-spinlock" class="headerlink" title="Code: spinlock"></a>Code: spinlock</h2><blockquote>
<p><a href="https://blog.csdn.net/chenwh_cn/article/details/117227454">spinlock 使用介绍</a></p>
<p>一、spinlock 简介<br>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，不断尝试获取锁，直到获取到锁才会退出循环</p>
<p>二、自旋锁与互斥锁的区别<br>自旋锁与互斥锁类似，它们都是为了解决对某项资源的互斥使用，在任何时刻最多只能有一个线程获得锁<br>对于互斥锁，如果资源已经被占用，调用者将进入睡眠状态<br>对于自旋锁，如果资源已经被占用，调用者就一直循环在那里，看是否自旋锁的保持者已经释放了锁</p>
<p>三、自旋锁的优缺点<br>自旋锁不会发生进程切换，不会使进程进入阻塞状态，减少了不必要的上下文切换，执行速度快。非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换，影响性能<br>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程长时间循环等待消耗CPU，造成CPU使用率极高</p>
</blockquote>
<h3 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>大概是这么个原理：</p>
<p><img src="/2023/01/10/xv6/image-20230115231857670.png" alt="image-20230115231857670"></p>
<p>当然这有竞态条件。xv6用的是CPU提供的amoswap原子指令来消除竞态条件的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/spinlock.c</span></span><br><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 关中断</span></span><br><span class="line">  <span class="comment">// xv6允许禁止中断。但是由于xv6是一个多核系统,单个core被禁止中断并不会影响其他core。</span></span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// holding(): Check whether this cpu is holding the lock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="comment">// amoswap: 交换a5和(s1)的值，返回(s1)原来的值</span></span><br><span class="line">  <span class="comment">// 也即是如图所示的竞态条件的原子指令</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sync-synchronize"><a href="#sync-synchronize" class="headerlink" title="__sync_synchronize();"></a>__sync_synchronize();</h4><p>代码里的官方注释：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line"><span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line"><span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line"><span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br></pre></td></tr></table></figure>

<p>这个注释其实没太看明白。我去翻了一下asm代码，发现这句话正如它最后一句所说的被翻译成fence指令：</p>
<p><img src="/2023/01/10/xv6/image-20230115231457971.png" alt="image-20230115231457971"></p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/139797515">处理器中的存储系统（一）：RISC-V的FENCE、FENCE.I指令</a></p>
<p>顾名思义,FENCE指令犹如一道屏障,把前面的存储操作和后面的存储操作隔离开来,前面的决不能到后面再执行,后面的决不能先于FENCE前的指令执行。</p>
</blockquote>
<p>这个就好明白多了。</p>
<p>这样一来，acquire和release的两个fence就形成了两道屏障：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acquire();</span><br><span class="line">l-&gt;nexy = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">release();</span><br></pre></td></tr></table></figure>

<p>中间那部分的指令可以重排，但是中间的指令就绝不会跑到临界区外。</p>
<h4 id="push-off和pop-off"><a href="#push-off和pop-off" class="headerlink" title="push_off和pop_off"></a>push_off和pop_off</h4><blockquote>
<p>当CPU未持有自旋锁时，xv6重新启用中断；它必须做一些记录来处理嵌套的临界区域。<code>acquire</code>调用<code>push_off</code> (*<strong>kernel/spinlock.c*</strong>:89) 并且<code>release</code>调用<code>pop_off</code> (*<strong>kernel/spinlock.c*</strong>:100)来跟踪当前CPU上锁的嵌套级别。当计数达到零时，<code>pop_off</code>恢复最外层临界区域开始时存在的中断使能状态。<code>intr_off</code>和<code>intr_on</code>函数执行RISC-V指令分别用来禁用和启用中断。</p>
</blockquote>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/spinlock.c</span></span><br><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开中断</span></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Using-locks"><a href="#Code-Using-locks" class="headerlink" title="Code: Using locks"></a>Code: Using locks</h2><blockquote>
<p>作为粗粒度锁的一个例子，xv6的<strong>kalloc.c</strong>有一个由单个锁保护的空闲列表。如果不同CPU上的多个进程试图同时分配页面，每个进程在获得锁之前将必须在<code>acquire</code>中自旋等待。自旋会降低性能，因为它只是无用的等待。如果对锁的争夺浪费了很大一部分CPU时间，也许可以通过改变内存分配的设计来提高性能，使其拥有<strong>多个空闲列表</strong>，每个列表都有自己的锁，以允许真正的并行分配。【很棒的思路】</p>
<p>作为细粒度锁的一个例子，xv6<u>对每个文件都有一个单独的锁</u>，这样操作不同文件的进程通常可以不需等待彼此的锁而继续进行。文件锁的粒度可以进一步细化，以允许进程同时写入同一个文件的不同区域。最终的锁粒度决策需要由性能测试和复杂性考量来驱动。</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>锁</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>bcache.lock</code></td>
<td>保护块缓冲区缓存项（block buffer cache entries）的分配</td>
</tr>
<tr>
<td><code>cons.lock</code></td>
<td>串行化对控制台硬件的访问，避免混合输出</td>
</tr>
<tr>
<td><code>ftable.lock</code></td>
<td>串行化文件表中文件结构体的分配</td>
</tr>
<tr>
<td><code>icache.lock</code></td>
<td>保护索引结点缓存项（inode cache entries）的分配</td>
</tr>
<tr>
<td><code>vdisk_lock</code></td>
<td>串行化对磁盘硬件和DMA描述符队列的访问</td>
</tr>
<tr>
<td><code>kmem.lock</code></td>
<td>串行化内存分配</td>
</tr>
<tr>
<td><code>log.lock</code></td>
<td>串行化事务日志操作</td>
</tr>
<tr>
<td>管道的<code>pi-&gt;lock</code></td>
<td>串行化每个管道的操作</td>
</tr>
<tr>
<td><code>pid_lock</code></td>
<td>串行化next_pid的增量</td>
</tr>
<tr>
<td>进程的<code>p-&gt;lock</code></td>
<td>串行化进程状态的改变</td>
</tr>
<tr>
<td><code>tickslock</code></td>
<td>串行化时钟计数操作</td>
</tr>
<tr>
<td>索引结点的 <code>ip-&gt;lock</code></td>
<td>串行化索引结点及其内容的操作</td>
</tr>
<tr>
<td>缓冲区的<code>b-&gt;lock</code></td>
<td>串行化每个块缓冲区的操作</td>
</tr>
</tbody></table>
<p> Figure 6.3: Locks in xv6</p>
<h2 id="Deadlock-and-lock-ordering"><a href="#Deadlock-and-lock-ordering" class="headerlink" title="Deadlock and lock ordering"></a>Deadlock and lock ordering</h2><blockquote>
<p>如果在内核中执行的代码路径必须同时持有数个锁，那么所有代码路径以相同的顺序获取这些锁是很重要的。如果它们不这样做，就有死锁的风险。假设xv6中的两个代码路径需要锁A和B，但是代码路径1按照先A后B的顺序获取锁，另一个路径按照先B后A的顺序获取锁。为了避免这种死锁，<strong>所有代码路径必须以相同的顺序获取锁</strong>。全局锁获取顺序的需求意味着锁实际上是每个<strong>函数规范</strong>的一部分：调用者必须以一种使锁按照约定顺序被获取的方式调用函数。</p>
<p>由于<code>sleep</code>的工作方式（见第7章），Xv6有许多包含每个进程的锁（每个<code>struct proc</code>中的锁）在内的长度为2的锁顺序链。例如，<code>consoleintr</code> (*<strong>kernel/console.c*</strong>:138)是处理键入字符的中断例程。当换行符到达时，任何等待控制台输入的进程都应该被唤醒。为此，<code>consoleintr</code>在调用<code>wakeup</code>时持有<code>cons.lock</code>，<code>wakeup</code>获取等待进程的锁以唤醒它。因此，全局避免死锁的锁顺序包括必须在任何进程锁之前获取<code>cons.lock</code>的规则。【这段不怎么能看懂，学完第七章再回来看看】</p>
<p>文件系统代码包含xv6最长的锁链。例如，创建一个文件需要同时持有目录上的锁、新文件inode上的锁、磁盘块缓冲区上的锁、磁盘驱动程序的<code>vdisk_lock</code>和调用进程的<code>p-&gt;lock</code>。为了避免死锁，文件系统代码总是按照前一句中提到的顺序获取锁。</p>
</blockquote>
<h2 id="Locks-and-interrupt-handlers"><a href="#Locks-and-interrupt-handlers" class="headerlink" title="Locks and interrupt handlers"></a>Locks and interrupt handlers</h2><blockquote>
<p> Xv6 is more conservative: when a CPU acquires any lock, xv6 always <strong>disables interrupts</strong> on that CPU. Interrupts may still occur on other CPUs, so an interrupt’s acquire can wait for a thread to release a spinlock; just not on the same CPU.看来是通过开关中断来保护临界区的</p>
<p> <code>acquire</code>调用<code>push_off</code> (*<strong>kernel/spinlock.c*</strong>:89) 并且<code>release</code>调用<code>pop_off</code> (*<strong>kernel/spinlock.c*</strong>:100)来跟踪当前CPU上锁的嵌套级别。当计数达到零时，<code>pop_off</code>恢复最外层临界区域开始时存在的中断使能状态。<code>intr_off</code>和<code>intr_on</code>函数执行RISC-V指令分别用来禁用和启用中断。</p>
<p> 严格的在设置<code>lk-&gt;locked</code> (<em>kernel/spinlock.c</em>:28)之前让<code>acquire</code>调用<code>push_off</code>是很重要的。如果两者颠倒，会存在一个既持有锁又启用了中断的短暂窗口期，不幸的话定时器中断会使系统死锁。同样，只有在释放锁之后，<code>release</code>才调用<code>pop_off</code>也是很重要的(*<strong>kernel/spinlock.c*</strong>:66)。</p>
</blockquote>
<h3 id="一个解决了一半的疑问"><a href="#一个解决了一半的疑问" class="headerlink" title="一个解决了一半的疑问"></a>一个解决了一半的疑问</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>Xv6更保守：当CPU获取任何锁时，xv6总是禁用该CPU上的中断。中断仍然可能发生在其他CPU上，此时中断的<code>acquire</code>可以等待线程释放自旋锁；由于不在同一CPU上，不会造成死锁。</p>
<p>进展：似乎书中说到，“sleep atomically yields the CPU and releases the spinlock”。等了解完sleep，也即读完第七章之后再来看看。</p>
</blockquote>
<p>在处理时钟中断的trap.c中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c devintr()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 这里！！</span></span><br><span class="line">    <span class="comment">// in kernel/trap.c devintr()</span></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见只有CPU0才会进入clockintr【因为要求cpuid==0】，锁住ticks引起ticks递增。</p>
<p>而当sys_sleep获得锁之后，其结束循环的条件是ticks - ticks0 &lt; n:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我认为，这会导致死锁情况。假设计算机为多CPU，且从零开始依次递增编号。对该死锁情况的讨论，可以分为以下两类：</p>
<ol>
<li><p>sys_sleep在CPU2（或者其他编号非零的CPU）运行，且先获取了tickslock的锁。这时候，ticks将会停止增长，sys_sleep结束循环的条件将无法结束。</p>
<p>理由：对于CPU0，它可以进入clockintr的代码段，但是由于锁已经被获取，所以就只能一直在那边死锁等待；对于其他CPU来说，压根执行不了那段增加ticks的代码段，所以ticks压根不会增加。这样一来，CPU2进程等待ticks增加，从而获取结束循环的条件；CPU0等待CPU2进程结束，从而使得ticks增加，就造成了死锁。</p>
</li>
<li><p>sys_sleep在CPU0运行，且先获取了tickslock的锁。这时候，ticks将会停止增长，sys_sleep结束循环的条件将无法结束。</p>
<p>理由：由于xv6会在获取锁和释放锁期间关闭中断，因而CPU0无法进行时钟中断而发生进程的切换，只能一直在sys_sleep中等待，所以ticks更不可能增加，造成了死锁。</p>
</li>
</ol>
<p>暂时没有很充分的理由反驳这两点。。。</p>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>学习完下一章的内容后可知，<code>sleep(&amp;ticks, &amp;tickslock);</code>会释放掉tickslock的锁，这样CPU0就可以进入<code>clockintr</code>增加ticks了。</p>
<p>再详细梳理一次，这里的具体机制是这样的：</p>
<p>可以把ticks看做信号量，<code>sys_sleep</code>为消费者，<code>clockintr</code>为生产者。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in sys_sleep()</span></span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  <span class="keyword">while</span>(ticks &lt; 某个数字)&#123;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这是非常典型的生产者消费者模型。生产者每生产一次ticks，就会唤醒消费者，让消费者检查条件。如果条件错误，则继续sleep等待消费者下一次唤醒，如此循环往复。</p>
<p>只不过，还有一个小疑点，就是<code>clockintr</code>这段只有CPU0可以执行这一点是否为真依然存疑。如果确实只有CPU0可以执行的话，假若<code>sys_sleep</code>在CPU0上执行，那么还是依然会造成死锁。所以我猜想是不是CPU0是无法关中断的？也就是说CPU0是一个后盾一般的保护角色？或者是别的CPU也能进入本段代码？如果别的CPU也能进，那是怎么实现的？因为很明显这段代码确实只有CPU0可以进入。</p>
<h2 id="Sleep-locks"><a href="#Sleep-locks" class="headerlink" title="Sleep locks"></a>Sleep locks</h2><p>关于sleep lock的由来和优点，书里描述得很详细，简单来说就是：</p>
<blockquote>
<p>Thus we’d like a type of lock that yields the CPU while waiting to acquire, and allows yields (and interrupts) while the lock is held.</p>
<p>因为等待会浪费CPU时间，所以自旋锁最适合短的临界区域；睡眠锁对于冗长的操作效果很好。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="comment">// 等待</span></span><br><span class="line">  <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">    <span class="comment">// sleep atomically yields the CPU and releases the spinlock</span></span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 占用</span></span><br><span class="line">  lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">  lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 到时候可以留意一下wakeup是会唤醒一个还是多个</span></span><br><span class="line">  wakeup(lk);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点值得注意：</p>
<blockquote>
<p>Because sleep-locks leave interrupts enabled, they cannot be used in interrupt handlers. Because acquiresleep may yield the CPU, sleep-locks cannot be used inside spinlock critical sections (though spinlocks can be used inside sleep-lock critical sections).</p>
</blockquote>
<p>这实际上是因为自旋锁内不能sleep，因而也就不能使用sleep lock。</p>
<p>为什么不能sleep？我猜测应该是因为sleep中会释放自旋锁然后再调度别的进程。此时，临界区就不受保护了很危险，不符合spinlock在临界区结束才能释放的规范。</p>
<p>在查阅别人的说法的时候，我还看到了这个讨论：</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_44175439/article/details/119963732">中断中为什么不能sleep | Linux内核</a>的评论区</p>
<p>在中断服务程序中，无法sleep的原因应该是sleep后，调度程序将CPU窃走，由于调度的基本单位是线程（中断服务程序不是线程），因此中断服务程序无法再被调度回来，即中断程序中sleep后的部分永远无法得到执行。</p>
</blockquote>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>大多数操作系统都支持POSIX线程（Pthread），它允许一个用户进程在不同的CPU上同时运行几个线程。Pthread支持用户级锁（user-level locks）、障碍（barriers）等。支持Pthread需要操作系统的支持。例如，如果一个Pthread在系统调用中阻塞，同一进程的另一个Pthread应当能够在该CPU上运行。另一个例子是，如果一个线程改变了其进程的地址空间（例如，映射或取消映射内存），内核必须安排运行同一进程下的线程的其他CPU更新其硬件页表，以反映地址空间的变化。</p>
</blockquote>
<h2 id="Lab-locks"><a href="#Lab-locks" class="headerlink" title="Lab: locks"></a>Lab: locks</h2><blockquote>
<p>In this lab you’ll gain experience in re-designing code to increase parallelism. You’ll do this for the xv6 <strong>memory allocator</strong> and <strong>block cache</strong>.</p>
</blockquote>
<h3 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h3><blockquote>
<p>The program <code>user/kalloctest</code> stresses xv6’s memory allocator: three processes grow and shrink their address spaces, resulting in many calls to <code>kalloc</code> and <code>kfree</code>. <code>kalloc</code> and <code>kfree</code> obtain <code>kmem.lock</code>. kalloctest prints (as “#fetch-and-add”) the number of loop iterations in <code>acquire</code> due to attempts to acquire a lock that another core already holds, for the <code>kmem</code> lock and a few other locks. The number of loop iterations in <code>acquire</code> is a rough measure of lock contention. </p>
<p>To remove lock contention, you will have to redesign the memory allocator to avoid a single lock and list. 也就是说要把kalloc中的整个列表上锁，修改为每个CPU有自己的列表The basic idea is to maintain a free list per CPU, each list with its own lock. Allocations and frees on different CPUs can run in parallel, because each CPU will operate on a different list. The main challenge will be to deal with the case in which one CPU’s free list is empty, but another CPU’s list has free memory; in that case, the one CPU must “steal” part of the other CPU’s free list. Stealing may introduce lock contention, but that will hopefully be infrequent.主要挑战将是处理一个 CPU 的空闲列表为空，但另一个 CPU 的列表有空闲内存的情况； 在这种情况下，一个 CPU 必须“窃取”另一个 CPU 的空闲列表的一部分。</p>
<p>Your job is to implement per-CPU freelists, and stealing when a CPU’s free list is empty. </p>
<p>You must give all of your locks names that start with “kmem”. That is, you should call <code>initlock</code> for each of your locks, and pass a name that starts with “kmem”. </p>
<p>Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run <code>usertests sbrkmuch</code>. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ.</p>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>总之，意思就是kalloc里面本来是多核CPU共用一个空闲页list，现在要做的就是给每一核的CPU独立分配一个空闲页list。我觉得可以分为如下几步来做：</p>
<ol>
<li><p>定义list数组以及对应的锁</p>
<p>cpu的数量是一定的；cpuid可以用来作为数组下标索引</p>
</li>
<li><p>在init时初始化锁，在freelist的时候把空闲页均分给CPU</p>
</li>
<li><p>当kalloc和kfree的时候，获取当前cpuid上锁</p>
</li>
<li><p>当一个CPU的内存不够的时候，去向另一个CPU窃取。窃取之前，首先应该获取另一个CPU的锁。</p>
</li>
</ol>
<p>以上是初见思路。正确思路确实跟上面的一样，编码过程也比较简单，没有很恶心的细节和奇奇怪怪的bug，没什么好说的。</p>
<p>第二步中，hints是推荐把所有空闲页都分给CPU0。</p>
<p>第四步的时候我是一次窃取一页。我看到一个一次窃取多页的做法，我觉得很有想法，在这里附上链接：</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/524460096">MIT6.S081 lab8 locks</a></p>
</blockquote>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">kmem_locks</span>[<span class="title">NCPU</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelists</span>[<span class="title">NCPU</span>];</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>由于kinit仅会由一个cpu执行一次【详情见main.c】，故而我这里在kinit的做法是由一个CPU初始化所有CPU，而没有选择去修改main.c从而使每个CPU都执行一次kinit。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++)&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="number">6</span>,<span class="string">&quot;kmem%d&quot;</span>,i);</span><br><span class="line">    initlock(&amp;kmem.kmem_locks[i], buf);</span><br><span class="line">  &#125;</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多带一个参数表示cpuid，仅在kinit的freerange中使用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree_init</span><span class="params">(<span class="type">void</span> *pa,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  r-&gt;next = kmem.freelists[i];</span><br><span class="line">  kmem.freelists[i] = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 把空闲内存页均分给每个CPU</span></span><br><span class="line">  uint64 sz = ((uint64)pa_end - (uint64)pa_start)/NCPU;</span><br><span class="line">  uint64 tmp = PGROUNDDOWN(sz) + (uint64)p;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)tmp; p += PGSIZE)</span><br><span class="line">      kfree_init(p,i);</span><br><span class="line">    tmp += PGROUNDDOWN(sz);</span><br><span class="line">    <span class="keyword">if</span>(i == NCPU<span class="number">-2</span>)&#123;</span><br><span class="line">      tmp = (uint64)pa_end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a>kfree</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">  <span class="comment">// 在这</span></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  r-&gt;next = kmem.freelists[id];</span><br><span class="line">  kmem.freelists[id] = r;</span><br><span class="line">  release(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="kalloc"><a href="#kalloc" class="headerlink" title="kalloc"></a>kalloc</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  r = kmem.freelists[id];</span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    kmem.freelists[id] = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果无空闲页，则窃取</span></span><br><span class="line">  <span class="keyword">if</span>(!r)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=NCPU<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      acquire(&amp;kmem.kmem_locks[i]);</span><br><span class="line">      r = kmem.freelists[i];</span><br><span class="line">      <span class="keyword">if</span>(r)&#123;</span><br><span class="line">        kmem.freelists[i] = r-&gt;next;</span><br><span class="line">        release(&amp;kmem.kmem_locks[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;kmem.kmem_locks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h3><p>buffer cache的结构其实跟kalloc的内存分配结构有一定的类似之处，都是采用链表管理，但是buffer cache的实现相较于kalloc更为复杂。</p>
<blockquote>
<p>Reducing contention in the block cache is more tricky than for kalloc, because bcache buffers are truly shared among processes (and thus CPUs). </p>
<p>For kalloc, one could eliminate most contention by giving each CPU its own allocator; that won’t work for the block cache. </p>
<p>We suggest you look up block numbers in the cache with a hash table that has a lock per hash bucket.</p>
</blockquote>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><h5 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h5><p>我想我们可以这么实现：</p>
<p>首先有一个双向链表，接收着所有空闲无设备分配的buf。然后再有多个双向链表桶，以设备号为索引值。</p>
<p>设备号数量，也即hash table的大小定义在<code>kernel/param.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEV         10 </span></span><br></pre></td></tr></table></figure>

<p>在<code>bget</code>中，第一个循环仅需在设备链表中查找即可，第二个循环需要先看设备链表是否有空闲的对象，如果没有，则去接收所有空闲无设备分配的那个双向链表中窃取一个对象。</p>
<p>在<code>brelse</code>中，则把要释放的buf对象添加在head中即可。</p>
<p>因而，我们要做以下几件事：</p>
<ol>
<li><p>修改bcache的定义</p>
<p>添加数量为设备号的head数组，以及对应的锁</p>
</li>
<li><p>初始化bcache</p>
</li>
<li><p>添加工具函数：将一个buf加入一个双向链表；从一个双向链表中得到一个buf</p>
</li>
<li><p>写<code>bget</code>和<code>brelse</code></p>
</li>
</ol>
<p>看起来确实好像可以实现的样子，但是这个问题在于，这么做就直接破坏了LRU的这个规则。所以还是不能这么写的。但总之先把我的代码放上来。</p>
<p>以下代码是不能正常运行的。比如说在执行<code>ls</code>命令时，会发生如下错误：</p>
<p><img src="/2023/01/10/xv6/image-20230122163938601.png" alt="image-20230122163938601"></p>
<p>会打印出一些乱七八糟的东西，并且这些东西似乎是固定的，每次都会发生，看来应该不是多进程的问题，而是代码有哪里出现逻辑错误了。不过注意到会产生“stopforking”、“bigarg-ok”，这两个似乎是在usertest中的两个文件名，很奇怪。</p>
<p>很遗憾我暂时没有精力debug了。姑且先把错误代码放在这里吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">dev_heads</span>[<span class="title">NDEV</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">dev_locks</span>[<span class="title">NDEV</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NDEV;i++)&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="number">9</span>,<span class="string">&quot;bcache%02d&quot;</span>,i);</span><br><span class="line">    initlock(&amp;(bcache.dev_locks[i]), buf);</span><br><span class="line">    bcache.dev_heads[i].prev = &amp;(bcache.dev_heads[i]);</span><br><span class="line">    bcache.dev_heads[i].next = &amp;(bcache.dev_heads[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始时，每一个桶内都有一个buf结点</span></span><br><span class="line">  b = bcache.buf;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NDEV;i++)&#123;</span><br><span class="line">    b-&gt;next = bcache.dev_heads[i].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.dev_heads[i];</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.dev_heads[i].next-&gt;prev = b;</span><br><span class="line">    bcache.dev_heads[i].next = b;</span><br><span class="line">    b++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uint dev = b-&gt;dev;</span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;(bcache.dev_locks[dev]));</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line"></span><br><span class="line">    acquire(&amp;bcache.lock);</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">    release(&amp;bcache.lock);</span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">    release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;(bcache.dev_locks[dev]));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.dev_heads[dev].next; b != &amp;(bcache.dev_heads[dev]); b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在head中找</span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.head.prev; b != &amp;(bcache.head); b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h5><p>首先，大家似乎都是用<code>blockno</code>来hash的，这点就跟我的原始思路不一样了（。其实也很对，因为每个设备的使用频率是不平均的，用<code>blockno</code>来hash比用<code>dev</code>来hash其实会让访问次数更加平均。</p>
<p>然后就是怎么保证LRU依然OK。hints的做法是使用时间戳。我们可以在<code>brelse</code>的时候记录时间戳字段，在<code>bget</code>缺块的时候遍历hash table，找出对应timestamp最小的block即可。</p>
<p>历经了几小时的debug，代码最终正确。正确版本在下面的代码模块处。</p>
<h5 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h5><p>coding过程其实很短暂，毕竟思路很直观。我一开始是按初见思路写的代码，然后再从初见思路改到正确思路，这个过程，给我埋下了极大的安全隐患【悲】</p>
<p>其实几个小时下来，很多细节都已经忘记了，接下来就说点印象比较深的吧。</p>
<p>首先，我使用了正确思路以来，依然出现了跟初见思路一样的错误，也即xv6正常boot，但是执行ls命令会有错误。但是，当我<code>make clean</code>之后再次<code>make qemu</code>，错误改变了，变成了xv6 boot失败，并且爆出错误<code>panic:ilock:no type</code>。</p>
<blockquote>
<p>注：关于此处的make clean，有两点需要解释。一是为什么会做出make clean的行为，二是这个变化的原理是什么。</p>
<p>此处突然做出make clean的行为，是因为参照了该文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/524460096">MIT6.S081 lab8 locks</a></p>
<p><img src="/2023/01/10/xv6/image-20230123172138766.png" alt="image-20230123172138766"></p>
<p>没想到我make clean之后反而就变成了他这样的问题23333也是感觉蛮惊讶的</p>
<p>这个的原理说实话我不大清楚。猜想可能是make qemu的某段访问磁盘初始化之类的代码只会执行一次，只有make clean之后才会让其执行第二次。所以我们手动完全boot了一遍操作系统，才会导致这个错误爆出来，否则，操作系统就会使用原本的正确boot版本启动，之后再执行命令就当然是错误的了。</p>
<p>我想知乎文章里也应该是这个原因。操作系统本来使用的是错误版本，make clean后才会重新使用正确版本。</p>
<p>我之后写对了又尝试了一下，觉得我的猜想应该是对的。我的执行路线：</p>
<ol>
<li>make qemu，得到正确结果</li>
<li>将<code>bio.c</code>改回错误版本</li>
<li>再次make qemu，发现xv6正常boot，但是执行ls命令会出以上同样的错误</li>
<li>make clean，然后make qemu，爆出<code>panic:ilock: no type</code></li>
</ol>
<p>挺完美地符合了我的猜想。</p>
<p>【来自之后的学习：</p>
<p>in lab file system：</p>
<p>mkfs 程序创建 xv6 文件系统磁盘映像并确定文件系统总共有多少个块； 这个大小由 kernel/param.h 中的 FSSIZE 控制。 您会看到本实验存储库中的 FSSIZE 设置为 200,000 个块。 您应该在 make 输出中看到 mkfs/mkfs 的以下输出：<br>nmeta 70 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 25) blocks 199930 total 200000<br>这一行描述了 mkfs/mkfs 构建的文件系统：它有 70 个元数据块（用于描述文件系统的块）和 199,930 个数据块，共计 200,000 个块。<br><strong>如果在实验期间的任何时候您发现自己必须从头开始重建文件系统，您可以运行 make clean 来强制 make 重建 fs.img</strong>。</p>
<p>可以看到，我们上面就是做了强制重构fs.img。】</p>
</blockquote>
<p>我想来想去不知道这个错到底怎么爆的，看了下<code>ilock()</code>对应报错点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in fs.c ilock()</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;ilock begin.\n&quot;);</span></span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//print_buf();</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;bp-&gt;blockno = %d, bp-&gt;refcnt = %d\n&quot;</span>,bp-&gt;blockno,bp-&gt;refcnt);</span><br><span class="line">      panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可知大概就是，ip的type为0这个非法数值就报错了，而ip的type来源于dip，dip又指向了bp的data，bp也就是我们在<code>bio.c</code>一直在打交道的buf结构体。所以说，其实问题是出在了buf上，我们的<code>bread</code>返回的是一个错误的buf。</p>
<p>那么，究竟是buf的哪里出错了呢？这个问题想了我很久很久很久，依然没想出来。我一直认为是我的hashtable+双向链表这个数据结构哪里写错了，反反复复看了三四遍，其他地方的逻辑也反反复复研究了好几遍，依然没有结论。当然此过程也抓出了很多bug，但抓完bug后报错仍在，非常坚挺。</p>
<p>快要放弃的时候，我发现了错误。这很大一部分归功于我用于调试的这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印出hashtable的所有结点</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_buf</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;**********************\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cnt = %d,dec = %d\n&quot;</span>,cnt,dec);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NBUCKET;i++)&#123;</span><br><span class="line">  <span class="type">int</span> should = !holding(&amp;(bcache.dev_locks[i]));</span><br><span class="line">   <span class="keyword">if</span>(should)</span><br><span class="line">     acquire(&amp;(bcache.dev_locks[i]));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">   <span class="type">int</span> tmp_cnt = <span class="number">0</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">b</span>;</span></span><br><span class="line">   <span class="keyword">for</span>(b = bcache.dev_heads[i].next; b != &amp;(bcache.dev_heads[i]); b = b-&gt;next)&#123;</span><br><span class="line">   <span class="comment">//for(b = bcache.dev_heads[i].prev; b != &amp;(bcache.dev_heads[i]); b = b-&gt;prev)&#123;</span></span><br><span class="line">     tmp_cnt++;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;b.refcnt = %d,b.dev = %d,b.blockno = %d\n&quot;</span>,b-&gt;refcnt,b-&gt;dev,b-&gt;blockno);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d:total:%d\n&quot;</span>,i,tmp_cnt);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(should)</span><br><span class="line">     release(&amp;(bcache.dev_locks[i]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在<code>ilock()</code>的panic前面调用了这个函数，并且打印了出问题的buf的blockno：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)&#123;</span><br><span class="line">  print_buf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bp-&gt;blockno = %d, bp-&gt;refcnt = %d\n&quot;</span>,bp-&gt;blockno,bp-&gt;refcnt);</span><br><span class="line">  panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/10/xv6/image-20230123174332113.png" alt="image-20230123174332113"></p>
<p>可以看到，出问题的这里blockno=33，而在桶7中，首先有两个blockno==33的结点，这已经违反了不变性条件；其次有一个refcnt==1的结点，那个是所需结点，但我们却没有找到那个结点，反而去新申请了一个结点。这显然非常地古怪。</p>
<p>于是随后，我就在<code>bio.c</code>的<code>bget()</code>中添加了这么几句话：</p>
<p><img src="/2023/01/10/xv6/image-20230123174620818.png" alt="image-20230123174620818"></p>
<p>最终结果是会打印出两个blockno==0的结点，但是blockno==33的结点没有访问到。</p>
<p>这就很奇怪了。<code>print_buf</code>中以及<code>bget</code>的这个地方，都是遍历hashtable的某个双向链表，但是，为什么<code>print_buf</code>可以访问到，但是<code>bget</code>不行呢？</p>
<p>我首先对比出来的，是<code>print_buf</code>是逆序遍历，而<code>bget</code>是顺序遍历，所以我就又猜想是因为我的数据结构写错了，然而又看了一遍发现并不是。</p>
<p>这时候，可能我的视力恢复了吧，我猛然发现：：</p>
<p><img src="/2023/01/10/xv6/image-20230123174921100.png" alt="image-20230123174921100"></p>
<p>我超，这里是不是应该用hash。。。。。改完这处之后，果然就非常顺利地pass了所有测试【悲】</p>
<p>可以看到伏笔回收了。我是在旧思路代码基础上改过来的。旧思路代码是用dev作为index的，这个for循环忘记改了。因而，就这样，就这么寄了，看了我三四个小时【悲】</p>
<p>不过这倒是可以解释得通所有的错误了。之所以<code>ilock</code>中buf出错，没有正确找到已经映射在cache中的buf而是自己新建了一个，是因为，我压根就没有在正确的桶里找，而是在别的桶中找，这样自然就找不到了，就会自己新建一个，然后就寄了。</p>
<p>这个故事告诉我们，还是得谨慎写代码（）以及，我在旧代码基础上改的时候，其实可以用更聪明的替换方法：修改dev的变量名为hash-&gt;把参数里的dev变量名改为dev。这样就不会出错了。很遗憾，我并没有想到，只是很急很急地手动一个个改了，之后也没有检查，才发生如此错误。忏悔。</p>
<p>本次bug虽然很sb，但确实让我在debug过程中收获了些许，至少毅力变强了（）途中无数次想要放弃，还好我坚持了下来，才能看到如此感动的OK一片：</p>
<p><img src="/2023/01/10/xv6/image-20230123170805666.png" alt="image-20230123170805666"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h5 id="定义数据结构"><a href="#定义数据结构" class="headerlink" title="定义数据结构"></a>定义数据结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBUCKET 13</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">dev_heads</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">dev_locks</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span> =</span> bcache.buf;</span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 一开始先均分</span></span><br><span class="line">  uint64 tmp = NBUF/NBUCKET;</span><br><span class="line">  uint64 t = tmp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NBUCKET;i++)&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="number">9</span>,<span class="string">&quot;bcache%02d&quot;</span>,i);</span><br><span class="line">    initlock(&amp;(bcache.dev_locks[i]), buf);</span><br><span class="line">    bcache.dev_heads[i].prev = &amp;(bcache.dev_heads[i]);</span><br><span class="line">    bcache.dev_heads[i].next = &amp;(bcache.dev_heads[i]);</span><br><span class="line">    <span class="keyword">if</span>(i == NBUCKET<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(;b&lt;bcache.buf+NBUF;b++)&#123;</span><br><span class="line">        b-&gt;timestamp = ticks;</span><br><span class="line">        b-&gt;next = bcache.dev_heads[i].next;</span><br><span class="line">        b-&gt;prev = &amp;bcache.dev_heads[i];</span><br><span class="line">        initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">        bcache.dev_heads[i].next-&gt;prev = b;</span><br><span class="line">        bcache.dev_heads[i].next = b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(;b&lt;bcache.buf+t;b++)&#123;</span><br><span class="line">        b-&gt;timestamp = ticks;</span><br><span class="line">        b-&gt;next = bcache.dev_heads[i].next;</span><br><span class="line">        b-&gt;prev = &amp;bcache.dev_heads[i];</span><br><span class="line">        initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">        bcache.dev_heads[i].next-&gt;prev = b;</span><br><span class="line">        bcache.dev_heads[i].next = b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      t += tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="bget"><a href="#bget" class="headerlink" title="bget"></a>bget</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint hash = blockno%<span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;(bcache.dev_locks[hash]));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.dev_heads[hash].next; b != &amp;(bcache.dev_heads[hash]); b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;blockno == blockno&amp;&amp;b-&gt;dev == dev)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      b-&gt;timestamp = ticks;</span><br><span class="line">      release(&amp;(bcache.dev_locks[hash]));</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;(bcache.dev_locks[hash]));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历hash table，找到LRU，也即时间戳最小的且refcnt小于0的那一项</span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  uint min_time = <span class="number">4294967295</span>;<span class="comment">// uint的最大值。此处不能使用(uint)(-1)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">goal</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NBUCKET;i++)&#123;</span><br><span class="line">   uint time = <span class="number">0</span>;</span><br><span class="line">   acquire(&amp;(bcache.dev_locks[i]));</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.dev_heads[i].prev; b != &amp;(bcache.dev_heads[i]); b = b-&gt;prev)&#123;</span><br><span class="line">     <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">       time = b-&gt;timestamp;</span><br><span class="line">       <span class="keyword">if</span>(time &lt; min_time)&#123;</span><br><span class="line">         min_time = time;</span><br><span class="line">         goal = b;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;(bcache.dev_locks[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// hashtable中存在着空闲buf</span></span><br><span class="line">  <span class="keyword">if</span>(goal != <span class="number">0</span>)&#123;</span><br><span class="line">      goal-&gt;dev = dev;</span><br><span class="line">      goal-&gt;blockno = blockno;</span><br><span class="line">      goal-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      goal-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将goal从其所在双向链表中移除</span></span><br><span class="line">      goal-&gt;prev-&gt;next = goal-&gt;next;</span><br><span class="line">      goal-&gt;next-&gt;prev = goal-&gt;prev;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在新双向链表中添加goal</span></span><br><span class="line">      goal-&gt;prev = &amp;(bcache.dev_heads[hash]);</span><br><span class="line">      goal-&gt;next = bcache.dev_heads[hash].next;</span><br><span class="line"></span><br><span class="line">      bcache.dev_heads[hash].next-&gt;prev = goal;</span><br><span class="line">      bcache.dev_heads[hash].next = goal;</span><br><span class="line"></span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;goal-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> goal;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="brelse"><a href="#brelse" class="headerlink" title="brelse"></a>brelse</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uint hash = b-&gt;blockno%NBUCKET;</span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;(bcache.dev_locks[hash]));</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  b-&gt;timestamp = ticks;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>)&#123;</span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line"></span><br><span class="line">    b-&gt;next = bcache.dev_heads[hash].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.dev_heads[hash];</span><br><span class="line">    bcache.dev_heads[hash].next-&gt;prev = b;</span><br><span class="line">    bcache.dev_heads[hash].next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;(bcache.dev_locks[hash]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改bunpin和bpin"><a href="#修改bunpin和bpin" class="headerlink" title="修改bunpin和bpin"></a>修改bunpin和bpin</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  uint hash = b-&gt;blockno%NBUCKET;</span><br><span class="line">  acquire(&amp;bcache.dev_locks[hash]);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.dev_locks[hash]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bunpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  uint hash = b-&gt;blockno%NBUCKET;</span><br><span class="line">  acquire(&amp;bcache.dev_locks[hash]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.dev_locks[hash]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Scheduling</title>
    <url>/2023/01/10/xv6$chap7/</url>
    <content><![CDATA[<h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><h2 id="Code-Context-switching"><a href="#Code-Context-switching" class="headerlink" title="Code: Context switching"></a>Code: Context switching</h2><p>xv6中，每个CPU中的scheduler都有一个专用的线程。这里线程的概念是，有自己的栈，有自己的寄存器状态。</p>
<p>当发生时钟中断时，当前进程调用yield，yield再通过swtch切换到scheduler线程。scheduler线程会通过swtch跳转到另外一个进程去执行。当另外一个进程发生时钟中断，又会通过yield回到scheduler，scheduler再调度原进程继续执行，如此周而复始。</p>
<p><img src="/2023/01/10/xv6/image-20230118221757367.png" alt="image-20230118221757367"></p>
<p>下面就来讲讲这个所谓的“线程”以及xv6的上下文切换是怎么实现的。</p>
<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>上下文切换的操作对象是上下文，因而首先了解一下上下文的结构。各种寄存器的状态即是上下文context。xv6中的context定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上下文切换需要修改栈和pc，context中确实有sp寄存器，但是没有pc寄存器，这主要还是因为当swtch返回时，会回到ra所指向的地方，所以仅保存ra就足够了。</p>
<h3 id="swtch"><a href="#swtch" class="headerlink" title="swtch"></a>swtch</h3><p>上下文的切换是通过swtch实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>            <span class="title function_">swtch</span><span class="params">(<span class="keyword">struct</span> context*, <span class="keyword">struct</span> context*)</span>;</span><br></pre></td></tr></table></figure>

<p>swtch会把当前进程的上下文保存在第一个context中，再切换到第二个context保存的上下文，具体实现就是写读保存寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># in kernel/swtch.S</span><br><span class="line"># a0和a1分别保存着两个参数的值，也即第一个context的地址和第二个context的地址</span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        sd s1, 24(a0)</span><br><span class="line">        # ...</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ld s1, 24(a1)</span><br><span class="line">        # ...</span><br><span class="line">        ld 11, 104(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><p>在sleep、yield和wakeup中，都会通过sched中的swtch进入scheduler线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena;</span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpu中存储着的是scheduler线程的context。因而，这样就可以保存当前进程的context，读取scheduler线程的context，然后转换到scheduler的context执行了。</p>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过swtch进入scheduler线程后，会继续执行scheduler中swtch的下一个指令，完成下一次调度。</p>
<h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><p>以上是书本的介绍内容。看到这想必会有很多疑惑，至少有以下两点：</p>
<ol>
<li>为什么cpu-&gt;context会存储着scheduler的上下文？这是什么时候，又是怎么初始化的？</li>
<li>为什么从sched中swtch会来到scheduler中swtch的下一句？</li>
</ol>
<p>先从第一点入手。实际上，这个初始化的工作，是在操作系统启动时的<code>main.c</code>中完成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这之前，创建了第一个进程proc。在这里，每个cpu都调用了scheduler。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个cpu都在scheduler线程的<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context);</code>中，将当前的context，<strong>也即scheduler的context</strong>存入了<code>mycpu()-&gt;context</code>。随后，CPU中的某个去执行下一个进程，其他的就在scheduler线程的<strong>无限循环中等待</strong>，直到有别的进程产生。</p>
<p>去执行进程的CPU通过swtch切换上下文，切到了另一个进程中，此时在swtch中保存的ra是scheduler线程的swtch的下一句（因为scheduler-&gt;swtch也是个函数调用的过程）。会切到另一个进程的sched的下一句【因为它正是从那边swtch过来的】，或者是那个进程开始执行的地方【下面会提到是forkret】。另一个进程通过sched切换回来的时候，就正会切到ra所指向的位置，也即切到scheduler中的swtch后面。</p>
<p>这样一来，两个问题就都得到了解答。</p>
<p><strong>从这，我们也能知道xv6是如何让CPU运转的：scheduler线程是CPU的IDLE状态。无事的时候在scheduler中等待，并且一直监测是否有进程需要执行。有的话，则去执行该进程；该进程又会通过sched切换回scheduler线程，继续等待。这样一来，就完成了进程管理的基本的自动机图像。</strong></p>
<h2 id="Code-Scheduling"><a href="#Code-Scheduling" class="headerlink" title="Code: Scheduling"></a>Code: Scheduling</h2><h3 id="sched前要做的事"><a href="#sched前要做的事" class="headerlink" title="sched前要做的事"></a>sched前要做的事</h3><blockquote>
<p> A process that wants to give up the CPU must do three things:</p>
<ol>
<li>acquire its own process lock p-&gt;lock, release any other locks it is holding</li>
<li>update its own state (p-&gt;state)</li>
<li>call sched</li>
</ol>
<p> <code>yield</code> (kernel/proc.c:515) follows this convention, as do <code>sleep</code> and <code>exit</code>.</p>
<p> <code>sched</code> double-checks those conditions (kernel/proc.c:499-504) and then an implication of those conditions:  since a lock is held, interrupts should be disabled.</p>
</blockquote>
<h3 id="sched与scheduler"><a href="#sched与scheduler" class="headerlink" title="sched与scheduler"></a>sched与scheduler</h3><p>在上面的描述我们可以看到，<code>sched</code>和<code>scheduler</code>联系非常密切，他们俩通过<code>swtch</code>相互切来切去，并且一直都只在这几行切来切去：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scheduler()</span></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// in sched()</span></span><br><span class="line">swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">mycpu()-&gt;intena = intena;</span><br></pre></td></tr></table></figure>

<p>在两个线程之间进行这种样式化切换的过程有时被称为协程（coroutines）。</p>
<blockquote>
<p>存在一种情况使得调度程序对<code>swtch</code>的调用没有以<code>sched</code>结束。一个新进程第一次被调度时，它从<code>forkret</code>（<strong>kernel/proc.c</strong>:527）开始。<code>Forkret</code>是为了释放<code>p-&gt;lock</code>而包装的，要不然，新进程可以从<code>usertrapret</code>开始。</p>
</blockquote>
<h3 id="p-gt-lock保证了并发安全性"><a href="#p-gt-lock保证了并发安全性" class="headerlink" title="p-&gt;lock保证了并发安全性"></a>p-&gt;lock保证了并发安全性</h3><blockquote>
<p>考虑调度代码结构的一种方法是，它为每个进程强制维持一个不变性条件的集合，并在这些不变性条件不成立时持有<code>p-&gt;lock</code>。</p>
<p>其中一个不变性条件是：如果进程是<code>RUNNING</code>状态，计时器中断的<code>yield</code>必须能够安全地从进程中切换出去；这意味着CPU寄存器必须保存进程的寄存器值（即<code>swtch</code>没有将它们移动到<code>context</code>中），并且<code>c-&gt;proc</code>必须指向进程。另一个不变性条件是：如果进程是<code>RUNNABLE</code>状态，空闲CPU的调度程序必须安全地运行它；这意味着<code>p-&gt;context</code>必须保存进程的寄存器（即，它们实际上不在实际寄存器中），没有CPU在进程的内核栈上执行，并且没有CPU的<code>c-&gt;proc</code>引用进程。</p>
<p><u>维护上述不变性条件是xv6经常在一个线程中获取p-&gt;lock并在另一个线程中释放它的原因</u>，在保持<code>p-&gt;lock</code>时，这些属性通常不成立。</p>
<p>例如在<code>yield</code>中获取并在<code>scheduler</code>中释放。一旦<code>yield</code>开始修改一个<code>RUNNING</code>进程的状态为<code>RUNNABLE</code>，锁必须保持被持有状态，直到不变量恢复：最早的正确释放点是<code>scheduler</code>（在其自身栈上运行）清除<code>c-&gt;proc</code>之后。类似地，一旦<code>scheduler</code>开始将<code>RUNNABLE</code>进程转换为<code>RUNNING</code>，在内核线程完全运行之前（在<code>swtch</code>之后，例如在<code>yield</code>中）绝不能释放锁。</p>
<p><code>p-&gt;lock</code>还保护其他东西：<code>exit</code>和<code>wait</code>之间的相互作用，避免丢失<code>wakeup</code>的机制（参见第7.5节），以及避免一个进程退出和其他进程读写其状态之间的争用（例如，<code>exit</code>系统调用查看<code>p-&gt;pid</code>并设置<code>p-&gt;killed</code>(<strong>kernel/proc.c</strong>:611)）。为了清晰起见，也许为了性能起见，有必要考虑一下<code>p-&gt;lock</code>的不同功能是否可以拆分。</p>
</blockquote>
<p>p-&gt;lock在每次scheduler开始的时候获取，swtch到p进程的时候在yield等调用完sched的地方释放。而调用yield时获取的锁，又会在scheduler中释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Give up the CPU for one scheduling round.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);<span class="comment">// 该锁会在scheduler中释放</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  sched();</span><br><span class="line">  release(&amp;p-&gt;lock);<span class="comment">// 该锁释放的是scheduler中得到的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/proc.c scheduler()</span></span><br><span class="line">	  acquire(&amp;p-&gt;lock);<span class="comment">// 该锁会在yield等地被释放</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">      release(&amp;p-&gt;lock);<span class="comment">// 该锁会释放yield等地中获得的锁</span></span><br></pre></td></tr></table></figure>

<p>不得不说，这结构实在是太精妙了。这中间的如此多的复杂过程，就这样成功地被锁保护了起来。</p>
<h2 id="Code-mycpu-and-myproc"><a href="#Code-mycpu-and-myproc" class="headerlink" title="Code: mycpu and myproc"></a>Code: mycpu and myproc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mycpu是通过获取当前cpuid来获取cpu结构的。当前使用的cpuid约定俗成地存在了tp寄存器里。为了让mycpu有效工作，必须确保tp寄存器始终存放的是当前cpu的hartid。</p>
<p>首先是在操作系统初始化的时候要把cpuid存入tp寄存器。RISC-V规定，mhartid也即cpuid的存放点只能在machine mode被读取。因而这项工作得在<code>start.c</code>中完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/start.c </span></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"><span class="comment">// in kernel/riscv.h</span></span><br><span class="line"><span class="comment">// which hart (core) is this?</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_mhartid</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, mhartid&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内核态中，编译器被设置为保证不会以其他方式使用tp寄存器。因而初始化之后，内核态中每个CPU的tp寄存器就始终存放着自己的cpuid。</p>
<p>但这在用户进程是不成立的。因而必须在用户进程进入陷阱的时候做一些工作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># in kernel/trampoline.S uservec</span><br><span class="line">sd tp, 64(a0)</span><br><span class="line"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">ld tp, 32(a0)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须在trampoline保存用户态中使用的tp值，以及内核态中对应的hartid。</p>
<p>最后再在返回用户态的时候恢复用户态的tp值以及更新trampoline的tp值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c usertrapret()</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># in trampoline.S userret</span><br><span class="line">ld tp, 64(a0)</span><br></pre></td></tr></table></figure>

<p>注意，更新trampoline的tp值这一步很重要。因为如果在用户态发生的是时钟中断，就会引起yield，可能造成CPU的切换。这时候就需要在返回用户态的时候修改一下trapframe中的tp为当前CPU的tp。这样一来才能保证，在本次时钟中断结束，以及到下一次时钟中断修改CPU这一期间，trapframe中的tp寄存器以及内核态中的tp寄存器都是正确的。</p>
<p>通过<code>mycpu()</code>获取cpuid其实是非常脆弱的。因为你可能获取完cpuid，进程就被切到别的CPU去执行了，这就会有一个先检查后执行的竞态条件，具有并发安全隐患。因而，xv6要求使用<code>mycpu()</code>返回值的这段代码需要关中断，这样就可以避免时钟中断造成的进程切换了。比如说像<code>myproc()</code>这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return the current struct proc *, or zero if none.</span></span><br><span class="line"><span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，不同于<code>mycpu()</code>，使用<code>myproc()</code>的返回值不需要进行开关中断保护。因为当前进程的指针不论处于哪个CPU都是不变的。</p>
<h2 id="Sleep-and-wakeup"><a href="#Sleep-and-wakeup" class="headerlink" title="Sleep and wakeup"></a>Sleep and wakeup</h2><p>前面我们已经介绍了进程隔离性的基本图像，接下来要讲xv6是如何让进程之间互动的。xv6使用的是经典的<em>sleep and wakeup</em>，也叫<em>序列协调（sequence coordination）</em>或<em>条件同步机制（conditional synchronization mechanisms</em>。下面，将从最基本的自旋锁实现信号量开始，来逐步讲解xv6的<em>sleep and wakeup</em>机制。</p>
<h3 id="自旋锁实现信号量"><a href="#自旋锁实现信号量" class="headerlink" title="自旋锁实现信号量"></a>自旋锁实现信号量</h3><p><img src="/2023/01/10/xv6/image-20230120150659730.png" alt="image-20230120150659730"></p>
<p><img src="/2023/01/10/xv6/image-20230120150715925.png" alt="image-20230120150715925"></p>
<p>缺点就是自旋太久了，因而我们需要在等待的时候调用yield，直到资源生产出来之后再继续执行。</p>
<h3 id="不安全的sleep-and-wakeup"><a href="#不安全的sleep-and-wakeup" class="headerlink" title="不安全的sleep and wakeup"></a>不安全的sleep and wakeup</h3><blockquote>
<p>Let’s imagine a pair of calls, sleep and wakeup, that work as follows:</p>
<ol>
<li><p><code>sleep(chan)</code></p>
<p>Sleeps on the arbitrary value chan, called the <em>wait channel</em>. Sleep puts the calling process to sleep, releasing the CPU for other work.  </p>
</li>
<li><p><code>wakeup(chan)</code></p>
<p>Wakes <strong>all</strong> processes sleeping on chan (if any), causing their sleep calls to return. If no processes are waiting on chan, wakeup does nothing.</p>
</li>
</ol>
</blockquote>
<p>这样一来，信号量实现就可修改为这样了：</p>
<p><img src="/2023/01/10/xv6/image-20230120151051989.png" alt="image-20230120151051989"></p>
<p>但是，我们可以注意到，在212-213行这里产生了一个先检查后执行的竞态条件。</p>
<blockquote>
<p>如果消费者进程执行到212-213中间，此时生产者进程已经调用结束，也就是说wakeup并没有唤醒任何消费者进程。消费者进程就会一直在sleep中没人唤醒，除非生产者进程再执行一次。这样就会造成<em>lost wake-up</em> 这个问题。</p>
</blockquote>
<p>所以，我们可以选择把这个竞态条件也放入s-&gt;lock这个锁区域保护。</p>
<p><img src="/2023/01/10/xv6/image-20230120151353712.png" alt="image-20230120151353712"></p>
<p>但是这样一来又会产生死锁问题。因而，我们可以尝试着修改sleep和wakeup的接口定义。</p>
<h3 id="sleep-and-wakeup"><a href="#sleep-and-wakeup" class="headerlink" title="sleep and wakeup"></a>sleep and wakeup</h3><blockquote>
<p>We’ll fix the preceding scheme by changing sleep’s interface: </p>
<p>The caller must pass the <em>condition lock</em> to sleep so it can <strong>release the lock</strong> after the calling process is marked as asleep and waiting on the sleep channel. The lock will force a concurrent V to wait until P has finished putting itself to sleep, so that the wakeup will find the sleeping consumer and wake it up. Once the consumer is awake again sleep <strong>reacquires the lock</strong> before returning. </p>
<p>也即在sleep中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sleep(s,&amp;s-&gt;lock)&#123;</span><br><span class="line"> <span class="comment">// do something</span></span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">	<span class="comment">//wait until wakeup</span></span><br><span class="line"> acquire(&amp;s-&gt;lock);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样一来，信号量就可以完美实现了：</p>
<p><img src="/2023/01/10/xv6/image-20230120151807102.png" alt="image-20230120151807102"></p>
<p><img src="/2023/01/10/xv6/image-20230120151820455.png" alt="image-20230120151820455"></p>
<blockquote>
<p>注：严格地说，<code>wakeup</code>只需跟在<code>acquire</code>之后就足够了（也就是说，可以在<code>release</code>之后调用<code>wakeup</code>）</p>
<p>【想了一下，有一说一确实，放在release前后都不影响】</p>
</blockquote>
<blockquote>
<p>原始Unix内核的<code>sleep</code>只是禁用了中断，这就足够了，因为Unix运行在单CPU系统上。因为xv6在多处理器上运行，所以它为<code>sleep</code>添加了一个显式锁。</p>
</blockquote>
<h2 id="Code-Sleep-and-wakeup"><a href="#Code-Sleep-and-wakeup" class="headerlink" title="Code: Sleep and wakeup"></a>Code: Sleep and wakeup</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Atomically release lock and sleep on chan.</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    <span class="comment">// 获取进程锁，释放外部锁</span></span><br><span class="line">    <span class="comment">// 此进程锁将在scheduler线程中释放</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    release(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line">  <span class="comment">// 到这里来，说明已经被wakeup且被调度了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    <span class="comment">//释放进程锁，获取外部锁</span></span><br><span class="line">    <span class="comment">// 此进程锁是在scheduler中获取到的</span></span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    acquire(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果lk为p-&gt;lock，那么<strong>lk依然会在scheduler线程中被暂时释放</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到，关于<code>chan</code>这一变量的取值是非常任意的，仅需取一个约定俗成的值就OK。这里取为了信号量的地址，同时满足了逻辑需求和语义需求。</p>
<blockquote>
<p>Callers of sleep and wakeup can use any mutually convenient number as the channel. Xv6 often uses the address of a kernel data structure involved in the waiting.</p>
</blockquote>
<p>这里也解释了为什么需要while循环</p>
<blockquote>
<p>有时，多个进程在同一个通道上睡眠；例如，多个进程读取同一个管道。一个单独的<code>wakeup</code>调用就能把他们全部唤醒。其中一个将首先运行并获取与<code>sleep</code>一同调用的锁，并且（在管道例子中）读取在管道中等待的任何数据。尽管被唤醒，其他进程将发现没有要读取的数据。从他们的角度来看，醒来是“虚假的”，他们必须再次睡眠。因此，在检查条件的循环中总是调用<code>sleep</code>。</p>
</blockquote>
<h2 id="Code-Pipes"><a href="#Code-Pipes" class="headerlink" title="Code: Pipes"></a>Code: Pipes</h2><p>pipes很显然就是生产者消费者模式的一个例证。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">  uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">  uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">  <span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">  <span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">piperead</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="comment">//DOC: pipe-empty并且依然有进程在写</span></span><br><span class="line">    <span class="keyword">if</span>(pr-&gt;killed)&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待直到pipe不为空</span></span><br><span class="line">    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="comment">//DOC: piperead-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">//DOC: piperead-copy</span></span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];</span><br><span class="line">    <span class="keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒写入管道的进程</span></span><br><span class="line">  wakeup(&amp;pi-&gt;nwrite);  <span class="comment">//DOC: piperead-wakeup</span></span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipewrite</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123;  <span class="comment">//DOC: pipewrite-full管道满则阻塞</span></span><br><span class="line">      <span class="keyword">if</span>(pi-&gt;readopen == <span class="number">0</span> || pr-&gt;killed)&#123;</span><br><span class="line">        release(&amp;pi-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 唤醒读取管道的进程</span></span><br><span class="line">      wakeup(&amp;pi-&gt;nread);</span><br><span class="line">      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;pi-&gt;nread);</span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非常有意思且巧妙的点，就是<strong>读写管道等待在不同的chan上</strong>，这与上面信号量的例子是不一样的。想想也确实，如果使用同一个管道的话，当唤醒的时候，就会把不论是读还是写的全部进程都唤醒过来，这对性能显然损失较大。</p>
<blockquote>
<p>The pipe code uses separate sleep channels for reader and writer (pi-&gt;nread and pi-&gt;nwrite); this might make the system more effificient in the unlikely event that there are lots of readers and writers waiting for the same pipe.</p>
</blockquote>
<h2 id="Code-Wait-exit-and-kill"><a href="#Code-Wait-exit-and-kill" class="headerlink" title="Code: Wait, exit, and kill"></a>Code: Wait, exit, and kill</h2><h3 id="exit和wait"><a href="#exit和wait" class="headerlink" title="exit和wait"></a>exit和wait</h3><blockquote>
<p><code>Sleep</code>和<code>wakeup</code>可用于多种等待。第一章介绍的一个有趣的例子是子进程<code>exit</code>和父进程<code>wait</code>之间的交互。</p>
<p>xv6记录子进程终止直到<code>wait</code>观察到它的方式是让<code>exit</code>将调用方置于<code>ZOMBIE</code>状态，在那里它一直保持到父进程的<code>wait</code>注意到它，将子进程的状态更改为<code>UNUSED</code>，复制子进程的<code>exit</code>状态码，释放子进程，并将子进程ID返回给父进程。</p>
<p>如果父进程在子进程之前退出，则父进程将子进程交给<code>init</code>进程，<code>init</code>进程将永久调用<code>wait</code>；因此，每个子进程退出后都有一个父进程进行清理。</p>
</blockquote>
<p>又是一个生产者消费者模式。只不过此时的chan是父进程，资源是僵尸子进程【草】。由于涉及到进程间的调度切换，因而实现稍微复杂了点。</p>
<p>为什么需要涉及到进程间的调度呢？子进程设置完僵尸状态后，直接通过函数ret不行吗？答案是不行，因为ret的话就会去到不知道哪的地方【大概率会变成scause=2的情况】，所以这里子进程想要退出，就得做几件事，一是依靠父进程，让父进程杀死子进程，二是把自己设置为一个特殊的状态，使得自己不会被调度从而执行ret指令出错，三是尽快让父进程杀死自己越快越好。综合上述三个原因，exit最终在调度方面的实现方式，就变成了，子进程设置自己为ZOMBIE态-&gt;启用调度-&gt;父进程杀死ZOMBIE态的子进程。这期间不变性条件的防护，就得依赖于锁，以及sleep和wakeup了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// we need the parent&#x27;s lock in order to wake it up from wait().</span></span><br><span class="line">  <span class="comment">// the parent-then-child rule says we have to lock it first.</span></span><br><span class="line">  <span class="comment">// 整个xv6都必须遵守相同的顺序（父级，然后是子级）不论是锁定还是释放，都是先父再子</span></span><br><span class="line">  acquire(&amp;original_parent-&gt;lock);</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give any children to init.</span></span><br><span class="line">  <span class="comment">// 把自己的所有孩子都托付给init进程</span></span><br><span class="line">  <span class="comment">// init进程就是在操作系统启动时</span></span><br><span class="line">  reparent(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parent might be sleeping in wait().</span></span><br><span class="line">  <span class="comment">// 唤醒wait中的父进程</span></span><br><span class="line">  <span class="comment">// 这里看上去很诡异，明明子进程状态还未完全，怎么就唤醒父亲了呢？但其实很安全。</span></span><br><span class="line">  <span class="comment">// 此时子进程仍持有父进程的锁，如果有别的CPU中断进入scheduler线程，到父进程那时会卡在aquire</span></span><br><span class="line">  <span class="comment">// 直到子进程完成后续工作后父进程才能被真正唤醒执行</span></span><br><span class="line">  wakeup1(original_parent);</span><br><span class="line"></span><br><span class="line">  p-&gt;xstate = status;</span><br><span class="line">  <span class="comment">// 设为ZOMBIE态</span></span><br><span class="line">  p-&gt;state = ZOMBIE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成后续工作，解除父进程的锁</span></span><br><span class="line">  release(&amp;original_parent-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Jump into the scheduler, never to return.</span></span><br><span class="line">  <span class="comment">// 子进程会在父进程中被释放，所以永远不会回来</span></span><br><span class="line">  sched();</span><br><span class="line">  panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">wait</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hold p-&gt;lock for the whole time to avoid lost</span></span><br><span class="line">  <span class="comment">// wakeups from a child&#x27;s exit().</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;</span><br><span class="line">      <span class="comment">// this code uses np-&gt;parent without holding np-&gt;lock.</span></span><br><span class="line">      <span class="comment">// acquiring the lock first would cause a deadlock,</span></span><br><span class="line">      <span class="comment">// since np might be an ancestor, and we already hold p-&gt;lock.</span></span><br><span class="line">      <span class="comment">// 下面的第一点其实一句话就可以搞定：</span></span><br><span class="line">      <span class="comment">// 【它违反了先获取父亲锁，再获取子锁的xv6代码规定】</span></span><br><span class="line">      <span class="comment">// 1.要是在这句话之前acquire的话，acquire到你爸，你爸这时候也刚好执行到这句话</span></span><br><span class="line">      <span class="comment">// 那么就会造成你在自旋【此时你爸在wait一开始就得到了锁】，</span></span><br><span class="line">      <span class="comment">// 你爸也在自旋【你也在wait一开始得到了锁】,这样就造成了死锁</span></span><br><span class="line">      <span class="comment">// 2.并且由于np-&gt;parent只有parent才能改，所以数据是否过时是没关系的</span></span><br><span class="line">      <span class="comment">// 因为如果不是你儿子，数据过时与否都知道不是你儿子</span></span><br><span class="line">      <span class="comment">// 如果是你儿子，那数据压根就不会过时</span></span><br><span class="line">      <span class="keyword">if</span>(np-&gt;parent == p)&#123;</span><br><span class="line">        <span class="comment">// np-&gt;parent can&#x27;t change between the check and the acquire()</span></span><br><span class="line">        <span class="comment">// because only the parent changes it, and we&#x27;re the parent.</span></span><br><span class="line">        acquire(&amp;np-&gt;lock);</span><br><span class="line">        havekids = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(np-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          <span class="comment">// Found one.</span></span><br><span class="line">          pid = np-&gt;pid;</span><br><span class="line">          <span class="comment">// 传递返回参数</span></span><br><span class="line">          <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;np-&gt;xstate,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(np-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            release(&amp;np-&gt;lock);</span><br><span class="line">            release(&amp;p-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          freeproc(np);</span><br><span class="line">          release(&amp;np-&gt;lock);</span><br><span class="line">          release(&amp;p-&gt;lock);</span><br><span class="line">          <span class="keyword">return</span> pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don&#x27;t have any children.</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || p-&gt;killed)&#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for a child to exit.</span></span><br><span class="line">    <span class="comment">// 暂时释放p锁，等待子进程获取退出</span></span><br><span class="line">    sleep(p, &amp;p-&gt;lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中值得注意的几个点：</p>
<ol>
<li><p><code>wait</code>中的<code>sleep</code>中释放的条件锁是等待进程的<code>p-&gt;lock</code>，这是上面提到的特例。</p>
</li>
<li><p>exit会将自己的所有子进程交付给一直在等待着的init进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">    <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">    wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">      <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这里！！</span></span><br><span class="line">      <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子进程退出，就会通过init的wait释放它们。然后init释放完它们后进入第三个if分支，继续进行循环。</p>
</li>
<li><p>wakeup1</p>
<blockquote>
<p>Exit calls a specialized wakeup function, wakeup1, that wakes up only the parent, and only if it is sleeping in wait.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wake up p if it is sleeping in wait(); used by exit().</span></span><br><span class="line"><span class="comment">// Caller must hold p-&gt;lock.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup1</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;wakeup1&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;chan == p &amp;&amp; p-&gt;state == SLEEPING) &#123;</span><br><span class="line">    p-&gt;state = RUNNABLE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>kill其实做得很温和。它只是会把想鲨的进程的p-&gt;killed设置为1，然后如果该进程sleeping，则唤醒它。最后的死亡以及销毁由进程自己来做。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kill the process with the given pid.</span></span><br><span class="line"><span class="comment">// The victim won&#x27;t exit until it tries to go</span></span><br><span class="line"><span class="comment">// to kernel space (see usertrap() in trap.c).</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid == pid)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING)&#123;</span><br><span class="line">        <span class="comment">// Wake process from sleep().</span></span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// in trap.c usertrap()</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>可能这里有一个疑问：调用完exit后，进程会变成ZOMBIE态。谁最终把它释放了呢？其实答案很简单，只有两种：init进程或者是创建它的父进程。</p>
<p>如果创建它的父进程处于wait中，那么是由父进程把它销毁的，这没什么好说的。但如果创建它的父进程不在wait呢？那么父进程最后也是会调用exit的。父进程调用完exit后，会将其所有子进程过继给init进程。所以，ZOMBIE进程最终还是会迟早被init进程杀死的。</p>
<p>由这里，可以窥见xv6进程管理的进一步的冰山一角：</p>
<p>init进程是所有进程的根系进程。它一直处于wait的死循环中，因而可以将需要被杀死的进程杀死。</p>
<p>可见，wait和exit，实际上就构筑了进程的生命周期的最后一环。</p>
<p>这种巧妙地将进程生命周期这个大事<strong>完全托付给了wait和exit这两个函数</strong>的这种结构，实在是非常精妙，太牛了吧。</p>
<blockquote>
<p>一些XV6的<code>sleep</code>循环不检查<code>p-&gt;killed</code>，因为代码在应该是原子操作的多步系统调用的中间。virtio驱动程序（*<strong>kernel/virtio_disk.c*</strong>:242）就是一个例子：它不检查<code>p-&gt;killed</code>，因为一个磁盘操作可能是文件系统保持正确状态所需的一组写入操作之一。等待磁盘I/O时被杀死的进程将不会退出，直到它完成当前系统调用并且<code>usertrap</code>看到<code>killed</code>标志</p>
</blockquote>
<blockquote>
<p>Xv6对<code>kill</code>的支持并不完全令人满意：有一些<code>sleep</code>循环可能应该检查<code>p-&gt;killed</code>。一个相关的问题是，即使对于检查<code>p-&gt;killed</code>的<code>sleep</code>循环，<code>sleep</code>和<code>kill</code>之间也存在竞争；后者可能会设置<code>p-&gt;killed</code>，并试图在受害者的循环检查<code>p-&gt;killed</code>之后但在调用<code>sleep</code>之前尝试唤醒受害者。如果出现此问题，受害者将不会注意到<code>p-&gt;killed</code>，直到其等待的条件发生。这可能比正常情况要晚一点（例如，当virtio驱动程序返回受害者正在等待的磁盘块时）或永远不会发生（例如，如果受害者正在等待来自控制台的输入，但用户没有键入任何输入）。</p>
</blockquote>
<p>是的，所以这个kill的实现其实是相当玄学的。</p>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>xv6调度器实现了一个简单的调度策略：它依次运行每个进程。这一策略被称为轮询调度（round robin）。真实的操作系统实施更复杂的策略，例如，允许进程具有优先级。</p>
</blockquote>
<p>我记得linux0.11用的是时间片轮转+优先级队列完美融合的方法，是真的很牛逼</p>
<blockquote>
<p>复杂的策略可能会导致意外的交互，例如优先级反转（priority inversion）和航队（convoys）。当低优先级进程和高优先级进程共享一个锁时，可能会发生优先级反转，当低优先级进程持有该锁时，可能会阻止高优先级进程前进。当许多高优先级进程正在等待一个获得共享锁的低优先级进程时，可能会形成一个长的等待进程航队；一旦航队形成，它可以持续很长时间。为了避免此类问题，在复杂的调度器中需要额外的机制。</p>
</blockquote>
<blockquote>
<p>在<code>wakeup</code>中扫描整个进程列表以查找具有匹配<code>chan</code>的进程效率低下。一个更好的解决方案是用一个数据结构替换<code>sleep</code>和<code>wakeup</code>中的<code>chan</code>，该数据结构包含在该结构上休眠的进程列表，例如Linux的等待队列。</p>
</blockquote>
<p>是的，linux的那个wakeup真的很牛，我现在都还记得当初学到那的时候的震撼。</p>
<blockquote>
<p><code>wakeup</code>的实现会唤醒在特定通道上等待的所有进程，可能有许多进程在等待该特定通道。操作系统将安排所有这些进程，它们将竞相检查睡眠条件。进程的这种行为有时被称为<strong>惊群效应</strong>（thundering herd），最好避免。</p>
<p>大多数条件变量都有两个用于唤醒的原语：<code>signal</code>用于唤醒一个进程；<code>broadcast</code>用于唤醒所有等待进程。</p>
</blockquote>
<blockquote>
<p>一个实际的操作系统将在固定时间内使用空闲列表找到自由的<code>proc</code>结构体，而不是<code>allocproc</code>中的线性时间搜索；xv6使用线性扫描是为了简单起见。</p>
</blockquote>
<h2 id="Lab-Multithreading"><a href="#Lab-Multithreading" class="headerlink" title="Lab: Multithreading"></a>Lab: Multithreading</h2><blockquote>
<p>You will implement switching between threads in a user-level threads package, use multiple threads to speed up a program, and implement a barrier.</p>
</blockquote>
<p>这个introduction看起来还是非常激动人心的，很早就想了解到底线程是怎么实现的了。不过做完发现思想还是很简单的，就是只用切换上下文和栈就行。可以看看提供给的代码。</p>
<h3 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h3><blockquote>
<p>In this exercise you will design the <strong>context switch</strong> mechanism for a user-level threading system, and then implement it. </p>
<p>To get you started, your xv6 has two files <code>user/uthread.c</code> and <code>user/uthread_switch.S</code>, and a rule in the Makefile to build a uthread program. </p>
<p><code>uthread.c</code> contains most of a user-level threading package, and code for three simple test threads. The threading package is missing some of the code to create a thread and to switch between threads.</p>
<p>You will need to add code to <code>thread_create()</code> and <code>thread_schedule()</code> in <code>user/uthread.c</code>, and <code>thread_switch</code> in <code>user/uthread_switch.S</code>. </p>
<p>One goal is ensure that when <code>thread_schedule()</code> runs a given thread for the first time, the thread executes the function passed to <code>thread_create()</code>, on its <strong>own stack.</strong> </p>
<p>Another goal is to ensure that <code>thread_switch</code> saves the registers of the thread being switched away from, restores the registers of the thread being switched to, and returns to the point in the latter thread’s instructions where it last left off. You will have to decide where to save/restore registers; modifying <code>struct thread</code> to hold registers is a good plan. </p>
<p>You’ll need to add a call to <code>thread_switch</code> in <code>thread_schedule</code>; you can pass whatever arguments you need to <code>thread_switch</code>, but the intent is to switch from thread <code>t</code> to <code>next_thread</code>.</p>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>看了一遍它这里面写的题目还是有点抽象的，需要结合着给的代码看，那样就清晰多了。</p>
<p>首先，要补全的地方有这几个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. in thread_schedule()</span></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 2. in thread_create()</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. in uthread_switch.S</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * save the old thread&#x27;s registers,</span></span><br><span class="line"><span class="comment">         * restore the new thread&#x27;s registers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        .globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">        <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">        ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure>

<p>这几个函数到时候会被如此调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  a_started = b_started = c_started = <span class="number">0</span>;</span><br><span class="line">  a_n = b_n = c_n = <span class="number">0</span>;</span><br><span class="line">  thread_init();</span><br><span class="line">  thread_create(thread_a);</span><br><span class="line">  thread_create(thread_b);</span><br><span class="line">  thread_create(thread_c);</span><br><span class="line">  thread_schedule();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们在第一个地方要做的，就是要填入swtch的签名。第二个地方要做的，就是要想办法让该线程一被启动就去执行参数的函数指针。第三个地方要做的，就是要完成上下文的切换。</p>
<p>所以思路其实是很直观的。我们可以模仿进程管理中用来表示上下文的context，在<code>thread_create</code>的时候把里面的ra设置为参数的函数指针入口，sp修改为thread结构体中的栈地址。swtch函数则完全把<code>kernel/swtch.S</code>超过来就行。</p>
<blockquote>
<p>在这个思路中，我们是怎么做到栈的切换的呢？</p>
<p>每个线程在<code>thread_create</code>的时候，都将自己的context中的sp修改为自己的栈地址。这样一来，在它们被调度的时候，switch会自然而然地从context中读取sp作为之后运行的sp，这样就实现了栈的切换。</p>
</blockquote>
<h5 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h5><p>我觉得其他方面都不难，最坑最细节的【也是我完全没有想到的……】就是这里：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改sp为栈顶</span></span><br><span class="line">t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br></pre></td></tr></table></figure>

<p>需要注意，栈顶并不是<code>t-&gt;stack</code>。</p>
<p>通过测试程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0062f</span>eb8</span><br><span class="line"><span class="number">0062f</span>ebc</span><br><span class="line"><span class="number">0062f</span>ec0</span><br><span class="line"><span class="number">0062f</span>ec4</span><br><span class="line"><span class="number">0062f</span>ec8</span><br></pre></td></tr></table></figure>

<p>栈是向下增长的，因而，栈顶确实应该是数组的末尾……</p>
<p>这里完全没有想到，还是吃了基础的亏啊。</p>
<blockquote>
<p>如果这里将<code>t-&gt;stack</code>作为sp，那么运行时会出现非常诡异的现象（打印的是abc三个的<code>thread-&gt;state</code>）：</p>
<p><img src="/2023/01/10/xv6/image-20230120232149776.png" alt="image-20230120232149776"></p>
<p>仅有c【经测试，是仅有最后一个启动的线程】在执行，而ab的state都不是理想中的2，而是很奇怪的值。我确实有想过栈溢出问题，但是马上被我否定了。我完全没有想到是那样错的【悲】</p>
</blockquote>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="增加context结构体定义，修改thread结构体"><a href="#增加context结构体定义，修改thread结构体" class="headerlink" title="增加context结构体定义，修改thread结构体"></a>增加context结构体定义，修改thread结构体</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-create"><a href="#修改thread-create" class="headerlink" title="修改thread_create"></a>修改thread_create</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">// 将当前上下文保存入context</span></span><br><span class="line">  thread_switch((uint64)(&amp;(t-&gt;context)),(uint64)(&amp;(t-&gt;context)));</span><br><span class="line">  <span class="comment">// 修改sp为栈顶</span></span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">  <span class="comment">// 修改ra为参数的函数指针入口</span></span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-schedule"><a href="#修改thread-schedule" class="headerlink" title="修改thread_schedule"></a>修改thread_schedule</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">  next_thread-&gt;state = RUNNING;</span><br><span class="line">  t = current_thread;</span><br><span class="line">  current_thread = next_thread;</span><br><span class="line">  <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">   * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">   * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  thread_switch((uint64)(&amp;(t-&gt;context)),(uint64)(&amp;(current_thread-&gt;context)));</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-switch"><a href="#修改thread-switch" class="headerlink" title="修改thread_switch"></a>修改thread_switch</h5><p>全部照搬<code>kernel/swtch.S</code>，没什么好说的</p>
<h3 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h3><p>一步步细粒度化，最后，每个桶用单独一把锁，仅在调用insert处加锁就行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> locks[NBUCKET];<span class="comment">// 在main中初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><blockquote>
<p>In this assignment you’ll implement a <a href="http://en.wikipedia.org/wiki/Barrier_(computer_science)">barrier</a>: a point in an application at which all participating threads must wait until all other participating threads reach that point too.</p>
</blockquote>
<p>直接上代码，还是比较简单的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">   pthread_mutex_lock(&amp;(bstate.barrier_mutex));</span><br><span class="line">   bstate.nthread++;</span><br><span class="line">   <span class="keyword">while</span>(bstate.nthread &lt; nthread)&#123;</span><br><span class="line">    pthread_cond_wait(&amp;(bstate.barrier_cond), &amp;(bstate.barrier_mutex));</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 此部分仅一个线程会进入</span></span><br><span class="line">   pthread_cond_broadcast(&amp;(bstate.barrier_cond));</span><br><span class="line">   bstate.nthread = <span class="number">0</span>;</span><br><span class="line">   bstate.round++;</span><br><span class="line">end:</span><br><span class="line">   pthread_mutex_unlock(&amp;(bstate.barrier_mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>File system</title>
    <url>/2023/01/10/xv6$chap8/</url>
    <content><![CDATA[<h1 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h1><blockquote>
<p>来到指导书最高点！太美丽了xv6。哎呀那不文件系统吗（</p>
<p>这里是自底向上讲起的。之后可以看看hit网课的自顶向下。</p>
</blockquote>
<blockquote>
<p><img src="/2023/01/10/xv6/image-20230121160555370.png" alt="image-20230121160555370"></p>
</blockquote>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="/2023/01/10/xv6/image-20230121160641718.png" alt="image-20230121160641718"></p>
<blockquote>
<p>The disk layer reads and writes blocks on an virtio hard drive. </p>
<p>The buffer cache layer <strong>caches</strong> disk blocks and <strong>synchronizes</strong> access to them, making sure that only one kernel process at a time can modify the data stored in any particular block. </p>
<p>The logging layer allows higher layers to <strong>wrap updates</strong> to several blocks in a <em>transaction</em>, and ensures that the blocks are updated atomically in the face of crashes (i.e., all of them are updated or none). 【日志记录层允许更高层将更新包装到一个<em>事务</em>中的多个块，并确保在崩溃时以原子方式更新块（即，所有块都更新或不更新）。可以类比一下数据库的那个概念。】</p>
<p>The inode layer provides individual files, each represented as an <em>inode</em> with a unique i-number and some blocks holding the file’s data. </p>
<p>The directory layer implements each directory as a <strong>special kind of inode</strong> whose content is a sequence of directory entries, each of which contains a file’s name and i-number. </p>
<p>The pathname layer provides hierarchical path names like /usr/rtm/xv6/fs.c, and resolves them with <strong>recursive</strong> lookup. </p>
<p>The file descriptor layer <strong>abstracts</strong> many Unix resources (e.g., pipes, devices, fifiles, etc.) using the file system interface, simplifying the lives of application programmers.</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<blockquote>
<p>The file system must have a plan for where it stores inodes and content blocks on the disk. To do so, xv6 divides the disk into several sections, as Figure 8.2 shows.</p>
<p>The file system does not use block 0 (it holds the boot sector). </p>
<p>Block 1 is called the <strong>superblock</strong>; it contains <strong>metadata</strong> about the file system (the file system size in blocks, the number of data blocks, the number of inodes, and the number of blocks in the log). The superblock is filled in by a separate program, called <code>mkfs</code>, which builds an <strong>initial</strong> file system.</p>
<p>Blocks starting at 2 hold the log. </p>
<p>After the log are the inodes, with multiple inodes per block. </p>
<p>After those come bitmap blocks tracking which data blocks are in use. 【应该是用来标识每个块是否空闲的吧】</p>
<p>The remaining blocks are data blocks; each is either marked free in the bitmap block, or holds content for a file or directory【要么空闲要么是文件或目录】. </p>
</blockquote>
<h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><blockquote>
<p>The buffer cache has two jobs: </p>
<ol>
<li><strong>synchronize</strong> access to disk blocks to ensure that only one copy of a block is in memory and that only one kernel thread at a time uses that copy; </li>
<li><strong>cache</strong> <u>popular blocks</u> so that they don’t need to be re-read from the slow disk. </li>
</ol>
<p>The code is in <code>bio.c</code>.</p>
<p>Buffer cache中保存磁盘块的缓冲区数量固定，这意味着如果文件系统请求还未存放在缓存中的块，Buffer cache必须回收当前保存其他块内容的缓冲区。Buffer cache为新块回收最近使用最少的缓冲区。这样做的原因是认为最近使用最少的缓冲区是最不可能近期再次使用的缓冲区。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230124151719288.png" alt="image-20230124151719288"></p>
<h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?缓冲区是否包含块的副本</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?缓冲区内容是否已交给磁盘</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这应该代表着一个磁盘块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<p>大概buf数组里存储着所有buf的内容。buf本身通过最近使用排序的双向链表连接，head是链表的头。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// called by main.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  <span class="comment">// 把b插在head之后</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上层接口"><a href="#上层接口" class="headerlink" title="上层接口"></a>上层接口</h3><blockquote>
<p>The main interface exported by the buffer cache consists of <code>bread</code> and <code>bwrite</code>.</p>
<p>The buffer cache uses a per-buffer sleep-lock to ensure concurrent security.</p>
</blockquote>
<h4 id="bread"><a href="#bread" class="headerlink" title="bread"></a>bread</h4><blockquote>
<p><code>bread</code> obtains a buf containing a copy of a block which can be read or modified in memory.</p>
<p>依据给定设备号和给定扇区号寻找cache的buf。返回的buf是locked的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return a locked buf with the contents of the indicated block.</span></span><br><span class="line"><span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取buf块</span></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line">    <span class="comment">// 说明cache未命中，需要从磁盘读入</span></span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bwrite"><a href="#bwrite" class="headerlink" title="bwrite"></a>bwrite</h4><blockquote>
<p>writes a modified buffer to the appropriate block on the disk</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 必须持有b的锁</span></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  <span class="comment">// 写入磁盘</span></span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="brelse"><a href="#brelse" class="headerlink" title="brelse"></a>brelse</h4><blockquote>
<p> A kernel thread must release a buffer by calling brelse when it is done with it.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    <span class="comment">// 移动到头结点和头结点的下一个结点之间的位置</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><h4 id="bget"><a href="#bget" class="headerlink" title="bget"></a>bget</h4><p>用于获取cache中是否存在block。如果不存在，则新申请一个buf，并把该buf以上锁状态返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="comment">// 这个循环条件很有意思，充分用到了双向链表的特性</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      <span class="comment">// 引用数增加</span></span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      <span class="comment">// 锁定</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="comment">// 从尾部开始遍历，确实就是最少使用的了</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="comment">// 如果该buf空闲</span></span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      <span class="comment">// 仅是新建了一个buf，还未从磁盘读取对应磁盘块的副本，因而设valid为0以供上层函数调用处理</span></span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      <span class="comment">// 锁定</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cache不够用了</span></span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Logging-layer"><a href="#Logging-layer" class="headerlink" title="Logging layer"></a>Logging layer</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>Xv6通过简单的日志记录形式解决了文件系统操作期间的崩溃问题。</p>
<p>xv6系统调用不会直接写入磁盘上的文件系统数据结构。相反，它会在磁盘上的<em>log</em>（日志）中放置它希望进行的所有磁盘写入的描述。一旦系统调用记录了它的所有写入操作，它就会向磁盘写入一条特殊的<em>commit</em>（提交）记录，表明日志包含一个完整的操作。此时，系统调用将写操作复制到磁盘上的文件系统数据结构。完成这些写入后，系统调用将擦除磁盘上的日志。</p>
</blockquote>
<blockquote>
<p>如果系统崩溃并重新启动，则在运行任何进程之前，文件系统代码将按如下方式从崩溃中恢复：</p>
<p>如果日志标记为包含完整操作，则恢复代码会将写操作复制到磁盘文件系统中它们所属的位置，然后擦除日志。如果日志没有标记为包含完整操作，则恢复代码将忽略该日志，然后擦除日志。</p>
</blockquote>
<p>这就保证了原子性。</p>
<h3 id="Log-design"><a href="#Log-design" class="headerlink" title="Log design"></a>Log design</h3><p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<p>superblock记录了log的存储位置。</p>
<blockquote>
<p>它由一个头块（header block）和一系列更新块的副本（logged block）组成。</p>
<p>头块包含一个扇区号（sector）数组（每个logged block对应一个扇区号）以及日志块的计数。</p>
<p>磁盘上的头块中的计数为零表示日志中没有事务，为非零表示日志包含一个完整的已提交事务，并具有指定数量的logged block。</p>
<p>在事务提交（commit）时Xv6才向头块写入数据，在此之前不会写入。在将logged blocks复制到文件系统后，头块的计数将被设置为零。</p>
<p>因此，事务中途崩溃将导致日志头块中的计数为零；提交后的崩溃将导致非零计数。</p>
</blockquote>
<blockquote>
<p>为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写入累积到一个事务中。因此，单个提交可能涉及多个完整系统调用的写入。为了避免在事务之间拆分系统调用，日志系统仅在没有文件系统调用进行时提交。</p>
<p>同时提交多个事务的想法称为组提交（group commit）。组提交减少了磁盘操作的数量，因为成本固定的一次提交分摊了多个操作。组提交还同时为磁盘系统提供更多并发写操作，可能允许磁盘在一个磁盘旋转时间内写入所有这些操作。Xv6的virtio驱动程序不支持这种批处理，但是Xv6的文件系统设计允许这样做。</p>
<p>【这感觉实现得也还挺简略的】</p>
</blockquote>
<blockquote>
<p>Xv6在磁盘上留出固定的空间来保存日志。事务中系统调用写入的块总数必须可容纳于该空间。这导致两个后果：</p>
<ol>
<li><p>任何单个系统调用都不允许写入超过日志空间的不同块。</p>
<p>【这段话我一个字没看懂】</p>
<p>这对于大多数系统调用来说都不是问题，但其中两个可能会写入许多块：<code>write</code>和<code>unlink</code>。一个大文件的<code>write</code>可以写入多个数据块和多个位图块以及一个inode块；<code>unlink</code>大文件可能会写入许多位图块和inode。Xv6的<code>write</code>系统调用将大的写入分解为适合日志的多个较小的写入，<code>unlink</code>不会导致此问题，因为实际上Xv6文件系统只使用一个位图块。</p>
</li>
<li><p>日志空间有限的另一个后果是，除非确定系统调用的写入将可容纳于日志中剩余的空间，否则日志系统无法允许启动系统调用。</p>
</li>
</ol>
</blockquote>
<h3 id="Code-logging"><a href="#Code-logging" class="headerlink" title="Code: logging"></a>Code: logging</h3><blockquote>
<p>log的原理是这样的：</p>
<p>在每个系统调用的开始调用<code>begin_op</code>表示事务开始，然后之后新申请一块block，也即把该block的内容读入内存，并且把该block的blockno记录到log的header中。此后程序正常修改在内存中的block，磁盘中的block保持不变。最后commit的时候遍历log header中的blockno，一块块地把内存中的block写入日志和磁盘中。</p>
<p>如果程序在commit前崩溃，则内存消失，同时磁盘也不会写入；如果在commit后崩溃，那也无事发生。</p>
<p>在每次启动的时候，都会执行log的初始化，届时可以顺便恢复数据。</p>
<p>完美实现了日志的功能。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230123212753931.png" alt="image-20230123212753931"></p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Contents of the header block, used for both the on-disk header block</span></span><br><span class="line"><span class="comment">// and to keep track in memory of logged block# before commit.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="comment">// 扇区号也即blockno的数组</span></span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表log磁盘块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> start;<span class="comment">// log磁盘块的开始。start开始的第一块为log header，之后皆为写入的block</span></span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// how many FS sys calls are executing.</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// in commit(), please wait.</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h4><h5 id="begin-op"><a href="#begin-op" class="headerlink" title="begin_op()"></a>begin_op()</h5><blockquote>
<p><code>begin_op</code>等待直到日志系统当前未处于提交中，并且直到有足够的未被占用的日志空间来保存此调用的写入。</p>
<p><code>log.outstanding</code>统计<strong>预定了日志空间</strong>的系统调用数；为此保留的总空间为<code>log.outstanding</code>乘以<code>MAXOPBLOCKS</code>（10）。递增<code>log.outstanding</code>会预定空间并防止在此系统调用期间发生提交（if的第二个分支）。代码保守地假设每个系统调用最多可以写入<code>MAXOPBLOCKS</code>（10）个不同的块。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// called at the start of each FS system call.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">begin_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 正在提交则等待日志空闲</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;</span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="comment">// 日志空间不足则等待空间充足</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">// this op might exhaust log space此操作可能会耗尽日志空间; wait for commit.</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="log-write"><a href="#log-write" class="headerlink" title="log_write"></a>log_write</h5><blockquote>
<p><code>log_write</code>充当<code>bwrite</code>的代理。它将块的扇区号记录在内存中，在磁盘上的日志中预定一个槽位，并调用<code>bpin</code>将缓存固定在block cache中，以防止block cache将其逐出【具体原理就是让refcnt++，这样就不会被当成空闲block用掉了】。</p>
<p>为啥要防止换出呢？换出不是就正好自动写入磁盘了吗？这里一是为了保障前面提到的原子性，防止换入换出导致的单一写入磁盘；二是换出自动写入的是磁盘对应位而不一定是日志所在的blocks。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">log_write</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log</span></span><br><span class="line">  <span class="comment">// 30</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="comment">// log_write会注意到在单个事务中多次写入一个块的情况，并在日志中为该块分配相同的槽位。</span></span><br><span class="line">  <span class="comment">// 这种优化通常称为合并（absorption）</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorbtion</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里还是挺巧妙的。</span></span><br><span class="line">  <span class="comment">// 如果存在log.lh.block[i] == b-&gt;blockno的情况，执行此句话也无妨</span></span><br><span class="line">  <span class="comment">// 如果不存在，则给log新增一块，填入log.lh.block[log.lh.n]的位置，再++log.lh.n</span></span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log?</span></span><br><span class="line">    bpin(b);</span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="end-op"><a href="#end-op" class="headerlink" title="end_op"></a>end_op</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// called at the end of each FS system call.</span></span><br><span class="line"><span class="comment">// 如果这是最后一层outstanding就会执行commit操作</span></span><br><span class="line"><span class="comment">// commits if this was the last outstanding operation.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// begin_op() may be waiting for log space,</span></span><br><span class="line">    <span class="comment">// and decrementing log.outstanding has decreased</span></span><br><span class="line">    <span class="comment">// the amount of reserved space.</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    <span class="comment">// call commit w/o holding locks, since not allowed</span></span><br><span class="line">    <span class="comment">// to sleep with locks.</span></span><br><span class="line">    commit();</span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// cache -&gt; log block</span></span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    <span class="comment">// head(in stack/heap) -&gt; log block</span></span><br><span class="line">    <span class="comment">// 此可以说为commit完成的标志。</span></span><br><span class="line">    <span class="comment">// 因为无论接下来是否崩溃，数据最终都会被写入disk，不同在于是在recover时还是接下来写入</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    <span class="comment">// log block -&gt; real position</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 擦除</span></span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="write-log"><a href="#write-log" class="headerlink" title="write_log"></a>write_log</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy modified blocks from cache to log.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">    brelse(from);<span class="comment">// 此处的brelse呼应了外界调用的bread</span></span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="write-head"><a href="#write-head" class="headerlink" title="write_head"></a>write_head</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write in-memory log header to disk.</span></span><br><span class="line"><span class="comment">// 这是事务提交的标志</span></span><br><span class="line"><span class="comment">// This is the true point at which the</span></span><br><span class="line"><span class="comment">// current transaction commits.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf);</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="install-trans"><a href="#install-trans" class="headerlink" title="install_trans"></a>install_trans</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy committed blocks from log to their home location</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">install_trans</span><span class="params">(<span class="type">int</span> recovering)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// read log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// read dst</span></span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="comment">// copy block to dst</span></span><br><span class="line">    bwrite(dbuf);  <span class="comment">// write dst to disk</span></span><br><span class="line">    <span class="keyword">if</span>(recovering == <span class="number">0</span>)</span><br><span class="line">      bunpin(dbuf);<span class="comment">// 如果不是在recover的过程中</span></span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="恢复与初始化"><a href="#恢复与初始化" class="headerlink" title="恢复与初始化"></a>恢复与初始化</h4><p>上面介绍了log的一次事务提交的流程。接下来介绍它是怎么恢复的。</p>
<blockquote>
<p><code>recover_from_log</code>是由<code>initlog</code>调用的，而它又是在第一个用户进程运行之前的引导期间由<code>fsinit</code>调用的。</p>
</blockquote>
<h5 id="第一个进程运行之前"><a href="#第一个进程运行之前" class="headerlink" title="第一个进程运行之前"></a>第一个进程运行之前</h5><p>由前面scheduler一章的知识可知，每个进程被初次调度的时候会先来执行<code>forkret</code>。这时候就做了log的恢复工作。</p>
<p>注释解释了为什么不选择在<code>main.c</code>中初始化，而选择在此处初始化。确实，它需要调用sleep，如果在main.c中调用sleep感觉会乱套（）毕竟那时候scheduler线程尚未被初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A fork child&#x27;s very first scheduling by scheduler()</span></span><br><span class="line"><span class="comment">// will swtch to forkret.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// static变量仅会被初始化一次</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Still holding p-&gt;lock from scheduler.</span></span><br><span class="line">  release(&amp;myproc()-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是第一个进程</span></span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    <span class="comment">// File system initialization must be run in the context of a</span></span><br><span class="line">    <span class="comment">// regular process (e.g., because it calls sleep), and thus cannot</span></span><br><span class="line">    <span class="comment">// be run from main().</span></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    fsinit(ROOTDEV);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fsinit"><a href="#fsinit" class="headerlink" title="fsinit"></a>fsinit</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Init fs</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fsinit</span><span class="params">(<span class="type">int</span> dev)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  initlog(dev, &amp;sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="initlog"><a href="#initlog" class="headerlink" title="initlog"></a>initlog</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlog</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> logheader) &gt;= BSIZE)</span><br><span class="line">    panic(<span class="string">&quot;initlog: too big logheader&quot;</span>);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;<span class="built_in">log</span>.lock, <span class="string">&quot;log&quot;</span>);</span><br><span class="line">  <span class="comment">// 从super block中获取必要参数</span></span><br><span class="line">  <span class="built_in">log</span>.start = sb-&gt;logstart;</span><br><span class="line">  <span class="built_in">log</span>.size = sb-&gt;nlog;</span><br><span class="line">  <span class="built_in">log</span>.dev = dev;</span><br><span class="line">  recover_from_log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="recover-from-log"><a href="#recover-from-log" class="headerlink" title="recover_from_log"></a>recover_from_log</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 读取head</span></span><br><span class="line">  read_head();</span><br><span class="line">  <span class="comment">// 注意，commit中会把header写入log block，而这里从log block读出header</span></span><br><span class="line">  <span class="comment">// 也就是说，如果header的n不为零，那么说明已经commit了，但可能未写入，重复写入保障安全</span></span><br><span class="line">  <span class="comment">// 如果header的n为零，说明未commit，在install_trans的逻辑中会什么也不做</span></span><br><span class="line">  <span class="comment">// 两种情况完美满足</span></span><br><span class="line">  install_trans(<span class="number">1</span>); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 擦除</span></span><br><span class="line">  write_head(); <span class="comment">// clear the log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Block-allocator"><a href="#Code-Block-allocator" class="headerlink" title="Code: Block allocator"></a>Code: Block allocator</h2><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>说实话没怎么懂，也不大清楚它有什么用，先大概推测一下：</p>
<p>之前的bread和bwrite这些，就是你给一个设备号和扇区号，它就帮你加载进内存cache。你如果要用的话，肯定还是使用地址方便。所以block allocator的作用之一就是给bread和bwrite加一层封装，将获取的block封装为地址返回，你可以直接操纵这个地址，<strong>而无需知道下层的细节。</strong></p>
<p>这个过程要注意的有两点：</p>
<ol>
<li><p>封装返回的地址具体是什么，怎么工作的</p>
<p>封装返回的地址实质上是buffer cache中的buf的data字段的地址【差不多】。之后的上层应用在该地址上写入，也即写入了buf，最后会通过log层真正写入磁盘。</p>
</li>
<li><p>结合bcache的LRU，详细谈谈工作机制</p>
<p>我们可以看到，在balloc中有这么一段逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> b + bi;</span><br></pre></td></tr></table></figure>

<p>看到的第一反应就是，我们需求的那块buf是bp，但是这里先是bread了一次，又是brelse了一次，这样bp的refcnt不就为0，很容易被替换掉了吗？</p>
<p>会有这个反应，一定程度上是因为没有很好地理解LRU。事实上，正是它可能被替换掉，才满足了LRU的条件。因为它可能被替掉才能说明它可能是最近最少使用的。</p>
</li>
</ol>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><blockquote>
<p>文件和目录内容存储在磁盘块中，磁盘块必须从空闲池中分配。xv6的块分配器在磁盘上维护一个空闲位图，每一位代表一个块。0表示对应的块是空闲的；1表示它正在使用中。</p>
<p>引导扇区、超级块、日志块、inode块和位图块的比特位是由程序<code>mkfs</code>初始化设置的：</p>
<p><img src="/2023/01/10/xv6/image-20230123234919055.png" alt="image-20230123234919055"></p>
</blockquote>
<h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3><p>类似于memory allocator，块分配器也提供了两个函数：<code>bfree</code>和<code>balloc</code>。</p>
<h4 id="balloc"><a href="#balloc" class="headerlink" title="balloc"></a>balloc</h4><blockquote>
<p><code>Balloc</code>从块0到<code>sb.size</code>（文件系统中的块数）遍历每个块。它查找位图中位为零的空闲块。如果<code>balloc</code>找到这样一个块，它将更新位图并返回该块。</p>
<p>为了提高效率，循环被分成两部分。外部循环读取位图中的每个块。内部循环检查单个位图块中的所有BPB位。由于任何一个位图块在buffer cache中一次只允许一个进程使用【<code> bread(dev, BBLOCK(b, sb))</code>会返回一个上锁的block，<code>bread</code>和<code>brelse</code>隐含的独占使用避免了显式锁定的需要】，因此，如果两个进程同时尝试分配一个块也是并发安全的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a zeroed disk block.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">balloc</span><span class="params">(uint dev)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> b, bi, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  bp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(b = <span class="number">0</span>; b &lt; sb.size; b += BPB)&#123;</span><br><span class="line">    bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">    <span class="keyword">for</span>(bi = <span class="number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;</span><br><span class="line">      m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)&#123;  <span class="comment">// Is block free?</span></span><br><span class="line">        bp-&gt;data[bi/<span class="number">8</span>] |= m;  <span class="comment">// Mark block in use.</span></span><br><span class="line">        log_write(bp);</span><br><span class="line">        brelse(bp);</span><br><span class="line">        bzero(dev, b + bi);</span><br><span class="line">        <span class="keyword">return</span> b + bi;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;balloc: out of blocks&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bfree"><a href="#bfree" class="headerlink" title="bfree"></a>bfree</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Free a disk block.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="type">int</span> bi, m;</span><br><span class="line"></span><br><span class="line">  bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">  bi = b % BPB;</span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">  bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Inode-layer"><a href="#Inode-layer" class="headerlink" title="Inode layer"></a>Inode layer</h2><h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><blockquote>
<p>术语inode（即索引结点）可以具有两种相关含义之一。它可能是指包含文件大小和数据块编号列表的磁盘上的数据结构【on-disk inode】。或者“inode”可能指内存中的inode【in-memory inode】，它包含磁盘上inode的副本以及内核中所需的额外信息。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<h4 id="on-disk-inode"><a href="#on-disk-inode" class="headerlink" title="on-disk inode"></a>on-disk inode</h4><blockquote>
<p>The on-disk inodes are packed into a contiguous area of disk called the inode blocks. </p>
<p>Every inode is the <strong>same size,</strong> so it is easy, given a number n, to find the nth inode on the disk. In fact, this number n, called the <strong>inode number</strong> or <strong>i-number</strong>, is how inodes are <strong>identifified</strong> in the implementation.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in fs.h</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 为0表示free</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="comment">//  The nlink field counts the number of directory entries that refer to this inode,</span></span><br><span class="line">  <span class="comment">//  in order to recognize when the on-disk inode and its data blocks should be freed.</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="in-memory-inode"><a href="#in-memory-inode" class="headerlink" title="in-memory inode"></a>in-memory inode</h4><blockquote>
<p>The kernel keeps the set of active inodes in memory.</p>
<p>The kernel stores an inode in memory <strong>only</strong> if there are C pointers referring to that inode.当且仅当ref==0才会从内核中释放。</p>
<p>如果nlinks==0就会从物理block中释放。</p>
<p>The <code>iget</code> and <code>iput</code> functions acquire and release pointers to an inode, modifying the reference count.【相当于buffer cache的<code>balloc</code>和<code>bfree</code>】Pointers to an inode can come from file descriptors, current working directories, and transient kernel code such as exec.</p>
<p><code>iget</code>返回的<code>struct inode</code>可能没有任何有用的内容。为了确保它保存磁盘inode的副本，代码必须调用<code>ilock</code>。这将锁定inode（以便没有其他进程可以对其进行<code>ilock</code>），并从磁盘读取尚未读取的inode。<code>iunlock</code>释放inode上的锁。将inode指针的获取与锁定分离有助于在某些情况下避免死锁，例如在目录查找期间。多个进程可以持有指向<code>iget</code>返回的inode的C指针，但一次只能有一个进程锁定inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];<span class="comment">// 存储着inode数据的blocks的地址，从balloc中获取</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Code-inode"><a href="#Code-inode" class="headerlink" title="Code: inode"></a>Code: inode</h3><blockquote>
<p>主要是在讲inode layer这一层的方法，以及给上层提供的接口。</p>
</blockquote>
<h4 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h4><p><img src="/2023/01/10/xv6/image-20230124153309132.png" alt="image-20230124153309132"></p>
<h4 id="底层接口"><a href="#底层接口" class="headerlink" title="底层接口"></a>底层接口</h4><blockquote>
<p><code>iget</code> <code>iput</code> </p>
</blockquote>
<h5 id="iget"><a href="#iget" class="headerlink" title="iget"></a>iget</h5><p>逻辑还是跟buffer cache非常相似的，不过可以看出这个的数据结构简单许多，也不用实现LRU。</p>
<blockquote>
<p>A struct inode pointer returned by iget() is <strong>guaranteed to be valid</strong> until the corresponding call to iput()： the inode <u>won’t be deleted</u>, and the memory referred to by the pointer <u>won’t be re-used</u> for a different inode. 【通过ref++实现。】</p>
<p>不同于buffer cache的<code>bget</code>，<code>iget()</code>提供对inode的非独占访问，因此可以有许多指向同一inode的指针。文件系统代码的许多部分都依赖于<code>iget()</code>的这种行为，既可以保存对inode的长期引用（如打开的文件和当前目录），也可以防止争用，同时避免操纵多个inode（如路径名查找）的代码产生死锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find the inode with number inum on device dev</span></span><br><span class="line"><span class="comment">// and return the in-memory copy. Does not lock</span></span><br><span class="line"><span class="comment">// the inode and does not read it from disk.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">iget</span><span class="params">(uint dev, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the inode already cached?</span></span><br><span class="line">  empty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ip = &amp;icache.inode[<span class="number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">      ip-&gt;ref++;</span><br><span class="line">      release(&amp;icache.lock);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于不用实现LRU，所以只需一次循环记录即可。</span></span><br><span class="line">    <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// Remember empty slot.</span></span><br><span class="line">      empty = ip;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recycle an inode cache entry.</span></span><br><span class="line">  <span class="keyword">if</span>(empty == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;iget: no inodes&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ip = empty;</span><br><span class="line">  ip-&gt;dev = dev;</span><br><span class="line">  ip-&gt;inum = inum;</span><br><span class="line">  ip-&gt;ref = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// does not read from disk</span></span><br><span class="line">  ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="iput"><a href="#iput" class="headerlink" title="iput"></a>iput</h5><blockquote>
<p><code>iput()</code>可以写入磁盘。这意味着任何使用文件系统的系统调用都可能写入磁盘，因为系统调用可能是最后一个引用该文件的系统调用。即使像<code>read()</code>这样看起来是只读的调用，也可能最终调用<code>iput()</code>。这反过来意味着，即使是只读系统调用，如果它们使用文件系统，也必须在事务中进行包装。</p>
<p><code>iput()</code>和崩溃之间存在一种具有挑战性的交互。<code>iput()</code>不会在文件的链接计数降至零时立即截断文件，因为某些进程可能仍在内存中保留对inode的引用：进程可能仍在读取和写入该文件，因为它已成功打开该文件。但是，如果在最后一个进程关闭该文件的文件描述符之前发生崩溃，则该文件将被标记为已在磁盘上分配，但没有目录项指向它。如果不做任何处理措施的话，这块磁盘就再也用不了了。</p>
<p>文件系统以两种方式之一处理这种情况。简单的解决方案用于恢复时：重新启动后，文件系统会扫描整个文件系统，以查找标记为已分配但没有指向它们的目录项的文件。如果存在任何此类文件，接下来可以将其释放。</p>
<p>第二种解决方案不需要扫描文件系统。在此解决方案中，文件系统在磁盘（例如在超级块中）上记录链接计数降至零但引用计数不为零的文件的i-number。如果文件系统在其引用计数达到0时删除该文件，则会通过从列表中删除该inode来更新磁盘列表。重新启动时，文件系统将释放列表中的所有文件。</p>
<p>Xv6没有实现这两种解决方案，这意味着inode可能被标记为已在磁盘上分配，即使它们不再使用。这意味着随着时间的推移，xv6可能会面临磁盘空间不足的风险。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Drop a reference to an in-memory inode.</span></span><br><span class="line"><span class="comment">// If that was the last reference, the inode cache entry can</span></span><br><span class="line"><span class="comment">// be recycled.【refvnt==0 可以回收】</span></span><br><span class="line"><span class="comment">// 注意这个回收过程无需特别处理，只需自然--refcnt就行，不用像buffer cache那么烦</span></span><br><span class="line"><span class="comment">// If that was the last reference and the inode has no links</span></span><br><span class="line"><span class="comment">// to it, free the inode (and its content) on disk.【nlinks==0 copy和本体都得扔掉】</span></span><br><span class="line"><span class="comment">// All calls to iput() must be inside a transaction in</span></span><br><span class="line"><span class="comment">// case it has to free the inode.任何需要iput的地方都需要包裹在事务内，因为它可能会释放inode</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;ref == <span class="number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// inode has no links and no other references: truncate and free.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ip-&gt;ref == 1 means no other process can have ip locked,</span></span><br><span class="line">    <span class="comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span></span><br><span class="line">    acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    release(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终调用bfree，会标记bitmap，完全释放block</span></span><br><span class="line">    itrunc(ip);</span><br><span class="line">    ip-&gt;type = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/*iupdate:</span></span><br><span class="line"><span class="comment">    // Copy a modified in-memory inode to disk.</span></span><br><span class="line"><span class="comment">    // Must be called after every change to an ip-&gt;xxx field</span></span><br><span class="line"><span class="comment">	// that lives on disk, since i-node cache is write-through.</span></span><br><span class="line"><span class="comment">	write-through:</span></span><br><span class="line"><span class="comment">	CPU向cache写入数据时，同时向memory(后端存储)也写一份，使cache和memory的数据保持一致。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 这里修改的type是dinode也有的字段，所以需要update一下。</span></span><br><span class="line">    <span class="comment">// 下面的valid是dinode没有的字段，所以随便改，无需update</span></span><br><span class="line">    iupdate(ip);</span><br><span class="line">    ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    releasesleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;icache.lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;ref--;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上层接口-1"><a href="#上层接口-1" class="headerlink" title="上层接口"></a>上层接口</h4><h5 id="获取和释放inode"><a href="#获取和释放inode" class="headerlink" title="获取和释放inode"></a>获取和释放inode</h5><h6 id="ialloc"><a href="#ialloc" class="headerlink" title="ialloc"></a>ialloc</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate an inode on device dev.</span></span><br><span class="line"><span class="comment">// Mark it as allocated by  giving it type type.</span></span><br><span class="line"><span class="comment">// Returns an unlocked but allocated and referenced inode.</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">ialloc</span><span class="params">(uint dev, <span class="type">short</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;</span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// a free inode通过type判断是否free</span></span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));<span class="comment">// zerod</span></span><br><span class="line">      dip-&gt;type = type;</span><br><span class="line">      log_write(bp);   <span class="comment">// mark it allocated on the disk</span></span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;ialloc: no inodes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="inode的锁保护"><a href="#inode的锁保护" class="headerlink" title="inode的锁保护"></a>inode的锁保护</h5><p>前面说到，inode的设计使得有多个指针同时指向一个inode成为了可能。因而，修改使用inode的时候就要对其进行独占访问。使用<code>ialloc</code>获取和用<code>ifree</code>释放的inode必须被保护在<code>ilock</code>和<code>iunlock</code>区域中。</p>
<h6 id="ilock"><a href="#ilock" class="headerlink" title="ilock"></a>ilock</h6><p><code>ilock</code>既可以实现对inode的独占访问，同时也可以给未初始化的inode进行初始化工作。</p>
<blockquote>
<p><code>iget</code>返回的<code>struct inode</code>可能没有任何有用的内容。为了确保它保存磁盘inode的副本，代码必须调用<code>ilock</code>。这将锁定inode（以便没有其他进程可以对其进行<code>ilock</code>），并从磁盘读取尚未读取的inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock the given inode and reads the inode from disk if necessary.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ilock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;ilock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 通过inode索引号和superblock算出扇区号</span></span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    <span class="comment">// 填充ip</span></span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">    ip-&gt;major = dip-&gt;major;</span><br><span class="line">    ip-&gt;minor = dip-&gt;minor;</span><br><span class="line">    ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="iunlock"><a href="#iunlock" class="headerlink" title="iunlock"></a>iunlock</h6><blockquote>
<p><code>iunlock</code>释放inode上的锁。</p>
<p>将inode指针的获取与锁定分离有助于在某些情况下避免死锁，例如在目录查找期间。多个进程可以持有指向<code>iget</code>返回的inode的C指针，但一次只能有一个进程锁定inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unlock the given inode.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iunlock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;iunlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Code-inode-content"><a href="#Code-inode-content" class="headerlink" title="Code: inode content"></a>Code: inode content</h3><h4 id="Overview-2"><a href="#Overview-2" class="headerlink" title="Overview"></a>Overview</h4><blockquote>
<p>主要讲的是inode本身存储数据的结构</p>
</blockquote>
<blockquote>
<p>磁盘上的inode结构体<code>struct dinode</code>包含一个<code>size</code>和一个块号数组（见图8.3），数组内罗列着存储着该inode数据的块号。</p>
<p>前面的<code>NDIRECT</code>个数据块被列在数组中的前<code>NDIRECT</code>个元素中；这些块称为直接块（direct blocks）。接下来的<code>NINDIRECT</code>个数据块不在inode中列出，而是在称为间接块（indirect block）的数据块中列出。<code>addrs</code>数组中的最后一个元素给出了间接块的地址。</p>
<p>因此，可以从inode中列出的块加载文件的前12 kB（<code>NDIRECT x BSIZE</code>）字节，而只有在查阅间接块后才能加载下一个256 kB（<code>NINDIRECT x BSIZE</code>）字节。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/10/xv6/image-20230124163025094.png" alt="image-20230124163025094"></p>
<h4 id="bmap"><a href="#bmap" class="headerlink" title="bmap"></a>bmap</h4><blockquote>
<p>函数<code>bmap</code>负责封装这个寻找数据块的过程，以便实现我们将很快看到的如<code>readi</code>和<code>writei</code>这样的更高级例程。</p>
<p><code>bmap(struct inode *ip, uint bn)</code>返回inode<code>ip</code>的第<code>bn</code>个数据块的磁盘块号。如果<code>ip</code>还没有这样的块，<code>bmap</code>会分配一个。</p>
<p><code>Bmap</code>使<code>readi</code>和<code>writei</code>很容易获取inode的数据。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inode content</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The content (data) associated with each inode is stored</span></span><br><span class="line"><span class="comment">// in blocks on the disk. The first NDIRECT block numbers</span></span><br><span class="line"><span class="comment">// are listed in ip-&gt;addrs[].  The next NINDIRECT blocks are</span></span><br><span class="line"><span class="comment">// listed in block ip-&gt;addrs[NDIRECT].</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip.</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果为direct block</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 如果为indirect block</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 如果没有，会分配一个</span></span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="itrunc"><a href="#itrunc" class="headerlink" title="itrunc"></a>itrunc</h4><blockquote>
<p><code>itrunc</code>释放文件的块，将inode的<code>size</code>重置为零。</p>
<p><code>Itrunc</code>首先释放直接块，然后释放间接块中列出的块，最后释放间接块本身。</p>
</blockquote>
<h4 id="readi"><a href="#readi" class="headerlink" title="readi"></a>readi</h4><blockquote>
<p><code>readi</code>和<code>writei</code>都是从检查<code>ip-&gt;type == T_DEV</code>开始的。这种情况处理的是数据不在文件系统中的特殊设备；我们将在文件描述符层返回到这种情况。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read data from inode.数据大小为n，从off开始，读到dst处</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="comment">// If user_dst==1, then dst is a user virtual address;</span></span><br><span class="line"><span class="comment">// otherwise, dst is a kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">readi</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; ip-&gt;size)</span><br><span class="line">    n = ip-&gt;size - off;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主循环处理文件的每个块，将数据从缓冲区复制到dst</span></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      tot = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="writei"><a href="#writei" class="headerlink" title="writei"></a>writei</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write data to inode.</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="comment">// If user_src==1, then src is a user virtual address;</span></span><br><span class="line"><span class="comment">// otherwise, src is a kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">writei</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_src, uint64 src, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// writei会自动增长文件，除非达到文件的最大大小</span></span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; MAXFILE*BSIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      n = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(off &gt; ip-&gt;size)</span><br><span class="line">      <span class="comment">// 说明扩大了文件大小，需要修改</span></span><br><span class="line">      ip-&gt;size = off;</span><br><span class="line">    <span class="comment">// write the i-node back to disk even if the size didn&#x27;t change</span></span><br><span class="line">    <span class="comment">// because the loop above might have called bmap() and added a new</span></span><br><span class="line">    <span class="comment">// block to ip-&gt;addrs[].</span></span><br><span class="line">    iupdate(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stati"><a href="#stati" class="headerlink" title="stati"></a>stati</h4><blockquote>
<p>函数<code>stati</code>将inode元数据复制到<code>stat</code>结构体中，该结构通过<code>stat</code>系统调用向用户程序公开。</p>
</blockquote>
<p>在<code>defs.h</code>中可看到inode结构体是private的，而stat是public的。</p>
<h2 id="Directory-layer"><a href="#Directory-layer" class="headerlink" title="Directory layer"></a>Directory layer</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>目录的内部实现很像文件。其inode的<code>type</code>为<code>T_DIR</code>，其数据是directory entries的集合。</p>
<p>每个entry都是一个<code>struct dirent</code>。</p>
</blockquote>
<p><strong>也就是说这一层其实本质上是一个大小一定的map</strong>，该map自身也存放在inode中，大小为inode的大小，每个表项entry<strong>映射了目录名和文件inode</strong>。所以接下来介绍的函数我们完全可以从hashmap增删改查的角度去理解。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;<span class="comment">// 如果为0，说明该entry free</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/10/xv6/image-20230124173241241.png" alt="image-20230124173241241"></p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><h4 id="dirlookup"><a href="#dirlookup" class="headerlink" title="dirlookup"></a>dirlookup</h4><blockquote>
<p>函数<code>dirlookup</code>在directory中搜索具有给定名称的entry。</p>
<p>它返回的指向enrty.inum相应的inode是非独占的【通过iget获取】，也即无锁状态。它还会把<code>*poff</code>设置为所需的entry的字节偏移量。</p>
<p>为什么要返回未锁定的inode？是因为调用者已锁定<code>dp</code>，因此，如果对<code>.</code>进行查找，则在返回之前尝试锁定inode将导致重新锁定<code>dp</code>并产生死锁【确实】(还有更复杂的死锁场景，涉及多个进程和<code>..</code>，父目录的别名。<code>.</code>不是唯一的问题。）</p>
<p>所以锁定交给caller来做。caller可以解锁<code>dp</code>，然后锁定该函数返回的<code>ip</code>，确保它一次只持有一个锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Look for a directory entry in a directory.</span></span><br><span class="line"><span class="comment">// If found, set *poff to byte offset of entry.</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">dirlookup</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint *poff)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint off, inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;type != T_DIR)</span><br><span class="line">    panic(<span class="string">&quot;dirlookup not DIR&quot;</span>);</span><br><span class="line">  <span class="comment">// new level of abstraction,可以把directory的inode看作一个表文件，每个表项都是一个entry</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="comment">// 从directory中获取entry，也即从inode中获取数据</span></span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlookup read&quot;</span>);</span><br><span class="line">    <span class="comment">// free</span></span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(namecmp(name, de.name) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// entry matches path element</span></span><br><span class="line">      <span class="keyword">if</span>(poff)</span><br><span class="line">        *poff = off;</span><br><span class="line">      inum = de.inum;</span><br><span class="line">      <span class="keyword">return</span> iget(dp-&gt;dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dirlink"><a href="#dirlink" class="headerlink" title="dirlink"></a>dirlink</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write a new directory entry (name, inum) into the directory dp.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dirlink</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that name is not present.</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Look for an empty dirent.</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlink read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没找到空闲的则调用writei自动增长inode，添加新表项</span></span><br><span class="line">  <span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">  de.inum = inum;</span><br><span class="line">  <span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">    panic(<span class="string">&quot;dirlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pathname-layer"><a href="#Pathname-layer" class="headerlink" title="Pathname layer"></a>Pathname layer</h2><blockquote>
<p>Path name lookup involves a succession of calls to dirlookup, one for each path component.</p>
</blockquote>
<h3 id="namei和nameiparent"><a href="#namei和nameiparent" class="headerlink" title="namei和nameiparent"></a>namei和nameiparent</h3><blockquote>
<p>Namei (kernel/fs.c:661) evaluates path and returns the corresponding inode.</p>
<p>函数<code>nameiparent</code>是一个变体：它在最后一个元素之前停止，返回父目录的inode并将最后一个元素复制到<code>name</code>中。两者都调用通用函数<code>namex</code>来完成实际工作。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">0</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">1</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="namex"><a href="#namex" class="headerlink" title="namex"></a>namex</h3><blockquote>
<p><code>Namex</code>首先决定路径解析的开始位置。</p>
<p>如果路径以“ / ”开始，则从根目录开始解析；否则，从当前目录开始。</p>
<p>然后，它使用<code>skipelem</code>依次考察路径的每个元素。循环的每次迭代都必须在当前索引结点<code>ip</code>中查找<code>name</code>。</p>
<p>迭代首先给<code>ip</code>上锁并检查它是否是一个目录。如果不是，则查找失败。</p>
<p>如果caller是<code>nameiparent</code>，并且这是最后一个路径元素，则根据<code>nameiparent</code>的定义，循环会提前停止；最后一个路径元素已经复制到<code>name</code>中【在上一轮循坏中做了这件事】，因此<code>namex</code>只需返回解锁的<code>ip</code>。</p>
<p>最后，循环将使用<code>dirlookup</code>查找路径元素，并通过设置<code>ip = next</code>为下一次迭代做准备。当循环用完路径元素时，它返回<code>ip</code>。</p>
<p>注：</p>
<ol>
<li>在每次迭代中锁定<code>ip</code>是必要的，不是因为<code>ip-&gt;type</code>可以被更改，而是因为在<code>ilock</code>运行之前，<code>ip-&gt;type</code>不能保证已从磁盘加载，所以得用到ilock保证一定会被加载的这个性质。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Look up and return the inode for a path name.</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes.</span></span><br><span class="line"><span class="comment">// Must be called inside a transaction since it calls iput().</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用skipelem依次考察路径的每个元素</span></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early.</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>namex</code>过程可能需要很长时间才能完成：它可能涉及多个磁盘操作来读取路径名中所遍历目录的索引节点和目录块（如果它们不在buffer cache中）。</p>
<p>Xv6 is carefully designed，如果一个内核线程对<code>namex</code>的调用在磁盘I/O上阻塞，另一个查找不同路径名的内核线程可以同时进行。<code>Namex</code> locks each directory in the path <strong>separately</strong> so that lookups in different directories can proceed in parallel.锁细粒度化</p>
<p>This concurrency introduces some challenges. For example, while one kernel thread is looking up a pathname another kernel thread may be changing the directory tree by unlinking a directory. A potential risk is that a lookup may be searching a directory that has been deleted by another kernel thread and its blocks have been re-used for another directory or file.一个潜在的风险是，查找可能正在搜索已被另一个内核线程删除且其块已被重新用于另一个目录或文件的目录。</p>
<p>Xv6避免了这种竞争，也就是说，你查到的inode保证暂时不会被释放，里面的内容还是真的，而不会被重新利用从而导致里面的内容变样。</p>
<p>例如，在<code>namex</code>中执行<code>dirlookup</code>时，lookup线程持有目录上的锁，<code>dirlookup</code>返回使用<code>iget</code>获得的inode。<code>Iget</code>增加索引节点的引用计数。只有在从<code>dirlookup</code>接收inode之后，<code>namex</code>才会释放目录上的锁。现在，另一个线程可以从目录中取消inode的链接，但是xv6还不会删除inode，<u>因为inode的引用计数仍然大于零</u>。</p>
<p>另一个风险是死锁。例如，查找“<code>.</code>”时，<code>next</code>指向与<code>ip</code>相同的inode【确实】。在释放<code>ip</code>上的锁之前锁定<code>next</code>将导致死锁【为什么？？？难道不是会由于在acquire时已经持有锁，从而爆<code>panic(&quot;acquire&quot;)</code>吗？】。为了避免这种死锁，<code>namex</code>在获得下一个目录的锁之前解锁该目录。这里我们再次看到为什么<code>iget</code>和<code>ilock</code>之间的分离很重要。</p>
</blockquote>
<h2 id="File-descriptor-layer"><a href="#File-descriptor-layer" class="headerlink" title="File descriptor layer"></a>File descriptor layer</h2><blockquote>
<p>Unix的一个很酷的方面是，Unix中的大多数资源都表示为文件，包括控制台、管道等设备，当然还有真实文件。文件描述符层是实现这种一致性的层。</p>
</blockquote>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>Xv6为每个进程提供了自己的打开文件表或文件描述符。每个打开的文件都由一个<code>struct file</code>表示，它是inode或管道的封装，加上一个I/O偏移量。</p>
<p>每次调用<code>open</code>都会创建一个新的打开文件（一个新的<code>struct file</code>）：如果多个进程独立地打开同一个文件，那么不同的实例将具有不同的I/O偏移量。</p>
<p>另一方面，单个打开的文件（同一个<code>struct file</code>）可以多次出现在一个进程的文件表中，也可以出现在多个进程的文件表中。如果一个进程使用<code>open</code>打开文件，然后使用<code>dup</code>创建别名，或使用<code>fork</code>与子进程共享，就会发生这种情况。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;</span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ftable"><a href="#ftable" class="headerlink" title="ftable"></a>ftable</h3><blockquote>
<p>所有在系统中打开的文件都会被放入global file table<code>ftable</code>中。</p>
<p><code>ftable</code>具有分配文件（<code>filealloc</code>）、创建重复引用（<code>filedup</code>）、释放引用（<code>fileclose</code>）以及读取和写入数据（<code>fileread</code>和<code>filewrite</code>）的函数。</p>
<p>前三个都很常规，跟之前的xxalloc、xxfree的思路是一样的。</p>
<p>函数<code>filestat</code>、<code>fileread</code>和<code>filewrite</code>实现对文件的<code>stat</code>、<code>read</code>和<code>write</code>操作。</p>
</blockquote>
<h4 id="filealloc"><a href="#filealloc" class="headerlink" title="filealloc"></a>filealloc</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filealloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">      f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">      release(&amp;ftable.lock);</span><br><span class="line">      <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="filedup"><a href="#filedup" class="headerlink" title="filedup"></a>filedup</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Increment ref count for file f.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filedup</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;filedup&quot;</span>);</span><br><span class="line">  f-&gt;ref++;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fileclose"><a href="#fileclose" class="headerlink" title="fileclose"></a>fileclose</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;fileclose&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ff = *f;</span><br><span class="line">  f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">  f-&gt;type = FD_NONE;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line">    pipeclose(ff.pipe, ff.writable);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line">    begin_op();</span><br><span class="line">    iput(ff.ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="filestat"><a href="#filestat" class="headerlink" title="filestat"></a>filestat</h4><blockquote>
<p>Filestat只允许在inode上操作并且调用了<code>stati</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅允许文件/设备执行</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fileread"><a href="#fileread" class="headerlink" title="fileread"></a>fileread</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read from file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 首先检查是否可读</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>((r = readi(f-&gt;ip, <span class="number">1</span>, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 移动文件指针偏移量</span></span><br><span class="line">      f-&gt;off += r;</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    panic(<span class="string">&quot;fileread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-System-calls"><a href="#Code-System-calls" class="headerlink" title="Code: System calls"></a>Code: System calls</h2><blockquote>
<p>通过使用底层提供的函数，大多数系统调用的实现都很简单（请参阅***kernel/sysfile.c***）。有几个调用值得仔细看看。</p>
<p>以下介绍的函数都在<code>kernel/sysfile.c</code>中。</p>
</blockquote>
<h3 id="sys-link"><a href="#sys-link" class="headerlink" title="sys_link"></a>sys_link</h3><p>这个函数的功能是给文件old加上一个链接，这个链接存在于文件new的父目录。感觉也就相当于把文件从old复制到new处了。具体实现逻辑就是要给该文件所在目录添加一个entry，name=新名字，inode=该文件的inode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the path new as a link to the same inode as old.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>, *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, old, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, new, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先先增加nlink</span></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">// 通过path找到ip结点</span></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(old)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="comment">// directory不能被link</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DIR)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;nlink++;</span><br><span class="line">  <span class="comment">// 修改一次字段就需要update一次</span></span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后再在目录中登记新的entry</span></span><br><span class="line">  <span class="comment">// 找到new的parent，也即new所在目录</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(new, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  ilock(dp);</span><br><span class="line">  <span class="comment">// 在目录中添加一个entry，名字为给定的新名字，inode依旧为原来的inode</span></span><br><span class="line">  <span class="comment">// new的父目录必须存在并且与现有inode位于同一设备上</span></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  iput(ip);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;nlink--;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><blockquote>
<p>它是三个文件创建系统调用的泛化：带有<code>O_CREATE</code>标志的<code>open</code>生成一个新的普通文件，<code>mkdir</code>生成一个新目录，<code>mkdev</code>生成一个新的设备文件。</p>
</blockquote>
<p>创建一个新的inode结点，结点名包含在<code>path</code>内。返回一个<strong>锁定的</strong>inode。</p>
<p>由于使用了<code>iupdate</code>等，所以该函数只能在事务中被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">create</span><span class="params">(<span class="type">char</span> *path, <span class="type">short</span> type, <span class="type">short</span> major, <span class="type">short</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">dp</span>;</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取结点父目录</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(path, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ilock(dp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 说明文件已存在</span></span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))</span><br><span class="line">      <span class="comment">// 说明此时caller为open（type == T_FILE），open调用create只能是用于创建文件</span></span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;create: ialloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;major = major;</span><br><span class="line">  ip-&gt;minor = minor;</span><br><span class="line">  ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type == T_DIR)&#123;  <span class="comment">// Create . and .. entries.</span></span><br><span class="line">    dp-&gt;nlink++;  <span class="comment">// for &quot;..&quot;</span></span><br><span class="line">    iupdate(dp);</span><br><span class="line">    <span class="comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span></span><br><span class="line">    <span class="comment">// 所以其实.和..本质上是link</span></span><br><span class="line">    <span class="keyword">if</span>(dirlink(ip, <span class="string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="number">0</span> || dirlink(ip, <span class="string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;create dots&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;create: dirlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">  iunlockput(dp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-mkdir"><a href="#sys-mkdir" class="headerlink" title="sys_mkdir"></a>sys_mkdir</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, path, MAXPATH) &lt; <span class="number">0</span> || (ip = create(path, T_DIR, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-open"><a href="#sys-open" class="headerlink" title="sys_open"></a>sys_open</h3><blockquote>
<p><code>Sys_open</code>是最复杂的，因为创建一个新文件只是它能做的一小部分。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> fd, omode;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;omode) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建失败</span></span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 文件不存在</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create返回一个锁定的inode，但namei不锁定，因此sys_open必须锁定inode本身。</span></span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="comment">// 非文件，为目录并且非只读</span></span><br><span class="line">    <span class="comment">// 所以说想要open一个目录的话只能以只读模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取file结构体和文件描述符。</span></span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">      fileclose(f);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有其他进程可以访问部分初始化的文件，因为它仅位于当前进程的表中，因而这里可以不用上锁</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class="line">    f-&gt;type = FD_DEVICE;</span><br><span class="line">    f-&gt;major = ip-&gt;major;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    f-&gt;type = FD_INODE;</span><br><span class="line">    f-&gt;off = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;ip = ip;</span><br><span class="line">  f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class="line">  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果使用了这个标志,调用 open 函数打开文件的时候会将文件原本的内容全部丢弃,文件大小变为 0。</span></span><br><span class="line">  <span class="keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;</span><br><span class="line">    itrunc(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-pipe"><a href="#sys-pipe" class="headerlink" title="sys_pipe"></a>sys_pipe</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fdarray; <span class="comment">// user pointer to array of two integers用来接收pipe两端的文件描述符</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">rf</span>, *<span class="title">wf</span>;</span></span><br><span class="line">  <span class="type">int</span> fd0, fd1;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;fdarray) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(pipealloc(&amp;rf, &amp;wf) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  fd0 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>((fd0 = fdalloc(rf)) &lt; <span class="number">0</span> || (fd1 = fdalloc(wf)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd0 &gt;= <span class="number">0</span>)</span><br><span class="line">      p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line">    fileclose(rf);</span><br><span class="line">    fileclose(wf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, fdarray, (<span class="type">char</span>*)&amp;fd0, <span class="keyword">sizeof</span>(fd0)) &lt; <span class="number">0</span> ||</span><br><span class="line">     copyout(p-&gt;pagetable, fdarray+<span class="keyword">sizeof</span>(fd0), (<span class="type">char</span> *)&amp;fd1, <span class="keyword">sizeof</span>(fd1)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line">    p-&gt;ofile[fd1] = <span class="number">0</span>;</span><br><span class="line">    fileclose(rf);</span><br><span class="line">    fileclose(wf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>实际操作系统中的buffer cache比xv6复杂得多，但它有两个相同的用途：缓存和同步对磁盘的访问。</p>
<p>与UNIX V6一样，Xv6的buffer cache使用简单的最近最少使用（LRU）替换策略；有许多更复杂的策略可以实现，每种策略都适用于某些工作场景，而不适用于其他工作场景。更高效的LRU缓存将消除链表，而改为使用哈希表进行查找，并使用堆进行LRU替换【跟我们在lock中实现的一样，再多个堆优化】。现代buffer cache通常与虚拟内存系统集成，以支持内存映射文件。</p>
<p>Xv6的日志系统效率低下。提交不能与文件系统调用同时发生。系统记录整个块，即使一个块中只有几个字节被更改。它执行同步日志写入，每次写入一个块，每个块可能需要整个磁盘旋转时间。真正的日志系统解决了所有这些问题。</p>
<p>文件系统布局中最低效的部分是目录，它要求在每次查找期间对所有磁盘块进行线性扫描【确实】。当目录只有几个磁盘块时，这是合理的，但对于包含许多文件的目录来说，开销巨大。Microsoft Windows的NTFS、Mac OS X的HFS和Solaris的ZFS（仅举几例）将目录实现为磁盘上块的平衡树。这很复杂，但可以保证目录查找在对数时间内完成（即时间复杂度为O(logn)）。</p>
<p>Xv6对于磁盘故障的解决很初级：如果磁盘操作失败，Xv6就会调用<code>panic</code>。这是否合理取决于硬件：如果操作系统位于使用冗余屏蔽磁盘故障的特殊硬件之上，那么操作系统可能很少看到故障，因此<code>panic</code>是可以的。另一方面，使用普通磁盘的操作系统应该预料到会出现故障，并能更优雅地处理它们，这样一个文件中的块丢失不会影响文件系统其余部分的使用。</p>
<p>Xv6要求文件系统安装在单个磁盘设备上，且大小不变。随着大型数据库和多媒体文件对存储的要求越来越高，操作系统正在开发各种方法来消除“每个文件系统一个磁盘”的瓶颈。基本方法是将<strong>多个物理磁盘组合成一个逻辑磁盘</strong>。RAID等硬件解决方案仍然是最流行的，但当前的趋势是在软件中尽可能多地实现这种逻辑。这些软件实现通常<strong>允许通过动态添加或删除磁盘来扩展或缩小逻辑设备</strong>等丰富功能。当然，一个能够动态增长或收缩的存储层需要一个能够做到这一点的文件系统：xv6使用的固定大小的inode块阵列在这样的环境中无法正常工作。<strong>将磁盘管理与文件系统分离可能是最干净的设计</strong>，但两者之间复杂的接口导致了一些系统（如Sun的ZFS）将它们结合起来。</p>
<p>Xv6的文件系统缺少现代文件系统的许多其他功能；例如，它缺乏对快照和增量备份的支持。</p>
<p>现代Unix系统允许使用与磁盘存储相同的系统调用访问多种资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口，如<code>/proc</code>。不同于xv6中<code>fileread</code>和<code>filewrite</code>的<code>if</code>语句，这些系统通常为每个打开的文件提供一个<strong>函数指针表</strong>【确实有印象】，每个操作一个，并通过函数指针来援引inode的调用实现。网络文件系统和用户级文件系统提供了将这些调用转换为网络RPC并在返回之前等待响应的函数。</p>
<p>（注：Linux 内核提供了一种通过<code>/proc</code>文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。）</p>
</blockquote>
<h2 id="Lab-file-system"><a href="#Lab-file-system" class="headerlink" title="Lab: file system"></a>Lab: file system</h2><blockquote>
<p>In this lab you will add large files【大文件支持】 and symbolic links【软链接】 to the xv6 file system.</p>
<p>不过做完这个实验，给我的一种感觉就是磁盘管理和内存管理真的有很多相似之处，不过也许它们所代表的思想也很普遍。</p>
</blockquote>
<h3 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h3><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><h5 id="Overview-3"><a href="#Overview-3" class="headerlink" title="Overview"></a>Overview</h5><blockquote>
<p>In this assignment you’ll increase the maximum size of an xv6 file. </p>
<p>Currently xv6 files are limited to 268 blocks, or 268*BSIZE bytes (BSIZE is 1024 in xv6). This limit comes from the fact that an xv6 inode contains 12 “direct” block numbers and one “singly-indirect” block number, which refers to a block that holds up to 256 more block numbers, for a total of 12+256=268 blocks.</p>
<p>You’ll change the xv6 file system code to support a <strong>“doubly-indirect” block</strong> in each inode, containing 256 addresses of singly-indirect blocks, each of which can contain up to 256 addresses of data blocks. The result will be that a file will be able to consist of up to 65803 blocks, or 256*256+256+11 blocks (11 instead of 12, because <strong>we will sacrifice one of the direct block numbers for the double-indirect block</strong>).</p>
</blockquote>
<h5 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h5><blockquote>
<p>If at any point during the lab you find yourself having to rebuild the file system from scratch, you can run <code>make clean</code> which forces make to rebuild fs.img.</p>
</blockquote>
<h5 id="What-to-Look-At"><a href="#What-to-Look-At" class="headerlink" title="What to Look At"></a>What to Look At</h5><p>意思就是要我们去看一眼fs.h，bmap，以及了解一下逻辑地址bn如何转化为blockno。这个我是知道的。</p>
<h5 id="Your-Job"><a href="#Your-Job" class="headerlink" title="Your Job"></a>Your Job</h5><blockquote>
<p>Modify <code>bmap()</code> so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. </p>
<p>You’ll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you’re not allowed to change the size of an on-disk inode. </p>
<p>The first 11 elements of <code>ip-&gt;addrs[]</code> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when <code>bigfile</code> writes 65803 blocks and <code>usertests</code> runs successfully.</p>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>意外地很简单（）在此不多做赘述，直接上代码。</p>
<p>唯一要注意的一点就是记得在<code>itrunc</code>中free掉</p>
<p><img src="/2023/01/10/xv6/image-20230124232433793.png" alt="image-20230124232433793"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="修改定义"><a href="#修改定义" class="headerlink" title="修改定义"></a>修改定义</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in fs.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDOUBLEINDIRECT ((BSIZE/sizeof(uint))*(BSIZE/sizeof(uint)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NDOUBLEINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="修改bmap"><a href="#修改bmap" class="headerlink" title="修改bmap()"></a>修改bmap()</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in fs.c</span></span><br><span class="line"><span class="comment">// 调试用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// CODE HERE</span></span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDOUBLEINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// 调试用</span></span><br><span class="line">    <span class="keyword">if</span>(bn/<span class="number">10000</span> &gt; cnt)&#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;double_indirect:%d\n&quot;</span>,bn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一层</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="comment">// 第二层</span></span><br><span class="line">    bp = bread(ip-&gt;dev,addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[(bn &gt;&gt; <span class="number">8</span>)]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[(bn &gt;&gt; <span class="number">8</span>)] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="comment">// 第三层</span></span><br><span class="line">    bp = bread(ip-&gt;dev,addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[(bn &amp; <span class="number">0x00FF</span>)]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[(bn &amp; <span class="number">0x00FF</span>)] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改itrunc"><a href="#修改itrunc" class="headerlink" title="修改itrunc"></a>修改itrunc</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents).</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CODE HERE</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="number">1</span>])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="comment">// 双层循环。这里其实不应该用NINDIRECT这个宏定义的，因为意义其实不大一样。</span></span><br><span class="line">    <span class="comment">// 但是由于数值一样，这里就先凑合着用了</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">tmp_bp</span> =</span> bread(ip-&gt;dev,a[j]);</span><br><span class="line">        uint* tmp_a = (uint*)tmp_bp-&gt;data;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; NINDIRECT; k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(tmp_a[k])</span><br><span class="line">            bfree(ip-&gt;dev,tmp_a[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(tmp_bp);</span><br><span class="line">        bfree(ip-&gt;dev,a[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h3><blockquote>
<p>In this exercise you will add symbolic links to xv6. </p>
<p>Symbolic links (or <strong>soft links</strong>) refer to a linked file by pathname; when a symbolic link is opened, the kernel follows the link to the referred file. </p>
<p>Symbolic links resembles hard links, <u>but hard links are restricted to pointing to file on the same disk</u>, while symbolic links can cross disk devices. </p>
<p>Although xv6 doesn’t support multiple devices, implementing this system call is a good exercise to understand how pathname lookup works.</p>
<p>You will implement the <code>symlink(char *target, char *path)</code> system call, which creates a new symbolic link at path that refers to file named by target. For further information, see the man page symlink. To test, add symlinktest to the Makefile and run it. </p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_40179091/article/details/125306898">linux：硬链接和软链接</a></p>
<p>硬链接不会创建新的物理文件，但是会使得当前物理文件的引用数加1。当硬链接产生的文件存在时，删除源文件，不会清除实际的物理文件，即对于硬链接“生成的新文件”不会产生任何影响。</p>
<p>软链接就更像一个指针，只是指向实际物理文件位置，当源文件移动或者删除时，软链接就会失效。</p>
<p>【所以说，意思就是软链接不会让inode-&gt;ulinks++的意思？】</p>
</blockquote>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><p>这个实验比上个实验稍难一些，但也确实只是moderate的水平，其复杂程度主要来源于对文件系统的理解，还有如何判断环，以及对锁的获取和释放的应用。我做这个实验居然是没看提示的【非常骄傲&lt;-】，让我有一种自己水平上升了的感觉hhh</p>
<h5 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h5><p>本实验要求实现软链接。首先需要实现创建软链接：写一个系统调用 <code>symlink(char *target, char *path)</code> 用于创建一个指向target的在path的软链接；然后需要实现打开软链接进行自动的跳转：在<code>sys_open</code>中添加对文件类型为软链接的特殊处理。</p>
<h5 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h5><p>我的初见思路是觉得可以完全参照<code>sys_link</code>来写。但其实还是很不一样的。</p>
<p><code>sys_link</code>的逻辑：</p>
<ol>
<li>获取old的inode</li>
<li>获取new所在目录的inode，称为dp</li>
<li>在dp中添加一项entry指向old</li>
</ol>
<p><code>sys_symlink</code>的逻辑：</p>
<ol>
<li><p>通过path创建一个新的inode，作为软链接的文件</p>
<p>这里选择新建inode，而不是像link那样做，主要还是为了能遵从<code>symlinktest</code>给的接口使用方法（朴实无华的理由）。而且这么做也很方便，符合“一切皆文件”的思想，也能简单化对其在<code>open</code>中的处理。</p>
</li>
<li><p>在inode中填入target的地址</p>
<p>我们可以把软链接视为文件，文件内容是其target的path。</p>
</li>
</ol>
<p>可以说是毫不相干，所以还是直接自起炉灶比较好。</p>
<h5 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h5><p>其实没什么好说的，虽然debug过程挺久，但是靠常规的printf追踪就都可以看出来是哪里错了。下面我说说一个我印象比较深刻的吧。</p>
<p><code>symlinktest</code>中有一个检测点是，软链接不能成环，也即b-&gt;a-&gt;b是非法的。于是，我就选择了用快慢指针来检测环形链表这个思想，用来看是否出现环。</p>
<p>在<code>symlinktest</code>的另一个检测点中：</p>
<p><img src="/2023/01/10/xv6/image-20230125173143735.png" alt="image-20230125173143735"></p>
<p>我出现了如下错误：</p>
<p><img src="/2023/01/10/xv6/image-20230125162542807.png" alt="image-20230125162542807"></p>
<p>此时的结构是1[27]-&gt;2[28]-&gt;3[29]-&gt;4，[]内为inode的inum。</p>
<p>快慢指针的实现方式是当cnt为奇数的时候，慢指针才会移动。而上图中，cnt==0时，两个指针的值都发生了变化，这就非常诡异。</p>
<p>这其实是因为slow指针所指向的那个inode被释放了，然后又被fast指针的下一个inode捡过来用了，从而导致值覆盖。</p>
<p>为什么会被释放呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="comment">// 快指针移动</span></span><br><span class="line">      readi(ip,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 在这里！！！</span></span><br><span class="line">      ilockput(ip);</span><br></pre></td></tr></table></figure>

<p>在这里，我错误地调用了<code>ilockput</code>，从而使inode的ref–，使得它在下一次fast指针调用<code>namei</code>，<code>namei</code>调用<code>iget</code>时，该inode被当做free inode使用，于是就这么寄了。</p>
<p>所以我们需要把<code>ilockput</code>的调用换成<code>ilock</code>，这样一来就能防止inode被free。至于什么时候再iput？我想还是交给操作系统启动时的清理工作来做吧23333【开摆】</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p><img src="/2023/01/10/xv6/image-20230125165612112.png" alt="image-20230125165612112"></p>
<h5 id="添加定义"><a href="#添加定义" class="headerlink" title="添加定义"></a>添加定义</h5><h6 id="fcntl-c"><a href="#fcntl-c" class="headerlink" title="fcntl.c"></a>fcntl.c</h6><p>open参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 意为只用获取软链接文件本身，而不用顺着软链接去找它的target文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_NOFOLLOW 0x100</span></span><br></pre></td></tr></table></figure>

<h6 id="stat-h"><a href="#stat-h" class="headerlink" title="stat.h"></a>stat.h</h6><p>文件类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYMLINK  4   <span class="comment">// symbol links</span></span></span><br></pre></td></tr></table></figure>

<h5 id="添加sys-symlink系统调用"><a href="#添加sys-symlink系统调用" class="headerlink" title="添加sys_symlink系统调用"></a>添加sys_symlink系统调用</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in sysfile.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建软链接结点</span></span><br><span class="line">  ip = create(path,T_SYMLINK,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//printf(&quot;symlink:before writei,inum = %d\n&quot;,ip-&gt;inum);</span></span><br><span class="line">  <span class="comment">// 此处可以防止住一些并发错误</span></span><br><span class="line">  <span class="keyword">if</span>(ip ==<span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向软链接结点文件内写入其所指向的路径</span></span><br><span class="line">  writei(ip,<span class="number">0</span>,(uint64)target,<span class="number">0</span>,MAXPATH);</span><br><span class="line">  <span class="comment">//printf(&quot;symlink:after writei\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 软链接不需要让nlink++</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 记得要释放在create()中申请的锁</span></span><br><span class="line">  iunlockput(ip);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改open"><a href="#修改open" class="headerlink" title="修改open"></a>修改open</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 软链接不可能是以O_CREATE的形式创建的</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改从这里开始</span></span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="comment">// ip为快指针，slow为慢指针</span></span><br><span class="line">    uint cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">slow</span> =</span> ip;</span><br><span class="line">    <span class="comment">// 可能有多重链接，因而需要持续跳转</span></span><br><span class="line">    <span class="keyword">while</span>(ip-&gt;type == T_SYMLINK)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;slow = %d,fast = %d,cnt = %d\n&quot;,slow-&gt;inum,ip-&gt;inum,cnt);</span></span><br><span class="line">      <span class="comment">// 其实这个只需要检测一次就够了。但为了编码方便，仍然把它保留在while循环中</span></span><br><span class="line">      <span class="keyword">if</span>(omode &amp; O_NOFOLLOW)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 检测到cycle</span></span><br><span class="line">        <span class="keyword">if</span>(slow == ip &amp;&amp; cnt!=<span class="number">0</span>)&#123;</span><br><span class="line">          iunlockput(ip);</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快指针移动</span></span><br><span class="line">        readi(ip,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">        <span class="comment">// 此处不能用iunlockput()，具体原因见 感想-一些错误</span></span><br><span class="line">        iunlock(ip);</span><br><span class="line">        <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ilock(ip);</span><br><span class="line">        <span class="comment">// 慢指针移动</span></span><br><span class="line">        <span class="comment">// 注意，我慢指针移动的时候没有锁保护，因为用锁太麻烦了（）其实还是用锁比较合适</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="comment">//printf(&quot;%d\n&quot;,cnt);</span></span><br><span class="line">          readi(slow,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">          <span class="keyword">if</span>((slow = namei(path) )== <span class="number">0</span>)&#123;</span><br><span class="line">            end_op();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当跳出循环时，此时的ip必定是锁住的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab-mmap"><a href="#Lab-mmap" class="headerlink" title="Lab mmap"></a>Lab mmap</h2><blockquote>
<p>The <code>mmap</code> and <code>munmap</code> system calls allow UNIX programs to exert detailed control over their address spaces. </p>
<p>They can be used to:</p>
<ol>
<li>share memory among processes</li>
<li>map files into process address spaces</li>
<li>as part of user-level page fault schemes such as the garbage-collection algorithms discussed in lecture. </li>
</ol>
<p>In this lab you’ll add <code>mmap</code> and <code>munmap</code> to xv6, <strong>focusing on memory-mapped files</strong>.</p>
<p>mmap是系统调用，在用户态被使用。我们这次实验仅实现mmap功能的子集，也即memory-mapped files。</p>
</blockquote>
<blockquote>
<p>declaration for <code>mmap</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">     <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>参数</p>
<ol>
<li><p><code>addr</code> is always zero.</p>
<p>You can assume that <code>addr</code> will always be zero, meaning that the kernel should decide the <strong>virtual address</strong> at which to map the file.【<code>addr</code>由kernel决定，因而用户态只需传入0即可】</p>
</li>
<li><p><code>length</code> is the number of bytes to map</p>
<p>Might not be the same as the file’s length.</p>
</li>
<li><p><code>prot</code> indicates whether the memory should be mapped readable, writeable, and/or executable.</p>
<p>you can assume that <code>prot</code> is <code>PROT_READ</code> or <code>PROT_WRITE</code> or both. </p>
</li>
<li><p><code>flags</code> has two values.</p>
<ol>
<li><p><code>MAP_SHARED</code></p>
<p>meaning that modifications to the mapped memory <strong>should be written back to the file</strong>, </p>
<p>如果标记为此，则当且仅当file本身权限为RW或者WRITABLE的时候，prot才可以标记为PROT_WRITE</p>
</li>
<li><p><code>MAP_PRIVATE</code></p>
<p>meaning that they should not. </p>
<p>如果标记为此，则无论file本身权限如何，prot都可以标记为PROT_WRITE</p>
</li>
</ol>
</li>
<li><p>You can assume <code>offset</code> is zero (it’s the starting point in the file at which to map)</p>
</li>
</ol>
</li>
<li><p>return</p>
<p><code>mmap</code> returns that kernel-decided address, or 0xffffffffffffffff if it fails.</p>
</li>
</ol>
<p>如果两个进程同时对某个文件进行memory map，那么这两个进程可以不共享物理页面。</p>
</blockquote>
<blockquote>
<p><code>munmap(addr, length)</code> should remove mmap mappings in the indicated address range. </p>
<p>If the process has modified the memory and has it mapped <code>MAP_SHARED</code>, <strong>the modifications should first be written to the file</strong>. 【如果两个进程的修改发生冲突了怎么办？】</p>
<p>An <code>munmap</code> call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region).</p>
</blockquote>
<h3 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h3><p>这个实验做得我……怎么说，感觉非常地难受吧。虽然我认为我这次做得挺不错的，因为我没有怎么看hints，我的代码差不多全都是我自己想出来的，没有依赖保姆级教学，我认为是一个很好的进步。不过，正因为我没有看hints，导致我的想法比起答案来思路非常地奇诡，导致我第一次错误想法写了一天，看了hints后决心痛改前非，结果第二次错误想法又写了一天emmm</p>
<p>下面的第一个代码版本虽然可以过掉mmaptest，但<strong>确实还是有一个很致命的bug</strong>，并且<strong>lazy也没有lazy到位</strong>，最后的版本离正确思路还有偏差，<strong>也就是下面放的第一个代码版本是错误的，</strong>但我认为它也不是完全没有亮点。第二个版本才是经过改正的正确版本，但写得着实有点潦草。</p>
<p>笔记整理得也有点匆忙，毕竟我真的话比较多而且心里很烦。总之，先记录我的全部思路过程，至于价值如何，先不管了2333</p>
<h4 id="初见思路-1"><a href="#初见思路-1" class="headerlink" title="初见思路"></a>初见思路</h4><p>所以说，我们要做的，就是实现一个系统调用mmap，在mmap中，应该首先申请几页用来放file的内容，并且在页表中填入该项，然后再返回该项的虚拟地址。然后在munmap中，再将该file页内容写入file。</p>
<p>也就是说，直接在mmap把文件的全部内容写入内存，然后各进程读写自己的那块内容块，最后在munmap的时候把修改内容写入文件然后释放该内存块就行了</p>
<h5 id="问题：在哪里放置file的内容"><a href="#问题：在哪里放置file的内容" class="headerlink" title="问题：在哪里放置file的内容"></a>问题：在哪里放置file的内容</h5><p>题目要求<code>the kernel should decide the **virtual address** at which to map the file.</code>也就是说，在我们的<code>mmap</code>中，需要决定我们要讲文件内容放在哪里。那要放在哪呢……</p>
<p>我第一反应很奇葩：扫描页表，找到空闲页。但我自己也知道这样不可行，文件内容不止一页，这种零零散散存储需要的数据结构实现起来太麻烦了。</p>
<p>那怎么办？可以在heap内分配。那么到底怎么样才能在heap里分配？你该怎么知道heap哪里开始是空闲的，哪里是用过的，不还是得扫描页表吗？【思维大僵化】</p>
<p>其实……道理很简单。我们之间把<code>proc-&gt;sz</code>作为mapped-file的起始地址就好了。相信看到这里，你也明白这是什么原理了。能想到这个，我感觉确实很不容易。</p>
<h4 id="正确思路-1"><a href="#正确思路-1" class="headerlink" title="正确思路"></a>正确思路</h4><p>初见思路虽然简单，但是很粗暴，如果文件很大，宝贵的内存空间就会被我们浪费。所以我们借用lazy allocation的思想，先建立memory-file的映射，再在缺页中断中通过文件读写申请内存空间，把文件内容读入内存。</p>
<p>问题就在于如何“先建立memory-file的映射”。在lazy allocation中，我们是先填好所有的对应页表项，仅是不申请对应的物理内存，也即占着XX不XX。在这次实验中，我们也是这么做，只不过新增了一个难点，那就是<strong>如何管理这些页</strong>。因为lazy allocation页与页之间没有比较紧密的关系，但是在mmap中页却可以被所属文件这个关键字划分。因而，我们需要一个数据结构，来给页分门别类地组织在一起，并且记录它们的meta data比如说所属文件之类的，这也就是hints里的VMA结构，也即我的filemap结构。</p>
<p>我们可以将这样的数据结构池化，并且存储在proc域中，以避免对象的重复创建。</p>
<blockquote>
<p>我的lazy法与别人不大一样……我没有想得像他们那么完美。我的做法是，在需要读某个地址的文件内容时，直接确保这个地址前面的所有文件内容都读了进来。也即在filemap中维护一个okva，表明va<del>okva这段内存已经读入，之后就仅需再读入okva</del>need_va这段地址就行。这样虽然lazy了，但没完全lazy。</p>
<p>我认为这不能体现lazy的思想……因为一读读一坨，还是很占空间啊。</p>
</blockquote>
<p>因而，我们需要做的就是：</p>
<ol>
<li><p>在mmap中将信息填入该数据结构</p>
<ol>
<li>依据传入的长度扩容proc，原sz作为mapped-file起始地址va</li>
<li>从对象池中寻找到一个空闲的filemap，对其填写信息</li>
<li>返回1所得的va</li>
</ol>
<p>在我的代码中，还针对proc-&gt;sz不满足page-align做出了对策：先把文件的<code>PGROUNDUP(sz)-sz</code>这部分的信息读入，并且更新okva，这样一来，之后在usertrap中，就可以从okva开始一页页地分配地址，做到自然地page-align了。</p>
<blockquote>
<p>为什么要对不满足page-align的情况进行处理？</p>
<p>这是因为，growproc的时候一次性扩充一页，但proc-&gt;sz却可以不满足page-align，也就是说，proc-&gt;sz所处的这一页已经被分配了。</p>
<p>在我们的lazy思路中，我们如果不预先读入文件页，是只能等待用户陷入缺页中断的情况下才能读入文件内容。</p>
<p>但是，proc-&gt;sz这一页已经被分配了。因而，在用户态读取这一页地址的时候，<strong>并不会发生缺页中断</strong>。因而，就会发生文件内容未读入，用户读到脏数据的情况。</p>
<p>其实还有一种更简单的办法可以强制page-align，那就是，直接让起始地址为<code>PGROUNDUP(proc-&gt;sz)</code>……至于为什么我不用这个，而要写这么多麻烦的东西呢？答案是我没想到。（）</p>
</blockquote>
</li>
<li><p>在usertrap增加对缺页中断的处理</p>
<ol>
<li>依据va找到对应filemap</li>
<li>根据对应filemap的信息，使用<code>readi</code>（正确）<code>fileread</code>（错误）读取文件内容并存入物理内存</li>
</ol>
</li>
<li><p>在munmap中进行释放</p>
<ol>
<li>根据标记写入文件页，并且释放对应物理内存</li>
<li>修改filemap结构的参数，并且在其失效的时候放回对象池</li>
</ol>
</li>
<li><p>修改fork和exit</p>
<ol>
<li><p>exit</p>
<p>手动释放map-file域</p>
<blockquote>
<p>为什么不能把这些合并到<code>wait</code>中调用的<code>freepagetable</code>进行释放呢？</p>
<p>因为<code>freepagetable</code>只会释放对应的物理页，没有达到<code>munmap</code>减少文件引用等功能。</p>
</blockquote>
</li>
<li><p>fork</p>
<p>手动复制filemap池</p>
</li>
</ol>
</li>
</ol>
<h4 id="我的错误思路们"><a href="#我的错误思路们" class="headerlink" title="我的错误思路们"></a>我的错误思路们</h4><h5 id="第一次错误思路"><a href="#第一次错误思路" class="headerlink" title="第一次错误思路"></a>第一次错误思路</h5><p>上面说到：</p>
<blockquote>
<p>问题就在于如何“先建立memory-file的映射”。在lazy allocation中，我们是先填好所有的对应页表项，仅是不申请对应的物理内存，也即占着XX不XX。在这次实验中，我们也是这么做，只不过新增了一个难点，那就是<strong>如何管理这些页</strong>。因为lazy allocation页与页之间没有比较紧密的关系，但是在mmap中页却可以被所属文件这个关键字划分。因而，我们需要一个数据结构，来给页分门别类地组织在一起，并且记录它们的meta data比如说所属文件之类的，这也就是hints里的VMA结构，也即我的filemap结构。</p>
</blockquote>
<p>官方给出的答案是在proc域里的pool。我……额……是把这些信息，存入在页中（真是自找麻烦呀）</p>
<p>具体来说，就是，我在<code>mmap</code>的时候给每个文件申请一页，然后在页的开头填上和filemap结构相差无几的那些参数，再加上一个next指针，表示下一个文件页的地址。页的剩下部分就用来存储数据。总的就是一个链表结构。</p>
<p>这个思路其实很不错，比起上面的直接在proc内存的尾巴扩容，这个空间利用率应该更大，并且不仅能节省物理内存，还能节省虚拟地址空间，实现了lazy上加lazy。</p>
<p>但问题是……我<strong>为什么非要傻瓜式操纵内存，在页的开头填入参数数据</strong>，而不是把这种页抽象为一个个node，最终形成一个十字链表的形式（差不多的意思，鱼骨状），组织进proc域，这样不挺好的吗……唔，有时候我头脑昏迷程度让我自己都感到十分震惊。归根结底，还是想得太少就动手了，失策。</p>
<p>总之放上代码。我没有实现next指针，仅假设文件内容不超过一页。也就是这一页开头在mmap中填meta data，其余部分在usertrap中填入文件内容。【这个分开的点也让我迷惑至极……】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERRORADDR 0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="keyword">struct</span> file* file,uint64 offset)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">// 获取va,也即真正的address</span></span><br><span class="line">    uint64 va = p-&gt;sz;</span><br><span class="line">    <span class="keyword">if</span>(growproc(PGSIZE) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    <span class="type">char</span>* mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 保存信息：file指针、prot（这就是傻瓜式操纵内存的典范）</span></span><br><span class="line">    uint64* pointer = (uint64*)mem;</span><br><span class="line">    *pointer = (uint64)file;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)prot;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)length;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)flags;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)offset;</span><br><span class="line">    pointer++;</span><br><span class="line">    filedup(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(p-&gt;pagetable, va+PGSIZE, PGSIZE, (uint64)mem, PTE_M|PTE_X|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return start of free memory</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)(va + (uint64)pointer - (uint64)mem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64* pa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, (uint64)address, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span> ||(*pte &amp; PTE_M) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// the start is where the params save</span></span><br><span class="line">    pa = (uint64*)(PGROUNDDOWN(PTE2PA(*pte)));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span> =</span> (<span class="keyword">struct</span> file*)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> prot = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> flags = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flags == MAP_SHARED&amp;&amp;(prot&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 需要更新写内容</span></span><br><span class="line">        filewrite(file,(uint64)address,length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后释放内存</span></span><br><span class="line">    uvmunmap(p-&gt;pagetable, PGROUNDDOWN((uint64)address), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64* pa;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span> ||(*pte &amp; PTE_M) == <span class="number">0</span>)</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the start is where the params save</span></span><br><span class="line">    pa = (uint64*)(PGROUNDDOWN(PTE2PA(*pte)));</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span> =</span> (<span class="keyword">struct</span> file*)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> prot = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">size_t</span> length = (<span class="type">size_t</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((prot&amp;PROT_READ) != <span class="number">0</span>)&#123;</span><br><span class="line">      fileread(file,va,length);</span><br><span class="line">      flags |= PTE_R;</span><br><span class="line">      <span class="keyword">if</span>((prot&amp;PROT_WRITE) != <span class="number">0</span>)    flags |= PTE_W;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)     p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      *pte = ((*pte) | flags);</span><br><span class="line">    &#125; <span class="keyword">else</span>  p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="为什么下面的代码是错的"><a href="#为什么下面的代码是错的" class="headerlink" title="为什么下面的代码是错的"></a>为什么下面的代码是错的</h5><p>正如开头所说的那样，我并没有完美做好这次实验，下面代码有一个致命的bug。</p>
<p>先说说致命bug是什么。</p>
<p>我的filemap结构体其实隐藏了两个具有“offset”这一含义的状态。一个是filemap里面的成员变量offset，另一个是filemap里面的成员变量file的成员变量off：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">filemap</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span><span class="comment">//文件</span></span><br><span class="line">  uint64 offset;<span class="comment">//va相对于file开头的offset</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// in file.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在我的代码里，它们被赋予了不同的含义。</p>
<p><code>filemap-&gt;file-&gt;off</code>被用于<code>trap.c</code>中，表示的是当前未读入文件内容的起始位置（实际上也就是<code>okva-va</code>的值），用于自然地使用<code>fileread</code>进行文件读入。</p>
<blockquote>
<p>比如说，这次读入PGSIZE，那么off就会在<code>fileread</code>中自增PGSIZE。下次调用<code>fileread</code>就可以直接从下一个位置读入了，这样使代码更加简洁</p>
</blockquote>
<p><code>filemap-&gt;offset</code>被用于<code>munmap</code>中。<code>filewrite</code>同<code>fileread</code>一样，都是从<code>file-&gt;off</code>处开始取数据。<code>munmap</code>所需要取数据的起始位置和<code>trap.c</code>中需要取数据的起始位置肯定不一样，</p>
<blockquote>
<p>想想它们的功能。<code>trap.c</code>的off需要始终指向有效内存段的末尾，但<code>munmap</code>由于要对特定内存段进行写入文件操作，因而off要求可以随机指向。</p>
</blockquote>
<p>因而，我们可以将当前va对应的文件位置记录在offset中。届时，我们只需要从<code>p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va</code>取数据就行。</p>
<p>上述两个变量相辅相成，看上去似乎能够完美无缺地实现我们的功能。但是，实际上，不行。为什么呢？因为它们的file指针，<code>filemap-&gt;file</code>，如果被两个mmap区域同时使用的话，就会出问题。</p>
<p>可以来看看<code>mmaptest.c</code>中的这一段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  makefile(f);</span><br><span class="line">  <span class="keyword">if</span> ((fd = open(f, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">  unlink(f);</span><br><span class="line">  <span class="type">char</span> *p1 = mmap(<span class="number">0</span>, PGSIZE*<span class="number">2</span>, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">  <span class="type">char</span> *p2 = mmap(<span class="number">0</span>, PGSIZE*<span class="number">2</span>, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// read just 2nd page.</span></span><br><span class="line">  <span class="keyword">if</span>(*(p1+PGSIZE) != <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    err(<span class="string">&quot;fork mismatch (1)&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    err(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// v1是用来触发缺页中断的函数</span></span><br><span class="line">    _v1(p1);</span><br><span class="line">    munmap(p1, PGSIZE); <span class="comment">// just the first page</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// tell the parent that the mapping looks OK.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> status = <span class="number">-1</span>;</span><br><span class="line">  wait(&amp;status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(status != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork_test failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check that the parent&#x27;s mappings are still there.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;before v1,p1 = %d\n&quot;</span>,(uint64)p1);</span><br><span class="line">  _v1(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;after v1,p1 = %d\n&quot;</span>,(uint64)p1);</span><br><span class="line">  _v1(p2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fork_test OK\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">fork_test starting</span></span><br><span class="line"><span class="comment">trap:map a page at 53248,okva = 53248</span></span><br><span class="line"><span class="comment">trap:mem[0]=65,off = 4096,size = 6144</span></span><br><span class="line"><span class="comment">trap:map a page at 57344,okva = 53248</span></span><br><span class="line"><span class="comment">trap:mem[0]=65,off = 6144,size = 6144</span></span><br><span class="line"><span class="comment">before v1,p1 = 53248</span></span><br><span class="line"><span class="comment">after v1,p1 = 53248</span></span><br><span class="line"><span class="comment">trap:map a page at 61440,okva = 61440</span></span><br><span class="line"><span class="comment">trap:mem[0]=0,off = 6144,size = 6144</span></span><br><span class="line"><span class="comment">mismatch at 0, wanted &#x27;A&#x27;, got 0x0</span></span><br><span class="line"><span class="comment">mmaptest: fork_test failed: v1 mismatch (1), pid=3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in trap.c</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap:map a page at %d,okva = %d\n&quot;</span>,start_va,p-&gt;filemaps[i].okva);</span><br><span class="line"></span><br><span class="line">fileread(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap:mem[0]=%d,off = %d,size = %d\n&quot;</span>,</span><br><span class="line">       mem[<span class="number">0</span>],p-&gt;filemaps[i].file-&gt;off,p-&gt;filemaps[i].file-&gt;ip-&gt;size);</span><br></pre></td></tr></table></figure>

<p>这段代码因为共用fd，导致file指针被两个mmap区域同时使用。</p>
<blockquote>
<p>共用fd，为什么file指针也一起共用了？</p>
<p>可以追踪一下它们的生命周期：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in sys_open()</span></span><br><span class="line"><span class="comment">// 获取file结构体和文件描述符。</span></span><br><span class="line"><span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in sysfile.c</span></span><br><span class="line"><span class="comment">// Allocate a file descriptor for the given file.</span></span><br><span class="line"><span class="comment">// Takes over file reference from caller on success.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fdalloc</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line">   p-&gt;ofile[fd] = f;</span><br><span class="line">   <span class="keyword">return</span> fd;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它实际上是有一个文件描述符表，key为fd，value为file指针。因而，同一张表，fd相同，file指针相同。</p>
<p>注：父子进程，同样的fd，file指针也是相同的</p>
<p><strong>fork出来的父子进程同一个句柄对同一个文件的偏移量是相同的</strong>，这个原理应该是因为，父子进程共享的是文件句柄这个结构体对象本身，也就是拷贝的时候是浅拷贝而不是深拷贝。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in fork()</span></span><br><span class="line"><span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">   np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后的<code>check that the parent&#39;s mappings are still there.</code>环节中，<code>_v1(p1)</code>执行时并没有陷入trap，这是正常的。不正常的是<code>_v1(p2)</code>的执行结果。它陷入了trap，但是却因<code>file-&gt;off == file size</code>，导致被判定为已全部读入文件，事实上却是并没有读入文件。</p>
<p>为什么会这样呢？</p>
<p>这是因为p1和p2共用同一个fd，也就共用了同一个file指针。共用了一个file指针，那么p1和p2面对的<code>file-&gt;off</code>相同。上面说到，<code>file-&gt;off</code>用于控制文件映射。那么，当p1完成了对文件的映射，p1的off指针如果不加重置，就会永远停留在file size处。这样一来，当p2想要使用同样的file指针进行文件映射时，就会出问题。</p>
<p>这个问题的一个解决方法是每次<code>mmap</code>都深拷贝一个船新file结构体。但是这样的话，<code>file</code>域里的<code>ref</code>变量就失去了它的意义，并且file对象池应该也很快就会爆满，非常不符合设计方案。</p>
<p>这个问题的完美解，是不要赋予<code>file-&gt;off</code>这个意义，而是使用<code>readi</code>替代<code>fileread</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fileread(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span><br><span class="line">readi(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span><br></pre></td></tr></table></figure>

<p>这样做的好处是，我们可以实时计算offset（前面提到，其恰恰等于okva-va），而不用把这个东西用file的off来表示。</p>
<blockquote>
<p>也确实，我之所以弯弯绕绕那么曲折，是因为只想到了<code>fileread</code>这个函数，压根没注意到还有一个<code>readi</code>……</p>
</blockquote>
<p>我在下面的代码仅做了一个能够通过测试，但是上面的<strong>bug依然存在</strong>的功利性折中代码。我是这么实现的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在`mmap`的时候初始化`file-&gt;off`</span></span><br><span class="line">p-&gt;filemaps[i].file-&gt;off = offset;</span><br><span class="line"><span class="comment">// 在`munmap`的时候清零`file-&gt;off`</span></span><br><span class="line">p-&gt;filemaps[i].file-&gt;off = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>因而，结论是，一步错步步错，一个错误需要更多的错误来弥补，最后还是错的（悲）</p>
<h5 id="如何把下面的错误思路改成正确思路"><a href="#如何把下面的错误思路改成正确思路" class="headerlink" title="如何把下面的错误思路改成正确思路"></a>如何把下面的错误思路改成正确思路</h5><p>可以做以下几点：</p>
<ol>
<li><p>正确地lazy</p>
<p>每次trap仅分配一页。</p>
</li>
<li><p>改用readi函数，修改<code>file-&gt;off</code>的语义</p>
</li>
</ol>
<p>这样一来，大概就可以完美地正确了。</p>
<h4 id="其他的一些小细节"><a href="#其他的一些小细节" class="headerlink" title="其他的一些小细节"></a>其他的一些小细节</h4><h5 id="file指针的生命周期"><a href="#file指针的生命周期" class="headerlink" title="file指针的生命周期"></a>file指针的生命周期</h5><p>在数据结构中存储file指针至关重要。但仔细想一想，file指针的生命周期似乎长到过分：从sys_mmap被调用，一直到usertrap处理缺页中断，最后到munmap释放，我们要求file指针的值需要保持稳定不变。</p>
<p>这么长的生命周期，它真的可以做到吗？毕竟file指针归根到底只是一个局部变量，在syscall mmap结束之后，它还有效吗？答案是有效的，这个有效性由<code>mmap</code>实现中对ref的增加来实现保障。</p>
<p>在用户态中关闭一个文件，需要使用syscall<code>close(int fd)</code>。不妨来看看<code>close</code>的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/sysfile.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argfd(<span class="number">0</span>, &amp;fd, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 一个进程打开的文件都会放入一个以fd为index的文件表里，</span></span><br><span class="line"><span class="comment">// 在xv6中，这个文件表便是`myproc()-&gt;ofile`。</span></span><br><span class="line"><span class="comment">// 可以看到，关闭一个文件首先需要把它移出文件表</span></span><br><span class="line">myproc()-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 对file指针关闭的主要操作</span></span><br><span class="line">fileclose(f);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in kernel/file.c</span></span><br><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;ftable.lock);</span><br><span class="line"><span class="comment">// 若ref数&lt;0，就会直接return</span></span><br><span class="line"><span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> release(&amp;ftable.lock);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放file</span></span><br><span class="line"><span class="comment">// close不会显式地释放file指针，只会释放file指针所指向的文件，让file指针失效。</span></span><br><span class="line">ff = *f;</span><br><span class="line">f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">f-&gt;type = FD_NONE;</span><br><span class="line">release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line"> pipeclose(ff.pipe, ff.writable);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line"> begin_op();</span><br><span class="line"> iput(ff.ip);</span><br><span class="line"> end_op();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当ref数&gt;1时，file指针就不会失效。</p>
<p>这就是为什么我们还需要在mmap中让file的ref数++。</p>
<h5 id="缺页中断蕴含的设计思想"><a href="#缺页中断蕴含的设计思想" class="headerlink" title="缺页中断蕴含的设计思想"></a>缺页中断蕴含的设计思想</h5><p>如果只存入file指针，用户态要如何对对应的文件进行读写呢？</p>
<p>我们可以自然想到也许需要设计一个函数，让用户在想要对这块内存读写的时候调用这个函数即可。但是，这样的方法使得用户对内存不能自然地读写，还需要使用我们新设计的这个函数，这显然十分地不美观。所以，我们需要找到一个方法，让上层的用户可以<strong>统一</strong>地读取任何的内存块，包括memory-mapped file内存块，而<strong>隐藏</strong>memory-mapped file与其他内存块读写方式不同的这些复杂细节。经历过前面几次实验的你看到这里一定能想到，有一个更加优美更加符合设计规范的方法，那就是：<strong>缺页中断</strong>！</p>
<blockquote>
<p>没做这个实验之前就知道mmap需要借助缺页中断来实现了，但实际自己的第一印象是觉得并不需要缺页中断，直到分析到这里才恍然大悟。</p>
<p>“让上层的用户可以<strong>统一</strong>地读取任何的内存块，而<strong>隐藏</strong>不同类型的内存块读写方式不同的这些复杂细节”</p>
<p>仔细想想，前面几个关于缺页中断的实验，比如说cow fork，lazy allocation，事实上都是基于这个思想。它们并不是不能与缺页中断分离，只是有了缺页中断，它们的实现更加简洁，更加优美。</p>
<p>再次感慨os的博大精深。小小一个缺页中断，原理那么简单，居然集中了这么多设计思想，不禁叹服。</p>
</blockquote>
<h5 id="正确答案的munmap中如果遇到未映射的页怎么办"><a href="#正确答案的munmap中如果遇到未映射的页怎么办" class="headerlink" title="正确答案的munmap中如果遇到未映射的页怎么办"></a>正确答案的munmap中如果遇到未映射的页怎么办</h5><p>在正确答案的munmap中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line"><span class="keyword">while</span>(start_va &lt; bounder)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">    <span class="comment">//写回</span></span><br><span class="line">    filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">  &#125;</span><br><span class="line">  uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">  start_va += PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果map类型为<code>MAP_SHARED</code>，并且该页尚未映射，会怎么样呢？</p>
<p>追踪filewrite的路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in file.c</span></span><br><span class="line">	  begin_op();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line"><span class="comment">// in fs.c</span></span><br><span class="line">    <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line"><span class="comment">// in vm.c copyin()</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><code>copyin</code>最终会在<code>    if(pa0 == 0)  return -1;</code>这里终结，但<code>writei</code>并不会在接收到-1的时候爆出panic或者是引发缺页中断，而只会把它当做文件结尾，默默地返回。</p>
<p>并且，在<code>munmap</code>中是一页一页地释放，而不是直接传参length全部释放，这一点也很重要。因为我们的lazy allocation很可能导致<code>va~va+length</code>这一区间内只是部分页被映射，部分页没有。如果直接传参length释放，那么在遇到第一页未被映射的时候，<code>filewrite</code>就会终止，该页之后的页就没有被写回文件的机会了。</p>
<p>所以结论是，在正确实现的<code>munmap</code>中遇到未映射的页会自动跳过，什么也不会发生。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in param.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFILEMAP 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">filemap</span>&#123;</span></span><br><span class="line">  uint isused;<span class="comment">//对象池思想。该filemap是否正在被使用</span></span><br><span class="line">  uint64 va;<span class="comment">//该文件的起始内存页地址</span></span><br><span class="line">  uint64 okva;<span class="comment">//该文件的起始未被读入部分对应的内存地址</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span><span class="comment">//文件</span></span><br><span class="line">  <span class="type">size_t</span> length;<span class="comment">//需要映射到内存的长度</span></span><br><span class="line">  <span class="type">int</span> flags;<span class="comment">//MAP_SHARED OR MAP_PRIVATE</span></span><br><span class="line">  <span class="type">int</span> prot;<span class="comment">//PROT_READ OR PROT_WRITE</span></span><br><span class="line">  uint64 offset;<span class="comment">//va相对于file开头的offset</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">filemap</span> <span class="title">filemaps</span>[<span class="title">NFILEMAP</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>具体系统调用注册过程略。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length,prot,flags,offset;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>,&amp;length) &lt; <span class="number">0</span> || argint(<span class="number">2</span>,&amp;prot) &lt; <span class="number">0</span> || argint(<span class="number">3</span>,&amp;flags) &lt; <span class="number">0</span> || argfd(<span class="number">4</span>,<span class="number">0</span>,&amp;file) ||argint(<span class="number">5</span>,&amp;offset) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> (uint64)mmap((<span class="type">void</span>*)addr,(<span class="type">size_t</span>)length,prot,flags,file,(uint)offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERRORADDR 0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射file从offset开始长度为length的内容到内存中，返回内存中的文件内容起始地址</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="keyword">struct</span> file* file,uint64 offset)</span>&#123;</span><br><span class="line">    <span class="comment">// mmap的prot权限必须与file的权限对应，不能file只读但是mmap却可写且shared</span></span><br><span class="line">    <span class="keyword">if</span>((prot&amp;PROT_WRITE) != <span class="number">0</span>&amp;&amp;flags == MAP_SHARED &amp;&amp;file-&gt;writable == <span class="number">0</span>)       </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到filemap池中第一个空闲的filemap</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!p-&gt;filemaps[i].isused)&#123;</span><br><span class="line">        <span class="comment">// 获取va,也即真正的address</span></span><br><span class="line">        va = p-&gt;sz;</span><br><span class="line">        p-&gt;sz += length;</span><br><span class="line">        <span class="comment">// 其实这里用一个memcpy会更加优雅，可惜我忘记了（）</span></span><br><span class="line">        p-&gt;filemaps[i].isused = <span class="number">1</span>;</span><br><span class="line">        p-&gt;filemaps[i].va = va;</span><br><span class="line">        p-&gt;filemaps[i].okva = va;</span><br><span class="line">        p-&gt;filemaps[i].length = length;</span><br><span class="line">        p-&gt;filemaps[i].prot = prot;</span><br><span class="line">        p-&gt;filemaps[i].flags = flags;</span><br><span class="line">        p-&gt;filemaps[i].file = file;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = offset;</span><br><span class="line">        p-&gt;filemaps[i].offset = offset;</span><br><span class="line">        <span class="comment">// 增加文件引用数</span></span><br><span class="line">        filedup(file);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(va == <span class="number">0</span>)  <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    <span class="comment">// return start of free memory</span></span><br><span class="line">    uint64 start_va = PGROUNDUP(va);</span><br><span class="line">    <span class="comment">// 先读入处于proc已申请的内存页区域（也即没有内存对齐情况下）</span></span><br><span class="line">    uint64 off = start_va - va;</span><br><span class="line">    <span class="keyword">if</span>(off &lt; PGSIZE)&#123;</span><br><span class="line">        fileread(file,va,off);</span><br><span class="line">        file-&gt;off += off;</span><br><span class="line">        p-&gt;filemaps[i].okva = va+off;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)va;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h4><h5 id="错的"><a href="#错的" class="headerlink" title="错的"></a>错的</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">   uint64 va = r_stval();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">       <span class="comment">// 找到va对应的filemap</span></span><br><span class="line">     <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;va&gt;=p-&gt;filemaps[i].va </span><br><span class="line">        &amp;&amp; va&lt;p-&gt;filemaps[i].va+p-&gt;filemaps[i].length)&#123;</span><br><span class="line">       <span class="comment">// 说明本来就不应该写</span></span><br><span class="line">       <span class="keyword">if</span>(r_scause() == <span class="number">15</span> &amp;&amp; ((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) == <span class="number">0</span>)&#123;</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//说明地址不在文件范围内</span></span><br><span class="line">       <span class="keyword">if</span>(p-&gt;filemaps[i].va+p-&gt;filemaps[i].file-&gt;ip-&gt;size &lt;= va)&#123;</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 能进到这里来的都是产生了缺页中断，也就是说va对应文件数据不存在</span></span><br><span class="line">       <span class="comment">// 我们需要维护一个okva，表示从filemaps.va到okva这段地址已经加载了文件</span></span><br><span class="line">       <span class="comment">// 这样一来，我们这里就只需加载okva~va地址对应的文件了</span></span><br><span class="line">       <span class="comment">// file结构体自带的off成员会由于fileread而自动增长到对应位置，所以文件可以自然地读写</span></span><br><span class="line">       uint64 start_va = p-&gt;filemaps[i].okva;<span class="comment">// okva一定是page-align的</span></span><br><span class="line">       <span class="comment">// 加载文件内容</span></span><br><span class="line">       <span class="keyword">while</span>(start_va &lt;= va)&#123;</span><br><span class="line">         <span class="type">char</span>* mem = kalloc();</span><br><span class="line">         <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">           p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">         <span class="type">int</span> flag = PTE_X|PTE_R|PTE_U;</span><br><span class="line">         <span class="keyword">if</span>(((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">           flag |= PTE_W;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(mappages(p-&gt;pagetable, start_va, PGSIZE, (uint64)mem, flag) != <span class="number">0</span>)&#123;</span><br><span class="line">           p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">           kfree(mem);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 读入文件内容</span></span><br><span class="line">         fileread(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">         start_va += PGSIZE;</span><br><span class="line">       &#125;</span><br><span class="line">       p-&gt;filemaps[i].okva = start_va;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="对的"><a href="#对的" class="headerlink" title="对的"></a>对的</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;va&gt;=p-&gt;filemaps[i].va &amp;&amp; va&lt;p-&gt;filemaps[i].va+p-&gt;filemaps[i].length)&#123;</span><br><span class="line">      <span class="keyword">if</span>(r_scause() == <span class="number">15</span> &amp;&amp; ((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 说明本来就不应该写</span></span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].va+p-&gt;filemaps[i].file-&gt;ip-&gt;size &lt;= va)&#123;</span><br><span class="line">        <span class="comment">//说明地址不在文件范围内</span></span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      uint64 start_va = PGROUNDDOWN(va);</span><br><span class="line">        <span class="type">char</span>* mem = kalloc();</span><br><span class="line">        <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="type">int</span> flag = PTE_X|PTE_R|PTE_U;</span><br><span class="line">        <span class="keyword">if</span>(((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">         flag |= PTE_W;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable, start_va, PGSIZE, (uint64)mem, flag) != <span class="number">0</span>)&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">          kfree(mem);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readi(p-&gt;filemaps[i].file-&gt;ip,<span class="number">0</span>,(uint64)mem,va-p-&gt;filemaps[i].va+p-&gt;filemaps[i].offset,PGSIZE);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h4><h5 id="错的-1"><a href="#错的-1" class="headerlink" title="错的"></a>错的</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">min</span><span class="params">(uint64 a,uint64 b)</span>&#123;<span class="keyword">return</span> a&gt;b?b:a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放文件映射以address为起始地址，length为长度这个范围内的内存地址空间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = (uint64)address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到对应的filemap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;p-&gt;filemaps[i].va&lt;=va&amp;&amp;p-&gt;filemaps[i].va+length&gt;va)&#123;</span><br><span class="line">        <span class="comment">// 开始释放的内存地址</span></span><br><span class="line">        uint64 start_va;</span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)</span><br><span class="line">            start_va = PGROUNDUP(p-&gt;filemaps[i].va);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start_va = PGROUNDDOWN(va);</span><br><span class="line">        <span class="comment">// 结束释放的内存地址</span></span><br><span class="line">        uint64 bounder = p-&gt;filemaps[i].va + min(p-&gt;filemaps[i].file-&gt;ip-&gt;size,length);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//file的off在trap中用于表示文件已加载的位置</span></span><br><span class="line">        <span class="comment">//在这里需要用off进行filewrite，所以需要对原本在usertrap用于记录加载位置的off进行手动保存</span></span><br><span class="line">        uint64 tmp_off = p-&gt;filemaps[i].file-&gt;off;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line">        <span class="keyword">while</span>(start_va &lt; bounder &amp;&amp; start_va &lt; p-&gt;filemaps[i].okva)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">            <span class="comment">//写回</span></span><br><span class="line">            filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">          &#125;</span><br><span class="line">          uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">          start_va += PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改filemap结构体的起始地址va和长度，offset也要变，因为他记录va对应的是文件哪个位置</span></span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)&#123;</span><br><span class="line">          <span class="comment">//释放的是头几页</span></span><br><span class="line">          p-&gt;filemaps[i].offset += length;</span><br><span class="line">          p-&gt;filemaps[i].va = va+length;</span><br><span class="line">          p-&gt;filemaps[i].length -= length;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//释放的是尾几页</span></span><br><span class="line">          p-&gt;filemaps[i].length -= p-&gt;filemaps[i].length - va;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = tmp_off;</span><br><span class="line">        <span class="comment">// 检验map的合理性</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;filemaps[i].length == <span class="number">0</span> || p-&gt;filemaps[i].va &gt;= p-&gt;filemaps[i].va+length</span><br><span class="line">                        || p-&gt;filemaps[i].file-&gt;off &gt; p-&gt;filemaps[i].file-&gt;ip-&gt;size)&#123;</span><br><span class="line">          p-&gt;filemaps[i].isused = <span class="number">0</span>;<span class="comment">//释放</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 注意！！！！这句话对我的错误代码来说非常重要</span></span><br><span class="line">          p-&gt;filemaps[i].file-&gt;off = <span class="number">0</span>;</span><br><span class="line">          fileclose(p-&gt;filemaps[i].file);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对的-1"><a href="#对的-1" class="headerlink" title="对的"></a>对的</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">min</span><span class="params">(uint64 a,uint64 b)</span>&#123;<span class="keyword">return</span> a&gt;b?b:a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = (uint64)address;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;p-&gt;filemaps[i].va&lt;=va&amp;&amp;p-&gt;filemaps[i].va+length&gt;va)&#123;</span><br><span class="line">        uint64 start_va;</span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)</span><br><span class="line">                start_va = PGROUNDUP(p-&gt;filemaps[i].va);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                start_va = PGROUNDDOWN(va);</span><br><span class="line">        uint64 bounder = p-&gt;filemaps[i].va + min(p-&gt;filemaps[i].file-&gt;ip-&gt;size,length);</span><br><span class="line">        <span class="comment">//在这里需要用off进行读写，所以需要对原本的加载处off手动保存</span></span><br><span class="line">        uint64 tmp_off = p-&gt;filemaps[i].file-&gt;off;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line">        <span class="keyword">while</span>(start_va &lt; bounder)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">            <span class="comment">//写回</span></span><br><span class="line">            filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">          &#125;</span><br><span class="line">          uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">          start_va += PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改filemap结构体的起始地址va和长度，offset也要变，因为他记录va对应的是文件哪个位置</span></span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)&#123;</span><br><span class="line">          <span class="comment">//释放的是头几页</span></span><br><span class="line">          p-&gt;filemaps[i].offset += length;</span><br><span class="line">          p-&gt;filemaps[i].va = va+length;</span><br><span class="line">          p-&gt;filemaps[i].length -= length;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//释放的是尾几页</span></span><br><span class="line">          p-&gt;filemaps[i].length -= p-&gt;filemaps[i].length - va;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检验map的合理性</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;filemaps[i].length == <span class="number">0</span> || p-&gt;filemaps[i].va &gt;= p-&gt;filemaps[i].va+length</span><br><span class="line">                        || p-&gt;filemaps[i].file-&gt;off &gt; p-&gt;filemaps[i].file-&gt;ip-&gt;size)&#123;</span><br><span class="line">          p-&gt;filemaps[i].isused = <span class="number">0</span>;<span class="comment">//释放</span></span><br><span class="line">          fileclose(p-&gt;filemaps[i].file);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = tmp_off;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exit和fork"><a href="#exit和fork" class="headerlink" title="exit和fork"></a>exit和fork</h4><h5 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭map-file</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;filemaps[i].isused)&#123;</span><br><span class="line">    munmap((<span class="type">void</span>*)(p-&gt;filemaps[i].va),p-&gt;filemaps[i].length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">  np-&gt;filemaps[i].isused = p-&gt;filemaps[i].isused;</span><br><span class="line">  np-&gt;filemaps[i].va = p-&gt;filemaps[i].va;</span><br><span class="line">  np-&gt;filemaps[i].okva = p-&gt;filemaps[i].okva;</span><br><span class="line">  np-&gt;filemaps[i].file = p-&gt;filemaps[i].file;</span><br><span class="line">  np-&gt;filemaps[i].length = p-&gt;filemaps[i].length;</span><br><span class="line">  np-&gt;filemaps[i].flags = p-&gt;filemaps[i].flags;</span><br><span class="line">  np-&gt;filemaps[i].offset = p-&gt;filemaps[i].offset;</span><br><span class="line">  np-&gt;filemaps[i].prot = p-&gt;filemaps[i].prot;</span><br><span class="line">  <span class="keyword">if</span>(np-&gt;filemaps[i].file)</span><br><span class="line">    filedup(np-&gt;filemaps[i].file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改uvmcopy和uvmunmap"><a href="#修改uvmcopy和uvmunmap" class="headerlink" title="修改uvmcopy和uvmunmap"></a>修改uvmcopy和uvmunmap</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in uvmunmap()</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      *pte = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// in uvmcopy()</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>其他的对实验未涉及的思考</title>
    <url>/2023/01/10/xv6$chap9/</url>
    <content><![CDATA[<h1 id="其他的对实验未涉及的思考"><a href="#其他的对实验未涉及的思考" class="headerlink" title="其他的对实验未涉及的思考"></a>其他的对实验未涉及的思考</h1><h2 id="由mkfs引发的对虚拟机的学习"><a href="#由mkfs引发的对虚拟机的学习" class="headerlink" title="由mkfs引发的对虚拟机的学习"></a>由mkfs引发的对虚拟机的学习</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247489645&idx=5&sn=a6ad41806effb6bc8ff4815f4eab968a&chksm=fbb29193ccc51885348ce6dfb81661ecc17cd271bf6fb79a78a656b49d4eccaa9de7606c01cc&scene=27">懂了！VMware/KVM/Docker原来是这么回事儿</a>这篇文章对虚拟化、虚拟机技术讲解很到位，写得通俗易懂，非常值得一看</p>
<p><a href="https://www.zhihu.com/question/24123210/answer/2852910075">KVM 的「基于内核的虚拟机」是什么意思？</a>这篇文章对QEMU-KVM架构进行了详细的介绍。还有这篇文章对应的知乎问题下面的高赞回答有机会也可以去看看。</p>
<p><a href="https://blog.csdn.net/hbuxiaofei/article/details/113556046">QEMU/KVM原理概述</a>这篇文章前面的原理和上面那个差不多，后面有使用kvm做一个精简内核的实例，有兴趣/有精力/有需要可以看看。</p>
<p><a href="https://blog.csdn.net/qq_23924713/article/details/126080325">MIT6.S081操作系统实验——操作系统是如何在qemu虚拟机中启动的？</a></p>
<p><a href="https://blog.csdn.net/Mumu3w/article/details/54173069">xv6分析–mkfs源代码注释</a></p>
</blockquote>
<p>以前只是知道，xv6是运行在qemu提供的虚拟环境之上的。qemu是什么，怎么虚拟的，虚拟机和宿主机是怎么交互的，这些一概不通。今天心血来潮想研究下qemu，虚拟机啥的到底是什么玩意，虽然看得有些猪脑过载，但还是写下一些个人的整理。</p>
<h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>在了解qemu之前，可以先了解一下虚拟化的思想。</p>
<h5 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h5><blockquote>
<p>虚拟化的主要思想是，通过分层将底层的复杂、难用的资源虚拟抽象成简单、易用的资源，<strong>提供给上层</strong>使用。</p>
<p>本质上，计算机的发展过程也是虚拟化不断发展的过程，底层的资源或者通过<strong>空间的分割</strong>，或者通过<strong>时间的分割</strong>，将下层的资源通过一种简单易用的方式转换成另一种资源，提供给上层使用。</p>
<p>虚拟化可分为以下几方面：</p>
<ol>
<li><strong>CPU抽象</strong>：机器码、汇编语言到C语言、再到高级语言的不断虚拟的过程</li>
<li><strong>存储抽象</strong>：操作系统通过文件和目录抽象</li>
<li><strong>网络抽象</strong>：TCP/IP协议栈模型将网卡设备中传递的二进制数据，经过网络层、传输层的抽象后，为应用程序提供了便捷的网络包处理接口，而无需关心底层的IP路由、分片等细节</li>
<li><strong>进程抽象</strong>：操作系统通过进程抽象为不同的应用程序提供了安全隔离的执行环境，并且有着独立的CPU和内存等资源</li>
</ol>
</blockquote>
<p>虚拟化的思想实际上就是我以前一直称为“抽象”的思想，以接口的形式逐层向上服务。</p>
<h5 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h5><blockquote>
<p>虚拟机的核心能力在于<strong>提供一个执行环境</strong>（隐藏底层细节），并在其中完成用户的指定任务。</p>
</blockquote>
<blockquote>
<p>虚拟机有多种不同的<strong>形式</strong>，包括提供指令执行环境的进程、模拟器和高级语言虚拟机，或者是提供一个完整的系统环境的系统虚拟机。</p>
</blockquote>
<h6 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h6><p>进程实际上就是一种虚拟机。</p>
<blockquote>
<p>进程可以看作是一组<strong>资源的集合</strong>，有自己<strong>独立</strong>的进程地址空间以及<strong>独立</strong>的CPU和寄存器，执行程序员编写的指令，完成一定的任务。</p>
<p>操作系统可以创建多个进程，每一个进程都可以看成一个<strong>独立的虚拟机</strong>，它们在执行指令、访问内存的时候并不会相互影响影响。</p>
</blockquote>
<h6 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h6><h6 id="高级语言虚拟机"><a href="#高级语言虚拟机" class="headerlink" title="高级语言虚拟机"></a>高级语言虚拟机</h6><h6 id="系统虚拟机"><a href="#系统虚拟机" class="headerlink" title="系统虚拟机"></a>系统虚拟机</h6><blockquote>
<p>通过<a href="https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">系统虚拟化技术</a>，能够在<strong>单个的宿主机硬件平台上运行多个虚拟机</strong>，每个虚拟机都有着完整的虚拟机硬件，如虚拟的CPU、内存、虚拟的外设等，并且虚拟机之间能够实现完整的隔离。</p>
<p>在系统虚拟化中，管理全局物理资源的软件叫作<a href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%91%E6%8E%A7%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">虚拟机监控器</a>（Virtual Machine Monitor，VMM），<u>VMM之于虚拟机就如同操作系统之于进程</u>，VMM利用时分复用或者空分复用的办法将硬件资源在各个虚拟机之间进行分配。</p>
</blockquote>
<h5 id="qemu-1"><a href="#qemu-1" class="headerlink" title="qemu"></a>qemu</h5><p>可以看到，qemu就是一种虚拟机。它可以模拟虚拟机硬件，为操作系统提供虚拟硬件环境，从而能够让不同的操作系统能够在不同主机硬件上执行。</p>
<h4 id="qemu-kvm架构"><a href="#qemu-kvm架构" class="headerlink" title="qemu-kvm架构"></a>qemu-kvm架构</h4><h5 id="诞生的原因"><a href="#诞生的原因" class="headerlink" title="诞生的原因"></a>诞生的原因</h5><blockquote>
<p>其对于虚拟化技术的优化，以及发展的前因后果，具体可以看<a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247489645&idx=5&sn=a6ad41806effb6bc8ff4815f4eab968a&chksm=fbb29193ccc51885348ce6dfb81661ecc17cd271bf6fb79a78a656b49d4eccaa9de7606c01cc&scene=27">懂了！VMware/KVM/Docker原来是这么回事儿</a>这篇文章。</p>
<p>概括来讲，大致有以下几个要点：</p>
</blockquote>
<h6 id="两种虚拟化方案"><a href="#两种虚拟化方案" class="headerlink" title="两种虚拟化方案"></a>两种虚拟化方案</h6><p><img src="/2023/01/10/xv6/640.png" alt="640"></p>
<p><img src="/2023/01/10/xv6/640-1676793944101-7.png" alt="640-1676793944101-7"></p>
<h6 id="实现上述的虚拟化方案"><a href="#实现上述的虚拟化方案" class="headerlink" title="实现上述的虚拟化方案"></a>实现上述的虚拟化方案</h6><p>一个典型的做法是——<code>陷阱 &amp; 模拟</code>技术</p>
<p>什么意思？<strong>简单来说就是正常情况下直接把虚拟机中的代码指令放到物理的CPU上去执行，一旦执行到一些敏感指令，就触发异常，控制流程交给VMM，由VMM来进行对应的处理，以此来营造出一个虚拟的计算机环境。</strong></p>
<h6 id="x86架构的问题"><a href="#x86架构的问题" class="headerlink" title="x86架构的问题"></a>x86架构的问题</h6><p>x86架构使得上述做法用不了了。因为它引入了四种权限</p>
<p><img src="/2023/01/10/xv6/image-20230219160725978.png" alt="image-20230219160725978"></p>
<h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h6><ol>
<li><p>全虚拟化</p>
<p>VMware的二进制翻译技术、QEMU的模拟指令集</p>
</li>
<li><p>半虚拟化</p>
</li>
<li><p>硬件辅助虚拟化</p>
<p>硬件辅助虚拟化细节较为复杂，简单来说，新一代CPU在原先的Ring0-Ring3四种工作状态之下，再引入了一个叫工作模式的概念，有<code>VMX root operation</code>和<code>VMX non-root operation</code>两种模式，每种模式都具有完整的Ring0-Ring3四种工作状态，前者是VMM运行的模式，后者是虚拟机中的OS运行的模式。</p>
<p>qemu-kvm架构正是借助于此实现的。</p>
</li>
</ol>
<h6 id="kvm"><a href="#kvm" class="headerlink" title="kvm"></a>kvm</h6><p>kvm就是借助硬件辅助虚拟化诞生的。可以把kvm看作是一堆系统调用。</p>
<blockquote>
<p><a href="https://www.redhat.com/zh/topics/virtualization/what-is-KVM">什么是 KVM？</a></p>
<p>KVM本身是一个<strong>内核模块</strong>，它导出了一系列的<strong>接口</strong>到用户空间，用户态程序可以使用这些接口创建虚拟机。</p>
<p>具体而言，KVM 可帮助您将 Linux 转变为<a href="https://www.redhat.com/zh/topics/virtualization/what-is-a-hypervisor">虚拟机监控程序</a>，使主机计算机能够运行多个隔离的虚拟环境，即虚拟客户机或虚拟机（VM）。【也即，虚拟机—进程，KVM—操作系统】</p>
</blockquote>
<blockquote>
<p>在虚拟化底层技术上，<u>KVM和VMware后续版本一样</u>，都是基于<strong>硬件辅助虚拟化</strong>实现。不同的是VMware作为独立的第三方软件可以安装在Linux、Windows、MacOS等多种不同的操作系统之上，而KVM作为一项虚拟化技术已经<strong>集成</strong>到Linux内核之中，可以认为Linux内核本身就是一个HyperVisor，这也是KVM名字的含义，因此该技术只能在Linux服务器上使用。</p>
</blockquote>
<h6 id="qemu-kvm"><a href="#qemu-kvm" class="headerlink" title="qemu-kvm"></a>qemu-kvm</h6><p>KVM本身基于硬件辅助虚拟化，仅仅实现CPU和内存的虚拟化，但一台计算机不仅仅有CPU和内存，还需要各种各样的I/O设备，不过KVM不负责这些。这个时候，QEMU就和KVM搭上了线，经过改造后的QEMU，负责外部设备的虚拟，KVM负责底层执行引擎和内存的虚拟，两者彼此互补，成为新一代云计算虚拟化方案的宠儿。</p>
<h5 id="qemu-kvm总体架构"><a href="#qemu-kvm总体架构" class="headerlink" title="qemu-kvm总体架构"></a>qemu-kvm总体架构</h5><p>KVM只负责最核心的<strong>CPU虚拟化和内存虚拟化</strong>部分；QEMU作为其用户态组件，负责完成<strong>大量外设的模拟</strong>。</p>
<p><img src="/2023/01/10/xv6/v2-249a3f162de88198bbe415110fc71c7f_1440w.jpg" alt="v2-249a3f162de88198bbe415110fc71c7f_1440w"></p>
<h6 id="VMX-root和VMX-non-root"><a href="#VMX-root和VMX-non-root" class="headerlink" title="VMX root和VMX non root"></a>VMX root和VMX non root</h6><blockquote>
<p>VMX root是宿主机模式，此时CPU在运行包括QEMU在内的普通进程和宿主机的操作系统内核；</p>
<p>VMX non-root是<a href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">虚拟机模式</a>，此时CPU在运行虚拟机中的用户程序和操作系统代码。</p>
</blockquote>
<p>也就是说，虚拟机的程序，包括用户程序和内核程序，都运行在non-root模式。宿主机的所有程序，包括用户程序【包括qemu】和内核程序【包括kvm】，都运行在root模式。</p>
<h6 id="qemu层（左上）"><a href="#qemu层（左上）" class="headerlink" title="qemu层（左上）"></a>qemu层（左上）</h6><p>上面说到，qemu负责的是大量外设的模拟。它具体要做以下几件事：</p>
<blockquote>
<p>初始化虚拟机：</p>
<ol>
<li><p>创建模拟的芯片组</p>
</li>
<li><p>创建<strong>CPU线程</strong>来表示虚拟机的CPU</p>
<p>QEMU在初始化虚拟机的CPU线程时，首先设置好相应的虚拟CPU寄存器的值，然后调用KVM的接口将虚拟机运行起来，这样CPU线程就会被调度在物理CPU上执行虚拟机的代码。</p>
</li>
<li><p><strong>在QEMU的虚拟地址空间中分配空间作为虚拟机的物理地址</strong></p>
</li>
<li><p>根据用户在命令行<strong>指定的设备</strong>为虚拟机创建对应的虚拟设备【如各种IO设备】</p>
</li>
</ol>
<p>虚拟机运行时：</p>
<ol>
<li><p>监听多种事件</p>
<p>包括虚拟机对设备的I/O访问、用户对虚拟机管理界面、虚拟设备对应的宿主机上的一些I/O事件（比如虚拟机网络数据的接收）等</p>
</li>
<li><p>调用函数处理</p>
</li>
</ol>
</blockquote>
<p>可以看到，qemu确实利用了宿主机的各种资源，提供了一个很完美的硬件环境。其资源对应关系为：</p>
<p>虚拟机的CPU——宿主机的一个线程</p>
<p>虚拟机的物理地址——qemu在宿主机的虚拟地址</p>
<p>虚拟机对硬件设备的访问 —→ 对qemu的访问 </p>
<h6 id="kvm层（下方）"><a href="#kvm层（下方）" class="headerlink" title="kvm层（下方）"></a>kvm层（下方）</h6><p>它大概做了两件事：</p>
<ol>
<li><p>给qemu提供运行时的参数</p>
<p>通过“/dev/kvm”设备，比如CPU个数、内存布局、运行等。</p>
</li>
<li><p>截获VM Exit事件【下面会讲，用来完成虚拟机和硬件环境的交互】并进行处理。</p>
</li>
</ol>
<h6 id="虚拟机层（右上）"><a href="#虚拟机层（右上）" class="headerlink" title="虚拟机层（右上）"></a>虚拟机层（右上）</h6><ol>
<li><p>CPU——QEMU进程中的一个线程</p>
<p>通过QEMU和KVM的相互协作，虚拟机的线程会被宿主机操作系统正常调度，<strong>直接执行虚拟机中的代码</strong></p>
</li>
<li><p>物理地址——QEMU进程中的虚拟地址</p>
</li>
<li><p>设备——QEMU实现</p>
<p>在运行过程中，虚拟机操作系统通过设备的I/O端口（Port IO、PIO）或者MMIO（Memory Mapped I/O）进行交互，<strong>KVM会截获这个请求</strong>【也即VM Exit，下面会讲】，大多数时候KVM会将请求分发到用户空间的QEMU进程中，由<strong>QEMU处理</strong>这些I/O请求</p>
</li>
</ol>
<h5 id="虚拟机在QEMU-KVM架构的执行方法"><a href="#虚拟机在QEMU-KVM架构的执行方法" class="headerlink" title="虚拟机在QEMU-KVM架构的执行方法"></a>虚拟机在QEMU-KVM架构的执行方法</h5><h6 id="状态管理虚拟化"><a href="#状态管理虚拟化" class="headerlink" title="状态管理虚拟化"></a>状态管理虚拟化</h6><p>虚拟机肯定是会与它的硬件环境进行交互的，它的硬件环境也就是QEMU—KVM。</p>
<p>虚拟机的用户程序和内核程序都是直接由宿主机的操作系统正常调度，我们可以将其看作虚拟态。QEMU—KVM可以看作是宿主机的进程，我们可以将其看作宿主态。因而，当虚拟机一些事情希望由QEMU—KVM来做，我们就需要从虚拟态转移到宿主态。</p>
<p>听起来有没有感觉很耳熟？是的，“从用户态陷入内核态”，跟这个的原理是一样的。</p>
<p>因而，虚拟机与硬件环境交互，实际上是虚拟态和宿主态状态的转换，如下图：</p>
<p><img src="/2023/01/10/xv6/v2-9377a260d034d2904b1807d3fe53dcd9_1440w.jpg" alt="v2-9377a260d034d2904b1807d3fe53dcd9_1440w"></p>
<p><strong>VM Exit</strong></p>
<p>当虚拟机中的代码是敏感指令或者说满足了一定的退出条件时，CPU会从虚拟态退出到KVM，这叫作VM Exit。</p>
<p>这就像在用户态执行指令陷入内核一样。</p>
<p>VM Exit首先陷入到KVM中进行处理，如果KVM无法处理，比如说虚拟机写了设备的寄存器地址，那么KVM会将这个写操作分派到QEMU中进行处理。</p>
<p><strong>VM Entry</strong></p>
<p>当KVM或者QEMU处好了退出事件之后，又可以将CPU置于虚拟态以运行虚拟机代码，这叫作VM Entry。</p>
<h6 id="内存管理虚拟化"><a href="#内存管理虚拟化" class="headerlink" title="内存管理虚拟化"></a>内存管理虚拟化</h6><blockquote>
<p>QEMU在初始化的时候会通过<code>mmap</code>分配虚拟内存空间作为虚拟机的物理内存，【感觉思路打开，物理内存与文件对应了起来】QEMU在不断更新内存布局的过程中会持续调用KVM接口通知内核KVM模块虚拟机的内存分布。</p>
</blockquote>
<p>虚拟机在运行过程中，首先需要将虚拟机的虚拟地址（Guest Virtual Address，GVA）转换成虚拟机的物理地址（Guest Physical Address，GPA），然后将虚拟机的物理地址转换成宿主机的虚拟地址（Host Virtual Address，HVA），最终转换成宿主机的物理地址（Host Physical Address，HPA）。</p>
<p>整个寻址过程由硬件实现，具体实现方式为扩展页表（Extended Page Table，EPT）。</p>
<p>在支持EPT的环境中，虚拟机在<strong>第一次访问内存的时候就会陷入到KVM</strong>，KVM会<strong>逐渐建立</strong>起所谓的EPT页面【lazy思想贯穿始终，还是该叫自适应？】。这样虚拟机的虚拟CPU在后面访问虚拟机虚拟内存地址的时候，首先会被转换为虚拟机物理地址，接着会查找EPT页表，然后得到宿主机物理地址。【有种TLB的感觉】</p>
<p><img src="/2023/01/10/xv6/v2-942e1ed598eed3d401d00e4719224d27_1440w.jpg" alt="v2-942e1ed598eed3d401d00e4719224d27_1440w"></p>
<h6 id="外设管理虚拟化"><a href="#外设管理虚拟化" class="headerlink" title="外设管理虚拟化"></a>外设管理虚拟化</h6><p>设备模拟的本质是要为虚拟机提供一个<strong>与物理设备接口完全一致的虚拟接口</strong>。</p>
<p>虚拟机中的操作系统与设备进行的数据交互或者由QEMU和（或）KVM完成，或者由宿主机上对应的后端设备完成。</p>
<p>QEMU在初始化过程中会创建好模拟芯片组和必要的模拟设备，包括南北桥芯片、PCI根总线、ISA根总线等总线系统，以及各种PCI设备、ISA设备等。</p>
<p>外设虚拟化主要有如下几种方式：</p>
<ol>
<li><p>纯软件模拟（完全虚拟化）</p>
<p>QEMU最早的方案，虚拟机内核不用做任何修改，每一次对设备的寄存器读写都会陷入到KVM，进而到QEMU，QEMU再对这些请求进行处理并模拟硬件行为。</p>
<p>软件模拟会导致非常多的QEMU/KVM接入，效率低下。</p>
</li>
<li><p>virtio设备（半虚拟化）</p>
<p>virtio设备是一类特殊的设备，并没有对应的物理设备，所以需要虚拟机内部操作系统安装特殊的virtio驱动。</p>
<p>相比软件模拟，virtio方案提高了虚拟设备的性能。</p>
</li>
<li><p>设备直通</p>
<p>将物理硬件设备直接挂到虚拟机上，虚拟机直接与物理设备交互，尽可能在I/O路径上减少QEMU/KVM的参与。</p>
<p>设备直通经常搭配硬件虚拟化支持技术SRIOV（Single Root I/O Virtualization，单根输入/输出虚拟化）使用，SRIOV能够将单个的物理硬件高效地虚拟出多个虚拟硬件。</p>
</li>
</ol>
<p><img src="/2023/01/10/xv6/v2-555d017ce5b65457f98617a5fdf232af_1440w.jpg" alt="v2-555d017ce5b65457f98617a5fdf232af_1440w"></p>
<h6 id="中断处理虚拟化"><a href="#中断处理虚拟化" class="headerlink" title="中断处理虚拟化"></a>中断处理虚拟化</h6><p>操作系统通过写设备的I/O端口或者MMIO地址来与设备交互，设备通过发送中断来通知操作系统事件。</p>
<p>QEMU/KVM一方面需要完成这项<strong>中断设备的模拟</strong>，另一方面需要模拟<strong>中断的请求处理</strong>。</p>
<blockquote>
<p>QEMU支持单CPU的Intel 8259中断控制器以及SMP的I/O APIC（I/O Advanced Programmable Interrupt Controller）和LAPIC（Local Advanced Programmable Interrupt Controller）中断控制器。在这种方式下，虚拟外设通过QEMU向虚拟机注入中断，需要先陷入到KVM，然后由KVM向虚拟机注入中断，这是一个非常费时的操作。</p>
<p>为了提高虚拟机的效率，KVM自己也实现了中断控制器Intel 8259、I/O APIC以及LAPIC。用户可以有选择地让QEMU或者KVM模拟全部中断控制器，也可以让QEMU模拟Intel 8259中断控制器和I/O APIC，让KVM模拟LAPIC。</p>
</blockquote>
<h4 id="xv6的全启动运行过程梳理"><a href="#xv6的全启动运行过程梳理" class="headerlink" title="xv6的全启动运行过程梳理"></a>xv6的全启动运行过程梳理</h4><p>介绍完上述的qemu虚拟化，接下来就可以对xv6的全启动进行一个梳理了。</p>
<p>首先，在宿主机执行<code>make qemu</code>。</p>
<p>在<code>Makefile</code>中可以看到：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">qemu: $K/kernel fs.img</span></span><br><span class="line">        <span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span></span><br><span class="line">QEMU = qemu-system-riscv64</span><br></pre></td></tr></table></figure>

<p>在log中可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">mkfs/mkfs fs.img README user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie user/_mmaptest</span><br><span class="line">...</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>具体的<code>Makefile</code>相关内容我不大了解，但结合输出，我想大概是先通过<code>riscv64-linux-gnu-gcc</code>编译链接完所有文件，然后再执行<code>mkfs</code>产生<code>fs.img</code>镜像（<code>mkfs</code>后面那些东西应该是文件参数，对应于源码中的读取可执行程序进磁盘的部分），最后再运行<code>qemu-system-riscv64</code>开始对虚拟机进行boot。</p>
<p>boot直至启动后的所有代码，都是通过QEMU-KVM架构处理，直接运行在宿主机的CPU上的。其余的各种管理，可以详见小标题<code>虚拟机在QEMU-KVM架构的执行方法</code>。</p>
<h4 id="mkfs的作用及源码解读"><a href="#mkfs的作用及源码解读" class="headerlink" title="mkfs的作用及源码解读"></a>mkfs的作用及源码解读</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>上面的知识表明，<strong>操作系统的启动在于文件系统初始化之后</strong>，这是因为操作系统本身的启动代码，放在磁盘映像<code>fs.img</code>中，而<code>fs.img</code>正是由文件系统初始化时弄出来的。也就是说，<strong>文件系统是操作系统的爸爸</strong>。【我以前一直以为是反过来的】</p>
<p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<blockquote>
<p>图中的boot块就是操作系统的引导扇区。</p>
</blockquote>
<p>而<code>mkfs</code>的作用，正是把宿主机提供的<strong>虚拟地址空间作为虚拟磁盘</strong>，把虚拟地址空间划分为如上图所示的地址结构。<strong>它是运行在宿主机当中的</strong>。有了<code>mkfs</code>，才能有我们的虚拟机。</p>
<h5 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h5><p><a href="https://blog.csdn.net/Mumu3w/article/details/54173069">xv6分析–mkfs源代码注释</a></p>
<p>yysy这个就写得很好了。</p>
]]></content>
  </entry>
  <entry>
    <title>Lab0</title>
    <url>/2023/02/25/cs144$lab0/</url>
    <content><![CDATA[<h1 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a>Lab0</h1><blockquote>
<p>本次实验一直在强调的一点就是，TCP的功能是将底层的零散数据包，拼接成一个reliable in-order的byte stream。这个对我来说非常“振聋发聩”（夸张了233），以前只是背诵地知道TCP的可靠性，这次我算是第一次知道了所谓“可靠”究竟可靠在哪：一是保证了序列有序性，二是保证了数据不丢失（从软件层面）。</p>
<p>还有一个就是大致了解了cs144的主题：实现TCP协议。也就是说，运输层下面的那些层是不用管的吗？不过这样也挺恰好，我正好在学校的实验做过对下面这些层的实现了，就差一个TCP23333这样一来，我的协议栈就可以完整了。</p>
</blockquote>
<blockquote>
<p>本次实验与TCP的关系：</p>
<p>在我们的<code>webget</code>实现中，正是由于TCP的可靠传输，才能使我们的http request正确地被服务器接收，才能使服务器的response正确地被我们接收打印。</p>
<p>而在<code>ByteStream</code>中，我们也做了跟TCP类似的工作：接收substring，并且将它们拼接为in-order的byte stream【由于在内存中/单线程，所以这个工作看起来非常简单】：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(is_input_end == <span class="literal">false</span>&amp;&amp;pointer&lt;length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buffer.<span class="built_in">size</span>() == capacity)   <span class="keyword">break</span>;</span><br><span class="line">    buffer.<span class="built_in">push_back</span>(data[pointer]);</span><br><span class="line">    pointer++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Fetch-a-Web-page"><a href="#Fetch-a-Web-page" class="headerlink" title="Fetch a Web page"></a>Fetch a Web page</h2><p>主要是介绍了<code>telnet</code>指令</p>
<p><img src="/2023/02/25/cs144/194758.png" alt="屏幕截图 2023-02-23 194758"></p>
<h2 id="Send-yourself-an-email"><a href="#Send-yourself-an-email" class="headerlink" title="Send yourself an email"></a>Send yourself an email</h2><p>用的是telnet带smtp参</p>
<h2 id="Listening-and-connecting"><a href="#Listening-and-connecting" class="headerlink" title="Listening and connecting"></a>Listening and connecting</h2><p>上面的telnet是一个client program。接下来我们要把自己放在server的位置上。</p>
<p>用的是<code>netcat</code>指令。</p>
<p><img src="/2023/02/25/cs144/image-20230223202202509.png" alt="image-20230223202202509"></p>
<h2 id="Use-socket-to-write-webget"><a href="#Use-socket-to-write-webget" class="headerlink" title="Use socket to write webget"></a>Use socket to write webget</h2><p>这个确实不难，就是这个地方有点坑：</p>
<blockquote>
<p>Please note that in HTTP, each line must be ended with “\r\n” (it’s not sufficient to use just “\n” or endl).</p>
</blockquote>
<p>导致我跟400 Bad Request大眼瞪小眼了好久。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">	TCPSocket sock;</span><br><span class="line">    string tmp;</span><br><span class="line"><span class="comment">//    sock.set_blocking(true);// 默认情况下即为true</span></span><br><span class="line">    sock.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host,<span class="string">&quot;http&quot;</span>));</span><br><span class="line">    sock.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span> + </span><br><span class="line">               host + <span class="string">&quot;\r\nConnection: close\r\n\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((tmp = sock.<span class="built_in">read</span>(<span class="number">1</span>)) != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        cout &lt;&lt; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	上面那个写法不大规范，更规范的写法：</span></span><br><span class="line"><span class="comment">    while(!sock.eof())&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; sock.read(1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    sock.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一点值得注意的是，当我这样时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TCPSocket sock;</span><br><span class="line">   sock.<span class="built_in">set_blocking</span>(<span class="literal">false</span>);</span><br><span class="line">   sock.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host,<span class="string">&quot;http&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>会报错<code>Operation now in progress</code>。</p>
<blockquote>
<p><a href="https://blog.csdn.net/liujiakunit/article/details/9791461">关于socket通信中在connect()遇到的Operation now in progress错误</a></p>
<p>遇到此错误是因为将在connect()函数之前将套接字socket设为了非阻塞模式。改为在connect()函数之后设置即可。</p>
</blockquote>
<p>我觉得这个实验设计得挺好的，写的时候感觉很有意思。我推荐看下 <a href="https://github.com/shootfirst/CS144/blob/main/lab-0/apps/webget.cc">https://github.com/shootfirst/CS144/blob/main/lab-0/apps/webget.cc</a> 里的注释，写得很好很规范，让我明白了很多本来没搞懂的地方，比如说<code>shutdown</code>的用法。</p>
<h2 id="An-in-memory-reliable-byte-stream"><a href="#An-in-memory-reliable-byte-stream" class="headerlink" title="An in-memory reliable byte stream"></a>An in-memory reliable byte stream</h2><blockquote>
<p>实现一个<code>ByteStream</code>类，可以通过<code>read</code>和<code>write</code>对其两端进行读写。是单线程程序，因而无需考虑阻塞。</p>
</blockquote>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>这东西其实是很简单的，但是我还是花了一定的时间，主要原因有两点，一是我不懂c++，所以一些地方错得我很懵逼，二是因为我是sb。</p>
<p>下面就记录下三个我印象比较深刻的错误吧。</p>
<h5 id="错误1-member-initialization-list"><a href="#错误1-member-initialization-list" class="headerlink" title="错误1 member initialization list"></a>错误1 member initialization list</h5><p>构造函数我一开始是这么写的：</p>
<p><img src="/2023/02/25/cs144/image-20230224113108208.png" alt="image-20230224113108208"></p>
<p>结果爆出了这样的错：</p>
<p><img src="/2023/02/25/cs144/image-20230224112056879.png" alt="image-20230224112056879"></p>
<p>搜了半天也没看懂怎么回事，去求助了下某场外c艹选手，才知道了还有成员变量初始化列表这玩意，这个东西似乎比较高效安全。</p>
<p>于是我改成了这么写：</p>
<p><img src="/2023/02/25/cs144/image-20230224113333962.png" alt="image-20230224113333962"></p>
<p>它告诉我<code>buffer</code>也得初始化。于是我又这么写：</p>
<p><img src="/2023/02/25/cs144/image-20230224113358856.png" alt="image-20230224113358856"></p>
<p>又是奇奇怪怪的错误，说明vector不能这么初始化。</p>
<p>场外c艹选手看到了这个：</p>
<p><img src="/2023/02/25/cs144/image-20230224113456432.png" alt="image-20230224113456432"></p>
<p>所以说vector应该这样初始化：</p>
<p><img src="/2023/02/25/cs144/image-20230224113549970.png" alt="image-20230224113549970"></p>
<h5 id="错误2-使用了vector作为buffer的载体"><a href="#错误2-使用了vector作为buffer的载体" class="headerlink" title="错误2 使用了vector作为buffer的载体"></a>错误2 使用了<code>vector</code>作为buffer的载体</h5><p>应该使用的是可以从front删除数据的数据结构，比如说deque。【vector也行，但是效率较低】</p>
<p>具体为什么，可以以数据流为cat为例。执行<code>peek(2)</code>时，使用vector得到的是at，使用deque得到的是ca。</p>
<h5 id="错误3-错误地阻塞"><a href="#错误3-错误地阻塞" class="headerlink" title="错误3 错误地阻塞"></a>错误3 错误地阻塞</h5><p>一开始在<code>write</code>方法，我是这么写的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> length = data.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">while</span>(is_input_end == <span class="literal">false</span>&amp;&amp;pointer&lt;length)&#123;</span><br><span class="line">    <span class="keyword">while</span>(buffer.<span class="built_in">size</span>() == capacity);</span><br><span class="line">    buffer.<span class="built_in">push_back</span>(data[pointer]);</span><br><span class="line">    pointer++;</span><br><span class="line">    total_write ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果就是测试用例Timeout。我找了很久都不知道错在了哪，最后求助了场外观众【罪过……这次实验太不独立了】，学着他把length改成了这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> length = <span class="built_in">min</span>(data.<span class="built_in">length</span>(),capacity-buffer.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<p>发现成了。</p>
<p>我去看了看testbench，猜测应该是因为阻塞了，我还以为是deque自身会阻塞【是的，我完全没注意到自己顺手把阻塞写了下去】，查了半天发现不会，最后才发现是自己不小心搞错了呃呃…………</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="头文件声明"><a href="#头文件声明" class="headerlink" title="头文件声明"></a>头文件声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This doesn&#x27;t need to be a sophisticated data structure at</span></span><br><span class="line">    <span class="comment">// all, but if any of your tests are taking longer than a second,</span></span><br><span class="line">    <span class="comment">// that&#x27;s a sign that you probably want to keep exploring</span></span><br><span class="line">    <span class="comment">// different approaches.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> total_write;</span><br><span class="line">    <span class="type">size_t</span> total_read;</span><br><span class="line">    <span class="type">bool</span> is_input_end;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> capacity;</span><br><span class="line">    deque&lt;<span class="type">char</span>&gt; buffer;</span><br></pre></td></tr></table></figure>

<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> cap) : <span class="built_in">total_write</span>(<span class="number">0</span>),<span class="built_in">total_read</span>(<span class="number">0</span>),<span class="built_in">is_input_end</span>(<span class="literal">false</span>),<span class="built_in">capacity</span>(cap),<span class="built_in">buffer</span>()&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Write a string of bytes into the stream. Write as many</span></span><br><span class="line">    <span class="comment">//! as will fit, and return how many were written.</span></span><br><span class="line">    <span class="comment">//! \returns the number of bytes accepted into the stream</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is_input_end == <span class="literal">true</span>)    is_input_end = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> pointer = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> length = data.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span>(is_input_end == <span class="literal">false</span>&amp;&amp;pointer&lt;length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buffer.<span class="built_in">size</span>() == capacity)   <span class="keyword">break</span>;</span><br><span class="line">        buffer.<span class="built_in">push_back</span>(data[pointer]);</span><br><span class="line">        pointer++;</span><br><span class="line">    &#125;</span><br><span class="line">    total_write+=pointer;</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//! Peek at next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        i++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Remove bytes from the buffer</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    total_read+=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string res = <span class="built_in">peek_output</span>(len);</span><br><span class="line">    <span class="built_in">pop_output</span>(len);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123;is_input_end = <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_input_end; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_input_end &amp;&amp; buffer.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> total_write; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> total_read; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> capacity - buffer.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Lab3   TCPSender</title>
    <url>/2023/02/25/cs144$lab3/</url>
    <content><![CDATA[<h1 id="Lab3-TCPSender"><a href="#Lab3-TCPSender" class="headerlink" title="Lab3   TCPSender"></a>Lab3   TCPSender</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在TCP协议中，<code>TCPSender</code>负责对ack进行处理，将字节流封装为TCP报文，根据拥塞窗口的大小传输数据，以及管理超时重传。</p>
<p>我们的<code>TCPSender</code>需要做的是：</p>
<ol>
<li><p>维护拥塞窗口</p>
<p><img src="/2023/02/25/cs144/image-20230228105405827.png" alt="image-20230228105405827"></p>
<p>我们需要通过ackno和window_size两个参数维护拥塞窗口的大小</p>
</li>
<li><p>填充拥塞窗口</p>
<p>必须as possible。除非拥塞窗口满或者<code>ByteStream</code>空才不填。</p>
<p>对于从<code>ByteStream</code>读出的数据，我们需要把其封装为一个<code>TCPSegment</code>再向<code>_segment_out</code>输出</p>
</li>
<li><p>记录哪一部分ack了，哪一部分没有ack</p>
<p>我们需要在发送segment的同时暂存segment，当且仅当接收到ack，并且ack为segment.seqno+length的时候才能将其释放。</p>
</li>
<li><p>管理超时重传</p>
<p>当对方超过一段时间还没有收到数据时，需要进行超时重传</p>
<p>以segment为单位，一个segment重传具有原子性。</p>
<p>在sender和暂存segment的数据结构中保存时钟滴答</p>
</li>
</ol>
<p>特别的，指导书上有一段话表述得很有意思：</p>
<p><img src="/2023/02/25/cs144/image-20230228110046088.png" alt="image-20230228110046088"></p>
<p>这体现了<code>TCPReceiver</code>和<code>TCPSender</code>之间的对偶关系，这种细节性的设计理念值得学习。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>写完<code>TCPSender</code>后我还是觉得有些迷茫……就跟<code>TCPReceiver</code>一样。说不出来具体是哪里不清楚，但总感觉隐隐约约有些怪怪的？总感觉相互之间接口有点混乱，对它们之间是怎么交互的一概不知。我想这是由于我们是自底向上实现TCP协议所带来的问题。希望这种感觉在实现完<code>TCPConnection</code>之后可以好转吧。</p>
<p><code>TCPReceiver</code>的主要任务是把segment拼接成字节流，以及维护即将要告知<code>TCPSender</code>的ackno和拥塞窗口大小。而<code>TCPSender</code>的作用就是把字节流切成segment，并且根据ackno和拥塞窗口大小，进行数据的填充以及超时重传的管理。可以看到，它们是对偶的关系。</p>
<h3 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h3><p>看完指导书以及各种接口定义可以得知，我们需要：</p>
<ol>
<li><p>增加成员变量</p>
<ol>
<li><p>window_size    拥塞窗口的大小</p>
</li>
<li><p>ackono      记录当前收到的最大ackno</p>
</li>
<li><p>ticks           记录sender从出生到现在的时钟滴答</p>
</li>
<li><p>tmp_size    记录tmp_segments  中的数据字节数（注意算上SYN和FIN）</p>
</li>
<li><p>tmp_segments  暂存segment，等待收到ack</p>
<p>数据结构：</p>
<p>list，自定义struct，结构体内有</p>
<ul>
<li>TCPSegment</li>
<li>seqno  记录该segment的起始数据的seq</li>
<li>data_size    记录该segment携带数据的长度</li>
</ul>
</li>
<li><p>cons_retran  记录连续的超时重传次数</p>
</li>
<li><p>syn    标记当前是否为第一个segment</p>
</li>
<li><p>fin</p>
</li>
<li><p>rto    记录当前的RTO</p>
</li>
<li><p>timer_start    记录timer是否等待中</p>
</li>
<li><p>timer_ticks     记录timer开启时的时间</p>
</li>
</ol>
</li>
<li><p>实现一个定时函数</p>
<p>第一次从bytestream取出数据包装为segment的时候（也即发送SYN报文）开启它，当所有data都收到ack的时候（也即FIN报文也被成功ACK）关闭它</p>
<p>应该在ticks中被调用</p>
<blockquote>
<p>Every time a segment containing data (nonzero length in sequence space) is sent (whether it’s the first time or a retransmission), if the timer is not running, <strong>start it</strong> <strong>running</strong> so that it will expire after RTO milliseconds.</p>
</blockquote>
<p>当timer触发时，我们需要重传tmp_segments  队列头。</p>
<p>如果空间足够，直接重传就行了，然后double RTO，然后用RTO reset timer，然后再次启动timer。</p>
<p>如果空间不足够，只做上面那个的后两步，也即reset timer，然后再次启动timer。</p>
</li>
<li><p><code>ack_received</code></p>
<ol>
<li><p>更新window_size和ackno</p>
</li>
<li><p>重置超时重传</p>
<p>如果接收到的ackno比以前的大，则重置RTO，重启timer（如果tmp_segments不为空），重置cons_retran  </p>
</li>
<li><p>从tmp_segments中删除元素</p>
</li>
<li><p>调用<code>fill_window</code></p>
</li>
</ol>
</li>
<li><p><code>fill_window</code></p>
<p>如果window_size - tmp_size &lt;= 0 或者 byte stream空，则什么也不做</p>
<p>否则根据syn和fin标记创建一个new segment，然后写入out stream</p>
<blockquote>
<p> no bigger than the value given by TCPConfig::MAX PAYLOAD SIZE (1452 bytes)</p>
</blockquote>
<blockquote>
<p>If the receiver has announced a window size of zero, the fifill window method should act like the window size is <strong>one</strong>. </p>
</blockquote>
</li>
</ol>
<h3 id="细节补充"><a href="#细节补充" class="headerlink" title="细节补充"></a>细节补充</h3><p>实现起来虽然很复杂，但思路确实很简单，正确思路和初见思路差不多，指导书写得很好很详细【以至于一开始我被指导书这么多内容给吓到了】。在这里只记录点实现过程中遇到的一些小错误以及我各个部分的实现细节补充。</p>
<h4 id="timer实现"><a href="#timer实现" class="headerlink" title="timer实现"></a>timer实现</h4><p>指导书的建议是实现一个类，但是我太懒了（）而且确实这个timer的状态也很少，因而我就直接把它写在sender里面了。</p>
<h4 id="SYN报文是否可以带数据"><a href="#SYN报文是否可以带数据" class="headerlink" title="SYN报文是否可以带数据"></a>SYN报文是否可以带数据</h4><p>此实验未涉及这个。本次全部的测试用例都是SYN报文不携带数据的情况。【因为发出syn报文之后才将window_size设置为非0情况】</p>
<p>如果需要SYN报文不携带数据，可以在<code>fill_window</code>中把这句话：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(_stream.<span class="built_in">buffer_empty</span>() || remaining == <span class="number">0</span>)) &#123;</span><br></pre></td></tr></table></figure>

<p>修改为这句话：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!segment.<span class="built_in">header</span>().syn&amp;&amp;!(_stream.<span class="built_in">buffer_empty</span>() || remaining == <span class="number">0</span>)) &#123;</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSender</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// our initial sequence number, the number for our SYN.</span></span><br><span class="line">    WrappingInt32 _isn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// outbound queue of segments that the TCPSender wants sent</span></span><br><span class="line">    std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retransmission timer for the connection</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _initial_retransmission_timeout;<span class="comment">// 初始的超时重传时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// outgoing stream of bytes that have not yet been sent</span></span><br><span class="line">    ByteStream _stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the (absolute) sequence number for the next byte to be sent</span></span><br><span class="line">    <span class="type">uint64_t</span> _next_seqno&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">OutSegment</span> &#123; <span class="comment">// outstanding segment的包装类</span></span><br><span class="line">        TCPSegment segment;</span><br><span class="line">        <span class="type">uint64_t</span> seqno;</span><br><span class="line">        <span class="type">size_t</span> data_size;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::list&lt;OutSegment&gt; tmp_segments&#123;&#125;;<span class="comment">// 内部存储结构</span></span><br><span class="line">    <span class="type">size_t</span> tmp_size = <span class="number">0</span>;<span class="comment">// 存储结构中含有的segment的总字节数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意此处一定要初始化为1</span></span><br><span class="line">    <span class="type">size_t</span> window_size = <span class="number">1</span>;<span class="comment">// 拥塞窗口大小</span></span><br><span class="line">    <span class="type">uint64_t</span> ackno = <span class="number">0</span>;<span class="comment">// 最大的ackno</span></span><br><span class="line">    <span class="type">size_t</span> ticks = <span class="number">0</span>;<span class="comment">// 从出生到当前经过的时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cons_retran = <span class="number">0</span>;  <span class="comment">// 超时重传连续次数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rto;<span class="comment">// 当前超时重传时间</span></span><br><span class="line">    <span class="type">bool</span> timer_start = <span class="literal">false</span>;<span class="comment">// 超时重传timer是否开启</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> timer_ticks = <span class="number">0</span>;<span class="comment">// timer开启时的时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> syn = <span class="literal">false</span>;<span class="comment">// 是否发送了SYN报文</span></span><br><span class="line">    <span class="type">bool</span> fin = <span class="literal">false</span>;<span class="comment">// 是否发送了FIN报文</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send_empty_rst_segment</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send_empty_ack_segment</span><span class="params">(WrappingInt32 t_ackno)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fully_acked</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _next_seqno == ackno; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TCPSender::<span class="built_in">TCPSender</span>(<span class="type">const</span> <span class="type">size_t</span> capacity, <span class="type">const</span> <span class="type">uint16_t</span> retx_timeout, <span class="type">const</span> std::optional&lt;WrappingInt32&gt; fixed_isn)</span><br><span class="line">    : _isn(fixed_isn.<span class="built_in">value_or</span>(WrappingInt32&#123;<span class="built_in">random_device</span>()()&#125;))</span><br><span class="line">    , _initial_retransmission_timeout&#123;retx_timeout&#125;</span><br><span class="line">    , _stream(capacity)</span><br><span class="line">    , rto&#123;retx_timeout&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tmp_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽可能地创造segment并且填充到segment output中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// should act like the window size is one</span></span><br><span class="line">    <span class="type">size_t</span> t_win_size = window_size == <span class="number">0</span> ? <span class="number">1</span> : window_size;</span><br><span class="line">    <span class="type">size_t</span> remaining = t_win_size - tmp_size;</span><br><span class="line">    <span class="comment">// 防止数值溢出的情况</span></span><br><span class="line">    <span class="keyword">if</span> (t_win_size &lt; tmp_size)</span><br><span class="line">        remaining = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill as possible</span></span><br><span class="line">    <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// create and fill in a segment</span></span><br><span class="line">        TCPSegment segment = <span class="built_in">TCPSegment</span>();</span><br><span class="line">        <span class="comment">// 如果处于CLOSED状态</span></span><br><span class="line">        <span class="keyword">if</span> (!syn) &#123;</span><br><span class="line">            <span class="comment">// 转移到SYN_SENT状态</span></span><br><span class="line">            <span class="comment">// first segment</span></span><br><span class="line">            segment.<span class="built_in">header</span>().syn = <span class="literal">true</span>;</span><br><span class="line">            segment.<span class="built_in">header</span>().seqno = _isn;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">            syn = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// should start the timer here</span></span><br><span class="line">            rto = _initial_retransmission_timeout;</span><br><span class="line">            timer_start = <span class="literal">true</span>;</span><br><span class="line">            timer_ticks = ticks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fill in the payload</span></span><br><span class="line">        <span class="keyword">if</span> (!segment.<span class="built_in">header</span>().syn &amp;&amp; !(_stream.<span class="built_in">buffer_empty</span>() || remaining == <span class="number">0</span>)) &#123;</span><br><span class="line">            string data = _stream.<span class="built_in">read</span>(<span class="built_in">min</span>(remaining, TCPConfig::MAX_PAYLOAD_SIZE));</span><br><span class="line">            remaining -= data.<span class="built_in">length</span>();</span><br><span class="line">            Buffer buf = <span class="built_in">Buffer</span>(<span class="built_in">move</span>(data));</span><br><span class="line">            segment.<span class="built_in">payload</span>() = buf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转移到FIN_SENT状态</span></span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !fin &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// last segment</span></span><br><span class="line">            segment.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">            fin = <span class="literal">true</span>;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// segment为空（不为SYN、FIN，也不携带任何数据）</span></span><br><span class="line">        <span class="keyword">if</span> (segment.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        segment.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);</span><br><span class="line">        _next_seqno += segment.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">        <span class="comment">// push into the outstanding segments</span></span><br><span class="line">        tmp_segments.<span class="built_in">push_back</span>(</span><br><span class="line">            &#123;segment, <span class="built_in">unwrap</span>(segment.<span class="built_in">header</span>().seqno, _isn, _next_seqno), segment.<span class="built_in">length_in_sequence_space</span>()&#125;);</span><br><span class="line">        tmp_size += segment.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">        <span class="comment">// push into the segment out queue</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ack, <span class="type">const</span> <span class="type">uint16_t</span> wind_size)</span> </span>&#123;</span><br><span class="line">    window_size = wind_size;</span><br><span class="line">    <span class="type">uint64_t</span> a_ack = <span class="built_in">unwrap</span>(ack, _isn, ackno);</span><br><span class="line">    <span class="keyword">if</span> (a_ack &gt; _next_seqno)</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// impossible ack is ignored</span></span><br><span class="line">    <span class="keyword">if</span> (a_ack &gt; ackno) &#123;</span><br><span class="line">        <span class="comment">// reset the retransmission</span></span><br><span class="line">        rto = _initial_retransmission_timeout;</span><br><span class="line">        timer_ticks = ticks;</span><br><span class="line">        cons_retran = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// erase elements from the tmp_segments</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = tmp_segments.<span class="built_in">begin</span>(); it != tmp_segments.<span class="built_in">end</span>();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a_ack &gt;= it-&gt;seqno + it-&gt;data_size) &#123;</span><br><span class="line">                tmp_size -= (it-&gt;segment).<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">                <span class="comment">// 如果FIN报文被成功接收，就关闭timer</span></span><br><span class="line">                <span class="comment">// FIN_ACKED</span></span><br><span class="line">                <span class="keyword">if</span> (it-&gt;segment.<span class="built_in">header</span>().fin)</span><br><span class="line">                    timer_start = <span class="literal">false</span>;</span><br><span class="line">                it = tmp_segments.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                it++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ackno = a_ack;</span><br><span class="line">    <span class="built_in">fill_window</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ticks &gt; ticks + ms_since_last_tick) &#123;</span><br><span class="line">        <span class="comment">// 进行简单的溢出处理，还是有可能溢出</span></span><br><span class="line">        ticks -= timer_ticks;</span><br><span class="line">        timer_ticks = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ticks += ms_since_last_tick;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timer_start &amp;&amp; ticks &gt; timer_ticks &amp;&amp; ticks - timer_ticks &gt;= rto) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tmp_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// resend</span></span><br><span class="line">            _segments_out.<span class="built_in">push</span>(tmp_segments.<span class="built_in">front</span>().segment);</span><br><span class="line">            <span class="keyword">if</span> (window_size != <span class="number">0</span>) &#123;</span><br><span class="line">                cons_retran++;</span><br><span class="line">                rto *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer_ticks = ticks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cons_retran; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  在TCPConnection中被使用的辅助方法们  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TCPSegment segment = <span class="built_in">TCPSegment</span>();</span><br><span class="line">    segment.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_empty_ack_segment</span><span class="params">(WrappingInt32 t_ackno)</span> </span>&#123;</span><br><span class="line">    TCPSegment segment = <span class="built_in">TCPSegment</span>();</span><br><span class="line">    segment.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);</span><br><span class="line">    segment.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">    segment.<span class="built_in">header</span>().ackno = t_ackno;</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_empty_rst_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TCPSegment segment = <span class="built_in">TCPSegment</span>();</span><br><span class="line">    segment.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);</span><br><span class="line">    segment.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Lab2   TCPReceiver</title>
    <url>/2023/02/25/cs144$lab2/</url>
    <content><![CDATA[<h1 id="Lab2-TCPReceiver"><a href="#Lab2-TCPReceiver" class="headerlink" title="Lab2   TCPReceiver"></a>Lab2   TCPReceiver</h1><h2 id="前置学习"><a href="#前置学习" class="headerlink" title="前置学习"></a>前置学习</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><h4 id="承上启下"><a href="#承上启下" class="headerlink" title="承上启下"></a>承上启下</h4><p>在前两个实验中，我们可以说只是做了点算法上的抽象工作，跟TCP协议还是没什么显著的关系的。但来到了本次实验，一切就都不一样了。</p>
<p><img src="/2023/02/25/cs144/image-20230226194708398.png" alt="image-20230226194708398"></p>
<p>依然还是这张图。相信此时做过前两个实验之后，看到这张图就会有了不一样的发现。</p>
<p>我们对TCP协议的实现是由内向外的，先实现里面再实现最外层。前两节实验，我们由内而外实现了<code>ByteStream</code>和<code>StreamReassembler</code>；在这次实验中，我们会实现更外层一点的<code>TCPReceiver</code>。</p>
<p>根据我们前两次实验内容，我们可以知道，<code>TCPReceiver</code>的功能之一就是，将数据包<code>TCPSegment</code>拆分成一个个<code>data</code>，并且通过<code>seq</code>生成出这些<code>data</code>的<code>index</code>，然后传递给<code>StreamReassembler</code>。</p>
<h4 id="由外而内"><a href="#由外而内" class="headerlink" title="由外而内"></a>由外而内</h4><h5 id="TCPConnection"><a href="#TCPConnection" class="headerlink" title="TCPConnection"></a>TCPConnection</h5><p>在说明<code>TCPReceiver</code>的其他功能前，不妨先从外面的<code>TCPConnection</code>说起，由外而内回忆一下整个TCP协议过程。</p>
<p><img src="/2023/02/25/cs144/image-20230226200935395.png" alt="image-20230226200935395"></p>
<p><img src="/2023/02/25/cs144/image-20230226202631406.png" alt="image-20230226202631406"></p>
<p>这期间最关键需要理解的，是SYN FIN ACK ack seq这些东西究竟是什么东西。</p>
<h5 id="对象说明"><a href="#对象说明" class="headerlink" title="对象说明"></a>对象说明</h5><h6 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h6><p>seq用来标识字节流中某个字节的序号，在TCP报文中，它表示的是该报文携带的数据的第一个字节的序号。</p>
<p>与我们在Lab1实现的<code>StreamReassembler</code>的参数index相比，它有三方面不同：</p>
<ol>
<li><p>seq为32位，index为64位</p>
<p>当一个字节流的数据超过2^32字节（实际上比这少就会环绕）时，seq就会产生环绕。如，当前seq为0xFFFFFFFF，则下一个seq就是0x00000000。</p>
</li>
<li><p>seq不从0开始，index从0开始</p>
<p>为了确保传输过程中的安全性，一个字节流的起始seq不为0，而是一个<strong>随机数</strong>，称其为<strong>ISN</strong>。</p>
</li>
<li><p>seq有不携带数据的两个逻辑报文SYN和FIN，index没有</p>
</li>
</ol>
<h6 id="SYN"><a href="#SYN" class="headerlink" title="SYN"></a>SYN</h6><p>SYN是TCP“三握手”中服务器端接收到的来自客户端的第一个报文。它是TCP报文中的一个标识位：</p>
<p><img src="/2023/02/25/cs144/image-20230227135255525.png" alt="image-20230227135255525"></p>
<p>它用以标识数据传输的开始，并且<strong>携带</strong>seq最初随机的序号ISN。</p>
<blockquote>
<p>除了确保收到所有字节的数据外，TCP必须确保也能收到流的开始和结束</p>
<p>这个说得非常好，完美解释了为什么需要占据一个seqno</p>
</blockquote>
<h6 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a>ACK</h6><p>ACK也是一个标识位，它代表当前报文是一个确认收到的报文ACK，也即报文中的ackno<strong>值有效</strong>。</p>
<h6 id="ack"><a href="#ack" class="headerlink" title="ack"></a>ack</h6><p>ack表示当前endpoint【包括客户端和服务器端】希望接收到的下一个数据流的起始字节的seq。</p>
<blockquote>
<p>关于seq和ack，听起来还是有点抽象，不如以连接释放图中ack和seq的值变化为例来说明。</p>
<p><img src="/2023/02/25/cs144/image-20230226202631406.png" alt="image-20230226202631406"></p>
<p>为什么一开始seq=u，ack=v，但下一个就是seq=v，ack=u+1？</p>
<p>这是因为，ack和seq的语义对于客户端和服务器端都是不变的。ack为已经收到的数据的seq+1表示第一个应该接收的值，seq为已经发送的数据的seq+1表示已经发送的值。并且还需要意识到，图中其实有两个数据流（一个是C→S，另一个是S→C），也即有两套seq和ack。</p>
<ul>
<li><p>ack</p>
<p>服务器从客户端接收信号。ack表示服务器希望接收到的下一个序列号，也即为它从客户端收到的数据的seq+1。</p>
<p>对于此情况，虽然终止报文不携带数据，但其依然占据一个序列号seq。</p>
<p>因而服务器的ack=u+1.</p>
</li>
<li><p>seq</p>
<p>服务器向客户端发送数据。ack表示客户端希望接收到的下一个序号，因而服务器端就应该发送ack这个序号的数据，也即v。</p>
</li>
</ul>
</blockquote>
<h6 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h6><p>FIN也是一个标识位，标识着数据传输的结束</p>
<h5 id="接收报文类型"><a href="#接收报文类型" class="headerlink" title="接收报文类型"></a>接收报文类型</h5><p>因而，从图中可以看出，TCP连接中大概会收到以下几类报文：</p>
<ol>
<li><p>特殊报文</p>
<ol>
<li><p>SYN = 1</p>
<ol>
<li><p>C的连接请求  携带了ISN</p>
</li>
<li><p>S的连接请求确认，ACK = 1，携带了S的ISN</p>
</li>
</ol>
</li>
<li><p>ACK = 1</p>
<p>额我觉得这是TCPSender管的。这大概是Connection知道了之后通知下TCPSender吧，应该跟我们这次实验没关系</p>
</li>
<li><p>FIN = 1</p>
</li>
</ol>
</li>
<li><p>普通的数据</p>
</li>
</ol>
<h5 id="TCPReceiver的作用"><a href="#TCPReceiver的作用" class="headerlink" title="TCPReceiver的作用"></a>TCPReceiver的作用</h5><p>我们的<code>TCPReceiver</code>需要负责TCP协议中部分关键对象的管理。我们需要生成ackno以及拥塞窗口大小；我们需要接收SYN和FIN等信号；我们需要对seq进行处理，将其变为<code>StreamReassembler</code>所想要的index。</p>
<h4 id="总结TCPReceiver的作用"><a href="#总结TCPReceiver的作用" class="headerlink" title="总结TCPReceiver的作用"></a>总结TCPReceiver的作用</h4><ol>
<li><p>处理数据</p>
<p>把Internet过来的一个个TCP报文变成一个个小data，小data再由整流器整流为完整的data，外界再通过socket从ByteStream读取完整的data。</p>
</li>
<li><p>反馈信息</p>
<p>向发送方反馈自己当前的一些状态信息，如拥塞窗口的大小以及ack等。</p>
<ol>
<li><p>ackno</p>
<p>本质上是“index of the first unassembled byte”</p>
</li>
<li><p>window size</p>
<p>本质上是“the distance between the first unassembled index and the first unacceptable index”</p>
</li>
</ol>
<p>也即，ackno为拥塞窗口的左端点，ackno+window_size为拥塞窗口的右端点</p>
</li>
</ol>
<h3 id="64-bit-indexes-←→-32-bit-seqnos"><a href="#64-bit-indexes-←→-32-bit-seqnos" class="headerlink" title="64-bit indexes ←→ 32-bit seqnos"></a>64-bit indexes ←→ 32-bit seqnos</h3><p>从Overview中可以看出来，至关重要的一点就是，将环绕的32bit的seq转化为我们在<code>StreamReassembler</code>中使用的index。</p>
<p>我们不妨再引入一个中间变量<code>abstract seqno</code>。则<code>seqno</code>、<code>abstract seqno</code>、<code>stream index</code>三者关系如下图：</p>
<p><img src="/2023/02/25/cs144/image-20230227141242426.png" alt="image-20230227141242426"></p>
<p>显然从<code>seqno</code>转化为<code>abstract seqno</code>更加复杂。因而，我们要做的第一个实验部分就是实现这个转化。</p>
<p>我们需要实现类<code>WrappingInt32</code>。它的<code>wrap</code>函数将64位的<code>abstract seqno</code>转化为32位的<code>seqno</code>，它的<code>unwrap</code>将32位的<code>seqno</code>转化为64位的<code>abstract seqno</code>。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><h3 id="64-bit-indexes-←→-32-bit-seqnos-1"><a href="#64-bit-indexes-←→-32-bit-seqnos-1" class="headerlink" title="64-bit indexes ←→ 32-bit seqnos"></a>64-bit indexes ←→ 32-bit seqnos</h3><p>这个实验完美地触及到了我的雷点：对这种环绕来环绕去的东西非常头疼……因而昨天晚上做的时候晕晕乎乎的什么也思考不了，今天过来边画了下图才知道要怎么做。</p>
<p><code>wrap</code>很简单我就不说了。对于<code>unwrap</code>，我的做法是，先让checkpoint和n-isn都处在同一个区间（红圈）内【也即都让它们对2^32取余】，再通过几个东西之间的关系来确定最终的res是否需要+-HEAD_ONE：</p>
<p>【蓝线表示n-isn，橙线表示红圈区间的中点】</p>
<p><img src="/2023/02/25/cs144/image-20230227133550293.png" alt="image-20230227133550293"></p>
<p>具体的就不多说了。直接看下面的代码，多画画图就能明白了。</p>
<h3 id="TCPReceiver"><a href="#TCPReceiver" class="headerlink" title="TCPReceiver"></a>TCPReceiver</h3><p><img src="/2023/02/25/cs144/image-20230227231044428.png" alt="image-20230227231044428"></p>
<h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>我一开始头晕晕地去写，对很多地方产生了疑问，激情地写下了一些消极的话语。刚刚出去吹了会儿风回来，bug全都改对了，于是狂喜着把消极的话语全部删掉了（）</p>
<p>怎么说呢，我的错误发生是因为我<strong>没有意识到</strong>sponge的TCP也许算是一个“简化版”。</p>
<p>在学习本章内容之前，我特地先去回顾了下TCP协议的全过程，并且所有的SYN，FIN等等等概念都是按照网上的概念来的。因而我在面对自己的错误时真的是一脸懵逼……好在，吹完风之后我还是及时醒悟了。</p>
<p>思路还是很简单的，细节也不像Lab1那样那么多那么破防，就是一些奇奇怪怪的恶心小毛病太多了，导致我出错频频，并且都是些很sb的问题，让人直接心态爆炸。</p>
<p>先不吐槽了，接下来就来讲讲总体的思路，以及我产生疑惑的一些地方吧。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h5><p>得益于Lab1那个复杂算法的健壮性和多功能性，我们对<code>TCPReceiver</code>的实现就可以变得更加简洁。我们不再需要关心报文是否能够被成功接收、报文是否重叠等等等。我们仅需对SYN和FIN这样的报文做特殊的参数处理，将seqno转化为index，然后直接传入我们的<code>StreamReassembler</code>中就行了。</p>
<p>也即，基本流程为：</p>
<ol>
<li>如果收到SYN报文，则对一些参数进行初始化，并且标记数据传输开始信号syn为true</li>
<li>如果syn为true，则计算index后传入整流器</li>
<li>判断是否需要加上FIN报文的比特位</li>
</ol>
<h5 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h5><h6 id="SYN和FIN各占一个seqno"><a href="#SYN和FIN各占一个seqno" class="headerlink" title="SYN和FIN各占一个seqno"></a>SYN和FIN各占一个seqno</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SYN</span></span><br><span class="line">    <span class="keyword">if</span>(!syn&amp;&amp;header.syn)&#123; <span class="comment">// is the first packet</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        isn = header.seqno;</span><br><span class="line">        seqno = seqno + <span class="number">1</span>; <span class="comment">// plus one to skip the SYN byte</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// FIN</span></span><br><span class="line">	<span class="keyword">if</span>(header.fin)      fin = <span class="literal">true</span>; <span class="comment">// 这个一定要写在上面那个if的后面</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span>(_reassembler.<span class="built_in">empty</span>() &amp;&amp; fin)&#123;</span><br><span class="line">    	ack += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>SYN很直观，没什么好说的。</p>
<p>FIN比较烧。之所以不是这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(header.fin)&#123;</span><br><span class="line">   	ack += <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>也即一发现FIN报文到了就++，是因为可能会发生这种情况：</p>
<p><img src="/2023/02/25/cs144/image-20230227224055002.png" alt="image-20230227224055002"></p>
<p>也即FIN报文虽然到了，但是中间有一段数据还没到，ack应该等于中间那段数据的开头，你这时候想要跳过FIN而把ack+1那肯定是不对的。</p>
<p>也因而，我们需要记录fin是否有过，并且仅当：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">empty</span>()&amp;&amp;is_eof; &#125;</span><br></pre></td></tr></table></figure>

<p>成立时，才能表示数据传输真正结束，让ack++。</p>
<h6 id="以abstract-seqno的形式保存ackno"><a href="#以abstract-seqno的形式保存ackno" class="headerlink" title="以abstract seqno的形式保存ackno"></a>以abstract seqno的形式保存ackno</h6><p>说实话我一开始ackno的数据结构是WrappingInt32。为了这么搞，我还得特地维护一个checkpoint变量用来做unwrap的参数，然后ackno也不能用<code>_reassembler.get_left_bound()</code>来获取，总之就搞得非常非常麻烦。这时候我不小心【是故意的还是不小心的？】看到了<a href="https://github.com/shootfirst/CS144/">感恩</a>的代码，对其用abstract seqno保存ackno这个想法大为赞叹，于是就果断地沿用了（）果然设计思想方面我还是有很大不足啊。</p>
<h4 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h4><h5 id="关于特殊报文"><a href="#关于特殊报文" class="headerlink" title="关于特殊报文"></a>关于特殊报文</h5><p>我一开始被这个图以及百度得到的结果受影响：</p>
<p><img src="/2023/02/25/cs144/image-20230227224429692.png" alt="image-20230227224429692"></p>
<p><img src="/2023/02/25/cs144/image-20230227224449780.png" alt="image-20230227224449780"></p>
<p>认为SYN报文不能携带数据【同理FIN也是】，因而在最初实现的时候看到test case人都麻透了开始怀疑人生……</p>
<p>不过这也怪我没有意识到实验和业界可能是不一样的，但指导书也没说SYN和FIN到底会不会携带数据……emm，我感觉这一点做得不够详细，也许可以改进一下。</p>
<h5 id="关于window-size的定义"><a href="#关于window-size的定义" class="headerlink" title="关于window size的定义"></a>关于window size的定义</h5><p>我现在还是搞不懂这东西究竟是什么玩意……</p>
<p>指导书上是这么说的：</p>
<blockquote>
<p>the distance between the “first <strong>unassembled</strong>” index and the “first <strong>unacceptable</strong>” index.</p>
<p>This is called the “<strong>window size</strong>”.</p>
</blockquote>
<p>所谓的“first <strong>unassembled</strong>”正是ackno。而，我正是理解错了所谓“first <strong>unacceptable</strong>” 的意思，才导致我想了好久好久都没想出来，最后看了答案被薄纱到现在。</p>
<p>看到这个“first <strong>unacceptable</strong>” ，我的第一反应就是，维护一个变量right_bound，当packet过来的时候，如果packet的index范围(seqno + data.length())比right_bound大就更新。我认为这才叫做“first <strong>unacceptable</strong>”。但其实！我会这么想是因为我英语不好……</p>
<p>“first <strong>unacceptable</strong>” ，unacceptable，意为<strong>无法接受的</strong>，也就是说，它跟容量有关。第一个无法接受的，就是第一个超出容量的。而结合我们上面的那张图：</p>
<p><img src="/2023/02/25/cs144/image-20230225232723083-1677510449924-1.png" alt="image-20230225232723083"></p>
<p>可以看出，事实上window size就是黑框部分，也即紫框部分减去绿色部分，也即<code>ByteStream</code>的<code>remaining_capacity()</code>……</p>
<p>而我以为它是<strong>还未收到的</strong>的意思，故而才理解成了上面那样。</p>
<p>看来英语不好也是原罪23333</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="64-bit-indexes-←→-32-bit-seqnos-2"><a href="#64-bit-indexes-←→-32-bit-seqnos-2" class="headerlink" title="64-bit indexes ←→ 32-bit seqnos"></a>64-bit indexes ←→ 32-bit seqnos</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! Transform an &quot;absolute&quot; 64-bit sequence number (zero-indexed) into a WrappingInt32</span></span><br><span class="line"><span class="comment">//! \param n The input absolute 64-bit sequence number</span></span><br><span class="line"><span class="comment">//! \param isn The initial sequence number</span></span><br><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tmp = (n &amp; TAIL_MASK);</span><br><span class="line">    <span class="keyword">return</span> isn + tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Transform a WrappingInt32 into an &quot;absolute&quot; 64-bit sequence number (zero-indexed)</span></span><br><span class="line"><span class="comment">//! \param n The relative sequence number</span></span><br><span class="line"><span class="comment">//! \param isn The initial sequence number</span></span><br><span class="line"><span class="comment">//! \param checkpoint A recent absolute 64-bit sequence number</span></span><br><span class="line"><span class="comment">//! \returns the 64-bit sequence number that wraps to `n` and is closest to `checkpoint`</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! \note Each of the two streams of the TCP connection has its own ISN. One stream</span></span><br><span class="line"><span class="comment">//! runs from the local TCPSender to the remote TCPReceiver and has one ISN,</span></span><br><span class="line"><span class="comment">//! and the other stream runs from the remote TCPSender to the local TCPReceiver and</span></span><br><span class="line"><span class="comment">//! has a different ISN.</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="type">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tmp_n = n.<span class="built_in">raw_value</span>() - isn.<span class="built_in">raw_value</span>();</span><br><span class="line">    <span class="type">uint64_t</span> res = (checkpoint &amp; HEAD_MASK);</span><br><span class="line">    <span class="type">uint32_t</span> tmp_cp = (checkpoint &amp; TAIL_MASK);</span><br><span class="line"></span><br><span class="line">    res |= tmp_n;</span><br><span class="line">    <span class="keyword">if</span>(tmp_cp &lt; FLAG)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp_n &gt; tmp_cp + FLAG)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &gt;= HEAD_ONE) res -= HEAD_ONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp_cp &gt; FLAG)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp_n &lt; tmp_cp - FLAG)       res += HEAD_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TCPReceiver-1"><a href="#TCPReceiver-1" class="headerlink" title="TCPReceiver"></a>TCPReceiver</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPReceiver</span> &#123;</span><br><span class="line">    StreamReassembler _reassembler;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _capacity;</span><br><span class="line">    <span class="type">uint64_t</span> ack = <span class="number">0</span>;</span><br><span class="line">    WrappingInt32 isn = <span class="built_in">WrappingInt32</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> syn = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> fin = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    TCPHeader header = seg.<span class="built_in">header</span>();</span><br><span class="line">    WrappingInt32 seqno = header.seqno;</span><br><span class="line">    string data = seg.<span class="built_in">payload</span>().<span class="built_in">copy</span>();</span><br><span class="line">    <span class="type">size_t</span> index = <span class="number">0</span>; <span class="comment">// the param of the reassembler</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LISTENING -&gt; SYN_SENT</span></span><br><span class="line">    <span class="keyword">if</span>(!syn&amp;&amp;header.syn)&#123; <span class="comment">// is the first packet</span></span><br><span class="line">        _reassembler.<span class="built_in">set_is_eof</span>();<span class="comment">// reset the eof flag</span></span><br><span class="line">        fin = <span class="literal">false</span>;<span class="comment">// reset the fin flag</span></span><br><span class="line">        isn = header.seqno;</span><br><span class="line">        seqno = seqno + <span class="number">1</span>; <span class="comment">// plus one to skip the SYN byte</span></span><br><span class="line">        syn = <span class="literal">true</span>;<span class="comment">// mark the start of the byte stream</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// must keep after the last if branch to avoid the case &quot;flag = SF&quot;</span></span><br><span class="line">    <span class="comment">// FIN_RECEIVED</span></span><br><span class="line">    <span class="keyword">if</span>(header.fin)      fin = <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">if</span>(syn)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> abs_seqno = <span class="built_in">unwrap</span>(seqno,isn,ack);</span><br><span class="line">        index = abs_seqno - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (abs_seqno != <span class="number">0</span>)<span class="comment">// write into the assembler</span></span><br><span class="line">        	_reassembler.<span class="built_in">push_substring</span>(data,index,header.fin);</span><br><span class="line">        ack = _reassembler.<span class="built_in">get_left_bound</span>() + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; fin)</span><br><span class="line">            ack += <span class="number">1</span>;<span class="comment">// plus one to skip the FIN byte</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(syn)     <span class="keyword">return</span> <span class="built_in">wrap</span>(ack,isn);</span><br><span class="line">    <span class="keyword">else</span>        <span class="keyword">return</span> &#123;&#125;;<span class="comment">// empty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stream_out</span>().<span class="built_in">remaining_capacity</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Lab1  StreamReassembler</title>
    <url>/2023/02/25/cs144$lab1/</url>
    <content><![CDATA[<h1 id="Lab1-StreamReassembler"><a href="#Lab1-StreamReassembler" class="headerlink" title="Lab1   StreamReassembler"></a>Lab1   StreamReassembler</h1><blockquote>
<p>TCP managed to produce a pair of <em>reliable in-order byte streams</em> (one from you to the server, and one in the opposite direction), even though the underlying network only delivers “best-effort” datagrams. </p>
<p>You also implemented the byte-stream abstraction yourself, in memory within one computer. </p>
<p>Over the next four weeks, you’ll implement TCP, to <strong>provide the byte-stream abstraction between a pair of computers</strong> separated by an unreliable datagram network.</p>
</blockquote>
<p>我们的任务是实现一个<code>StreamReassembler</code>。它的具体功能相信看下数据传输路径就很明了了：</p>
<blockquote>
<p>receiver的数据传输路径：network → StreamReassembler整流 →（write）ByteStream（read）→ app</p>
</blockquote>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>先放个通关截图在这。</p>
<p><img src="/2023/02/25/cs144/image-20230225192145829.png" alt="image-20230225192145829"></p>
<p>这个实验我前前后后总共做了大概有9h+……写我下面放上来的屎山代码可能大概用了5h+。我总共使用了140+行代码实现我的核心函数<code>push_substring</code>。</p>
<p>整个过程，包括思路和代码都十分复杂，但最后的表现相比于别人好像也没好到哪去，让我不禁怀疑自己是不是想错了……以及，这样的复杂性也给我带来很多担忧，担心会不会在以后的实验因为这个的bug而寄，毕竟我在写笔记的同时都已经找到了不止一个bug了（）希望人没事。</p>
<p>总而言之，先把我的思路和一步步的代码拆解放上来吧。</p>
<blockquote>
<p>后记：</p>
<p>不得不说，这个东西太健壮了，给后面的<code>TCPReceiver</code>省去了好多功夫……</p>
<p>比如说，<code>TCPReceiver</code>无需考虑ack怎么算，因为这里就帮你算好了；<code>TCPReceiver</code>无需考虑数据包重叠或者重复，因为这里已经考虑到这个情况了；<code>TCPReceiver</code>无需担忧FIN是否会因为容量满丢弃一部分数据而未达到真正的FIN，只需调用其相关接口判断就行。</p>
<p>它虽然帮助了<code>TCPReceiver</code>那么多，但很神奇的是，它们的耦合性并不高。你把<code>StreamReassembler</code>单独拆出来看，左看右看，它都<u>确实仅仅只是一个健壮的区间合并算法</u>。</p>
<p>这得益于实验设计的精良，得益于设计<code>TCPReceiver</code>时的野心。这些边界情况都这么麻烦，而且都只与区间合并有关，那么我们为什么不直接把它抽象进区间合并进行处理呢？这种想法极富胆识，事实证明最后也确实能实现。这种设计理念让我受益很深。</p>
</blockquote>
<h2 id="为什么我的思路那么复杂"><a href="#为什么我的思路那么复杂" class="headerlink" title="为什么我的思路那么复杂"></a>为什么我的思路那么复杂</h2><p>看了<a href="https://github.com/shootfirst/CS144/">感恩</a>的代码，我发现我俩的大题思路其实差不多是一模一样的，都是先进行两轮的区间合并，然后再处理但为啥我看起来就那么复杂呢？</p>
<p>一是题意理解问题。</p>
<p>我发现他对<code>_capacity</code>的理解跟我的理解不一样emmm……</p>
<p>额好像怪我没认真看指导书的图。</p>
<p><img src="/2023/02/25/cs144/image-20230225232723083-1677339210527-2.png" alt="image-20230225232723083-1677339210527-2"></p>
<p>我理解的capacity：绿色部分和红色部分的净含量</p>
<p>似乎是真正的capacity：绿色部分+红色部分+空部分？？也就是说capacity只是一个跟index差不多的索引下标？？…………</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// out of bound</span></span><br><span class="line"><span class="keyword">if</span> (start &gt;= hope_to_rec + _capacity - _output.<span class="built_in">buffer_size</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说我能过测试是因为偶然吗？？</p>
<p>我其实感觉正确理解的capacity意义好怪啊，这怎么就能节省内存了呢？我觉得我理解的反而比较有道理（倔强）</p>
<p>笑一笑算了家人们。总之先这么写吧，以后的实验寄掉了再回来改。</p>
<blockquote>
<p>UPDATE: 确实寄掉了，并且已经改过来了，也不复杂，只需要添加对<code>right</code>边界的处理就行。【指去掉超出<code>start+capacity</code>的部分。】</p>
</blockquote>
<p>二是代码规范问题。</p>
<p>首先他代码规范性强，看起来非常舒服。其次他会用类似<code>upper_bound()</code>这样的函数（反观我压根没想起来），这样就显得比我的循环简洁了很多很多。</p>
<p>首先他的代码规范确实做得很好</p>
<p>第二他还会用upper_bound这样的函数（反观我压根没想起来），这样就显得比我的清除很多。</p>
<p>三是设计问题。</p>
<p>他用的是<code>map</code>我用的是<code>set</code>。确实是map比较合理，它既有find功能也兼具了有序的特性。</p>
<h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>我们要做的，是将零散的数据包拼接成完整的字节流，并且将整流过的数据送入<code>ByteStream</code>中，这通过核心函数<code>push_substring</code>实现。我们可以先来看看<code>push_substring</code>的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>;</span><br></pre></td></tr></table></figure>

<p><code>data</code>为数据包，<code>index</code>为<code>data</code>中第一个字符在整个字节流的下标，<code>eof</code>用来标识这是字节流的最后一个数据包。</p>
<blockquote>
<p>详细说明：</p>
<p>比方说有字节流“abcdefg”，则合法的参数对有如：{“abc”,0,0},{“cdef”,2,0},{“g”,6,1}</p>
</blockquote>
<p>通俗来说，我们这个函数的功能就是，把一堆起始下标为<code>index</code>的<code>data</code>（无序、可能重叠）拼接为一个完整的字节流。</p>
<p>听起来有没有觉得很耳熟？是的，我认为这正是“区间合并”问题。我接下来便通过区间合并的思想，对问题进行如下数据结构以及算法的设计。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h4><p>由于是区间合并问题，所以就先需要定义区间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> left;   <span class="comment">// 当前data位于总体的左index（闭）</span></span><br><span class="line">    <span class="type">size_t</span> right;  <span class="comment">// 右index（开）</span></span><br><span class="line">    string data;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;b) <span class="type">const</span> &#123; <span class="keyword">return</span> left &lt; b.left; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>我们需要维护一个左端点升序的区间集合，故使用内部红黑树实现的有序集合set。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;node&gt; buffer;   <span class="comment">// 存储结构</span></span><br></pre></td></tr></table></figure>

<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>我们要做的，是对数据包进行整流，并且把整流过的部分输送到<code>ByteStream</code>中。由于存储结构存在<code>_capacity</code>的上限，因而，我们需要尽可能早地把存储结构中已经整流好的数据送入<code>ByteStream</code>中。</p>
<p>那么，如何定义“已经整流好的数据”呢？它需要满足跟“之前已经整流好了的数据”的有序性，也即，比方说[0,1000]已经整流完毕送入app，那么下一个送入app的数据一定满足<code>index=1001</code>。</p>
<p>因而，我们可以维护一个变量<code>left_bound</code>，表示下一个将被app接受的数据的index（如上例的1001）。为了达到“尽早”目的，我们需要在每次<code>push_substring</code>执行完区间合并之后，检查<code>buffer</code>的第一个区间的左端点是否与<code>left_bound</code>相等，是的话则将第一个区间写入<code>ByteStream</code>，不是的话就什么也不做。</p>
<p>因而，在<code>push_substring</code>中，对于一个新来的数据包，我们大致需要进行以下几步：</p>
<ol>
<li>将参数所给的区间( <code>[index, index+data.length())</code> )并入区间集合<code>buffer</code>中</li>
<li>查看是否需要<code>ByteStream</code></li>
</ol>
<h4 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h4><h5 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h5><p>问题可抽象为：</p>
<blockquote>
<p>给定一个有序区间集合<code>buffer</code>，以及一个小区间<code>node</code>，你需要把<code>node</code>塞进<code>buffer</code>里。</p>
<p>Example： buffer = {[1,3),[5,7)} , node = [6,8) 输出：buffer = {[1,3), [5,8)}</p>
</blockquote>
<h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><p>判断区间重叠统一只检查左端点。注意，两次重叠的判断条件不一样，是因为相对性发生了改变。第一次相当于node的左端点在buffer[i]中，第二次相当于buffer[i]的左端点在node中。</p>
<ol>
<li><p>对<code>buffer</code>进行第一轮扫描</p>
<p>如果node与buffer[i]产生重叠（<code>(left &gt;= it-&gt;left &amp;&amp; left &lt;= it-&gt;right)</code>），那么更新node为node∪buffer[i]，并且将buffer[i]从buffer中删去。</p>
<p>在第一次找到重叠的区间，就应该break退出第一轮循环。</p>
</li>
<li><p>对<code>buffer</code>进行第二轮扫描</p>
<p>如果node与buffer[i]产生重叠（<code> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right)</code>），那么更新node为node∪buffer[i]，并且将buffer[i]从buffer中删去。</p>
</li>
</ol>
<p>我们在合并区间时，不仅需要对<code>struct node</code>的左端点<code>left</code>和右端点<code>right</code>进行更新，还需要对其数据域<code>data</code>也进行合并拼接。我们维护变量<code>res</code>作为维护的目标区间的数据域。对于res，我们应该进行如下操作：</p>
<ol>
<li><p>初始化为data</p>
</li>
<li><p>除去[left, left_bound)这一区间内的数据</p>
<p>这部分数据我们已经整流过并且写入<code>ByteStream</code></p>
</li>
<li><p>在两轮合并中对其进行正确拼接</p>
</li>
</ol>
<h5 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h5><p><img src="/2023/02/25/cs144/image-20230225200605175.png" alt="image-20230225200605175"></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> left = index, right = index + data.<span class="built_in">length</span>();  <span class="comment">// 初始化左右区间</span></span><br><span class="line"><span class="type">size_t</span> o_left = left, o_right = right;               <span class="comment">// keep the original value</span></span><br><span class="line">node tmp = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right &lt; left_bound)	<span class="keyword">return</span>;                <span class="comment">// must be duplicated</span></span><br><span class="line">left = left &lt; left_bound ? left_bound : left;  <span class="comment">// 左边已经接受过的数据就不要了</span></span><br><span class="line">string res = data.<span class="built_in">substr</span>(left - o_left, right - left);<span class="comment">// 掐头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开始区间合并。需要扫描两次 */</span></span><br><span class="line"><span class="comment">// 第一次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= it-&gt;left &amp;&amp; left &lt;= it-&gt;right) &#123; <span class="comment">// 区间重叠</span></span><br><span class="line">        <span class="type">size_t</span> r = right,l = left;</span><br><span class="line">        <span class="comment">// 更新左右端点</span></span><br><span class="line">        right = <span class="built_in">max</span>(right, it-&gt;right);</span><br><span class="line">        left = <span class="built_in">min</span>(left, it-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= it-&gt;right) <span class="comment">// 如果目标区间被包裹在it内</span></span><br><span class="line">            <span class="comment">// res需要更新为it头+data掐头后的全长+it尾，也即将it中间重叠部分用data替换</span></span><br><span class="line">            res = it-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, l - it-&gt;left) + data.<span class="built_in">substr</span>(l - o_left) +</span><br><span class="line">            it-&gt;data.<span class="built_in">substr</span>(r - it-&gt;left, it-&gt;right - r);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            res = it-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, l - it-&gt;left) + data.<span class="built_in">substr</span>(l - o_left);</span><br><span class="line">        <span class="comment">// 删除原来的结点</span></span><br><span class="line">        buffer.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;right &lt;= right);<span class="comment">// it这个区间被包含在目标区间内，则什么也不做</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 需要加上it的尾</span></span><br><span class="line">            res += it-&gt;data.<span class="built_in">substr</span>(right - it-&gt;left, it-&gt;right - right);</span><br><span class="line">            <span class="comment">// 更新右端点</span></span><br><span class="line">            right = it-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        buffer.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将维护区间插入区间集合</span></span><br><span class="line">tmp = &#123;left, right, res&#125;;</span><br><span class="line">buffer.<span class="built_in">insert</span>(tmp);</span><br></pre></td></tr></table></figure>

<h4 id="写入ByteStream"><a href="#写入ByteStream" class="headerlink" title="写入ByteStream"></a>写入<code>ByteStream</code></h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>我们需要检查buffer内的第一个区间，如果其左端点与left_bound相等，则把第一个区间填入<code>ByteStream</code>，然后更新left_bound，从buffer中删去该区间；如果不相等（只可能是left &gt; left_bound）则什么也不做。</p>
<p>在把区间数据填入<code>ByteStream</code>的过程中，可能造成<code>ByteStream</code>满。因而我们就只能填入第一个区间内的一部分数据，更新left_bound，将第一个区间的剩余数据继续存在buffer中。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> iterator = buffer.<span class="built_in">begin</span>();  </span><br><span class="line">iterator = buffer.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// write into the ByteStream</span></span><br><span class="line"><span class="keyword">if</span> (iterator != buffer.<span class="built_in">end</span>() &amp;&amp; iterator-&gt;left == left_bound) &#123;</span><br><span class="line">    <span class="comment">// 防止_output的容量超过</span></span><br><span class="line">    <span class="type">size_t</span> out_rem = _output.<span class="built_in">remaining_capacity</span>();</span><br><span class="line">    <span class="keyword">if</span> (out_rem &lt; iterator-&gt;data.<span class="built_in">length</span>()) &#123; <span class="comment">// ByteStream剩余容量小于第一个区间长度</span></span><br><span class="line">        _output.<span class="built_in">write</span>(iterator-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, out_rem));<span class="comment">// 写入尽量多数据</span></span><br><span class="line">        left_bound = iterator-&gt;left + out_rem;<span class="comment">// 更新左边界</span></span><br><span class="line">        <span class="comment">// 由于iterator只读，因而我们不能直接修改其左端点和data域</span></span><br><span class="line">        tmp = &#123;left_bound, iterator-&gt;right, iterator-&gt;data.<span class="built_in">substr</span>(out_rem)&#125;;</span><br><span class="line">        buffer.<span class="built_in">erase</span>(iterator);</span><br><span class="line">        buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _output.<span class="built_in">write</span>(iterator-&gt;data);</span><br><span class="line">        left_bound = iterator-&gt;right;</span><br><span class="line">        buffer.<span class="built_in">erase</span>(iterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="buffer的最大容量-capacity"><a href="#buffer的最大容量-capacity" class="headerlink" title="buffer的最大容量_capacity"></a>buffer的最大容量_capacity</h4><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>维护“存储结构的容量不超过capacity”这个不变性条件可以说是这个实验最恶心最难的地方……也正是它，让我的代码写成了一坨shit山（）</p>
<p>为什么说它最难最恶心呢？其实它本来也许不算难，但在这个思路下想要保持这个不变性条件，就显得非常地困难。</p>
<p>一开始没过脑子的时候，我觉得这样就行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(data.<span class="built_in">length</span>() + <span class="built_in">unassemble_bytes</span>() &gt; capacity)	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样很明显有两个问题。</p>
<p>一是就算你超过了，你也不能直接丢弃掉data，得把没超过的部分填满。</p>
<p>二是，<code>data.length() + unassemble_bytes()</code>有时，甚至是很多时候，都不会是将data并入buffer之后buffer的容量。因为data和buffer很大概率会存在重叠区间。</p>
<p>那么，你能不能在区间合并完之后，再进行该不变性条件的判断，并且将没超过的部分填满，超过的部分丢弃呢？</p>
<p>答案是，也不能。因为经过两轮合并，你的data和buffer里原有的数据早已你中有我我中有你了，你无法在最后将它们分开，找出data超过capacity的数据并且丢弃它。</p>
<p>因而，头尾都不行的话，唯一的答案就是，<strong>我们只能在两轮区间合并中途，去时刻追踪当前容量是否超过capacity</strong>。</p>
<p>这听起来就令人十分地头大。但事实证明，并不是无法实现的，坚持下去，就算是shit山也能跑起来（）下面便是我的实现思路。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>维护一个变量<code>remaining</code>，表示当前还有多少容量。维护<code>start</code>，表示未判断是否可以写入buffer的数据起点。我们要做的事：</p>
<ol>
<li>初始化remaining为capacity - 当前容量，start为掐头后的left</li>
<li>在第一轮循环中更新start</li>
<li>在第二轮循环中通过start和remaining来判断是否能够写入buffer。尽可能多地写入，把写入不了的部分丢弃。</li>
</ol>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>下面举个例子来说明整个流程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">initial:  </span><br><span class="line">buffer = &#123; [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">5</span>,<span class="number">8</span>],[<span class="number">10</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>] &#125; , capacity = <span class="number">12</span>, remaining = <span class="number">12</span><span class="number">-9</span>=<span class="number">3</span>, data = [<span class="number">2</span>,<span class="number">11</span>], start = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>start为2，是因为data的从2开始的这段数据还不知道能不能被成功存入buffer中。</p>
<p>第一次合并后，buffer = { [5,8],[10,12],[13,14] } ，data=[1,11]，start = 3.</p>
<p>start为3，是因为[2,11]与[1,3]合并，由于[2,3]这段本来就在buffer中，因而可以不用占用remaining，但从3开始这段数据还不知道能不能成功存入buffer中。</p>
<p>在第二轮合并中，首先扫描到[5,8]。由于[start,it-&gt;left]也即[3,5]这段数据长度为2&lt;remaining=3，故而这段数据可以存入buffer，remaining更新为3-2=1，start更新为it-&gt;right=8.</p>
<p>/*</p>
<p>注意，此处无需再对[9,10]进行同样的操作。对于这种情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">buffer = &#123; [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">5</span>,<span class="number">8</span>] &#125; , capacity = <span class="number">12</span>, remaining = <span class="number">12</span><span class="number">-9</span>=<span class="number">3</span>, data = [<span class="number">2</span>,<span class="number">11</span>], start = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>在循环结束的这里已经处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (remaining &lt; right - start) &#123;</span><br><span class="line">    right = remaining + start;</span><br><span class="line">    <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">        is_eof = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*/</p>
<p>然后扫描到[10,12]。由于[start,it-&gt;left]也即[8,10]这段数据长度为2&gt;remaining=1，故而这段数据只能把[8,9]这部分存入buffer。因而，我们把到此为止的[1,9]结点存入buffer，剩下的[10,11]部分直接丢弃，也即直接跳入到最后的写入<code>ByteStream</code>部分。</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> remaining = _capacity - <span class="built_in">unassembled_bytes</span>();  <span class="comment">// how much room left?</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> left = index, right = index + data.<span class="built_in">length</span>();  <span class="comment">// 初始化左右区间</span></span><br><span class="line">    <span class="type">size_t</span> o_left = left, o_right = right;               <span class="comment">// keep the original value</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> start = left;  <span class="comment">// the begin of the unused data-zone of variable data</span></span><br><span class="line">    <span class="comment">// if(remaining == 0)	goto end; // buffer满</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始区间合并。需要扫描两次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= it-&gt;left &amp;&amp; left &lt;= it-&gt;right) &#123;</span><br><span class="line">            right = <span class="built_in">max</span>(right, it-&gt;right);</span><br><span class="line">            left = <span class="built_in">min</span>(left, it-&gt;left);</span><br><span class="line">            <span class="comment">// 说明目标区间完全被包裹，也即目标区间一定可以塞进buffer中</span></span><br><span class="line">            <span class="keyword">if</span> (right == it-&gt;right) 	start = o_right;</span><br><span class="line">            <span class="comment">// 说明仅仅部分重叠，去重部分从it-&gt;right开始</span></span><br><span class="line">            <span class="keyword">else</span>	start = it-&gt;right;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 比remaining满</span></span><br><span class="line">            <span class="comment">// 第一个条件是为了防止unsigned溢出</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;left &gt; start &amp;&amp; remaining &lt; it-&gt;left - start) &#123;</span><br><span class="line">                <span class="comment">// 截取能塞得下的部分</span></span><br><span class="line">                tmp = &#123;left, start + remaining, res.<span class="built_in">substr</span>(<span class="number">0</span>, start - left + remaining)&#125;;</span><br><span class="line">                remaining = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 此时塞进去是肯定不重叠的，因为tmp.right &lt; it-&gt;left</span></span><br><span class="line">                buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">                <span class="comment">// 剩下的直接丢弃</span></span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 塞得下</span></span><br><span class="line">            remaining -= it-&gt;left - start;</span><br><span class="line">            start = it-&gt;right;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界处理</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt; right - start) &#123;</span><br><span class="line">        <span class="comment">// 扔掉塞不下的部分</span></span><br><span class="line">        right = remaining + start;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = &#123;left, right, res&#125;;</span><br><span class="line">    buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    iterator = buffer.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// write into the ByteStream</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="capacity还没结束"><a href="#capacity还没结束" class="headerlink" title="capacity还没结束"></a>capacity还没结束</h4><h5 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h5><p>你以为做到上面那个小标题那样就万无一失了吗？答案是，并不！</p>
<p>我们还有哪里想得不周全呢？考虑这样一个案例，<code>ByteStream</code>未满，但是在更新remaining时发现buffer已满塞不下了。这时候，我们上面的做法是直接扔掉塞不下的部分。但其实，我们还可以查看buffer的一部分数据是否能够再塞进<code>ByteStream</code>，如果能的话，就又能省下一笔空间了！</p>
<p>所以，我们在发现remaining不够时，应该首先检查能不能塞一部分buffer的数据进入<code>ByteStream</code>中用来腾出空间。</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 比remaining满</span></span><br><span class="line">        <span class="comment">// 第一个条件是为了防止unsigned溢出</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;left &gt; start &amp;&amp; remaining &lt; it-&gt;left - start) &#123;</span><br><span class="line">            <span class="comment">// 先看看能不能塞进ByteStream腾空间。需要满足两个条件</span></span><br><span class="line">            <span class="comment">// buffer的第一个区间正好是left_bound</span></span><br><span class="line">            <span class="keyword">if</span> (left == left_bound) &#123;</span><br><span class="line">                <span class="type">size_t</span> out_mem = _output.<span class="built_in">remaining_capacity</span>();</span><br><span class="line">                <span class="comment">// ByteStream有位置</span></span><br><span class="line">                <span class="keyword">if</span> (out_mem &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 腾出的空间很充足，完全可以不改变remaining</span></span><br><span class="line">                    <span class="keyword">if</span> (out_mem &gt;= it-&gt;left - start) &#123;</span><br><span class="line">                        <span class="comment">// 写入ByteStream</span></span><br><span class="line">                        _output.<span class="built_in">write</span>(res.<span class="built_in">substr</span>(<span class="number">0</span>, it-&gt;left - start));</span><br><span class="line">                        <span class="comment">// 更新</span></span><br><span class="line">                        res = res.<span class="built_in">substr</span>(it-&gt;left - start);</span><br><span class="line">                        left_bound = it-&gt;left - start + left;</span><br><span class="line">                        left = left_bound;</span><br><span class="line">                        <span class="comment">// 加上腾出的空间【在ok标签处减掉】</span></span><br><span class="line">                        remaining += it-&gt;left-start;</span><br><span class="line">                        <span class="keyword">goto</span> ok;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 空间不足以完全不改变remaining</span></span><br><span class="line">                        _output.<span class="built_in">write</span>(res.<span class="built_in">substr</span>(<span class="number">0</span>, out_mem));</span><br><span class="line">                        res = res.<span class="built_in">substr</span>(out_mem);</span><br><span class="line">                        left_bound = out_mem + left;</span><br><span class="line">                        left = left_bound;</span><br><span class="line">                        <span class="comment">// 加上腾出的空间</span></span><br><span class="line">                        remaining += out_mem;</span><br><span class="line">                        <span class="comment">// 如果两个加起来就行，则ok</span></span><br><span class="line">                        <span class="keyword">if</span>(it-&gt;left&gt;start &amp;&amp; remaining&gt;=it-&gt;left - start)&#123;</span><br><span class="line">                                <span class="keyword">goto</span> ok;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 否则remaining依然不充足</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 截取能塞得下的部分</span></span><br><span class="line">            tmp = &#123;left, start + remaining, res.<span class="built_in">substr</span>(<span class="number">0</span>, start - left + remaining)&#125;;</span><br><span class="line">            remaining = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 此时塞进去是肯定不重叠的，因为tmp.right &lt; it-&gt;left</span></span><br><span class="line">            buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">            <span class="comment">// 剩下的直接丢弃</span></span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    ok:</span><br><span class="line">        <span class="comment">// 塞得下</span></span><br><span class="line">        remaining -= it-&gt;left - start;</span><br><span class="line">        start = it-&gt;right;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h5><p>因而，在一开始发现remaining满的时候，不能直接goto end。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if(remaining == 0)	goto end; // buffer满</span></span><br></pre></td></tr></table></figure>

<p>因为还得看看<code>ByteStream</code>能不能腾空间。</p>
<h4 id="eof"><a href="#eof" class="headerlink" title="eof"></a>eof</h4><p>对于eof的处理也是需要注意的一个小细节。</p>
<p>我们不能这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (eof)</span><br><span class="line">    _output.<span class="built_in">end_input</span>();</span><br></pre></td></tr></table></figure>

<p>原因有二，一是最后一个数据包有可能是部分丢失，二是整流可能还未结束。</p>
<p>所以我们应该在成员变量中维护<code>is_eof</code>，记录是否收到过最后一个数据包，并且在最后一个数据包部分丢失的时候置它为false。当且仅当<code>is_eof == true</code>且buffer非空时，才能说明输入结束。</p>
<p>相关代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">        is_eof = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 第二次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 此时空间不够，先尝试下能不能写入一部分到_output中</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;left &gt; start &amp;&amp; remaining &lt; it-&gt;left - start) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                tmp = &#123;left, start + remaining, res.<span class="built_in">substr</span>(<span class="number">0</span>, start - left + remaining)&#125;;</span><br><span class="line">                remaining = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">                    is_eof = <span class="literal">false</span>;</span><br><span class="line">                buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">        ok:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (remaining &lt; right - start) &#123;</span><br><span class="line">        right = remaining + start;</span><br><span class="line">        <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">            is_eof = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">end:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 满足两个条件才是真的eof</span></span><br><span class="line">    <span class="keyword">if</span> (is_eof &amp;&amp; buffer.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        is_eof = <span class="literal">false</span>;</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><h3 id="头文件声明"><a href="#头文件声明" class="headerlink" title="头文件声明"></a>头文件声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StreamReassembler</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> left;   <span class="comment">// 当前data位于总体的左index（闭）</span></span><br><span class="line">        <span class="type">size_t</span> right;  <span class="comment">// 右index（开）</span></span><br><span class="line">        string data;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;b) <span class="type">const</span> &#123; <span class="keyword">return</span> left &lt; b.left; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">bool</span> is_eof;        <span class="comment">// 文件的末尾是否接收成功</span></span><br><span class="line">    <span class="type">size_t</span> left_bound;  <span class="comment">// 当前已经成功接收到left_bound之前的数据</span></span><br><span class="line">    set&lt;node&gt; buffer;   <span class="comment">// 存储结构</span></span><br><span class="line"></span><br><span class="line">    ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// used by the TCPReceiver</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_is_eof</span><span class="params">()</span> </span>&#123; is_eof = <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stream_reassembler.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">StreamReassembler::<span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity)</span><br><span class="line">    : <span class="built_in">is_eof</span>(<span class="literal">false</span>), <span class="built_in">left_bound</span>(<span class="number">0</span>), <span class="built_in">buffer</span>(), _output(capacity), _capacity(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">        is_eof = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> unass = <span class="built_in">unassembled_bytes</span>();</span><br><span class="line">    <span class="type">size_t</span> remaining = _capacity &gt; unass ? _capacity - unass : <span class="number">0</span>;  <span class="comment">// how much room left?</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> left = index, right = index + data.<span class="built_in">length</span>();  <span class="comment">// 初始化左右区间</span></span><br><span class="line">    <span class="type">size_t</span> o_left = left, o_right = right;               <span class="comment">// keep the original value</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = buffer.<span class="built_in">begin</span>();                 <span class="comment">// 这些变量在这里声明是为了防止后面goto报错</span></span><br><span class="line">    node tmp = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &lt; left_bound)	<span class="keyword">return</span>;                <span class="comment">// must be duplicated</span></span><br><span class="line">    left = left &lt; left_bound ? left_bound : left;  <span class="comment">// 左边已经接受过的数据就不要了</span></span><br><span class="line">    right = right &lt;= left_bound + _capacity ? right : left_bound + _capacity;  <span class="comment">// 右边越界的也不要</span></span><br><span class="line">    o_right = right;</span><br><span class="line">    string res = data.<span class="built_in">substr</span>(left - o_left, right - left);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> start = left;  <span class="comment">// the begin of the unused data-zone of variable data</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">compare</span>(<span class="string">&quot;&quot;</span>) == <span class="number">0</span> || res.<span class="built_in">compare</span>(<span class="string">&quot;&quot;</span>) == <span class="number">0</span>)	<span class="keyword">goto</span> end;  <span class="comment">// 如果data是空串也直接不要</span></span><br><span class="line">    <span class="keyword">if</span> (o_left &gt;= left_bound + _capacity)	<span class="keyword">goto</span> end;  <span class="comment">// 越界的不要</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始区间合并。需要扫描两次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= it-&gt;left &amp;&amp; left &lt;= it-&gt;right) &#123;</span><br><span class="line">            <span class="type">size_t</span> r = right;</span><br><span class="line">            <span class="type">size_t</span> l = left;</span><br><span class="line">            right = <span class="built_in">max</span>(right, it-&gt;right);</span><br><span class="line">            left = <span class="built_in">min</span>(left, it-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (right == it-&gt;right) &#123;</span><br><span class="line">                start = o_right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = it-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r &lt;= it-&gt;right) &#123;</span><br><span class="line">                res = it-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, l - it-&gt;left) + data.<span class="built_in">substr</span>(l - o_left) +</span><br><span class="line">                      it-&gt;data.<span class="built_in">substr</span>(r - it-&gt;left, it-&gt;right - r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = it-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, l - it-&gt;left) + data.<span class="built_in">substr</span>(l - o_left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除这一步很关键。</span></span><br><span class="line">            buffer.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 此时空间不够，先尝试下能不能写入一部分到_output中</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;left &gt; start &amp;&amp; remaining &lt; it-&gt;left - start) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == left_bound) &#123;</span><br><span class="line">                    <span class="type">size_t</span> out_mem = _output.<span class="built_in">remaining_capacity</span>();</span><br><span class="line">                    <span class="keyword">if</span> (out_mem &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// out的区域本身就很充足</span></span><br><span class="line">                        <span class="keyword">if</span> (out_mem &gt;= it-&gt;left - start) &#123;</span><br><span class="line">                            <span class="comment">// 写入ByteStream</span></span><br><span class="line">                            _output.<span class="built_in">write</span>(res.<span class="built_in">substr</span>(<span class="number">0</span>, it-&gt;left - start));</span><br><span class="line">                            <span class="comment">// 更新</span></span><br><span class="line">                            res = res.<span class="built_in">substr</span>(it-&gt;left - start);</span><br><span class="line">                            left_bound = it-&gt;left - start + left;</span><br><span class="line">                            left = left_bound;</span><br><span class="line">                            remaining += it-&gt;left - start;</span><br><span class="line">                            <span class="comment">// out剩下的空位会在最后写入</span></span><br><span class="line">                            <span class="keyword">goto</span> ok;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 光是out不够的话，那就先能腾多少空间腾多少</span></span><br><span class="line">                            _output.<span class="built_in">write</span>(res.<span class="built_in">substr</span>(<span class="number">0</span>, out_mem));</span><br><span class="line">                            res = res.<span class="built_in">substr</span>(out_mem);</span><br><span class="line">                            left_bound = out_mem + left;</span><br><span class="line">                            left = left_bound;</span><br><span class="line">                            remaining += out_mem;</span><br><span class="line">                            <span class="comment">// 如果腾出空间加上原来空间足够，那就非常ok</span></span><br><span class="line">                            <span class="keyword">if</span> (it-&gt;left &gt; start &amp;&amp; remaining &gt;= it-&gt;left - start) &#123;</span><br><span class="line">                                <span class="keyword">goto</span> ok;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 否则进入错误处理代码</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp = &#123;left, start + remaining, res.<span class="built_in">substr</span>(<span class="number">0</span>, start - left + remaining)&#125;;</span><br><span class="line">                remaining = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">                    is_eof = <span class="literal">false</span>;</span><br><span class="line">                buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">        ok:</span><br><span class="line">            remaining -= it-&gt;left - start;</span><br><span class="line">            start = it-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;right &gt; right)&#123;</span><br><span class="line">                res += it-&gt;data.<span class="built_in">substr</span>(right - it-&gt;left, it-&gt;right - right);</span><br><span class="line">                right = it-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (start &lt; o_right &amp;&amp; remaining &lt; o_right - start) &#123;</span><br><span class="line">        right = start + remaining;</span><br><span class="line">        <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">            is_eof = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = &#123;left, right, res&#125;;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    	buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    iterator = buffer.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// write into the ByteStream</span></span><br><span class="line">    <span class="keyword">if</span> (iterator != buffer.<span class="built_in">end</span>() &amp;&amp; iterator-&gt;left == left_bound) &#123;</span><br><span class="line">        <span class="type">size_t</span> out_rem = _output.<span class="built_in">remaining_capacity</span>();</span><br><span class="line">        <span class="keyword">if</span> (out_rem &lt; iterator-&gt;data.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            _output.<span class="built_in">write</span>(iterator-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, out_rem));</span><br><span class="line">            left_bound = iterator-&gt;left + out_rem;</span><br><span class="line">            tmp = &#123;left_bound, iterator-&gt;right, iterator-&gt;data.<span class="built_in">substr</span>(out_rem)&#125;;</span><br><span class="line">            buffer.<span class="built_in">erase</span>(iterator);</span><br><span class="line">            buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _output.<span class="built_in">write</span>(iterator-&gt;data);</span><br><span class="line">            left_bound = iterator-&gt;right;</span><br><span class="line">            buffer.<span class="built_in">erase</span>(iterator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 满足两个条件才是真的eof</span></span><br><span class="line">    <span class="keyword">if</span> (is_eof &amp;&amp; buffer.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        is_eof = <span class="literal">false</span>;</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">StreamReassembler::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以跟上面的write合起来的，但在此处我采取了最保守的做法。</span></span><br><span class="line">    <span class="type">size_t</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        res += it-&gt;right - it-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">empty</span>()&amp;&amp;is_eof; &#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Lab4   TCPConnection</title>
    <url>/2023/02/25/cs144$lab4/</url>
    <content><![CDATA[<h1 id="Lab4-TCPConnection"><a href="#Lab4-TCPConnection" class="headerlink" title="Lab4   TCPConnection"></a>Lab4   TCPConnection</h1><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="耗时情况"><a href="#耗时情况" class="headerlink" title="耗时情况"></a>耗时情况</h3><p>【长舒一口气】</p>
<p>最开始先记录下总体耗时情况吧。本次实验共耗费我16h+【不包括接下来写笔记的时间23333】，共耗费三个工作日。第一天看完了指导书，写完了代码，过掉了<code>#45 reorder</code>之前的所有测试。第二天过掉了<code>#55 t_ucS_1M_32k</code>之前的所有测试，直到第三天才过完了所有测试。</p>
<p>我觉得这整个过程还是挺有意义的，每天都有新的进展，看到test case越过越多是真的很高兴。但是可以说第二天以来就都是面向测试用例改bug了，非常折磨非常坐牢，既要去再次理清之前写过的shit山，又得搞清楚很多让人一头雾水不知从何下手的地方。但总之，这三天很充实，并不会让人觉得心累。</p>
<p>放个通关截图吧，感人至深。</p>
<p><img src="/2023/02/25/cs144/image-20230305160608116.png" alt="image-20230305160608116"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在<code>TCPConnection</code>中具体要做什么，指导书已经写得很详细了，跟着指导书就行。代码部分还是不折磨的，思路直观清晰。</p>
<h4 id="指导书内容"><a href="#指导书内容" class="headerlink" title="指导书内容"></a>指导书内容</h4><blockquote>
<p>Here are the basic rules the TCPConnection has to follow:</p>
</blockquote>
<ol>
<li><p><strong>Receiving segments</strong></p>
<p>大概是在<code>segment_received</code>中做</p>
<p><img src="/2023/02/25/cs144/image-20230303103640065.png" alt="image-20230303103640065"></p>
<ol>
<li><p>检查RST flag</p>
<p>如果RST被设置，sets <strong>both</strong> the inbound and outbound streams to the <strong>error state</strong>，杀死当前connection</p>
<p>return;</p>
<p>具体实现中，杀死connection可以置<code>_linger_after_streams_finish</code>为false。<code> the inbound and outbound streams</code>对应着receiver和sender里的stream。让它们都处于error状态，只需设置<code>ByteStream</code>中的error字段</p>
</li>
<li><p>如果收到的segment with an invalid sequence number，connection需要发送empty segment应答</p>
<p><img src="/2023/02/25/cs144/image-20230303110238265.png" alt="image-20230303110238265"></p>
</li>
<li><p>转发segment给receiver</p>
</li>
<li><p>如果ACK，则把ackno和win_size给sender</p>
</li>
</ol>
</li>
<li><p><strong>Sending segments</strong></p>
<ol>
<li>任何时候sender把segment放进其out流，你都要从中取出来</li>
<li>从receiver处获取ackno和window_size，填入segment中</li>
<li>放到自己的segment_out中</li>
</ol>
<p>从上述表述中，我们需要注意两点：</p>
<ol>
<li><p>顺带ACK</p>
<p>可以看到，这跟我们上课的时候所学的一样，是“顺带ACK”，也即ACK报文并非独立发送，而是在下一次要发送其他数据报文的时候携带发送。这也一定程度上使得ack报文发送不会太频繁也不会太稀疏。</p>
</li>
<li><p>一定要经由sender</p>
<p>我们如果想要发送一个报文，一定得先把它存入sender中，再从sender的segment_out中取出来。这样做的目的是把该报文列入sender的超时重传管辖范围，你如果直接把报文发送到自己的segment_out中，就无法管理其超时重传了</p>
</li>
</ol>
</li>
<li><p><strong>When time passes</strong></p>
<p>在<code>tick()</code>中</p>
<ol>
<li>调用sender的<code>tick()</code></li>
<li>检查sender的连续超时重传次数，如果大于<code>MAX RETX ATTEMPTS</code>，则关闭连接，并且发送RST标志的空报文</li>
<li>end the connection cleanly if necessary</li>
</ol>
</li>
</ol>
<p>再注意一点对于connection的关闭。它要求有一个time pass</p>
<p><img src="/2023/02/25/cs144/image-20230303111131650.png" alt="image-20230303111131650"></p>
<p><img src="/2023/02/25/cs144/image-20230303112817891.png" alt="image-20230303112817891"></p>
<p>第一点挺好实现的，第二点需要在析构函数中检测。</p>
<p>最后的5.1部分值得一看。</p>
<h4 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h4><p><code>TCPConnection</code>的public函数接口定义以及具体要做什么如下。结合上面的指导书内容，<code>TCPConnection</code>的实现就很简单了，我就不多bb了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   TCPConfig _cfg;</span><br><span class="line">   <span class="comment">// 一个endpoint可以同时作为sender和receiver。</span></span><br><span class="line">   TCPReceiver _receiver&#123;_cfg.recv_capacity&#125;;</span><br><span class="line">   TCPSender _sender&#123;_cfg.send_capacity, _cfg.rt_timeout, _cfg.fixed_isn&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! outbound queue of segments that the TCPConnection wants sent</span></span><br><span class="line">   <span class="comment">// 把要发送的segment放在这里就行了</span></span><br><span class="line">   std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Should the TCPConnection stay active (and keep ACKing)</span></span><br><span class="line">   <span class="comment">//! for 10 * _cfg.rt_timeout milliseconds after both streams have ended,</span></span><br><span class="line">   <span class="comment">//! in case the remote TCPConnection doesn&#x27;t know we&#x27;ve received its whole stream?</span></span><br><span class="line">   <span class="type">bool</span> _linger_after_streams_finish&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 也许需要调用TCPSender的fill_window()，然后从其segment_out中取出来，再发送给自己的segment_out</span></span><br><span class="line">   <span class="comment">// Initiate a connection by sending a SYN segment初始化connection并且发送SYN</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  这几个都很好实现，都很直观，只需调sender和receiver的API就行  */</span></span><br><span class="line">   <span class="comment">// 由上层socket调用，data路径 socket-&gt;connection-&gt;sender.stream_in().write()</span></span><br><span class="line">   <span class="comment">//! \brief Write data to the outbound byte stream, and send it over TCP if possible</span></span><br><span class="line">   <span class="comment">//! \returns the number of bytes from `data` that were actually written.</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;data)</span></span>;</span><br><span class="line">   <span class="comment">//! \returns the number of `bytes` that can be written right now.</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="comment">//! \brief Shut down the outbound byte stream (still allows reading incoming data)</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">end_input_stream</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//! \brief The inbound byte stream received from the peer</span></span><br><span class="line">   <span class="function">ByteStream &amp;<span class="title">inbound_stream</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">stream_out</span>(); &#125;</span><br><span class="line">   <span class="comment">// number of bytes sent and not yet acknowledged, counting SYN/FIN each as one byte</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">bytes_in_flight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="comment">//! \brief number of bytes not yet reassembled</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">unassembled_bytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief Number of milliseconds since the last segment was received</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// debug用</span></span><br><span class="line">   <span class="comment">//!&lt; \brief summarize the state of the sender, receiver, and the connection</span></span><br><span class="line">   <span class="function">TCPState <span class="title">state</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &#123;_sender, _receiver, <span class="built_in">active</span>(), _linger_after_streams_finish&#125;; &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这些函数都会由上层在某些时候调用</span></span><br><span class="line">   <span class="comment">// 时钟滴答、收到segment以及从segment_out中取数据，这些都是由os调用相应函数实现的</span></span><br><span class="line">   <span class="comment">// 这也正是所谓“协议”的接口意义！</span></span><br><span class="line">   <span class="comment">//! \name Methods for the owner or operating system to call</span></span><br><span class="line">   <span class="comment">//! Called when a new segment has been received from the network</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Called periodically when time elapses</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief TCPSegments that the TCPConnection has enqueued for transmission.</span></span><br><span class="line">   <span class="comment">//! \note The owner or operating system will dequeue these and</span></span><br><span class="line">   <span class="comment">//! put each one into the payload of a lower-layer datagram (usually Internet datagrams (IP),</span></span><br><span class="line">   <span class="comment">//! but could also be user datagrams (UDP) or any other kind).</span></span><br><span class="line">   <span class="function">std::queue&lt;TCPSegment&gt; &amp;<span class="title">segments_out</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _segments_out; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief Is the connection still alive in any way?</span></span><br><span class="line">   <span class="comment">//! \returns `true` if either stream is still running or if the TCPConnection is lingering</span></span><br><span class="line">   <span class="comment">//! after both streams have finished (e.g. to ACK retransmissions from the peer)</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">active</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Construct a new connection from a configuration</span></span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">TCPConnection</span><span class="params">(<span class="type">const</span> TCPConfig &amp;cfg)</span> : _cfg&#123;</span>cfg&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \name construction and destruction</span></span><br><span class="line">   <span class="comment">//! moving is allowed; copying is disallowed; default construction not possible</span></span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">TCPConnection</span>();  <span class="comment">//!&lt; destructor sends a RST if the connection is still open</span></span><br><span class="line">   <span class="built_in">TCPConnection</span>() = <span class="keyword">delete</span>;</span><br><span class="line">   <span class="built_in">TCPConnection</span>(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">   TCPConnection &amp;<span class="keyword">operator</span>=(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">   <span class="built_in">TCPConnection</span>(<span class="type">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">   TCPConnection &amp;<span class="keyword">operator</span>=(<span class="type">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>这部分暂时还不大明白，随便瞎写一点（）</p>
<p>首先是socket实现，似乎要涉及到对一些事件，比如说<code>segment receive</code>的监听。它具体是这么做的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_helper/tcp_sponge_socket.cc  _initialize_TCP()</span></span><br><span class="line">    <span class="comment">// Set up the event loop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are four possible events to handle:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 1) Incoming datagram received (needs to be given to</span></span><br><span class="line">    <span class="comment">//    TCPConnection::segment_received method)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 2) Outbound bytes received from local application via a write()</span></span><br><span class="line">    <span class="comment">//    call (needs to be read from the local stream socket and</span></span><br><span class="line">    <span class="comment">//    given to TCPConnection::data_written method)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 3) Incoming bytes reassembled by the TCPConnection</span></span><br><span class="line">    <span class="comment">//    (needs to be read from the inbound_stream and written</span></span><br><span class="line">    <span class="comment">//    to the local stream socket back to the application)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 4) Outbound segment generated by TCP (needs to be</span></span><br><span class="line">    <span class="comment">//    given to underlying datagram socket)</span></span><br></pre></td></tr></table></figure>

<p>比如说event4：</p>
<p><img src="/2023/02/25/cs144/image-20230304171810877.png" alt="image-20230304171810877"></p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_61233877/article/details/124349171">什么是eventloop</a></p>
<p>事件循环（event loop）就是 任务在主线程不断进栈出栈的一个循环过程。任务会在将要执行时进入主线程，在执行完毕后会退出主线程。</p>
<p>这里的大致意思就是增加了一个监听事件，一旦tcp_connection的segments_out有元素，就会马上取出来</p>
</blockquote>
<p>这部分不大懂，不知道后面会不会涉及对socket的编写？</p>
<p>还有一点是对测试脚本好像有了点了解。比如在<code>build/CTestTestfile.cmake</code>中可以看到每个测试的对应脚本以及使用的options：</p>
<p><img src="/2023/02/25/cs144/image-20230304170132380.png" alt="image-20230304170132380"></p>
<p>如果不知道option的用法可以这么做：</p>
<p><img src="/2023/02/25/cs144/image-20230305232621024.png" alt="image-20230305232621024"></p>
<p>这些脚本实现的对应代码在<code>sponge/apps</code>中。</p>
<p>又比如，在<code>sponge/etc/tests.cmake</code>中，可以找到各个测试程序执行的参数，就可以比如说修改测试的Timeout时间：</p>
<p><img src="/2023/02/25/cs144/image-20230305232913611.png" alt="image-20230305232913611"></p>
<h3 id="总结：状态机"><a href="#总结：状态机" class="headerlink" title="总结：状态机"></a>总结：状态机</h3><p>我们已经完整实现了整个TCP协议，是时候该对其做出一个总结了。</p>
<p>TCP协议本质上是一个<strong>状态机</strong>。</p>
<p>在我们的sponge TCP中，我们将一个endpoint的TCP协议分成了两个状态机，一个是<code>TCPReceiver</code>的状态机，另一个是<code>TCPSender</code>的状态机。它们依据外界的输入【从app或者互联网】来进行状态的转移。</p>
<p>以下几张图完美地体现了状态转移关系【具体的状态体现标注在代码中了】：</p>
<p><img src="/2023/02/25/cs144/image-20230226200935395.png" alt="image-20230226200935395"></p>
<p><img src="/2023/02/25/cs144/image-20230226202631406.png" alt="image-20230226202631406"></p>
<p><img src="/2023/02/25/cs144/image-20230305225738049.png" alt="image-20230305225738049"></p>
<p><img src="/2023/02/25/cs144/image-20230225232723083-1678028236763-1.png" alt="image-20230225232723083"></p>
<p>而<code>TCPConnection</code>并不是状态机，它是两个状态机和外界联通的<u>桥梁</u>。它的职能有：</p>
<ol>
<li><p>给状态机提供输入</p>
<p>包括：</p>
<ol>
<li>app调用<code>write</code>传进来的数据</li>
<li>peer通过<code>segment_received</code>传进来的数据</li>
</ol>
</li>
<li><p>处理状态机的输出</p>
<p>包括：</p>
<ol>
<li>app调用receiver的stream接口获取数据</li>
<li>通过<code>send_segment</code>向peer传递数据</li>
</ol>
</li>
</ol>
<p>也可以说，它具有显式推动状态机状态转移的作用，比如说：</p>
<ol>
<li>给状态机传递外界数据让他们转移</li>
<li><code>connect</code>通过调用<code>fill_window</code>推动<code>_sender</code>从CLOSED状态转移到SYN_SENT状态</li>
<li>转移到ERROR状态的条件判断</li>
</ol>
<p>等等等。</p>
<p>也因而，<code>TCPConnection</code>并不包含复杂的逻辑和算法，它仅仅是做一些条件判断，以及一些数据转发的工作。</p>
<h3 id="喜闻乐见的bug合集"><a href="#喜闻乐见的bug合集" class="headerlink" title="喜闻乐见的bug合集"></a>喜闻乐见的bug合集</h3><p>相比于代码的编写，本次实验最难的部分是测试。由于lab4基于lab0-3，因而前面没有发现的bug在本次黑压压162个测试之下会全部涌现出来。有些bug我还是不知道怎么回事，并且debug过程也不像xv6那样条理清晰步步为营，感觉充满着不少玄幻色彩，所以<strong>也没有很多干货好说</strong>。在这里就先记录下印象比较深刻，耗时比较久的bug吧。</p>
<h4 id="TCP-produced-‘ackno-1’"><a href="#TCP-produced-‘ackno-1’" class="headerlink" title="TCP produced ‘ackno=1’"></a>TCP produced ‘ackno=1’</h4><p><img src="/2023/02/25/cs144/image-20230303214944132.png" alt="image-20230303214944132"></p>
<p>需要发送一个ackno=2的帧，但是不知道为什么却发送了一个ackno=1的，并且无论我怎么找，在哪里print，都只能找到一个ackno=2的，连1的影子都看不到。这个现象确实很诡异，但其实它的内因很简单。它是由于我对空的ACK帧发送条件限制得不恰当才出现的。</p>
<blockquote>
<p>有没有觉得这里有点跳跃？我是怎么通过这个现象得知是ACK发送不恰当导致的？</p>
<p>答案是我当时也没想到这一点，无头苍蝇般转了可能有一个小时，这里print一下那里print一下都没有发现异常。最后我放弃了这个用例去看下一个错误的用例，才发现了这个小bug，改了一下发现这个也一起过了【绷】</p>
</blockquote>
<p>本来我是这么写的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把_sender的所有segment都发送出去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当没有要发送的帧，无法进行顺带ACK时，就只能发送一个只有ACK的空帧</span></span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            _sender.<span class="built_in">send_empty_ack_segment</span>(_receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in segment_received()</span></span><br><span class="line">    <span class="comment">//if (seg.length_in_sequence_space() != 0) &#123;</span></span><br><span class="line">    <span class="comment">//    empty_ack_send();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br></pre></td></tr></table></figure>

<p>如果这么写的话，当这台endpoint收到peer的一个empty ACK后，它就也会以示敬意回复一个empty ACK，这样除了本应发过去的ackno=2的报文，就多了个幽灵般的ackno=1的empty ACK，从而导致上面的错误。</p>
<p>因而，正确的做法是，我们在receive时只对**!empty**的seg进行ACK回复就行。具体写法可以看看我下面的代码。</p>
<h4 id="超时重传时间翻倍问题"><a href="#超时重传时间翻倍问题" class="headerlink" title="超时重传时间翻倍问题"></a>超时重传时间翻倍问题</h4><p><img src="/2023/02/25/cs144/image-20230303224104016.png" alt="image-20230303224104016"></p>
<p><img src="/2023/02/25/cs144/image-20230303224053277.png" alt="image-20230303224053277"></p>
<p>可以看到，它是想要我们在1000ms后再发一次FIN的，也即rto依然等于1000，但是我们的rto却是2000.为啥呢？那就去看看超时重传呗。</p>
<p>原来的超时重传代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_sender.cc</span></span><br><span class="line"><span class="keyword">if</span> (timer_start &amp;&amp; ticks &gt; timer_ticks &amp;&amp; ticks - timer_ticks &gt;= rto) &#123;</span><br><span class="line">    <span class="comment">// resend</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(tmp_segments.<span class="built_in">front</span>().segment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (window_size != <span class="number">0</span>) &#123;</span><br><span class="line">        cons_retran++;</span><br><span class="line">        rto *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer_ticks = ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改完后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (timer_start &amp;&amp; ticks &gt; timer_ticks &amp;&amp; ticks - timer_ticks &gt;= rto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tmp_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// resend</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(tmp_segments.<span class="built_in">front</span>().segment);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (window_size != <span class="number">0</span>) &#123;</span><br><span class="line">            cons_retran++;</span><br><span class="line">            rto *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    timer_ticks = ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想想超时重传的定义，是不是重传了之后才会double时间呀（）</p>
<h4 id="assembler"><a href="#assembler" class="headerlink" title="assembler"></a>assembler</h4><p><img src="/2023/02/25/cs144/image-20230304163111298.png" alt="image-20230304163111298"></p>
<p>这个test花了我半个下午的时间排查和修改。大致流程及报错信息是，一方发了65000个byte，但是另一方只能收到&lt;&lt;65000个。最后print了一下，发现是<code>streamassembler</code>写错了，在stream end的时候仍然有很大一部分数据未被整流。</p>
<blockquote>
<p>这个直面屎山的经历极大地鼓舞了我</p>
</blockquote>
<p>之前在写<code>streamassembler</code>的时候就知道有个地方是错的了，那就是我对capacity的理解【具体见前面的笔记】。现在只用改一下就好了。修改方式很简单，加上这两句话就行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">right = right &lt;= left_bound + _capacity ? right : left_bound + _capacity;  <span class="comment">// 右边越界的也不要</span></span><br><span class="line"><span class="keyword">if</span> (o_left &gt;= left_bound + _capacity)       <span class="keyword">goto</span> end;  <span class="comment">// 越界的不要</span></span><br></pre></td></tr></table></figure>

<h4 id="t-udp-client-send超时"><a href="#t-udp-client-send超时" class="headerlink" title="t_udp_client_send超时"></a><code>t_udp_client_send</code>超时</h4><p><img src="/2023/02/25/cs144/image-20230304215748823.png" alt="image-20230304215748823"></p>
<p>这个错因非常地诡异，我到最后也还是没有自己找出来。直到我瞎搜来搜去看到了这篇文章：</p>
<blockquote>
<p>我也是真的很佩服这篇文章的作者能找到这个点</p>
<p><img src="/2023/02/25/cs144/image-20230304221420748.png" alt="image-20230304221420748"></p>
<p><a href="https://www.cnblogs.com/lawliet12/p/17066719.html">https://www.cnblogs.com/lawliet12/p/17066719.html</a></p>
</blockquote>
<p><img src="/2023/02/25/cs144/image-20230305215310021.png" alt="image-20230305215310021"></p>
<p>噔噔咚。</p>
<p>我为什么不用<code>_cfg.rt_timeout</code>呢？答案是我当初脑子一抽以为<code>rt_timeout</code>是static、const的，就写了个<code>TCPConfig::rt_timeout</code>然后报错了，我懒得思考了就换成了上面的那个，结果……就这东西，又花费了我好久好久【悲】怪我没有认真看，没发现<code>rt_timeout</code>不是一个静态常量。</p>
<h4 id="t-ucS-1M-32K超时"><a href="#t-ucS-1M-32K超时" class="headerlink" title="t_ucS_1M_32K超时"></a><code>t_ucS_1M_32K</code>超时</h4><p><img src="/2023/02/25/cs144/image-20230305162239877.png" alt="image-20230305162239877"></p>
<p>以及其后面的其他test也都超时了。</p>
<p>说实话我真是百思不得其解，这里打印来那里打印去，也都看得眼花缭乱什么也看不出来，使用指导书那些手动测试的方法，还有抓包，都十分地正常，但它自动测试就是会timeout。</p>
<p>我折腾来折腾去，这里print那里print，最后还怀疑是电脑问题就放到服务器上跑了一下结果还是不行。绝望之际，我只能使出了<strong>万策尽之时的迫不得已的非法手段</strong>：将我的一部分代码替换成别人的看看会怎么样。【传统艺能23333】</p>
<p>最终我定位发现是<code>TCPSender</code>出了问题，我猜测是因为状态机出错了。我比对着别人的代码【知道这不对，但我心态已经崩了。。。】，以及指导书提供的状态机，发现是这个地方出了小问题：</p>
<p><img src="/2023/02/25/cs144/image-20230305220614819.png" alt="image-20230305220614819"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in tcp_sender.cc fill_window()</span></span><br><span class="line">		<span class="comment">// 注释的是以前写的错误版本</span></span><br><span class="line">        <span class="comment">// if (_stream.input_ended() &amp;&amp; !fin &amp;&amp; remaining &gt; 0) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !fin &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// last segment</span></span><br><span class="line">            segment.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">            fin = <span class="literal">true</span>;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里不应该是<code>input_ended</code>，而应该是<code>eof</code>……</p>
<p>改了之后立刻所有测试都能跑通了【悲】</p>
<blockquote>
<p>那么问题来了，为什么错误版本就会timeout呢？我的猜测如下：</p>
<p>eof的条件如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_input_end &amp;&amp; buffer.<span class="built_in">empty</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，eof既要求input_ended，又要求缓冲区内所有数据成功发送。这也很符合FIN_SENT的语义：在数据流终止时（所有数据成功发送，不要求fully acked）发送FIN。</p>
<p>如果按照我错误版本的写法，会导致数据还没发送完毕（<code>!buffer.empty()</code>），就发送了FIN。之后数据虽然还能正常进入receiver的bytestream，并且发送给peer的receiver。但是会存在这也一个空窗期：FIN之后的数据还没到的时候，peer的receiver接收到FIN，并且peer的app从socket将receiver接收到的数据全部读出。出现了这样的空窗期，就会导致peer的receiver的stream达到eof状态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in tcp_receiver.cc segment_received()</span></span><br><span class="line">     <span class="keyword">if</span> (abs_seqno != <span class="number">0</span>)</span><br><span class="line">         _reassembler.<span class="built_in">push_substring</span>(data, index, header.fin);</span><br><span class="line"><span class="comment">// in streamassembler.cc</span></span><br><span class="line"> <span class="keyword">if</span> (is_eof &amp;&amp; buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">     _output.<span class="built_in">end_input</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>【接下来就是猜了】由于bytestream eof了，socket就停止读了。后来的数据再来，receiver的stream的缓冲区就满了，receiver就只能一直丢包。【接下来是真的<strong>纯猜</strong>】而且由于测试脚本问题，在这之后都不会调用tick方法了，故而超时重传检测不会被触发，而sender也会因为没有ack，而一直重传重传，就死循环然后timeout寄掉了。</p>
<p>纯猜部分的依据是：</p>
<p><img src="/2023/02/25/cs144/image-20230305173110776.png" alt="image-20230305173110776"></p>
<p><img src="/2023/02/25/cs144/image-20230305173152469.png" alt="image-20230305173152469"></p>
<p>可以看到，tick方法一直被调用，但是ticks却不变。数据报文一直被重传，但是retran一直不变。ticks-timer_ticks一直大于rto，但却始终无法进入那句if（经测试是这样的）。这非常奇怪，我也不知道为什么。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>【珍贵的调试用代码没删的版本放在github了。】</p>
<h3 id="TCPConnection-hh"><a href="#TCPConnection-hh" class="headerlink" title="TCPConnection.hh"></a>TCPConnection.hh</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPConnection</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="type">size_t</span> rec_tick&#123;&#125;;<span class="comment">// 上一次收到segment时的ticks数</span></span><br><span class="line">    <span class="type">size_t</span> ticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">segment_send</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">empty_ack_send</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_rst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="TCPConnection-cc"><a href="#TCPConnection-cc" class="headerlink" title="TCPConnection.cc"></a>TCPConnection.cc</h3><p>如果想要以状态机的视角来看待，可以看看<a href="https://github.com/shootfirst/CS144/">感恩</a>的代码。他写得很清晰。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_connection.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ticks - rec_tick; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一个只有ACK的空帧，仅在segment_received中调用</span></span><br><span class="line"><span class="comment">// 当没有要发送的帧，无法进行顺带ACK时，</span></span><br><span class="line"><span class="comment">// 为了保障一定有ACK发送，就只能发送一个只有ACK的空帧</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::empty_ack_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            _sender.<span class="built_in">send_empty_ack_segment</span>(_receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把_sender的所有segment都发送出去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// 顺带ACK</span></span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connection被置为error状态的部分必要操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::set_rst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重置发送的ticks</span></span><br><span class="line">    rec_tick = ticks;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        <span class="comment">// RST is set</span></span><br><span class="line">        <span class="built_in">set_rst</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回复对方问你是死是活的信息</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        seg.<span class="built_in">header</span>().seqno - _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">        <span class="built_in">segment_send</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123; <span class="comment">// ack_received也会调用fill_window</span></span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 只在本次收到的seg需要被ACK的时候才要ACK。</span></span><br><span class="line">    <span class="comment">// 需要被ACK：FIN/SYN/携带数据   总之就是length!=0</span></span><br><span class="line">    <span class="comment">// 不得不说，FIN和SYN都会占一个序列号这个点给ACK设计带来了简便，同时也增加了安全性</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">empty_ack_send</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If the inbound stream ends before the TCPConnection has reached EOF </span></span><br><span class="line">    <span class="comment">// on its outbound stream, this variable needs to be set to false</span></span><br><span class="line">    <span class="comment">// 如果receiver的那个stream比sender的stream早结束，就不用等待</span></span><br><span class="line">    <span class="comment">// 为什么呢？因为receiver的stream结束说明了全部的seg都成功接收并且全部整流【参见assembler实现】</span></span><br><span class="line">    <span class="comment">// 也就说明对方不发送数据了，并且已经把FIN也发过来了</span></span><br><span class="line">    <span class="comment">// 也即对方进入了FIN_WAIT状态</span></span><br><span class="line">    <span class="comment">// 而我们的sender还在输出，也即我们在CLOSE_WAIT状态</span></span><br><span class="line">    <span class="comment">// 因而我们只需输出完剩余数据再发送AF,最后直接关闭就行</span></span><br><span class="line">    <span class="comment">// 因为我们知道对方已经关闭了，无需再进行linger。</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; !_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        <span class="comment">// peer:FIN_WAIT   self:CLOSE_WAIT</span></span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="comment">// 处于error状态</span></span><br><span class="line">    <span class="keyword">if</span> (!_linger_after_streams_finish &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">error</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">error</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 满足条件1-3</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp;</span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">fully_acked</span>()) &#123;</span><br><span class="line">        <span class="comment">// 无需等待的话就直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!_linger_after_streams_finish)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 否则需要等待10*timeout</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">time_since_last_segment_received</span>() &gt;= <span class="number">10</span> * _cfg.rt_timeout)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> res = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    <span class="comment">// 注意此处需要手动调一下fill_window和send方法</span></span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ms_since_last_tick: number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    ticks += ms_since_last_tick;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; _cfg.MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>())</span><br><span class="line">            _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();  <span class="comment">// 清除sender遗留的所有帧</span></span><br><span class="line">        _sender.<span class="built_in">send_empty_rst_segment</span>();<span class="comment">// 只发送rst帧</span></span><br><span class="line">        <span class="built_in">set_rst</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// end the connection cleanly if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp;</span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">fully_acked</span>()</span><br><span class="line">	&amp;&amp; <span class="built_in">time_since_last_segment_received</span>() &gt;= <span class="number">10</span> * _cfg.rt_timeout) &#123;</span><br><span class="line">        <span class="comment">// 等待结束</span></span><br><span class="line">	    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="comment">// send_segment重复代码。目的是防止发送SYN外还发送别的东西</span></span><br><span class="line">    <span class="keyword">if</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// shutdown uncleanly</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">	    	<span class="built_in">set_rst</span>();</span><br><span class="line">            _sender.<span class="built_in">send_empty_rst_segment</span>();</span><br><span class="line">            <span class="built_in">segment_send</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="debug函数"><a href="#debug函数" class="headerlink" title="debug函数"></a>debug函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_helper/tcp_segment.hh</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_seg</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">         std::cerr&lt;&lt;<span class="string">&quot;  flag=&quot;</span>&lt;&lt;(<span class="built_in">header</span>().syn?<span class="string">&quot;S&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;(<span class="built_in">header</span>().ack?<span class="string">&quot;A&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;(<span class="built_in">header</span>().fin?<span class="string">&quot;F&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">            &lt;&lt;<span class="string">&quot;  seqno=&quot;</span>&lt;&lt;<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>()&lt;&lt;<span class="string">&quot;   ackno=&quot;</span>&lt;&lt;<span class="built_in">header</span>().ackno.<span class="built_in">raw_value</span>()</span><br><span class="line">            &lt;&lt;<span class="string">&quot;  payload_size:&quot;</span>&lt;&lt;<span class="built_in">payload</span>().<span class="built_in">size</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>in libsponge/tcp_helper/fd_adapter.cc</code></p>
<p><img src="/2023/02/25/cs144/image-20230304172207234.png" alt="image-20230304172207234"></p>
]]></content>
  </entry>
  <entry>
    <title>Lab5   NetworkInterface</title>
    <url>/2023/02/25/cs144$lab5/</url>
    <content><![CDATA[<h1 id="Lab5-NetworkInterface"><a href="#Lab5-NetworkInterface" class="headerlink" title="Lab5   NetworkInterface"></a>Lab5   NetworkInterface</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在前面的lab0-4中，我们实现了TCP协议。而在本次实验，以及接下来的实验6中，我们会将目光从顶层转移到底层——我们将着眼于运输层以下的协议。在本次实验中，我们将实现<strong>ETH协议</strong>，实现<u>对IP数据报的封装以及对物理地址的查询转发</u>；在下一次实验中，我们将实现网络层的路由转发算法。</p>
<h3 id="承上启下"><a href="#承上启下" class="headerlink" title="承上启下"></a>承上启下</h3><h4 id="协议栈架构"><a href="#协议栈架构" class="headerlink" title="协议栈架构"></a>协议栈架构</h4><p>我们在前面的实验已经实现了TCP协议，那么，TCP报文究竟是如何进行封装，最终到达peer那边的？我们的协议栈架构究竟是怎么样的？对于这个过程的实现协议栈，我们可以有如下三种选择。</p>
<h5 id="TCP-UDP-IP"><a href="#TCP-UDP-IP" class="headerlink" title="TCP-UDP-IP"></a>TCP-UDP-IP</h5><p>在此架构中，TCP不由操作系统的内核实现，而是运行在<strong>用户态</strong>。【事实上这三种选择TCP都是运行在用户态的，正如我们实现的这样】</p>
<p>用户态会将上层app传来的数据封装在TCP报文段中，用户态只需向操作系统提供的一个接口传入TCP报文段以及目的地址进入该接口就行。在此接口中，操作系统会给用户传进来的数据报文增加UDP、IP、ETH等等协议头，添加端口号等等等。</p>
<blockquote>
<p>所以说，其实操作系统<strong>默认只支持</strong>UDP-IP-ETH呀！新加的一层TCP反倒是靠用户实现的！</p>
<p>如果只需UDP协议，用户只需传入上层app的数据就行；如果还想要TCP，那就得由用户自己实现TCP协议，把上层app的数据封装成TCP报文，然后再发送给系统调用做进一步的封装。</p>
</blockquote>
<blockquote>
<p>其实不仅是TCP，HTTP应该也是用户自己实现的。对于web开发来说，大概应该是这样：top app data→ HTTP request/response → TCP segment → 操作系统接口 → UDP → IP → ETH frame</p>
</blockquote>
<blockquote>
<p>这个“TCP是用户态实现的”的观点让我非常震撼，在计网理论学的东西现在我们居然已经亲手实现出来了，有种网友面基的震撼。</p>
<p><a href="https://www.51cto.com/article/679964.html">TCP/IP协议栈到底是内核态好还是用户态好？</a>这篇文章好像写得很好，但是我没怎么看懂就先放在这【经典】不过里面对于NAK和ACK机制的对比学习写得挺有意思的，看了感觉很有收获。</p>
</blockquote>
<h5 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP-IP"></a>TCP-IP</h5><p>TCP当然也可以越过UDP协议，直接与IP层相连。但这由于不用了操作系统提供的那一层UDP，我们要做的事情就会变多变<strong>复杂</strong>。这也是我们经常听到的所谓“TCP/IP协议”的意义。</p>
<blockquote>
<p>Linux provides an interface, called a <code>TUN</code> device, that lets application supply <strong>an entire Internet datagram</strong>, and the kernel takes care of the rest (writing the Ethernet header, and actually sending via the physical Ethernet card, etc.). But now the application has to <u>construct the full IP header itself, not just the payload.</u>【要做的事变多了】</p>
<p>不过这里的这个填IP header的事情，在学校已经做过了，只是这个点的话确实没什么好说的</p>
</blockquote>
<p>听起来有没有很耳熟？是的，这个TCP-IP架构，我们在lab0-4已经实现了！其TCP部分是由我们自己写的，而IP部分则是由官方给的代码写的。</p>
<blockquote>
<p><strong>You’ve done this already.</strong></p>
<p>In Lab 4, we gave: </p>
<ol>
<li>an object that represents an Internet datagram and knows how to parse and serialize itself (<code>tcp_helpers/ipv4_datagram.&#123;hh,cc&#125;</code>) 表示了Internet datagram的数据结构，它可以自己序列化。</li>
<li>the logic to encapsulate(封装) TCP segments in IP (now found in <code>tcp_helpers/tcp_over_ip.cc</code>).</li>
</ol>
<p> The <code>CS144TCPSocket</code> uses these tools to connect your <code>TCPConnection</code> to a TUN device.</p>
<p>【我关于这些代码的研究放在了<code>其他的对实验未涉及的思考</code>模块中了】</p>
<p>所以说，</p>
<p>发送数据时，数据流向：上层app→（通过<code>CS144TCPSocket</code>）<code>TCPConnection</code>→（通过<code>write</code>方法）<code>ByteStream</code>→<code>TCPSender</code>→（通过从<code>_sender.segments_out</code>读）<code>TCPConnection</code>→（通过<code>CS144TCPSocket</code>绑定的事件从<code>segments_out</code>传输）<code>TUN</code></p>
<p>接收数据时，数据流向：<code>TUN</code>→（通过<code>CS144TCPSocket</code>绑定的事件调用<code>segment_received</code>）<code>TCPConnection</code>→<code>TCPReceiver</code>→（中间经过<code>StreamAssembler</code>）<code>BYteStream</code>→（通过<code>CS144TCPSocket</code>读）上层app</p>
<p>TUN以内隐藏的复杂逻辑，都由操作系统来帮我们实现。除去我们本次实验要做的ETH协议之外，剩下的其实好像就是我们在6.S081中做的networking driver了！再接下去就是数据链路层和物理层的工作了，这些就是硬件实现的范畴了。</p>
<p>感觉写到这，心情非常地澎湃。我们居然真的真的，亲手将计算机网络全部实现了出来，心中真是无限<strong>感→动↑</strong>啊！</p>
</blockquote>
<h5 id="TCP-IP-ETH"><a href="#TCP-IP-ETH" class="headerlink" title="TCP-IP-ETH"></a>TCP-IP-ETH</h5><p>而在整个sponge实现中，我们不拘泥于仅实现<code>TCP/IP</code>。我们还要实现属于我们自己的ETH协议。</p>
<p>就跟<code>TCP/IP</code>的实现中，将IP数据包发送给操作系统需要通过<code>TUN</code>接口一样，我们需要把包装的ETH数据报发送给<code>TAN</code>接口。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>因而，通过以上表述，我们知道了本次实验的目的是实现数据链路层，以及为什么要实现数据链路层。下面将详细介绍数据链路层的具体功能以及实现。</p>
<h3 id="数据链路层的实现"><a href="#数据链路层的实现" class="headerlink" title="数据链路层的实现"></a>数据链路层的实现</h3><p>要明白数据链路层怎么实现，首先要知道其功能。</p>
<h4 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h4><p>可大概分为两点：</p>
<ol>
<li><p>通过ETH协议，封装/拆封数据包</p>
<p>这个没什么好说的。</p>
<blockquote>
<p>“交付给上层协议栈”的这个“交付”动作是怎么用代码实现的呢？在成员变量里保留对上层协议栈的成员的引用？或者是像TCP那样，维护一个_out和一个received方法，其它具体连接由socket的事件驱动？</p>
<p>答案应该是像TCP这样。</p>
<p>但其实也不完全像TCP。TCP与其上层，也即app的交互是通过socket；但interface没有这个机制，它只能在frame_received的时候直接return它收到的数据报。啊不过，也许从eth得到数据报然后交给ip也是socket的任务？</p>
<p>我记得在本校的计网实验中，似乎是归结到了一个函数内实现，其接收一个void*类型的指针，好像还有代表报文格式的枚举类。</p>
</blockquote>
</li>
<li><p>通过ARP协议，将IP地址转化为物理地址</p>
<p>我们学过，在数据链路层（还是说是物理层？）endpoint的交互是通过物理地址的，但在网络层以上，endpoint的交互是通过IP地址（域名也会被解析为IP地址）的。因而，在ETH层，我们首先需要将IP地址转化为其对应的物理地址。</p>
<blockquote>
<p>在这里可以梳理一下计算机网络中所谓“地址”的<strong>转化路径</strong>：</p>
<p>我们通过约定俗成的<strong>域名</strong>访问某个主机，该域名会被DNS解析为<strong>IP地址</strong>，该IP地址会在网络层，也就是IP协议这边经过路由转发【<u>如果是用户host的话会发给自己的default路由器</u>】，然后在ETH层会根据这个要去的地方的IP地址通过ARP协议查表，得到下一站应该要去的<strong>物理地址</strong>。</p>
<p>与此同时我们也可以归纳出lab6的内容。我们的lab6就是要做这个“转发”功能。根据所学可知，实质上只有路由器才算起着真实的路由转发功能【host的路由转发只是转发给自己的海关路由器】。而路由器不需要什么TCP协议，所以lab6只基于lab5，跟lab0-4没有半毛钱关系。</p>
</blockquote>
</li>
</ol>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p><img src="/2023/02/25/cs144/image-20230307193836409.png" alt="image-20230307193836409"></p>
<p>H1知道R1的IP地址是因为设置了默认网关，而路由器之间知道彼此的IP地址是通过路由协议相互通信。</p>
<p>为什么H1知道要发给H2就需要经过R1，以及为什么H1知道R1的IP地址，R1知道R2的IP地址，这都是网络层的路由协议在起作用。</p>
<p>而H1怎么知道的R1的MAC地址，这就是ARP协议研究的内容了。是ARP将已知的IP地址翻译为MAC。</p>
<p>ARP协议的具体内容看视频就好，在此不赘述。具体有ARP请求报文（广播）、ARP响应报文（单播）</p>
<p>如果发现不知道MAC地址就发ARP request，收到ARP request的host如果发现是自己的，就需要做两件事，一个是记下来者，另一个是发送ARP响应报文。</p>
<p><img src="/2023/02/25/cs144/image-20230307194650945.png" alt="image-20230307194650945"></p>
<h3 id="network-interface"><a href="#network-interface" class="headerlink" title="network interface"></a>network interface</h3><p>介绍完上面的种种，终于来到了本次实验要实现的正题：<strong>network interface</strong>。</p>
<p>正如同在网络层，各个主机通过IP协议，凭借自己的IP地址相互打交道一样，在数据链路层，各个network interface通过ARP协议和ETH协议，凭借MAC地址相互打交道。</p>
<blockquote>
<p>可以看出，数据链路层的“network interface”与网络层的“主机”是相近的。它们的区别是什么呢？</p>
<p>答案是，一个主机可以有多个网卡，因而可以有多个network interface。</p>
<p><img src="/2023/02/25/cs144/image-20230307193102495.png" alt="image-20230307193102495"></p>
</blockquote>
<blockquote>
<p>不过这里的这个对应还是很有意思的，它反映出了计算机网络的抽象：一次网络传输可以看作是单层之间的相互交流，可以忽略其他层。不得不感慨，设计出网络层级模型的人真是天才。</p>
</blockquote>
<p>因而，在我们的数据链路层，也即我们的network interface中，我们需要实现ARP协议和ETH协议，完成数据包的收发。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>这次实验内容其实有一说一挺复杂的，既要管理各种超时，又要写收发管理。它其实跟<code>TCPSender</code>有点像，只不过本次实验的难点在数据结构的管理，<code>TCPSender</code>的难点在各种状态机的细枝末节。由于有<code>TCPSender</code>的基础，本次实验完成难度大大减小，我甚至写完代码后不出二十分钟就pass掉了测试用例（骄傲←）不过，它的编码过程及数据结构确实还是有点复杂的。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h4><p>整理一下我们的interface可能收到/发送的报文，思路就很简单了</p>
<p>收：</p>
<ol>
<li><p>来自外部的数据</p>
<p>比较MAC地址跟自己一不一样</p>
<p>需要去掉其ETH头，交付给上层</p>
</li>
<li><p>ARP请求</p>
<p>比对请求的IP地址跟自己的一不一样。</p>
<p>如果一样，就把该报文的src MAC记录进ARP，并且发送一个ARP响应进入frame_out</p>
</li>
<li><p>ARP响应</p>
<p>记录MAC地址；将放入等待暂存队列的数据包取出重新发送</p>
</li>
</ol>
<p>发：</p>
<ol>
<li><p>来自上层的数据报</p>
<p>查询ARP表，如果MAC地址已知就发，未知的话放入等待队列，并且发送ARP请求</p>
</li>
<li><p>ARP请求</p>
</li>
<li><p>ARP响应</p>
</li>
</ol>
<p>所以我们需要写以下几个函数：</p>
<ol>
<li><p>frame_received</p>
</li>
<li><p>send_arp_response</p>
<p>创建一个新的frame，填上自己的MAC地址和srcMAC</p>
</li>
<li><p>send_arp_request</p>
<p>创建一个新的frame，填上自己的MAC地址、IP地址和目的IP地址</p>
</li>
<li><p>frame_send</p>
<p>发送从上层来的报文</p>
</li>
<li><p>ARP操作    ARP表是一个map映射</p>
</li>
</ol>
<p>以及如下成员变量：</p>
<ol>
<li><p>ARP映射的数据结构</p>
<p>map&lt;IP地址，{MAC地址，ticks}&gt;</p>
</li>
<li><p>等待队列</p>
<p>map&lt;IP地址，{未填写dst的frame们，latest_ticks}&gt;</p>
</li>
<li><p>ticks  代表当前经过的时间</p>
</li>
</ol>
<h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>可以看到，官方提供给我们的接口定义，以及在指导书中对函数实现的详细拆分，确实跟初见思路所想的差不多完全一样【但我更推荐看指导书的版本，它枚列得更加清晰】，可以说思路还是很直观的。所以就不多bb了直接看代码吧。</p>
<h4 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h4><ol>
<li><p>等待在同一个IP地址的帧可能不止一个，所以在数据结构中需要以vector集合形式管理</p>
</li>
<li><p>在接收以太帧时，应该首先检查最外层的ETH协议的MAC地址，作用是判断这个帧是不是发给自己的。</p>
<p>如果帧内封装的是IP数据包，这样做就很OK了，因为能确保此时自己一定可以收这个包；</p>
<p>但是如果帧内封装的是ARP数据包，这样做是不OK的。因为依照ARP协议，若是此为ARP REQUEST，则其ETH header是广播地址，而它真正想要届到的对象的信息是在ARP header中的target IP。因而，对于ARP协议，我们还得判断header中的target IP和本机IP是否相等。</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkInterface</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// arp映射的元素定义</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">arp_node</span> &#123;</span><br><span class="line">        EthernetAddress mac;<span class="comment">// ip地址key对应的mac地址</span></span><br><span class="line">        <span class="type">size_t</span> ticks;<span class="comment">// 该条记录被记录时的时间</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ARP映射，&lt;IP地址，元素结点&gt;</span></span><br><span class="line">    std::map&lt;<span class="type">uint32_t</span>, arp_node&gt; arp_mappings&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">waiting_node</span> &#123;</span><br><span class="line">        std::vector&lt;EthernetFrame&gt; frames&#123;&#125;;<span class="comment">// 等待在该IP地址的以太帧们</span></span><br><span class="line">        <span class="type">size_t</span> latest_ticks = <span class="number">0</span>;  <span class="comment">// 等候中的frame们最晚放入者的时间</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 等待队列，&lt;IP地址，元素结点&gt;</span></span><br><span class="line">    std::map&lt;<span class="type">uint32_t</span>, waiting_node&gt; waiting_frames&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> ticks = <span class="number">0</span>;<span class="comment">// 出生到现在经过的时钟滴答</span></span><br><span class="line">    <span class="comment">// 自定义方法，用于发送一个arp报文【请求/响应】</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send_arp</span><span class="params">(<span class="type">uint32_t</span> target_ip, EthernetAddress eth_add, <span class="type">uint16_t</span> opcode)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network_interface.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;arp_message.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ethernet_frame.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NetworkInterface::<span class="built_in">NetworkInterface</span>(<span class="type">const</span> EthernetAddress &amp;ethernet_address, <span class="type">const</span> Address &amp;ip_address)</span><br><span class="line">    : _ethernet_address(ethernet_address), _ip_address(ip_address) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// param: target ip address , target ethernet address , and the arp opcode</span></span><br><span class="line"><span class="comment">// if is the request, pass BROADCAST as the param;</span></span><br><span class="line"><span class="comment">// if is the response, pass arprequest.eth_add as the param.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::send_arp</span><span class="params">(<span class="type">uint32_t</span> target_ip, EthernetAddress eth_add, <span class="type">uint16_t</span> opcode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// create the eth frame</span></span><br><span class="line">    EthernetFrame frame;</span><br><span class="line">    <span class="comment">/* create the payload */</span></span><br><span class="line">    <span class="comment">// create the arp message</span></span><br><span class="line">    ARPMessage arp_mes;</span><br><span class="line">    arp_mes.sender_ethernet_address = _ethernet_address;</span><br><span class="line">    arp_mes.sender_ip_address = _ip_address.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    arp_mes.opcode = opcode;</span><br><span class="line">    arp_mes.target_ip_address = target_ip;</span><br><span class="line">    <span class="keyword">if</span> (opcode == ARPMessage::OPCODE_REPLY)</span><br><span class="line">        arp_mes.target_ethernet_address = eth_add;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// if is the REQUEST, arp target mac is unknown and should be set to zero</span></span><br><span class="line">        arp_mes.target_ethernet_address = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// serialize and put it into the payload</span></span><br><span class="line">    frame.<span class="built_in">payload</span>() = <span class="built_in">BufferList</span>(arp_mes.<span class="built_in">serialize</span>());</span><br><span class="line">    <span class="comment">/* fill in the header */</span></span><br><span class="line">    EthernetHeader header;</span><br><span class="line">    header.src = _ethernet_address;</span><br><span class="line">    header.dst = eth_add;</span><br><span class="line">    header.type = EthernetHeader::TYPE_ARP;</span><br><span class="line">    frame.<span class="built_in">header</span>() = header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send it</span></span><br><span class="line">    _frames_out.<span class="built_in">push</span>(frame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] dgram the IPv4 datagram to be sent</span></span><br><span class="line"><span class="comment">//! \param[in] next_hop the IP address of the interface to send it to (typically a router or default gateway, but may also be another host if directly connected to the same network as the destination)</span></span><br><span class="line"><span class="comment">//! (Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) with the Address::ipv4_numeric() method.)</span></span><br><span class="line"><span class="comment">// 处理从上层协议接收到的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::send_datagram</span><span class="params">(<span class="type">const</span> InternetDatagram &amp;dgram, <span class="type">const</span> Address &amp;next_hop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// convert IP address of next hop to raw 32-bit representation (used in ARP header)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> next_hop_ip = next_hop.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    <span class="comment">// create the eth frame</span></span><br><span class="line">    EthernetFrame frame;</span><br><span class="line">    <span class="comment">// fill in the payload</span></span><br><span class="line">    frame.<span class="built_in">payload</span>() = dgram.<span class="built_in">serialize</span>();</span><br><span class="line">    <span class="comment">// fill in the header</span></span><br><span class="line">    EthernetHeader header;</span><br><span class="line">    <span class="comment">// dst is reserved</span></span><br><span class="line">    header.src = _ethernet_address;</span><br><span class="line">    header.type = EthernetHeader::TYPE_IPv4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> tmp_arp = arp_mappings.<span class="built_in">find</span>(next_hop_ip);<span class="comment">// find the mac from the arp mappings</span></span><br><span class="line">    <span class="keyword">if</span> (tmp_arp == arp_mappings.<span class="built_in">end</span>()) &#123;  <span class="comment">// not exist</span></span><br><span class="line">        frame.<span class="built_in">header</span>() = header;          <span class="comment">// remember that the dst field is reserved</span></span><br><span class="line">        <span class="keyword">auto</span> tmp_wait = waiting_frames.<span class="built_in">find</span>(next_hop_ip);<span class="comment">// is there a waiting queue?</span></span><br><span class="line">        <span class="comment">// the arp request hasn&#x27;t been sent if there is not a waiting queue, </span></span><br><span class="line">        <span class="keyword">if</span> (tmp_wait == waiting_frames.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// create the waiting queue</span></span><br><span class="line">            vector&lt;EthernetFrame&gt; frames;</span><br><span class="line">            frames.<span class="built_in">push_back</span>(frame);</span><br><span class="line">            waiting_node node;</span><br><span class="line">            node.frames = frames;</span><br><span class="line">            node.latest_ticks = ticks;</span><br><span class="line">            waiting_frames.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(next_hop_ip, node));</span><br><span class="line">            <span class="comment">// send arp request</span></span><br><span class="line">            <span class="built_in">send_arp</span>(next_hop_ip, ETHERNET_BROADCAST, ARPMessage::OPCODE_REQUEST);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// the arp request has been sended</span></span><br><span class="line">            <span class="keyword">if</span> (ticks - tmp_wait-&gt;second.latest_ticks &gt; <span class="number">5</span>*<span class="number">1000</span>) &#123;<span class="comment">// send before 5 seconds</span></span><br><span class="line">                <span class="comment">// resend arp request</span></span><br><span class="line">                <span class="built_in">send_arp</span>(next_hop_ip, ETHERNET_BROADCAST, ARPMessage::OPCODE_REQUEST);</span><br><span class="line">                <span class="comment">// update the time only when the arp request was sent</span></span><br><span class="line">                tmp_wait-&gt;second.latest_ticks = ticks;  </span><br><span class="line">            &#125;</span><br><span class="line">            tmp_wait-&gt;second.frames.<span class="built_in">push_back</span>(frame);<span class="comment">// add the frame to the waiting list</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recall that the dst field is reserved</span></span><br><span class="line">    header.dst = tmp_arp-&gt;second.mac;</span><br><span class="line">    frame.<span class="built_in">header</span>() = header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send it right away</span></span><br><span class="line">    _frames_out.<span class="built_in">push</span>(frame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] frame the incoming Ethernet frame</span></span><br><span class="line"><span class="function">optional&lt;InternetDatagram&gt; <span class="title">NetworkInterface::recv_frame</span><span class="params">(<span class="type">const</span> EthernetFrame &amp;frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().dst != _ethernet_address &amp;&amp; frame.<span class="built_in">header</span>().dst != ETHERNET_BROADCAST)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;  <span class="comment">// should not accept</span></span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().type == EthernetHeader::TYPE_IPv4) &#123;</span><br><span class="line">        InternetDatagram ip_data;</span><br><span class="line">        ParseResult res = ip_data.<span class="built_in">parse</span>(frame.<span class="built_in">payload</span>());</span><br><span class="line">        <span class="keyword">if</span> (res == ParseResult::NoError) &#123;</span><br><span class="line">            <span class="keyword">return</span> ip_data; <span class="comment">// return to send it to the upper protocal</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().type != EthernetHeader::TYPE_ARP)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    ARPMessage arp_mes;</span><br><span class="line">    ParseResult res = arp_mes.<span class="built_in">parse</span>(frame.<span class="built_in">payload</span>());</span><br><span class="line">    <span class="keyword">if</span> (res != ParseResult::NoError)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// I&#x27;m not the arp target</span></span><br><span class="line">    <span class="keyword">if</span> (arp_mes.target_ip_address != _ip_address.<span class="built_in">ipv4_numeric</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> tmp_arp = arp_mappings.<span class="built_in">find</span>(arp_mes.sender_ip_address);</span><br><span class="line">    <span class="keyword">if</span> (tmp_arp == arp_mappings.<span class="built_in">end</span>()) &#123;  <span class="comment">// arp mapping not exist, create one</span></span><br><span class="line">        arp_node node;</span><br><span class="line">        node.ticks = ticks;</span><br><span class="line">        node.mac = arp_mes.sender_ethernet_address;</span><br><span class="line">        arp_mappings.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(arp_mes.sender_ip_address, node));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp_arp-&gt;second.ticks = ticks;  <span class="comment">// update the record ticks</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arp_mes.opcode == ARPMessage::OPCODE_REQUEST) &#123;</span><br><span class="line">        <span class="built_in">send_arp</span>(arp_mes.sender_ip_address, arp_mes.sender_ethernet_address, ARPMessage::OPCODE_REPLY);</span><br><span class="line">        <span class="comment">// shouldn&#x27;t return now, maybe we are also waiting for the sender&#x27;s mac address</span></span><br><span class="line">        <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send all frames in the waiting queue</span></span><br><span class="line">    <span class="keyword">auto</span> tmp_wait = waiting_frames.<span class="built_in">find</span>(arp_mes.sender_ip_address);</span><br><span class="line">    <span class="comment">// have no frames waiting for the address</span></span><br><span class="line">    <span class="keyword">if</span> (tmp_wait == waiting_frames.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!tmp_wait-&gt;second.frames.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        EthernetFrame f = tmp_wait-&gt;second.frames.<span class="built_in">back</span>();</span><br><span class="line">        <span class="comment">// recall that the dst field is reserved</span></span><br><span class="line">        f.<span class="built_in">header</span>().dst = arp_mes.sender_ethernet_address;  </span><br><span class="line">        _frames_out.<span class="built_in">push</span>(f);</span><br><span class="line">        tmp_wait-&gt;second.frames.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// erase all the waiting frames</span></span><br><span class="line">    waiting_frames.<span class="built_in">erase</span>(tmp_wait);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    ticks += ms_since_last_tick;</span><br><span class="line">    <span class="comment">// walk the arp mappings to check whether a mapping is out-of-date</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = arp_mappings.<span class="built_in">begin</span>(); it != arp_mappings.<span class="built_in">end</span>();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticks - it-&gt;second.ticks &gt; <span class="number">30</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">            it = arp_mappings.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>其他的对实验未涉及的思考</title>
    <url>/2023/02/25/cs144$else/</url>
    <content><![CDATA[<h1 id="其他的对实验未涉及的思考"><a href="#其他的对实验未涉及的思考" class="headerlink" title="其他的对实验未涉及的思考"></a>其他的对实验未涉及的思考</h1><h2 id="网络层实现"><a href="#网络层实现" class="headerlink" title="网络层实现"></a>网络层实现</h2><p>在我们的协议栈实现中，我们负责了运输层的TCP协议、网络层的ARP协议以及数据链路层的ETH协议的编写，剩下的网络层的IP协议则由官方给定。接下来我们就来探究下网络层的实现。</p>
<h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><blockquote>
<p><strong>You’ve done this already.</strong></p>
<p>In Lab 4, we gave:</p>
<ol>
<li>an object that represents an Internet datagram and knows how to parse and serialize itself (<code>tcp_helpers/ipv4_datagram.&#123;hh,cc&#125;</code>) 表示了Internet datagram的数据结构，它可以自己序列化。</li>
<li>the logic to encapsulate(封装) TCP segments in IP (now found in <code>tcp_helpers/tcp_over_ip.cc</code>).</li>
</ol>
<p>The <code>CS144TCPSocket</code> uses these tools to connect your <code>TCPConnection</code> to a TUN device.</p>
</blockquote>
<p>也即，IP协议主要由两个文件实现，一个是IP数据报抽象为的类<code>ipv4_datagram.&#123;hh,cc&#125;</code>，另一个是将TCP报文封装为IP报文的类<code>tcp_helpers/tcp_over_ip.cc</code>；除此之外，IP协议还负责与下次协议连接，在实验0-4中它通过<code>CS144TCPSocket</code>与TUN连接，在实验5-6则与TAN连接。</p>
<p>连接部分暂且先放到下一部分讲，下面来看看IP协议的具体实现。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="ipv4-datagram-hh-amp-amp-ipv4-header-hh"><a href="#ipv4-datagram-hh-amp-amp-ipv4-header-hh" class="headerlink" title="ipv4_datagram.hh &amp;&amp; ipv4_header.hh"></a>ipv4_datagram.hh &amp;&amp; ipv4_header.hh</h4><p><code>ipv4_datagram</code>没什么好说的，跟<code>TCPSegment</code>的结构一模一样。<code>ipv4_header</code>也没什么好说的，就纯纯是IP数据报的报头、</p>
<h4 id="tcp-over-ip"><a href="#tcp-over-ip" class="headerlink" title="tcp_over_ip"></a>tcp_over_ip</h4><h5 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h5><p>它的头文件很简单，只包含一个类的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A converter from TCP segments to serialized IPv4 datagrams</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPOverIPv4Adapter</span> : <span class="keyword">public</span> FdAdapterBase &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::optional&lt;TCPSegment&gt; <span class="title">unwrap_tcp_in_ip</span><span class="params">(<span class="type">const</span> InternetDatagram &amp;ip_dgram)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">InternetDatagram <span class="title">wrap_tcp_in_ip</span><span class="params">(TCPSegment &amp;seg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// SPONGE_LIBSPONGE_TCP_OVER_IP_HH</span></span></span><br></pre></td></tr></table></figure>

<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><p>可以看到，相比于TCP和ETH/ARP协议，IP协议的实现可以说是非常简单。它作为一个中间层，只需要把上面给的东西包装下再传到下面，或者把下面给的东西解包下再传给上面，无需其他复杂的算法和数据结构（比如TCP的reliable transmission和ETH/ARP的地址自学习），也无需跟外界打交道。</p>
<p>除了打包解包外，它只需确保一件事，那就是一台主机只能同时拥有一个TCP连接。这样一来也能简化其实现：填写IP协议头时，它就只需从自己保存的config中取参数就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来拆IP数据包为一个TCP数据包</span></span><br><span class="line"><span class="comment">//! If this succeeds, it then checks that the received segment is related to the</span></span><br><span class="line"><span class="comment">//! current connection. When a TCP connection has been established, this means</span></span><br><span class="line"><span class="comment">//  如果TCP连接已建立，则会检查src和dst端口号的正确性</span></span><br><span class="line"><span class="comment">//! checking that the source and destination ports in the TCP header are correct.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! If the TCP connection is listening 如果处于listening状态，并且参数为SYN报文</span></span><br><span class="line"><span class="comment">//! and the TCP segment read from the wire includes a SYN, this function clears the</span></span><br><span class="line"><span class="comment">//  就需要解除listening的flag，记录下src和dst的地址和端口号</span></span><br><span class="line"><span class="comment">//! `_listen` flag and records the source and destination addresses and port numbers</span></span><br><span class="line"><span class="comment">//  目的是为了 filter future reads</span></span><br><span class="line"><span class="comment">//  这说明我们的sponge实现是单线程的，也就是一台主机只能同时建立一个TCP连接</span></span><br><span class="line"><span class="comment">//  并且在此时会忽略其他主机发过来的数据包</span></span><br><span class="line"><span class="comment">//! from the TCP header; it uses this information to filter future reads.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  returns a std::optional&lt;TCPSegment&gt; that is empty if the segment was invalid or unrelated</span></span><br><span class="line"><span class="function">optional&lt;TCPSegment&gt; <span class="title">TCPOverIPv4Adapter::unwrap_tcp_in_ip</span><span class="params">(<span class="type">const</span> InternetDatagram &amp;ip_dgram)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// is the IPv4 datagram for us?</span></span><br><span class="line">    <span class="comment">// Note: it&#x27;s valid to bind to address &quot;0&quot; (INADDR_ANY) and reply from actual address contacted</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">listening</span>() <span class="built_in">and</span> (ip_dgram.<span class="built_in">header</span>().dst != <span class="built_in">config</span>().source.<span class="built_in">ipv4_numeric</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the IPv4 datagram from our peer?</span></span><br><span class="line">    <span class="comment">// 过滤非peer发来的其他数据包</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">listening</span>() <span class="built_in">and</span> (ip_dgram.<span class="built_in">header</span>().src != <span class="built_in">config</span>().destination.<span class="built_in">ipv4_numeric</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// does the IPv4 datagram claim that its payload is a TCP segment?</span></span><br><span class="line">    <span class="comment">// 我们只需解包TCP数据报</span></span><br><span class="line">    <span class="keyword">if</span> (ip_dgram.<span class="built_in">header</span>().proto != IPv4Header::PROTO_TCP) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the payload a valid TCP segment?</span></span><br><span class="line">    TCPSegment tcp_seg;</span><br><span class="line">    <span class="keyword">if</span> (ParseResult::NoError != tcp_seg.<span class="built_in">parse</span>(ip_dgram.<span class="built_in">payload</span>(), ip_dgram.<span class="built_in">header</span>().<span class="built_in">pseudo_cksum</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the TCP segment for us?</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_seg.<span class="built_in">header</span>().dport != <span class="built_in">config</span>().source.<span class="built_in">port</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should we target this source addr/port (and use its destination addr as our source) in reply?</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listening</span>()) &#123;</span><br><span class="line">        <span class="comment">// records the source and destination addresses and port numbers</span></span><br><span class="line">        <span class="keyword">if</span> (tcp_seg.<span class="built_in">header</span>().syn <span class="keyword">and</span> <span class="keyword">not</span> tcp_seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">            <span class="built_in">config_mutable</span>().source = &#123;<span class="built_in">inet_ntoa</span>(&#123;<span class="built_in">htobe32</span>(ip_dgram.<span class="built_in">header</span>().dst)&#125;), <span class="built_in">config</span>().source.<span class="built_in">port</span>()&#125;;</span><br><span class="line">            <span class="built_in">config_mutable</span>().destination = &#123;<span class="built_in">inet_ntoa</span>(&#123;<span class="built_in">htobe32</span>(ip_dgram.<span class="built_in">header</span>().src)&#125;), tcp_seg.<span class="built_in">header</span>().sport&#125;;</span><br><span class="line">            <span class="built_in">set_listening</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the TCP segment from our peer?</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_seg.<span class="built_in">header</span>().sport != <span class="built_in">config</span>().destination.<span class="built_in">port</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tcp_seg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Takes a TCP segment, sets port numbers as necessary, and wraps it in an IPv4 datagram</span></span><br><span class="line"><span class="comment">//! \param[in] seg is the TCP segment to convert</span></span><br><span class="line"><span class="function">InternetDatagram <span class="title">TCPOverIPv4Adapter::wrap_tcp_in_ip</span><span class="params">(TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set the port numbers in the TCP segment</span></span><br><span class="line">    seg.<span class="built_in">header</span>().sport = <span class="built_in">config</span>().source.<span class="built_in">port</span>();</span><br><span class="line">    seg.<span class="built_in">header</span>().dport = <span class="built_in">config</span>().destination.<span class="built_in">port</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an Internet Datagram and set its addresses and length</span></span><br><span class="line">    InternetDatagram ip_dgram;</span><br><span class="line">    ip_dgram.<span class="built_in">header</span>().src = <span class="built_in">config</span>().source.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    ip_dgram.<span class="built_in">header</span>().dst = <span class="built_in">config</span>().destination.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    <span class="comment">// uint8_t hlen = LENGTH / 4;  //!&lt; header length</span></span><br><span class="line">    <span class="comment">// uint8_t doff = LENGTH / 4;  //!&lt; data offset</span></span><br><span class="line">    ip_dgram.<span class="built_in">header</span>().len = ip_dgram.<span class="built_in">header</span>().hlen * <span class="number">4</span> + seg.<span class="built_in">header</span>().doff * <span class="number">4</span> + seg.<span class="built_in">payload</span>().<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set payload, calculating TCP checksum using information from IP header</span></span><br><span class="line">    ip_dgram.<span class="built_in">payload</span>() = seg.<span class="built_in">serialize</span>(ip_dgram.<span class="built_in">header</span>().<span class="built_in">pseudo_cksum</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ip_dgram;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Socket实现"><a href="#Socket实现" class="headerlink" title="Socket实现"></a>Socket实现</h2><p>最top的话可以分为<code>CS144TCPSocket</code>和<code>FullStackSocket</code>。</p>
<p>继承关系如下图：</p>
<p><img src="/2023/02/25/cs144/class_socket__inherit__graph.png" alt="Inheritance graph"></p>
<p>其中，<code>TCPSocket</code>是完完全全的包装类，它的所有协议栈都是在内核态中实现（也就是跟我们之后写的没半毛钱关系），它的存在意义应该是用在lab0来写<code>webget</code>的测试。而<code>CS144TCPSocket</code>就是我们在lab0-4用的了，它的数据链路层由内核实现，网络层和运输层由用户实现。<code>FullStackSocket</code>就是加上了我们在lab5做的用户态数据链路层。</p>
<p>最主要的部分是<code>TCPSpongeSocket</code>的实现，其他就是一些包装类没什么好说的。</p>
<h3 id="FileDescriptor"><a href="#FileDescriptor" class="headerlink" title="FileDescriptor"></a>FileDescriptor</h3><p>将socket看作是fd，将网络看作是IO，这一抽象简直是太伟大了，牛逼到爆。</p>
<h4 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! A reference-counted handle to a file descriptor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileDescriptor</span> &#123;</span><br><span class="line">    <span class="comment">//! \brief A handle on a kernel file descriptor.</span></span><br><span class="line">    <span class="comment">//! \details FileDescriptor objects contain a std::shared_ptr to a FDWrapper.</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FDWrapper</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> _fd;                    <span class="comment">// file descriptor number returned by the kernel</span></span><br><span class="line">        <span class="type">bool</span> _eof = <span class="literal">false</span>;          <span class="comment">// fd是否eof</span></span><br><span class="line">        <span class="type">bool</span> _closed = <span class="literal">false</span>;       <span class="comment">// fd是否close</span></span><br><span class="line">        <span class="comment">// fd被读写的次数</span></span><br><span class="line">        <span class="type">unsigned</span> _read_count = <span class="number">0</span>;   </span><br><span class="line">        <span class="type">unsigned</span> _write_count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Construct from a file descriptor number returned by the kernel</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">FDWrapper</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd)</span></span>;</span><br><span class="line">        <span class="comment">//! Closes the file descriptor upon destruction</span></span><br><span class="line">        ~<span class="built_in">FDWrapper</span>();</span><br><span class="line">        <span class="comment">//! Calls [close(2)](\ref man2::close) on FDWrapper::_fd</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//! An FDWrapper cannot be copied or moved</span></span><br><span class="line">        <span class="built_in">FDWrapper</span>(<span class="type">const</span> FDWrapper &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">        FDWrapper &amp;<span class="keyword">operator</span>=(<span class="type">const</span> FDWrapper &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="built_in">FDWrapper</span>(FDWrapper &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">        FDWrapper &amp;<span class="keyword">operator</span>=(FDWrapper &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! A reference-counted handle to a shared FDWrapper</span></span><br><span class="line">    std::shared_ptr&lt;FDWrapper&gt; _internal_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private constructor used to duplicate the FileDescriptor (increase the reference count)  这个构造函数会增加其参数传进来的那个fd的引用，也许相当于dump</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FileDescriptor</span><span class="params">(std::shared_ptr&lt;FDWrapper&gt; other_shared_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">register_read</span><span class="params">()</span> </span>&#123; ++_internal_fd-&gt;_read_count; &#125;    <span class="comment">//!&lt; increment read count</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">register_write</span><span class="params">()</span> </span>&#123; ++_internal_fd-&gt;_write_count; &#125;  <span class="comment">//!&lt; increment write count</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Construct from a file descriptor number returned by the kernel</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FileDescriptor</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Free the std::shared_ptr; the FDWrapper destructor calls close() when the refcount goes to zero.</span></span><br><span class="line">    ~<span class="built_in">FileDescriptor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  读写  */</span></span><br><span class="line">    <span class="function">std::string <span class="title">read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> limit = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::max())</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(std::string &amp;str, <span class="type">const</span> <span class="type">size_t</span> limit = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::max())</span></span>;</span><br><span class="line">    <span class="comment">// possibly blocking until all is written</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">write</span>(<span class="built_in">BufferViewList</span>(str), write_all); &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;str, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">write</span>(<span class="built_in">BufferViewList</span>(str), write_all); &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(BufferViewList buffer, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Close the underlying file descriptor</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; _internal_fd-&gt;<span class="built_in">close</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Copy a FileDescriptor explicitly, increasing the FDWrapper refcount</span></span><br><span class="line">    <span class="function">FileDescriptor <span class="title">duplicate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Set blocking(true) or non-blocking(false)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_blocking</span><span class="params">(<span class="type">const</span> <span class="type">bool</span> blocking_state)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p>差不多就是全程调用系统调用没什么好说的，记录下几个有意思的点</p>
<h5 id="包装系统调用"><a href="#包装系统调用" class="headerlink" title="包装系统调用"></a>包装系统调用</h5><p>可以看下其调用系统调用的方式，看起来很有意思：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileDescriptor::set_blocking</span><span class="params">(<span class="type">const</span> <span class="type">bool</span> blocking_state)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">SystemCall</span>(<span class="string">&quot;fcntl&quot;</span>, <span class="built_in">fcntl</span>(<span class="built_in">fd_num</span>(), F_GETFL));</span><br><span class="line">    <span class="keyword">if</span> (blocking_state) &#123;</span><br><span class="line">        flags ^= (flags &amp; O_NONBLOCK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags |= O_NONBLOCK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SystemCall</span>(<span class="string">&quot;fcntl&quot;</span>, <span class="built_in">fcntl</span>(<span class="built_in">fd_num</span>(), F_SETFL, flags));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说这里设置文件读写是否阻塞就是通过系统调用实现的。</p>
<p>在写os实验时，你应该就能很深刻感受到，很多时候调用完一个系统调用后，对它的返回结果进行合法性判断以及错误处理还是有点烦的（举例来说，如<code>if(kalloc() == 0)</code>或者<code>if(mappages() == 0)</code>，出错后杀死进程等等等）。在那会我们还可以直接就这么冗余地干了，但是这里不行，一是我们要用面向对象的思想，二是我们的重点事实上并不是操作系统而是网络，因而最好还是这么封装下以减少冗余代码。</p>
<p>而它除了会调用系统调用外，还使用了一个包装性的方法<code>SystemCall</code>来保障调用的安全性和合理性。看看<code>SystemCall</code>的具体实现方式，确实就是包了层安全检查。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SystemCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (return_value &gt;= <span class="number">0</span> || errno == errno_mask) &#123;</span><br><span class="line">        <span class="keyword">return</span> return_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">unix_error</span>(attempt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os内核看不懂c++，所以要注意转换为c-style的字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SystemCall</span><span class="params">(<span class="type">const</span> string &amp;attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SystemCall</span>(attempt.<span class="built_in">c_str</span>(), return_value, errno_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>没什么好说的，只是操作系统socket接口的包装类。</p>
<h4 id="头文件-2"><a href="#头文件-2" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base class for network sockets (TCP, UDP, etc.)</span></span><br><span class="line"><span class="comment">// Socket is generally used via a subclass. See TCPSocket and UDPSocket for usage examples.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span> : <span class="keyword">public</span> FileDescriptor &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! Get the local or peer address the socket is connected to</span></span><br><span class="line">    <span class="function">Address <span class="title">get_address</span><span class="params">(<span class="type">const</span> std::string &amp;name_of_function,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> std::function&lt;<span class="type">int</span>(<span class="type">int</span>, sockaddr *, <span class="type">socklen_t</span> *)&gt; &amp;function)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Socket</span>(<span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type);</span><br><span class="line">    <span class="built_in">Socket</span>(FileDescriptor &amp;&amp;fd, <span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> option_type&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setsockopt</span><span class="params">(<span class="type">const</span> <span class="type">int</span> level, <span class="type">const</span> <span class="type">int</span> option, <span class="type">const</span> option_type &amp;option_value)</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Bind a socket to a local address, usually for listen/accept</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bind</span><span class="params">(<span class="type">const</span> Address &amp;address)</span></span>;</span><br><span class="line">    <span class="comment">// Connect a socket to a peer address</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> Address &amp;address)</span></span>;</span><br><span class="line">    <span class="comment">// Shut down a socket</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">(<span class="type">const</span> <span class="type">int</span> how)</span></span>;</span><br><span class="line">    <span class="comment">//! Get local address of socket</span></span><br><span class="line">    <span class="function">Address <span class="title">local_address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//! Get peer address of socket</span></span><br><span class="line">    <span class="function">Address <span class="title">peer_address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//! Allow local address to be reused sooner</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_reuseaddr</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! A wrapper around [UDP sockets](\ref man7::udp)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UDPSocket</span> : <span class="keyword">public</span> Socket &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//! \brief Construct from FileDescriptor (used by TCPOverUDPSocketAdapter)</span></span><br><span class="line">    <span class="comment">//! \param[in] fd is the FileDescriptor from which to construct</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UDPSocket</span><span class="params">(FileDescriptor &amp;&amp;fd)</span> : Socket(std::move(fd), AF_INET, SOCK_DGRAM) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Default: construct an unbound, unconnected UDP socket</span></span><br><span class="line">    <span class="built_in">UDPSocket</span>() : <span class="built_in">Socket</span>(AF_INET, SOCK_DGRAM) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// carries received data and information about the sender</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">received_datagram</span> &#123;</span><br><span class="line">        Address source_address;  <span class="comment">//!&lt; Address from which this datagram was received</span></span><br><span class="line">        std::string payload;     <span class="comment">//!&lt; UDP datagram payload</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//! Receive a datagram and the Address of its sender</span></span><br><span class="line">    <span class="function">received_datagram <span class="title">recv</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> mtu = <span class="number">65536</span>)</span></span>;</span><br><span class="line">    <span class="comment">//! Receive a datagram and the Address of its sender (caller can allocate storage)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recv</span><span class="params">(received_datagram &amp;datagram, <span class="type">const</span> <span class="type">size_t</span> mtu = <span class="number">65536</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Send a datagram to specified Address</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendto</span><span class="params">(<span class="type">const</span> Address &amp;destination, <span class="type">const</span> BufferViewList &amp;payload)</span></span>;</span><br><span class="line">    <span class="comment">//! Send datagram to the socket&#x27;s connected address (must call connect() first)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> BufferViewList &amp;payload)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! A wrapper around [TCP sockets](\ref man7::tcp)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSocket</span> : <span class="keyword">public</span> Socket &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Construct from FileDescriptor (used by accept())</span></span><br><span class="line">    <span class="comment">// fd is the FileDescriptor from which to construct</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TCPSocket</span><span class="params">(FileDescriptor &amp;&amp;fd)</span> : Socket(std::move(fd), AF_INET, SOCK_STREAM) &#123;</span>&#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Default: construct an unbound, unconnected TCP socket</span></span><br><span class="line">    <span class="built_in">TCPSocket</span>() : <span class="built_in">Socket</span>(AF_INET, SOCK_STREAM) &#123;&#125;</span><br><span class="line">    <span class="comment">//! Mark a socket as listening for incoming connections</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">(<span class="type">const</span> <span class="type">int</span> backlog = <span class="number">16</span>)</span></span>;</span><br><span class="line">    <span class="comment">//! Accept a new incoming connection</span></span><br><span class="line">    <span class="function">TCPSocket <span class="title">accept</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! A wrapper around [Unix-domain stream sockets](\ref man7::unix)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LocalStreamSocket</span> : <span class="keyword">public</span> Socket &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...构造器</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// SPONGE_LIBSPONGE_SOCKET_HH</span></span></span><br></pre></td></tr></table></figure>

<h4 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="构造器的参数"><a href="#构造器的参数" class="headerlink" title="构造器的参数"></a>构造器的参数</h5><p><a href="https://blog.csdn.net/liuxingen/article/details/44995467">参考文章</a></p>
<p>也是系统调用socket的参数，了解一下知识多多益善。</p>
<ol>
<li><p>domain</p>
<p>在本次实验中只会取值前两个，即本地通信和IPv4网络通信</p>
<p><img src="/2023/02/25/cs144/image-20230309232045195.png" alt="image-20230309232045195"></p>
</li>
<li><p>type</p>
<p>好像比如说取<code>SOCK_DGRAM</code>就是UDP，取<code>SOCK_STREAM</code>就是TCP。</p>
</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Socket */</span></span><br><span class="line"><span class="comment">/* 构造器 */</span></span><br><span class="line"><span class="comment">// default constructor for socket of (subclassed) domain and type</span></span><br><span class="line">Socket::<span class="built_in">Socket</span>(<span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type) : <span class="built_in">FileDescriptor</span>(<span class="built_in">SystemCall</span>(<span class="string">&quot;socket&quot;</span>, <span class="built_in">socket</span>(domain, type, <span class="number">0</span>))) &#123;&#125;</span><br><span class="line"><span class="comment">// construct from file descriptor</span></span><br><span class="line">Socket::<span class="built_in">Socket</span>(FileDescriptor &amp;&amp;fd, <span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type) : <span class="built_in">FileDescriptor</span>(<span class="built_in">move</span>(fd)) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the local or peer address the socket is connected to</span></span><br><span class="line"><span class="comment">// 此为private函数，应该是用于方便下面那两个函数的，虽然我觉得这个设计意图没什么必要（）</span></span><br><span class="line"><span class="function">Address <span class="title">Socket::get_address</span><span class="params">(<span class="type">const</span> string &amp;name_of_function,<span class="type">const</span> function&lt;<span class="type">int</span>(<span class="type">int</span>, sockaddr *, <span class="type">socklen_t</span> *)&gt; &amp;function)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Address::Raw address;</span><br><span class="line">    <span class="type">socklen_t</span> size = <span class="built_in">sizeof</span>(address);</span><br><span class="line">	<span class="built_in">SystemCall</span>(name_of_function, <span class="built_in">function</span>(<span class="built_in">fd_num</span>(), address, &amp;size));</span><br><span class="line">    <span class="keyword">return</span> &#123;address, size&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Address <span class="title">Socket::local_address</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">get_address</span>(<span class="string">&quot;getsockname&quot;</span>, getsockname); &#125;</span><br><span class="line"><span class="function">Address <span class="title">Socket::peer_address</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">get_address</span>(<span class="string">&quot;getpeername&quot;</span>, getpeername); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">这两个函数是用于把socket连到CS的</span></span><br><span class="line"><span class="comment">将socket的一端连上本机，就需要调用bind；连上别的什么东西就要用connect</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// bind socket to a specified local address (usually to listen/accept)</span></span><br><span class="line"><span class="comment">// address is a local Address to bind</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::bind</span><span class="params">(<span class="type">const</span> Address &amp;address)</span> </span>&#123; <span class="built_in">SystemCall</span>(<span class="string">&quot;bind&quot;</span>, ::<span class="built_in">bind</span>(<span class="built_in">fd_num</span>(), address, address.<span class="built_in">size</span>())); &#125;</span><br><span class="line"><span class="comment">// connect socket to a specified peer address</span></span><br><span class="line"><span class="comment">// address is the peer&#x27;s Address</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::connect</span><span class="params">(<span class="type">const</span> Address &amp;address)</span> </span>&#123; <span class="built_in">SystemCall</span>(<span class="string">&quot;connect&quot;</span>, ::<span class="built_in">connect</span>(<span class="built_in">fd_num</span>(), address, address.<span class="built_in">size</span>())); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shut down a socket in the specified way</span></span><br><span class="line"><span class="comment">// how can be `SHUT_RD`, `SHUT_WR`, or `SHUT_RDWR`</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::shutdown</span><span class="params">(<span class="type">const</span> <span class="type">int</span> how)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SystemCall</span>(<span class="string">&quot;shutdown&quot;</span>, ::<span class="built_in">shutdown</span>(<span class="built_in">fd_num</span>(), how));</span><br><span class="line">    <span class="keyword">switch</span> (how) &#123;</span><br><span class="line">        <span class="keyword">case</span> SHUT_RD:</span><br><span class="line">            <span class="built_in">register_read</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set socket option，传入协议层以及要设置非选项的键和值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> option_type&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setsockopt</span><span class="params">(<span class="type">const</span> <span class="type">int</span> level, <span class="type">const</span> <span class="type">int</span> option, <span class="type">const</span> option_type &amp;option_value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SystemCall</span>(<span class="string">&quot;setsockopt&quot;</span>, ::<span class="built_in">setsockopt</span>(<span class="built_in">fd_num</span>(), level, option, &amp;option_value, <span class="built_in">sizeof</span>(option_value)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allow local address to be reused sooner, at the cost of some robustness</span></span><br><span class="line"><span class="comment">// 以鲁棒性为代价，让local address可复用</span></span><br><span class="line"><span class="comment">// Using `SO_REUSEADDR` may reduce the robustness of your application</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::set_reuseaddr</span><span class="params">()</span> </span>&#123; <span class="built_in">setsockopt</span>(SOL_SOCKET, SO_REUSEADDR, <span class="built_in">int</span>(<span class="literal">true</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UDPSocket */</span></span><br><span class="line"><span class="comment">// 从socket中接收数据并放进datagram中</span></span><br><span class="line"><span class="comment">// If mtu is too small to hold the received datagram, this method throws a runtime_error</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDPSocket::recv</span><span class="params">(received_datagram &amp;datagram, <span class="type">const</span> <span class="type">size_t</span> mtu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// receive source address and payload</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> recv_len = <span class="built_in">SystemCall</span>(</span><br><span class="line">        <span class="string">&quot;recvfrom&quot;</span>,</span><br><span class="line">        ::<span class="built_in">recvfrom</span>(</span><br><span class="line">            <span class="built_in">fd_num</span>(), datagram.payload.<span class="built_in">data</span>(), datagram.payload.<span class="built_in">size</span>(), MSG_TRUNC, datagram_source_address, &amp;fromlen));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UDPSocket::received_datagram <span class="title">UDPSocket::recv</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> mtu)</span> </span>&#123;</span><br><span class="line">    received_datagram ret&#123;&#123;<span class="literal">nullptr</span>, <span class="number">0</span>&#125;, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">recv</span>(ret, mtu);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向socket发送数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendmsg_helper</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd_num,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> sockaddr *destination_address,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="type">socklen_t</span> destination_address_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> BufferViewList &amp;payload)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> bytes_sent = <span class="built_in">SystemCall</span>(<span class="string">&quot;sendmsg&quot;</span>, ::<span class="built_in">sendmsg</span>(fd_num, &amp;message, <span class="number">0</span>));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDPSocket::sendto</span><span class="params">(<span class="type">const</span> Address &amp;destination, <span class="type">const</span> BufferViewList &amp;payload)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sendmsg_helper</span>(<span class="built_in">fd_num</span>(), destination, destination.<span class="built_in">size</span>(), payload);</span><br><span class="line">    <span class="built_in">register_write</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDPSocket::send</span><span class="params">(<span class="type">const</span> BufferViewList &amp;payload)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sendmsg_helper</span>(<span class="built_in">fd_num</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>, payload);</span><br><span class="line">    <span class="built_in">register_write</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="TCPSpongeSocket"><a href="#TCPSpongeSocket" class="headerlink" title="* TCPSpongeSocket"></a>* TCPSpongeSocket</h3><p>上面那俩类其实就是两个包装类，用来将系统调用包装为c++类，看起来很抽象很迷惑。<strong>但到这就不一样了！我们开始用上我们之前写的TCP协议的代码了！</strong></p>
<p>除了跟fd以及socket一致的<code>read</code>、<code>write</code>以及<code>close</code>之外，<code>TCPSocket</code>最独特的功能，应该就是TCP连接的建立与释放了，其状态转移等逻辑已由我们在Lab0-4实现，此socket类仅实现<u>事件的监听</u>和<u>TCP协议对象生命周期的管理</u>。</p>
<h4 id="双线程"><a href="#双线程" class="headerlink" title="双线程"></a>双线程</h4><p>在详细说明其两个功能——事件监听和生命周期管理——之前，不妨先了解下其总体的架构。</p>
<p><code>TCPSpongeSocket</code>需要双线程实现。其中一个线程用来招待其owner：它会执行向owner public的connect、read、write等服务。另一个线程用来运行<code>TCPConnection</code>：它会时刻调用connection的tick方法，并且进行事件监听。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! \class TCPSpongeSocket</span></span><br><span class="line"><span class="comment">//! This class involves the simultaneous operation of two threads.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! One, the &quot;owner&quot; or foreground thread, interacts with this class in much the</span></span><br><span class="line"><span class="comment">//! same way as one would interact with a TCPSocket: it connects or listens, writes to</span></span><br><span class="line"><span class="comment">//! and reads from a reliable data stream, etc. Only the owner thread calls public</span></span><br><span class="line"><span class="comment">//! methods of this class.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! The other, the &quot;TCPConnection&quot; thread, takes care of the back-end tasks that the kernel would</span></span><br><span class="line"><span class="comment">//! perform for a TCPSocket: reading and parsing datagrams from the wire, filtering out</span></span><br><span class="line"><span class="comment">//! segments unrelated to the connection, etc.</span></span><br></pre></td></tr></table></figure>

<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>完成事件监听的核心部分是方法<code>_tcp_loop</code>以及<code>_initialize_TCP</code>中对<code>_eventloop</code>的初始化，还有<code>eventloop</code>的实现。</p>
<p>看下来其实理解难度不大（虽然细节很多并且我懒得研究了），但我认为很值得学习。</p>
<h5 id="initialize-TCP"><a href="#initialize-TCP" class="headerlink" title="_initialize_TCP"></a>_initialize_TCP</h5><p>主要功能是添加我们想监听的事件，有四个，分别是从app得到数据、有要向app发送的数据、从底层协议得到数据、有要向底层协议发送的数据。具体的话，代码和注释都写得很详细就不说了。</p>
<p>可以看到，TCP与协议栈交互【包括收发数据报】，是通过<code>AdaptT _datagram_adapter;</code>实现的；TCP与上层APP交互【包括传送数据】，是通过<code>LocalStreamSocket _thread_data;</code>实现的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::_initialize_TCP(<span class="type">const</span> TCPConfig &amp;config) &#123;</span><br><span class="line">    _tcp.<span class="built_in">emplace</span>(config);</span><br><span class="line">    <span class="comment">// Set up the event loop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are four possible events to handle:需要监听以下四种事件</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 1) Incoming datagram received (needs to be given to</span></span><br><span class="line">    <span class="comment">//    TCPConnection::segment_received method)得到底层协议栈送过来的data</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 2) Outbound bytes received from local application via a write()</span></span><br><span class="line">    <span class="comment">//    call (needs to be read from the local stream socket and</span></span><br><span class="line">    <span class="comment">//    given to TCPConnection::data_written method)得到上层app送过来的data</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 3) Incoming bytes reassembled by the TCPConnection</span></span><br><span class="line">    <span class="comment">//    (needs to be read from the inbound_stream and written</span></span><br><span class="line">    <span class="comment">//    to the local stream socket back to the application)TCP协议需要向app写入data</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 4) Outbound segment generated by TCP (needs to be</span></span><br><span class="line">    <span class="comment">//    given to underlying datagram socket)TCP需要向外界发送data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 1: read from filtered packet stream and dump into TCPConnection得到外界data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::In,</span><br><span class="line">                        [&amp;] &#123;</span><br><span class="line">                            <span class="keyword">auto</span> seg = _datagram_adapter.<span class="built_in">read</span>();</span><br><span class="line">                            <span class="keyword">if</span> (seg) &#123;</span><br><span class="line">                                _tcp-&gt;<span class="built_in">segment_received</span>(<span class="built_in">move</span>(seg.<span class="built_in">value</span>()));</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (_thread_data.<span class="built_in">eof</span>() <span class="keyword">and</span> _tcp.<span class="built_in">value</span>().<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> _fully_acked) &#123; _fully_acked = <span class="literal">true</span>; &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        [&amp;] &#123; <span class="keyword">return</span> _tcp-&gt;<span class="built_in">active</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 2: read from pipe into outbound buffer得到app data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">        <span class="comment">// LocalStreamSocket _thread_data;</span></span><br><span class="line">		<span class="comment">// 看来用户是通过socket写入的数据</span></span><br><span class="line">        _thread_data,</span><br><span class="line">        Direction::In,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> data = _thread_data.<span class="built_in">read</span>(_tcp-&gt;<span class="built_in">remaining_outbound_capacity</span>());</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> len = data.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> amount_written = _tcp-&gt;<span class="built_in">write</span>(<span class="built_in">move</span>(data));</span><br><span class="line">            <span class="keyword">if</span> (amount_written != len) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;TCPConnection::write() accepted less than advertised length&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (_thread_data.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">                _tcp-&gt;<span class="built_in">end_input_stream</span>();</span><br><span class="line">                _outbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        [&amp;] &#123; <span class="built_in">return</span> (_tcp-&gt;<span class="built_in">active</span>()) <span class="built_in">and</span> (<span class="keyword">not</span> _outbound_shutdown) <span class="built_in">and</span> (_tcp-&gt;<span class="built_in">remaining_outbound_capacity</span>() &gt; <span class="number">0</span>); &#125;,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            _tcp-&gt;<span class="built_in">end_input_stream</span>();</span><br><span class="line">            _outbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 3: read from inbound buffer into pipe向app写入data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">        _thread_data,</span><br><span class="line">        Direction::Out,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            ByteStream &amp;inbound = _tcp-&gt;<span class="built_in">inbound_stream</span>();</span><br><span class="line">            <span class="comment">// Write from the inbound_stream into the pipe</span></span><br><span class="line">            <span class="type">const</span> <span class="type">size_t</span> amount_to_write = <span class="built_in">min</span>(<span class="built_in">size_t</span>(<span class="number">65536</span>), inbound.<span class="built_in">buffer_size</span>());</span><br><span class="line">            <span class="type">const</span> std::string buffer = inbound.<span class="built_in">peek_output</span>(amount_to_write);</span><br><span class="line">            <span class="comment">// 通过向socket写实现</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> bytes_written = _thread_data.<span class="built_in">write</span>(<span class="built_in">move</span>(buffer), <span class="literal">false</span>);</span><br><span class="line">            inbound.<span class="built_in">pop_output</span>(bytes_written);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inbound.<span class="built_in">eof</span>() <span class="keyword">or</span> inbound.<span class="built_in">error</span>()) &#123;</span><br><span class="line">                _thread_data.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">                _inbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="keyword">not</span> _tcp-&gt;<span class="built_in">inbound_stream</span>().<span class="built_in">buffer_empty</span>()) <span class="built_in">or</span></span><br><span class="line">                   ((_tcp-&gt;<span class="built_in">inbound_stream</span>().<span class="built_in">eof</span>() <span class="keyword">or</span> _tcp-&gt;<span class="built_in">inbound_stream</span>().<span class="built_in">error</span>()) <span class="keyword">and</span> <span class="keyword">not</span> _inbound_shutdown);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 4: read outbound segments from TCPConnection and send as datagrams向外界写data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::Out,</span><br><span class="line">                        [&amp;] &#123;</span><br><span class="line">                            <span class="keyword">while</span> (<span class="keyword">not</span> _tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                                <span class="comment">// 通过对adapter写实现</span></span><br><span class="line">                                _datagram_adapter.<span class="built_in">write</span>(_tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">front</span>());</span><br><span class="line">                                _tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        [&amp;] &#123; <span class="keyword">return</span> <span class="keyword">not</span> _tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tcp-loop"><a href="#tcp-loop" class="headerlink" title="_tcp_loop"></a>_tcp_loop</h5><p>可以看到，<code>_tcp_loop</code>的功能就是，在<code>condition</code>为真的时候，一是监听我们之前塞进<code>_event_loop</code>的所有事件，二是调用<code>TCPConnection</code>的<code>tick</code>方法来管理时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// condition is a function returning true if loop should continue</span></span><br><span class="line"><span class="comment">// Process events while specified condition is true</span></span><br><span class="line"><span class="comment">// 周期性调用事件condition以达到监听等待事件的效果，管理TCP的tick</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::_tcp_loop(<span class="type">const</span> function&lt;<span class="built_in">bool</span>()&gt; &amp;condition) &#123;</span><br><span class="line">    <span class="keyword">auto</span> base_time = <span class="built_in">timestamp_ms</span>();</span><br><span class="line">    <span class="comment">// 当条件一直为真时，监听event</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">condition</span>()) &#123;</span><br><span class="line">        <span class="comment">// 持续监听eventloop中的各种event</span></span><br><span class="line">        <span class="keyword">auto</span> ret = _eventloop.<span class="built_in">wait_next_event</span>(TCP_TICK_MS);</span><br><span class="line">        <span class="comment">// 条件为退出/丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (ret == EventLoop::Result::Exit <span class="keyword">or</span> _abort) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果tcp还存活，则调用其tick方法</span></span><br><span class="line">        <span class="keyword">if</span> (_tcp.<span class="built_in">value</span>().<span class="built_in">active</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> next_time = <span class="built_in">timestamp_ms</span>();</span><br><span class="line">            _tcp.<span class="built_in">value</span>().<span class="built_in">tick</span>(next_time - base_time);</span><br><span class="line">            _datagram_adapter.<span class="built_in">tick</span>(next_time - base_time);</span><br><span class="line">            base_time = next_time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="eventloop"><a href="#eventloop" class="headerlink" title="eventloop"></a>eventloop</h5><p>eventloop具体是通过Linux提供的poll机制来进行事件监听的。</p>
<blockquote>
<p><a href="https://blog.csdn.net/m0_49328056/article/details/123454707">Linux poll机制</a></p>
<p>怎么说，又一次感受到了“<strong>网络就是IO</strong>”这个抽象的牛逼之处。操作系统的poll机制和poll函数本质上是针对IO读写来设计的，而正因为网络的本质是IO，正因为网络收发数据包、与上层app交互本质还是IO（因为通过文件描述符），才能在这里采用这种方式进行文件读写。</p>
<p>我的评价是佩服到五体投地好吧</p>
<p><img src="/2023/02/25/cs144/image-20230310185319115.png" alt="image-20230310185319115"></p>
<p><strong>poll函数就是IO等待的一种实现机制。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>事件类型events可以为下列值：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">POLLIN</span>:<span class="string">有数据可读</span></span><br><span class="line"><span class="attr">POLLRDNORM</span>:<span class="string">有普通数据可读，等效于POLLIN</span></span><br><span class="line"><span class="attr">POLLRDBAND</span>:<span class="string">有优先数据可读</span></span><br><span class="line"><span class="attr">POLLPRI</span>:<span class="string">有紧迫数据可读</span></span><br><span class="line"><span class="attr">POLLOUT</span>:<span class="string">写数据不会导致阻塞</span></span><br><span class="line"><span class="attr">POLLWRNORM</span>:<span class="string">写普通数据不会导致阻塞</span></span><br><span class="line"><span class="attr">POLLWRBAND</span>:<span class="string">写优先数据不会导致阻塞</span></span><br><span class="line"><span class="attr">POLLMSG</span>:<span class="string">SIGPOLL消息可用</span></span><br><span class="line"><span class="attr">POLLER</span>:<span class="string">指定的文件描述符发生错误</span></span><br><span class="line"><span class="attr">POLLHUP</span>:<span class="string">指定的文件描述符挂起事件</span></span><br><span class="line"><span class="attr">POLLNVAL</span>:<span class="string">无效的请求，打不开指定的文件描述符</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们在前面的eventloop的rule初始化中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::In,</span><br><span class="line">                        [&amp;] &#123; ... &#125;);</span><br></pre></td></tr></table></figure>

<p>这个的意思是针对<code>_datagram_adapter</code>这个文件的<code>Direction::In</code>这个事件发生时，就会执行<code>[&amp;]</code>中的事件。那么<code>Direction::In</code>是什么？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Direction</span> : <span class="type">short</span> &#123;</span><br><span class="line">    In = POLLIN,   <span class="comment">//!&lt; Callback will be triggered when Rule::fd is readable.</span></span><br><span class="line">    Out = POLLOUT  <span class="comment">//!&lt; Callback will be triggered when Rule::fd is writable.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见，eventloop具体是通过os提供的IO事件机制来进行监听的。</p>
<p>具体的监听以及执行逻辑由<code>wait_next_event</code>来实现。它主要干的就是，清理掉那些我们不感兴趣的或者已经似了（比如说对应的fd已经close之类的）的事件，然后找到那些触发到了的active的事件并且调用它们的caller。</p>
<p>具体代码还是有些微复杂的，有兴趣可以去看看，这里就不放了。</p>
<h4 id="生命周期的管理"><a href="#生命周期的管理" class="headerlink" title="生命周期的管理"></a>生命周期的管理</h4><p>核心部分为方法<code>connect</code>、<code>listen_and_accept</code>以及<code>_tcp_main</code>。</p>
<h5 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h5><p>由客户端调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client调用</span></span><br><span class="line"><span class="comment">// 未收到外界连接时，owner进程会阻塞</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::<span class="built_in">connect</span>(<span class="type">const</span> TCPConfig &amp;c_tcp, <span class="type">const</span> FdAdapterConfig &amp;c_ad) &#123;</span><br><span class="line">    <span class="comment">// 初始化tcp的事件监听</span></span><br><span class="line">    _initialize_TCP(c_tcp);</span><br><span class="line">    <span class="comment">// 初始化adapater</span></span><br><span class="line">    _datagram_adapter.<span class="built_in">config_mut</span>() = c_ad;</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: Connecting to &quot;</span> &lt;&lt; c_ad.destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;...\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 我们实现的：发送SYN报文</span></span><br><span class="line">    _tcp-&gt;<span class="built_in">connect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一的状态管理</span></span><br><span class="line">    <span class="type">const</span> TCPState expected_state = TCPState::State::SYN_SENT;</span><br><span class="line">    <span class="comment">// 等待直到条件为假，也即脱离SYN-SENT转移到ESTABLISHED</span></span><br><span class="line">    _tcp_loop([&amp;] &#123; <span class="keyword">return</span> _tcp-&gt;<span class="built_in">state</span>() == TCPState::State::SYN_SENT; &#125;);</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Successfully connected to &quot;</span> &lt;&lt; c_ad.destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立连接后开启connection进程, 执行_tcp_main，继续监听event直到死亡</span></span><br><span class="line">    _tcp_thread = <span class="built_in">thread</span>(&amp;TCPSpongeSocket::_tcp_main, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tcp-main"><a href="#tcp-main" class="headerlink" title="_tcp_main"></a>_tcp_main</h5><p>负责establish状态的监听以及之后关闭TCP连接的擦屁股工作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::_tcp_main() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> _tcp.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;no TCP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 持续监听直到死亡</span></span><br><span class="line">        _tcp_loop([] &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br><span class="line">        <span class="built_in">shutdown</span>(SHUT_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> _tcp.<span class="built_in">value</span>().<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;DEBUG: TCP connection finished &quot;</span></span><br><span class="line">                 &lt;&lt; (_tcp.<span class="built_in">value</span>().<span class="built_in">state</span>() == TCPState::State::RESET ? <span class="string">&quot;uncleanly&quot;</span> : <span class="string">&quot;cleanly.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _tcp.<span class="built_in">reset</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Exception in TCPConnection runner thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="listen-and-accept"><a href="#listen-and-accept" class="headerlink" title="listen_and_accept"></a>listen_and_accept</h5><p>由服务器端调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Server调用</span></span><br><span class="line"><span class="comment">// 未收到外界连接时，owner进程会阻塞</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::<span class="built_in">listen_and_accept</span>(<span class="type">const</span> TCPConfig &amp;c_tcp, <span class="type">const</span> FdAdapterConfig &amp;c_ad) &#123;</span><br><span class="line">     _initialize_TCP(c_tcp);</span><br><span class="line">    _datagram_adapter.<span class="built_in">config_mut</span>() = c_ad;</span><br><span class="line">    </span><br><span class="line">    _datagram_adapter.<span class="built_in">set_listening</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: Listening for incoming connection...\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 等待直到ESTABLISHED。注意下这里的状态条件</span></span><br><span class="line">    <span class="comment">// 其中各种收发报文的事件由tcp_loop中的event做</span></span><br><span class="line">    _tcp_loop([&amp;] &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> s = _tcp-&gt;<span class="built_in">state</span>();</span><br><span class="line">        <span class="built_in">return</span> (s == TCPState::State::LISTEN <span class="keyword">or</span> s == TCPState::State::SYN_RCVD <span class="keyword">or</span> s == TCPState::State::SYN_SENT);</span><br><span class="line">    &#125;);</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;New connection from &quot;</span> &lt;&lt; _datagram_adapter.<span class="built_in">config</span>().destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启connection进程</span></span><br><span class="line">    _tcp_thread = <span class="built_in">thread</span>(&amp;TCPSpongeSocket::_tcp_main, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CS144TCPSocket-和-FullStackSocket"><a href="#CS144TCPSocket-和-FullStackSocket" class="headerlink" title="CS144TCPSocket 和 FullStackSocket"></a>CS144TCPSocket 和 FullStackSocket</h3><p>主菜（上面那个）已经说完了，这两个就是简单的包装类，没什么好说的，大概就做了点传参工作，主要差异还是adapter。</p>
<h3 id="Adapter实现"><a href="#Adapter实现" class="headerlink" title="Adapter实现"></a>Adapter实现</h3><p>在我们的<code>TCPSpongeSocket</code>实现中，我们引入了“adapter”的概念。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//! Adapter to underlying datagram socket (e.g., UDP or IP)</span></span><br><span class="line">    AdaptT _datagram_adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> TCPOverUDPSpongeSocket = TCPSpongeSocket&lt;TCPOverUDPSocketAdapter&gt;;</span><br><span class="line"><span class="keyword">using</span> TCPOverIPv4SpongeSocket = TCPSpongeSocket&lt;TCPOverIPv4OverTunFdAdapter&gt;;</span><br><span class="line"><span class="keyword">using</span> TCPOverIPv4OverEthernetSpongeSocket = TCPSpongeSocket&lt;TCPOverIPv4OverEthernetAdapter&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LossyTCPOverUDPSpongeSocket = TCPSpongeSocket&lt;LossyTCPOverUDPSocketAdapter&gt;;</span><br><span class="line"><span class="keyword">using</span> LossyTCPOverIPv4SpongeSocket = TCPSpongeSocket&lt;LossyTCPOverIPv4OverTunFdAdapter&gt;;</span><br></pre></td></tr></table></figure>

<p>它很完美地以策略模式的形式，凝结出了我们本次实验所需的各种协议栈的共同代码，放进了<code>TCPSpongeSocket</code>，而将涉及到协议栈差异的部分用adapter完成。</p>
<p>在<code>TCPSpongeSocket</code>中，adapter主要完成了如下操作：</p>
<ol>
<li><p>adapter的tick函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in tcp_loop</span></span><br><span class="line">_tcp.<span class="built_in">value</span>().<span class="built_in">tick</span>(next_time - base_time);</span><br><span class="line">_datagram_adapter.<span class="built_in">tick</span>(next_time - base_time);</span><br></pre></td></tr></table></figure></li>
<li><p>作为订阅事件的IO流</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::In,</span><br><span class="line">                        [&amp;] &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li>
<li><p>TCP层通过对其读写来获取TCP segment</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto seg = _datagram_adapter.read();</span><br><span class="line">_datagram_adapter.write(_tcp-&gt;segments_out().front());</span><br></pre></td></tr></table></figure></li>
<li><p>记录各类参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">datagram_adapter.<span class="built_in">config</span>().destination.<span class="built_in">to_string</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/2023/02/25/cs144/class_fd_adapter_base__inherit__graph.png" alt="Inheritance graph"></p>
<p>具体实现说实话没什么好说的，确实无非也就是上面那几个方法，然后在里面包装下和操作系统提供的tun和tap的接口交互罢了，代码也比较简单，此处就不说了。</p>
<h2 id="apps"><a href="#apps" class="headerlink" title="apps"></a>apps</h2><p>除了对协议栈的实现之外，在app文件夹下还有许多对我们实现的协议栈的应用实例。我认为了解下应用实例也是很重要的。</p>
<h3 id="bidirectional-stream-copy"><a href="#bidirectional-stream-copy" class="headerlink" title="bidirectional_stream_copy"></a>bidirectional_stream_copy</h3><p>其作用就是建立stdin/stdout与socket的关联。它从stdin读输入，作为上层app的输入写入socket；从socket读输出，传给上层app，也即stdout输出。它的具体实现在stdin/stdout之间隔了两条bytestream，分别是<code>_inbound</code>和<code>_outbound</code>。</p>
<p>由于stdin、stdout、socket本质上都是fd，所以我们依然可以采用跟上面一样的事件驱动方式。我们只需在socket有输出时马上读给inbound bytestream，在inbound bytestream有输入时马上读给stdout，在stdin有输入时马上写入outbound bytestream，在outbound bytestream有输入时马上读给socket。遵守这4条rule就行了。</p>
<p>因而，具体实现就是<code>TCPSpongeSocket::_initialize_TCP</code>和<code>TCPSpongeSocket::_tcp_loop</code>的结合体，订阅事件+循环等待。由于跟前面类似，在此就不放代码了。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他都太复杂了，感觉我水平一般还不大能理解，也懒得看了【草】总之先咕咕咕</p>
]]></content>
  </entry>
  <entry>
    <title>Lab6   Router</title>
    <url>/2023/02/25/cs144$lab6/</url>
    <content><![CDATA[<h1 id="Lab6-Router"><a href="#Lab6-Router" class="headerlink" title="Lab6   Router"></a>Lab6   Router</h1><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="要做什么"><a href="#要做什么" class="headerlink" title="要做什么"></a>要做什么</h3><p>本次实验要实现的是IP层的路由工作，但是只用实现对路由表进行操作的部分，比如说增加表项以及查询路由表等，其他的什么RIP、OSPF都不用我们实现，所以这样一来其实就简单非常多了（）</p>
<p>有一点需要注意的是，它一直在强调一个“最长前缀匹配”。也就是：</p>
<p><img src="/2023/02/25/cs144/image-20230309142032359.png" alt="image-20230309142032359"></p>
<p><img src="/2023/02/25/cs144/image-20230309141949757.png" alt="image-20230309141949757"></p>
<p>还有一点需要注意的是路由的结构：</p>
<p><img src="/2023/02/25/cs144/image-20230308142934287.png" alt="image-20230308142934287"></p>
<p>实际上就是路由表+一堆网络接口，这些端口都是network interface。</p>
<blockquote>
<p>路由器可分为两部分，一部分控制路由协议，包括完善路由表之类的；另一部分负责数据转发。</p>
<p>负责接收数据的端口既可能收到数据，也可能收到路由信息报文。收到前者，则需要查询转发表然后进行路由转发；收到后者，就需要将其交付给路由选择处理机进行处理。</p>
<p>它有一个地方说得很有意思：路由表需要对网络拓扑最优化，转发表需要使查找过程最优化</p>
<p>也就是说，路由表只是key为目的IP地址，value为下一跳IP地址的一个普通map，可以是unordered_map，因为无需对它进行查找操作；转发表的内容可能跟路由表差不多，但是由于它要被进行频繁的查找工作，因而其数据结构需要对查找的消耗较低。</p>
<p>不过在我们这边，一般不区分路由表和转发表的概念。</p>
</blockquote>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>说实话思路很直观很简单，懒得说了，直接看代码吧【开摆】</p>
<p>我唯一卡得比较久的有两个地方，一个是一开始数据结构选用的是set，图它的天然排序，针对<code>prefix_length</code>排序来优化查找，但是没有意识到，对于自定义比较运算符的结构体，set也是会自动去重的（）而不同路由项的<code>prefix_length</code>显然可以重复。因而这样是达咩的，最后不得已选用了一个普通的list。</p>
<p>另一个是子网掩码计算问题，刚开始一个小地方想错了。这个没什么好说的，纯纯脑子一抽。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">route_node</span> &#123;</span><br><span class="line">        <span class="type">uint32_t</span> route_prefix = <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint8_t</span> prefix_length = <span class="number">0</span>;</span><br><span class="line">        std::optional&lt;Address&gt; next_hop&#123;&#125;;</span><br><span class="line">        <span class="type">size_t</span> interface_num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 降序</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> route_node &amp;b) <span class="type">const</span> &#123; <span class="keyword">return</span> prefix_length &gt; b.prefix_length; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::list&lt;route_node&gt; route_table&#123;&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::add_route</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="type">size_t</span> interface_num)</span> </span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: adding route &quot;</span> &lt;&lt; Address::<span class="built_in">from_ipv4_numeric</span>(route_prefix).<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">int</span>(prefix_length)</span><br><span class="line">         &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; (next_hop.<span class="built_in">has_value</span>() ? next_hop-&gt;<span class="built_in">ip</span>() : <span class="string">&quot;(direct)&quot;</span>) &lt;&lt; <span class="string">&quot; on interface &quot;</span> &lt;&lt; interface_num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    route_node node;</span><br><span class="line">    node.route_prefix = route_prefix;</span><br><span class="line">    node.prefix_length = prefix_length;</span><br><span class="line">    node.next_hop = next_hop;</span><br><span class="line">    node.interface_num = interface_num;</span><br><span class="line">    route_table.<span class="built_in">push_back</span>(node);</span><br><span class="line">    route_table.<span class="built_in">sort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] dgram The datagram to be routed</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::route_one_datagram</span><span class="params">(InternetDatagram &amp;dgram)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 减少TTL</span></span><br><span class="line">    <span class="keyword">if</span> (dgram.<span class="built_in">header</span>().ttl &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// drop</span></span><br><span class="line">    dgram.<span class="built_in">header</span>().ttl -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> target_ip = dgram.<span class="built_in">header</span>().dst;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = route_table.<span class="built_in">begin</span>(); it != route_table.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> mask = <span class="number">0</span>;</span><br><span class="line">        mask = (((~mask) &gt;&gt; (<span class="number">32</span>-it-&gt;prefix_length)) &lt;&lt; (<span class="number">32</span>-it-&gt;prefix_length));</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;prefix_length == <span class="number">0</span> || ((it-&gt;route_prefix &amp; mask) == (target_ip &amp; mask)))&#123;</span><br><span class="line">            <span class="comment">// 发送报文</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;next_hop.<span class="built_in">has_value</span>())</span><br><span class="line">                <span class="built_in">interface</span>(it-&gt;interface_num).<span class="built_in">send_datagram</span>(dgram, it-&gt;next_hop.<span class="built_in">value</span>());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">interface</span>(it-&gt;interface_num).<span class="built_in">send_datagram</span>(dgram,</span><br><span class="line">Address::<span class="built_in">from_ipv4_numeric</span>(dgram.<span class="built_in">header</span>().dst));</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 一定是最长前缀</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Go through all the interfaces, and route every incoming datagram to its proper outgoing interface.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;interface : _interfaces) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;queue = interface.<span class="built_in">datagrams_out</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">not</span> queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">route_one_datagram</span>(queue.<span class="built_in">front</span>());</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>状态机</title>
    <url>/2023/03/10/%E5%AF%B9moore%E5%9E%8B%E5%92%8Cmealy%E5%9E%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>复习数电时，一道密码锁题令我十分不解：</p>
<img src="/2023/03/10/%E5%AF%B9moore%E5%9E%8B%E5%92%8Cmealy%E5%9E%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E7%90%86%E8%A7%A3/aWorkStorage\hexo\blog\source\_posts\对moore型和mealy型状态机的理解\image-20230213201519568.png" alt="image-20230213201519568" style="zoom:33%;">

<p>看到题目时，我首先联想到的是mealy型状态机，因为我联想到了序列检测。课内的序列检测讲的时候是把它当做mealy型的。但看了标准作答之后，才发现它其实应该是moore型。这让我对这二者的区别产生了深深的不解。</p>
<p>原来对于moore型状态机和mealy型状态机的理解仅仅停留在概念上，“moore型状态机的输出与输入无关，只与当前状态有关”“mealy型状态机输出与输入和现态都有关”。但这其实是一句非常抽象的话：什么是“无关”，什么是“有关”？moore型状态机的状态不也是依据输入进行转移的吗？那么这算不算“有关”？</p>
<p>探究之后，我得到了更精确的“有关”“无关”的定义。</p>
<blockquote>
<p>来自：<a href="https://blog.51cto.com/u_15338162/5215788">Moore状态机和Mealy状态机的区别</a></p>
<img src="/2023/03/10/%E5%AF%B9moore%E5%9E%8B%E5%92%8Cmealy%E5%9E%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E7%90%86%E8%A7%A3/aWorkStorage\hexo\blog\source\_posts\对moore型和mealy型状态机的理解\image-20230213202110900.png" alt="image-20230213202110900" style="zoom:50%;">

<img src="/2023/03/10/%E5%AF%B9moore%E5%9E%8B%E5%92%8Cmealy%E5%9E%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E7%90%86%E8%A7%A3/aWorkStorage\hexo\blog\source\_posts\对moore型和mealy型状态机的理解\image-20230213202124943.png" alt="image-20230213202124943" style="zoom:50%;">
</blockquote>
<blockquote>
<p>来自：<a href="https://blog.csdn.net/qq_39507748/article/details/108764246">Moore状态机和Mealy状态机的区别(以序列检测器为例)</a></p>
<p>Moore状态机输出只与此时的状态有关，因此假如需要检测宽度为4的序列，则需要<strong>五个状态</strong>。</p>
<p>Mealy状态机输出与此时的状态以及输入有关，因此假如需要检测宽度为4的序列，只需要<strong>四个状态</strong>即可。</p>
</blockquote>
<p>联想到我们课上学习的序列检测：</p>
<img src="/2023/03/10/%E5%AF%B9moore%E5%9E%8B%E5%92%8Cmealy%E5%9E%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E7%90%86%E8%A7%A3/aWorkStorage\hexo\blog\source\_posts\对moore型和mealy型状态机的理解\image-20230213202320825.png" alt="image-20230213202320825" style="zoom:50%;">

<p>它这明明长度为3的序列用了4个状态，应该算是moore型，为什么我们却被教说序列检测器是mealy型状态机呢？</p>
<p>原因是因为，我们进行了<strong>状态化简</strong>这一步，将<strong>moore型状态机转化为了mealy型状态机</strong>。</p>
<blockquote>
<p>这俩是可以相互转化的</p>
<p>来自：<a href="pianshen.com/article/1017591353/">[转载][FPGA]有限状态机FSM学习笔记（二）</a></p>
<p>把Moore机转换为Mealy机的办法为，把次态的输出修改为对应现态的输出，同时合并一些具有等价性能的状态。把Mealy机转换为Moore机的办法是，把当前态的输出修改为对应次态的输出，同时添加一些状态。如图1所示，为把Mealy机状态图转化为Moore机状态图。</p>
<p><img src="/2023/03/10/%E5%AF%B9moore%E5%9E%8B%E5%92%8Cmealy%E5%9E%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E7%90%86%E8%A7%A3/aWorkStorage\hexo\blog\source_posts\对moore型和mealy型状态机的理解\ffde858ac67cfa7459c85b56f1301649.png" alt="img"><br>　　　　　　　　图1　　Mealy型机转换为Moore型机</p>
<p>　　如图1所示，把Mealy型机转换为Moore型机，只要把现时输出改变为下一时刻输出。对于状态A，有4个箭头指向它，表示在当前状态下有4个状态可以转换为下一状态的A；同时当前输出均为0，可以把0移入状态A内部，表示在Moore机中状态A的输出为0。同理，可以把0分别移位B/C状态。但对于状态D，有两个箭头指向且具有不同的输出值，需要把状态D分解成两个状态D1和D2（每个状态对应一个输出，当输出不同需要利用不同的状态表示，这即是Moore机具有更多状态的原因），得到完整的Moore机状态模型。</p>
<p>　　同理，若把上图的Moore机转换为Mealy机，只要把Moore机中下一状态的输出改变成Mealy机中当前状态的输出，由于D1/D2两状态处于A/C两状态之间，且相当于A/C节点之间的一个等效节点，可以把D1/D2两状态合并为一个状态。</p>
</blockquote>
<blockquote>
<p>来自：<a href="http://www.mamicode.com/info-detail-3045628.html">Moore型状态机和Mealy型状态机</a></p>
<p>并非所有时序电路都可以使用Mealy模型实现。 一些时序电路只能作为摩尔机器实现。</p>
</blockquote>
<p>所以，我们可以出此暴论：在课程范围内，首先以moore的思想来设计状态机。如果该状态机可以被化简，那么这道题就要用mealy型的来做；如果不能，那么这道题就是得用moore型状态机来做。</p>
<p>一开始的那个时序锁的moore状态机不能化简，因此它是moore型。</p>
<blockquote>
<p>这个点本来可以讲得更清楚一些的……只教会我们做题的套路有啥意思呢←_←</p>
</blockquote>
]]></content>
  </entry>
</search>
