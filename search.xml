<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Capping</title>
    <url>/2024/01/07/Capping/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/opennaive/p/3312731.html">https://www.cnblogs.com/opennaive/p/3312731.html</a></p>
</blockquote>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>主要提出了三个经过去重后解决<strong>碎片化问题</strong>的restore手段：<code>increasing cache size</code>, <code>container capping</code>, <code>using a forward assembly area</code>。</p>
<blockquote>
<p>capping是一种在去重阶段减少碎片化但会导致去重率降低的技术，这个在之前我已经看到了代码</p>
<p>实现；</p>
<p>【回想一下capping的实现，也确实。</p>
<p>每次dedup一次处理的segment大小为20MB，容器固定大小为4MB。</p>
<p>我们通过capping技巧降低碎片化程度。在capping的实现中，我们记录所有涉及到去重的容器中所需去重块数，&lt;container_id, chunk_num&gt;，并且当涉及容器过多时会舍弃那些chunk_num小的不进行去重。</p>
<p>因为，chunk_num小，说明容器中有效块少，读放大率大，碎片化程度大，所以与其引用这些有效率小的容器，不如牺牲一下去重率，再把这些重复块copy一次。】</p>
<p>forward assembly是一种在restore时进行cache和prefetch的技术，并且通过算法优化减少了cache所需的RAM。</p>
<p>【这个东西好像也是老朋友了，也即recipe+cachechunk restore的实现原理】</p>
</blockquote>
<h1 id="思考1"><a href="#思考1" class="headerlink" title="思考1"></a>思考1</h1><p>感觉之后有必要再回忆一下代码实现和论文里看到的专业名词的差异了。</p>
<p>首先，总结一下论文中的流程。需要备份的应用先将backup转化为数据流，通过网络传输到deduplication app上。后者经过分块、去重、写回这几个流程，外加gc和restore两个辅助流程，实现了备份管理组织。</p>
<p>其中落实到具体算法，分块流程采用content-based chunk，在具体实现中是通过各种hash算法计算出fingerprint，从而实现对各个chunk的区分；去重阶段是通过一个全局指纹表，来判断chunk的重复；写回阶段，是根据去重的结果，将需要写回的chunks以顺序形式分割为一个个容器（容器体现为一个个文件），写回磁盘。【这也体现出为什么说IO单位是一个container了，你读磁盘确实一次就是一次性读一个文件的啊（）】</p>
<p>再落实到具体的优化策略：</p>
<ol>
<li><p>data layout</p>
<p>去重结束后，会针对去重过程中收集到的块信息对数据布局进行适当的调整。</p>
<p>对于MFDedup策略，GC过程较为简单，可能最主要在restore的时候需要访问数据布局；</p>
<p>对于Odess，在GC中会根据二叉树进行数据块的迁移，保证<strong>每个叶子结点包含的chunks都大概率连续存储在连续的容器中</strong>，在restore时根据recipe进行恢复，从而无需访问数据布局。</p>
</li>
<li><p>capping【经典rewrite技术，通过降低去重率来提高恢复速度】</p>
<p>去重时，会根据容器的重复率进行capping，具体体现为造一个&lt;cid, chunk_num&gt;的map，根据这个map来进行容器的筛选。当涉及容器过多时会舍弃那些chunk_num小的不进行去重，从而<strong>限制一个备份版本能够使用的旧容器的最大数量</strong><code>FLAGS_CappingThreshold</code>（每20MB）和<strong>新容器最大数量</strong>（不超过5个，因为20MB/4MB）。</p>
<blockquote>
<p><img src="/2024/01/07/Capping/image-20231025221335792.png" alt="image-20231025221335792"></p>
<p>这段论述很精彩。要限制chunk碎片化，就是要限制restore过程中读取的容器数量；要限制restore涉及容器数量，就是要限制一个备份版本所涉及的所有容器数量；而所有容器数量中，我们能限制的就是这b最多能引用多少个旧容器。感觉这个逻辑链很完美。</p>
<p>不过，为什么不像gc那样通过计算每个容器的活chunk比例呢，就像gc那样？而且实现也无需太复杂，毕竟容器大小都是固定的，所以比例只需计算map-&gt;second*chunk_sz/c_sz这样粗略即可，然后从尾到头（降序）进行逐一判断该比率即可。</p>
<p><strong>这点值得思考下。</strong></p>
</blockquote>
</li>
<li><p>forward assembly</p>
<p>在writeback时，每个备份版本都有一个对应的文件（logicFile）记录其meta data，根据chunk的不同类型（dedup or unique）对其进行记录。然后之后在恢复过程中，遍历此logic file，就可以做到“预先得知需要取的容器”，【而且在具体实现中，是<strong>通过cid从小到大进行容器遍历</strong>的，因为cid连续表明文件创建连续表明磁盘连续】从而借助cache进行乱序恢复就行。</p>
<p>Odess由于预先根据二叉树进行了组织，所以在恢复过程中recipe涉及到的容器数会更少，读放大会更小。</p>
</li>
</ol>
<h1 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h1><p>这部分具体来说，就是详细介绍了capping和forward assembly area的运作方法。</p>
<ol>
<li><p>capping</p>
<p>capping的实现写法很容易理解，没什么好说的，但重要的是其思想精髓。我们的目的是防止备份碎片化，从而影响restore速率，保证读放大小。那么，为了保证读放大小，我们自然而然想到应该尽可能减少涉及到的容器个数（想想读放大计算公式），这也就是capping的核心思想：限制容器数量。</p>
<p>每个segment的新容器数量被限制在1~5范围内，旧容器数量由一个参数规定。</p>
</li>
<li><p>foward assembly area</p>
<blockquote>
<p>经典的LRU cache每次读入一整个容器，对一整个容器进行lru；这玩意每次读一个容器，仅保留容器中需要的chunks，会把容器其他部分释放</p>
</blockquote>
<p>这个相比起来有些复杂，并且跟以前看到的好像也不大一样，它大概更像是一个restore技术。在整个pipeline中，我们记录下recipe表。然后在恢复过程中，我们申请一块foward assembly area，每次读取一段recipe，然后根据recipe读取容器，并将所需chunks写入这块area中，若area开头有一段continuous的chunks，则写入文件，移动指针。</p>
<p>其中area以循环队列形式出现。这个也很容易理解，这个东西听起来就很循环。</p>
<p>fixed和rolling的区别可能是这样的。假设cache固定为1，也即一次只读入一个容器。fixed每次读取固定数量的recipe，然后全恢复完了再写回，恢复该段期间不读recipe；rolling的话就是每次读入一个container，就把前面continuous的部分写回，然后写回多少chunk就再继续读多少recipe，从而实现滚动。</p>
</li>
</ol>
<h1 id="思考2"><a href="#思考2" class="headerlink" title="思考2"></a>思考2</h1><p>码的，遇到了一个很严重的没想过的问题。。。</p>
<p>在论文中，那个recipe恢复的原理是一次读取固定大小，然后针对固定大小的地方进行随机恢复。但是我目前的写法的话需要进行多次的fseek，我就很害怕会导致每次fseek跨越很大。</p>
<p>但是，在实际测试中，我发现针对于cid、offset升序的情况，似乎这样得到的offset序列也是稳定升序的：</p>
<p><img src="/2024/01/07/Capping/image-20231027101550605.png" alt="image-20231027101550605"></p>
<p>并且经计算，非升序的仅占7%，并且平均seek跨越为23459150.000000。可以看到，这个数字还是比较resonable的，那么这玩意是不是gc的功劳呢？</p>
<p>测试需要等得久一些，不妨就先只从理论上来分析为什么这个GC算法可以让cid相邻的容器在文件中的位置也是稳定升序的。</p>
<p>好像仔细一想也确实，因为你看，你一个个segment处理是顺序的，所以你一个个chunks加入到chunks_to_add也是顺序的，这样就保证了内部升序，那么容器间升序是怎么做到的？额我怎么知道。。。这个好像更像数据内部特征了，与gc无瓜。</p>
<p><img src="/2024/01/07/Capping/image-20231027103752642.png" alt="image-20231027103752642"></p>
<p>确实，换了个数据集马上就寄了哎。而且看数据感觉能看得出来这b在不同容器间确实是反复横跳的。所以fseek的问题确实存在。</p>
<p>不过，我仔细想了想，感觉使用fseek跟它那啥玩意似乎各有优劣。</p>
<p>fseek：</p>
<ol>
<li>优点<ol>
<li>代码简单</li>
<li>一个container只用io一次</li>
</ol>
</li>
<li>缺点<ol>
<li>会反复横跳文件多个位置，并且这个横跳开销较大，我看到甚至好几次都跨度甚至达到g水平，有个2g和1g之类的</li>
</ol>
</li>
</ol>
<p>那啥玩意：</p>
<ol>
<li>优点<ol>
<li>不会发生横跳情况</li>
</ol>
</li>
<li>缺点<ol>
<li>一个container需要io多次，但是container io的seek部分应该跨度较小</li>
</ol>
</li>
</ol>
<p>等看完论文问一下两位学长吧，就问我简单粗暴用的那个seek开销会不会太大了，说明下发现测试数据中有跨度2g版本。</p>
<p>其实感觉也没必要了，毕竟最后测出来速度就是seek那个最牛逼。这可能也说明最主要开销还是容器重复IO罢。</p>
<p>草，感觉这里在说XX（）因为我们自始至终恢复都是直接恢复进RAM或者SSD的hhhh所以seek自然不是问题了</p>
<h1 id="evaluation"><a href="#evaluation" class="headerlink" title="evaluation"></a>evaluation</h1><p>文章中的评估方法这部分介绍得很详细，很适合菜鸡如我感受一下它的这个流程。</p>
<h2 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h2><ol>
<li><p>workgroup dataset：</p>
<p>There are 154 fulls and 392 incrementals in this 3.8 TB collection, with the fulls ranging from 3 GB to 56 GB, with a mean size of 21 GB. </p>
<p>模型是：每天一增量，每周一全量的备份日程。使用TTTD技术进行chunk处理。</p>
</li>
<li><p>2-year dataset</p>
<p>HPstorage提供（工业界），synthetic data set合成数据集，高度碎片化。</p>
<p>一开始是一个10GB的文件系统快照，每几天就会随机选择2%的文件，并且synthetically（综合地）改变每个文件中10%的内容，并且增加200MB新文件。</p>
<blockquote>
<p>During each simulated week, one full backup and four incremental backups, one for each other weekday, are taken via uncompressed tar for a total of 480 backups covering 96 simulated weeks (1.9 years).</p>
</blockquote>
<p>每周有1个全备份和4个增量备份，每天的备份都是以未压缩的tar形式存在，然后一共进行2 year，也即一共有480个backup、96个模拟周。</p>
<p>依然使用TTTD技术进行chunk处理。</p>
</li>
</ol>
<p>由于备份数量还是太多，所以在实际中应该是不可能保留所有这些备份的，而是会保留一定数量。所以，我们设置<strong>每个备份只被保留30天</strong>，也即在备份第n个backup时删除第n-30个backup。【当然，尝试了别的schedule发现了不会影响结果】</p>
<blockquote>
<p>此处介绍常见的备份轮换（<em>Backup rotation scheme</em>）算法（from <a href="https://en.wikipedia.org/wiki/Backup_rotation_scheme#">wiki</a>）：</p>
<ol>
<li><p><strong>Grandfather-Father-Son (GFS)</strong></p>
<p>这是一种经典的备份轮换方案，通常包括每日、每周和每月备份。每日备份称为“儿子”（Son），每周备份称为“父亲”（Father），每月备份称为“祖父”（Grandfather）。</p>
<p>儿子备份按照FIFO系统进行3个月的轮换。父亲备份类似地按照每两年的周期进行轮换，而祖父备份则按照每年的周期进行轮换。</p>
</li>
<li><p><strong>Tower of Hanoi</strong>：多级备份。例如，第一级备份可能是每天一次，第二级是每周一次，第三级是每月一次，以此类推。</p>
<p>感觉这个用了汉诺塔原理的备份轮换算法还挺有意思的，之后学习下汉诺塔是啥玩意，然后再来看看这个算法简介。</p>
</li>
<li><p><strong>Weekly Rotation</strong>：每周备份轮换，保留过去几周的备份。</p>
</li>
<li><p><strong>Daily Rotation</strong>：每日备份轮换，保留过去几天的备份。</p>
</li>
</ol>
</blockquote>
<h2 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h2><p>LRU caching, no capping</p>
<p>这个部分大概就是针对no capping的普通LRU，对两个数据集，测了随着cache增大而变化的speed factor、读放大这俩指标。</p>
<p><img src="/2024/01/07/Capping/image-20231027221346694.png" alt="image-20231027221346694"></p>
<p>可以看到图标是备份版本，纵轴是speed factor，横轴是cache大小。</p>
<p>然后根据线性回归算法说明了下碎片化程度与备份层级增多为线性强正相关，因而这也就说明，<strong>增加一倍的备份就会使restore速度double</strong>。</p>
<p>然后再说明了一下这两个数据集碎片化变化趋势不同，是因为碎片化程度可以被看做多个影响因素一维向量叠加后的成果，而不是一个固定的标量。</p>
<p><img src="/2024/01/07/Capping/image-20231028220214261.png" alt="image-20231028220214261"></p>
<h2 id="capping"><a href="#capping" class="headerlink" title="capping"></a>capping</h2><p>通过数据表示了capping后放弃的去重比率和速度提升倍数的关系。缓存越大，提升越有限，所以需要放弃更大比例的去重才能获取同样的效果。</p>
<p><img src="/2024/01/07/Capping/image-20231027223619971.png" alt="image-20231027223619971"></p>
<p>也表明了与碎片化的关系：</p>
<p><img src="/2024/01/07/Capping/image-20231027223837565.png" alt="image-20231027223837565"></p>
<p>不过为啥2year还能超过100%的？</p>
<p>这个则是体现了，去重率越低（rewrite越多）恢复速度越快，并且缓存越大越快。并且要注意segment大小需要适中。</p>
<p><img src="/2024/01/07/Capping/image-20231027224435204.png" alt="image-20231027224435204"></p>
<p>那么，此处为什么改变segment的大小，会影响capping效果，就值得思考。</p>
<p>假设cache足够大。首先，segment的大小不会影响capping的比率。所以我们需要从容器分布的角度来理解。由于segment只能体现局部性质，那么当一个容器在当前segment分布稀疏（导致被capping，从而其引用数据块的references从此被改变到新容器），而在之后的其他segment又密集，就会导致我们不大精准地rewrite了那部分数据。而当segment越大，我们的视野就越大，判断也会越精准，从而再次减小读放大，从而提高性能。</p>
<p>至于为什么当cache为128MB时，segment越大反而会起反效果呢？作者解释说，这是因为，去重过程中以S为segment大小相当于restore过程中以S为forward assembly area大小，而area越大，就必须得要有一个更大更充分的cache。那么如果当S接近于或大于cache size，LRU换入换出就会频繁，也就没半毛钱好处了。</p>
<h2 id="assembly"><a href="#assembly" class="headerlink" title="assembly"></a>assembly</h2><blockquote>
<p>RAM used for LRU is simply the number of container slots in the cache times the container size (4 MB). For the forward assembly area methods, it is the size of the forward assembly area.</p>
</blockquote>
<p>对于LRU来说，RAM大小指的是它的LRU列表元素个数*容器大小这个值；对于faa来说，RAM大小指的是forward assembly area的大小。</p>
<blockquote>
<p>在odes中，chunkcache的大小为128*4MB=512MB，应该是用的整块整块读的LRU算法</p>
</blockquote>
<p><img src="/2024/01/07/Capping/image-20231027232135327.png" alt="image-20231027232135327"></p>
<p>可以看到，在有限RAM的情况下，改进的restore算法相比于LRU有极大提升，且rolling猛于fixed。</p>
<h2 id="capping-amp-assembly"><a href="#capping-amp-assembly" class="headerlink" title="capping &amp; assembly"></a>capping &amp; assembly</h2><p>首先一开始大概说了下容器大小的影响，这个测试部分做得确实很完善：</p>
<p><img src="/2024/01/07/Capping/image-20231028132153808.png" alt="image-20231028132153808"></p>
<blockquote>
<p>在存储领域中，backup ingestion是什么意思</p>
<p>在存储领域中，”backup ingestion” 指的是备份摄取或备份导入的过程。这一阶段涉及将备份数据从源存储系统传输或复制到备份系统中，以确保数据的安全存储和管理。这个过程可能包括数据传输、数据转换、压缩、加密等步骤，确保备份数据能够有效地存储和恢复。</p>
<p>意思是说deduplication是在这个过程进行的吗</p>
<p>是的，通常在备份摄取（backup ingestion）的过程中，会应用去重（deduplication）技术。去重的目标是识别和消除备份数据中的重复块，以节省存储空间并提高备份效率。在备份数据传输到备份系统之前或之后，去重过程可以帮助减少存储需求，降低备份存储的成本，并加速备份和恢复操作。</p>
</blockquote>
<p>提到了个sparce indexing，感觉有必要先去看看mfdedup的indexing方法。</p>
<p>在看之前，可以先稍微回忆下你现在理解的indexing是什么。回忆一下去重过程，本质上就是对到来的数据流进行重复检测，不重复则写入新的container，重复则找到以前重复块的位置进行引用。其中这个“重复检测”我想就是indexing的工作。具体而言，它应该是一张表的形式，记录着每个chunk的fp及其所处的位置。那么，将它存储在哪，以及如何对它进行快速查找，这就是我们需要考虑的。</p>
<p>在Odess实现中，提供了两种存储这个indexing table的形式。一个是存储在内存，另一个是通过<strong>RocksDB</strong>存储在磁盘中。</p>
<p>对于sparce indexing，它大概思想就是每次只抽样查询部分的indexing table来判断去重。</p>
<blockquote>
<p>sparce indexing：</p>
<p>一般来说，基于chunks的去重都要求使用full index，而这RAM一般承受不起，但是纯用disk io就太慢了。所以它采取了一招：</p>
<ol>
<li><p>将input stream划分为多个segment，每个segment仅与它最接近的之前的某个segment进行去重，也即<u>只需对那个被选中的抽样segment进行index构建</u>。</p>
</li>
<li><p>为了找到最接近的segment，使用了sampling（抽样）和sparce indexing。</p>
<ol>
<li><p>samples： We <strong>choose a small portion of the chunks in the stream as samples</strong>; samples是一些chunks。</p>
</li>
<li><p>sparce indexing：Our sparse index <strong>maps</strong> these samples <strong>to the existing segments</strong> in which they occur.也就是&lt;fp, segment_id&gt;</p>
</li>
</ol>
</li>
<li><p>避免了full index，而只有sampled chunks的fp被保留在RAM中。</p>
</li>
</ol>
<p>它所用的数据局部性：</p>
<p>If two pieces of backup streams share any chunks, they are likely to share many chunks. <u>如果两个segment共享了某个chunk，那么它们很有可能共享很多chunks。</u></p>
<p><strong>也就是说，它是这样的流程：</strong></p>
<ol>
<li>以segment为单位读取input stream；</li>
<li>计算该segment的每个chunk的fp，然后对每个chunk查询sparce indexing table: &lt;fp, segment_id&gt;，记录所需读取的segment_id；</li>
<li>读取这些segment_id对应的segment的chunk indexing table（存储在disk中）；</li>
<li>for every chunks： 重复，copy entry ；不重复，add to new container</li>
<li>最后再将该segment的信息写入磁盘，填写sparce indexing表。</li>
</ol>
<p>而sparce indexing表最一开始，由对input segment进行chunks的随机抽样得出（或者逐渐构建起来，反正大概是这个意思）</p>
<p>可以看到，它将segment info保留在disk中，在RAM中只保留fp2seg_id的映射，每次只需简单从磁盘中读取几个segment info即可，利用数据局部性极大地降低了磁盘IO次数。</p>
</blockquote>
<p>然后我猜测估计mfdedup的indexing就是只保留neighborhood的indexing，也是类似的意思。</p>
<p>这个sparce indexing的好处除了有节省RAM之外，还有一个减少碎片化（因为每次只从受限个数的segment中进行去重，resonable）</p>
<p>我们对其算法进行了一定修改：将sparce indexing从原来的&lt;fp, seg_id&gt;改为&lt;fp, cid&gt;，并且每次只取top T个包含sample chunks最多的容器，从而将对segment进行cap修改为对container进行cap。仔细想想，这样确实依然保证了原算法的核心思想，也属于是segment size = container size的特种了。</p>
<p>草，不过这个&lt;fp, cid&gt;不就是Odess中的recipe（或者说是全局指纹表）吗？乐。Odess也确实体现了这种capping+sparce indexing结合的方法【只不过进行简化了，每个chunk固定取其第一个container】，只能说不愧是落地实现，处处映射。</p>
<h1 id="future-works"><a href="#future-works" class="headerlink" title="future works"></a>future works</h1><p>我们目前这玩意还是有缺点，就是它只是针对局部的segment进行capping，可能就使优化效果不是那么绝对。所以我们提出了两个解决方法：</p>
<ol>
<li><p>adaptive capping</p>
<p>令当前的capping level根据recent segment的container nums进行调整，也许可以理解为再给这个recent seg的&lt;cid, nums&gt;信息进行一个FIFO，从而将局部视角扩展到略微全局平均一点的视角。</p>
<p>这个会在那些unevenly fragment的备份中起到更好的优化作用。【至于为什么，可以回忆下我之前说的那个在一些部分被稀疏引用、在一些部分被密集引用的那个例子。具体大概在evaluation-capping那个部分。】</p>
</li>
<li><p>只记录recent segment中是否被使用，而不记录具体使用情况（如次数）</p>
<blockquote>
<p>We hope this will give us the same performance as using a larger segment size without actually needing to increase our segment buffer space.</p>
</blockquote>
<p>这也是我之前提到的，当cache足够大，segment理论上是越大越好的，因为这样就会有全局视角。</p>
</li>
</ol>
<h1 id="related-works"><a href="#related-works" class="headerlink" title="related works"></a>related works</h1><ol>
<li><p>CBR</p>
<p>CBR和Capping的思想极为相似。</p>
<p>CBR：当且仅当某个容器包含该段至少T个块时，才会dedup该容器在该段中的chunks。并且这个T是会adaptive的。</p>
<p>听起来简直和capping一模一样，只不过确实如blog所说capping更注重限制容器个数，从而获取<strong>读性能</strong>；CBR更注重限制<strong>rewrite比率</strong>。而且由于T的adaptive，CBR很有可能unbound，也即万一T=1那么碎片化问题无法缓解。</p>
</li>
<li></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>精炼一下看完这篇论文后我的收获。</p>
<ol>
<li><p>design</p>
<p>首先是对论文提出算法的理解。</p>
<p>论文提出的最有用的应该就是<strong>capping</strong>这个rewrite技术。它的核心思想是将input stream划分为定长segment（通常20MB），通过限制每个segment的容器数量（重复chunks所在容器数、新容器数（不超过5个）），对部分chunks进行deny dedup重写，从而减少restore过程的读放大。</p>
</li>
<li><p>evaluation</p>
<p>然后就是论文中写得很好的evaluation部分了。它主要从以下这几个方面进行了全方位的性能评估：baseline、only capping、only assembly、capping+assembly。</p>
<ol>
<li><p>测试指标：containers read per MB restored（读放大）、speed factor（1/读放大）、cumulative deduplication factor（累积去重率）、relative loss of cumulative deduplication factor（放弃的去重比率）、缓存大小</p>
</li>
<li><p>dataset：介绍了两个经典data set，很值得看看，体会下practical的备份场景是什么样的。</p>
</li>
<li><p>baseline：由于我们之后的几个实验都需要测试缓存大小对restore相关指标的影响，所以在一开始首先测试基准情况下随缓存大小的指标变化。</p>
<p>基准情况：no capping， no assembly； use LRU cache to restore</p>
<p>指标：containers read per MB restored <strong>&amp;&amp;</strong> speed factor 随备份版本号变化，with different cache size</p>
</li>
<li><p>capping：</p>
<p>指标：cumulative deduplication factor和speed factor的关系、relative去重率和relative速度的关系；with different <strong>cache size</strong> and <strong>segment size</strong></p>
<p>重点体现了capping在降低去重率和提升restore速率之间的平衡；以及测试了capping相关指标（segment size）对capping的影响。</p>
</li>
<li><p>assembly：</p>
<p>指标：与baseline进行speed factor的对比测试；with different cache size</p>
</li>
<li><p>both</p>
<p>没什么好说的，体现了下container size的影响。</p>
</li>
</ol>
</li>
</ol>
<p>总的来说，是一篇测试很完善、rewrite很经典的文章，让本垃圾入门者也能轻易get到的好文。</p>
]]></content>
  </entry>
  <entry>
    <title>总结—2023全国大学生计算机系统能力大赛-OS功能</title>
    <url>/2023/08/27/2023-os-comp/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><ul>
<li><p>竞赛简介</p>
<p>全国大学生计算机系统能力大赛可以说是计算机专业除了ACM以外专业性最高的比赛之一了。内分多个赛道，如CPU设计（“龙芯杯”）、编译器设计（“毕昇杯”）、数据库设计以及操作系统设计。其中操作系统设计赛又分为内核实现和功能挑战两个赛道，我这一次参加的是<strong>功能赛道</strong>。</p>
<p>功能赛道的主要任务就是，从给定的265个赛题中选出一个赛题，并围绕此赛题做项目。项目周期为半年左右（其中3.28~6.07为初赛阶段，6.10~8.15为决赛阶段），并在最后有线下答辩以及代码现场检查验收。</p>
</li>
<li><p>团队</p>
<p>这是我在<strong>大二</strong>时参加的比赛。我作为<strong>队员</strong>，与两位高年级成员一起参加比赛，并且在最后取得了<strong>全国一等奖</strong>的成绩。（详情可见<a href="https://os.educg.net/#/index">官网公示</a>）</p>
<p><img src="/2023/08/27/2023-os-comp/image-20230827152845720.png" alt="image-20230827152845720"></p>
</li>
<li><p>项目简介</p>
<p>详见我们的<a href="https://gitlab.eduxiji.net/202318123111334/project1466467-176093">项目首页</a>。我们的代码分别托管在多个仓库，<a href="https://gitlab.eduxiji.net/202318123111334/project1466467-176093#%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93:~:text=%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%94%B1%E5%A4%9A%E4%B8%AA%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E7%BB%84%E6%88%90%EF%BC%8C%E6%89%98%E7%AE%A1%E5%9C%A8%20GitHub%20%E6%88%96%20Gitlab%20%E4%B8%8A">仓库链接</a>放在了首页的最后一部分。</p>
<p>简单来讲，我们的项目就是实现一个 “将<strong>线程调度</strong>的权限从内核暴露给用户态，从而使得用户态可以实现<strong>各种各样的调度算法</strong>并做出调度决策” 的用户态调度框架。</p>
<p>EXT的用户态部分是我们初赛成果，COS的内核态+用户态是我们决赛成果。</p>
</li>
</ul>
<h1 id="我的工作"><a href="#我的工作" class="headerlink" title="我的工作"></a>我的工作</h1><p>大致可以分为调研—代码—展示这三个方面的工作。</p>
<h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><p>由于当时两位学长都在实习，我是三个人中时间最充足的一个，所以我负责的调研工作应该是三个人中最多的。</p>
<p>我们项目主要调研了Google的ghOSt和Meta的EXT这两个开源的用户态调度框架。以下是我调研过程中的相关笔记：</p>
<blockquote>
<p><a href="https://gitlab.eduxiji.net/202318123111334/project1466467-176093/-/tree/main/record/Dev-Docs/first-stage/hwx/4.5-5.6/note/ghOSt">ghOSt-userspace</a>   梳理调度流程、进程通信等</p>
<p><a href="https://gitlab.eduxiji.net/202318123111334/project1466467-176093/-/blob/main/record/Dev-Docs/final-stage/note/ghost%E9%98%85%E8%AF%BB.md">ghOSt-kernel</a>   主要是探究了各类消息的发送时机，特别是抢占消息</p>
<p><a href="https://gitlab.eduxiji.net/202318123111334/project1466467-176093/-/blob/main/record/Dev-Docs/first-stage/hwx/5.7-final/note/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ext.md">EXT-userland</a>   主要研究了下eBPF程序以及userland示例</p>
<p><a href="https://gitlab.eduxiji.net/202318123111334/project1466467-176093/-/blob/main/record/Dev-Docs/final-stage/develop/EXT%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95.md">EXT-kernel</a>   记录了我对EXT内核的所有探究，如消息发送、任务调度、eBPF实现等，以及各种debug过程</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>EXT的用户态部分是我们初赛成果，COS的内核态+用户态是我们决赛成果。</p>
<ul>
<li><p>初赛</p>
<blockquote>
<p>EXT在内核中新增一个调度类，就类似常用的CFS调度类。该调度类定义了一系列最终由用户在用户态实现的eBPF钩子，并且将其挂载到Linux内核调度策略起作用的关键节点，从而达到用户态调度策略动态注入的效果。<strong>初赛阶段我们基于Meta的EXT内核开发了一个用户态调度框架</strong>。</p>
</blockquote>
<p>初赛的时候有点找不到比赛方向，差点万策尽了，最后队长通过userland得到了方向灵感，但无奈还是只能在应用层中游泳，所以是在堆代码量刷KPI的阶段（）</p>
<p><img src="/2023/08/27/2023-os-comp/image-20230827154559468.png" alt="image-20230827154559468"></p>
<p>其中SJF、Shinjuku以及测试程序都由我负责，故而统<strong>共刷了约3000行KPI</strong>。</p>
</li>
<li><p>决赛</p>
<p>决赛我们发展了两个方向，一个是继续初赛的成果优化EXT内核，另一个是自己从零开发一个新的用户态调度框架COS。我与队友负责第一个方向，队长负责第二个方向。</p>
<p>决赛的前期我在痛苦地调优初赛的石山Shinjuku最后还没优化出什么，然后<strong>跟另一个队友一起完成了决赛的Shinjuku-eBPF</strong>（最后效果还是shit），所以到了中期我就转而去跟队长一起开发COS了。</p>
<p>不过这时候COS开发也大概进入了成熟阶段，所以对于COS内核，我并没有做什么代码工作，主要做的就是<strong>跟队长一起完成了消息的开发（我更多负责调研）以及一起debug</strong>。COS的用户态也由我跟队长共同开发，COS<strong>用户态代码量各写了一半</strong>。</p>
</li>
<li><p>测试</p>
<p>测试部分差不多初赛和决赛都算是我全权负责。</p>
<p>我们最主要的负载还是参考ghOSt实现的I/O密集型场景RocksDB。我们的四个比较对象（CFS、COS、EXT、ghOSt）都使用了这个统一的负载进行测试。RocksDB负载大约有一千多行代码量，将它重写到COS和EXT也花了我不少时间。</p>
</li>
</ul>
<h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>大概分为文档、PPT、演示视频、性能测试、开发记录这几个部分。<strong>我主要负责的是后三个部分</strong>。</p>
<ul>
<li><p>文档</p>
<p><a href="https://gitlab.eduxiji.net/202318123111334/project1466467-176093/-/blob/main/doc/%E5%86%B3%E8%B5%9B%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3.pdf">项目文档</a>的文字部分由队长负责，图片部分由我负责。</p>
<p>环境配置教程和性能测试教程是我完成的。</p>
</li>
<li><p><a href="https://gitlab.eduxiji.net/202318123111334/project1466467-176093/-/blob/main/doc/2023COS%E5%86%B3%E8%B5%9B%E7%AD%94%E8%BE%A9.pptx">PPT</a>（链接非最终版）</p>
<p>PPT文案大多由队长负责，我仅对背景介绍以及PPT模板做了调整。</p>
</li>
<li><p><a href="https://pan.baidu.com/s/1QJdYM_LAyrB1bswgEuO41g?pwd=hcos">演示视频</a>（链接非最终版）</p>
<p>录制和剪辑都由我完成。</p>
</li>
<li><p>性能测试</p>
<p>数据处理和图片都由我完成。</p>
</li>
<li><p><a href="https://gitlab.eduxiji.net/202318123111334/project1466467-176093/-/tree/main/record">开发记录</a></p>
<p>由我完成。</p>
</li>
</ul>
<h1 id="知识性的综合叙述"><a href="#知识性的综合叙述" class="headerlink" title="知识性的综合叙述"></a>知识性的综合叙述</h1><p><a href="/2024/04/21/userspace_scheduling_framework">看这个</a></p>
]]></content>
      <tags>
        <tag>os竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Indexing</title>
    <url>/2023/11/11/Indexing/</url>
    <content><![CDATA[<h2 id="sparce-indexing"><a href="#sparce-indexing" class="headerlink" title="sparce indexing"></a>sparce indexing</h2><p>基于chunks的去重都要求使用full index，而这RAM一般承受不起，但是纯用disk io就太慢了。所以它利用了数据局部性：</p>
<p>If two pieces of backup streams share any chunks, they are likely to share many chunks. <u>如果两个segment共享了某个chunk，那么它们很有可能共享很多chunks。</u></p>
<p><strong>是这样的流程：</strong></p>
<ol>
<li>分段为segment；</li>
<li>计算该segment的每个chunk的fp，然后对每个chunk查询其对应的sparce indexing table: &lt;fp, segment_id&gt;，记录<u>可能跟它共享很多chunk的segment</u>的segment_id；</li>
<li>读取这些segment_id对应的segment的chunk indexing table（存储在disk中）；</li>
<li>for every chunks： 重复，copy entry ；不重复，add to new container</li>
<li>最后再将该segment的信息写入磁盘，填写sparce indexing表。</li>
</ol>
<p>而sparce indexing表最一开始，由对input segment进行chunks的随机抽样得出（或者逐渐构建起来，反正大概是这个意思）</p>
<p>可以看到，它将segment info保留在disk中，在RAM中只保留fp2seg_id的映射，每次只需简单从磁盘中读取几个segment info即可，利用数据局部性极大地降低了磁盘IO次数。</p>
<p>Odess采用的就是类似这种capping+sparce indexing的方法。</p>
<p>将sparce indexing从原来的&lt;fp, seg_id&gt;改为&lt;fp, cid&gt;，并且每次只取top T个包含sample chunks最多的容器，从而将对segment进行cap修改为对container进行cap。仔细想想，这样确实依然保证了原算法的核心思想，也属于是segment size = container size的特种了。</p>
<p>不这个&lt;fp, cid&gt;不就是Odess中的recipe（或者说是全局指纹表）吗？乐。Odess也确实体现了这种capping+sparce indexing结合的方法【只不过进行简化了，每个chunk固定取其第一个container】。</p>
]]></content>
  </entry>
  <entry>
    <title>MFDedup</title>
    <url>/2023/10/11/MFDedup/</url>
    <content><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>**The Dilemma between Deduplication and Locality: Can Both be Achieved? ** 重复数据删除和数据局部性之间的困境：两者都能实现吗？</p>
<p><strong>重复数据删除</strong>：deduplication，是一种用于压缩去重的常见方法，经常采用虚拟指针法。</p>
<p>一个硬盘中的文件往往会随着时间推移拥有多个备份，去重就是针对这些备份之间的概念。我们采用对每个chunk（通过<strong>fingerprint</strong>标识）进行引用的方法进行去重（<strong>虚拟指针法</strong>），但这会导致严重的<strong>碎片化</strong>（也即<strong>丧失数据局部性</strong>）和<strong>GC性能</strong>的问题。</p>
<p><strong>数据局部性</strong>：</p>
<ol>
<li>程序访问数据有局部性，因而备份数据之间也有局部性。</li>
<li>如果在restore时采用<strong>顺序访问</strong>，那么相邻两个数据块之间就产生了数据局部性。</li>
</ol>
<p>本文聚焦于<strong>对硬盘</strong>进行备份过程中的去重压缩（<code> deduplication on hard drive systems</code>），提出了基于<code>Neighbor-Duplicate-Focus indexing(NDF) and Across-Version-Aware Reorganization scheme(AVAR)</code>两项技术、兼得数据去重和保持数据局部性两个优点的去重压缩框架<code>MFDedup</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><ol>
<li><p>container</p>
<p>在存储领域中，针对磁盘备份的压缩去重，传统是使用基于容器的数据布局。</p>
<p>许多基于重复数据删除的存储系统通常与压缩技术相结合，<strong>所有的块都作为压缩的基本单元存储在容器中</strong>。【也即，一个“容器”事实上是一个压缩的基本单元，这个划分是为压缩服务的。】因此，存储I/O<u>通常是以<strong>顺序存储</strong>的容器为粒度的</u>。容器通常具有固定大小。</p>
<p><u>一个备份相当于由多个指针构成，每个指针都指向某个container的某个chunk。</u></p>
</li>
<li><p>碎片化</p>
<p><strong>碎片化与基于容器的I/O和hdd的查找延迟有关</strong>。随着备份层数增多，相邻数据所指向的version就很有可能会不一样，chunk粒度减小，碎片化问题严重程度会增大，从而导致相邻的数据存储的磁盘位置相差甚远，不利于应用程序的性能。</p>
</li>
<li><p>deduplication技术</p>
<ol>
<li><p> Content-Defined Chunking  基于内容分块</p>
</li>
<li><p>Fingerprint Index</p>
</li>
<li><p>Restore Optimization</p>
<p>‘<em>rewriting</em>’ and ‘<em>cache</em>’.</p>
</li>
</ol>
</li>
<li><p>GC</p>
<ol>
<li><p>传统的Mark Sweep</p>
<p>遍历需要释放的备份，解引用备份中用到的chunks。当chunks引用计数为0释放。并且还要做container合并工作。</p>
</li>
<li><p>Container-Marker Algorithm</p>
</li>
</ol>
</li>
</ol>
<h2 id="problems"><a href="#problems" class="headerlink" title="problems"></a>problems</h2><p><strong>数据局部性</strong>：</p>
<ol>
<li><p>程序对磁盘的修改往往具有局部性特点。因而，相邻两个备份之间的被修改的差异可能遵循数据局部性特点，集中在某块区域。这就会导致<strong>碎片化问题</strong>，也即最经常被访问的那块磁盘区域会在备份间被划分为多个小块，并且指针情况错综复杂。</p>
</li>
<li><p>从而，对于局部访问频繁的那部分数据，同一个备份中的相邻两个chunks的局部性也会被破坏，因为它们<u>虽然逻辑连续，但是物理存储却不一定连续</u>。</p>
</li>
<li><p>restore和gc性能垃圾</p>
<p><strong>对于restore</strong>，过多的deduplication就会导致一个备份中相邻数据块实际存储的容器不同，导致：</p>
<ol>
<li><u>读放大问题</u>：每次读取一个数据块就得读取其所在的整个容器（因为是IO粒度），导致<em>read amplification</em>很垃圾。</li>
<li><u>查找问题</u>：需要多次读取不同容器，因而需要多次随机IO到不同容器位置，这与hdd（Hard Disk Drive）的设计相违背（HDD连续读取快，随机寻址慢），从而导致性能垃圾。</li>
</ol>
<p><strong>对于GC</strong>，需要unreference的chunks会分布在各个不同容器中，影响GC性能。</p>
</li>
</ol>
<h2 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h2><p>在container和backup中新加一层category分类，分类方式：</p>
<ol>
<li>根据reference relationship对chunks进行分类</li>
<li>类别只考虑那些版本号连续 or 独立版本号的类别，如B1B2B3，B3B4，B1这种（也很容易知道，这样分类比较有意义），这样一来类别数目就可以从2^n降到<em>n</em>(<em>n</em> + 1)*/*2 for <em>n</em> backup versions。</li>
</ol>
<p><strong>这样一来，我们可以显著提高restore和gc：</strong></p>
<ol>
<li><p>restore</p>
<p>比如说要restore版本Bj，我们就需要恢复所有包含Bj这个版本指针的category，并且每个category中的多个chunks做的IO操作都是一样的（比如一个category的指针序列为B2B3B4，那么IO操作的回溯次序是一模一样的），这样就能极大减少随机IO。</p>
</li>
<li><p>gc</p>
<p>gc时，比如说要删除版本Bi，我们只需要删除所有category中的这个版本指针，并且在一个category没有版本指针后释放category及其对应chunk就行。</p>
</li>
</ol>
<p>传统的方法将数据块保存在固定大小的容器中，也即相当于通过顺序划分数据块，随着备份层级增大，chunks碎片化问题严重，相邻的数据块可能存储在不同磁盘位置，导致局部性垃圾，读放大高，restore和gc开销大。于是MFDedup通过修改数据布局，通过备份版本号来对数据块进行分类。类似九九乘法表的volume布局。</p>
<ol>
<li><p>备份</p>
<p>inline：fingerprint（NDF）   offline：arrange（AVAR）</p>
<p>arrange：通过NDF。如果上一个版本的数据块没出现在新版本，就归档；否则就迁移到新版本备份对应卷组上。</p>
</li>
<li><p>restore</p>
<p>恢复所有包含了备份版本号的category。</p>
</li>
<li><p>gc</p>
<p>只需删除其unique 块。</p>
</li>
</ol>
<h1 id="abstract-introduction"><a href="#abstract-introduction" class="headerlink" title="abstract/introduction"></a>abstract/introduction</h1><ol>
<li><p>deduplication被广泛用于减小backup，但会带来碎片化问题（影响restore和gc）和poor locality。</p>
<p>一个硬盘中的文件往往会随着时间推移拥有多个备份，去重就是针对这些备份之间的概念。我们采用对每个chunk（通过fingerprint标识）进行引用的方法进行去重，但这会导致严重的<strong>碎片化</strong>（也即<strong>丧失数据局部性</strong>）和<strong>GC性能</strong>的问题。</p>
<blockquote>
<p><strong>碎片化</strong>：</p>
<p>随着备份层数增多，相邻数据所指向的version就很有可能会不一样，chunk粒度减小，碎片化问题严重程度会增大，从而导致相邻的数据存储的磁盘位置相差甚远，不利于应用程序的性能。详情见下例子：</p>
<blockquote>
<p>As an example, consider backup <em>version</em> 1 that has few or no duplicates, so its chunks are stored sequentially in containers. </p>
<p>Then,  <em>version</em> 2 may be highly re dundant with the first with small modifications throughout the backup, so its recipe has references to many chunks of the first version intermixed with references to newly written chunks. </p>
<p>Later, <em>version N</em> tends to have even worse locality as it refers to chunks written by many previous backup versions, so <u>restoring a backup version involves <strong>random seeks back and forth</strong> across the disks, and <strong>read amplification is high</strong> since an accessed container may have needed and unneeded chunks</u>.</p>
</blockquote>
<p>为了解决这个问题，以往的策略是针对那些被频繁访问的数据或者碎片化程度（<code>fragmentation degree</code>）到达一定的阈值之后就进行<code>rewrite</code>，或者使用SSD来cache那些被频繁reference的chunk。但这依然无法根治碎片化问题。</p>
</blockquote>
</li>
<li><p>我们提出了 MFDedup ，保持了备份的数据局部性，通过 data classification 生成了优化的 data layout。关键技术为Neighbor-Duplicate-Focus indexing(NDF) and Across-Version-Aware Reorganization scheme(AVAR)。</p>
</li>
<li><p>基于容器的数据布局</p>
<p>在存储领域中，针对磁盘备份的压缩去重，传统是使用基于容器的数据布局。</p>
<p>基于容器的数据布局相当于是对数据块进行分类，有几类就有几个容器。分类的依据可以是简单的顺序分类，也可以是哈希值分类等。</p>
</li>
<li><p>在我们对重复数据删除备份的观察中，我们发现备份版本Bi+1中几乎所有的重复块都来自于它之前的版本Bi</p>
</li>
</ol>
<h2 id="MFDedup基本思路"><a href="#MFDedup基本思路" class="headerlink" title="MFDedup基本思路"></a>MFDedup基本思路</h2><p>传统方法的容器按顺序分类，重点在于简化新建备份时的<strong>写路径</strong>，但碎片化问题严重；我们提出的数据布局方法按照reference relationship分类，重点在于简化<strong>restore</strong>备份，写入可能复杂点，但是恢复和gc很快。</p>
<ol>
<li><p>根据reference relationship对chunks进行分类</p>
</li>
<li><p>类别只考虑那些版本号连续 or 独立版本号的类别，如B1B2B3，B3B4，B1这种（也很容易知道，这样分类比较有意义），这样一来类别数目就可以从2^n降到<em>n</em>(<em>n</em> + 1)*/*2 for <em>n</em> backup versions。</p>
<p>这样的话，就只会重复删除internal、adjust块，而不会删除skip块，也即如下图右所示：</p>
<p><img src="/2023/10/11/MFDedup/image-20231010095534708.png" alt="image-20231010095534708"></p>
</li>
</ol>
<p><strong>这样一来，我们可以显著提高restore和gc：</strong></p>
<ol>
<li><p>restore</p>
<p>比如说要restore版本Bj，我们就需要恢复所有包含Bj这个版本指针的category，并且每个category中的多个chunks做的IO操作都是一样的（比如一个category的指针序列为B2B3B4，那么IO操作的回溯次序是一模一样的），这样就能极大减少随机IO。</p>
</li>
<li><p>gc</p>
<p>gc时，比如说要删除版本Bi，我们只需要删除所有category中的这个版本指针，并且在一个category没有版本指针后释放category及其对应chunk就行。</p>
</li>
</ol>
<p>不得不说，真是很巧妙。</p>
<h1 id="background-1"><a href="#background-1" class="headerlink" title="background"></a>background</h1><ol>
<li><p>containers</p>
<p>解释了一下为什么会有containers，以及其作用。</p>
<p>许多基于重复数据删除的存储系统通常与压缩技术相结合，<strong>所有的块都作为压缩的基本单元存储在容器中</strong>。【也即，一个“容器”事实上是一个压缩的基本单元，这个划分是为压缩服务的。】因此，存储I/O<u>通常是以<strong>顺序存储</strong>的容器为粒度的</u>。</p>
<p>容器通常具有固定大小。</p>
</li>
<li><p>碎片化</p>
<p><strong>碎片化与基于容器的I/O和hdd的查找延迟有关</strong>。</p>
</li>
<li><p>inline and offline deduplication</p>
<blockquote>
<ol>
<li><strong>Inline Deduplication（内联去重）：</strong> 在内联去重中，<u>数据去重的过程发生在数据写入备份存储之前</u>，即在备份数据被存储到磁盘或其他媒体之前。</li>
<li><strong>Offline Deduplication（离线去重）：</strong> 在离线去重中，<u>备份数据首先被写入备份存储，然后在后续的离线过程中进行去重</u>。</li>
</ol>
</blockquote>
<p>deduplication广泛运用于primary storage和secondary storage。其中，Primary storage prioritizes <strong>low latency</strong>, whereas secondary storage works prioritize <strong>high throughput</strong>.</p>
<blockquote>
<p>这里还提到了一个很巧妙的RevDedup：</p>
<p>RevDedup shifts fragmentation to older backups by adjusting their references to newer backups to retain the locality of newer backups that are more likely to be restored. As a result, restoring older backups will be slower with this approach.</p>
<p>也就是说，原来是新备份指向原来的旧备份，从而导致新备份碎片化；现在是旧备份指向新备份，碎片化的变成了旧备份！同时，它只将创建新备份操作inline，调整旧备份指向新备份的操作offline，也降低了性能损耗。牛的。这个方法的缺点就是恢复旧备份会很慢。</p>
</blockquote>
</li>
</ol>
<h1 id="Observation-and-Motivation"><a href="#Observation-and-Motivation" class="headerlink" title="Observation and Motivation"></a>Observation and Motivation</h1><p><img src="/2023/10/11/MFDedup/image-20231009115234691.png" alt="image-20231009115234691"></p>
<h1 id="After"><a href="#After" class="headerlink" title="After"></a>After</h1><p>不过我以前还以为去重就是简单的在不同备份版本中建立二维指针，看来我还是想得太天真了。</p>
<p>下图是最理想的去重方法，保留了deduplication和locality：</p>
<p><img src="/2023/10/11/MFDedup/image-20231010090932440.png" alt="image-20231010090932440"></p>
<p>但意思好像是说这东西不实用，所以我们最终只能退而求其次，用二维指针法组织多个备份，但这就很难兼容locality。</p>
<p>而且这样就引出了一个很巧妙的角度：<u>数据去重data layout的高维结构&amp;&amp;存储设备顺序存储</u>，这两者之间的矛盾。</p>
<blockquote>
<p>Directly considering how to <u>flatten the hyper-structure of deduplicated data</u> is <strong>difficult</strong>, and in this article, we consider how to <u>maintain locality in the flattened structure</u> and discuss that from both the micro and macro perspectives.</p>
</blockquote>
<p>还有值得注意的是，这边也提出了好几种去重针对的文件类型：<code>backup files, database snapshots, virtual machine images</code>，并且提到了一点就是去重事实上是根据它们的fingerprint去重的。</p>
<p>并且它还提出了deduplication中和文件系统中碎片化问题的不同。</p>
<p>并且值得注意的是，除了我上面说的读取一个类目的容器有助于解决读放大，它这边还说明了另一个很重要的点，也即是如何在restore时保证磁盘顺序读取的。</p>
<p>当我们restore备份时，每次都是得读取所有包括它这个版本号的category，也即所有Cat( i, n ) ( 1 &lt; i &lt;= k )。所以，我们可以将Cat( i, n ) ( 1 &lt; i &lt;= k )在物理设备上连续存储，从而方便磁盘顺序读取：</p>
<p><img src="/2023/10/11/MFDedup/image-20231010123108075.png" alt="image-20231010123108075"></p>
<p>并且，每次产生新的备份版本时也无需更新所有的category，只需更新那些延续到latest的就行，其它的都已经算是archive状态只需备份无需更新。</p>
<p><strong>所以，看到现在整理一下总体思路：</strong></p>
<p>将chunk以连续备份版本号分类，总共分成<code>n(n+1)/2</code>个category（这样做无视了对skip data的deduplication。skip data：如一个数据块在版本1和3出现）。一个category中存放的是指针信息，指向了类似页表一样的hash table（recipe）。hash table中真正记录了数据块的物理地址。</p>
<ol>
<li><p>对于restore</p>
<p>当我们restore备份时，每次都是得读取所有包括它这个版本号的category：</p>
<p><img src="/2023/10/11/MFDedup/image-20231010153418595.png" alt="image-20231010153418595"></p>
<p>也即比如n=4，我们想恢复version 2，就需要Cat 1,2  2,2  1,3  2,3  1,4  2,4</p>
<p>所以，我们可以将Cat( i, n ) ( 1 &lt; i &lt;= k )在物理设备上连续存储，从而方便磁盘顺序读取：</p>
<p>​    <img src="/2023/10/11/MFDedup/image-20231010135001047.png" alt="image-20231010135001047"></p>
<p><img src="/2023/10/11/MFDedup/image-20231010153717371.png" alt="image-20231010153717371"></p>
</li>
<li><p>对于update</p>
<p>每次产生新的备份版本时也无需更新所有的category，只需更新那些延续到latest的就行，其它的都已经算是archive状态只需备份无需更新。</p>
<p><img src="/2023/10/11/MFDedup/image-20231010135124053.png" alt="image-20231010135124053"></p>
</li>
<li><p>对于gc</p>
<p>删除某个版本时，只删除那个版本特有块，也即Cat n,n ，也就是说比如备份2被删了，那么Cat 1,3 依然整体存在而不会被拆分为Cat 1,1 + Cat 3,3。然后好像同时也会维护，如果一个数据块最后一个引用也没了，就直接踢了。</p>
</li>
<li><p>空间管理</p>
<ol>
<li><p>通过卷的大小预估下次备份所占用的空间</p>
<p>因为<strong>卷相当于当前版本与上一个版本之间的差异</strong>，所以可以用来预估</p>
</li>
<li><p>通过在volum和category开头统计信息来获取剩余空间</p>
</li>
</ol>
</li>
</ol>
<p>可以看到，大大减少了GC和restore的开销，update开销也可以近似没有。</p>
]]></content>
  </entry>
  <entry>
    <title>算法题</title>
    <url>/2024/04/27/algorithm_questions/</url>
    <content><![CDATA[<p>因为各种各样的原因，我需要开始进行一定的算法训练，在此记下过程中的一些心得体会和文章摘抄。刷的题目集是 <a href="https://www.programmercarl.com/">代码随想录</a>。</p>
<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p>
<p>很难崩</p>
<p><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></p>
<p>TODO用DP做一下</p>
<p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></p>
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></p>
<p>TODO</p>
<p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></p>
<p>TODO</p>
<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p>
<p>TODO，区间思想做一下</p>
<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><p>2024.5.1 Medium <a href="https://leetcode.cn/problems/total-cost-to-hire-k-workers/">2462. 雇佣 K 位工人的总代价</a></p>
<p>这个比较有意思。其中一个c++写法需要注意：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">element</span> &#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> element &amp;a, <span class="type">const</span> element &amp;b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先比较 val 值</span></span><br><span class="line">        <span class="keyword">if</span> (a.val != b.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.val &gt; b.val; <span class="comment">// 小顶堆：较小的 val 在堆顶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 val 值相同，则比较 index 值</span></span><br><span class="line">        <span class="keyword">return</span> a.index &gt; b.index; <span class="comment">// 小顶堆：较小的 index 在堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::priority_queue&lt;element, std::vector&lt;element&gt;, Compare&gt; heap;</span><br></pre></td></tr></table></figure>

<p>可以直接写成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pair第一位对应val，第二位对应index</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br></pre></td></tr></table></figure>

<p>很直观，pair的greater逻辑应该就是先比第一个再比第二个，学到了。</p>
<p>24.5.10 <a href="https://leetcode.cn/problems/count-tested-devices-after-test-operations/">2960. 统计已测试设备</a></p>
<p>居然无师自通了<a href="https://oi-wiki.org/basic/prefix-sum/#%E5%B7%AE%E5%88%86">差分</a>，不过差分居然可以视为前缀和，对这个思想感到非常巧妙。当然更复杂的树差分这里暂且只先了解一下概念了。。。</p>
<p><a href="https://leetcode.cn/problems/find-the-longest-equal-subarray/description/?envType=daily-question&amp;envId=2024-05-23">https://leetcode.cn/problems/find-the-longest-equal-subarray/description/?envType=daily-question&amp;envId=2024-05-23</a></p>
<p>这题有时间仔细想想。。其实我已经有一个近似解了，只不过问题出在需要枚举左区间，这种情况下理应想到滑动窗口的</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a>  牛顿迭代</p>
<p><a href="https://leetcode.cn/problems/convert-to-base-2/">1017. 负二进制转换</a>  是我最讨厌的数学种类之一……</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>  TODO</p>
<p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote>
<p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p>
<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p>
<p>写二分法，区间的定义一般为两种，**左闭右闭即[left, right]，或者左闭右开即[left, right)**。</p>
</blockquote>
<blockquote>
<p><strong>第一种写法，</strong>我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p>
<p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p>
<ul>
<li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
</blockquote>
<blockquote>
<p><strong>第二种写法，</strong>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p>
<p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
</blockquote>
<p><a href="https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html">35.搜索插入位置</a></p>
<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<p>做了这么多二分下来，感觉二分最核心的还是脑补出这样一个结构：left和right一左一右紧挨着，此时，</p>
<ol>
<li><p>left指向target</p>
<ol>
<li><p>middle=left</p>
<p>直接return，此时target = left = right - 1 = middle</p>
</li>
<li><p>middle=right</p>
<ol>
<li><p>开区间：不可能出现该情况。</p>
</li>
<li><p>闭区间：right紧缩。下一轮return，target = left = right = middle</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>right指向target</p>
<ol>
<li><p>middle=left</p>
<p>left紧缩。</p>
<ol>
<li><p>开区间：下一轮left = right退出循环，target = left = right = middle + 1</p>
</li>
<li><p>闭区间：下一轮return，target = left = right = middle</p>
</li>
</ol>
</li>
<li><p>middle=right</p>
<ol>
<li>开区间：不可能出现该情况。</li>
<li>闭区间：直接，此时target = right = left + 1 = middle</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>所以总结：</p>
<ol>
<li>对于开区间来说，<code>middle != right</code>恒成立，这点也很直观。</li>
<li>传统的二分查找开闭区间都是在内层return middle，外层return -1。</li>
</ol>
<p>想要解决区间问题，最重要的就是想清楚这四点……</p>
<p>还有二分枚举：</p>
<p><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></p>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p>
<p><img src="/2024/04/27/algorithm_questions/image-20240427223534521.png" alt="image-20240427223534521"></p>
<p>6666，我用的是方法二，也即找到零点分界线再左右遍历，它这个思路三比我高超</p>
<p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a> 见哈希表一节</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p>
<p>算是简单的滑动窗口了。right bound负责遍历拓展视野，left bound负责在区间的底线反复横跳。</p>
<h3 id="各种遍历顺序"><a href="#各种遍历顺序" class="headerlink" title="各种遍历顺序"></a>各种遍历顺序</h3><p><a href="https://leetcode.cn/problems/sort-the-matrix-diagonally/">1329. 将矩阵按对角线排序</a></p>
<p>因为矩阵的下标不能为负数。同一“对角线”上的点，i-j的值相等，但是，可能是负数，所以我们，把那部分负数的值，变换到都大于等于0。 考虑到，i最小为0，j最大为m-1 时，（i-j）最小为：0-(m-1) = 1-m，故i-j+m，就把原来可能为负的区间，向右平移，变成最小值为1的区间。</p>
<p>因此，我们就可以将每条对角线映射到&lt;i-j+m, array&gt;这样的映射中了。</p>
<h3 id="TopK"><a href="#TopK" class="headerlink" title="TopK"></a>TopK</h3><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></p>
<p>这个On做法亮瞎我了。。。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p>
<p>学到了一个很有意思的写法：dummyHead</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dummyHead = std::<span class="built_in">make_shared</span>&lt;ListNode&gt;(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">auto</span> tmp = dummyHead.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">while</span> (tmp-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;next-&gt;val == val) &#123;</span><br><span class="line">            tmp-&gt;next = tmp-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有递归写法也值得一看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)  <span class="keyword">return</span> head;</span><br><span class="line">    head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">    <span class="keyword">return</span> head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
<p>可以很好地练一下递归写法</p>
<p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p>
<p>还有这题递归写法也很经典</p>
<p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a>   <a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p>
<p>经典指针</p>
<p><a href="https://leetcode.cn/problems/aMhZSa/">LCR 027. 回文链表</a></p>
<p>这题的递归写法思路很有意思</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>
<p>一次遍历的做法值得注意</p>
<p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a>  经典老题，不过这次真是水平提升了居然很快想出一两年前觉得很难的正解hhh</p>
<p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a>   这题其实最难的是去重。</p>
<p>我的思路是两重循环建立哈希表，然后一重循环找元组。</p>
<p>对于去重，需要做以下几件事：</p>
<ol>
<li><p>保证i&lt;j&lt;k</p>
</li>
<li><p><strong>排序</strong></p>
<p>这个很重要。。。。也是我绞尽脑汁好久没想出来的。有了这个，才能让重复元素连续出现，确保i&lt;j&lt;k的情况不会重复</p>
</li>
<li><p>两重循环建立哈希表的时候，保证i和j不重复</p>
<p>具体来说，对于连续的重复元素，都只取第一个作为i、j，后面的都跳过。</p>
</li>
<li><p>一重循环找元组的时候，保证k不重复</p>
<p>k就不能像3一样简单粗暴地取第一个然后跳过了，因为有可能第一个不满足i&lt;j&lt;k但是第二个满足。</p>
<p>所以我们要做的，就是把那些满足的加入res之后，赶紧把它给erase了，这样一来就能防止重复了。</p>
</li>
</ol>
<p>还有这题的双指针解法也很需要注意。</p>
<p><img src="/2024/04/27/algorithm_questions/image-20240501201841386.png" alt="image-20240501201841386"></p>
<p>我一直没怎么考虑到数组已排序的条件，所以在想怎么用双指针做时一直没想到这点。。。实在是很巧妙。再加上理解为太大了小一点（紧缩有边界），太小了大一点（紧缩左边界），也是挺有意思。</p>
<p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></p>
<p>跟三数之和解法一模一样。值得注意的是，需要注意这里的隐式类型转换坑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; nums.size() - <span class="number">3</span>; m ++)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>当m=0，num.size() = 2,此时居然会得到m &lt; nums.size() - 3为true，解释一下这个现象</strong></p>
<p>在表达式 <code>m &lt; nums.size() - 3</code> 中，如果 <code>nums.size() = 2</code>，那么 <code>nums.size() - 3</code> 的计算结果为 <code>2 - 3 = -1</code>。这个结果是一个 <code>int</code> 类型的常量 <code>-1</code>，但由于 <code>nums.size()</code> 的返回类型是 <code>size_t</code>，它是一个无符号整数类型。</p>
<p>在 C++ 中，当无符号整数和有符号整数进行运算时，有符号整数会转换为无符号整数类型。这意味着在计算 <code>nums.size() - 3</code> 时，<code>-1</code> 会被转换为无符号整数。</p>
<p>具体来说，<code>-1</code> 在无符号整数 <code>size_t</code> 中表示为一个非常大的数，因为在无符号整数中，负数表示为最大的正数减去对应的绝对值。例如，在一个 32 位无符号整数中，<code>-1</code> 会被解释为 <code>4294967295</code>。</p>
<p>因此，当 <code>m</code> 为 <code>0</code> 时，表达式 <code>m &lt; nums.size() - 3</code> 变成了 <code>0 &lt; -1</code>（解释为一个非常大的正数），结果是 <code>true</code>。这是因为 <code>0</code> 小于非常大的正数，因此得到 <code>true</code> 结果。</p>
<p>这说明在 C++ 中的类型转换时，要特别注意有符号整数和无符号整数之间的转换，因为它们可能导致意外的结果。在这种情况下，您可能需要确保变量和表达式类型匹配，以避免未预期的行为。</p>
</blockquote>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><p>各种经典的翻转：</p>
<p><a href="https://kamacoder.com/problempage.php?pid=1065">55.右旋字符串</a></p>
<p><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></p>
<p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></p>
<h3 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h3><p><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></p>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></p>
<p>也是终于第一次自己写出了KMP。。。</p>
<p>【【算法】为什么说KMP是自动机？- 字符串匹配DFA的构建和优化】 <a href="https://www.bilibili.com/video/BV1rW4y1H7nz/?share_source=copy_web&amp;vd_source=f268a75a895f54b9c1bc316efde67a44">https://www.bilibili.com/video/BV1rW4y1H7nz/?share_source=copy_web&amp;vd_source=f268a75a895f54b9c1bc316efde67a44</a></p>
<p>红字表示等待指针，第一个指针永远等待，通过构筑所有可能输入来构筑等待指针，然后每过一个状态等待指针往下一个字母移动。</p>
<p><img src="/2024/04/27/algorithm_questions/image-20240502155748704.png" alt="image-20240502155748704"></p>
<p>然后的话，我们可以化简的思想，就是将这张表简化为只有两列，一列是收到正确消息前进到哪个状态，一类是收到错误消息回退到哪个状态，因为一直回退其实跟直接跳效果是一样的</p>
<p><img src="/2024/04/27/algorithm_questions/image-20240502160957249.png" alt="image-20240502160957249"></p>
<p><img src="/2024/04/27/algorithm_questions/image-20240502164319105.png" alt="image-20240502164319105"></p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></p>
<p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF">二叉树的统一迭代法</a></p>
<p>有意思</p>
<p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></p>
<p>这题log方n解法是真牛逼吧，有时间好好写一遍</p>
]]></content>
  </entry>
  <entry>
    <title>计算机体系结构</title>
    <url>/2024/01/04/arch/</url>
    <content><![CDATA[<h1 id="01-基本知识"><a href="#01-基本知识" class="headerlink" title="01  基本知识"></a>01  基本知识</h1><ol>
<li><p><a href="http://www.taodudu.cc/news/show-5657924.html?action=onClick">SISD、SIMD、MIMD、向量处理器的基本概念</a></p>
<p>向量处理器意思是一条指令可以同时处理多个数据元素（SIMD）（就类似于这几个数据元素组成了一个向量）；多发射处理器可以同一时间并行多条指令。</p>
</li>
<li><p>发射与流出</p>
<p>在计算机体系结构中，”发射”和”流出”是与指令执行有关的两个重要概念，它们描述了处理器在执行指令时的不同阶段和行为。</p>
<ol>
<li><strong>发射（Issue）：</strong><ul>
<li>“发射”指的是将指令从指令流中发送到处理器的执行部件或执行单元，以进行实际的执行。</li>
<li>发射阶段通常是在取指令和解码指令之后，将指令发送到执行单元的过程。</li>
<li>多发射处理器意味着<strong>多条指令可以同时进入执行阶段，通过并行执行提高处理器的性能</strong>。</li>
</ul>
</li>
<li><strong>流出（Out-of-Order Execution）：</strong><ul>
<li>“流出”是指处理器在执行过程中<strong>允许指令乱序执行</strong>，即不按照它们在程序中的原始顺序执行。在乱序执行的情况下，处理器会通过<strong>重新排序指令</strong>来填充执行单元的空闲周期，以提高整体性能。</li>
<li>多流出处理器采用<strong>乱序执行</strong>的方式，允许<strong>在执行单元空闲时执行无关的指令</strong>，以最大程度地利用执行单元的并行性。</li>
</ul>
</li>
</ol>
<p>这两个概念都涉及到提高指令级并行性，但它们描述了处理器在执行阶段的不同方面。发射强调在同一时钟周期内同时发送多条指令，而流出强调在执行过程中的乱序执行策略。</p>
</li>
<li><p>tensor  张量</p>
<p>sparse tensor  稀疏张量</p>
</li>
<li><p>异构计算</p>
<p>指的是在同一系统中<strong>集成多种不同体系结构或架构的处理器和计算设备</strong>，以便更有效地处理各种类型的任务。这包括集成不同类型的中央处理单元（CPU）、图形处理单元（GPU）、加速器、协处理器等。异构计算的目标是充分发挥各种处理器的优势，以提高整体系统性能和能效。</p>
<p>其关键概念有协处理器等等等。</p>
</li>
</ol>
<h1 id="02-现代处理器体系结构"><a href="#02-现代处理器体系结构" class="headerlink" title="02  现代处理器体系结构"></a>02  现代处理器体系结构</h1><p><img src="/2024/01/04/arch/image-20240102144004552.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102213220264.png" alt="img"></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题型1-生成指令序列，分析时间"><a href="#题型1-生成指令序列，分析时间" class="headerlink" title="题型1  生成指令序列，分析时间"></a>题型1  生成指令序列，分析时间</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><img src="/2024/01/04/arch/image-20240103165154015.png" alt="img"></p>
<p>注意几点：</p>
<ol>
<li>变量需要通过LD指令载入到寄存器</li>
</ol>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p><img src="/2024/01/04/arch/image-20240102205804595.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205819502.png" alt="img"></p>
<p>注意，它的意思是LD、SD、DADDIU都只占1个时钟周期，ADD占2个</p>
<p><img src="/2024/01/04/arch/image-20240102205838569.png" alt="img"></p>
<p>感觉这么个例题下来，我就懂了循环展开的作用了</p>
<h3 id="题型2-换名-消除WAR-WAW"><a href="#题型2-换名-消除WAR-WAW" class="headerlink" title="题型2  换名/消除WAR WAW"></a>题型2  换名/消除WAR WAW</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><p><img src="/2024/01/04/arch/image-20240102150141545.png" alt="img"></p>
<h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p><img src="/2024/01/04/arch/image-20240103170029102.png" alt="img"></p>
<h3 id="题型3-记分牌"><a href="#题型3-记分牌" class="headerlink" title="题型3  记分牌"></a>题型3  记分牌</h3><p><img src="/2024/01/04/arch/image-20240102154331889.png" alt="img"></p>
<p>这里的结构相关值得注意</p>
<p>做这种题的套路是，需要明确它要求的时刻时的情况，并且依照以下规则判断即可：</p>
<ol>
<li><p>指令状态表</p>
<ol>
<li><p>流出</p>
<p>无结构冲突、无WAW冲突</p>
<p>如① 当MULT准备写回时，此时前两条L必定流出，然后后面的SUB、DIV、ADD都没有结构冲突和WAW冲突，所以全部流出。只不过ADD和DIV会卡在读操作数阶段</p>
<p>② 由①可知全部流出</p>
</li>
<li><p>读操作数</p>
<p>操作数可用时完成该阶段</p>
<p>如① 此时前三条必定完成。并且SUB也完成了，所以ADD也完成了读数阶段。只有DIV还在等待mul的结果</p>
<p>② 此时大伙差不多都结了，没什么好说的</p>
</li>
<li><p>执行</p>
<p>纯纯的算术</p>
<p>如① 除了除法别的都完了，没什么好说的</p>
<p>② 全部都结了</p>
</li>
<li><p>写结果</p>
<p>不存在WAR则写入</p>
<p>如① 前两个肯定完成了，然后SUB也结了，ADD存在WAR，所以最后是ADD和MUL没完成。</p>
<p>② 除了DIV全部结了</p>
</li>
</ol>
</li>
<li><p>功能部件状态表</p>
<p>记住这些字母的含义即可：</p>
<ul>
<li>Busy：yes/no</li>
<li>Op：操作编码</li>
<li>Fi：目的寄存器编号</li>
<li>Fj，Fk：源寄存器编号</li>
<li>Qj，Qk：正在计算Fj和Fk的功能部件</li>
<li>Rj，Rk：Fj和Fk是否就绪且还没被取走</li>
</ul>
</li>
<li><p>寄存器状态表</p>
<p>每个寄存器有一项，用于指出哪个功能部件将把结果写入</p>
</li>
</ol>
<p><img src="/2024/01/04/arch/image-20240102154405358.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102154418509.png" alt="img"></p>
<h3 id="题型4-Tomasulo算法"><a href="#题型4-Tomasulo算法" class="headerlink" title="题型4  Tomasulo算法"></a>题型4  Tomasulo算法</h3><p>3段流水</p>
<ol>
<li><p>流出</p>
<ol>
<li><p>没有结构冲突就流出，填进保留站</p>
<p>一般有ADD1，ADD2，ADD3（加减），MUL1，MUL2（乘除），LD1，LD2（SL）</p>
</li>
<li><p>具体填什么看操作数有没有就绪</p>
</li>
</ol>
<p>保留站有以下字段：</p>
<ul>
<li><p>Op：操作</p>
</li>
<li><p>Qj，Qk：操作数保留站号</p>
</li>
<li><p>Vj，Vk：源操作数值</p>
<p>load的Vk保存偏移量</p>
</li>
<li><p>Busy</p>
</li>
<li><p>A：存放立即数字段 or 有效地址，仅用于load和store缓冲器</p>
</li>
<li><p>Qi：寄存器状态表</p>
<p>存放要写入它的保留站ID</p>
</li>
</ul>
</li>
<li><p>执行</p>
<p>两个操作数就绪后就执行</p>
</li>
<li><p>写结果</p>
<p>计算完毕后由CDB传送</p>
</li>
</ol>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><img src="/2024/01/04/arch/image-20240102155858450.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102155908430.png" alt="img"></p>
<p>这里不知道为什么LD2没有跟LD1同时完成？限制了一个时钟周期只流出一条指令吗</p>
<p><img src="/2024/01/04/arch/image-20240102155918983.png" alt="img"></p>
<p>这里可以注意其特点是结果一经算出全部写回</p>
<p><img src="/2024/01/04/arch/image-20240102155858450.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102160005644.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102160013903.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102160026555.png" alt="img"></p>
<p>通过换名避免了WAR，而不是像记分牌那样通过等待</p>
<p><img src="/2024/01/04/arch/image-20240102160047452.png" alt="img"></p>
<h3 id="题型5-Tomasulo-前瞻执行"><a href="#题型5-Tomasulo-前瞻执行" class="headerlink" title="题型5  Tomasulo+前瞻执行"></a>题型5  Tomasulo+前瞻执行</h3><p>4段流水</p>
<ol>
<li><p>流出</p>
<ol>
<li><p>保留站&amp;ROB都有空闲才流出</p>
<p>一般有ADD1，ADD2，ADD3（加减），MUL1，MUL2（乘除），LD1，LD2（SL）</p>
</li>
<li><p>具体填什么看操作数有没有就绪</p>
</li>
</ol>
<p>保留站有以下字段：</p>
<ul>
<li><p>Op：操作</p>
</li>
<li><p>Qj，Qk：操作数保留站号</p>
</li>
<li><p>Vj，Vk：源操作数值</p>
<p>load的Vk保存偏移量</p>
</li>
<li><p>Busy</p>
</li>
<li><p>A：存放立即数字段 or 有效地址，仅用于load和store缓冲器</p>
</li>
<li><p>Qi：寄存器状态表</p>
<p>存放要写入它的保留站ID</p>
</li>
</ul>
</li>
<li><p>执行</p>
<p>两个操作数就绪后就执行</p>
</li>
<li><p>写结果</p>
<ol>
<li>写入ROB，CDB传送ROB编号到保留站</li>
<li>释放产生该结果的保留站</li>
</ol>
<p>ROB字段：</p>
<ul>
<li><p>指令类型</p>
</li>
<li><p>目标地址</p>
<p>目标寄存器/存储器单元地址</p>
</li>
<li><p>数据值字段</p>
<p>前瞻结果</p>
</li>
<li><p>就绪字段</p>
<p>结果是否就绪</p>
</li>
</ul>
</li>
<li><p>指令确认</p>
<p>分支结果出来后确认</p>
<ol>
<li>猜测对        写入寄存器/存储器，释放ROB</li>
<li>猜测错        从另一条路径开始重新执行，清空ROB</li>
</ol>
</li>
</ol>
<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p><img src="/2024/01/04/arch/image-20240102194359700.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194416531.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194433216.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194506823.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194538913.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194525604.png" alt="img"></p>
<h3 id="题型6-超标量实现"><a href="#题型6-超标量实现" class="headerlink" title="题型6  超标量实现"></a>题型6  超标量实现</h3><h4 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h4><p><img src="/2024/01/04/arch/image-20240102205448599.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205456703.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205505451.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205515735.png" alt="img"></p>
<p>注意，SD指令的0和R1有了就开始执行，不必等到F4有了再执行。。。</p>
<p><img src="/2024/01/04/arch/image-20240102205527361.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205539266.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205550165.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205602207.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205612833.png" alt="img"></p>
<h3 id="题型7-循环展开"><a href="#题型7-循环展开" class="headerlink" title="题型7  循环展开"></a>题型7  循环展开</h3><p>具体步骤：</p>
<ol>
<li>依题意展开</li>
<li>去除多余的BNE、合并所有DADDUI</li>
<li>寄存器换名消除名相关</li>
<li>重排序消除数据相关</li>
</ol>
<h4 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h4><p><img src="/2024/01/04/arch/image-20240102205448599.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210509759.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210530728.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210541651.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210600491.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210613233.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210625427.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210637394.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210646714.png" alt="img"></p>
<h4 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h4><p><img src="/2024/01/04/arch/image-20240102210811811.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210826366.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210919898.png" alt="img"></p>
<h3 id="题型8-VIEW技术"><a href="#题型8-VIEW技术" class="headerlink" title="题型8  VIEW技术"></a>题型8  VIEW技术</h3><h4 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h4><p><img src="/2024/01/04/arch/image-20240102205448599.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102211143089.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102211153575.png" alt="img"></p>
<p>看起来大概可能就有点类似树的概念，什么都不依赖的就放前面，然后依赖1层的依赖2层的之类的</p>
<p><img src="/2024/01/04/arch/image-20240102211202383.png" alt="img"></p>
<h3 id="题型9-软流水"><a href="#题型9-软流水" class="headerlink" title="题型9  软流水"></a>题型9  软流水</h3><h4 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h4><p><img src="/2024/01/04/arch/image-20240102205448599.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102212859714.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102212925789.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102213054498.png" alt="img"></p>
<h2 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li><p>开发指令级并行ILP的方法</p>
<ol>
<li>基于硬件的动态开发</li>
<li>基于软件的静态开发</li>
</ol>
</li>
<li><p>流水线CPI</p>
<p>实际CPI = 理想CPI + 停顿（结构/数据/控制冲突引起）</p>
</li>
<li><p>理想CPI是衡量流水线最高性能</p>
</li>
<li><p>IPC：每个时钟周期完成的指令数</p>
<p>CPI：每个指令所需时钟周期数</p>
</li>
<li><p>基本程序块：一串没有分支和跳转转入点的指令块</p>
</li>
</ol>
<p>解决冲突的方法之一是序列调度，不过对于跨块的调度（也即jump指令）会有影响</p>
<h3 id="相关与并行"><a href="#相关与并行" class="headerlink" title="相关与并行"></a>相关与并行</h3><p>相关：两条指令之间存在某种依赖关系</p>
<p>只能部分（完全不难）在流水线中重叠执行</p>
<p>类型：数据相关（真数据相关）、名相关、控制相关</p>
<p>约定先执行i再执行j</p>
<ol>
<li><p>数据相关</p>
<ol>
<li><p>定义：j使用i的结果，也即<strong>先写后读</strong></p>
</li>
<li><p>具有传递性</p>
</li>
<li><p>反映数据流动关系，即如何从生产者流动到消费者</p>
</li>
<li><p>数据相关不能并行，需要插入暂停解决冲突</p>
</li>
<li><p>解决方法</p>
<ol>
<li><p>保持相关但避免冲突</p>
<p>调度</p>
</li>
<li><p>变换代码消除相关关系</p>
</li>
</ol>
</li>
<li><p>检测方法</p>
<p>流经寄存器时直观；流经存储器复杂</p>
</li>
</ol>
</li>
<li><p>名相关</p>
<p><img src="/2024/01/04/arch/image-20240102144922624.png" alt="img"></p>
<ol>
<li><p>分类</p>
<ol>
<li>反相关：<strong>先读后写</strong>，也即i读的名与j写的名相同</li>
<li>输出相关：i和j写的名相同</li>
</ol>
</li>
<li><p>解决方法：换名技术，可以编译器静态实现 or 硬件动态实现</p>
<p><img src="/2024/01/04/arch/image-20240102150212591.png" alt="img"></p>
</li>
<li><p>相关问题</p>
<p>寄存器换名可以消除WAR和WAW冲突</p>
<ol>
<li>WAR（反相关）</li>
<li>WAW（输出相关）</li>
</ol>
</li>
</ol>
</li>
<li><p>数据冲突</p>
<p>注意这里的命名，是按照正确顺序命名的。比如说RAW（read after write），写后读，正确次序就是i写入然后j再读，所以叫写后读。</p>
<ol>
<li><p>RAW（数据相关）</p>
<p>也即i写j读</p>
</li>
<li><p>WAW（输出相关）</p>
<p>也即i写j写</p>
<p>流水线发生条件：流水线不止一个段可以写操作、指令被重新排序</p>
<p>5段流水线不会发生，因为只会在WB阶段写寄存器</p>
</li>
<li><p>WAR（反相关）</p>
<p>也即i读j写</p>
<p>流水线发生条件：有些指令写操作提前有些读操作滞后、指令被重新排序</p>
</li>
</ol>
</li>
<li><p>控制相关</p>
<p>由分支指令引起</p>
</li>
</ol>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p><img src="/2024/01/04/arch/image-20240102153057320.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102153140860.png" alt="img"></p>
<h3 id="动态调度"><a href="#动态调度" class="headerlink" title="动态调度"></a>动态调度</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p><img src="/2024/01/04/arch/image-20240102153209547.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102153253158.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102153325256.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102153513610.png" alt="img"></p>
<p>这里可能意思是引出了多流出，所以会导致DIV和ADD同时流出，从而发生WAW。同理，可能的阻塞也会导致WAR。</p>
<p><img src="/2024/01/04/arch/image-20240102153553760.png" alt="img"></p>
<h4 id="记分牌动态调度算法"><a href="#记分牌动态调度算法" class="headerlink" title="记分牌动态调度算法"></a>记分牌动态调度算法</h4><ol>
<li><p>基本思想</p>
<p>在没有结构冲突时，尽可能早地执行没有数据冲突的指令，实现每个时钟周期执行一条指令</p>
</li>
<li><p>基本结构</p>
<p>三张表：指令执行状态、功能部件状态、寄存器状态及数据相关关系</p>
<ol>
<li><p>指令状态表</p>
<p>记录正在执行的各条指令的状态</p>
</li>
<li><p>功能部件状态表</p>
<p>记录各个功能部件状态，每项有以下字段：</p>
<ul>
<li>Busy：yes/no</li>
<li>Op：操作编码</li>
<li>Fi：目的寄存器编号</li>
<li>Fj，Fk：源寄存器编号</li>
<li>Qj，Qk：Fj和Fk的功能部件</li>
<li>Rj，Rk：Fj和Fk是否就绪且还没被取走</li>
</ul>
</li>
<li><p>结果寄存器状态表</p>
<p>每个寄存器有一项，用于指出哪个功能部件将把结果写入</p>
<p>大概是这样的结果：n(寄存器数量) X m(功能部件数量) 的值为0 or 1的矩阵</p>
</li>
</ol>
</li>
<li><p>执行流程</p>
<p>每条指令的执行过程分为4段（只考虑浮点计算）</p>
<ol>
<li><p>流出</p>
<p>如果①所需功能部件空闲（结构冲突） ②其他正在执行指令目的寄存器与当前不同（WAW冲突），则流出</p>
</li>
<li><p>读操作数</p>
<p>记分牌监测操作数可用性，可用时通知功能部件从寄存器中读出源操作数开始执行（RAW冲突）</p>
</li>
<li><p>写结果</p>
<p>记分牌监测是否完成执行，若不存在or已消失WAR，则写入；存在，等待</p>
</li>
</ol>
</li>
<li><p>性能分析</p>
<p><img src="/2024/01/04/arch/image-20240102154713396.png" alt="img"></p>
</li>
</ol>
<h4 id="Tomasulo算法"><a href="#Tomasulo算法" class="headerlink" title="Tomasulo算法"></a>Tomasulo算法</h4><ol>
<li><p>核心思想</p>
<p>记录和检测指令相关，操作数一旦就绪立刻执行，把发生RAW的可能减到最小；</p>
<p>通过寄存器换名消除WAR和WAW（上面的记分牌是通过等待）</p>
<p><img src="/2024/01/04/arch/image-20240102155003297.png" alt="img"></p>
</li>
<li><p>基本结构</p>
<ol>
<li><p>保留站</p>
<p>每个保留一条已经流出并且等待到本功能部件执行的指令的相关信息。包括操作数、操作码以及各种元数据。</p>
<p><img src="/2024/01/04/arch/image-20240103191456693.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240103191510745.png" alt="img"></p>
<p>故而，需要有以下字段：</p>
<ul>
<li><p>Op：操作</p>
</li>
<li><p>Qj，Qk：操作数保留站号</p>
</li>
<li><p>Vj，Vk：源操作数值</p>
<p>load的Vk保存偏移量</p>
</li>
<li><p>Busy</p>
</li>
<li><p>A：存放立即数字段 or 有效地址，仅用于load和store缓冲器</p>
</li>
<li><p>Qi：寄存器状态表</p>
<p>存放把结果写入该寄存器的保留站ID</p>
</li>
</ul>
</li>
<li><p>公共数据总线CDB</p>
<p>用于发送各个功能部件的计算结果。如果具有多个执行部件且采用多流出流水线，则需要采用多条CDB。</p>
</li>
<li><p>load缓冲器和store缓冲器</p>
<ol>
<li>load缓冲器<ol>
<li>存放用于计算有效地址的分量</li>
<li>记录正在进行的load访存</li>
<li>保存buffer等待CDB传输</li>
</ol>
</li>
<li>store缓冲器<ol>
<li>存放用于计算有效地址的分量</li>
<li>记录正在进行的store访存，如目标地址以及是否已有数据</li>
<li>保存buffer等待CDB传输</li>
</ol>
</li>
</ol>
</li>
<li><p>浮点寄存器FP</p>
<p><img src="/2024/01/04/arch/image-20240103191954961.png" alt="img"></p>
</li>
<li><p>指令队列</p>
<p>FIFO</p>
</li>
<li><p>运算部件</p>
<p>浮点加法器、浮点乘法器</p>
</li>
</ol>
</li>
<li><p>寄存器换名实现</p>
<p>当指令流出，如果操作数缺失，则将指令数据换名为保留站编号</p>
</li>
<li><p>特点</p>
<ol>
<li><p>冲突检测与指令执行是分布的</p>
<p>通过保留站和CDB实现</p>
<p>计算结果通过CDB直接从产生它的保留站传送到所有需要它的功能部件，无需经过寄存器</p>
</li>
<li><p>消除了WAW和WAR</p>
</li>
</ol>
</li>
<li><p>执行步骤</p>
<p>3段流水</p>
<ol>
<li><p>流出</p>
<p>如果操作要求的保留站空闲（结构冲突），则送到保留站r。如果操作数已就绪，填入；否则，填入产生该操作数的保留站ID（寄存器换名，消除WAW、WAR）。</p>
</li>
<li><p>执行</p>
<p>两个操作数就绪后，就可以用保留站对应功能部件执行</p>
<p><img src="/2024/01/04/arch/image-20240103192438191.png" alt="img"></p>
</li>
<li><p>写结果</p>
<p>计算完毕后由CDB传送</p>
</li>
</ol>
</li>
</ol>
<h2 id="基于硬件的前瞻执行"><a href="#基于硬件的前瞻执行" class="headerlink" title="基于硬件的前瞻执行"></a>基于硬件的前瞻执行</h2><p><img src="/2024/01/04/arch/image-20240102194006302.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194044491.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194110646.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194131815.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194153222.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194455281.png" alt="img"></p>
<h2 id="多指令流出"><a href="#多指令流出" class="headerlink" title="多指令流出"></a>多指令流出</h2><p><img src="/2024/01/04/arch/image-20240102194619871.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194630616.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194647233.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194657928.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102194707753.png" alt="img"></p>
<h3 id="超标量实现"><a href="#超标量实现" class="headerlink" title="超标量实现"></a>超标量实现</h3><p><img src="/2024/01/04/arch/image-20240102194746453.png" alt="img"></p>
<ol>
<li><p>假设每个时钟周期流出两条，1整数型指令+1浮点型指令。</p>
<p>整数型：load、store、分支</p>
<p>浮点型：可能各种运算吧</p>
</li>
<li><p>假设所有浮点指令都是加法，执行时间3个时钟周期，且图中整数总在浮点前</p>
</li>
</ol>
<p><img src="/2024/01/04/arch/image-20240102204411292.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102204808639.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205022502.png" alt="img"></p>
<p>没懂，难道单发射流水线就不会吗。。。</p>
<p><img src="/2024/01/04/arch/image-20240102205049565.png" alt="img"></p>
<h4 id="基于静态调度"><a href="#基于静态调度" class="headerlink" title="基于静态调度"></a>基于静态调度</h4><p><img src="/2024/01/04/arch/image-20240102194736316.png" alt="img"></p>
<h4 id="基于动态调度"><a href="#基于动态调度" class="headerlink" title="基于动态调度"></a>基于动态调度</h4><p><img src="/2024/01/04/arch/image-20240102205352954.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205436394.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205627805.png" alt="img"></p>
<h3 id="VLIW技术"><a href="#VLIW技术" class="headerlink" title="VLIW技术"></a>VLIW技术</h3><p><img src="/2024/01/04/arch/image-20240102211051665.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102211128253.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102211233432.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102212621882.png" alt="img"></p>
<h2 id="基本指令调度和循环展开"><a href="#基本指令调度和循环展开" class="headerlink" title="基本指令调度和循环展开"></a>基本指令调度和循环展开</h2><p><img src="/2024/01/04/arch/image-20240102210720149.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210908707.png" alt="img"></p>
<h3 id="指令调度"><a href="#指令调度" class="headerlink" title="指令调度"></a>指令调度</h3><p><img src="/2024/01/04/arch/image-20240102205734815.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205747020.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102205905316.png" alt="img"></p>
<h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p><img src="/2024/01/04/arch/image-20240102210451127.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102210950130.png" alt="img"></p>
<h2 id="软流水"><a href="#软流水" class="headerlink" title="软流水"></a>软流水</h2><p><img src="/2024/01/04/arch/image-20240102212837871.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102213138751.png" alt="img"></p>
<h1 id="03-AI处理器"><a href="#03-AI处理器" class="headerlink" title="03  AI处理器"></a>03  AI处理器</h1><h2 id="并行体系结构"><a href="#并行体系结构" class="headerlink" title="并行体系结构"></a>并行体系结构</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="SISD"><a href="#SISD" class="headerlink" title="SISD"></a>SISD</h4><p><img src="/2024/01/04/arch/image-20240102214021593.png" alt="img"></p>
<h4 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h4><p><img src="/2024/01/04/arch/image-20240102214056889.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102214157734.png" alt="img"></p>
<h4 id="MIMD"><a href="#MIMD" class="headerlink" title="MIMD"></a>MIMD</h4><p><img src="/2024/01/04/arch/image-20240102214245315.png" alt="img"></p>
<h3 id="向量体系结构"><a href="#向量体系结构" class="headerlink" title="向量体系结构"></a>向量体系结构</h3><p><img src="/2024/01/04/arch/image-20240102214749559.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102214821362.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102215610502.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102215637482.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102215801347.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102220449488.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102220551855.png" alt="img"></p>
<p>后面不知道为什么写着写着开始英文了。。。算了，看起来都不重要。</p>
<h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><img src="/2024/01/04/arch/image-20240102224355405.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102224624834.png" alt="img"></p>
<h3 id="GPU体系结构"><a href="#GPU体系结构" class="headerlink" title="GPU体系结构"></a>GPU体系结构</h3><p><img src="/2024/01/04/arch/image-20240102224654360.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102224844092.png" alt="img"></p>
<h3 id="GPU计算"><a href="#GPU计算" class="headerlink" title="GPU计算"></a>GPU计算</h3><p><img src="/2024/01/04/arch/image-20240102225232885.png" alt="img"></p>
<h2 id="CUDA编程"><a href="#CUDA编程" class="headerlink" title="CUDA编程"></a>CUDA编程</h2><p><img src="/2024/01/04/arch/image-20240102225516782.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102225554050.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102225628645.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102225744734.png" alt="img"></p>
<p>GPU中的线程是执行计算任务的最小单位，可以看作是一系列指令的执行者。每个线程都有自己的程序计数器（PC）、寄存器集和局部内存。这些线程以并行的方式执行相同的指令，但可以有不同的输入数据，从而在数据并行的模式下执行计算。</p>
<p><img src="/2024/01/04/arch/image-20240102225815591.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102230010342.png" alt="img"></p>
<p>下面两个标题反了额</p>
<p><img src="/2024/01/04/arch/image-20240102230038257.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102230206629.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102230306330.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102230656126.png" alt="img"></p>
<p>感觉能明白其划分一组组线程的意义了，就是方便管理，一个warp执行相同的指令代码，所以要求同时调度同时执行</p>
<p><img src="/2024/01/04/arch/image-20240102231011833.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102231117382.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102231215353.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102231342912.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102231402948.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102231439031.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102231510202.png" alt="img"></p>
<h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><p><img src="/2024/01/04/arch/image-20240102231142528.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102231555745.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102231720776.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102231744036.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102231833061.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102231853576.png" alt="img"></p>
<h2 id="访存优化"><a href="#访存优化" class="headerlink" title="访存优化"></a>访存优化</h2><p><img src="/2024/01/04/arch/image-20240102232001600.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102232046305.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102232108515.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102232158535.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102232255286.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102232414096.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102232432245.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102232451438.png" alt="img"></p>
<p>真没懂。。。。</p>
<p><img src="/2024/01/04/arch/image-20240102232535558.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102232632515.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102232803540.png" alt="img"></p>
<p>真没看懂</p>
<h2 id="GPU控制流和指令优化"><a href="#GPU控制流和指令优化" class="headerlink" title="GPU控制流和指令优化"></a>GPU控制流和指令优化</h2><p><img src="/2024/01/04/arch/image-20240102232933197.png" alt="img"></p>
<h2 id="AI开发"><a href="#AI开发" class="headerlink" title="AI开发"></a>AI开发</h2><h3 id="DL框架"><a href="#DL框架" class="headerlink" title="DL框架"></a>DL框架</h3><p><img src="/2024/01/04/arch/image-20240102233128408.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102233209215.png" alt="img"></p>
<h3 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h3><p><img src="/2024/01/04/arch/image-20240102233246339.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102233303086.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102233318668.png" alt="img"></p>
<h4 id="算子开发"><a href="#算子开发" class="headerlink" title="算子开发"></a>算子开发</h4><p><img src="/2024/01/04/arch/image-20240102233405004.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102233451083.png" alt="img"></p>
<p>TODO接下来有兴趣看吧</p>
<h4 id="模型开发"><a href="#模型开发" class="headerlink" title="模型开发"></a>模型开发</h4><p><img src="/2024/01/04/arch/image-20240102233629195.png" alt="img"></p>
<h1 id="04-自动驾驶体系结构"><a href="#04-自动驾驶体系结构" class="headerlink" title="04  自动驾驶体系结构"></a>04  自动驾驶体系结构</h1><p><img src="/2024/01/04/arch/image-20240102235111370.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102235132586.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102235521886.png" alt="img"></p>
<p><img src="/2024/01/04/arch/image-20240102235604742.png" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>Rewriting</title>
    <url>/2024/05/11/Rewriting/</url>
    <content><![CDATA[<h1 id="Capping"><a href="#Capping" class="headerlink" title="Capping"></a><a href="/2024/01/07/Capping">Capping</a></h1><p>测试做得很友好很完善</p>
<p>对stream进行分段为segment；限制每个版本的容器数（主要是指引用的旧容器数）；将那些包含重复块rate较小的容器所包含的重复块视为unique block进行rewrite。</p>
<h1 id="HAR"><a href="#HAR" class="headerlink" title="HAR"></a>HAR</h1><p>sparse container和out-of-order container；连续备份间sparse container有继承趋势；每次重写所有继承的sparse container，并且维护当前的sparse container列表以供下次备份参考。</p>
<p>TODO</p>
<h1 id="SMR"><a href="#SMR" class="headerlink" title="SMR"></a>SMR</h1><p><a href="https://ieeexplore.ieee.org/abstract/document/8402122/">Improving Restore Performance in Deduplication Systems via a Cost-Efficient Rewriting Scheme</a></p>
<p>在去重时选择容器这个问题可以建模为一个NP的算法问题：（或者说Restoration，由于是反过程所以感觉原理也比较相似）</p>
<p><strong>Input</strong>:         n个等长集合；数组target【container、recipe】</p>
<p><strong>Output</strong>:     并集包含target中所有数字的最少集合【selected restore containers】</p>
<p>Capping事实上就相当于进行了一个妥协，将该问题转化为：</p>
<p><strong>Input</strong>:         n个等长集合；数组target【container、recipe】</p>
<p><strong>Output</strong>:     选择集合中target比率最大的T个集合【selected restore containers】</p>
<p>之前刚入门deduplication system，在看代码的时候，就在想对capping的处理是不是有点暴力了。具体来说，在Capping中，这个块是很多个容器都有，我们每次都默认选择第一个容器来作为这个chunk的index，也即只视第一个容器的chunk为<strong>referenced chunks</strong>，其它都为仅被引用一次的<strong>redundant chunks</strong>。而这有时候并不是最优解，因为有可能选同样包含该chunk的其它容器是最优解，也即它们事实上利用比率最大，但是里面部分chunk被视为了redundant而非referenced chunk。</p>
<p>本篇文章也正是针对该问题提出。它认为，Capping会产生这个问题是因为它依据了index来进行容器利用率的检测，但其实完全没必要这么做。故而，它提出采用容器之间的差异性来作为指标。</p>
<p><img src="/2024/05/11/Rewriting/image-20240511151432270.png" alt="image-20240511151432270"></p>
<p>也即，它将问题转化为了：</p>
<p><strong>Input</strong>:         n个集合；</p>
<p><strong>Output</strong>:     并集包含的数字最多的T个集合</p>
<p>然后只对这个选出来的集合id的容器进行去重，别的都重写。这样一来，它就能够使容器利用率相比于Capping大大增加，重写数大大减少，效果一流。</p>
<p>不过这个问题依然还是一个NP问题，故而它使用了贪心算法来进一步解决这个问题：每次从容器全集中选出一个跟当前smr集合不一样的chunk最多的容器。</p>
<p><img src="/2024/05/11/Rewriting/image-20240511152707489.png" alt="image-20240511152707489"></p>
<blockquote>
<p>补充：贪心算法可解的证明<br><img src="/2024/05/11/Rewriting/2kSfwhw5Sd7.png" alt="image.png"><br><img src="/2024/05/11/Rewriting/2kSgf9wdlNi.png" alt="image.png"><br>求解任何单调子模性函数的最大值，都可以用贪心算法来取得一个质量不错的近似解。于是它的思路就是证明这个是单调子模函数即可</p>
<p><img src="/2024/05/11/Rewriting/image-20240511154851309.png" alt="image-20240511154851309"></p>
</blockquote>
<p>它最后还提出了一个GSMR，依据备份版本之间的特性进行的重写，感觉跟MFDedup的NDF很像，很神奇，后者多加了个更主要的布局整理的第二步。</p>
<h1 id="DePFC"><a href="#DePFC" class="headerlink" title="DePFC"></a>DePFC</h1><p><a href="https://ieeexplore.ieee.org/abstract/document/8994084">Improving Restore Performance of Packed Datasets in Deduplication Systems via Reducing Persistent Fragmented Chunks</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>大概是说发现了一部分persistent fragment chunk，这些块会一直被重写。具体来说，它关注的是这样的情形。在Deduplication System中，数据流都是以tar形式输入的。而tar的打包方式大概是会给每个文件安上一个metadata block前缀，后面再跟数据块一样，所以最终会是metadata和数据混合存储，并且一般情况下，都是metadata变化较频繁（比如说时间戳变化之类的），数据块变化较为少。而对于小文件较多的场景，这时候就是一个容器中含有很多metadata和少部分data block，如果数据块是持久不变的，由于这个metadata经常变化（unique），导致目前的Rewriting方案都会觉得这个对应的容器的利用率很低，并且加上不会更新index，从而就会导致这个chunk一直被重写，就称这样的chunk为PFC。</p>
<blockquote>
<p>这点其实也是审稿意见中提到的吧，文件间（或者说chunk间）访问频率不固定，不过NACC的做法倒是均等化了每一个chunk的出现几率</p>
</blockquote>
<p>故而，本篇文章提出的思路是，在协作的其它rewriting算法选举出重写块之后，再进一步对重写块分类，分为PFC(persistent fragment chunk) 和 RFC(regular fragment chunk)，然后后者普通重写，前者放在一起重写，并且更新fp index指向最新重写块。</p>
<p>其中，identify RFC and PFC是这么实现的，维护上一个备份版本的rewritten set。如果FC在其中，则为PFC(被重写过了一次)；否则为RFC，加入本次版本的rewritten index。</p>
<p>然后，这个过程就会有两个比较关键的点：</p>
<ol>
<li><p>Limited Scope to Compute the Container’s Utilization</p>
<p><img src="/2024/05/11/Rewriting/image-20240511194450908.png" alt="image-20240511194450908"></p>
<p>在对于Capping协作这种情况会导致该方法失效……</p>
<p>解决方法是引入一个FCBuffer。具体来说，这个FCBuffer是一个跨segment的数据结构，FC首先被写入FCBuffer，并且实时监测FCBuffer中的各个container的利用率，若利用率达到阈值，就移除FCBuffer中该container对应的所有数据块（因为这说明这些数据块已经被depfc过了）。然后当FCBuffer满的时候再写入新容器。</p>
</li>
<li><p>Restore Cache Thrashing</p>
<p>PFC之间可能间隔很远，特别第一点的FCBuffer带来的PFC和RFC混合存储可能会worsen这一点（毕竟本来RFC就是为了大局起见重写的，把他们集中放置反而可能让PFC之后又面临那个问题了），导致RFC一直滞留更是G。为了防范这点，它引入了一个LRU cache来模拟Restoration阶段，当一个container被驱逐时，就可能说明它里面含有的RFC和当前FCBuffer内所有PFC马上要离当前的context太远了，于是就赶紧写入它对应的所有RFC，以及FCBuffer中所有的PFC。这样一来就能改善距离过远的问题。</p>
<blockquote>
<p>这一点我其实觉得有点费解，虽然说直观上觉得是对的，但是理性上还是很难说服自己，实在没怎么看懂。</p>
</blockquote>
</li>
</ol>
<p>整个算法流程如下图所示：</p>
<p><img src="/2024/05/11/Rewriting/image-20240511201404030.png" alt="image-20240511201404030"></p>
<blockquote>
<p>我看这篇文章，其实是想在当前代码框架尝试着去复现它的。然而，当前的代码框架是一个顺序写入recipe和block的逻辑，貌似不大支持有的chunk可能得在下一个segment的时候才能被确定recipe中的容器位置，我能想到的唯一解决方法是先把这些视为duplicate，等到最后整个dedup完成（所有segment输入完毕）的时候再统一进行一次recipe的更新，不过实现代价可能有点大所以暂时没敢动。</p>
</blockquote>
<p>不过想了想，如果是结合HAR实现的话，可能不一定会这么复杂。首先得知道为什么<strong>HAR的话PFC是每隔两个版本才被重写一次</strong>，因为你刚重写完的那个版本中PFC所在容器肯定不是sparse的吧，所以下一个版本自然也不会认定其为herite然后重写。因此，我们就需要的是根据相隔版本来构造RCrecent。而且值得注意的是，HAR检测需要重写的块是通过一个global的视角来实现的，只要对应容器是herite的那么它就是需要重写的，因此就不用考虑什么FCBuffer这种现象，更进一步的也不用啥LRU cache了，这个可以通过恢复时采用OPT算法或者更大的缓存来实现。具体来说，逻辑大概是这样：</p>
<ol>
<li><p>如果chunk所在cid ∉ sparse herite</p>
<p>去重or重写</p>
</li>
<li><p>如果chunk所在cid ∈ sparse herite</p>
<ol>
<li>如果chunk在上上个版本的RCrecent    PFC</li>
<li>不在    PFC</li>
</ol>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>DePFC的代码感觉比别的两个要复杂，这里也暂且放个我的DePFC + Capping的代码实现吧，虽然最后发现还是不大行（指跟现有代码框架不大兼容，但感觉逻辑一类还是差不多），虽然未经debug，感觉也是可供参考。下面的代码暂没更新fp index，只是基本逻辑框架。</p>
<p>TODO，之后有时间继续完善下吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	基本思路：</span></span><br><span class="line"><span class="comment">	1. Capping识别出FC</span></span><br><span class="line"><span class="comment">	2. doDePFC()分类出PFC和RFC</span></span><br><span class="line"><span class="comment">		1. 不断地从wl中获取，unique跳过，普通duplicate跳过</span></span><br><span class="line"><span class="comment">		2. FCBuffer满时全部视为PFC，加入PFC set，更新global fp index</span></span><br><span class="line"><span class="comment">		3. 驱逐遍历时，PFC加入PFC set，RFC更新rewritten index</span></span><br><span class="line"><span class="comment">		4. 如果FCBuffer中某一容器出现频率达到阈值，移出FCBuffer（相当于视作RFC了）</span></span><br><span class="line"><span class="comment">	3. 在写入阶段</span></span><br><span class="line"><span class="comment">		1. unique和duplicate正常处理（写入data block、写入recipe）</span></span><br><span class="line"><span class="comment">		2. 如果是PFC，写入new container</span></span><br><span class="line"><span class="comment">	当前代码框架是顺序写入逻辑，要求写入时必须要写入recipe。上述思路会致使一些chunk在本segment输入结束时仍未得知自己是PFC还是RFC还是普通duplicate，从而无法顺序写入recipe，导致可能需要先把FC都视为duplicate，然后之后再进行一个统一的更新recipe。由于实现太过复杂，时间上来不大及，故而暂且先放下。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Data Structure */</span></span><br><span class="line"><span class="comment">// FCBuffer &lt;cid, FCs&gt;</span></span><br><span class="line">std::unordered_map&lt;<span class="type">uint64_t</span>, std::list&lt;SHA1FP&gt;&gt; FCBuffer;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">uint64_t</span> FCBufferCapacity = ContainerSize / ExpectChunkSize;</span><br><span class="line"><span class="type">int</span> FCBufferCurrentSize = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> FCBuffer_new_cid = fid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// old rewritten index</span></span><br><span class="line">std::unordered_set&lt;SHA1FP, TupleHasher, TupleEqualer&gt; RCIndex;</span><br><span class="line"><span class="comment">// new rewritten index</span></span><br><span class="line">std::unordered_set&lt;SHA1FP, TupleHasher, TupleEqualer&gt; new_RCIndex;</span><br><span class="line"></span><br><span class="line">LRUCache SRC;	<span class="comment">// LRU for container id</span></span><br><span class="line"></span><br><span class="line">std::unordered_set&lt;SHA1FP, TupleHasher, TupleEqualer&gt; PFC;</span><br><span class="line"><span class="comment">// 记录FC中被视为duplicate的（与Capping兼容情况）</span></span><br><span class="line">std::unordered_set&lt;SHA1FP, TupleHasher, TupleEqualer&gt; InterCapping;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DePFC</span></span><br><span class="line">Dedup Pipeline:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;dedupTask : taskList) &#123;</span><br><span class="line">        detectList.<span class="built_in">push_back</span>(dedupTask);</span><br><span class="line">        segmentLength += dedupTask.length;</span><br><span class="line">        <span class="keyword">if</span> (segmentLength &gt; SegmentThreshold || dedupTask.countdownLatch) &#123;</span><br><span class="line">            <span class="built_in">processingWaitingList</span>(detectList);</span><br><span class="line">            <span class="built_in">cappingDedupChunks</span>(detectList);	<span class="comment">// do Capping first</span></span><br><span class="line">            <span class="built_in">doDePFC</span>(detectList);</span><br><span class="line"></span><br><span class="line">            segmentLength = <span class="number">0</span>;</span><br><span class="line">            detectList.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// change RCIndex to new_RCIndex</span></span><br><span class="line">    RCIndex = new_RCIndex;</span><br><span class="line">    new_RCIndex.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// baseChunkPositions中是Capping分类出的FC</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dePFC</span><span class="params">(std::list&lt;DedupTask&gt; &amp;wl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;entry: wl) &#123;</span><br><span class="line">        <span class="type">bool</span> isFC = <span class="literal">false</span>;</span><br><span class="line">        Location location;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unlikely</span>(!FLAGS_dedup))    <span class="keyword">continue</span>;   <span class="comment">// all chunks are regarded as unique</span></span><br><span class="line">        <span class="type">int</span> result = GlobalMetadataManagerPtr-&gt;<span class="built_in">findRecord</span>(entry.fp, &amp;location);</span><br><span class="line">        <span class="keyword">if</span> (!result)    <span class="keyword">continue</span>;   <span class="comment">// unique</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// now all chunks here is duplicated</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> citer = baseChunkPositions.<span class="built_in">find</span>(location.fid);</span><br><span class="line">        <span class="keyword">if</span> (citer == baseChunkPositions.<span class="built_in">end</span>() || citer-&gt;second == <span class="number">0</span>) &#123;	<span class="comment">// Capping result</span></span><br><span class="line">            isFC = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isFC)  <span class="keyword">continue</span>;   <span class="comment">// normal duplicate</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// now all chunks here is FC</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FCBufferCurrentSize + <span class="number">1</span> &gt;= FCBufferCapacity) &#123;</span><br><span class="line">            <span class="comment">// regard all as PFC</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> fc_it = FCBuffer.<span class="built_in">begin</span>(); fc_it != FCBuffer.<span class="built_in">end</span>();) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> fp = fc_it-&gt;second.<span class="built_in">begin</span>(); fp != fc_it-&gt;second.<span class="built_in">end</span>();) &#123;</span><br><span class="line">                    PFC.<span class="built_in">insert</span>(*fp);</span><br><span class="line">                    FCBufferCurrentSize --;</span><br><span class="line">                    fp = fc_it-&gt;second.<span class="built_in">erase</span>(fp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fc_it-&gt;second.<span class="built_in">empty</span>() || fc_it-&gt;first == vid)   </span><br><span class="line">                    fc_it = FCBuffer.<span class="built_in">erase</span>(fc_it);</span><br><span class="line">                <span class="keyword">else</span>    fc_it ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert</span>(FCBufferCurrentSize == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">uint64_t</span> old_cid = location.fid;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> vid = SRC.<span class="built_in">put</span>(old_cid);</span><br><span class="line">        <span class="keyword">if</span> (vid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = FCBuffer.<span class="built_in">find</span>(vid);</span><br><span class="line">            <span class="built_in">assert</span>(it != FCBuffer.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">bool</span> has_pfc = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;fp : it-&gt;second) &#123;</span><br><span class="line">                <span class="keyword">if</span> (RCIndex.<span class="built_in">find</span>(fp) == RCIndex.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="comment">// RFC, regard as normal denyDedup</span></span><br><span class="line">                    FCBufferCurrentSize  --;</span><br><span class="line">                    new_RCIndex.<span class="built_in">insert</span>(fp);</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> add updates for rewritten index</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                has_pfc = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remove all pfc in the buffer</span></span><br><span class="line">            <span class="keyword">if</span> (has_pfc) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> fc_it = FCBuffer.<span class="built_in">begin</span>(); fc_it != FCBuffer.<span class="built_in">end</span>();) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> fp = fc_it-&gt;second.<span class="built_in">begin</span>(); fp != fc_it-&gt;second.<span class="built_in">end</span>();) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (RCIndex.<span class="built_in">find</span>(*fp) == RCIndex.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                            fp ++</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// PFC</span></span><br><span class="line">                        FCBufferCurrentSize --;</span><br><span class="line">                        PFC.<span class="built_in">insert</span>(*fp);</span><br><span class="line">                        fp = fc_it-&gt;second.<span class="built_in">erase</span>(fp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (fc_it-&gt;second.<span class="built_in">empty</span>() || fc_it-&gt;first == vid)   fc_it = FCBuffer.<span class="built_in">erase</span>(fc_it);</span><br><span class="line">                    <span class="keyword">else</span>    fc_it ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            FCBuffer.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FCBuffer[old_cid].<span class="built_in">insert</span>(entry);</span><br><span class="line">        FCBufferCurrentSize ++;</span><br><span class="line">        <span class="keyword">auto</span> it = FCBuffer.<span class="built_in">find</span>(old_cid);</span><br><span class="line">        <span class="keyword">if</span> ((it-&gt;second.<span class="built_in">size</span>()) * FLAGS_ExpectSize / ContainerSize &gt;= Threshold) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;fp : it-&gt;second) &#123;</span><br><span class="line">                FCBufferCurrentSize --;</span><br><span class="line">                <span class="comment">// normal duplicate</span></span><br><span class="line">                InterCapping.<span class="built_in">insert</span>(fp);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            FCBuffer.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DePFC</span></span><br><span class="line"><span class="keyword">auto</span> citer = baseChunkPositions.<span class="built_in">find</span>(writeTask.location.fid);</span><br><span class="line"><span class="keyword">if</span> (citer == baseChunkPositions.<span class="built_in">end</span>() || citer-&gt;second == <span class="number">0</span>) &#123;	<span class="comment">// FC</span></span><br><span class="line">    <span class="keyword">if</span> (InterCapping.<span class="built_in">find</span>(entry.fp) == InterCapping.<span class="built_in">end</span>()) &#123;	<span class="comment">// RFC or PFC</span></span><br><span class="line">        result = <span class="number">0</span>; <span class="comment">// capping reject similar chunks.</span></span><br><span class="line">        denyDedup++;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;writeTask.location, <span class="number">0</span>, <span class="built_in">sizeof</span>(Location));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>They propose <strong>DePFC</strong> that identifies and groups PFCs to increase the utilization of containers storing PFCs, making grouped PFCs no longer fragmented. However, DePFC <u>fails to remove redundant data among similar chunks holding metadata blocks</u>.</p>
<p>与之相关的是他们团队ICCD’21的另一篇文章，A High-performance Post-deduplication Delta Compression Scheme for Packed Datasets，利用了通过PFC来发现metadata block，然后对其进行内部的delta compression。</p>
<h1 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h1><p>正好一次性读了两篇文章，就来稍微想一下对比吧。我感觉相比DePFC，还是SMR的应用范围可能更广一些，毕竟DePFC可能只在巨多小文件的时候，效果才会出奇的好，平时感觉可能就比一般重写好些。SMR的话，可能还是有一个情况比较受限，比如说一个极端情况，target中正巧很少包含选举出的container中互异的那些chunk，这种情况下target可能需要被大规模重写。emmm…但感觉这种情况也特别少见，不大懂。</p>
<p>总之，感觉我还是缺少了点看出这些方法有什么缺点的眼力，不过好在看完了也是收获了挺多。过几天再看看两篇文章的evaluation具体都测了什么吧。</p>
]]></content>
  </entry>
  <entry>
    <title>Project0   C++ Primer</title>
    <url>/2023/03/13/cmu15445$lab0/</url>
    <content><![CDATA[<h1 id="Project0-C-Primer"><a href="#Project0-C-Primer" class="headerlink" title="Project0   C++ Primer"></a>Project0   C++ Primer</h1><p>相比于fall2022（Trie），<u>spring2023（COW-Trie）的难度更大，算法更复杂</u>【毕竟是要实现一个cow的数据结构】，我认为两个都很有意义，故而两个都做了。</p>
<p>其中在Trie中，由于我是第一次接触cpp，所以遇到了很多麻烦。好在经过18h+的cpp拷打后，cow-trie虽然难度大，语法也更复杂一些，但我还是很快（话虽如此也花了7、8小时23333）就完美pass了。不过效率可能还是不大高，毕竟我不熟悉cpp，很多地方可能都直接拷贝了emm希望后续学习可以加把劲。</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><blockquote>
<p>In this project, you will implement a key-value store backed by a concurrent <a href="https://en.wikipedia.org/wiki/Trie">trie</a>. 实现并发安全的trie</p>
<p>To simplify the explaination, we will assume tha the keys are all <u>non-empty</u> <u>variable-length</u> <strong>strings</strong> but in practice they can be any arbitrary type.  key为非空变长字符串</p>
<p>The key-value store you will implement can store string keys mapped to values of any type. key必须是字符串类型，但value可以是任意类型</p>
<p>The value of a key is stored in the node representing the <strong>last</strong> character of that key.</p>
<p><img src="/2023/03/13/cmu15445/image-20230312150245669.png" alt="image-20230312150245669"></p>
</blockquote>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>本次实验完成时间总计18h+。是的，lab0就做了这么久【难绷】</p>
<p>其实光就实验内容来看，无非就是实现trie树，算法上没有很难，最难的应该是Remove函数的编写，因为它是个递归。</p>
<p>但正如本次实验的主题<code>C++ Primer</code>所揭示的那样，本次实验的真正难点在于C++……而在接触本实验之前，我对c++<u>一无所知</u>。</p>
<p>除了这个萌新debuf之外，我还不小心犯了另一件非常sb的乌龙，加上对cpp实在是太小白了，再加上这几天破事又贼多，更是让我心态大崩，差点一蹶不振不想写了（。</p>
<p>因而，整个实验在我看来<strong>十分痛苦</strong>。coding阶段，就是 语法错误-看了半天报错信息才发现哪错了-改错误-改得不对-再改-再改-再改……这样的痛苦过程在循环往复；运行阶段，就是看着stack trace发呆、用gdb调来调去还不知道为什么错了这样的痛苦过程在循环往复。好在，我还是坚持下来了，虽然内心还是很浮躁很浮躁（</p>
<p>不过总而言之，我认为这次实验给我收获挺大的。它帮助我熟悉了C++，但我认为更重要的，是它帮我矫正了心态。做这个实验之前，我内心是很浮躁的（那会破事太多了），而且因为它是lab0所以有点轻敌（对不起。。），因而我所采取的策略是“错误驱动”，也即哪里报错就百度下怎么改就行。这样的心态就导致我的debug过程极度痛苦，因为完全看不懂报错信息，压根不知道错在哪里，百度也百度不出来。于是我被迫修改了战略，去看了我一直不想看的书，学了我一直很害怕的cpp，用了我一直很抗拒的gdb调试，才发现其实都没有我想象的这么恐怖。这期间、这几天的种种心路历程，我认为是十分可贵的。</p>
<h4 id="错误集锦"><a href="#错误集锦" class="headerlink" title="错误集锦"></a>错误集锦</h4><h5 id="sb错误"><a href="#sb错误" class="headerlink" title="sb错误"></a>sb错误</h5><p>我下载下来starter code的时候，发现找不到它要我们实现的<code>p0_trie.h</code>，只有这几个：</p>
<p><img src="/2023/03/13/cmu15445/image-20230318154940622.png" alt="image-20230318154940622"></p>
<p>我便觉得可能是实验代码改版了。但是我<strong>并没有多想</strong>，我觉得可能只是代码模板改版了但实验内容不变QAQ【为什么会这么觉得呢？因为我看到指导书的url为fall2022便以为这是最新版指导书，没有想到春季学期也可以开课，还有个spring2023呃呃】而且代码看起来也确实是要我们实现Trie树【虽然跟指导书说得不大一样】。故而，我就这么直接开干了。</p>
<p>写完了Tire树的逻辑【这部分确实挺简单的】之后，我就开始了漫长的痛苦且折磨的原地兜圈之旅。由于真正的spring2023的代码模板是实现COW-Trie，故而代码模板中很多地方都使用了const关键字，包括树结点以及树的children_成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in class Trie</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; root_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">auto</span> <span class="title">Get</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> T *</span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">auto</span> <span class="title">Put</span><span class="params">(std::string_view key, T value)</span> <span class="type">const</span> -&gt; Trie</span>;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Remove</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; Trie</span>;</span><br><span class="line"><span class="comment">// in class TrieNode</span></span><br><span class="line">  std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;&gt; children_;</span><br></pre></td></tr></table></figure>

<p>如上是spring2023的代码模板。</p>
<p>如果使用其给我们提供的COW-Tire接口来实现Trie树，就会产生巨大的矛盾。你无法在<code>root_</code>的孩子中插入或者删除一个树节点，因为<code>root_</code>指向一个const对象，其<code>children_</code>域也是const的。同样的，你也无法对<code>root_</code>的孩子的孩子集合做增删结点操作，因为它也是const的。</p>
<p>由于对C++不熟悉，通过满屏幕的报错从而搞清楚上面那些东西这件事，就花费了我很多很多时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">error: no matching function <span class="keyword">for</span> call to </span><br><span class="line">    ‘std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> bustub::TrieNode&gt; &gt;</span><br><span class="line">    ::<span class="built_in">insert</span>(std::pair&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> bustub::TrieNode&gt; &gt;) <span class="type">const</span>’</span><br></pre></td></tr></table></figure>

<p>比如说这个错误我就看了半天完全不知道啥意思（</p>
<p>好在明白上面这点后，我很快就发现了spring2023的存在，然后切到了fall2022的正确分支【乐】</p>
<p>经过了此乌龙后，我深刻地意识到了我对C++一窍不通的程度（，比如说上面的这些const，还有比如说&amp;是什么东西&amp;&amp;又是什么东西，shared_ptr又是什么东西等等等，我都不懂。故而，我压制了内心的浮躁，去简单看了一下书，了解了new的作用、左值引用右值引用、move、智能指针这几个地方，然后再去重新开始写本实验，最终果然好了不少。</p>
<h5 id="错误使用unique-ptr-get"><a href="#错误使用unique-ptr-get" class="headerlink" title="错误使用unique_ptr::get"></a>错误使用unique_ptr::get</h5><p>在<code>Trie::GetValue</code>中，我本来是这么写的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	std::unique_ptr&lt;TrieNode&gt;* t = &amp;root_;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	std::unique_ptr&lt;TrieNodeWithValue&lt;T&gt;&gt; <span class="built_in">tmp</span>(<span class="keyword">dynamic_cast</span>&lt;TrieNodeWithValue&lt;T&gt; *&gt;(t-&gt;<span class="built_in">get</span>()));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就会导致，tmp和(*t)会指向同一块内存区域，并且它们都是<code>unique_ptr</code>。随后，代码块遇到<code>&#125;</code>结束，tmp的析构函数被调用，那块内存区域被free，但(*t)依然指向那块内存区域，随后在释放整个Trie树时这块区域就会被再次释放，然后寄（</p>
<h5 id="共享unique-ptr"><a href="#共享unique-ptr" class="headerlink" title="共享unique_ptr"></a>共享unique_ptr</h5><p>有一个方法可以在不剥夺某个<code>unique_ptr</code>的所有权的同时，又能用另一个变量来操作该指针所指向的对象。这个方法就是——使用指向<code>unique_ptr</code>的指针（。</p>
<p>也即比如：<code>std::unique_ptr&lt;TrieNode&gt; *</code></p>
<h5 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h5><p>本次实验还格外要求了代码规范问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make format</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make check-lint</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make check-clang-tidy-p0</span></span><br></pre></td></tr></table></figure>

<h5 id="自测"><a href="#自测" class="headerlink" title="自测"></a>自测</h5><p>我暂时没进行gradescope的自测，原因是它上面报了个跟我没啥关系的错，我不知道怎么改呃呃。</p>
<p><img src="/2023/03/13/cmu15445/image-20230318165521340.png" alt="image-20230318165521340"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In file included from /autograder/bustub/src/common/bustub_instance.cpp:17:</span><br><span class="line">/autograder/bustub/src/include/common/bustub_instance.h:30:10: fatal error: &#x27;libfort/lib/fort.hpp&#x27; file not found</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include <span class="string">&quot;libfort/lib/fort.hpp&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>都指向说找不到这个fort。但我真的不知道它为啥找不到，因为我看CMakeLists.txt中已经加了<code>third_party/</code>这个include目录了，并且这个东西的路径也确实是<code>third_party/libfort/lib/for.hpp</code>。</p>
<p>我还在<code>CMackLists.txt</code>、<code>src/CMackLists.txt</code>、<code>tools/shell/CMackLists.txt</code>里面都加了<code>include($&#123;PROJECT_SOURCE_DIR&#125;/third_party/libfort/lib/fort.hpp)</code>，但是依然报了这样的错：</p>
<p><img src="/2023/03/13/cmu15445/image-20230318173941576.png" alt="image-20230318173941576"></p>
<p><img src="/2023/03/13/cmu15445/image-20230318174102171.png" alt="image-20230318174102171"></p>
<p>它这为啥找不到我是真的很不理解。</p>
<p>所以真的很奇怪。暂且先放着吧，之后有精力研究下这些编译链接过程。</p>
<h2 id="COW-Trie"><a href="#COW-Trie" class="headerlink" title="COW-Trie"></a>COW-Trie</h2><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/613920859">CMU 15445 Project 0 (Spring 2023) 学习记录</a>  参考了task2和一个bug</p>
</blockquote>
<p>先放个通关截图~</p>
<p><img src="/2023/03/13/cmu15445/image-20230322235159843.png" alt="image-20230322235159843"></p>
<p>总体用时（coding+debug+note）10h+</p>
<p>本次实验是在它给的接口的基础上，实现一株并发安全的cow的trie树，还有一个小小的实现<code>upper</code>和<code>lower</code>函数的实验用来熟悉我们之后要写的db的东西。算法难度还是有一些的，我的coding和debug时间估摸着可能有46开。</p>
<p>总体来说整个实验还是非常有价值的，相比往年难度和意义都更上了一层。感谢实验设计者让我做到设计得这么好的实验~</p>
<h3 id="Task1-cow-trie"><a href="#Task1-cow-trie" class="headerlink" title="Task1 cow-trie"></a>Task1 cow-trie</h3><blockquote>
<p>In this task, you will need to modify <code>trie.h</code> and <code>trie.cpp</code> to implement a copy-on-write trie.</p>
<p>下面举例说明</p>
<p>Consider inserting <code>(&quot;ad&quot;, 2)</code> in the above example. We create a new <code>Node2</code> by reusing two of the child nodes from the original tree, and creating a new value node 2. (See figure below)</p>
<p><img src="/2023/03/13/cmu15445/image-20230323000513767.png" alt="image-20230323000513767"></p>
<p>If we then insert <code>(&quot;b&quot;, 3)</code>, we will create a new root, a new node and reuse the previous nodes. In this way, we can get the content of the trie before and after each insertion operation. As long as we have the root object (<code>Trie</code> class), we can access the data inside the trie at that time. (See figure below)</p>
<p><img src="/2023/03/13/cmu15445/image-20230323000601882.png" alt="image-20230323000601882"></p>
<p>One more example: if we then insert <code>(&quot;a&quot;, &quot;abc&quot;)</code> and remove <code>(&quot;ab&quot;, 1)</code>, we can get the below trie. Note that parent nodes can have values, and you will need to purge all unnecessary nodes after removal.</p>
<p><img src="/2023/03/13/cmu15445/image-20230323000658620.png" alt="image-20230323000658620"></p>
<p>To create a new node, you should use the <code>Clone</code> function on the <code>TrieNode</code> class. To reuse an existing node in the new trie, you can copy <code>std::shared_ptr&lt;TrieNode&gt;</code>: copying a shared pointer doesn’t copy the underlying data.</p>
<p>You <strong>should not</strong> manually allocate memory by using <code>new</code> and <code>delete</code> in this project. <code>std::shared_ptr</code> will deallocate the object when no one has a reference to the underlying object.</p>
</blockquote>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><p>task1的目标就是实现我们的cow-trie的主体，先不要求并发。</p>
<p>虽说算法上比较复杂，但是由于它图解以及代码中的注释解说都已经说得很详细了，再加上之前已经写过了trie树有一个大体框架，因而具体coding的时候思路还是比较清晰的。</p>
<p>我认为具体的难点还是在于cpp上。下面列出了几个比较有价值的错误和相关debug过程，其中<code>const转移</code>和<code>显示保存is_value_node_</code>是我认为两个比较难的点。</p>
<h4 id="错误集锦-1"><a href="#错误集锦-1" class="headerlink" title="错误集锦"></a>错误集锦</h4><h5 id="const转移"><a href="#const转移" class="headerlink" title="const转移"></a>const转移</h5><p>在<code>trie.h</code>中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The root of the trie.</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; root_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  <span class="comment">// Create a new trie with the given root.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Trie</span><span class="params">(std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; root)</span> : root_(std::move(root)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create an empty trie.</span></span><br><span class="line">  <span class="built_in">Trie</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the value associated with the given key.</span></span><br><span class="line">  <span class="comment">// 1. If the key is not in the trie, return nullptr.</span></span><br><span class="line">  <span class="comment">// 2. If the key is in the trie but the type is mismatched, return nullptr.</span></span><br><span class="line">  <span class="comment">// 3. Otherwise, return the value.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Get</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> T *</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Put a new key-value pair into the trie. If the key already exists, overwrite the value.</span></span><br><span class="line">  <span class="comment">// Returns the new trie.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Put</span><span class="params">(std::string_view key, T value)</span> <span class="type">const</span> -&gt; Trie</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the key from the trie. If the key does not exist, return the original trie.</span></span><br><span class="line">  <span class="comment">// Otherwise, returns the new trie.</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Remove</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; Trie</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，为了呼应我们的cow-trie，在语法上强制性要求不能“directly modify”，它将<code>root_</code>和<code>children_-&gt;second</code>同时设置为了一个指向对象为const的指针。而这意味着什么呢？意味着我们不能修改<code>root_</code>的内容，也不能修改<code>root_-&gt;children_-&gt;second</code>的内容，同样的孩子的孩子也不行。这就需要我们在<code>Put</code>方法中遍历trie时，对遍历路径上的每个结点都需要copy一次，故而我们的代码具体是如下实现的：</p>
<p>首先，利用<code>TrieNode::Clone()</code>方法来创造一个非const指针的新root：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in trie.h  TrieNode&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Clone</span><span class="params">()</span> <span class="type">const</span> -&gt; std::unique_ptr&lt;TrieNode&gt; </span>&#123; <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;TrieNode&gt;(children_); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创造新的根节点，并且为非const类型</span></span><br><span class="line">std::shared_ptr&lt;TrieNode&gt; root = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(root_-&gt;<span class="built_in">Clone</span>());</span><br><span class="line"><span class="comment">// 使用t指针来遍历trie树</span></span><br><span class="line">std::shared_ptr&lt;TrieNode&gt; t = root;</span><br></pre></td></tr></table></figure>

<p>再然后，每次迭代的时候在遍历路径上创造新的结点，结点类型非const；再利用shared_ptr的共享复制（<code> t = tmp;</code>），就能使得当前的t指针一直保持非const状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; key.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">auto</span> it = t-&gt;children_.<span class="built_in">find</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">  <span class="keyword">if</span> (it == t-&gt;children_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="function">std::shared_ptr&lt;TrieNode&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">new</span> TrieNode())</span></span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      t = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::shared_ptr&lt;TrieNodeWithValue&lt;T&gt;&gt; <span class="built_in">tmp</span>(<span class="keyword">new</span> <span class="built_in">TrieNodeWithValue</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value))));</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      t = tmp;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      std::shared_ptr&lt;TrieNodeWithValue&lt;T&gt;&gt; node =</span><br><span class="line">          std::make_shared&lt;TrieNodeWithValue&lt;T&gt;&gt;(it-&gt;second-&gt;children_, std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value)));</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      t = node;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::shared_ptr&lt;TrieNode&gt; node = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(it-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    t = node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：我本来的写法是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; key.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">auto</span> it = t-&gt;children_.<span class="built_in">find</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">  <span class="keyword">if</span> (it == t-&gt;children_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="function">std::shared_ptr&lt;TrieNode&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">new</span> TrieNode())</span></span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::shared_ptr&lt;TrieNodeWithValue&lt;T&gt;&gt; <span class="built_in">tmp</span>(<span class="keyword">new</span> <span class="built_in">TrieNodeWithValue</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value))));</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      std::shared_ptr&lt;TrieNodeWithValue&lt;T&gt;&gt; node =</span><br><span class="line">          std::make_shared&lt;TrieNodeWithValue&lt;T&gt;&gt;(it-&gt;second-&gt;children_, std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value)));</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::shared_ptr&lt;TrieNode&gt; node = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(it-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  it = t-&gt;children_.<span class="built_in">find</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">  t = it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是为了省事，将t指针的转移集中放在了循环体最后进行。但这样是不行的。</p>
<p>cpp中，可以将非const对象自然转移为const对象，比如代码中就将非const的新结点放进了<code>children_</code>中；但是不允许将const对象自然转移为非const对象，比如代码中的<code>t = it-&gt;second;</code>。因而，我们对t指针的转移不能在新结点放入其<code>children_</code>之后。</p>
</blockquote>
<blockquote>
<p>注2：在这里，我本来还多用了一个prev指针，因为在coding的时候用的是上面的本来的写法，误以为t指针只能是const，所以还得有父节点才能再把t指针复制一遍。但其实并非如此，而且就算如此prev指针也还是跟t指针一样的const的。。。不过还好编译前发现了上面那点改过来了，要不然就得面对编译大报错2333</p>
</blockquote>
<h5 id="make-shared"><a href="#make-shared" class="headerlink" title="make_shared"></a>make_shared</h5><p><code>make_shared</code>作用也类似于new，会在堆上开辟空间用以存放共享指针的base对象。这也让我想起来我在做上面那个实验时一个地方改成<code>make_shared</code>就对了，估计是犯了用栈中对象创建共享指针的错误。</p>
<blockquote>
<p>官方鼓励用<code>make_shared</code>函数来创建对象，而不要手动去new。这一是因为，new出来的类型是原始指针，<code>make_shared</code>可以防止我们去使用原始指针创建多个引用计数体系；二是因为，<code>make_shared</code>可以防止内存碎片化。</p>
</blockquote>
<h5 id="一个奇妙的报错"><a href="#一个奇妙的报错" class="headerlink" title="一个奇妙的报错"></a>一个奇妙的报错</h5><p>在写这样的shared_ptr的共享转移时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;TrieNode&gt; tmp = <span class="built_in">make_shared</span>&lt;TrieNode&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">t = tmp;</span><br></pre></td></tr></table></figure>

<p>会在<code>t=tmp</code>这里报错不能把int类型的tmp复制给t。我看了半天很奇怪哪来的int类型，查了半天怎么共享shared_ptr，最后才发现是因为这里：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">make_shared</span>&lt;TrieNode&gt;()</span><br></pre></td></tr></table></figure>

<p>漏了个<code>std::</code>呃呃。</p>
<h5 id="显式保存is-value-node"><a href="#显式保存is-value-node" class="headerlink" title="显式保存is_value_node_"></a>显式保存is_value_node_</h5><p>在<code>trie.cpp RemoveHelper()</code>中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i != key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意此处需要保留原来的is_value_node_，之后再赋值回去！！！</span></span><br><span class="line">    <span class="type">bool</span> tmp_val = node-&gt;second-&gt;is_value_node_;</span><br><span class="line">    std::shared_ptr&lt;TrieNode&gt; tmp = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(node-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">    tmp-&gt;is_value_node_ = tmp_val;</span><br><span class="line">    </span><br><span class="line">    root-&gt;children_.<span class="built_in">erase</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">    root-&gt;children_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key.<span class="built_in">at</span>(i), tmp));</span><br><span class="line">    flag = <span class="built_in">RemoveHelper</span>(tmp, key, i + <span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>否则会：</p>
<p><img src="/2023/03/13/cmu15445/image-20230323114435061.png" alt="image-20230323114435061"></p>
<p>查看<code>trie_test.cpp</code>的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(TrieTest, BasicRemoveTest2) &#123;</span><br><span class="line">  <span class="keyword">auto</span> trie = <span class="built_in">Trie</span>();</span><br><span class="line">  <span class="comment">// Put something</span></span><br><span class="line">  trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;test&quot;</span>, <span class="number">2333</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(*trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;test&quot;</span>), <span class="number">2333</span>);</span><br><span class="line">  trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;te&quot;</span>, <span class="number">23</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(*trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;te&quot;</span>), <span class="number">23</span>);</span><br><span class="line">  trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;tes&quot;</span>, <span class="number">233</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(*trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;tes&quot;</span>), <span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete something</span></span><br><span class="line">  trie = trie.<span class="built_in">Remove</span>(<span class="string">&quot;te&quot;</span>);</span><br><span class="line">  trie = trie.<span class="built_in">Remove</span>(<span class="string">&quot;tes&quot;</span>);</span><br><span class="line">  trie = trie.<span class="built_in">Remove</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;te&quot;</span>), <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;tes&quot;</span>), <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;test&quot;</span>), <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它是在<code>ASSERT_EQ(trie.Get&lt;uint32_t&gt;(&quot;te&quot;), nullptr);</code>这句报错的。这确实很奇怪，因为“te”已经被remove了。这是为什么呢？</p>
<p>经过gdb调试，trie的Remove和Put功能都确实很正常，但是我发现了一个诡异的现象。</p>
<p>在经过<code>trie = trie.Remove(&quot;te&quot;);</code>这句话后，trie的状态是t-e-(s)-(t)【括号表示为有值结点，类型为<code>TireNodeWithValue</code>】，符合预期。但是，经过紧随其后的<code>trie = trie.Remove(&quot;tes&quot;);</code>之后，trie的状态却变成了t-(e)-s-(t)。</p>
<p><img src="/2023/03/13/cmu15445/image-20230323115902073.png" alt="image-20230323115902073"></p>
<p>这实在是很诡异，为什么经过了一次Remove之后，<code>trie = trie.Remove(&quot;te&quot;);</code>这句话的效果就被重置了？</p>
<p>我想了挺久，最终认为这是构造方法的问题。</p>
<p>再次看一遍我们的Remove的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i != key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    std::shared_ptr&lt;TrieNode&gt; tmp = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(node-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">    </span><br><span class="line">    root-&gt;children_.<span class="built_in">erase</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">    root-&gt;children_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key.<span class="built_in">at</span>(i), tmp));</span><br><span class="line">    flag = <span class="built_in">RemoveHelper</span>(tmp, key, i + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;second-&gt;is_value_node_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!node-&gt;second-&gt;children_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::shared_ptr&lt;TrieNode&gt; tmp = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(node-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">        tmp-&gt;is_value_node_ = <span class="literal">false</span>;</span><br><span class="line">        root-&gt;children_.<span class="built_in">erase</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">        root-&gt;children_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key.<span class="built_in">at</span>(i), tmp));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;children_.<span class="built_in">erase</span>(key.<span class="built_in">at</span>(i));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及<code>TrieNodeWithValue::Clone()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Clone</span><span class="params">()</span> <span class="type">const</span> -&gt; std::unique_ptr&lt;TrieNode&gt; <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::make_unique&lt;TrieNodeWithValue&lt;T&gt;&gt;(children_, value_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及Clone()方法调用的<code>TrieNodeWithValue</code>的构造方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TrieNodeWithValue</span><span class="params">(std::shared_ptr&lt;T&gt; value)</span> : value_(std::move(value)) &#123;</span> <span class="keyword">this</span>-&gt;is_value_node_ = <span class="literal">true</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，在多态作用下，e结点始终是一个<code>TrieNodeWithValue</code>的结点。</p>
<p>在我们去除tes这个key时，会到这个分支：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i != key.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    std::shared_ptr&lt;TrieNode&gt; tmp = std::<span class="built_in">shared_ptr</span>&lt;TrieNode&gt;(node-&gt;second-&gt;<span class="built_in">Clone</span>());</span><br></pre></td></tr></table></figure>

<p>Clone()中会调用<code>node-&gt;second</code>，也即e结点的构造方法，然后将e结点的<code>is_value_node_</code>设置为true，从而导致<code>Get</code>中无法通过这句代码返回nullptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(t-&gt;is_value_node_)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因而，为了解决这个问题，我们就需要暂存<code>is_value_node_</code>，并在之后恢复它。</p>
<h3 id="Task2-concurrency"><a href="#Task2-concurrency" class="headerlink" title="Task2  concurrency"></a>Task2  concurrency</h3><blockquote>
<p>In this task, you will need to modify <code>trie_store.h</code> and <code>trie_store.cpp</code>.需要实现并发安全版本。</p>
<p>For the original Trie class, everytime we modify the trie, we need to get the new root to access the new content. But for the concurrent key-value store, the <code>put</code> and <code>delete</code> methods <strong>do not</strong> have a return value. This requires you to use concurrency primitives to synchronize reads and writes so that no data is lost through the process.在并发安全版本中，<code>Put</code>和<code>Get</code>不会返回trie，而是应该修改包装类的base trie。</p>
<p>Your concurrent key-value store should concurrently serve <strong>multiple readers and a single writer</strong>. That is to say, when someone is modifying the trie, reads can still be performed on the <u>old root</u>. When someone is reading, writes can still be performed without waiting for reads.同一时刻可以有一个writer和多个reader。</p>
<p>Also, if we get a reference to a value from the trie, we should be able to access it no matter how we modify the trie. The <code>Get</code> function from <code>Trie</code> only returns a pointer. If the trie node storing this value has been removed, the pointer will be dangling. Therefore, in <code>TrieStore</code>, we return a <code>ValueGuard</code> which stores both a reference to the value and the TrieNode corresponding to the root of the trie structure, so that the value can be accessed as we store the <code>ValueGuard</code>.为我们提供了 <code>ValueGuard</code>用以确保return值长时间有效。</p>
<p>To achieve this, we have provided you with the pseudo code for <code>TrieStore::Get</code> in <code>trie_store.cpp</code>. Please read it carefully and think of how to implement <code>TrieStore::Put</code> and <code>TrieStore::Remove</code>.我们在<code>Get</code>方法中给出了详细的步骤引导。你需要依据它来对<code>Put</code>和<code>Get</code>进行修改。</p>
</blockquote>
<h4 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h4><p>task2的内容是实现cow-trie并发安全版本的包装类<code>TrieStore</code>。</p>
<p>相比于fall2022的并发内容，由于加上了cow的特性，本次实验更加复杂。我写了三版都没写对，看到别人的才豁然开朗（很遗憾没有自己再多想会儿……）接下来就从我的错误版本开始，逐步过渡到正确版本吧。</p>
<h4 id="错误集锦-2"><a href="#错误集锦-2" class="headerlink" title="错误集锦"></a>错误集锦</h4><h5 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h5><p><code>Get</code>的实现很简单，按他说的一步步做就行，在这边不做赘述。<code>Put</code>和<code>Remove</code>思路差不多，在此只放<code>Put</code>的代码。</p>
<p><img src="/2023/03/13/cmu15445/image-20230321185244067.png" alt="image-20230321185244067"></p>
<p>这样看起来很合理：同一时刻似乎确实只有一个writer对root_进行修改，也似乎确实同时可以有别的线程获取root_lock_对其进行读取。但其实，前者是错误的。</p>
<p>假如说进程A和进程B都在<code>Put</code>逻辑中。进程A执行到了<code>root_ = new_trie</code>这句话，然后进程B进入到<code>root_.Put</code>中。</p>
<p><code>root_ = new_trie</code>使用了运算符=的默认实现，进行浅拷贝，故而会修改<code>root_-&gt;root_</code>；<code>root_.Put</code>中会对<code>root_-&gt;root_</code>进行移动。</p>
<p>进程B在Put中执行<code>std::move(root_)</code>之后，进程A又让<code>root_-&gt;root_</code>变成了别的值（trie浅拷贝），导致原来的root_的引用计数变为0，自动释放（因为是智能指针shared_ptr），进程B在Put中再次访问就会寄。</p>
<blockquote>
<p>注，此处是因为智能指针引用计数为零才释放的，cpp没有垃圾回收机制。</p>
</blockquote>
<h5 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Put</span><span class="params">(std::string_view key, T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line">  root_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  Trie tmp = root_;</span><br><span class="line">  root_lock_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  write_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  Trie new_trie = tmp.<span class="built_in">Put</span>(key, std::<span class="built_in">move</span>(value));</span><br><span class="line">  write_lock_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  root_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  root_ = new_trie;</span><br><span class="line">  root_lock_.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>版本1错误后，我发现我并没有按它强调的“somehow similar to Get”那样，模仿<code>Get</code>中的写法来做。于是我就修改了下，版本2诞生了。</p>
<p>但是这样的话，依然不能解决版本1中的问题。所以我又搞了个版本3.</p>
<h5 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Put</span><span class="params">(std::string_view key, T value)</span> </span>&#123;</span><br><span class="line">  write_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  Trie tmp = root_;</span><br><span class="line">  Trie new_trie = tmp.<span class="built_in">Put</span>(key, std::<span class="built_in">move</span>(value));</span><br><span class="line">  root_ = new_trie;</span><br><span class="line">  write_lock_.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能通过所有测试了。</p>
<p>但这样做虽然能解决多个writer的争夺问题，但不能解决一个writer和一个reader的争夺问题：因为两者都争夺同一个root_变量，但只有reader争夺root_lock_，这显然很不安全。因而，终极版本应该是这样：</p>
<h5 id="正确版本"><a href="#正确版本" class="headerlink" title="正确版本"></a>正确版本</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Put</span><span class="params">(std::string_view key, T value)</span> </span>&#123;</span><br><span class="line">  write_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  root_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  Trie tmp = root_;</span><br><span class="line">  root_lock_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  Trie new_trie = tmp.<span class="built_in">Put</span>(key, std::<span class="built_in">move</span>(value));</span><br><span class="line"></span><br><span class="line">  root_lock_.<span class="built_in">lock</span>();</span><br><span class="line">  root_ = new_trie;</span><br><span class="line">  root_lock_.<span class="built_in">unlock</span>();</span><br><span class="line">  write_lock_.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到整个思维过程是线性的，逐步改进下来，正确答案其实很容易想到。只可惜我太浮躁了，没有静下心来好好想，在版本3之后就去看了眼别人怎么写的（罪过）没有独立思考，算是一个小遗憾。</p>
<h3 id="Task3-debugging"><a href="#Task3-debugging" class="headerlink" title="Task3  debugging"></a>Task3  debugging</h3><h4 id="感想-3"><a href="#感想-3" class="headerlink" title="感想"></a>感想</h4><p>一个考查我们debug入门技巧的小任务，简单，但我觉得形势很新颖。</p>
<h4 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h4><p>随便贴点debug过程的截图。</p>
<p><img src="/2023/03/13/cmu15445/image-20230322221526353.png" alt="image-20230322221526353"></p>
<p><img src="/2023/03/13/cmu15445/image-20230322221634506.png" alt="image-20230322221634506"></p>
<p><img src="/2023/03/13/cmu15445/image-20230322221716462.png" alt="image-20230322221716462"></p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><h5 id="gdb：Attempt-to-take-address-of-value-not-located-in-memory"><a href="#gdb：Attempt-to-take-address-of-value-not-located-in-memory" class="headerlink" title="gdb：Attempt to take address of value not located in memory."></a>gdb：Attempt to take address of value not located in memory.</h5><p>任务中，需要获取root_的孙子。所以我就这么写了个gdb指令：<code>p root_-&gt;children_.find(&#39;9&#39;)-&gt;second</code>，然后就爆出了标题这个错误。</p>
<p>百度了下看到了这个：</p>
<blockquote>
<p><a href="https://blog.csdn.net/sy4331/article/details/121587271">gdb调试时好用的命令</a></p>
<p><img src="/2023/03/13/cmu15445/image-20230323142137068.png" alt="image-20230323142137068"></p>
</blockquote>
<p>也许是因为我们通过.访问了children_的成员find吧（</p>
<p>总之，我最后是在<code>trie_debug_test</code>添加了这几行代码解决的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Put a breakpoint here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) How many children nodes are there on the root?</span></span><br><span class="line"><span class="comment">// Replace `CASE_1_YOUR_ANSWER` in `trie_answer.h` with the correct answer.</span></span><br><span class="line"><span class="keyword">if</span> (CASE_1_YOUR_ANSWER != <span class="built_in">Case1CorrectAnswer</span>()) &#123;</span><br><span class="line">  <span class="built_in">ASSERT_TRUE</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> it = trie.root_-&gt;children_.<span class="built_in">find</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">// (2) How many children nodes are there on the node of prefix `9`?</span></span><br><span class="line"><span class="comment">// Replace `CASE_2_YOUR_ANSWER` in `trie_answer.h` with the correct answer.</span></span><br><span class="line"><span class="keyword">if</span> (CASE_2_YOUR_ANSWER != <span class="built_in">Case2CorrectAnswer</span>()) &#123;</span><br><span class="line">  <span class="built_in">ASSERT_TRUE</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> val = trie.<span class="built_in">Get</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;93&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; val &lt;&lt; it-&gt;first &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// (3) What&#x27;s the value for `93`?</span></span><br><span class="line"><span class="comment">// Replace `CASE_3_YOUR_ANSWER` in `trie_answer.h` with the correct answer.</span></span><br><span class="line"><span class="keyword">if</span> (CASE_3_YOUR_ANSWER != <span class="built_in">Case3CorrectAnswer</span>()) &#123;</span><br><span class="line">  <span class="built_in">ASSERT_TRUE</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即添加了it和val，以及防止unused报错的cout语句。gdb调试时打印it和val就行。</p>
<h5 id="答案对但是过不了评测"><a href="#答案对但是过不了评测" class="headerlink" title="答案对但是过不了评测"></a>答案对但是过不了评测</h5><blockquote>
<p>来自<a href="https://zhuanlan.zhihu.com/p/613920859">CMU 15445 Project 0 (Spring 2023) 学习记录</a>  </p>
<p>在我本地的环境上，调试三问的答案分别是<code>8 1 42</code>，但该答案无法通过 Grade 平台的评测。发现在 Discord 上有人提出了同样的问题，助教 Alex Chi 给出了解答：</p>
<blockquote>
<p>Alex Chi — 2023/02/15 23:29<br>It is possible that your environment produces different random numbers than the grading environment. In case your environment is producing different set of random numbers than our grader, replace your TrieDebugger test with:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> trie = <span class="built_in">Trie</span>();</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;65&quot;</span>, <span class="number">25</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;61&quot;</span>, <span class="number">65</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;82&quot;</span>, <span class="number">84</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;2&quot;</span>, <span class="number">42</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;16&quot;</span>, <span class="number">67</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;94&quot;</span>, <span class="number">53</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;20&quot;</span>, <span class="number">35</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;3&quot;</span>, <span class="number">57</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;93&quot;</span>, <span class="number">30</span>);</span><br><span class="line">trie = trie.<span class="built_in">Put</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="string">&quot;75&quot;</span>, <span class="number">29</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>难绷，我反复确认了好几遍（。主要还是太相信cmu的权威了，觉得这实验都发布了好几个月了应该不会有错，就没想到是这个问题。我觉得最好还是把这个问题反应在指导书上吧。</p>
<h3 id="Task4-SQL-String-Functions"><a href="#Task4-SQL-String-Functions" class="headerlink" title="Task4  SQL String Functions"></a>Task4  SQL String Functions</h3><blockquote>
<p>Now it is time to dive into BusTub itself! </p>
<p>You will need to implement <code>upper</code> and <code>lower</code> SQL functions. </p>
<p>This can be done in 2 steps: </p>
<ol>
<li>implement the function logic in <code>string_expression.h</code>.</li>
<li>register the function in BusTub, so that the SQL framework can call your function when the user executes a SQL, in <code>plan_func_call.cpp</code>.</li>
</ol>
<p>To test your implementation, you can use <code>bustub-shell</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd build</span><br><span class="line">make -j`nproc` shell</span><br><span class="line">./bin/bustub-shell</span><br><span class="line"><span class="meta prompt_">bustub&gt; </span><span class="language-bash">select upper(<span class="string">&#x27;AbCd&#x27;</span>), lower(<span class="string">&#x27;AbCd&#x27;</span>);</span></span><br><span class="line">ABCD abcd</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="感想-4"><a href="#感想-4" class="headerlink" title="感想"></a>感想</h4><p>说实话乍一看我还没看懂（。它放在这个位置，我还以为跟上面实现的cow-trie有什么关系，并且误以为这个upper和lower是什么上层接口底层接口的意思，跟它大眼瞪小眼了半天。直到看到了下面的案例，才发现跟trie似乎没有任何关系23333</p>
<p>本次实验内容其实就是实现sql的转换大小写的函数。知道了要做什么之后，任务就很简单了，按着它提示一步步做就行。</p>
<p>不过此task重点其实也是在稍微了解下我们接下来要打交道的sql框架的代码。比如说，此次我们的实现涉及到的，居然是一个差不多是工厂模式（其实更像策略模式？）的一部分：</p>
<p>外界传入想调用的函数名，通过<code>GetFuncCallFromFactory</code>获取对应的处理对象</p>
<p><img src="/2023/03/13/cmu15445/image-20230322154915206.png" alt="image-20230322154915206"></p>
<p>得到处理对象后调用其<code>Compute</code>方法就行</p>
<p><img src="/2023/03/13/cmu15445/image-20230322154849449.png" alt="image-20230322154849449"></p>
<p>第一次如此鲜明地看到一个设计模式在cpp的应用，真是让我非常震撼。</p>
<h3 id="代码规范-1"><a href="#代码规范-1" class="headerlink" title="代码规范"></a>代码规范</h3><p>依旧是这三件套：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p0</span><br></pre></td></tr></table></figure>

<h4 id="错误集锦-3"><a href="#错误集锦-3" class="headerlink" title="错误集锦"></a>错误集锦</h4><h5 id="关于sanitizer"><a href="#关于sanitizer" class="headerlink" title="关于sanitizer"></a>关于sanitizer</h5><p>执行了该命令：<code>cmake -DCMAKE_BUILD_TYPE=Debug -DBUSTUB_SANITIZER= ..</code>之后，执行<code>make</code>报错<code>missing argument to &#39;-fsanitize=&#39;</code></p>
<p>发生这个的原因是cmake的命令中将<code>BUSTUB_SANITIZER</code>设置成了空。解决方法就是将其设置为别的值就好了，具体想设置成什么值可以参见：<a href="https://zhuanlan.zhihu.com/p/578225802">关于GCC/LLVM编译器中的sanitize选项用处用法详解</a> 我这里姑且随便设置了个<code>leak</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>Project1   Buffer Pool</title>
    <url>/2023/03/13/cmu15445$lab1/</url>
    <content><![CDATA[<h1 id="Project1-Buffer-Pool"><a href="#Project1-Buffer-Pool" class="headerlink" title="Project1   Buffer Pool"></a>Project1   Buffer Pool</h1><p>先放个通关记录~</p>
<p><img src="/2023/03/13/cmu15445/image-20230330235300907.png" alt="image-20230330235300907"></p>
<blockquote>
<p>特别鸣谢：</p>
<p>某不愿透露姓名的友人hhj</p>
<p><a href="https://zhuanlan.zhihu.com/p/617466684">大佬的实验过程</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/613920859">大佬的性能优化</a></p>
</blockquote>
<blockquote>
<p>During the semester, you will build a <u>disk-oriented</u> storage manager for the <a href="https://github.com/cmu-db/bustub">BusTub</a> DBMS.</p>
<p>注：DBMS(Database Management System)，比如说Oracle数据库</p>
<p>The first programming project is to implement a <strong>buffer pool</strong> in your storage manager.The buffer pool is responsible for <u>moving physical pages back and forth from main memory to disk</u>.也就是负责物理页从磁盘的读写</p>
<p>It allows a DBMS to support databases that are larger than the amount of memory available to the system. 是的，这其实就跟内存换入换出差不多。我们现在是不是要在用户态实现这个功能？我记得xv6似乎是没有这个机制的。有点小期待呀。不过这部分感觉说不定和xv6的磁盘管理（使用双向链表管理buffer cache），及其的改进版本（lab:locking  使用哈希+双向链表）比较类似。</p>
<blockquote>
<p>注：xv6确实没有内存换入换出机制，其是固定大小的内存空间。但xv6的文件系统有采用LRU算法的buffer cache（怪不得有什么数据库型的文件系统，这两个确实有点像）。</p>
</blockquote>
<p>The buffer pool’s operations are transparent to other parts in the system. For example, the system asks the buffer pool for a page using its unique identifier (<code>page_id_t</code>) and it does not know whether that page is already in memory or whether the system has to retrieve it from disk.</p>
<p><strong>Your implementation will need to be thread-safe</strong>. </p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于这几天时间比较零散+事情比较多，因此完成的总时间数不一定值得参考：26h（乐）</p>
<p>本次实验要说简单也还算简单。大概就是实现一个database与磁盘交换页的buffer pool，机制类似于内存换入换出。而实现这个buffer pool，首先得实现换入换出算法，也即task1的LRU-K算法。再然后就是在我们的LRU-K算法的基础上，实现真正的buffer pool（真正指：真正地存储以及读写磁盘、向外暴露接口），也即<code>BufferPoolManager</code>。最后，我们会实现类似于<code>lock_guard</code>这样结构的<code>PageGuard</code>，用于自动释放页引用和读写锁。最后的最后，我们会对实现的buffer pool进行性能优化，优化方向包括细粒度化锁以实现并行IO、针对特定应用场景调整LRU-K策略等。</p>
<p>这四者都是相互联系相互递进的，我认为每一个task都设计得非常不错，写完了之后对它所涉及的知识点都有了更深刻的理解。我认为其中最优美的一点就是<strong>LRU-K算法与buffer pool的解耦</strong>，这个设计让我十分地赞叹。</p>
<p>最后，再对我的完成情况进行一个评价。本次实验确实内容不是很难【除了性能调优部分，这个我是真不懂QAQ】，毕竟它指导书以及代码注释都给了详细的步骤参考，我之所以做了那么久一是因为我有不好的习惯，就是没认真看指导书和提示就开始按着自己的理解写，然后写完就直接开始debug开始交了；二是因为这几天学业的破事太多、竞赛也逐步开始了，因而战线拉得太长，总耗时就太多了。</p>
<p>因而，吸取经验，我之后coding完了之后，再照着指导书仔仔细细地过一遍自己的代码。同时，15445这个实验我也决定先暂时搁置，毕竟接下来这两个月应该会在竞赛和学业两头转，实在不能抽出很大段时间继续写了。</p>
<p>就酱。</p>
<h2 id="Task1-LRU-K"><a href="#Task1-LRU-K" class="headerlink" title="Task1  LRU-K"></a>Task1  LRU-K</h2><blockquote>
<p>This component is responsible for tracking page usage in the buffer pool.</p>
<p>The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. LRU-K 算法驱逐一个帧，其backward k-distance是替换器中所有帧的最大值。</p>
<p>Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access.  <code>backward k-distance</code>=现在的时间戳 - 之前第k次访问时的时间戳</p>
<p>A frame with fewer than k historical accesses is given +inf as its backward k-distance. 不足k次访问的帧的backward k-distance应该设置为inf（对应上图左边那个访问记录队列吧）</p>
<p>**When multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access, overall, out of all frames).**如果有多个inf的结点，按照LRU规则淘汰（也即上图左边那个历史记录队列采取LRU规则）</p>
<p>The maximum size for the <code>LRUKReplacer</code> is the same as the size of the buffer pool since it contains placeholders for all of the frames in the <code>BufferPoolManager</code>. However, at any given moment, not all the frames in the replacer are considered to be evictable. The size of <code>LRUKReplacer</code> is represented by the number of <em>evictable</em> frames. The <code>LRUKReplacer</code> is initialized to have no frames in it. Then, <u>only when a frame is marked as evictable, replacer’s size will increase</u>.   size为可驱逐的frame数而非所有frame数。</p>
</blockquote>
<h3 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h3><p>本次实验要我们实现的是一个LRU-K算法的页面置换器。</p>
<p>LRU-K算法是对LRU算法和LFU算法的折中优化，平衡了LFU和LRU的性能和开销的同时，也解决了缓存污染问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。具体来说，它维护了一个<code>backward k-distance</code>，其计算方法：</p>
<ol>
<li>如果已经被访问过k次：<code> backward k-distance</code> = <code>current_timestamp_</code> - <strong>倒数第k次</strong>访问的时间戳</li>
<li>如果还没被访问过k次：<code> backward k-distance</code> = +inf</li>
</ol>
<p>页面驱逐规则：</p>
<ol>
<li><p>驱逐<code> backward k-distance</code> 最大的页。</p>
<p>也即情况2总是优先会比情况1被驱逐；每次优先驱逐previous k次访问最早的页面。</p>
</li>
<li><p>当有多个页值为+inf，则采取FIFO规则进行驱逐。</p>
</li>
</ol>
<p>故而，在具体实现中，为了便于管理，我将此拆分为两个队列：</p>
<blockquote>
<p>思路来自：<a href="https://blog.csdn.net/zhanglong_4444/article/details/88344953">LRU . LFU 和 LRU-K 的解释与区别</a></p>
<p><img src="/2023/03/13/cmu15445/image-20230323205851168.png" alt="image-20230323205851168"></p>
<ol>
<li><p>数据第一次被访问，加入到访问历史列表；</p>
</li>
<li><p>如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p>
</li>
<li><p>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p>
</li>
<li><p>缓存数据队列中被再次访问后，重新排序；</p>
</li>
<li><p>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p>
</li>
</ol>
</blockquote>
<p>每个页面结构持有一个时间戳队列即可：</p>
<p><img src="/2023/03/13/cmu15445/image-20231128152139485.png" alt="image-20231128152139485"></p>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><h4 id="刚coding完"><a href="#刚coding完" class="headerlink" title="刚coding完"></a>刚coding完</h4><p>task1的内容就是实现对一堆<code>frame_id</code>的LRU-K算法管理，挺简单的（也可能是测试用例少我错误没排查出来2333）</p>
<p>我并没有用默认给的模板的<code>unorder_map</code>，也没有用默认给的模板思路（但原理以及最终效果是差不多的，就是没用它的方法），而是选择类似像上面这张图一样，分成两个队列实现，一个队列<code>visit_record_</code>存储那些访问次数&lt;k的数据，另一个队列<code>cache_data_</code>存储那些访问次数&gt;=k的顺序，每次优先淘汰<code>visit_record_</code>中的数据，<u>两个队列都采用LRU的方式管理。与此同时，我觉得LRU管理时间戳只用记录最新访问的就行，所以将历史访问时间戳队列改成了只有一个变量。</u></p>
<h4 id="终于通过online-test"><a href="#终于通过online-test" class="headerlink" title="终于通过online-test"></a>终于通过online-test</h4><blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/m0_63848007/article/details/125426740">FIFO和LRU</a>这里面的实例非常直观地说明了两种算法的差异，可以跟着手推感受一下</p>
<p><a href="https://blog.csdn.net/Altair_alpha/article/details/127745308">pro1</a>这个用的是我上面的那个想法，是错的。但是评论很值得参考：</p>
<p><img src="/2023/03/13/cmu15445/image-20230329230045194.png" alt="image-20230329230045194"></p>
<p><a href="https://blog.csdn.net/hrbust_cxl/article/details/127138778">pro1</a>这个评论的“偷测试用例”xswl，虽然这次没用，但以后说不定能用上：</p>
<p><img src="/2023/03/13/cmu15445/image-20230329230139300.png" alt="image-20230329230139300"></p>
</blockquote>
<h5 id="正确思路-1"><a href="#正确思路-1" class="headerlink" title="正确思路"></a>正确思路</h5><p>……简单个屁！！</p>
<p>算法上，上面错误的算法确实很简单；而正确的算法也确实很简单。那么难的是什么呢？我觉得难的还是搞清楚它要我们实现的究竟是上面东西。</p>
<p>结合指导书这段话：</p>
<blockquote>
<p>The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. 每次驱逐<code> backward k-distance</code>最大的</p>
<p>那么<code> backward k-distance</code>是什么？</p>
<p>Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. <code> backward k-distance</code> = <code>current_timestamp_</code> - <strong>倒数第k次</strong>访问的时间戳</p>
<p>A frame with fewer than k historical accesses is given +inf as its backward k-distance. 没有达到k次访问的，<code> backward k-distance</code>为+inf。也就是说，每次优先从历史访问队列清除元素。</p>
<p>【**When multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access, overall, out of all frames).**】当历史访问队列有多个元素，就驱逐英文描述那样的frame。</p>
</blockquote>
<p>我们可以发现，它这个对于两个队列的LRU，并非我们原来算法那样，对于每个frame，针对其最新的访问时间戳，也即<code>history_.back()</code>，进行LRU淘汰；而是，针对其倒数第k新的访问记录，也即<code>history_.front() &amp;&amp; history_.size()&lt;=k</code>，进行LRU淘汰。</p>
<p>其中，由于历史访问队列的记录少于k个，<u>因而其事实上从k-distance算法退化为了FIFO算法</u>。【感受一下这一点的优美：FIFO实际上是k-distance的特例】</p>
<p>我们上面的算法比较的是<code>history_.back()</code>，所以可以省略时间戳队列为一个变量，然后将两个队列使用FILO的形式组织起来。正确算法就不能这么简单了，要按front排序的话，实现开销可能更大，所以下面就采用了map形式来实现logn的查找。</p>
<h5 id="关于LRU的翻译"><a href="#关于LRU的翻译" class="headerlink" title="关于LRU的翻译"></a>关于LRU的翻译</h5><p>这里一个点我其实还是很疑惑的，完全想不通。</p>
<p>就是，对缓存队列实现k-distance算法没毛病，这段话已经写得很清楚了。</p>
<blockquote>
<p>Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. <code> backward k-distance</code> = <code>current_timestamp_</code> - <strong>倒数第k次</strong>访问的时间戳</p>
</blockquote>
<p>但是，为什么历史访问队列要用FIFO呢？是我英语不好吗，这段话不是实现纯正LRU的意思吗：</p>
<blockquote>
<p>【**When multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access, overall, out of all frames).**】当历史访问队列有多个元素，就驱逐英文描述那样的frame。</p>
</blockquote>
<p>我翻译一下：</p>
<p>当多个frame有+inf这个<code> backward k-distance</code>的时候，replacer需要驱逐拥有全部（overall）frame中最早的timestamp的frame。（也就是说，frame，它的最近访问记录是所有frame里面最早的）</p>
<p>这样确实看起来就是要用LRU。</p>
<p>但其实，是我英语不好。咨询了场外热心人士hhj之后，我才修订出了如下版本：</p>
<p>当多个frame有+inf这个<code> backward k-distance</code>的时候，replacer需要驱逐拥有全部（overall）frame中最早的timestamp的frame。（也就是说选择一个frame，这个frame的<strong>最不近</strong>的访问记录，是所有frame中最近最少访问的）【也即这个frame的history的front是所有frame中最早的，也即使用FIFO算法】</p>
<p>可见，正确解法确实是没问题的，就是理解上很困难。要是可以配个实例就好了QAQ</p>
<p>所以说，所谓LRU（Least Recently Used）的直译还是最不近使用，也即最近最少使用。里面这个least不是用来修饰recent表示recent程度深的，相反它表示的是recent的程度浅。英语不好的惨痛教训啊。</p>
<p><img src="/2023/03/13/cmu15445/image-20230330160207757.png" alt="image-20230330160207757"></p>
<p>最后一下子交了这么多次才过。绷不住了。</p>
<h2 id="Task2-BufferPoolManager"><a href="#Task2-BufferPoolManager" class="headerlink" title="Task2   BufferPoolManager"></a>Task2   BufferPoolManager</h2><blockquote>
<p>The <code>BufferPoolManager</code> is responsible for fetching database pages from the <code>DiskManager</code> and storing them in memory.从DiskManager中取出页，然后存入内存。</p>
<p>也就是说，我们的Buffer Pool是磁盘到内存的映射，我们在Task1实现了内存部分的管理数据结构？</p>
<p>The <code>BufferPoolManager</code> can also write dirty pages out to disk when it is either explicitly instructed to do so or when it needs to evict a page to make space for a new page.也要负责dirty页的写回</p>
<p>You will also not need to implement the code that actually reads and writes data to disk (this is called the <code>DiskManager</code> in our implementation). We will provide that functionality. <code>DiskManager</code>已给出</p>
<p>All in-memory pages in the system are represented by <code>Page</code> objects.  Each <code>Page</code> object contains a block of memory that the <code>DiskManager</code> will use as a location to copy the contents of a <strong>physical page</strong> that it reads from disk. <code>Page</code> 是可复用的内存页容器</p>
<p>The <code>Page</code> object’s identifer (<code>page_id</code>) keeps track of what physical page it contains; if a <code>Page</code> object does not contain a physical page, then its <code>page_id</code> must be set to <code>INVALID_PAGE_ID</code>.</p>
<p>也就是说，<code>page_id</code>表示的是实际的物理页号；<code>frame_id</code>表示的是你的Page容器的序号，同时也是LRU的对象。你需要一个类似<code>&lt;fid, pid&gt;</code>这样的map来记录这二者的映射。具体是通过：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Array of buffer pool pages. */</span></span><br><span class="line">Page *pages_; <span class="comment">// &lt;fid, pid&gt;</span></span><br><span class="line"><span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_; <span class="comment">// &lt;pid, fid&gt;</span></span><br></pre></td></tr></table></figure>

<p>Each <code>Page</code> object also maintains a counter for the number of threads that have “pinned” that page. Your <code>BufferPoolManager</code> is not allowed to free a <code>Page</code> that is pinned. 有引用计数机制</p>
<p>Each <code>Page</code> object also keeps track of whether it is dirty or not. It is your job to record whether a page was modified before it is unpinned.  Your <code>BufferPoolManager</code> must write the contents of a dirty <code>Page</code> back to disk before that object can be reused.需要track dirty，并且这是你要干的；要写回，这也是你要干的</p>
<p>Your <code>BufferPoolManager</code> implementation will use the <code>LRUKReplacer</code> class that you created in the previous steps of this assignment. The <code>LRUKReplacer</code> will keep track of when <code>Page</code> objects are accessed so that it can decide which one to evict when it must free a frame to make room for copying a new physical page from disk. When mapping <code>page_id</code> to <code>frame_id</code> in the <code>BufferPoolManager</code>, again be warned that STL containers are not thread-safe.</p>
</blockquote>
<h3 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h3><h4 id="刚coding完-1"><a href="#刚coding完-1" class="headerlink" title="刚coding完"></a>刚coding完</h4><p>task2说得比较复杂，实现的函数较多，实际coding细节也比较繁琐，但debug倒是很轻松。</p>
<p>主要内容就是实现<code>BufferPoolManager</code>，在task1实现的LRU-K算法的基础上，写具体的内存换入换出的接口逻辑。</p>
<p>再次回顾我们整个project1的目的：实现一个从磁盘到内存的buffer。task1只是实现了一个内存页换入换出的LRU-K算法部分，task2则基于算法部分，实现了具体与上层交互的像样的逻辑。</p>
<p>我认为这其中一个亮点就是，它非常完美地将LRU-K算法和具体的上层逻辑进行了<strong>解耦</strong>。LRU-K只需关注如何将这一堆<code>freme_id</code>组织起来组织好，而无需关心具体内存页存放在哪，以及对应frame淘汰之后内存页又何去何从，因为这些逻辑都会由上层实现；而上层逻辑也无需关心具体的淘汰页算法【LRU-K/LRU/LFU，只需替换replacer_就可以替换换入换出策略】，而只需打好evictable标记，并且在调用evict方法之后做好后处理（如内存释放等等等）即可。</p>
<p>这其中有一个小细节也值得借鉴，即从<code>page_id_</code>到<code>frame_id_</code>的转化。<code>frame_id_</code>有界，比较方便LRU-K算法实现，并且进行了LRU-K算法的容量控制，同时由于算法和上层逻辑的容量相同，故而也是<code>pages_</code>的索引号；而<code>page_id_</code>不能有界，因为实际上访问到的物理页不可能只共享<code>pool_size_</code>个序列号。故而在这样解耦实现的基础上，二者缺一不可。</p>
<p>还有<code>frame_id_</code>的复用，它是采用了类似我们日常生活中取号那样，要用号时从队列头取，不用号时塞回队列尾就行，这种方式我觉得还挺有意思。</p>
<p>其他部分虽然步骤繁杂，但理解难度不高，而且它提示得也很保姆了，所以不多bb。</p>
<h4 id="通过online-test"><a href="#通过online-test" class="headerlink" title="通过online-test"></a>通过online-test</h4><p>确实算简单了，我主要倒在没有认真看它的需求，这应该是语文问题（绷</p>
<p>一个是<code>FetchPage</code>这里：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330162812680.png" alt="image-20230330162812680"></p>
<p>如果所求物理页存在于buffer pool，直接返回+record access即可，不用再写回+读入。因为它的提示这边：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330162941774.png" alt="image-20230330162941774"></p>
<p>这个是句号。也就是说后面那些写回啊read啊，是没找到时才做的，不是并列关系。</p>
<p>这也很合理，毕竟你找到所需页就说明不用从磁盘读入，也即找到所需页=直接返回即可。</p>
<p>另一个是<code>UnpinPage</code>这里：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330163031739.png" alt="image-20230330163031739"></p>
<p>不应该写<code>is_dirty_ = is_dirty</code>，因为它的提示这边：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330163058921.png" alt="image-20230330163058921"></p>
<p>可见参数<code>is_dirty</code>为true是需要设置为dirty，为false的话没有别的意义，保持原来值就行。</p>
<p>还有一个就是，在<code>Page</code>类中声明了friend：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330163337929.png" alt="image-20230330163337929"></p>
<p>故而<code>BufferPoolManager</code>可以直接访问<code>Page</code>的私有成员变量，而无需手动为<code>Page</code>添加Getter/Setter方法。</p>
<h2 id="Task3-Page-Guard"><a href="#Task3-Page-Guard" class="headerlink" title="Task3   Page Guard"></a>Task3   Page Guard</h2><p>这是要写我们在上面用的那个PageGuard？这让我想起了Lab0的<code>ValueGuard</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValueGuard</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ValueGuard</span>(Trie root, <span class="type">const</span> T &amp;value) : <span class="built_in">root_</span>(std::<span class="built_in">move</span>(root)), <span class="built_in">value_</span>(value) &#123;&#125;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>*() <span class="type">const</span> -&gt; <span class="type">const</span> T &amp; &#123; <span class="keyword">return</span> value_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Trie root_;</span><br><span class="line">  <span class="type">const</span> T &amp;value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不过其实这两个是不一样的。本次要实现的Page Guard的语义更类似<code>lock_guard</code>。</p>
<blockquote>
<p>我们需要手动调用<code>UnpinPage</code>，但这中就跟new/delete、malloc/free一样都要靠人脑来记住，不大安全。</p>
<p>You will implement <code>BasicPageGuard</code> which store the pointers to <code>BufferPoolManager</code> and <code>Page</code> objects. <u>A page guard ensures that <code>UnpinPage</code> is called on the corresponding <code>Page</code> object as soon as it goes out of scope.</u> 【也许这需要在析构函数中实现？】Note that it should <strong>still</strong> expose a method for a programmer to manually unpin the page.仍然需要提供UnPin方法。</p>
<p>As <code>BasicPageGuard</code> hides the underlying <code>Page</code> pointer, it can also provide read-only/write data APIs that provide <strong>compile-time checks</strong> to ensure that the <code>is_dirty</code> flag is set correctly for each use case.这个思想很值得学习。</p>
<p>In the future projects, multiple threads will be reading and writing from the same pages, thus reader-writer latches are required to ensure the correctness of the data. Note that in the <code>Page</code> class, there are relevant latching methods for this purpose. Similar to unpinning of a page, a programmer can forget to unlatch a page after use. To mitigate the problem, you will implement <code>ReadPageGuard</code> and <code>WritePageGuard</code> which automatically unlatch the pages as soon as they go out of scope.</p>
</blockquote>
<h3 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h3><p>怎么说，其实只用仔细看相关文档和它的要求就不难，但你懂的我的尿性就是不细看文档，所以这里我也用gdb调了蛮久才过的。正确思路没什么好说的，直接记录下我觉得比较有意义的错误吧。</p>
<h4 id="错误集锦"><a href="#错误集锦" class="headerlink" title="错误集锦"></a>错误集锦</h4><h5 id="析构函数的调用"><a href="#析构函数的调用" class="headerlink" title="析构函数的调用"></a>析构函数的调用</h5><p><img src="/2023/03/13/cmu15445/image-20230330233252372.png" alt="image-20230330233252372"></p>
<p>在这个用例中，退出“}”会调用两次析构函数。</p>
<h5 id="奇怪的死锁"><a href="#奇怪的死锁" class="headerlink" title="奇怪的死锁"></a>奇怪的死锁</h5><h6 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h6><p>我在coding的过程中，遇到了一个很神奇的死锁现象。</p>
<p>在这里<code>page-&gt;WLatch();</code>这句会死锁，而且还是在第一次调用<code>FetchWritePage()</code>时死锁的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WritePageGuard</span>(BufferPoolManager *bpm, Page *page) : <span class="built_in">guard_</span>(bpm, page) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是添加了一句<code>page-&gt;WUnlatch();</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WritePageGuard</span>(BufferPoolManager *bpm, Page *page) : <span class="built_in">guard_</span>(bpm, page) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它就不会死锁了。</p>
<p>这很奇怪，到底是发生了什么？我用GDB调了半天，在<code>RWLatch.WLock()</code>处打了断点，也没发现在这之前有调用过lock()。于是我就去看了下<code>std::shared_mutex</code>的官方文档（当然，这中间想了很久也不知道怎么办）：</p>
<p><img src="/2023/03/13/cmu15445/image-20230331222601644.png" alt="image-20230331222601644"></p>
<p>我就怀疑是不是我哪里写错了，所以就干了这种undefined的事，然后就导致死锁了。于是我写了个测试程序：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330195418370.png" alt="image-20230330195418370"></p>
<p>发现，当在调用<code>WLock</code>（也即<code>std::shared_mutex::lock()</code>）之前，如果多调了一次<code>XUnlock</code>（也即<code>std::shared_mutex::unlock()</code>或者<code>std::shared_mutex::unlock_shared()</code>），就会卡住。</p>
<p>这说明确实发生了不匹配问题。于是我就在<code>Page</code>中添加了两个成员变量用来记录上锁和解锁的次数，并且在gurad test中打印了出来，结果发现：</p>
<p><img src="/2023/03/13/cmu15445/image-20230330233018049.png" alt="image-20230330233018049"></p>
<p>确实发生了不匹配问题，是在这里:</p>
<p><img src="/2023/03/13/cmu15445/image-20230330233252372.png" alt="image-20230330233252372"></p>
<p>之后用gdb调下就发现错误了，不赘述了。</p>
<h6 id="另外的想法"><a href="#另外的想法" class="headerlink" title="另外的想法"></a>另外的想法</h6><p>在出现死锁问题时，我是想着，会不会是测试程序中，对同一页获取了一次<code>ReadGuardPage</code>对象之后，再对同一页获取<code>Read/WriteGuardPage</code>导致的呢？于是我就开始思考如何防范这个流程，最后写下了这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageRead</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; ReadPageGuard </span>&#123;</span><br><span class="line">  Page *page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="type">bool</span> should_release = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!page-&gt;rwlatch_.<span class="built_in">try_lock_shared</span>()) &#123;</span><br><span class="line">    <span class="comment">// 说明此时已有read/write锁</span></span><br><span class="line">    should_release = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, pagei, should_release&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageWrite</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; WritePageGuard </span>&#123;</span><br><span class="line">  Page *page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="type">bool</span> should_release = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!page-&gt;rwlatch_.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">    <span class="comment">// 获取write锁失败，可能原因：该进程持有write锁、别的进程有read锁、该进程持有read锁</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;rwlatch_.<span class="built_in">try_lock_shared</span>()) &#123;</span><br><span class="line">      <span class="comment">// 成功read，说明是别的进程有read锁</span></span><br><span class="line">      page-&gt;rwlatch_.<span class="built_in">unlock_shared</span>();</span><br><span class="line">      <span class="comment">// 等待</span></span><br><span class="line">      page-&gt;rwlatch_.<span class="built_in">lock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 说明当前进程有read/write锁</span></span><br><span class="line">      should_release = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, pagei, should_release&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但很遗憾的是，我发现是无法区分当前进程持有write还是read锁的。也许有别的办法但我没想起来。</p>
<p>总之，我认为这段代码还是很有参考价值的，姑且放着先。</p>
<h2 id="Task4-性能调优"><a href="#Task4-性能调优" class="headerlink" title="Task4   性能调优"></a>Task4   性能调优</h2><blockquote>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/644160340">CMU 15-445 2023 P1 优化攻略 [rank#3]</a>  写得非常细致，思路很清晰</p>
<p> <a href="https://zhuanlan.zhihu.com/p/617466684">CMU 15-445 Project 1 (Spring 2023) 优化记录</a></p>
</blockquote>
<blockquote>
<p>我的实现有一些并发小问题，详见lab2的并发部分~</p>
</blockquote>
<p>lru-k的算法优化是自己想的，并行IO的优化思路全部来自 <a href="https://zhuanlan.zhihu.com/p/617466684">CMU 15-445 Project 1 (Spring 2023) 优化记录</a>，我只是把这位大佬的思路自己实现了一遍。感觉还是太菜了，面对这种实际场景毫无还手之力一点思路没有QAQ但正是如此，这个细粒度化锁的小task才值得学习。</p>
<p>放上优化前后性能对比：</p>
<p><img src="/2023/03/13/cmu15445/image-20230331000020775.png" alt="image-20230331000020775"></p>
<p><img src="/2023/03/13/cmu15445/image-20230404140838247.png" alt="image-20230404140838247"></p>
<h3 id="Better-replacer-algorithm"><a href="#Better-replacer-algorithm" class="headerlink" title="Better replacer algorithm"></a>Better replacer algorithm</h3><blockquote>
<p>In the leaderboard test, we will have multiple threads accessing the pages on the disk. There are two types of threads running in the benchmark:在具体的benchtest中，可以分为两类线程。</p>
<ol>
<li>Scan threads. Each scan thread will update all pages on the disk <u>sequentially</u>. There will be 8 scan threads.</li>
<li>Get threads. Each get thread will randomly select a page for access using the <a href="https://en.wikipedia.org/wiki/Zipf's_law">zipfian distribution</a>. There will be 8 get threads.</li>
</ol>
<p>Given that get workload is skewed（有偏向性的）(i.e., some pages are more frequently accessed than others), you can design your LRU-k replacer to <u>take page access type into consideration</u>, so as to reduce page miss.</p>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>我们可以回想起当初选择LRU-K而不选择LRU算法的原因：缓存污染。</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_43237362/article/details/121619601">LRU 一种缓存淘汰算法</a></p>
<p>缓存污染：</p>
<p>LRU因为只需要一次访问就能成为最新鲜的数据，当出现很多偶发数据时，这些偶发的数据也会被当作最新鲜的，从而成为缓存。但其实这些偶发数据以后并不会是被经常访问的。</p>
</blockquote>
<p>而在这里也是同理。我们的benchtest中，scan线程是顺序地访问磁盘上所有页，而get线程是遵从zip分布地访问，显然get线程的access记录比scan线程的有价值的多，并且scan线程的数据是很容易污染get线程的。</p>
<p>所以，我的解决方法是，如果某个页被第一次访问，且该访问方式为SCAN，则RecordAccess进入历史访问队列；如果某个页不是被第一次访问，且访问方式为SCAN，则不做任何处理。不用修改UnpinPage的处理方式。</p>
<h3 id="Parallel-I-O-operations"><a href="#Parallel-I-O-operations" class="headerlink" title="Parallel I/O operations"></a>Parallel I/O operations</h3><blockquote>
<p>Instead of holding a global lock when accessing the disk manager【不要在访问<code>disk_manager_</code>的时候使用bpm的全局锁<code>latch_</code>】, you can issue multiple requests to the disk manager at the same time. This optimization will be very useful in modern storage devices, where concurrent access to the disk can make better use of the disk bandwidth.</p>
</blockquote>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>详细的解决方法<a href="https://zhuanlan.zhihu.com/p/617466684">大佬</a>这边已经说得很清楚了，接下来我就对其总体的做法进行一点总结，加上一些个人理解。</p>
<p>我刚看到这个需求的时候是这么做的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pages_[fid].<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[fid].<span class="built_in">GetPageId</span>(), pages_[fid].<span class="built_in">GetData</span>());</span><br><span class="line">    latch_.<span class="built_in">lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即在原来代码的基础上做简单的改动，每次执行到涉及磁盘读写的地方，就暂时地开一下锁。但其实这样是不行的，当多个线程访问bpm，线程A在这里开锁执行Write，线程B正好得到锁，然后对<code>pages_[fid]</code>执行比如说ResetMemory操作，这样就寄了。</p>
<p>所以，在磁盘读写的时候，我们仍然需要使用锁保护，只不过我们需要选择粒度更细的锁。这时我们就可以想到在<code>page_guard</code>里常用的page自带的锁。在这里用page锁，既能够锁保护，又符合语义，看起来非常完美：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pages_[fid].<span class="built_in">WLatch</span>();</span><br><span class="line">latch_.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">if</span> (pages_[fid].<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[fid].<span class="built_in">GetPageId</span>(), pages_[fid].<span class="built_in">GetData</span>());</span><br><span class="line">&#125;</span><br><span class="line">latch_.<span class="built_in">lock</span>();</span><br><span class="line">pages_[fid].<span class="built_in">WUnlatch</span>();</span><br></pre></td></tr></table></figure>

<p>但由于我们在return<code>page_guard</code>的时候会获取锁，因而在这样的情况下，会发生死锁：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> reader_guard_1 = bpm-&gt;<span class="built_in">FetchPageRead</span>(page_id_temp);</span><br><span class="line"><span class="keyword">auto</span> reader_guard_2 = bpm-&gt;<span class="built_in">FetchPageRead</span>(page_id_temp);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里我们首先获取<code>reader_guard_1</code> ，持有了该 page 的读锁，并允许其他线程读；但在获取<code>reader_guard_2</code>时，<code>FetchPage</code>会在释放 bpm 写锁前，请求该 page 的写锁；但由于<code>reader_guard_1</code>已经申请了该 page 的读锁，就会造成死锁，与预期结果不符。</p>
</blockquote>
<p>因而，我们就可以选择在bpm内部，单独为pages_数组的每一页都维护一个锁，在每个对page页属性进行读写的地方进行锁定：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_mutex latch_;</span><br><span class="line">std::vector&lt;std::mutex&gt; pages_latch_;</span><br></pre></td></tr></table></figure>

<p>然后对代码进行重排序，尽量分离bpm内部成员和page内部成员属性的修改：（以<code>FetchPage</code>为例）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPage</span><span class="params">(<span class="type">page_id_t</span> page_id, [[maybe_unused]] AccessType access_type)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">frame_id_t</span> fid;</span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Evict</span>(&amp;fid)) &#123; ... &#125;</span><br><span class="line">    <span class="comment">// 这些地方不涉及对page的读写，只涉及对bpm内部成员的读写</span></span><br><span class="line">    page_table_.<span class="built_in">erase</span>(page_table_.<span class="built_in">find</span>(pages_[fid].<span class="built_in">GetPageId</span>()));</span><br><span class="line">    page_table_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(page_id, fid));</span><br><span class="line"></span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(fid, access_type);</span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(fid, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个锁的交接点</span></span><br><span class="line">    pages_latch_[fid].<span class="built_in">lock</span>();</span><br><span class="line">    latch_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pages_[fid].<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[fid].<span class="built_in">GetPageId</span>(), pages_[fid].<span class="built_in">GetData</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Page *res = &amp;(pages_[fid]);</span><br><span class="line">    res-&gt;page_id_ = page_id;</span><br><span class="line">    res-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, res-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">    res-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    res-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pages_latch_[fid].<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这些地方不涉及对page的读写，只涉及对bpm内部成员的读写</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid = free_list_.<span class="built_in">front</span>();</span><br><span class="line">  free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">  page_table_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(page_id, fid));</span><br><span class="line"></span><br><span class="line">  replacer_-&gt;<span class="built_in">RecordAccess</span>(fid, access_type);</span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(fid, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两个锁的交接点</span></span><br><span class="line">  pages_latch_[fid].<span class="built_in">lock</span>();</span><br><span class="line">  latch_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  Page *res = &amp;(pages_[fid]);</span><br><span class="line">  res-&gt;page_id_ = page_id;</span><br><span class="line">  res-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, res-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  res-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  res-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line">  pages_latch_[fid].<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他地方也是一样。就不多赘述了。</p>
<h5 id="一个小地方"><a href="#一个小地方" class="headerlink" title="一个小地方"></a>一个小地方</h5><p>当外界需要对页进行读写时，需要使用page自带的锁；而当bpm内部需要对页进行读写时，则使用的是bpm内部自带的页锁。</p>
<p>这句话说完，相信危险性已经显而易见了：我们使用了两把不同的锁维护了同一个变量！而且可能会有两个线程分别持有这两个锁，对这个变量并发更新！</p>
<p>但其实，在当前这个场景，这么做是没问题的。</p>
<p>外界实质上只能对page的data字段进行读写。因而，有上述危险的，实质上就只有bpm中会对data字段进行改变的地方，也即<code>bpm::NewPage()</code>、<code>bpm::FetchPage()</code>、<code>bpm::DeletePage()</code>这三个地方。</p>
<p>而在前两个地方，我们会使用到的page都是闲置/已经被释放的页，因而外界不可能，也即不可能有别的线程，会持有page的锁并且对其修改；同样的，在第三个地方，我们会使用的page也是pincount==0的页，仅有当前线程在对其进行读写。</p>
<p>因而，综上所述，这样做是并发安全的。</p>
]]></content>
  </entry>
  <entry>
    <title>Project2   B+Tree</title>
    <url>/2023/03/13/cmu15445$lab2/</url>
    <content><![CDATA[<blockquote>
<p>参考</p>
<p><a href="https://zhuanlan.zhihu.com/p/618912295">CMU 15-445 Project 2 (Spring 2023) | 关于 B+Tree 的十个问题</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/661208232#:~:text=lock%20(Pessimistic%20version)-,%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%98%AF%E8%BF%99%E4%B8%AA%E5%AE%9E%E9%AA%8C%E6%9C%80%E9%9A%BE%E7%9A%84%E4%B8%80%E4%B8%AA%E9%83%A8%E5%88%86%E4%BA%86,-%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%8E%BB">对crabbing lock、乐观锁做了详尽解释</a></p>
</blockquote>
<h1 id="Project2-B-Tree"><a href="#Project2-B-Tree" class="headerlink" title="Project2   B+Tree"></a>Project2   B+Tree</h1><blockquote>
<p>In this programming project you will implement a <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+Tree</a> index in your database system.</p>
<p>Your implementation will support thread-safe <u>search, insertion, deletion</u> (including splitting and merging nodes包括分裂和合并结点), and an iterator to support in-order leaf scans.</p>
</blockquote>
<p>它这里的B+树（以及wiki里的）跟王道考研讲得不大一样。王道考研的B+每个结点一个关键字对应一个child，但是这里的是B树的形式。</p>
<p><img src="/2023/03/13/cmu15445/B+-tree-remove-61.png" alt="undefined"></p>
<p><img src="/2023/03/13/cmu15445/image-20230417181239196.png" alt="image-20230417181239196"></p>
<h2 id="Task1-B-Tree-Pages"><a href="#Task1-B-Tree-Pages" class="headerlink" title="Task1   B+Tree Pages"></a>Task1   B+Tree Pages</h2><blockquote>
<p>You must implement three Page classes to store the data of your B+Tree:</p>
<ol>
<li><p>B+Tree Page  <code>BPlusTreePage</code></p>
<p>下面那两个的基类</p>
</li>
<li><p>B+Tree Internal Page</p>
<p>An Internal Page stores <strong>m</strong> ordered keys and <strong>m+1</strong> child pointers (as page_ids) to other B+Tree Pages.These keys and pointers are internally represented as an array of key/page_id pairs. </p>
<p>Because the number of pointers does not equal the number of keys, <strong>the first key is set to be invalid, and lookups should always start with the second key.</strong></p>
<p>At any time, each internal page should be at least half full.【min_size&lt;=  &lt;=max_size】</p>
<p>During deletion, two half-full pages can be merged, or keys and pointers can be redistributed to avoid merging. During insertion, one full page can be split into two, or keys and pointers can be redistributed to avoid splitting. </p>
</li>
<li><p>B+Tree Leaf Page</p>
<p>The Leaf Page stores <strong>m</strong> ordered keys and their <strong>m</strong> corresponding values.  In your implementation, the value should always be the 64-bit record_id for where the actual tuples are stored; see the <code>RID</code> class, in <code>src/include/common/rid.h</code>. </p>
<p>*<strong>Note:*</strong> Even though Leaf Pages and Internal Pages contain the same type of key, they may have different value types. <strong>Thus, the <code>max_size</code> can be different.</strong></p>
</li>
</ol>
</blockquote>
<p>大概就是有一个基类结点，它有两个子类，一个表示b+树的leaf node，另一个表示b+树的internal node，每个结点都占据一个内存页。</p>
<p>也就是说，一个内存页中存储着一个结点类对象。每次我们都是读取一页到内存中，然后将它类型转换为TreeNodePage*，就可以访问其里面的存储数据的数组<code>array_</code>了。体会一下这个思想。</p>
<p>值得一提的是，<code>LeafPage</code>的成员变量中有个这样的成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// Flexible array member for page data.</span></span><br><span class="line"> MappingType array_[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>它就是柔性数组成员。</p>
<blockquote>
<p>在C++中，Flexible Array Member（柔性数组成员）是一种用于定义具有可变大小的结构的技术。它通常用于在结构的末尾声明一个数组，该数组的大小是动态确定的，这允许你在使用该结构时更灵活地处理变长数据。</p>
<p>在你提供的代码片段中，<code>MappingType array_[0];</code> 是一个柔性数组成员的例子。这里 <code>array_</code> 后面有 <code>[0]</code>，这并不表示它们的大小是固定的0。相反，它们的大小是在运行时动态确定的，而 <code>[0]</code> 的写法是一种历史上的技巧，用于<strong>告诉编译器</strong>这是柔性数组成员。</p>
<p>例如，如果有一个结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="comment">// 其他成员...</span></span><br><span class="line">    MappingType array_[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你可以根据需要为 <code>array_</code> 分配任意数量的内存，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arraySize = <span class="number">10</span>;  <span class="comment">// 你想要的数组大小</span></span><br><span class="line">MyStruct* myObject = <span class="built_in">static_cast</span>&lt;MyStruct*&gt;(<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(MyStruct) + arraySize * <span class="built_in">sizeof</span>(MappingType)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里你可以使用 myObject，并通过 myObject-&gt;array_ 访问柔性数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记得在使用完毕后释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(myObject)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>array_</code> 可以用于存储可变大小的数据，而结构体 <code>MyStruct</code> 的大小将动态地调整为 <code>sizeof(MyStruct) + arraySize * sizeof(MappingType)</code>。这样的设计通常在需要处理变长数据块的场景中比较有用。请注意，在C++17之后，你也可以使用 <code>std::byte</code> 类型来定义柔性数组成员。</p>
</blockquote>
<p>拥有柔性数组成员的实例需要动态分配内存（或者像接下来的把一块内存空间interpret一下），柔性数组成员会占用其他成员没有占用的剩下的空间，也即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+--------------------------+</span><br><span class="line">| Other Members of MyClass |</span><br><span class="line">| ...                      |</span><br><span class="line">+--------------------------+</span><br><span class="line">| array_ (flexible)        |</span><br><span class="line">|                          |</span><br><span class="line">|                          |</span><br><span class="line">+--------------------------+</span><br></pre></td></tr></table></figure>



<h2 id="Task2a-Insertion-and-Search-Task3-Iterator"><a href="#Task2a-Insertion-and-Search-Task3-Iterator" class="headerlink" title="Task2a   Insertion and Search + Task3 Iterator"></a>Task2a   Insertion and Search + Task3 Iterator</h2><blockquote>
<p>The index should <strong>support only unique keys;</strong> if you try to reinsert an existing key into the index, it should not perform the insertion, and should return false. key必须unique</p>
<p>B+Tree pages should be split (or keys should be redistributed) if an insertion would violate the B+Tree’s invariants. 插入时需要分裂</p>
<p>If an insertion changes the page ID of the root, you must update the <code>root_page_id</code> in the B+Tree index’s header page. You can do this by accessing the <code>header_page_id_</code> page, which is given to you in the constructor.  Then, by using <code>reinterpret_cast</code>, you can interpret this page as a <code>BPlusTreeHeaderPage</code> (from <code>src/include/storage/page/b_plus_tree_header_page.h</code>) and update the root page ID from there. You also must implement <code>GetRootPageId</code>, which currently returns 0 by default.对<code>root_page_id</code>的一切访问，都需要通过<code>header_page_id_</code>。如果插入后改变了root的page ID，需要更新<code>root_page_id</code>。</p>
<p>We recommend that you use the page guard classes from Project 1 to help prevent synchronization problems. For this checkpoint, we recommend that you use <code>FetchPageBasic</code> (defined in <code>src/include/storage/page/</code>) when you access a page. 在当前task中，我们推荐你使用pro1实现的page guard，比如说这里如果要访问一页，就需要用 <code>FetchPageBasic</code> 。</p>
<p>You may optionally use the <code>Context</code> class (defined in <code>src/include/storage/index/b_plus_tree.h</code>) to track the pages that you’ve read or written (via the <code>read_set_</code> and <code>write_set_</code> fields) or to store other metadata that you need to pass into other functions recursively.你可以随意使用和修改 <code>Context</code> class，它大概就是一个存储共享信息的对象。</p>
<p>If you are using the <code>Context</code> class, here are some tips:如果你要用，要注意以下几点：</p>
<ul>
<li><p>You might only need to use <code>write_set_</code> when inserting or deleting. 当你在为B+树插入/删除结点时，需要用到<code>write_set_</code>。【为什么？这个set存储的是修改路径上的结点吗？然后如果要分裂/合并结点，只需什么while(pop且需要分裂/合并){分裂/合并}？？所以说这里的deque是栈结构？】</p>
<p>也就是说，其实我们就可以不用递归了，而是将上下文存储在context-&gt;write_set_这个栈里面就行了？大概是这个意思吧</p>
<p>It is possible that you don’t need to use <code>read_set_</code>, depending on your implementation.</p>
<p>read可以用递归（比较简单）也可以不用，所以说具体看实现。</p>
</li>
<li><p>You might want to store the root page id in the context and acquire write guard of header page when modifying the B+Tree.你需要将root page id存储在context，并且在修改b+树（插入、删除）时获取header page的WritePageGurad。</p>
</li>
<li><p>To find a parent to the current node, look at the back of <code>write_set_</code>. It should contain all nodes along the access path.如果想要寻找当前node的父亲，可以看看<code>write_set_.back</code>，它包含了访问路径上所有结点的引用【所以确实是当成栈来用了】</p>
</li>
<li><p>You should use <code>BUSTUB_ASSERT</code> to help you find inconsistent data in your implementation. 需要使用 <code>BUSTUB_ASSERT</code>。</p>
<p>For example, if you want to split a node (except root), you might want to ensure there is still at least one node in the <code>write_set_</code>. If you need to split root, you might want to check if <code>header_page_</code> is <code>std::nullopt</code>.</p>
<p>如果你想要分割一个根节点以外的node，那你必须保证<code>write_set_</code>中至少有一个结点；如果你想要分割根节点，那你必须保证<code>header_page_</code>非空。</p>
</li>
<li><p>To unlock the header page, simply set <code>header_page_</code> to <code>std::nullopt</code>. To unlock other pages, pop from the <code>write_set_</code> and drop.如果你想要不锁住header page，那就置其为空指针；如果想释放别的页，那就将它从 <code>write_set_</code> pop出来就行。【这是因为我们要用到的page类型都是page guard，可以析构时unpin吗？】</p>
</li>
</ul>
</blockquote>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>由于各种原因，lab2的战线还是拉得太长了。四月份完成了代码初版，中间修了几个bug勉强通过了insertion test，然后一直到十一月底的现在才再次捡起来。不得不说，回看当初的代码，还是能够很清晰地感受到自己这半年多来的成长的，令人感慨。</p>
<p>我先是花了一天的时间重构了下以前写的所有代码，然后再花了两天时间修bug终于通过了insertion test和sequence scale test，并且将b+树的代码修到了我满意的地步（指不像以前那样一坨重复代码和中文注释。。。）。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里简要介绍下B+树的插入实现及我觉得实现中需要注意的几个要点吧。</p>
<p>B+树的插入流程大概是这样的：</p>
<ol>
<li><p>查找到key要插入的叶子结点（途中需要维护write_set，也即查找路径）</p>
</li>
<li><p>判断结点是否满</p>
<ol>
<li><p>未满，直接插入即可。（我采取插入排序的方法）</p>
</li>
<li><p>已满，需要对结点进行分裂。</p>
<p>推举出中间结点tmp_key，它和新结点page_id接下来将插入到父节点中。</p>
</li>
</ol>
</li>
<li><p>持续进行分裂：</p>
<p>需要注意具体的分裂方法，我认为其中internal page size == 3的情况尤为棘手。在具体实现中，我是这样分裂的：</p>
<ol>
<li><p>推举出将要被插入到父节点的tmp_key</p>
<p>该推举出的key将不会出现在分裂后的新旧结点中，而是会被加入到父节点中。默认为<code>(m + 1) / 2</code>【m为max size】。</p>
<p>但是要尤其注意size为3的case，此时tmp_key为<code>array_[2]</code>，很有可能右边结点为空。所以我们需要做点特殊处理：</p>
<ol>
<li>当要插入到该节点的<code>insert_key &gt; array_[(m + 1) / 2]</code>时，我们推举<code>(m + 1) / 2</code>这个结点。</li>
<li>当<code>insert_key &lt; array_[m / 2]</code>，我们转而推举<code>m / 2</code>（此时为<code>array_[1]</code>）。</li>
<li>当<code>insert_key &lt; array_[(m + 1) / 2]</code>且<code>insert_key &gt; array_[m / 2]</code>时，我们应该对此做出特殊处理，推举insert_key。在此为了代码实现方便，<strong>我们还需要调换insert_key和tmp_key的地位</strong>。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">special = <span class="literal">false</span>;</span><br><span class="line">middle = (m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">tmp_key = root-&gt;<span class="built_in">KeyAt</span>(middle);</span><br><span class="line">insert_small_than_tmp_key = (<span class="built_in">comparator_</span>(insert_key, tmp_key) &lt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (insert_small_than_tmp_key) &#123;</span><br><span class="line">  middle = m / <span class="number">2</span>;</span><br><span class="line">  tmp_key = root-&gt;<span class="built_in">KeyAt</span>(middle);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">comparator_</span>(insert_key, tmp_key) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    special = <span class="literal">true</span>;</span><br><span class="line">    swap = insert_key;</span><br><span class="line">    insert_key = tmp_key;</span><br><span class="line">    tmp_key = swap;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分裂旧结点</p>
<p>被推举出的tmp_key的value及其右部元素会变成新结点，左部依然留在旧结点，tmp_key会到父节点中去。也即如下图所示：</p>
<p>![未命名文件 (1)](./cmu15445/未命名文件 (1).png)</p>
<p>依然是注意上面那个case3特殊情况，需要交换insert key和middle key：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!special)</span><br><span class="line">  new_page-&gt;<span class="built_in">SetValueAt</span>(<span class="number">0</span>, root-&gt;<span class="built_in">ValueAt</span>(middle));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  new_page-&gt;<span class="built_in">SetValueAt</span>(<span class="number">0</span>, insert_val);</span><br><span class="line">  insert_val = root-&gt;<span class="built_in">ValueAt</span>(middle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>持续进行推举和分裂，直到父节点不用分裂</p>
<p>此时直接将insert key和insert value插入排序到父节点即可。</p>
</li>
</ol>
</li>
</ol>
<p>然后是Iterator的话，我感觉这也是设计得很不错，让我们亲手写了下c++的重载运算符，也是让我学到了很多c++知识。。。</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>感觉问题其实不多，主要还是debug有点痛苦花了很长时间（）</p>
<h4 id="cmake报错"><a href="#cmake报错" class="headerlink" title="cmake报错"></a>cmake报错</h4><p>切换内核前后报错。</p>
<p><a href="https://www.cnblogs.com/minglee/p/9016306.html">Check for working C compiler: /usr/bin/cc - broken</a></p>
<p>感觉可能是内核切来切去，导致cmake cache发生了点小问题？总之我最后在5.11内核把build文件删了，重新执行<code>cmake -DCMAKE_CXX_COMPILER=$(which g++) -DCMAKE_C_COMPILER=$(which gcc) ..</code>就ok了。</p>
<h4 id="page-guard"><a href="#page-guard" class="headerlink" title="page guard"></a>page guard</h4><h5 id="用错了"><a href="#用错了" class="headerlink" title="用错了"></a>用错了</h5><p><img src="/2023/03/13/cmu15445/image-20230505002652748.png" alt="image-20230505002652748"></p>
<p>我发现在这里创建的root最后好像会被释放掉？</p>
<p>比如我看到新root的page为6，连接也做得好好的，最后出了函数就寄了：</p>
<p><img src="/2023/03/13/cmu15445/image-20230505002731312.png" alt="image-20230505002731312"></p>
<p>还有一个是发现新的leaf page好像不大对，其类型甚至是internal呃呃，我调下看看</p>
<p>尼玛，绷不住了是这里：</p>
<p><img src="/2023/03/13/cmu15445/image-20230505011731797.png" alt="image-20230505011731797"></p>
<p>原来写的</p>
<p><img src="/2023/03/13/cmu15445/image-20230505011744924.png" alt="image-20230505011744924"></p>
<p>改了之后test2马上ok，乐</p>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>还弄了个commit修:</p>
<p><img src="/2023/03/13/cmu15445/image-20231130222702358.png" alt="image-20231130222702358"></p>
<h4 id="一点c-引用震撼"><a href="#一点c-引用震撼" class="headerlink" title="一点c++引用震撼"></a>一点c++引用震撼</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>*() -&gt; <span class="type">const</span> MappingType &amp;</span><br></pre></td></tr></table></figure>

<p>这个函数卡了我还挺久。。。里面逻辑很简单，不过难就难在怎么构造出一个<code>const MappingType &amp;</code>。</p>
<p>如果这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>*() -&gt; <span class="type">const</span> MappingType &amp; &#123; </span><br><span class="line">    <span class="keyword">auto</span> page = guard_.<span class="built_in">As</span>&lt;LeafPage&gt;();</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;KeyType, ValueType&gt;(page-&gt;<span class="built_in">KeyAt</span>(cnt_), page-&gt;<span class="built_in">ValueAt</span>(cnt_));</span><br><span class="line">    <span class="comment">// or use make_pair. the same result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会说你临时对象不能作为引用。如果这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>*() -&gt; <span class="type">const</span> MappingType &amp; &#123; </span><br><span class="line">    <span class="keyword">auto</span> page = guard_.<span class="built_in">As</span>&lt;LeafPage&gt;();</span><br><span class="line">    <span class="keyword">auto</span> res = <span class="keyword">new</span> <span class="built_in">MappingType</span>(std::<span class="built_in">pair</span>&lt;KeyType, ValueType&gt;(page-&gt;<span class="built_in">KeyAt</span>(cnt_), page-&gt;<span class="built_in">ValueAt</span>(cnt_)));</span><br><span class="line">    <span class="keyword">return</span> *res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又会找不到机会delete导致内存泄漏。冥思苦想了半天不知道该怎么办，最后从网上看了别人怎么写的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>*() -&gt; <span class="type">const</span> MappingType &amp; &#123; </span><br><span class="line">    <span class="keyword">auto</span> page = guard_.<span class="built_in">As</span>&lt;LeafPage&gt;();</span><br><span class="line">    <span class="keyword">return</span> page-&gt;<span class="built_in">PairAt</span>(cnt_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::PairAt</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> -&gt; <span class="type">const</span> MappingType &amp; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array_[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我服了。</p>
<p>不过可能有更好的解决方法？可惜我c++水平不大够，所以暂时想不出来了。</p>
<h2 id="Task4-Remove"><a href="#Task4-Remove" class="headerlink" title="Task4  Remove"></a>Task4  Remove</h2><h3 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h3><p>由于有了insert的沉淀，remove的实现便相较不大困难了，写完代码到通过内置的delete测试只花了一天的时间。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>找到需要操作的叶结点路径</p>
</li>
<li><p>判断叶子结点属于以下四种策略中的哪一种，执行对应策略（优先级从高到低）：</p>
<ol>
<li><p>直接删除</p>
<p>当删除后叶结点元素数仍在合法范围，并且路径上父节点<strong>没有</strong>target key，直接删除然后返回即可。</p>
</li>
<li><p>更新父节点路径</p>
<p>当删除后叶结点元素数仍在合法范围，并且路径上父节点<strong>有</strong>target key，直接删除然后向上回溯更新父节点即可。</p>
</li>
<li><p>窃取兄弟元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">If <span class="keyword">do</span> a steal, we should update related key in the parent, and update up till reaching the root.</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    For that steal is more simple, we first check whether it can do a steal first.</span></span><br><span class="line"><span class="comment">    We steal the node whose size is biggest between the next and the prev node.</span></span><br><span class="line"><span class="comment">    If the prev size is bigger, we only update self key in parent.</span></span><br><span class="line"><span class="comment">    If the next size is bigger, we update both self key and next key n parent.</span></span><br><span class="line"><span class="comment">    After that, we trace back and update all the parent nodes which contains the</span></span><br><span class="line"><span class="comment">    target key.</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<p>当删除后叶结点元素数过少，并且左右兄弟元素充足，则从左右兄弟窃取一个。优先窃取元素最多者。</p>
<ol>
<li><p>窃取左兄弟</p>
<p>窃取左兄弟的最大元素</p>
<p>需递归更新自身父节点路径上的对应值。</p>
</li>
<li><p>窃取右兄弟</p>
<p>窃取右兄弟的最小元素</p>
<p>需要递归更新自身和右兄弟父节点路径上的对应值。</p>
</li>
</ol>
<p>之后返回即可。</p>
</li>
<li><p>合并</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Need to merge with one of the node. It is more simple to try to merge the left node</span></span><br><span class="line"><span class="comment">  first. So the strategy:</span></span><br><span class="line"><span class="comment">  1. Pick the prev node to merge. (If leaf is most left, pick next node)</span></span><br><span class="line"><span class="comment">  2. Update delete-key. (for prev, it&#x27;s leaf[0]; for next, it&#x27;s right key, and need</span></span><br><span class="line"><span class="comment">    to update self)</span></span><br><span class="line"><span class="comment">  3. Go up till reaching root. Do:</span></span><br><span class="line"><span class="comment">    1. delete delete-key.</span></span><br><span class="line"><span class="comment">    2. pick merging or stealing like above.</span></span><br><span class="line"><span class="comment">      1. if merge, update delete-key, go up;</span></span><br><span class="line"><span class="comment">      2. if steal, break to do update and has no need to go up.</span></span><br><span class="line"><span class="comment">  4. Remember to deal with edge case: root.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>当删除后叶结点元素数过少，并且左右兄弟元素也都是最小值，那么需要与左右兄弟之一进行合并。优先合并左兄弟。合并都为大-&gt;小，也即target-&gt;左兄弟 或者 右兄弟-&gt;target。</p>
<p>需要递归删除父节点路径上的merge from元素。</p>
</li>
</ol>
</li>
<li><p>可以看到，1/2/3三种情况都可以实现简单地直接返回。4稍显复杂，由于递归删除，所以需要对每一个父节点都再次进行上面几种策略的判断，直到遇到情况123返回为止。</p>
</li>
</ol>
<h3 id="遇到的问题-1"><a href="#遇到的问题-1" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>一个比较sb的小bug……</p>
<p><img src="/2023/03/13/cmu15445/image-20231204163052528.png" alt="image-20231204163052528"></p>
<h2 id="Task5-Concurrency"><a href="#Task5-Concurrency" class="headerlink" title="Task5  Concurrency"></a>Task5  Concurrency</h2><h3 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h3><p>这位可更是重量级，足足花了我三天的时间……不过感觉第一次处理这么一个复杂的并发情景，花的时间还是值得的。</p>
<p>最后的结果虽然很一般（指排行榜倒数水平。。。），但至少还是过了。就先这样吧。</p>
<p><img src="/2023/03/13/cmu15445/image-20231204170030245.png" alt="image-20231204170030245"></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我实现了crabbing lock+optimal lock。对于Insert和Remove，都是先在一开始获取header page和路径上父节点的读锁，然后在之后有可能向上更新时（比如说Insert的需要分裂、Remove的Update和Merge两种情况），丢弃所有读锁，然后获取header page和路径上父节点的写锁。</p>
<p>不过感觉我这个思路还是略有粗糙，因为相当一部分时间都得占用header page的写锁。但是我思考了一下细粒度方案，发现还是有点难实现。比如说，对于insert，细粒度化的方式也许就是一直持有header page的读锁，一直到需要分裂根节点时，才释放读锁获取写锁。但这样一来就会暴露一个危险的空窗期（而且感觉这个空窗期还不小），当你真的拿到写锁，这树的结构可能已经变得不知道什么样了。在这种情况下，你就需要再做一次回溯工作，也即获取从新root结点到旧root结点的路径，递归插入insert key和insert value，最后安全分裂根节点（因为此时已经安全持有了header page写锁）。感觉思路也是比较易懂，但是实现上还是太麻烦了，所以先暂且搁置吧。</p>
<h3 id="遇到的问题-2"><a href="#遇到的问题-2" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>这种感觉大多还是在面向测试用例见招拆招……所以其实感觉没什么好说的。</p>
<h4 id="bpm遗留"><a href="#bpm遗留" class="headerlink" title="bpm遗留"></a>bpm遗留</h4><p>这个并发问题是这样的，我原来是先evict，然后再写回被替换的页面，写回过程中磁盘没加bpm锁。这就会出现这样一个情况：</p>
<p>一个page被进程A evict，进程A还没执行写回的时候这个page又被进程B捡回来了，因为还没写入所以磁盘空空如也。这时候pages_latch_这个细粒度锁不能防范这种情况，是因为此时这个page对应的container不是同一个，所以fid不同，细粒度锁不同导致寄。</p>
<p>解决方法是要么写的时候持有bpm锁，但是这太太慢了。另一个就是干脆直接在unpin的时候不带bpm锁顺便写回了。也即把写回从evict后移到unpin中立即写回：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pages_[fid].<span class="built_in">GetPinCount</span>() == <span class="number">0</span> &amp;&amp; pages_[fid].<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">  pages_[fid].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[fid].<span class="built_in">GetPageId</span>(), pages_[fid].<span class="built_in">GetData</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="火焰图性能分析"><a href="#火焰图性能分析" class="headerlink" title="火焰图性能分析"></a>火焰图性能分析</h3><blockquote>
<p><a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/618912295#:~:text=%E6%97%B6%EF%BC%8C%E5%BE%88%E6%9C%89%E5%B8%AE%E5%8A%A9%E3%80%82-,Q6%EF%BC%9A%E5%88%86%E6%9E%90%E5%8D%95%E7%BA%BF%E7%A8%8B%20B%2BTree%20%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%EF%BC%9F,-%E5%9C%A8%E9%98%85%E8%AF%BB%E5%A4%A7">参考博客</a></p>
</blockquote>
<p>看起来感觉大多性能损耗还是在bpm上，特别是LRU-K。也许是我的全局锁太暴力了。</p>
<p><img src="/2023/03/13/cmu15445/out.png" alt="out"></p>
]]></content>
  </entry>
  <entry>
    <title>Project4   Concurrency</title>
    <url>/2023/03/13/cmu15445$lab4/</url>
    <content><![CDATA[<h1 id="Project4-Concurrency"><a href="#Project4-Concurrency" class="headerlink" title="Project4   Concurrency"></a>Project4   Concurrency</h1><p>在上面的project中，我们实现了负责管理内存页缓冲与磁盘的、用于一切数据和索引页管理的buffer pool，然后实现了一个b+树索引，最后实现了增删改查等操作的底层执行器以及部分查询优化规则。这一小节，我们将完成数据库的并发控制。需要关注<strong>事务的原子性的实现和事务的调度</strong>，关注事务并行执行时的正确性。</p>
<blockquote>
<p>In this project, you will add support for <strong>transactions</strong> in BusTub by adding a lock manager and then using it for concurrent query execution. </p>
<p>The lock manager will support <strong>table locks</strong> and <strong>tuple locks</strong> in <strong>five</strong> lock modes: intention-shared, intention-exclusive, shared-intention-exclusive, shared, and exclusive. </p>
<p>The lock manager will <u>process lock requests from transactions</u>, grant locks to transactions, and check if locks are released appropriately based on the <strong>transaction’s isolation level</strong>.</p>
</blockquote>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/78897428">聊一聊数据库中的锁 - 老刘的文章 - 知乎</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/51676675">一文了解db2的锁 - somenzz的文章 - 知乎</a></p>
<p><a href="https://www.jianshu.com/p/3aa634b0567c">CMU 15445 14.二阶段锁定 + homework 4</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/488482354">【15-445】8.事务(3)串行化 - 只爱睡觉的文章 - 知乎</a>  这篇文章写得很棒</p>
</blockquote>
<h4 id="多级粒度锁机制"><a href="#多级粒度锁机制" class="headerlink" title="多级粒度锁机制"></a>多级粒度锁机制</h4><p>假设存在如下需求：事务T需要访问一个有1亿个元组的数据库。</p>
<p>我们希望T只发出单个请求就能封锁整个数据库，因此这里需要引入允许系统定义<strong>多级粒度</strong>(granularity)锁的机制，并允许定义各种大小的数据项和数据粒度的层次结构。这种层次结构可以图形化地表示为树。</p>
<p><img src="/2023/03/13/cmu15445/v2-6a8363d4fada6e578c03b3d8d87c4813_1440w.webp" alt="img"></p>
<p>树中每个结点都可以单独加锁。当一个事务对一个结点加锁时，该事务也以同样类型的锁<strong>隐式地封锁这个结点的全部子结点</strong>。</p>
<p>但这样处理存在一个问题：事务T希望封锁整个子树，因此它只需给子树的根结点加锁。但是如果T在子树的某部分持有锁，那么T给该根结点加锁就会失败。<strong>如何判定根结点是否可以加锁呢</strong>？一种可能的方法是搜索整棵树。然而，这个方法破坏了多粒度封锁机制的初衷。另一种方法是引入一种新的锁类型，即<strong>意向锁类型</strong>( intentionlock mode)。</p>
<p>如果一个结点加上了意向锁，则意味着将要在树的较低层进行显式加锁(也就是说，以更小的粒度加锁)。这里有三种意向锁：</p>
<ul>
<li>**Intention-Shared (IS)**：说明在较低级别会使用共享锁（S）来显式上锁。</li>
<li>**Intention-Exclusive (IX)**：说明在较低级会使用互斥锁（X）来显式上锁</li>
<li><strong>Shared+Intention-Exclusive (SIX)<strong>：以该节点为根的子树</strong>已经显式得到了共享锁</strong>，并且<strong>将要</strong>在树的更低层次显示加上互斥锁。</li>
</ul>
<p>对某个结点进行加锁之前，需要获取它到根节点路径上的所有相关意向锁，具体规则如下图所示：</p>
<p><img src="/2023/03/13/cmu15445/webp-1706931395906-19.webp" alt="img"></p>
<p>引入该机制后，在一个结点显式加锁之前，该结点的全部祖先均需要加上意向锁。当我们希望给某个结点加锁时，事务必须遍历从根到该节点的路径，判断路径上的节点是否被加了意向锁：如果已加，则该显示加锁过程不能成功；如果未加，<strong>则给该路径上的节点加上意向锁</strong>。</p>
<h4 id="实际实现"><a href="#实际实现" class="headerlink" title="实际实现"></a>实际实现</h4><p>如上节所示，锁定层次结构有多种粒度：</p>
<p><img src="/2023/03/13/cmu15445/v2-34a703b4147e594149bc2a8d37110327_1440w.webp" alt="img"></p>
<p>而在bustub中，讨论锁的并发控制，我们通常只考虑table和tuple粒度，也即<strong>表锁与行锁</strong>。</p>
<p>如果加表锁，则表中所有的行都受到同等程度的影响；如果加行锁，则加锁的范围针对的是表及下属的行。有时对表加锁后，还要在相应的数据行上加锁。</p>
<p>针对表锁和行锁，我们可以使用上一小节提到的多级粒度锁机制。具体来说，表锁包括意图锁和传统的XS锁，行锁只包括XS锁。在具体上锁操作中，首先获取意图锁表明自己对表中的某些行有读写的需求，等到真正要读写了才会真正获取行锁。也即，它支持多个事务同时对表的不同行进行读写，故而相比传统锁住整个表的XS锁会更高效一些。</p>
<p>如果使用意图锁，需要对表加上意图锁才能对行加上XS锁，这就相当于是上面那个树结构的简化情况。</p>
<p>常见的表锁及其含义如下表所示：</p>
<p><img src="/2023/03/13/cmu15445/v2-0f3d06461969e38d22795ec8b33b3270_1440w.webp" alt="img"></p>
<p>其互斥矩阵如下图所示：</p>
<p><img src="/2023/03/13/cmu15445/webp.webp" alt="img"></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>与此同时这里还有几个使用锁的例子：</p>
<p><img src="/2023/03/13/cmu15445/image-20240203113752672.png" alt="image-20240203113752672"></p>
<p><img src="/2023/03/13/cmu15445/image-20240203113803390.png" alt="image-20240203113803390"></p>
<h3 id="concurrency"><a href="#concurrency" class="headerlink" title="concurrency"></a>concurrency</h3><p>要了解事务的并发控制，首先了解什么是调度、串行化。</p>
<p><img src="/2023/03/13/cmu15445/image-20231119160217938.png" alt="image"></p>
<p><img src="/2023/03/13/cmu15445/image-20231119160636318.png" alt="image"></p>
<p>事务并发控制大概有以下这几种方法：</p>
<ol>
<li><p>基于封锁的并发控制</p>
<p>使用<strong>两段封锁协议2pl</strong>来控制资源互斥的事务串行化执行，形成一个合理的串行调度；</p>
<p>同时，通过<strong>死锁检测</strong>方法来去除隐患的死锁。</p>
</li>
<li><p>基于时间戳的并发控制</p>
</li>
<li><p>基于有效性确认的并发控制</p>
</li>
</ol>
<p>在本次实验中，我们就是采用<strong>基于封锁的并发控制</strong>。</p>
<h4 id="两段封锁协议"><a href="#两段封锁协议" class="headerlink" title="两段封锁协议"></a>两段封锁协议</h4><p><img src="/2023/03/13/cmu15445/image-20231119183734987.png" alt="image"></p>
<p>在DBMS中，lock manager模块负责管理系统中的锁。每当事务需要加锁或者升级锁的时候，都需要向它发出请求。lock manager 内部维护着一个表，上面记录着当前所有锁的分配信息，用于跟踪哪些事务持有哪些锁，以及哪些事务正在等待获得哪些锁。由于我们想获得可串行化的调度序列，因此我们需要利用lock manager来实施加锁策略，以保证事务操作的正确性和并发度。</p>
<p>两阶段锁的实现由两阶段组成。</p>
<ul>
<li>growing 阶段：事务可以按需获取某条数据的锁，lock manager 决定同意或者拒绝</li>
<li>shringking 阶段：事务只能释放之前获取的锁，不能获得新锁，即一旦开始释放锁，之后就只能释放锁。</li>
</ul>
<p>通过2PL获得的调度策略是冲突可串行化的。</p>
<p>但是该方法有着致命的弱点：可能会导致<strong>级联中止</strong> (cascading aborts)。如下图所示的 “脏读”现象。为了保证整个调度是可串行化的，DBMS 需要在 T1 中止后将一些对T1有依赖的事务也中止，这些事务曾经读取过 T1 写入的数据。而这些中止可能进而使得其它正在进行的事务级联地中止。</p>
<p>为了解决这个问题，可以使用2PL的增强版变种（也即bustub所采取的版本）。该方法要求<strong>事务持有的X锁一直到其提交或者中止时才释放</strong>，从而使得每个事务在结束之前，其写过的数据不能被其它事务读取或者重写。</p>
<p><img src="/2023/03/13/cmu15445/v2-78b6f9cdb1b36484c3e0217f27730650_1440w.webp" alt="img"></p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p><img src="/2023/03/13/cmu15445/image-20231119183354649.png" alt="image"></p>
<ol>
<li><p>三个隔离级别含义</p>
<p><code>READ_UNCOMMITTED</code>、<code>READ_COMMITTED</code>、<code>REPEATED_READ</code>分别对应上图的1/2/3级协议。</p>
<ol>
<li><p><code>READ_UNCOMMITTED</code></p>
<p>由于读时不加锁，所以可以读取其他事务未提交的修改，也即有脏读现象。</p>
</li>
<li><p><code>READ_COMMITTED</code></p>
<p>读时加共享锁，故而只能读取其他事务已提交的修改；读完后立刻解锁，所以当同一个事务中读两次，有可能产生不可重复读现象。</p>
</li>
<li><p><code>REPEATED_READ</code></p>
<p>读时加共享锁，故而只能读取其他事务已提交的修改；事务提交时才解读锁，所以同一个事务中读的两次结果一定一致。</p>
</li>
</ol>
</li>
<li><p>支持锁类型</p>
<p><code>READ_UNCOMMITTED</code>级别不支持IS/S/SIX锁</p>
</li>
<li><p>读写操作</p>
<ul>
<li><p>A transaction should hold X locks for all write operations until it commit or aborts, regardless of its isolation level.  不论是什么隔离级别，写都需要获取X锁。</p>
</li>
<li><p>For <code>REPEATABLE_READ</code>, a transaction should take and hold S locks for all read operations until it commits or aborts.  重复读，所有读操作都需要获取S锁，直到事务commit or abort才释放。</p>
</li>
<li><p>For <code>READ_COMMITTED</code>, a transaction should take S locks for all read operations, but can release them immediately.  读已提交，所有读操作都需要获取S锁，读完立刻释放。</p>
</li>
<li><p>For <code>READ_UNCOMMITTED</code>, a transaction does not need to take any S locks for read operations.  读未提交，所有读操作都不用获取S锁。</p>
</li>
</ul>
</li>
<li><p>与2PL结合——Shrinking阶段允许解锁情况</p>
<ul>
<li><p>REPEATABLE_READ:</p>
<p>GROWINHG阶段可以加任何锁；</p>
<p>SHRINKING阶段不能加任何锁。【也即S、IS也必须像X一样等到事务提交/终止时才能解锁】</p>
</li>
<li><p>READ_COMMITTED:</p>
<p>GROWINHG阶段可以加任何锁；</p>
<p>SHRINKING阶段只能加IS/S锁。【也即S、IS可以用完即解锁】</p>
</li>
<li><p>READ_UNCOMMITTED:</p>
<p>GROWINHG阶段可以加IX/X锁；【不支持共享锁】</p>
<p>SHRINKING阶段不能加任何锁。</p>
</li>
</ul>
</li>
</ol>
<h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>基于封锁的并发控制通过<strong>死锁检测</strong>方法来去除隐患的死锁。</p>
<p>在os课上，我们学过的死锁检测算法是通过构建资源分配图实现的：</p>
<p><img src="/2023/03/13/cmu15445/image-20240221174955281.png" alt="image-20240221174955281"></p>
<p><img src="/2023/03/13/cmu15445/image-20240221175201124.png" alt="image-20240221175201124"></p>
<p><img src="/2023/03/13/cmu15445/image-20240221175444948.png" alt="image-20240221175444948"></p>
<p><img src="/2023/03/13/cmu15445/image-20240221175123917.png" alt="image-20240221175123917"></p>
<p><img src="/2023/03/13/cmu15445/image-20240221175212083.png" alt="image-20240221175212083"></p>
<p>然后还有<strong>环路和死锁的关系</strong>：<a href="https://zhuanlan.zhihu.com/p/654942846">【操作系统】死锁（详细）</a></p>
<p>① 如果进程-资源分配图中无环路</p>
<p>——&gt;则此时系统没有发生死锁</p>
<p>② 如果进程-资源分配图中有环路，且每个资源类中仅有一个资源</p>
<p>——&gt;则系统中发生了死锁，此时，环路是系统发生死锁的<strong>充要条件</strong>，环路中的进程便为死锁进程</p>
<p>③ 如果进程-资源分配图中有环路，且涉及的资源类中有多个资源</p>
<p>——&gt;则环的存在只是产生死锁的<strong>必要条件而不是充分条件</strong></p>
<h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><blockquote>
<p>To ensure correct interleaving of transactions’ operations, the DBMS uses a <strong>lock manager (LM)</strong> to control when transactions are allowed to access data items. The basic idea of a LM is that it maintains an internal data structure about the locks currently held by active transactions. Transactions issue lock requests to the LM before they access data items, and the LM will either grant the lock, block the transaction until the lock is available, or abort the transaction.</p>
<p>为了保证并发控制，DBMS通常会有一个lock manager(LM)，它记录了每个锁都被哪些事务正在持有着。每个事务要访问数据前都需要获取特定的锁，LM的作用就是检查这个锁是否可用，是的话就让该事务获取锁然后执行，否则的话就阻塞该事务，或者直接中止该事务。</p>
<p>In your implementation, there will be a <strong>global LM</strong> for the BusTub system. The <code>TableHeap</code> and <code>Executor</code> classes will use your LM to acquire locks on tuple records (by record id <code>RID</code>) when a transaction attempts to access or modify a tuple.</p>
<p>Your LM must implement hierarchical <strong>table-level and tuple-level intention locks</strong> (described above) and three isolation levels: <code>READ_UNCOMMITED</code>, <code>READ_COMMITTED</code>, and <code>REPEATABLE_READ</code>. The LM should grant or release locks according to a transaction’s isolation level.</p>
<p>需要支持多级粒度锁和三个隔离级别。</p>
<p>We provide a <code>Transaction</code> context handle (<code>include/concurrency/transaction.h</code>) with an isolation level attribute (i.e., <code>READ_UNCOMMITED</code>, <code>READ_COMMITTED</code>, and <code>REPEATABLE_READ</code>) and information about its acquired locks. </p>
<p><code>Transaction</code> context记录了很多有用的信息，如隔离级别、所需锁等。</p>
<p>The LM will need to check the isolation level of transaction and expose correct behavior on lock/unlock requests. Any invalid lock operation should lead to an ABORTED transaction state (implicit abort) and throw an exception. A failed lock attempt (such as for a <strong>deadlock</strong>) does not result in an exception, but the LM should return false for the lock request.</p>
<p>当锁操作不合法需要将事务abort并且抛出异常；失败的锁操作（如可能导致死锁）则不会导致异常，而只是简单地返回false。</p>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>bustub采用了<strong>两段封锁协议</strong>（2PL），也即事务可以分为以下几个阶段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">* Transaction states <span class="keyword">for</span> <span class="number">2</span>PL:</span><br><span class="line">*</span><br><span class="line">*     _________________________</span><br><span class="line">*    |                         v</span><br><span class="line">* GROWING -&gt; SHRINKING -&gt; COMMITTED   ABORTED</span><br><span class="line">*    |__________|________________________^</span><br></pre></td></tr></table></figure>

<p>并且，bustub采取了表锁和行锁粒度，遵循<strong>多级粒度锁机制</strong>。表锁有<strong>意图锁</strong>和S/X锁，行锁只有S/X锁；当访问一个表时，可以直接获取它的S/X锁，或者先获取其意图锁再获取对应访问行的S/X锁。</p>
<p>同时，bustub也支持三个隔离级别，也即<code>READ_UNCOMMITTED</code>，<code>REPEATABLE_READ</code>和<code>READ_COMMITTED</code>。它们应该分别对应于一级协议（解决丢失修改）、二级协议（解决脏读）、三级协议（解决不可重复读）。</p>
<p>而本次实验所需实现的，就是一个lock manager（LM），并且通过LM来实现各个executor执行的并发安全。它需要管理系统中所有资源的锁，并且当事务调用lock方法尝试获取某个类型的锁时，它需要检验是否合理后再进行授权。在bustub中它是全局的。具体来说，它对外提供这四个主要接口：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockTable</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UnlockTable</span><span class="params">(Transaction *txn, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockRow</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid, <span class="type">const</span> RID &amp;rid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UnlockRow</span><span class="params">(Transaction *txn, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid, <span class="type">const</span> RID &amp;rid, <span class="type">bool</span> force = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>每个事务要访问数据前都需要通过这些接口获取特定的锁。LM类内部检查这个锁是否可用，是的话就让该事务获取锁（GRANT）然后执行，否则的话就阻塞（BLOCK）该事务，或者直接中止（ABORT）该事务。同时，它也会进行周期性的死锁检测，避免2pl的死锁问题。</p>
<p>在task1，我们需要实现LM的lock/unlock基本功能；在task2，我们需要实现LM的死锁检测功能；在task3，我们需要运用LM来保证executor执行时的并发安全。</p>
<h3 id="Task-1-Lock-Manager"><a href="#Task-1-Lock-Manager" class="headerlink" title="Task #1 - Lock Manager"></a>Task #1 - Lock Manager</h3><blockquote>
<p>The only file you need to modify for this task is the <code>LockManager</code> class (<code>concurrency/lock_manager.cpp</code> and <code>include/concurrency/lock_manager.h</code>). You must implement the following functions:</p>
<ul>
<li><code>LockTable(Transaction, LockMode, TableOID)</code></li>
<li><code>UnlockTable(Transction, TableOID)</code></li>
<li><code>LockRow(Transaction, LockMode, TableOID, RID)</code></li>
<li><code>UnlockRow(Transaction, TableOID, RID, force)</code></li>
</ul>
<p>The LM’s specific locking mechanism depends on the transaction isolation level, whether it is a table-level or tuple-level lock, and the type of lock involved. Make sure you are familiar with the <code>Transaction</code> class’s API and member variables, defined in <code>transaction.h</code> and <code>lock_manager.h</code> Then, carefully read through <code>[LOCK_NOTE]</code>, <code>[UNLOCK_NOTE]</code>, and the LM’s functions’ specifications (in <code>lock_manager.h</code>).</p>
<p>The <code>UnlockRow</code> has a <code>force</code> parameter because executor implementations might need to determine whether a tuple is accessible before deciding whether to include it. If <code>force</code> is set to true, the operation bypasses all 2PL checks as if the tuple is not locked.</p>
<p>For <code>UnlockRow</code>, we have a <code>force</code> parameter, because in the executor implementation, we might need to <em>peek</em> whether a tuple is accessible by a transaction before deciding whether to scan this tuple to parent executors. If <code>force</code> is set to true, this operation bypasses all 2PL checks as if the tuple is never locked by the transaction.</p>
<p><strong>HINTS</strong></p>
<ul>
<li>Think carefully about when do you need to upgrade a lock, and about what operations on the <code>LockRequestQueue</code> is needed when you need to update a table/tuple lock.</li>
<li>You will need some way to notify waiting transactions when a lock is available. We recommend using <code>std::condition_variable </code>provided as part of <code>LockRequestQueue</code>.</li>
<li>The lock manager should update the state of transactions as needed. For example, the state of a transaction may be changed from <code>GROWING</code> to <code>SHRINKING</code> by an <code>unlock</code> operation. See the methods in <code>transaction.h</code></li>
<li>You should keep track of the locks acquired by a transaction using <code>*_lock_set_</code> so that the <code>TransactionManager</code> can release locks appropriately when it commits or aborts a transaction.</li>
<li>Setting a transaction’s state to ABORTED implicitly aborts it, but it is not explicitly aborted until <code>TransactionManager::Abort</code> is called. You should read this function and the provided tests to understand what it does and how your lock manager is used in the abort process.</li>
</ul>
</blockquote>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>要结合bustub支持的特性实现LM的lock/unlock基本功能，首先要明确lock/unlock函数的基本框架：</p>
<p>对于Lock()类函数，</p>
<ol>
<li>检验加锁合法性，不合法则中止事务</li>
<li>一个循环，内部不断尝试获取锁，获取不到则沉睡等待唤醒</li>
</ol>
<p>对于Unlock()类函数，</p>
<ol>
<li>检验解锁合法性，不合法则中止事务</li>
<li>进行解锁相关操作，唤醒所有沉睡中事务</li>
</ol>
<p>接下来，先介绍LM的数据结构，然后再从这三方面详细介绍LM中Lock()的实现：整体沉睡唤醒机制、合法性检测以及更新锁的实现。最后再在第四部分单独说明实现较为简单的Unlock()。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>LM的作用是管理所有资源的锁，而在bustub中资源粒度只为“table”和“tuple”。故而，只需有两个类似map的数据结构，分别记录表锁和行锁信息即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Structure that holds lock requests for a given table oid */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">table_oid_t</span>, std::shared_ptr&lt;LockRequestQueue&gt;&gt; table_lock_map_;</span><br><span class="line"><span class="comment">/** Coordination */</span></span><br><span class="line">std::mutex table_lock_map_latch_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Structure that holds lock requests for a given RID */</span></span><br><span class="line">std::unordered_map&lt;RID, std::shared_ptr&lt;LockRequestQueue&gt;&gt; row_lock_map_;</span><br><span class="line"><span class="comment">/** Coordination */</span></span><br><span class="line">std::mutex row_lock_map_latch_;</span><br></pre></td></tr></table></figure>

<p>其中<code>LockRequestQueue</code>记录了每个资源锁队列信息，具体结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockRequestQueue</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 阻塞于该资源的请求队列 */</span></span><br><span class="line">    std::list&lt;LockRequest *&gt; request_queue_;</span><br><span class="line">    <span class="comment">/** 用于对request_queue_内部线程进行同步，下下小节细说 */</span></span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    <span class="comment">/** 用于lock upgrade的实现，之后细说 */</span></span><br><span class="line">    <span class="type">txn_id_t</span> upgrading_ = INVALID_TXN_ID;</span><br><span class="line">    <span class="comment">/** 用于保护本结构 */</span></span><br><span class="line">    std::mutex latch_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockRequest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Txn_id of the txn requesting the lock */</span></span><br><span class="line">    <span class="type">txn_id_t</span> txn_id_;</span><br><span class="line">    <span class="comment">/** Locking mode of the requested lock */</span></span><br><span class="line">    LockMode lock_mode_;</span><br><span class="line">    <span class="comment">/** Oid of the table for a table lock; oid of the table the row belong to for a row lock */</span></span><br><span class="line">    <span class="type">table_oid_t</span> oid_;</span><br><span class="line">    <span class="comment">/** Rid of the row for a row lock; unused for table locks */</span></span><br><span class="line">    RID rid_;</span><br><span class="line">    <span class="comment">/** 记录该请求是否已经被授权 */</span></span><br><span class="line">    <span class="type">bool</span> granted_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相当于每个table OR tuple都有一个等待的事务队列，和它自己的锁。</p>
<h4 id="FIFO沉睡唤醒机制"><a href="#FIFO沉睡唤醒机制" class="headerlink" title="FIFO沉睡唤醒机制"></a>FIFO沉睡唤醒机制</h4><blockquote>
<p>感觉这里还是很有含金量的，通过<code>std::condition_variable</code>实现一个自定义的FIFO锁。</p>
</blockquote>
<h5 id="c-知识"><a href="#c-知识" class="headerlink" title="c++知识"></a>c++知识</h5><p><code>std::condition_variable</code> 是 C++ 标准库中用于线程间同步的工具之一，它通常与 <code>std::mutex</code> 一起使用，用于实现在特定条件下的线程等待和唤醒操作。<code>std::condition_variable</code> 提供了一种方式，允许一个线程等待另一个线程满足某个特定条件，然后通知等待的线程条件已经满足。</p>
<p>下面是一个简单的示例，演示了 <code>std::condition_variable</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitForCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Condition satisfied! Doing some work.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">waitingThread</span><span class="params">(waitForCondition)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    </span><br><span class="line">    waitingThread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的<code>unique_lock</code>值得注意。这东西和lock guard差不多，区别可能就在于<code>std::unique_lock</code> 提供了更多的灵活性，允许手动锁定和释放互斥量，并且在不同的作用域内多次锁定和解锁。一般都会将它传给条件变量的wait函数。</p>
<p>条件变量的基本流程图原理可见下图（来自<a href="https://blog.csdn.net/qq_39277419/article/details/99544724">condition_variable 条件变量</a>）：</p>
<p><img src="/2023/03/13/cmu15445/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mjc3NDE5,size_16,color_FFFFFF,t_70.jpeg" alt="在这里插入图片描述"></p>
<p><img src="/2023/03/13/cmu15445/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mjc3NDE5,size_16,color_FFFFFF,t_70-1707395142292-3.jpeg" alt="在这里插入图片描述"></p>
<p>可见，它其实就是在外部上锁，然后内部解锁，等到被唤醒再次获取锁。故而，我们可以用它实现沉睡唤醒机制。</p>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>由文档可得：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Both <span class="title function_">LockTable</span><span class="params">()</span> and <span class="title function_">LockRow</span><span class="params">()</span> are blocking methods; they should wait till the lock is granted and then <span class="keyword">return</span>. If the transaction was aborted in the meantime, <span class="keyword">do</span> not grant the lock and <span class="keyword">return</span> <span class="literal">false</span>.</span><br><span class="line">Unlocking a resource should also grant any new lock requests <span class="keyword">for</span> the resource (<span class="keyword">if</span> possible).</span><br></pre></td></tr></table></figure>

<p>由此我们可知lock和unlock的大抵机制。在lock中，如果当前不可用，则沉睡等待唤醒；unlock之后则通知所有线程。</p>
<p>我们可以通过<code>LockRequestQueue</code>结构体中的条件变量<code>cv_</code>来实现<strong>沉睡唤醒机制</strong>。而沉睡唤醒机制实现要点之一就是明确<strong>沉睡的条件</strong>。</p>
<p>LM的实现要求使用<strong>FIFO顺序</strong>来满足事务请求，而<code>std::condition_variable</code>的<code>notify_one</code>方法是按随机顺序的。所以我们只能手动使用<code>LockRequestQueue.request_queue_</code>队列来模拟FIFO，也即<u>仅当当前线程为队首元素，才进行锁的授权</u>。</p>
<p>除此之外，还需注意一点，也即要求如果请求队列中有多个锁能被满足，那么需要对它们<u>同时一次性授权</u>。比如说，假定当前请求队列为“SSXSX”，那么此次授权之后的请求队列应为“<u>SS</u>XSX”。（划线表示已授权）</p>
<p>其中，这个“满足”关系可被理解为<strong>兼容</strong>。锁之间的兼容矩阵如下图所示：</p>
<p><img src="/2023/03/13/cmu15445/webp.webp" alt="img"></p>
<p>故而，结合上述两点后，可得我们最终实现的<strong>沉睡条件</strong>：<u>当且仅当该请求与它前面所有请求都兼容，才能授权该请求</u>。以<code>LockTable()</code>为例，最终形成如下代码（伪码表示）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockManager::LockTable</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">table_oid_t</span> &amp;oid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = table_lock_map_.<span class="built_in">find</span>(oid);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">req_queue_lock</span><span class="params">(it-&gt;second-&gt;latch_)</span></span>;</span><br><span class="line">  it-&gt;second-&gt;request_queue_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid)); <span class="comment">// 加入当前请求到队尾</span></span><br><span class="line">  <span class="keyword">auto</span> req_it = std::<span class="built_in">prev</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前锁需要插入</span></span><br><span class="line">  <span class="keyword">switch</span> (lock_mode) &#123; <span class="comment">// 不同的锁类型有不同的机制，在此仅以S/X锁为例</span></span><br><span class="line">      <span class="keyword">case</span> LockMode::EXCLUSIVE: <span class="comment">// X锁不与任何其它锁兼容，故要求当前请求前面的为空</span></span><br><span class="line">        <span class="comment">// 注意这里不能直接判empty。因为有可能在wait过程中请求队列尾插了新的请求</span></span><br><span class="line">        <span class="keyword">while</span> (!(std::<span class="built_in">all_of</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(), req_it, [is_upgraded](LockRequest* req) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;))) &#123;</span><br><span class="line">          it-&gt;second-&gt;cv_.<span class="built_in">wait</span>(req_queue_lock);</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 注意需要更新it，因为stl的容器增删元素后迭代器不会始终指向原来那个元素……</span></span><br><span class="line">        <span class="keyword">for</span> (req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LockMode::SHARED: <span class="comment">// S锁只与S和IS兼容，故要求当前请求前面的为空或者全都是兼容类型</span></span><br><span class="line">        <span class="keyword">while</span> (!(std::<span class="built_in">all_of</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(), req_it, [is_upgraded](LockRequest* req) &#123; <span class="keyword">return</span> req-&gt;lock_mode_ == LockMode::SHARED || req-&gt;lock_mode_ == LockMode::INTENTION_SHARED; &#125;))) &#123;</span><br><span class="line">          it-&gt;second-&gt;cv_.<span class="built_in">wait</span>(req_queue_lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  (*req_it)-&gt;granted_ = <span class="literal">true</span>; <span class="comment">// 标记为已授权</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而唤醒机制就相较简单了，只需在unlock时移出队列并且调用<code>notify_all</code>即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LockManager::UnlockTable</span><span class="params">(Transaction *txn, <span class="type">table_oid_t</span> &amp;oid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = table_lock_map_.<span class="built_in">find</span>(oid);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">req_queue_lock</span><span class="params">(it-&gt;second-&gt;latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123; <span class="comment">// 移出队列</span></span><br><span class="line">      <span class="built_in">BUSTUB_ASSERT</span>((*req_it)-&gt;granted_, <span class="string">&quot;Must have been granted in unlock function!&quot;</span>);</span><br><span class="line">      <span class="built_in">delete</span> (*req_it);</span><br><span class="line">      it-&gt;second-&gt;request_queue_.<span class="built_in">erase</span>(req_it);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知其余线程</span></span><br><span class="line">  it-&gt;second-&gt;cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="合法性检测"><a href="#合法性检测" class="headerlink" title="合法性检测"></a>合法性检测</h4><p>我将合法性检验放在了整个函数的最前面。具体来说，需要考虑以下几个因素：</p>
<ol>
<li><p>隔离级别</p>
<ol>
<li><p>隔离级别是否支持这种类型的锁？</p>
<p>比如说<code>READ_UNCOMMITTED</code>级别就不支持IS/S/SIX锁，抛出<code>LOCK_SHARED_ON_READ_UNCOMMITTED</code>异常；</p>
<p>对于不同的隔离级别，在SHRINKING阶段允许加的锁的类型也不同。</p>
<p>具体可以看background部分关于隔离级别的介绍。</p>
</li>
</ol>
</li>
<li><p>其它</p>
<p>比如说对于行锁，它需要检测是否已经获取了对应的表锁。这里测试似乎遵循事务与线程一一对应的原则，所以我们应该只用在行锁的前面检测是否获取表锁就行，不用担心执行着执行着表锁没了的情况。我在此采用了通过txn的set判断的方法从而避免了对资源锁的争夺：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> holding_table_lock = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (lock_mode == LockMode::SHARED) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((txn-&gt;<span class="built_in">GetSharedTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetSharedTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetIntentionSharedTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetIntentionSharedTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) !=</span><br><span class="line">       txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>())) &#123;</span><br><span class="line">    holding_table_lock = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) != txn-&gt;<span class="built_in">GetIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>()) ||</span><br><span class="line">      (txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">find</span>(oid) !=</span><br><span class="line">       txn-&gt;<span class="built_in">GetSharedIntentionExclusiveTableLockSet</span>()-&gt;<span class="built_in">end</span>())) &#123;</span><br><span class="line">    holding_table_lock = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="锁的更新"><a href="#锁的更新" class="headerlink" title="锁的更新"></a>锁的更新</h4><blockquote>
<p><strong>LOCK UPGRADE:</strong><br>Calling Lock() on a resource <u>that is already locked</u> should have the following behaviour:</p>
<ul>
<li><p>If requested lock mode is the same as that of the lock presently held, Lock() should return true since it already has the lock.</p>
<p>lock_mode不变，则简单地return true</p>
</li>
<li><p>If requested lock mode is different, Lock() should upgrade the lock held by the transaction.</p>
<p>lock_mode有变，需要进行锁的更新</p>
</li>
</ul>
<p>   A lock request being upgraded should be prioritised over other waiting lock requests on the same resource. 这句话值得注意！！！更新锁这个请求是<strong>最高级</strong>的，需要优先处理！！</p>
<p>   While upgrading, <u>only the following transitions should be allowed:</u> 只有下列情况的更新合法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IS -&gt; [S, X, IX, SIX]</span><br><span class="line">S -&gt; [X, SIX]</span><br><span class="line">IX -&gt; [X, SIX]</span><br><span class="line">SIX -&gt; [X]</span><br></pre></td></tr></table></figure>

<p>   Any other upgrade is considered incompatible, and such an attempt should set the TransactionState as ABORTED and throw a TransactionAbortException (INCOMPATIBLE_UPGRADE)</p>
<p>   Furthermore, only one transaction should be allowed to upgrade its lock on a given resource. Multiple concurrent lock upgrades on the same resource should set the TransactionState as ABORTED and throw a TransactionAbortException (UPGRADE_CONFLICT). 不能多个事务同时对某个资源更新锁</p>
</blockquote>
<p>常常涉及这么一种情况：事务持有S锁，接下来又想申请将自己的S锁转化为X锁。不能简单地先释放S锁再继续申请X锁，因为这会产生一段未加锁区域从而有并发安全隐患。这时候就需要引入锁的更新。</p>
<p>锁的更新其实就相当于是在锁对象内部实现一个先释放再申请的原子操作了。它是这样保证更新操作的原子性的：</p>
<ol>
<li>释放原有锁</li>
<li>控制其它所有目前未获取到锁的事务都不能再获取锁（也即，<strong>更新锁优先级最高</strong>，其它为授权的锁申请都只能等待直到更新锁完成）</li>
<li>等待直到目标更新锁可获取</li>
</ol>
<p>这样一来，就能保证那段真空的未加锁区域不会被别的事务抢占先机了。故而，这里涉及到两个关键问题的处理，一个是如何实现锁的更新，另一个就是如何保证更新锁的优先级。</p>
<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><p>我这里给出的解决方案是，对更新时的更新锁和非更新锁进行分别的处理。</p>
<ol>
<li><p>更新锁</p>
<p>我的实现是在<u>释放旧锁之后</u>进行锁的争取。首先，释放旧锁，但是<u>不调用</u><code>notify_all</code>；如果当前队列中存在正在执行中的并且与新锁相冲突的请求（也即只有在队列中仅存在【兼容的 || 不兼容但还没被授权】的请求时才获取锁），则等待该请求释放。</p>
<blockquote>
<p>这里我本来打算实现先不释放旧锁，等到获取到新锁之后再释放旧锁。也即：</p>
<p>比方说S-&gt;X的情况，①先删除S的授权，然后再走常规锁的流程获取X的授权（也即有没有锁的时期），②先获取X的授权，再删除S的授权（也即有兼有S和X锁的时期）</p>
<p>我本来是选择②的，但现在发现完全没必要这么做，因为这是锁的内部实现，中间这段空窗期是不会有新的事务获取到该资源的（一个是不进行notify，另一个是更新锁优先级最高），故而为实现简单起见（<strong>并且线上测试也是要求先释放锁……</strong>）选择了先释放再获取。</p>
</blockquote>
<p>然后，直到更新锁被唤醒后，将自己插入到请求队列头（头插表示优先级最高）。至此成功被授权。</p>
</li>
<li><p>非更新锁</p>
<p>当更新锁在争取锁时，控制其它所有请求都不争夺授权（也即一直保持ungranted状态，表示优先级最高）。直到冲突请求释放，更新锁被授权，才回到正常的控制流中。</p>
</li>
</ol>
<p>其具体伪代码如下所示（仅以shared为例）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> is_upgraded = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/* case of upgrade */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">    it-&gt;second-&gt;upgrading_ = txn-&gt;<span class="built_in">GetTransactionId</span>();</span><br><span class="line">    is_upgraded = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 先进行解锁操作，但不会进行notify</span></span><br><span class="line">    <span class="built_in">delete</span> (*req_it);</span><br><span class="line">    it-&gt;second-&gt;request_queue_.<span class="built_in">erase</span>(req_it);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!is_upgraded) &#123;	<span class="comment">// 非更新锁的正常控制流。更新锁在后面才插入到队列的首部（表示优先级最高）</span></span><br><span class="line">  it-&gt;second-&gt;request_queue_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> req_it = std::<span class="built_in">prev</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (is_upgraded) &#123;	<span class="comment">// 更新锁需要关注整个队列，而不是它之前的队列</span></span><br><span class="line">  req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (lock_mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> LockMode::SHARED:</span><br><span class="line">    <span class="comment">// 这里条件比较复杂</span></span><br><span class="line">    <span class="comment">// 对于除了更新锁以外的其它锁，第一个条件分支满足，所以就一直等待，直到</span></span><br><span class="line">    <span class="comment">// it-&gt;second-&gt;upgrading_变为INVALID_TXN_ID，也即更新完成</span></span><br><span class="line">    <span class="comment">// 这体现了更新锁的最高级优先级</span></span><br><span class="line">    <span class="keyword">while</span> ((it-&gt;second-&gt;upgrading_ != INVALID_TXN_ID &amp;&amp; !is_upgraded) ||</span><br><span class="line">    <span class="comment">// 而对于更新锁，第一个条件为false，故而看第二个条件</span></span><br><span class="line">    <span class="comment">// 只有在队列中仅存在兼容的（原本控制流中的lock_mode判断语句），    </span></span><br><span class="line">    <span class="comment">// 或者不兼容但还没被授权（(!(req-&gt;granted_)）的请求时才获取锁</span></span><br><span class="line">            (!(std::<span class="built_in">all_of</span>(it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(), req_it,</span><br><span class="line">               [is_upgraded, txn, it](LockRequest *req) &#123;</span><br><span class="line">                 <span class="comment">// 【不兼容但还没被授权 || 自己的旧锁 || 兼容的】</span></span><br><span class="line">                 <span class="built_in">return</span> (is_upgraded &amp;&amp; (!(req-&gt;granted_))) || (txn-&gt;<span class="built_in">GetTransactionId</span>() == it-&gt;second-&gt;upgrading_) || req-&gt;lock_mode_ == LockMode::SHARED || req-&gt;lock_mode_ == LockMode::INTENTION_SHARED; &#125;)))) </span><br><span class="line">    &#123;</span><br><span class="line">      it-&gt;second-&gt;cv_.<span class="built_in">wait</span>(req_queue_lock);</span><br><span class="line">      <span class="comment">// 跟上面一样需要更新it</span></span><br><span class="line">      <span class="keyword">if</span> (is_upgraded) &#123;</span><br><span class="line">        req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (req_it = it-&gt;second-&gt;request_queue_.<span class="built_in">begin</span>(); req_it != it-&gt;second-&gt;request_queue_.<span class="built_in">end</span>(); ++req_it) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((*req_it)-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_upgraded) &#123;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  <span class="keyword">auto</span> upgraded_req = <span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid);</span><br><span class="line">  upgraded_req-&gt;granted_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 更新锁插入到队头，体现其优先级最高</span></span><br><span class="line">  it-&gt;second-&gt;request_queue_.<span class="built_in">push_front</span>(upgraded_req);</span><br><span class="line">  <span class="comment">// 表明更新完成</span></span><br><span class="line">  it-&gt;second-&gt;upgrading_ = INVALID_TXN_ID;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  (*req_it)-&gt;granted_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="更新锁的唯一性"><a href="#更新锁的唯一性" class="headerlink" title="更新锁的唯一性"></a>更新锁的唯一性</h5><p>除此之外，对于某一个资源，同一时刻只能有一个事务更新锁，不然会引发死锁问题，因为机制是持有旧锁的情况下更新新锁。</p>
<p>具体来说可以这样理解：（参考自<a href="https://blog.csdn.net/weixin_46879188/article/details/113882685">https://blog.csdn.net/weixin_46879188/article/details/113882685</a> 加一些个人实现理解）</p>
<p>一般更新模式由一个事务组成，此事务读取记录，获取资源的S锁，然后修改行，此操作要求锁转换为X锁。</p>
<p>如果两个事务获得了资源上的S锁，然后试图同时更新数据，则一个事务尝试将锁转换为X锁，此时锁队列变化情况为：<code>SS-&gt;SX</code>，发生锁等待。</p>
<p>第二个事务也试图获取X锁以进行更新，注意此刻它是不进行notify地释放锁。这时候，它会由于不满足<code>it-&gt;second-&gt;upgrading_ != INVALID_TXN_ID</code>这个条件（用于保障更新锁的最高优先级）而一直卡住，另一个事务也迟迟收不到notify，从而导致死锁情况发生。</p>
<p>那么可能就要问了，我们能不能修改一下沉睡的条件，也即将更新事务从一个拓展为一个数组，然后限制多个同时获取更新锁的情况下一个真获取其他等待呢？那么我们也很容易从结果看出，这种情况下不也跟同一时刻只能有一个事务更新锁是一个道理。。。所以不如简单粗暴地限制这个条件。</p>
<p>因此，在bustub实现中，当遇到更新冲突时，我们选择直接终止回滚事务。</p>
<h3 id="Task-2-Deadlock-Detection"><a href="#Task-2-Deadlock-Detection" class="headerlink" title="Task #2 - Deadlock Detection"></a>Task #2 - Deadlock Detection</h3><blockquote>
<p>Your lock manager should run deadlock detection in a background thread, periodically building a <strong>waits-for graph</strong> and abort transactions as needed to eliminate deadlocks.</p>
<p><strong>REQUIREMENTS</strong></p>
<p>You must implement and use the following graph API for <strong>cycle detection</strong>:</p>
<ul>
<li><code>AddEdge(txn_id_t t1, txn_id_t t2)</code>: Adds an edge in your graph from <code>t1</code> to <code>t2</code>, representing that <code>t1</code> is waiting for <code>t2</code>. If the edge already exists, you don’t have to do anything.</li>
<li><code>RemoveEdge(txn_id_t t1, txn_id_t t2)</code>: Removes edge <code>t1</code> to <code>t2</code> from your graph. If no such edge exists, you don’t have to do anything.</li>
<li><code>HasCycle(txn_id_t&amp; txn_id)</code>: Looks for a cycle by using depth-first search (DFS). If it finds a cycle, <code>HasCycle</code> should store the transaction id of the youngest transaction in the cycle in <code>txn_id</code> and return true. Your function should return the first cycle it finds. If your graph has no cycles, <code>HasCycle</code> should return false.</li>
<li><code>GetEdgeList()</code>: Returns a list of tuples representing the edges in your graph. We will use this to test correctness of your graph. A pair <code>(t1,t2)</code> corresponds to an edge from <code>t1</code> to <code>t2</code>.</li>
<li><code>RunCycleDetection()</code>: Contains skeleton code for running cycle detection in the background. You should implement your cycle detection algorithm here.</li>
</ul>
<p>You may implement the graph however you want, as long as you support the above API. We will use that API to test your implementation.</p>
<p>You may need to access the status of a transaction from the member variable <code>txn_manager_</code>. If <code>txn_manager_</code> is set to <code>nullptr</code>, <code>StartDeadlockDetection</code> will not be called, and you do not need to detect deadlocks.</p>
<p><strong>HINTS</strong></p>
<ul>
<li><p>Your background cycle detection algorithm may need to get a pointer to a transaction using a <code>txn_id</code>. There is a member variable <code>txn_manager_</code> in lock manager, and <code>Transaction* GetTransaction(txn_id_t txn_id)</code> enables you do that.</p>
</li>
<li><p>You can also tweak <code>CYCLE_DETECTION_INTERVAL</code> in <code>common/config.h</code> in your test cases.</p>
</li>
</ul>
</blockquote>
<h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>这里相当于是对上文background部分提到的死锁检测算法的一个简化。我们视锁为一个资源，故而每个资源类中仅有一个资源（互斥锁），所以当存在环路时，我们就可以直接判断存在死锁。而由于只有一个资源，所以资源结点其实是没什么必要的，所以我们就简化为了简单的每个顶点都为一个事务、边表示事务等待关系的图形式（waits-for graph），将问题转化为<strong>找出该图的环</strong>，如果环存在，则说明产生了死锁。</p>
<p>本次任务在此基础上的额外要求是：</p>
<ol>
<li><p>一个事务可能有多条指向其他事务的边</p>
<blockquote>
<p>Remember that the waits-for graph is a directed graph, with an edge for each transaction waiting for another transaction. Because multiple transactions may share a lock on the same object, a single transaction may be waiting for multiple transactions.</p>
</blockquote>
<p>比如说<code>SSSX</code>，此时队列中的X对应事务就会有三条边。</p>
</li>
<li><p>图不能动态维护，必须在bg进程中实时创建/销毁</p>
<blockquote>
<p>Your background thread should build the waits-for graph every time it wakes up. <strong>You should not maintain the waits-for graph over time</strong>; it should be built and destroyed every time the deadlock detection thread wakes up.</p>
</blockquote>
<p>不能动态维护waits-for图，它是由死锁检测进程一次性创建的。也即，我们需要在<code>RunCycleDetection</code>函数中获取table_map锁和row_map锁，来进行waits-for表时的构建。</p>
<blockquote>
<p>已产生死锁情况下，死锁检测进程再获取这两个锁会不会死上加死？</p>
<p>其实不会。仔细结合下我们的实现，在死锁的情况下，两个死锁进程都是在wait()条件变量中沉睡的，此时是释放了表锁和行锁状态，所以我们的死锁检测进程这时候获取锁是安全的，不会死上加死。</p>
</blockquote>
</li>
<li><p>环的检测结果需要是确定性的</p>
<blockquote>
<p>Your cycle detection algorithm must be <strong>deterministic</strong>. To achieve this, you should always explore the lowest transaction id first, by starting the depth-first search from the node with lowest transaction id and exploring neighbors in order (by transaction id) when searching from a node.</p>
</blockquote>
<p>也即如果图中包含多个环，需要以固定的次序返回这些环。为此，我们需要按照<code>txn_id</code>的顺序来遍历整个图。</p>
</li>
<li><p>当检测到环时，需要对环中最年轻（youngest）的事务进行abort来破除死锁</p>
<blockquote>
<p>When you find a cycle, abort the <strong>youngest</strong> transaction to break the cycle by setting that transaction’s state to ABORTED.</p>
</blockquote>
<p>并且这时候，需要进行一次notify，防止这个正在处于abort状态的进程一直沉睡，导致无法真正abort。</p>
<blockquote>
<p>A transaction waiting for a lock may be aborted by the background cycle detection thread. You must have a way to notify waiting transactions that they’ve been aborted.</p>
</blockquote>
</li>
</ol>
<h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p>图的数据结构为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">txn_id_t</span>, std::set&lt;<span class="type">txn_id_t</span>&gt;&gt; waits_for_;</span><br></pre></td></tr></table></figure>

<p>由于要求通过保证DFS遍历顺序来确保结果的确定性，并且两个事务间只会有一条边，故而使用了有序的map和set。</p>
<p>实现图中找环的DFS算法也是比较简单的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> LockManager::FindCycle &#123;</span><br><span class="line">  <span class="keyword">if</span> (visited.<span class="built_in">find</span>(source_txn) != visited.<span class="built_in">end</span>()) &#123;  <span class="comment">// has cycle</span></span><br><span class="line">    <span class="comment">// delete no-circle prefix</span></span><br><span class="line">    <span class="comment">// 注意需要删除path中[path.begin(), path.find(source_txn))</span></span><br><span class="line">    <span class="comment">// 这个区间内的元素，因为我们只需要环的路径</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  visited.<span class="built_in">insert</span>(source_txn);</span><br><span class="line">  path.<span class="built_in">push_back</span>(source_txn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : waits_for_[source_txn]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FindCycle</span>(edge, path, visited)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  visited.<span class="built_in">erase</span>(visited.<span class="built_in">find</span>(source_txn));</span><br><span class="line">  path.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> LockManager::HasCycle&#123;</span><br><span class="line">  <span class="keyword">if</span> (waits_for_.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;	<span class="comment">// 剪枝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;wait_pair : waits_for_) &#123;	<span class="comment">// 此处需要一个for循环，因为不一定是连通图</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FindCycle</span>(wait_pair.first, path, visited)) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后整个检测的逻辑也是比较简单的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LockManager::RunCycleDetection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (enable_cycle_detection_) &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(cycle_detection_interval);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 1. build wait-for graph</span></span><br><span class="line">      <span class="comment">// 遍历table lock map和row lock map，填写wait-for graph</span></span><br><span class="line">      <span class="comment">// 我只对这种情况进行处理：txn1-&gt;txn2，其中txn1-&gt;granted==false,txn2-&gt;granted==true</span></span><br><span class="line">      <span class="comment">// 毕竟感觉这样才是比较显式的死锁……</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 2. detect cycle and abort txn</span></span><br><span class="line">      <span class="type">txn_id_t</span> abort_txn;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">HasCycle</span>(&amp;abort_txn)) &#123;</span><br><span class="line">        <span class="comment">// 2.1. do an abort</span></span><br><span class="line">        txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 2.2. notify related txns</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;lock_req : sleep_for[abort_txn]) &#123;</span><br><span class="line">          <span class="comment">// 上面维护了sleep_for，表明该事务正在等待哪些资源</span></span><br><span class="line">          lock_req-&gt;cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        sleep_for.<span class="built_in">erase</span>(sleep_for.<span class="built_in">find</span>(abort_txn));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3. delete all related edges of wait-for graph</span></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3. destory waot-for graph</span></span><br><span class="line">      waits_for_.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说比较简单，没什么好说的。</p>
<h3 id="Task-3-Concurrent-Query-Execution"><a href="#Task-3-Concurrent-Query-Execution" class="headerlink" title="Task #3 - Concurrent Query Execution"></a>Task #3 - Concurrent Query Execution</h3><blockquote>
<p>To support concurrent query execution, executors must lock and unlock tables and tuples as needed to achieve the isolation level specified in the transaction. To simplify this task, you can <u>ignore concurrent index execution and just focus on data stored in heap files</u>.</p>
<p><strong>忽略索引</strong>，只关注涉及数据修改的地方</p>
<p>You must update methods of some executors implemented in Project 3. </p>
<p>Note that <u>transactions should abort when lock/unlock fails</u>. If a transaction aborts, you will <u>need to undo</u> its previous write operations; to achieve this, you will need to <strong>maintain the write set</strong> in each transaction, which is used by the <code>Abort()</code> method of the transaction manager. </p>
<p><strong>需要实现UNDO撤销事务</strong></p>
<p>If the executor fails to acquire a lock, you should throw an <code>ExecutionException</code> so that the execution engine will tell the user that the query failed.</p>
<p>当获取锁失败时（也即LM的方法<code>return false</code>或者抛出<code>TransactionAbortException</code>时），executor需要抛出<code>ExecutionException</code>。</p>
<p>You should not assume that a transaction only consists of just one query. Specifically, this means a tuple might be accessed by different queries more than once in a transaction. Think about how you should handle this under different isolation levels.</p>
<p>一个事务可能包括多个sql，也即一个tuple可能会在事务中以不同形式被访问多次。需要结合隔离级别来思考这个问题的处理方式。</p>
</blockquote>
<h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>在上面的部分中我们实现了LM，在这个task中我们需要把LM应用到实际的数据库执行之中。</p>
<p>我们使用的是火山模型，故而可以比较方便地实现2PL协议。以<code>REPEATED_READ</code>级别下的2PL为例，我们只需在每个executor的<code>Init</code>中获取表锁，在<code>Next</code>中获取行锁，最后在事务<code>Commit/Abort</code>时释放，自火山模型自顶向下都依照这个规律，即可实现GROWING阶段和SHRINKING阶段的分离。</p>
<p>那么，我们具体来说需要修改哪些executor的实现呢？首先，为了简化起见，bustub忽略对使用索引情况的并发控制，以及对update的并发控制（只在leaderboard中要求）。其次，那些<strong>针对中间表进行处理</strong>的executor也不用【因为中间产物不可能会被并发访问……】，如nlj、hash join、聚合函数实现等等。故而，剩下的便只有对底层表直接访问的executor，也即<strong>seq scan executor</strong>和<strong>insert executor</strong>（delete executor通过seq scan executor实现，所以无需额外加解锁）。</p>
<p>明确了需要修改哪些地方以进行加解锁之后，还有一点需要注意，也即回滚（rollback）的实现。当事务被终止（Abort）时，我们需要对它既定修改的部分进行回滚处理，这就需要我们在涉及修改底层表格的地方维护写集（write set），也即insert和delete。</p>
<p>总结下来，本任务需要修改这几个文件：</p>
<blockquote>
<p>To complete this task, you must add support for concurrent query execution in the following executors and the transaction manager:</p>
<ul>
<li><code>src/execution/seq_scan_executor.cpp</code></li>
<li><code>src/execution/insert_executor.cpp</code></li>
<li><code>src/execution/delete_executor.cpp</code></li>
<li><code>src/concurrency/transaction_manager.cpp</code></li>
</ul>
<p>You must pass all tests and produce correct results for the Terrier Benchmark (see below) without segfaults and deadlocks. You do not need to handle concurrency for indexes or the update executor, except for the leaderboard tests.</p>
</blockquote>
<p>接下来，将从两个方面进行详细的介绍。</p>
<h4 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h5><blockquote>
<p><strong>SeqScan Executor</strong></p>
<ul>
<li>In <code>Init</code>, take a table lock. Get an iterator by using <code>MakeEagerIterator</code> instead of <code>MakeIterator</code>. (<code>MakeIterator</code> is introduced to avoid the <strong>Halloween problem</strong>【下文详细说明】 in Project 3’s UpdateExecutor, but you do not need it now.)</li>
<li>In <code>Next</code><ol>
<li>Get the current position of the table iterator.</li>
<li>Lock the tuple as needed for the isolation level.</li>
<li>Fetch the tuple. Check tuple meta, and if you have implemented filter pushdown to scan, check the predicate.</li>
<li>If the tuple should not be read by this transaction, <strong>force unlock</strong> the row. Otherwise, unlock the row as needed for the isolation level.</li>
<li>If the current operation is delete (by checking executor context <code>IsDelete()</code>, which will be set to true for <code>DELETE</code> and <code>UPDATE</code>), you should assume all tuples scanned will be deleted, and you should take X locks on the table and tuple as necessary <em>in step 2</em>.</li>
</ol>
</li>
</ul>
<p><strong>Insert Executor</strong></p>
<ul>
<li>In <code>Init</code>, take a table lock.</li>
<li>In <code>Next</code>, pass the lock manager, transaction object, and table id to <code>InsertTuple</code> so as to insert and lock a tuple atomically.</li>
</ul>
</blockquote>
<p>它这边步骤说得很详细了，再次便不多说。</p>
<p>需要注意的有以下几点：</p>
<ol>
<li><p>表锁应该使用意图锁（IX/IS），行锁应该使用XS锁</p>
</li>
<li><p>insert只需用IX表锁，不用担心scan会遍历到新插入的元组是否有问题，因为这是依隔离级别而定的</p>
</li>
<li><p>注意一下不同隔离级别的要求，具体可以见background部分对隔离级别的介绍</p>
</li>
<li><p>锁更新的处理</p>
<p>需要考虑多次插入删除锁的更新情况，比如下面的例子，一个事务就是一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO result SELECT * FROM tmp; DELETE FROM tmp; SELECT count(*) FROM result;</span><br></pre></td></tr></table></figure>

<p>并且最后select是要能感知到前面的结果的。</p>
<p>这种情况下，为了避免死锁or abort问题，得先在获取S（IS）锁之前判断是否含有X（IX），是的话不获取，否则才获取。</p>
</li>
</ol>
<h5 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h5><blockquote>
<p><strong>Insert Executor</strong></p>
<ul>
<li>Be sure that you maintain the write set as needed.</li>
</ul>
<p><strong>Delete Executor</strong></p>
<ul>
<li>If you have implemented <code>SeqScanExecutor</code> correctly based on <code>IsDelete()</code> in executor context, you do not need to take any any locks in this executor.</li>
<li>Be sure that you maintain the write set in <code>Next</code>.</li>
</ul>
<p><strong>Transaction Manager</strong></p>
<ul>
<li>In <code>Commit</code>, you generally do not need to do anything except release all the locks.</li>
<li>In <code>Abort</code>, you should revert all changes of this transaction based on its write set.</li>
</ul>
</blockquote>
<p>要点：</p>
<ol>
<li><p>在insert和delete中增加对事务writeset修改的语句。这个只是调用api，没什么好说的</p>
</li>
<li><p>rollback实现</p>
<p>在abort中需要倒序遍历writeset进行UNDO：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = txn-&gt;<span class="built_in">GetWriteSet</span>()-&gt;<span class="built_in">rbegin</span>(); it != txn-&gt;<span class="built_in">GetWriteSet</span>()-&gt;<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> meta = it-&gt;table_heap_-&gt;<span class="built_in">GetTupleMeta</span>(it-&gt;rid_);</span><br><span class="line">    meta.is_deleted_ = !(meta.is_deleted_);	<span class="comment">// 对delete和insert都适用的写得方便的小trick</span></span><br><span class="line">    it-&gt;table_heap_-&gt;<span class="built_in">UpdateTupleMeta</span>(meta, it-&gt;rid_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Terrier-Benchmark"><a href="#Terrier-Benchmark" class="headerlink" title="Terrier Benchmark"></a>Terrier Benchmark</h4><p>大概就是，表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE nft(id INT, terrier INT);</span><br><span class="line">INSERT INTO nft VALUES (0, 0), (1, 1), ...;</span><br></pre></td></tr></table></figure>

<p>有两个线程，线程里不断循环运行着这样的两个事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- begin txn1</span><br><span class="line">SELECT * FROM nft WHERE id = &lt;nft_id&gt;; -- record the terrier_id</span><br><span class="line">DELETE FROM nft WHERE id = &lt;nft_id&gt;;</span><br><span class="line">-- end txn1</span><br><span class="line"></span><br><span class="line">-- begin txn2</span><br><span class="line">INSERT INTO nft VALUES (&lt;nft_id&gt;, &lt;terrier_id&gt;)</span><br><span class="line">-- end txn2</span><br></pre></td></tr></table></figure>

<p>除此之外还有另一个线程，线程里有这么个事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- begin txn3</span><br><span class="line">SELECT count(*) FROM nft WHERE terrier = &lt;terrier_id&gt;;</span><br><span class="line">SELECT count(*) FROM nft WHERE terrier = &lt;terrier_id&gt;;</span><br><span class="line">-- end txn3</span><br></pre></td></tr></table></figure>

<p>设定在<code>REPEATED_READ</code>级别下，所以两个查询结果应该一致。这样地检查，最后统计的指标是这三种事务的吞吐量以及终止事务的个数。</p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>首先就是特别傻的一个问题，terrier bench中不知怎的insert也成功了，但是select就是检测不到insert的结果……大概执行序列是这样的：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">insert txn <span class="keyword">begin</span>.</span><br><span class="line">scan txn <span class="keyword">begin</span>.</span><br><span class="line">insert txn commit.</span><br><span class="line">scan txn commit.</span><br></pre></td></tr></table></figure>

<p>看了半天没懂为什么insert txn已经提交scan txn还是看不到它的结果。。。最后发现是这里忘改了呃呃：</p>
<p><img src="/2023/03/13/cmu15445/image-20240226202841362.png" alt="image-20240226202841362"></p>
<h4 id="附：Halloween-Protection"><a href="#附：Halloween-Protection" class="headerlink" title="附：Halloween Protection"></a>附：Halloween Protection</h4><blockquote>
<p><strong>SeqScan Executor</strong></p>
<ul>
<li>In <code>Init</code>, take a table lock. Get an iterator by using <code>MakeEagerIterator</code> instead of <code>MakeIterator</code>. (<code>MakeIterator</code> is introduced to avoid the <strong>Halloween problem</strong> in Project 3’s UpdateExecutor, but you do not need it now.)</li>
</ul>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_34351321/article/details/90164892">什么是Halloween Problem</a></p>
<p><a href="https://www.cnblogs.com/LvanHades/p/4481497.html">sql server的处理方法</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/36758138">SQL 中的 Halloween Problem</a></p>
</blockquote>
<p>大概是说，update操作的实现方法为先delete再insert，并且一般优化它下面可能会连接一个index scan，就会导致在配合底层迭代器使用时，一个元组被更新多次，从而产生死循环、更新错误等问题。Sql Server为了防止该问题，采取了spool（一个用于缓存或存储中间结果的临时存储区域）来暂存原本的索引，遍历过程中也会转而遍历spool、写入真正的物理存储，从而防止索引乱套带来的问题。</p>
<p>而在Project#4中提到的“<code>MakeIterator</code> is introduced to avoid the Halloween problem in Project 3’s UpdateExecutor”，指的是我们在本次实验中会通过原地更新而非先删除再插入来实现update，所以就不会发生Halloween Problem。</p>
<p>接下来，我们可以了解一下Project#3中具体的防范实现。首先可以了解一下bustub会产生什么样的Halloween Problem。</p>
<p>由于bustub的删除不是真删除，而是采用标记+尾插法的方式，故而应该不会出现反复访问某个元组多次的现象（因为不会发生物理现象的位移）。真正需要防范的，是多个进程同时进行迭代和更新的现象。</p>
<p>比如说，进程A进行insert操作，进程B进行update操作。我们的原意是先update再insert，故而就算insert插入的新元组符合条件，我们也不应该将其进行update。但是，在不进行并发保护的情况下（也即project#3的情况），如果按照标准迭代器实现（也即遍历到表格末尾才停止），我们很有可能会连insert进来的新元组也遍历到，从而一起更新。</p>
<p>也即，update了多余的元组，这会是bustub中真正发生的Halloween Problem。防范方式相信也很直观了，就是<u>限制update中遍历的表范围为update时的表范围，不囊括之后插入的元组</u>。</p>
<p>我们是通过<code>MakeIterator</code>来实现防范的。看下<code>TableIterator</code>的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TableIterator</span>(TableHeap *table_heap, RID rid, RID stop_at_rid);</span><br></pre></td></tr></table></figure>

<p>可知它这实际上是一个区间结构，迭代范围为[rid, stop_at_rid)。当遇到<code>stop_at_rid</code>，迭代器就会使<code>IsEnd()</code>为真。</p>
<p>对比<code>MakeIterator</code>和<code>MakeEagerIterator</code>的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MakeIterator</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="keyword">this</span>, &#123;first_page_id_, <span class="number">0</span>&#125;, &#123;last_page_id, page-&gt;<span class="built_in">GetNumTuples</span>()&#125;&#125;;</span><br><span class="line"><span class="comment">// MakeEagerIterator</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="keyword">this</span>, &#123;first_page_id_, <span class="number">0</span>&#125;, &#123;INVALID_PAGE_ID, <span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>前者是以<code>last_page_id</code>为界，而后者以<code>INVALID_PAGE_ID</code>为界。其中，<code>last_page_id</code>表示当前表的最后一页物理页，会在insert之中被修改。这样一来，<code>MakeIterator</code>就能限制遍历的范围为当前创建的所有元组了。</p>
<p><u>而在Project#4中</u>，我们会实现update的原地更新，所以<strong>无需防范Halloween Problem的发生</strong>，故而无需使用<code>MakeIterator</code>，只使用<code>MakeEagerIterator</code>即可。</p>
<h3 id="Leaderboard"><a href="#Leaderboard" class="headerlink" title="Leaderboard"></a>Leaderboard</h3><p><img src="/2023/03/13/cmu15445/image-20240227223236821.png" alt="image-20240227223236821"></p>
<p>只能说前面性能烂了一路，到这里总的只会更烂hhh</p>
<p>运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j`<span class="built_in">nproc</span>` terrier-bench</span><br><span class="line">./bin/bustub-terrier-bench --duration 30000 --nft 10000</span><br></pre></td></tr></table></figure>

<p>它这里给了几个优化策略：</p>
<ol>
<li><p>谓词下推到seq scan</p>
<blockquote>
<p><strong>Predicate pushdown to SeqScan:</strong> You can implement a predicate filter in SeqScanExecutor so that you lock fewer tuples when doing SeqScan. You can enable MergeFilterScan optimizer rule <a href="https://github.com/cmu-db/bustub/blob/master/src/optimizer/merge_filter_scan.cpp"><code>merge_filter_scan.cpp</code></a> and implement this optimization.</p>
</blockquote>
<p>这个就是要enable<code>MergeFilterScan</code>，在p3已经开启了。</p>
</li>
<li><p>实现in-place的update操作</p>
<blockquote>
<p><strong>Implement In-Place UpdateExecutor:</strong> You can improve your UpdateExecutor implementation so that tuples can be updated in-place and will probably be more efficient. Modify <code>terrier_benchmark_config.h</code> to instruct Terriers to use <code>UPDATE</code> for exchanging NFTs.</p>
</blockquote>
<p>之前在terrier bench中都是通过先delete再insert实现，这里之后就直接调用update executor了。</p>
<p>实现方式也很简单，用函数<code>UpdateTupleInPlaceUnsafe</code>即可。</p>
<p>并且注意需要兼容Abort部分，需要维护写集，在Abort中恢复。但它给定的<code>TableWriteRecord</code>并没有记录old tuple的字段，所以我只得使用<code>IndexWriteRecord</code>来凑数了。</p>
<p>需要注意的一点是，我此处的in-place update的实现并没有更新索引，也即默认它更新字段是不包括索引字段的。这仅能通过terrier bench，会寄在p3的index scan test。</p>
</li>
<li><p>使用索引</p>
<blockquote>
<p><strong>Use Index:</strong> You can create an index over the NFT table, and then push the predicate down to IndexScanExecutor to do index lookup. For example, if we have an index over NFT’s id column, the <code>SELECT * FROM nft WHERE id = 1</code> can actually be done like (1) extract <code>id = 1</code> predicate and (2) directly call <code>GetValue(1)</code> over the index, instead of doing a full index scan or table scan. You will need to update index scan plan to facilitate this optimization. Modify <code>terrier_benchmark_config.h</code> to instruct Terriers to create an index before exchanging NFTs.</p>
</blockquote>
<p>大概就是需要把update-seqscan化为update-indexscan。这个也在p3做过了。然后就是需要在index scan executor的实现中仿照seq scan加解锁。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Project3   Query Execution</title>
    <url>/2023/03/13/cmu15445$lab3/</url>
    <content><![CDATA[<h1 id="Project3-Query-Execution"><a href="#Project3-Query-Execution" class="headerlink" title="Project3   Query Execution"></a>Project3   Query Execution</h1><p>实现了：</p>
<ol>
<li>使用迭代器模型实现各种sql操作的底层执行（增删改查、聚合、连接、排序）</li>
<li>针对语法树实现部分查询优化规则（nlj-&gt;hash-join、谓词下推、列剪裁、公共表达式消除、恒假条件剪枝、支持索引范围查找）</li>
</ol>
<p>大概花了我十天左右的时间。不过总体体验感觉比b+树好一些，因为这里主要还是代码量多，并且不用考虑并发控制，不像b+树那样复杂。</p>
<blockquote>
<p>In this project, you will implement the components that allow BusTub to execute queries. You will create the operator executors that execute SQL queries and implement optimizer rules to transform query plans.</p>
<p>实现SQL查询的执行，并且实现语句优化。</p>
</blockquote>
<blockquote>
<p>In this project, you will add new <strong>operator executors</strong> and <strong>query optimizations</strong> to BusTub. </p>
<p>BusTub uses the <strong>iterator</strong> (i.e., Volcano) query processing model, in which <u>every executor implements a <code>Next</code> function to get the next tuple result</u>. </p>
<p>When the DBMS invokes an executor’s <code>Next</code> function, the executor returns either:</p>
<p>(1) a single tuple</p>
<p>​    In BusTub’s implementation of the iterator model, 除了元组外还会返回<strong>record identifier</strong> (<code>RID</code>)</p>
<p>(2) an indicator that there are no more tuples. </p>
<p>With this approach, each executor implements a loop that continues calling <code>Next</code> on its children to retrieve tuples and process them one by one.</p>
</blockquote>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Bustub-Framewor"><a href="#Bustub-Framewor" class="headerlink" title="Bustub Framewor"></a>Bustub Framewor</h3><p><img src="/2023/03/13/cmu15445/image-20231227153858926.png" alt="image-20231227153858926"></p>
<h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>介绍完了bustub的框架之后，它对通过语法树进行查询优化进行了详细的样例介绍。</p>
<p>首先温习一下什么是语法树（<em>abstract syntax tree, AST</em> ）：</p>
<p>SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select `title`</span><br><span class="line">From Books, Borrowers, Loans</span><br><span class="line">Where Books.LC_NO = Loans.LC_NO and Borrowers.CARD_NO = Loans.CARD_NO and DATE &lt;= 1/1/78</span><br></pre></td></tr></table></figure>

<p>其语法树表示+优化结果如下图所示：</p>
<p><img src="/2023/03/13/cmu15445/image-20231227155236633.png" alt="image-20231227155236633"></p>
<p>算法如下，其关键思路就是选择投影尽早做，能移多下去就移多下去</p>
<p><img src="/2023/03/13/cmu15445/image-20231227155806019.png" alt="image-20231227155806019"></p>
<p>而这里15445介绍的也是这样的语法树优化算法。</p>
<p>首先记录一下它这几个专有名词对应的操作：</p>
<blockquote>
<ol>
<li>Projection：投影</li>
<li>Filter：选择</li>
<li>MockScan：对一个表进行的扫描操作</li>
<li>Aggregation：聚合函数</li>
<li>NestedLoopJoin：嵌套循环连接</li>
</ol>
</blockquote>
<p>再结合它给的几个语法树的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT * FROM __mock_table_1;</span><br><span class="line"></span><br><span class="line">=== PLANNER ===</span><br><span class="line">Projection &#123; exprs=[#<span class="number">0.0</span>, #<span class="number">0.1</span>] &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)</span><br><span class="line">	MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)</span><br><span class="line">=== OPTIMIZER ===</span><br><span class="line">MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT colA, MAX(colB) FROM</span><br><span class="line">  (SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE) GROUP BY colA;</span><br><span class="line"></span><br><span class="line">=== OPTIMIZER ===</span><br><span class="line">Agg &#123; types=[max], aggregates=[#<span class="number">0.1</span>], group_by=[#<span class="number">0.0</span>] &#125;</span><br><span class="line">  NestedLoopJoin &#123; type=Inner, predicate=(#<span class="number">0.0</span>=#<span class="number">1.0</span>) &#125;</span><br><span class="line">    MockScan &#123; table=__mock_table_1 &#125;</span><br><span class="line">    MockScan &#123; table=__mock_table_3 &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/13/cmu15445/image-20231227160450894.png" alt="image-20231227160450894"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT * FROM __mock_table_1 WHERE colA &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">=== OPTIMIZER ===                                     </span><br><span class="line"> Filter &#123; predicate=(#<span class="number">0.0</span>&gt;<span class="number">1</span>) &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)         </span><br><span class="line">   MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">values (<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">=== PLANNER === </span><br><span class="line">Projection &#123; exprs=[#<span class="number">0.0</span>, #<span class="number">0.1</span>, #<span class="number">0.2</span>] &#125; | (__values#<span class="number">0.0</span>:INTEGER, __values#<span class="number">0.1</span>:INTEGER, __values#<span class="number">0.2</span>:VARCHAR) </span><br><span class="line">Values &#123; rows=<span class="number">2</span> &#125; | (__values#<span class="number">0.0</span>:INTEGER, __values#<span class="number">0.1</span>:INTEGER, __values#<span class="number">0.2</span>:VARCHAR)                     </span><br><span class="line">=== OPTIMIZER ===</span><br><span class="line">Values &#123; rows=<span class="number">2</span> &#125; | (__values#<span class="number">0.0</span>:INTEGER, __values#<span class="number">0.1</span>:INTEGER, __values#<span class="number">0.2</span>:VARCHAR)</span><br></pre></td></tr></table></figure>

<p>可以看到，它大概是用缩进来表示了AST的父子关系。</p>
<p>我们课上学习的语法树中每个table标志对应着一个MockScan；笛卡尔积+选择操作可以表示为一个NestedLoopJoin。</p>
<p>对于这些输出的意义，指导书也给了详细的解释：</p>
<p>ColumnValueExpression</p>
<p>也即类似<code>exprs=[#0.0, #0.1]</code>，<code>#0</code>意为<strong>第一个子节点</strong>（不是第一个表的意思。。）</p>
<h3 id="Volcano-Model"><a href="#Volcano-Model" class="headerlink" title="Volcano Model"></a>Volcano Model</h3><h4 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h4><blockquote>
<p><a href="https://blog.csdn.net/qq_44766883/article/details/131353665">火山模型和优化(向量化执行、编译执行)</a> 这篇文章写得很详细，<strong>下文也摘抄自该博客</strong>。</p>
<p><a href="https://www.modb.pro/db/129548">数据库内核通过 code-gen 提升性能的探索</a></p>
</blockquote>
<p>火山模型又称 Volcano Model 或者 Pipeline Model（或者<strong>迭代器模型</strong>）。该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，从根节点到叶子结点自上而下地递归调用 next() 函数。</p>
<p>一般Operator的next() 接口实现分为三步：</p>
<ul>
<li>调用子节点Operator的next() 接口获取一行数据(tuple)；</li>
<li>对tuple进行Operator特定的处理(如filter 或project 等)；</li>
<li>返回处理后的tuple。</li>
</ul>
<p>因此，查询执行时会由查询树<strong>自顶向下的调用</strong>next() 接口，数据则<strong>自底向上的被拉取</strong>处理。火山模型的这种处理方式也称为<strong>拉取执行模型</strong>(Pull Based)。</p>
<p>大多数关系型数据库都是使用迭代模型的，如 SQLite、MongoDB、Impala、DB2、SQLServer、Greenplum、PostgreSQL、Oracle、MySQL 等。</p>
<p>火山模型的优点是，处理逻辑清晰，简单，每个Operator 只要关心自己的处理逻辑即可，耦合性低。但是缺点也非常明显：</p>
<ul>
<li><p>每处理一行需要调用多次next() 函数，而next()为虚函数，开销大。</p>
<p>编译器无法对虚函数进行inline优化，同时也带来分支预测的开销，且很容易预测失败，导致CPU流水线执行混乱。</p>
</li>
<li><p>数据以行为单位进行处理，不利于CPU cache 发挥作用。</p>
</li>
</ul>
<h4 id="pipeline-breaker"><a href="#pipeline-breaker" class="headerlink" title="pipeline breaker"></a>pipeline breaker</h4><p>火山模型显而易见是以从上到下一个流水线形式执行的，它的最理想情况是每个流水线节点所需的这个tuple都存储在寄存器中。然而，有一些操作，如聚合函数等等，需要对整个表进行操作才能获取到当前所需tuple，而整个表显然最多只能读入到内存中，这样的操作就被称为<strong>pipeline breaker</strong>。</p>
<p>下面的实现中的aggregation、sort、hash join的build阶段都是pipeline breaker，这些复杂的操作阶段都需要在init()函数中进行。</p>
<h2 id="ADDITIONAL-INFORMATION"><a href="#ADDITIONAL-INFORMATION" class="headerlink" title="ADDITIONAL INFORMATION"></a>ADDITIONAL INFORMATION</h2><h3 id="System-Catalog"><a href="#System-Catalog" class="headerlink" title="System Catalog"></a>System Catalog</h3><blockquote>
<p>The entirety of the catalog implementation is in <code>src/include/catalog/catalog.h</code>. You should pay particular attention to the member functions <code>Catalog::GetTable()</code> and <code>Catalog::GetIndex()</code>. You will use these functions in the implementation of your executors to query the catalog for tables and indexes.</p>
</blockquote>
<p>它意思大概是说在实现executor时可能需要用到catelog里这两个函数。</p>
<p><code>GetTable</code>返回一个<code>TableInfo</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TableInfo</span> &#123;</span><br><span class="line">  <span class="comment">/** The table schema */</span></span><br><span class="line">  Schema schema_;</span><br><span class="line">  <span class="comment">/** The table name */</span></span><br><span class="line">  <span class="type">const</span> std::string name_;</span><br><span class="line">  <span class="comment">/** An owning pointer to the table heap */</span></span><br><span class="line">  std::unique_ptr&lt;TableHeap&gt; table_;</span><br><span class="line">  <span class="comment">/** The table OID */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">table_oid_t</span> oid_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>For the table modification executors (<code>InsertExecutor</code>, <code>UpdateExecutor</code>, and <code>DeleteExecutor</code>) you must modify all indexes for the table targeted by the operation. You may find the <code>Catalog::GetTableIndexes()</code> function useful for querying all of the indexes defined for a particular table. Once you have the <code>IndexInfo</code> instance for each of the table’s indexes, you can invoke index modification operations on the underlying index structure.</p>
<p>In this project, we use your implementation of B+ Tree Index from Project 2 as the underlying data structure for all index operations. Therefore, successful completion of this project relies on a working implementation of the B+ Tree Index.</p>
</blockquote>
<p><strong>话说index是那个索引吗，就是每张表有几个建立在某个属性的索引，也即一张表可以有n棵b+树</strong></p>
<p><code>GetIndex</code>返回一个<code>IndexInfo</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexInfo</span> &#123;</span><br><span class="line">  <span class="comment">/** The schema for the index key */</span></span><br><span class="line">  Schema key_schema_;</span><br><span class="line">  <span class="comment">/** The name of the index */</span></span><br><span class="line">  std::string name_;</span><br><span class="line">  <span class="comment">/** An owning pointer to the index */</span></span><br><span class="line">  std::unique_ptr&lt;Index&gt; index_;</span><br><span class="line">  <span class="comment">/** The unique OID for the index */</span></span><br><span class="line">  <span class="type">index_oid_t</span> index_oid_;</span><br><span class="line">  <span class="comment">/** The name of the table on which the index is created */</span></span><br><span class="line">  std::string table_name_;</span><br><span class="line">  <span class="comment">/** The size of the index key, in bytes */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> key_size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Optimizer-Rule-Implementation-Guide"><a href="#Optimizer-Rule-Implementation-Guide" class="headerlink" title="Optimizer Rule Implementation Guide"></a>Optimizer Rule Implementation Guide</h3><blockquote>
<p>The BusTub optimizer is a <strong>rule-based optimizer</strong>. Most optimizer rules construct optimized plans in a <strong>bottom-up way</strong>(自底向上). Because the query plan has this tree structure, before applying the optimizer rules to the current plan node, you want to first recursively apply the rules to its children.</p>
<p>At each plan node, you should determine if the source plan structure matches the one you are trying to optimize, and then check the attributes in that plan to see if it can be optimized into the target optimized plan structure.</p>
<p><u>In the public BusTub repository, we already provide the implementation of several optimizer rules. Please take a look at them as reference.</u></p>
</blockquote>
<h2 id="Task1-Access-Method-Executors"><a href="#Task1-Access-Method-Executors" class="headerlink" title="Task1  Access Method Executors"></a>Task1  Access Method Executors</h2><blockquote>
<p>In the background section above, we saw that the BusTub can already retrieve data from mock tables in <code>SELECT</code> queries. </p>
<p>This is implemented without real tables by using a <code>MockScan</code> executor to always generate the same tuples using a predefined algorithm. </p>
<p>This is why you cannot update these tables.</p>
</blockquote>
<blockquote>
<p>In this task, you will implement executors that read from and write to tables in the storage system. </p>
<ul>
<li><code>src/execution/seq_scan_executor.cpp</code></li>
<li><code>src/execution/insert_executor.cpp</code></li>
<li><code>src/execution/update_executor.cpp</code></li>
<li><code>src/execution/delete_executor.cpp</code></li>
<li><code>src/execution/index_scan_executor.cpp</code></li>
</ul>
</blockquote>
<p>而我们本次实验就是需要实现这么一大堆的executor。看来又是个体力活了。</p>
<h3 id="seq-scan"><a href="#seq-scan" class="headerlink" title="seq_scan"></a>seq_scan</h3><h4 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h4><h5 id="c-知识"><a href="#c-知识" class="headerlink" title="c++知识"></a>c++知识</h5><p><img src="/2023/03/13/cmu15445/image-20240115121419677.png" alt="image-20240115121419677"></p>
<p>可以看到，前缀++重载的运算符方法和后缀++是不一样的。</p>
<blockquote>
<p>这里我理解得还是肤浅了…… 根据 <a href="https://zhuanlan.zhihu.com/p/625890227#:~:text=%E5%86%8D%E5%AE%9E%E7%8E%B0%20Update-,2.%20%2B%2Bi%20%E4%B8%8E%20i%2B%2B%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F,-%E5%9C%A8%E5%AE%9E%E7%8E%B0%20SeqScan">这篇文章</a>，<code>++i</code> 的内部类定义为 <code>T&amp; T:: operator++();</code>，而 <code>i++</code> 的内部类定义为 <code>T T:: operator++(int);</code>[<a href="https://zhuanlan.zhihu.com/p/625890227#ref_1">1]</a>，<strong>前置操作返回引用，后置操作返回值</strong>。后置操作的 <code>int</code> 参数是一个虚拟参数，用于区分运算符 <code>++</code> 的前置和后置。<strong>理论上，<code>i++</code> 会产生临时对象</strong>，实践中，编译器会对内置类型进行优化；而<strong>对于自定义类型</strong>（如这里的 Iterator），<code>++i</code> 的性能通常优于 <code>i++</code>。</p>
</blockquote>
<h5 id="MockScan"><a href="#MockScan" class="headerlink" title="MockScan"></a>MockScan</h5><p>值得一提的是它跟MockScan的关系。MockScan是一种模拟操作，所以各种表都是硬编码在它的mock_scan.h里的；而SeqScan就是真正的遍历操作了，它需要获取tuple就需要通过各种复杂的物理操作和封装一步步读取了。</p>
<p>mockscan executor不是真的查表，而是返回固定的元组。</p>
<p>看了一遍代码，感觉大概明白了。我们可以来看一下迭代器的Next函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">MockScanExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cursor_ == size_) &#123;</span><br><span class="line">    <span class="comment">// Scan complete</span></span><br><span class="line">    <span class="keyword">return</span> EXECUTOR_EXHAUSTED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shuffled_idx_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    *tuple = <span class="built_in">func_</span>(cursor_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *tuple = <span class="built_in">func_</span>(shuffled_idx_[cursor_]);</span><br><span class="line">  &#125;</span><br><span class="line">  ++cursor_;</span><br><span class="line">  *rid = <span class="built_in">MakeDummyRID</span>();</span><br><span class="line">  <span class="keyword">return</span> EXECUTOR_ACTIVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心就是调用func_来获取表的元组。</p>
<p>也就是说是这样的，每个MockScanExecutor用来执行一个plan，那么也就对应着某一个table。通过执行某一个table特定的迭代function，就可以返回元组。</p>
<p>这个迭代function比如说对于表tas_2023是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (table == <span class="string">&quot;__mock_table_tas_2023&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [plan](<span class="type">size_t</span> cursor) &#123;</span><br><span class="line">    std::vector&lt;Value&gt; values&#123;&#125;;</span><br><span class="line">    values.<span class="built_in">push_back</span>(ValueFactory::<span class="built_in">GetVarcharValue</span>(ta_list_2023[cursor]));</span><br><span class="line">    values.<span class="built_in">push_back</span>(ValueFactory::<span class="built_in">GetVarcharValue</span>(ta_oh_2023[cursor]));</span><br><span class="line">    <span class="keyword">return</span> Tuple&#123;values, &amp;plan-&gt;<span class="built_in">OutputSchema</span>()&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即<strong>MockScanExecutor负责对表指针的管理，function负责实际对表的物理访问</strong>。这样就成功解耦了。</p>
<h5 id="physical-layer"><a href="#physical-layer" class="headerlink" title="physical layer"></a>physical layer</h5><p>通过实现SeqScan，我们可以初步窥探整个bustub物理层面交互的架构。</p>
<p>跟之前project中的索引entry一样，实际的数据tuple也保存在page中，其对应类为<code>TablePage</code>。并且是堆文件组织结构：</p>
<p><img src="/2023/03/13/cmu15445/image-20240115114448798.png" alt="image-20240115114448798"></p>
<blockquote>
<p><code>TablePage</code>的结构值得一提。</p>
<p>在它的成员定义中，我们可以看到其中有两个柔性数组成员（Flexible array member）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> page_start_[<span class="number">0</span>];</span><br><span class="line">TupleInfo tuple_info_[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>之前的Project2，我们只接触过一个的case，这里的两个感觉其实也同理可得，相当于<code>page_start_</code>和<code>tuple_info_</code>都指向最末尾空闲空间的开始。</p>
<p><code>TablePage</code>的实际存储结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-&gt;  increase											   increase  &lt;-</span><br><span class="line">| ------------------------------- | ********************************* |</span><br><span class="line">↑								  ↑</span><br><span class="line">page_start &amp; tuple_info    +TUPLE_INFO_SIZE*<span class="title function_">sizeof</span><span class="params">(TupleInfo)</span></span><br></pre></td></tr></table></figure>

<p>也即tuple info存储在前半部分，tuple data存储在后半部分，并且二者增长方式相反。</p>
</blockquote>
<p>而多页<code>TablePage</code>就构成了一个<code>TableHeap</code>，也即其物理存储空间。每次创建表时，我们就会分配对应的heap空间和相关meta data。<code>TableHeap</code>对外提供了增删改查元组的方法，也提供了一个迭代器实现<code>TableIterator</code>，用于遍历里面的元素。</p>
<p>而由于元组tuple存储在磁盘中，所以我们需要在读取它的值的时候先进行反序列化<code>DeserializeFrom</code>，这个过程需要用到表的类型信息和offset信息之类的，所以<code>Tuple::GetValue</code>需要传入<code>schema</code>参数。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>它基本原理也就是顺序遍历整张表，没什么好说的。</p>
<p>在本次的sequence scan实现中，我们就需要首先获取表对应的iterator：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 巨长一串</span></span><br><span class="line">table_iterator_ = std::<span class="built_in">make_unique</span>&lt;TableIterator&gt;(exec_ctx_-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">GetTableOid</span>())-&gt;table_-&gt;<span class="built_in">MakeIterator</span>());</span><br></pre></td></tr></table></figure>

<p>然后通过这个iterator不断迭代获取元素即可。</p>
<p>有一点要注意的，应该是对删除元组的处理，毕竟sequence scan算是是实现其他二级操作的基石了，所以我们必须在这里处理删除元组。具体逻辑如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (table_iterator_-&gt;<span class="built_in">IsEnd</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> EXECUTOR_EXHAUSTED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get tuple;</span><br><span class="line">  ++ iterator;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span>(tuple_meta.is_deleted_);</span><br></pre></td></tr></table></figure>



<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><h4 id="一些想法-1"><a href="#一些想法-1" class="headerlink" title="一些想法"></a>一些想法</h4><h5 id="recursive-execute"><a href="#recursive-execute" class="headerlink" title="recursive execute"></a>recursive execute</h5><p>对于SQL的嵌套子查询，bustub采用的是递归实现。具体来说，以insertion为例：</p>
<p>外界调用情况如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Execute a query plan.</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Execute</span><span class="params">(...)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Construct the executor for the abstract plan node</span></span><br><span class="line">  <span class="keyword">auto</span> executor = ExecutorFactory::<span class="built_in">CreateExecutor</span>(exec_ctx, plan);      </span><br><span class="line">  executor-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  <span class="built_in">PollExecutor</span>(executor.<span class="built_in">get</span>(), plan, result_set);</span><br><span class="line">  <span class="built_in">PerformChecks</span>(exec_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CreateExecutor</code>是一个递归函数，递归创建每个子查询的实例，把对应的executor返回给父查询</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ExecutorFactory::CreateExecutor</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    -&gt; std::unique_ptr&lt;AbstractExecutor&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">switch</span> (plan-&gt;<span class="built_in">GetType</span>()) &#123;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">case</span> PlanType::SeqScan: &#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;SeqScanExecutor&gt;(exec_ctx, <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> SeqScanPlanNode *&gt;(plan.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">case</span> PlanType::Insert: &#123;</span><br><span class="line">      <span class="keyword">auto</span> insert_plan = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> InsertPlanNode *&gt;(plan.<span class="built_in">get</span>());</span><br><span class="line">      <span class="comment">// 递归创建每个子查询的实例</span></span><br><span class="line">      <span class="keyword">auto</span> child_executor = ExecutorFactory::<span class="built_in">CreateExecutor</span>(exec_ctx, insert_plan-&gt;<span class="built_in">GetChildPlan</span>());</span><br><span class="line">      <span class="comment">// 把对应的executor返回给父查询</span></span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;InsertExecutor&gt;(exec_ctx, insert_plan, std::<span class="built_in">move</span>(child_executor));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们再在父查询的Init中调用子查询的Init和Next等方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，就能递归实现嵌套子查询。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><blockquote>
<p>The <code>InsertExecutor</code> inserts tuples into a table and <strong>updates any affected indexes</strong>.</p>
<p>The planner will ensure that the values have the same schema as the table. The executor will produce a single tuple of integer type as the output, indicating how many rows have been inserted into the table.</p>
</blockquote>
<p>这里将Insert语句插入的值视为一个匿名子表，对其初始化后使用它的迭代器进行元素访问即可。</p>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><h4 id="一些想法-2"><a href="#一些想法-2" class="headerlink" title="一些想法"></a>一些想法</h4><h5 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h5><p>bustub将一切表达式抽象为了这么几个类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AbstractExpression <span class="comment">// 基类</span></span><br><span class="line">ConstantValueExpression <span class="comment">// 常量值表达式</span></span><br><span class="line">ColumnValueExpression <span class="comment">// 列值表达式，访问某一列的值</span></span><br><span class="line">ArithmeticExpression <span class="comment">// 算术表达式，树递归结构，子节点是值or算术表达式</span></span><br><span class="line">ComparisonExpression <span class="comment">// 比较表达式，表示两个表达式</span></span><br><span class="line">LogicExpression <span class="comment">// 逻辑表达式</span></span><br><span class="line">StringExpression <span class="comment">// 字符串表达式，包括原字符串or upper之类的</span></span><br></pre></td></tr></table></figure>

<p>而从UpdatePlanNode中，我们可以获取到update字句的所有表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The new expression at each column */</span></span><br><span class="line">std::vector&lt;AbstractExpressionRef&gt; target_expressions_;</span><br></pre></td></tr></table></figure>

<p>比如此处：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bustub&gt; explain (o,s) update test_1 <span class="built_in">set</span> colB = <span class="number">15445</span>;</span><br><span class="line">=== OPTIMIZER ===</span><br><span class="line"><span class="comment">// 可以注意这边target_exprs的值</span></span><br><span class="line">Update &#123; table_oid=<span class="number">20</span>, target_exprs=[#<span class="number">0.0</span>, <span class="number">15445</span>, #<span class="number">0.2</span>, #<span class="number">0.3</span>] &#125; | (__bustub_internal.update_rows:INTEGER)</span><br><span class="line">  SeqScan &#123; table=test_1 &#125; | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER)</span><br></pre></td></tr></table></figure>

<p>然后我们分别计算每个expression的值，就可以获取更新之后的元组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// insert again</span></span><br><span class="line">   std::vector&lt;Value&gt; insert_values;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> exp : plan_-&gt;target_expressions_) &#123;</span><br><span class="line">     <span class="comment">// tuple为旧值元组</span></span><br><span class="line">     insert_values.<span class="built_in">push_back</span>(exp-&gt;<span class="built_in">Evaluate</span>(&amp;tuple, table_info-&gt;schema_));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 注意table_info应为要插入的表的info，此处易写为update plan子表的info</span></span><br><span class="line">   table_heap-&gt;<span class="built_in">InsertTuple</span>(<span class="built_in">TupleMeta</span>(), <span class="built_in">Tuple</span>(insert_values, &amp;(table_info-&gt;schema_)));</span><br></pre></td></tr></table></figure>

<h5 id="lazy-delete"><a href="#lazy-delete" class="headerlink" title="lazy delete"></a>lazy delete</h5><p>删除元组的实现似乎只是简单地标记<code>is_delete_</code>为true就好了。但是我在实际的代码实现（<code>InsertTuple</code>）中似乎并没有看到重组删除空间or覆盖删除空间，每次插入页满只是简单地再申请新的一页，不会再回头。也许是为了简化起见暂不实现这个吧。</p>
<p>不过改进方法也很简单，对每个表进行固定分配页（或者说提供一个数据量达到百分之几的时候扩容的机制），然后页面间组织成环形链表，这样就能充分覆盖删除空间，同时也兼顾一定性能了。</p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>update的实现也不会很难，只需先删除原来的元组，再加个新元组即可。</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>delete的实现完全照搬update就行，没什么好说的。</p>
<h3 id="index-scan"><a href="#index-scan" class="headerlink" title="index_scan"></a>index_scan</h3><blockquote>
<p>The <code>IndexScanExecutor</code> iterates over an <strong>index</strong> to retrieve <code>RIDs</code> for tuples. The operator then uses these RIDs to retrieve their tuples in the corresponding table. It then emits these tuples one at a time.</p>
<p>You can test your index scan executor by <code>SELECT FROM &lt;table&gt; ORDER BY &lt;index column&gt;</code>. We will explain why <code>ORDER BY</code> can be transformed into <code>IndexScan</code> in <a href="https://15445.courses.cs.cmu.edu/spring2023/project3/#task3">Task #3</a>.     </p>
<p>如果order-by的对象没有index，那么bustub会先给生成一个sortplan针对关键字排序，具体见task #3。</p>
<p>BusTub only supports indexes with a single, unique integer column. Our test cases will not contain duplicate keys. The type of the index object in the plan will <strong>always be</strong> <code>BPlusTreeIndexForTwoIntegerColumn</code> in this project. You can safely cast it and store it in the executor object:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> BPlusTreeIndexForTwoIntegerColumn = BPlusTreeIndex&lt;IntegerKeyType, IntegerValueType, IntegerComparatorType&gt;;</span><br><span class="line"></span><br><span class="line">tree_ = <span class="built_in">dynamic_cast</span>&lt;BPlusTreeIndexForTwoIntegerColumn *&gt;(index_info_-&gt;index_.<span class="built_in">get</span>())</span><br></pre></td></tr></table></figure>

<p>但我看测试里怎么好像有两个键的index？</p>
<p>You can then construct an index iterator from the index object, scan through all the keys and tuple IDs, lookup the tuple from the table heap, and emit all tuples in order. </p>
<p>是的，project2的b+树实现确实只存了rid，然后我们通过rid就能知道实际的物理位置了</p>
</blockquote>
<h4 id="一些想法-3"><a href="#一些想法-3" class="headerlink" title="一些想法"></a>一些想法</h4><h5 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h5><p>通过b+树组织索引结构，索引结点中存的是RID，RID可以用来指示tuple的物理位置，于是我们通过RID就可以获取到tuple，从而减少了磁盘IO。RID结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RID: Record Identifier</span></span><br><span class="line"><span class="comment">// 高32位是pgid，低32位是slot num</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RID</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">RID</span><span class="params">(<span class="type">int64_t</span> rid)</span> : page_id_(static_cast&lt;page_id_t&gt;(rid &gt;&gt; <span class="number">32</span>)), slot_num_(static_cast&lt;uint32_t&gt;(rid)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">int64_t</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(page_id_)) &lt;&lt; <span class="number">32</span> | slot_num_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">page_id_t</span> page_id_&#123;INVALID_PAGE_ID&#125;;</span><br><span class="line">  <span class="type">uint32_t</span> slot_num_&#123;<span class="number">0</span>&#125;;  <span class="comment">// logical offset from 0, 1...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并且，bustub保证了对于有索引的表，是不会有重复元组的，故而b+树实际上应该是一个稠密索引。</p>
<p>（毕竟这个情况似乎有点复杂……物理存储上应该是按插入顺序顺序存储的，故而重复元组可能不放在一起，而我们实现的b+树又不支持重复结点，所以就会g。如果想要支持重复元组，可能就需要从两个改变思路入手，要么是修改b+树支持重复索引结点，此时b+树依然为稠密索引；要么是修改为链式存储结构以支持重复元组放在一起，此时b+树为稀疏索引。）</p>
<h5 id="c-知识-1"><a href="#c-知识-1" class="headerlink" title="c++知识"></a>c++知识</h5><p>非常非常崩溃，怎么保存索引尝试了很久都没做到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样不行……</span></span><br><span class="line">std::unique_ptr&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt; iterator_;</span><br><span class="line">iterator_ = std::<span class="built_in">make_unique</span>&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt;(std::<span class="built_in">move</span>(tree_-&gt;<span class="built_in">GetBeginIterator</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样也不行……</span></span><br><span class="line">BPlusTreeIndexIteratorForTwoIntegerColumn iterator_;</span><br><span class="line">iterator_ = std::<span class="built_in">move</span>(tree_-&gt;<span class="built_in">GetBeginIterator</span>());</span><br></pre></td></tr></table></figure>

<p>没办法，最终只能保存tree，iterator在next里动态获取了，我真是服了。等之后看完c++primer或者c++水平有所提升了再来解决这个问题吧。</p>
<p>最终解决了这个问题，需要这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt; current_iterator_;</span><br><span class="line">current_iterator_ = std::<span class="built_in">make_unique</span>&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt;(tree-&gt;<span class="built_in">GetBeginIterator</span>());</span><br></pre></td></tr></table></figure>

<p>然后在<code>Iterator</code>实现中加一个move constructor即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">IndexIterator</span>(INDEXITERATOR_TYPE &amp;&amp;it) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>



<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>难绷，本来以为这个index-scan应该是最简单的，毕竟只用调用现成索引接口，没想到居然写了最久，可能足足两三个小时。。。</p>
<p>首先的一个大难点就是如何保存迭代器了。在之前的seq-scan的时候，使用的是unique ptr，然而这里却不行会报一堆奇奇怪怪的错误（具体见<code>一些想法-c++知识</code>）。最后只能换一个思路，不保存迭代器而是保存<code>next_key_</code>了。然而又由于之前b+树的实现bug问题，导致对end iterator解引用是合法的，所以会产生各种奇奇怪怪的错误。解决了这个之后，之前写的insert、update、delete的更新索引部分又出了问题，rid和insert_key弄错了，诸如此类。</p>
<p>总之，解决了这一大堆小问题之后，才总算通过了index-scan的测试，真是令人南蚌。具体改了什么bug可以详情见<code>b8d3ba546cfdea6fc576ad8d668322c87f6386c1</code>这个commit。</p>
<p>同时，也跟上面的sequence scan一样，都需要对标识为deleted的元组进行跳过处理。</p>
<blockquote>
<p>这里我也是没想太多……事实上，index scan无需实时检测is_deleted字段并做处理，因为索引是会随着修改实时更新的，被删除的tuple不会在索引中。</p>
</blockquote>
<h2 id="Task2-Aggregation-amp-Join-Executors"><a href="#Task2-Aggregation-amp-Join-Executors" class="headerlink" title="Task2  Aggregation &amp; Join Executors"></a>Task2  Aggregation &amp; Join Executors</h2><blockquote>
<p>In this task you will add an <strong>aggregation executor</strong>, several <strong>join executors</strong>, and enable the optimizer to <strong>select between</strong> a nested loop join and hash join when planning a query. </p>
<p>You will complete your implementation in the following files:</p>
<ul>
<li><code>src/execution/aggregation_executor.cpp</code></li>
<li><code>src/execution/nested_loop_join_executor.cpp</code></li>
<li><code>src/execution/hash_join_executor.cpp</code></li>
<li><code>src/optimizer/nlj_as_hash_join.cpp</code></li>
</ul>
</blockquote>
<h3 id="aggregation"><a href="#aggregation" class="headerlink" title="aggregation"></a>aggregation</h3><blockquote>
<p>The <a href="https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/aggregation_plan.h"><code>AggregationPlanNode</code></a> is used to support queries like the following:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT colA, MIN(colB) FROM __mock_table_1 GROUP BY colA;</span><br><span class="line">EXPLAIN SELECT COUNT(colA), mi(colB) FROM __mock_table_1;</span><br><span class="line">EXPLAIN SELECT colA, MIN(colB) FROM __mock_table_1 GROUP BY colA HAVING MAX(colB) &gt; 10;</span><br><span class="line">EXPLAIN SELECT DISTINCT colA, colB FROM __mock_table_1;</span><br></pre></td></tr></table></figure>

<p>也即聚合函数和DISTINCT、GROUP这种。</p>
</blockquote>
<p>此处注意DINSTINCT也是通过aggregation实现的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT DISTINCT colA, colB FROM __mock_table_1;</span><br><span class="line">=== OPTIMIZER ===                                                                                                   </span><br><span class="line"> Agg &#123; types=[], aggregates=[], group_by=[#<span class="number">0.0</span>, #<span class="number">0.1</span>] &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) </span><br><span class="line">   MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>The aggregation executor computes an aggregation function for <strong>each group of input</strong>. 作用于每一组</p>
<p>It has exactly one child. The output schema consists of the group-by columns followed by the aggregation columns.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT colA, MIN(colB) FROM __mock_table_1 GROUP BY colA;</span><br><span class="line">=== OPTIMIZER ===</span><br><span class="line"><span class="comment">// types标志聚合的种类，aggregates标识聚合的目标，group_by单独用于表示是否有group</span></span><br><span class="line">Agg &#123; types=[min], aggregates=[#<span class="number">0.1</span>], group_by=[#<span class="number">0.0</span>] &#125; | (__mock_table_1.colA:INTEGER, &lt;unnamed&gt;:INTEGER) </span><br><span class="line">MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT COUNT(colA), min(colB) FROM __mock_table_1</span><br><span class="line">=== OPTIMIZER ===                                                                    <span class="comment">// 如果没有group，则其字段为空                 </span></span><br><span class="line">Agg &#123; types=[count, min], aggregates=[#<span class="number">0.0</span>, #<span class="number">0.1</span>], group_by=[] &#125; | (&lt;unnamed&gt;:INTEGER, &lt;unnamed&gt;:INTEGER) </span><br><span class="line">MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)  </span><br></pre></td></tr></table></figure>

<p>As discussed in class, a common strategy for implementing aggregation is to use a <strong>hash table</strong>, with the group-by columns as the <strong>key</strong>. </p>
<p>In this project, you may assume that the aggregation hash table <strong>fits in memory</strong>. This means that you do not need to implement a multi-stage, partition-based strategy, and the hash table does not need to be backed by buffer pool pages.</p>
<p>  也就是说这里采取的是基于hashtable的实现而非基于归并排序的，并且为了简单起见将hash table保存在内存中，所以无需进行多趟划分扫描。</p>
<p>We provide a <code>SimpleAggregationHashTable</code> data structure that exposes an in-memory hash table (<code>std::unordered_map</code>) but with an interface designed for computing aggregations. This class also exposes an <code>SimpleAggregationHashTable::Iterator</code> type that can be used to iterate through the hash table. You will need to complete the <code>CombineAggregateValues</code> function for this class.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: The aggregation executor itself won’t need to handle the <code>HAVING</code> predicate. The planner will plan aggregations with a <code>HAVING</code> clause as <u>an <code>AggregationPlanNode</code> followed by a <code>FilterPlanNode</code></u>.</p>
</blockquote>
<blockquote>
<p><strong>Hint:</strong> In the context of a query plan, aggregations are <em>pipeline breakers</em>. This may influence the way that you use the <code>AggregationExecutor::Init()</code> and <code>AggregationExecutor::Next()</code> functions in your implementation. Carefully decide whether the build phase of the aggregation should be performed in <code>AggregationExecutor::Init()</code> or <code>AggregationExecutor::Next()</code>.</p>
</blockquote>
<h4 id="一些想法-4"><a href="#一些想法-4" class="headerlink" title="一些想法"></a>一些想法</h4><h5 id="countstar"><a href="#countstar" class="headerlink" title="countstar"></a>countstar</h5><p>值得注意的是，这里的实现将<code>COUNT(*)</code>和<code>COUNT(colum)</code>区分开了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">AggregationType</span> &#123; CountStarAggregate, CountAggregate &#125;;</span><br></pre></td></tr></table></figure>

<p>因为这两者似乎语义上是有区别的，大概体现为以下几点：</p>
<ol>
<li>当没有结果时，CountStar返回0，Count返回integer_null</li>
<li>CountStar只记录行数，不管值是否为空；Count只记录所要求的列非空的那些行数</li>
</ol>
<h5 id="hash-aggregation"><a href="#hash-aggregation" class="headerlink" title="hash aggregation"></a>hash aggregation</h5><p>关于hashtable实现聚合的相关原理及相关示例，具体可见 <a href="https://zhuanlan.zhihu.com/p/52969666">这篇文章</a>。感觉这系列文章都写得挺好的，如对TiDB有兴趣可以细看。</p>
<blockquote>
<p>在 SQL 中，聚合操作对一组值执行计算，并返回单个值。TiDB 实现了 <u>2 种聚合算法：Hash Aggregation 和 Stream Aggregation</u>。</p>
<p>在 Hash Aggregate 的计算过程中，我们需要维护一个 Hash 表，Hash 表的<u>键为聚合计算的 <code>Group-By</code> 列</u>，<u>值为聚合函数的中间结果 <code>sum</code> 和 <code>count</code></u>。</p>
<p>计算过程中，只需要根据每行输入数据计算出键，在 Hash 表中找到对应值进行更新即可。输入数据输入完后，<u>扫描 Hash 表并计算，便可以得到最终结果</u>。</p>
</blockquote>
<p>故而思路也是很清晰了。我们在aggregation的实现中要做的，就是把child executor逐行喂给hashtable，最后再遍历hashtable得到结果即可。故而，我们重点需要实现hashtable的<code>InsertCombine</code>函数和hashtable的iterator。</p>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>理解了hash-aggregation的算法原理后，代码逻辑方面就不算难了，其余最主要的难点应该是空值的处理。</p>
<p>总结一下，bustub对空值的处理大概有以下几个要点：</p>
<ol>
<li><p>聚合函数对空值处理</p>
<p><code>COUNT(*)</code>：计入空值</p>
<p><code>COUNT/MAX/MIN/SUM(v1)</code>：跳过空值</p>
</li>
<li><p>空值自身运算性质</p>
<p>任意运算若有一个操作数为空，那么结果也为空。</p>
<p>故而，当没有使用<code>group by</code>关键字的时候（也即hashtable的key为空），此时不能天真地传入一个空的AggregationKey，而应该给它随便塞某个值。不然的话，hashtable内部的比较函数在处理空值的时候恒返回false，会导致检索失败。</p>
</li>
<li><p>空表情况处理</p>
<p>当表为空的时候，要求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select COUNT(*), MAX(v1), COUNT(v1) from table_;</span><br><span class="line"># 0 integer_null integer_null</span><br><span class="line">select COUNT(*), MAX(v1), COUNT(v1) from table_ group by v2;</span><br><span class="line"># no-output</span><br></pre></td></tr></table></figure>

<p>这个操作我着实不懂为什么。。。所以我最终代码只能面向测试用例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!has_next &amp;&amp; plan_-&gt;<span class="built_in">GetGroupBys</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 当表为空并且不使用聚合函数时，输出一个默认情况对</span></span><br><span class="line">    AggregateKey agg_key;</span><br><span class="line">    agg_key.group_bys_.<span class="built_in">push_back</span>(<span class="built_in">Value</span>(TypeId::INTEGER, <span class="number">1</span>));</span><br><span class="line">    aht_-&gt;<span class="built_in">InsertCombine</span>(agg_key, <span class="built_in">MakeAggregateValue</span>(<span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="NestedLoopJoin"><a href="#NestedLoopJoin" class="headerlink" title="NestedLoopJoin"></a>NestedLoopJoin</h3><blockquote>
<p>The DBMS will use <a href="https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/nested_loop_join_plan.h"><code>NestedLoopJoinPlanNode</code></a> for all join operations, <strong>by default</strong>.</p>
<p>You will need to implement an <strong>inner join and <a href="https://en.wikipedia.org/wiki/Join_(SQL)#Left_outer_join">left join</a></strong> for the <code>NestedLoopJoinExecutor</code> using the simple nested loop join algorithm from class. </p>
<p>The output schema of this operator is all columns from the left table followed by all columns from the right table. </p>
<p>For each tuple in the outer table, consider each tuple in the inner table and emit an output tuple if the join predicate is satisfied.</p>
</blockquote>
<p>也即嵌套循环实现的join，与在课上学的sort merge join一样，都是古法join实现。</p>
<p>nested join的实现相比之前的思路确实会复杂一些。我们需要学习如何迭代地调用<code>Next</code>来实现一次嵌套循环。思路大概是这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Init():</span><br><span class="line">    Init left, right</span><br><span class="line">    Move left to get current_left_tuple_</span><br><span class="line">Next():</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (Move(right)) :;</span><br><span class="line">    	<span class="keyword">else</span>:</span><br><span class="line">            Move left</span><br><span class="line">            Init right</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (checkPredict):</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>然而其中有这几个细节需要进行处理：</p>
<ol>
<li><p>左连接的实现</p>
<p>需要增加逻辑：当right遍历完之后，<code>current_left_tuple_</code>仍未被组装进结果过，此时需要帮其拼接上空right tuple。</p>
</li>
<li><p>空表情况</p>
<p>这个分支中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">       Move left</span><br><span class="line">       Init right</span><br><span class="line">       <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>不能这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">       Move left</span><br><span class="line">       Init right</span><br><span class="line">       Move right</span><br></pre></td></tr></table></figure>

<p>这是为了防止空表情况，使得Move right一直返回false，导致之后checkPredict报空指针异常。</p>
</li>
<li><p>测试要求<code>left-&gt;Next()</code>调用次数与<code>right-&gt;Init()</code>调用次数相同。</p>
<blockquote>
<p>这是为了强制让NestedLoopJoin的实现不是Pipeline Break，从而导致它性能垃圾了</p>
</blockquote>
</li>
</ol>
<h3 id="HashJoin"><a href="#HashJoin" class="headerlink" title="HashJoin"></a>HashJoin</h3><blockquote>
<p>The DBMS can use <a href="https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/hash_join_plan.h"><code>HashJoinPlanNode</code></a> if a query contains a join with a <strong>conjunction of equi-conditions between two columns (equi-conditions are seperated by <code>AND</code>)</strong>. </p>
<p>也就是说，当连接条件为一/多个列相等时，就可以用hash join。可以看到这是类似等值连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE;</span><br><span class="line">EXPLAIN SELECT * FROM __mock_table_1 INNER JOIN __mock_table_3 ON colA = colE;</span><br><span class="line">EXPLAIN SELECT * FROM __mock_table_1 LEFT OUTER JOIN __mock_table_3 ON colA = colE;</span><br><span class="line">EXPLAIN SELECT * FROM test_1 t1, test_2 t2 WHERE t1.colA = t2.colA AND t1.colB = t2.colC;</span><br><span class="line">EXPLAIN SELECT * FROM test_1 t1 INNER JOIN test_2 t2 on t1.colA = t2.colA AND t2.colC = t1.colB;</span><br><span class="line">EXPLAIN SELECT * FROM test_1 t1 LEFT OUTER JOIN test_2 t2 on t2.colA = t1.colA AND t2.colC = t1.colB;</span><br></pre></td></tr></table></figure>

<p>You will need to implement the inner join and <a href="https://en.wikipedia.org/wiki/Join_(SQL)#Left_outer_join">left join</a> for <code>HashJoinExecutor</code> using the hash join algorithm from class. </p>
<p>The output schema of this operator is all columns from the left table followed by all columns from the right table. </p>
<p>As with aggregation, you may assume that the hash table used by the join fits entirely in memory.</p>
<p><strong>Hint:</strong> Your implementation should correctly handle the case where multiple tuples have hash collisions (on either side of the join). 必须正确处理哈希冲突的情况</p>
<p><strong>Hint:</strong> You will want to make use of the join key accessors functions <code>GetLeftJoinKey()</code> and <code>GetRightJoinKey()</code> in the <code>HashJoinPlanNode</code> to construct the join keys for the left and right sides of the join, respectively.</p>
<p><strong>Hint:</strong> You will need a way to hash a tuple with multiple attributes in order to construct a unique key. As a starting point, take a look at how the <code>SimpleAggregationHashTable</code> in the <code>AggregationExecutor</code> implements this functionality. 可以参考 <code>SimpleAggregationHashTable</code>的实现</p>
<p><strong>Hint:</strong> As with aggregation, the build side of a hash join is a <em>pipeline breaker</em>. You should again consider whether the <em>build</em> phase of the hash join should be performed in <code>HashJoinExecutor::Init()</code> or <code>HashJoinExecutor::Next()</code>.</p>
</blockquote>
<p>具体什么是hash join，可以参考 <a href="https://zhuanlan.zhihu.com/p/663637344">这篇文章</a>。</p>
<p><img src="/2023/03/13/cmu15445/v2-bb022b4a6da1743b5f421248a0bae358_r.jpg" alt="img"></p>
<p>其大概思路也很简单，hash table就是一个<code>map&lt;key, vector&lt;value&gt;&gt;</code>这样的数据结构，然后将两个输入的关系选举出一个小表作为Build（建立hash table），另一个作为Probe（扫描，并根据hash table-&gt;second进行迭代组合）。它其实就是一个精确了范围的nested loop join的变种，将nested里层的针对整个关系的大循环缩小为针对hash table一个bucket的小循环。</p>
<p>具体到这里，思路可以是这样的。首先为了简单起见，我们就不进行选举小表的判断了，固定将right child作为Build，left child作为Probe。建表的话，我们就简单粗暴地遍历right table，然后以<code>right_key_expressions_</code>为key<code>Tuple</code>为value直接建表（反正也是in-memory即可。。。）。然后之后，就仿照之前思路即可。</p>
<h3 id="Optimizing-NestedLoopJoin-to-HashJoin"><a href="#Optimizing-NestedLoopJoin-to-HashJoin" class="headerlink" title="Optimizing NestedLoopJoin to HashJoin"></a>Optimizing NestedLoopJoin to HashJoin</h3><blockquote>
<p>Hash joins usually yield better performance than nested loop joins. You should modify the optimizer to transform a <code>NestedLoopJoinPlanNode</code> into a <code>HashJoinPlanNode</code> when it is possible to use a hash join. </p>
<p>Specifically, the hash join algorithm can be used <u>when a join predicate is a conjunction of equi-conditions between two columns</u>. For the purpose of this project, handling a <strong>single</strong> equi-condition, and also <strong>two</strong> equi-conditions connected by <code>AND</code>, will earn full credit.</p>
<p>Consider the following example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bustub&gt; EXPLAIN (o) SELECT * FROM test_1 t1, test_2 t2 WHERE t1.colA = t2.colA AND t1.colB = t2.colC;</span><br></pre></td></tr></table></figure>

<p>Without applying the <code>NLJAsHashJoin</code> optimizer rule, the plan may look like:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NestedLoopJoin &#123; type=Inner, predicate=((#<span class="number">0.0</span>=#<span class="number">1.0</span>)and(#<span class="number">0.1</span>=#<span class="number">1.2</span>)) &#125; </span><br><span class="line">SeqScan &#123; table=test_1 &#125;                                           </span><br><span class="line">SeqScan &#123; table=test_2 &#125;</span><br></pre></td></tr></table></figure>

<p>After applying the <code>NLJAsHashJoin</code> optimizer rule, the left and right join key expressions will be extracted from the single join predicate in the <code>NestedLoopJoinPlanNode</code>. The resulting plan will look like:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HashJoin &#123; type=Inner, left_key=[#<span class="number">0.0</span>, #<span class="number">0.1</span>], right_key=[#<span class="number">0.0</span>, #<span class="number">0.2</span>] &#125; </span><br><span class="line">SeqScan &#123; table=test_1 &#125;                                             </span><br><span class="line">SeqScan &#123; table=test_2 &#125; </span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> Please check the <a href="https://15445.courses.cs.cmu.edu/spring2023/project3/##optimizer-rule-implementation-guide">Optimizer Rule Implementation Guide</a> section for details on implementing an optimizer rule.</p>
<p><strong>Hint:</strong> Make sure to check which table the column belongs to for each side of the equi-condition. It is possible that the column from outer table is on the right side of the equi-condition. You may find <code>ColumnValueExpression::GetTupleIdx</code> helpful.</p>
<p><strong>Hint:</strong> The order to apply optimizer rules matters. For example, you want to optimize NestedLoopJoin into HashJoin after filters and NestedLoopJoin have merged. 这个感觉可能意思就是说<strong>优化规则的优先级</strong>之类的吧，这里用了个例子说hash join的优先级一般得在filter和nested loop join合并了之后。</p>
<p><strong>Hint:</strong> At this point, you should pass <a href="https://15445.courses.cs.cmu.edu/spring2023/project3/#testing">SQLLogicTests - #14 to #15</a>.</p>
</blockquote>
<h4 id="一些想法-5"><a href="#一些想法-5" class="headerlink" title="一些想法"></a>一些想法</h4><h5 id="bustub-optimizer"><a href="#bustub-optimizer" class="headerlink" title="bustub optimizer"></a>bustub optimizer</h5><blockquote>
<p>The BusTub optimizer is a <strong>rule-based optimizer</strong>. Most optimizer rules construct optimized plans in a <strong>bottom-up way</strong>(自底向上). Because the query plan has this tree structure, before applying the optimizer rules to the current plan node, you want to first recursively apply the rules to its children.    基于规则的优化器，规则都是对语法树自底向上实施。感觉跟课内学的差不多。</p>
<p><u>In the public BusTub repository, we already provide the implementation of several optimizer rules. Please take a look at them as reference.</u></p>
</blockquote>
<p>在课程中学到的语法优化，应该也是基于规则的优化，具体见下图及之后列出的无穷无尽个定理：</p>
<p><img src="/2023/03/13/cmu15445/image-20231119015111213.png" alt="image"></p>
<p><img src="/2023/03/13/cmu15445/image-20231227155806019.png" alt="image-20231227155806019"></p>
<p>（本图新增了一条规则：选择+嵌套笛卡尔积=嵌套连接）</p>
<p>查看目录<code>src/optimizer/</code>，我们可以看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree ../src/optimizer/</span><br><span class="line">../src/optimizer/</span><br><span class="line">├── eliminate_true_filter.cpp	<span class="comment"># 消除恒真选择</span></span><br><span class="line">├── merge_filter_nlj.cpp		<span class="comment"># 合并选择和嵌套连接</span></span><br><span class="line">├── merge_filter_scan.cpp		<span class="comment"># 合并选择和scan</span></span><br><span class="line">├── merge_projection.cpp		<span class="comment"># 合并多个投影</span></span><br><span class="line">├── nlj_as_hash_join.cpp		<span class="comment"># 嵌套连接-&gt;hash连接</span></span><br><span class="line">├── nlj_as_index_join.cpp		<span class="comment"># 嵌套连接-&gt;index连接</span></span><br><span class="line">├── optimizer.cpp</span><br><span class="line">├── optimizer_custom_rules.cpp</span><br><span class="line">├── optimizer_internal.cpp</span><br><span class="line">├── order_by_index_scan.cpp</span><br><span class="line">└── sort_limit_as_topn.cpp		<span class="comment"># 针对 top-N queries 进行优化</span></span><br></pre></td></tr></table></figure>

<p>在本小节任务中，我们需要做的，就是参照其他的规则来实现<code>nlj_as_hash_join</code>。但在此之前，我们不妨先研究一下它语法优化的总体架构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Optimizer::OptimizeCustom</span><span class="params">(<span class="type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> p = plan;</span><br><span class="line">  p = <span class="built_in">OptimizeMergeProjection</span>(p); 		<span class="comment">// 首先合并影响相同的投影</span></span><br><span class="line">  p = <span class="built_in">OptimizeMergeFilterNLJ</span>(p);		<span class="comment">// 然后合并选择和嵌套连接</span></span><br><span class="line">  p = <span class="built_in">OptimizeNLJAsHashJoin</span>(p);			<span class="comment">// 然后把嵌套连接改为hash join</span></span><br><span class="line">  p = <span class="built_in">OptimizeOrderByAsIndexScan</span>(p);	<span class="comment">// 根据索引进行查找</span></span><br><span class="line">  p = <span class="built_in">OptimizeSortLimitAsTopN</span>(p);		<span class="comment">// 针对 top-N queries 进行优化</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它的实际原理很简单，就是按照这样的优先级顺序对语法树运用规则进行优化。</p>
<h5 id="merge-filter-nlj"><a href="#merge-filter-nlj" class="headerlink" title="merge filter nlj"></a>merge filter nlj</h5><p>以<code>OptimizeMergeFilterNLJ</code>为例，我们可以研究一下它的整体架构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Optimizer::OptimizeMergeFilterNLJ</span><span class="params">(<span class="type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class="line">  <span class="comment">// 首先自底向上地对其所有子节点进行优化，采用DFS</span></span><br><span class="line">  std::vector&lt;AbstractPlanNodeRef&gt; children;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;child : plan-&gt;<span class="built_in">GetChildren</span>()) &#123;</span><br><span class="line">    children.<span class="built_in">emplace_back</span>(<span class="built_in">OptimizeMergeFilterNLJ</span>(child));</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">auto</span> optimized_plan = plan-&gt;<span class="built_in">CloneWithChildren</span>(std::<span class="built_in">move</span>(children));</span><br><span class="line">  <span class="comment">// 仅当当前结点为filter，并且其唯一子节点为nlj时，才进行重写优化</span></span><br><span class="line">  <span class="keyword">if</span> (optimized_plan-&gt;<span class="built_in">GetType</span>() == PlanType::Filter) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;filter_plan = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> FilterPlanNode &amp;&gt;(*optimized_plan);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;child_plan = optimized_plan-&gt;children_[<span class="number">0</span>];  <span class="comment">// Has exactly one child</span></span><br><span class="line">    <span class="keyword">if</span> (child_plan-&gt;<span class="built_in">GetType</span>() == PlanType::NestedLoopJoin) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> &amp;nlj_plan = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> NestedLoopJoinPlanNode &amp;&gt;(*child_plan);</span><br><span class="line">      <span class="comment">// 这里可能简单起见，仅当nlj为纯纯的笛卡尔积时，才会进行合并</span></span><br><span class="line">      <span class="comment">// 所以看起来就无法处理多个连续的选择的情况，或许在planner阶段规避了这种情况？</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">IsPredicateTrue</span>(nlj_plan.<span class="built_in">Predicate</span>())) &#123;</span><br><span class="line">        <span class="comment">// 将该filter+nlj结点重写为一个新的连接结点</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;NestedLoopJoinPlanNode&gt;(</span><br><span class="line">            filter_plan.output_schema_, nlj_plan.<span class="built_in">GetLeftPlan</span>(), nlj_plan.<span class="built_in">GetRightPlan</span>(),</span><br><span class="line">            <span class="built_in">RewriteExpressionForJoin</span>(filter_plan.<span class="built_in">GetPredicate</span>(), </span><br><span class="line">                                     nlj_plan.<span class="built_in">GetLeftPlan</span>()-&gt;<span class="built_in">OutputSchema</span>().<span class="built_in">GetColumnCount</span>(), nlj_plan.<span class="built_in">GetRightPlan</span>()-&gt;<span class="built_in">OutputSchema</span>().<span class="built_in">GetColumnCount</span>()), nlj_plan.<span class="built_in">GetJoinType</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> optimized_plan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，对语法树运用该merge filter nlj规则是采用自底向上的顺序，并且仅合并那些filter-笛卡尔积的结点。那么接下来，我们可以具体关注<code>RewriteExpressionForJoin</code>的实现。</p>
<p>首先，我们需要明确bustub中对expression的抽象。以<code>#0.0=#1.0</code>为例，expression的结构树如下所示：</p>
<p><img src="/2023/03/13/cmu15445/image-20240120104722170.png" alt="image-20240120104722170"></p>
<p>每个叶子结点都是一个基本的expression类型，如column value、constant value等等等，整个子树构成一个其他expression类型，如comparation expr、arithmetic expr等等等。</p>
<p>在未优化前，我们是先做笛卡尔积，再做选择。故而，假设t1有2列，t2有2列，选择条件为<code>t1.col1 = t2.col4</code>，在未优化前，filter结点的expr将为：<code>#0.0=#0.3</code>（两表经过笛卡尔积合在一起了）。故而，在<code>RewriteExpressionForJoin</code>函数中，我们需要根据t1表和t2表分别的列数，将<code>#0.0=#0.3</code>这样的表达式转化为<code>#0.0=#1.1</code>这样的表达式（其实也就是只用处理所有类型为colum expr的叶结点即可）。而由于expression是递归结构，所以我们需要先针对其所有子节点进行处理。故而，<code>RewriteExpressionForJoin</code>的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Optimizer::RewriteExpressionForJoin</span><span class="params">(<span class="type">const</span> AbstractExpressionRef &amp;expr, <span class="type">size_t</span> left_column_cnt, <span class="type">size_t</span> right_column_cnt)</span> -&gt; AbstractExpressionRef </span>&#123;</span><br><span class="line">  <span class="comment">// 首先自底向上地对其所有子节点进行优化，采用DFS</span></span><br><span class="line">  std::vector&lt;AbstractExpressionRef&gt; children;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;child : expr-&gt;<span class="built_in">GetChildren</span>()) &#123;</span><br><span class="line">    children.<span class="built_in">emplace_back</span>(<span class="built_in">RewriteExpressionForJoin</span>(child, left_column_cnt, right_column_cnt));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 仅对那些类型为column expr的叶子结点进行处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> *column_value_expr = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> ColumnValueExpression *&gt;(expr.<span class="built_in">get</span>()); column_value_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// #0.1, &quot;0&quot;为tuple_idx，&quot;1&quot;为col_idx</span></span><br><span class="line">    <span class="comment">// 此时tuple_idx一定是0，因为filter结点只有一个子节点</span></span><br><span class="line">    <span class="built_in">BUSTUB_ENSURE</span>(column_value_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span>, <span class="string">&quot;tuple_idx cannot be value other than 0 before this stage.&quot;</span>)</span><br><span class="line">    <span class="keyword">auto</span> col_idx = column_value_expr-&gt;<span class="built_in">GetColIdx</span>();</span><br><span class="line">    <span class="keyword">if</span> (col_idx &lt; left_column_cnt) &#123;	</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, col_idx, column_value_expr-&gt;<span class="built_in">GetReturnType</span>());	<span class="comment">// 替换为#0.X</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (col_idx &gt;= left_column_cnt &amp;&amp; col_idx &lt; left_column_cnt + right_column_cnt) &#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, col_idx - left_column_cnt, column_value_expr-&gt;<span class="built_in">GetReturnType</span>());	<span class="comment">// 替换为#1.X</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> bustub::<span class="built_in">Exception</span>(<span class="string">&quot;col_idx not in range&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// xiunian: do nothing if the filter contains no column value expression</span></span><br><span class="line">  <span class="keyword">return</span> expr-&gt;<span class="built_in">CloneWithChildren</span>(children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><blockquote>
<p>Specifically, the hash join algorithm can be used <u>when a join predicate is a conjunction of equi-conditions between two columns</u>. For the purpose of this project, handling a <strong>single</strong> equi-condition, and also <strong>two</strong> equi-conditions connected by <code>AND</code>, will earn full credit.</p>
</blockquote>
<p>看完了merge filter nlj的实现之后，本次任务的实现就变得不那么困难了。</p>
<p>当一个nlj的predicate条件是一堆使用AND连接的“=”expr，我们就可以将该nlj转化为hash join。而<code>OptimizeNLJAsHashJoin</code>作用于<code>OptimizeMergeFilterNLJ</code>之后，故而，我们可以直接对所有的nlj结点进行判定重写。</p>
<p>具体来说，我们可以首先实现一个函数<code>CheckIfEquiConjunction</code>，给定expr结构树输入，判断其是否只由AND、”=”、”column expr”构成。这个过程还需要做一件事，就是分离出hash join所需要的key expression，如nlj的连接条件为<code>#0.1=#1.2 AND #1.1=#0.2</code>，则最后形成的hash join为<code>left_key_expr=[#0.1, #0.2], right_key_expr=[#1.2, #1.1]</code>。</p>
<p>然后，在<code>OptimizeNLJAsHashJoin</code>函数主体中，我们只需遍历语法树的所有结点，然后对其进行判定，符合条件则将其转化为hash join即可。</p>
<h2 id="Task-3-Sort-Limit-Executors-and-Top-N-Optimization"><a href="#Task-3-Sort-Limit-Executors-and-Top-N-Optimization" class="headerlink" title="Task #3 - Sort + Limit Executors and Top-N Optimization"></a>Task #3 - Sort + Limit Executors and Top-N Optimization</h2><blockquote>
<p>You will finally implement a few more common executors, completing your implementation in the following files:</p>
<ul>
<li><code>src/execution/sort_executor.cpp</code></li>
<li><code>src/execution/limit_executor.cpp</code></li>
<li><code>src/execution/topn_executor.cpp</code></li>
<li><code>src/optimizer/sort_limit_as_topn.cpp</code></li>
</ul>
<p>You must implement the <code>IndexScanExecutor</code> in <a href="https://15445.courses.cs.cmu.edu/spring2023/project3/#task1">Task #1</a> before starting this task. <u>If there is an index over a table, the query processing layer will automatically pick it for sorting</u>. In other cases, you will need <strong>a special sort executor</strong> to do this.</p>
<p>For all order by clauses, we assume every sort key will only appear once. You do not need to worry about ties in sorting.</p>
</blockquote>
<h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><blockquote>
<p>If a query’s <code>ORDER BY</code> attributes <u>don’t match the keys of an index</u>, BusTub will produce a <a href="https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/sort_plan.h"><code>SortPlanNode</code></a> for queries such as:</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> __mock_table_1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> colA <span class="keyword">ASC</span>, colB <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>如果要求排序的key不是index key，就会用到这个sort executor。</p>
<p>This plan node has the same output scheme as its input schema. You can extract sort keys from <code>order_bys</code>, and then use <code>std::sort</code> with a custom comparator to sort the child node’s tuples. You may assume that all entries in a table will fit entirely in memory.</p>
<p>If the query does not include a sort direction (i.e., <code>ASC</code>, <code>DESC</code>), then the sort mode will be <code>default</code> (which is <code>ASC</code>).</p>
</blockquote>
<h4 id="一些想法-6"><a href="#一些想法-6" class="headerlink" title="一些想法"></a>一些想法</h4><h5 id="comparator实现"><a href="#comparator实现" class="headerlink" title="comparator实现"></a>comparator实现</h5><blockquote>
<p>我有一个类Tuple，另一个类Executor。我想实现一个Tuple的比较函数，但需要用到类Executor的成员变量，那么我该怎么写一个可以用于std::sort的cmp函数</p>
</blockquote>
<p>最终给出的提示是这样的，实现一个<strong>函数对象</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareTuplesByOrder</span> &#123;</span><br><span class="line">  Schema schema_;</span><br><span class="line">  <span class="comment">// add any new member</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CompareTuplesByOrder</span>(Schema schema, <span class="type">const</span> std::vector&lt;std::pair&lt;OrderByType, AbstractExpressionRef&gt;&gt;&amp; order_by) : <span class="built_in">schema_</span>(schema) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// override the &quot;()&quot; operator</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Tuple &amp;t1, <span class="type">const</span> Tuple &amp;t2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do any logic</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use in sort</span></span><br><span class="line">std::<span class="built_in">sort</span>(tuples_.<span class="built_in">begin</span>(), tuples_.<span class="built_in">end</span>(), <span class="built_in">CompareTuplesByOrder</span>(<span class="built_in">GetOutputSchema</span>(), plan_-&gt;<span class="built_in">GetOrderBy</span>()));</span><br></pre></td></tr></table></figure>

<p>可以看到，其本质是通过重载”()”运算符来实现的，感觉是一个很有意思的trick。</p>
<h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>它提示的实现思路很简单，就是大概从sort plan node获取所有key，然后用<code>std:sort</code>即可，默认升序，并且所有entry都是in-memory的。</p>
<p>有一点值得注意的是，在sql语言中，排序是可以指定多个关键词+不同顺序（关键词出现顺序表明排序优先级）的，如<code>order by col1 ASC, col3 DESC</code>。所以我们需要在comparator实现中按照优先级（也即<code>order_by_</code>数组顺序）一步步比较。</p>
<p>比较难的地方大概还是c++知识，也即如何为<code>std:sort</code>实现一个较为复杂的comparator。具体操作可见<code>一些想法-comparator实现</code>。</p>
<h3 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h3><blockquote>
<p>The <a href="https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/limit_plan.h"><code>LimitPlanNode</code></a> specifies the number of tuples that query will generate. Consider the following example:</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> __mock_table_1 <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>The <code>LimitExecutor</code> <strong>constrains the number of output tuples from its child executor</strong>. If the number of tuples produced by its child executor is less than the limit specified in the plan node, this executor has no effect and yields all of the tuples that it receives.</p>
<p>This plan node has the same output scheme as its input schema. You do not need to support offsets.</p>
</blockquote>
<p>挺简单的，就是限制输出的数量，没什么好说的。</p>
<h3 id="Top-N-Optimization-Rule"><a href="#Top-N-Optimization-Rule" class="headerlink" title="Top-N Optimization Rule"></a>Top-N Optimization Rule</h3><blockquote>
<p>Finally, you should modify BusTub’s optimizer to efficiently support top-N queries. (These were called top-K queries in class.) Consider the following:</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> __mock_table_1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> colA <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>By default, BusTub will plan this query as a <code>SortPlanNode</code> followed by a <code>LimitPlanNode</code>. This is inefficient because a heap can be used to keep track of the smallest 10 elements far more efficiently than sorting the entire table.</p>
<p>Implement the <code>TopNExecutor</code> and modify the optimizer to use it for queries containing <code>ORDER BY</code> and <code>LIMIT</code> clauses.</p>
<p>An example of the optimized plan of this query:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">TopN &#123; n=<span class="number">10</span>, order_bys=[(<span class="keyword">Default</span>, #<span class="number">0.0</span>)]&#125; | (__mock_table_1.colA:<span class="type">INTEGER</span>, __mock_table_1.colB:<span class="type">INTEGER</span>)</span><br><span class="line">MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:<span class="type">INTEGER</span>, __mock_table_1.colB:<span class="type">INTEGER</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Hint:</strong> See <a href="https://github.com/cmu-db/bustub/blob/master/src/optimizer/sort_limit_as_topn.cpp"><code>OptimizeSortLimitAsTopN</code></a> for more information, and check the <a href="https://15445.courses.cs.cmu.edu/spring2023/project3/##optimizer-rule-implementation-guide">Optimizer Rule Implementation Guide</a> for details on implementing an optimizer rule.</p>
<p><strong>Note:</strong> At this point, your implementation should pass <a href="https://15445.courses.cs.cmu.edu/spring2023/project3/#testing">SQLLogicTests #16 to #19</a>. Integration-test-2 requires you to use release mode to run.</p>
</blockquote>
<p>感觉标准做法应该是使用快速排序的partion思想。但是这里的话，我打算使用另一个实现更简单的思路，也即维护一个元素个数为<code>limit_</code>的有序set，每次插入元素同其最小值比较即可，这样的时间复杂度为<code>O(nlogk)</code>。当k不会太大的时候，我觉得这样应该还是会比快排要快些的。</p>
<h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>本来写到这准备开开心心提交了，突然发现自己的版本似乎跟仓库最新不大一样。rebase了感觉一下午（最后甚至还找了个以前写的小bug……），最后才终于提交完获得了full score……</p>
<p><img src="/2023/03/13/cmu15445/image-20240121200829707.png" alt="image-20240121200829707"></p>
<p>bustub仓库中的每个课程版本都是有这样的小tag了，一开始没发现直接大力出奇迹rebase最新，结果整了半天人麻了。。。</p>
<p><img src="/2023/03/13/cmu15445/image-20240121200726718.png" alt="image-20240121200726718"></p>
<h2 id="Leaderboard-Task"><a href="#Leaderboard-Task" class="headerlink" title="Leaderboard Task"></a>Leaderboard Task</h2><p>最终优化结果：</p>
<img src="/2023/03/13/cmu15445/image-20240202182014046.png" alt="image-20240202182014046" style="zoom:50%;">

<h3 id="Query-1-Where’s-the-Index"><a href="#Query-1-Where’s-the-Index" class="headerlink" title="Query 1: Where’s the Index?"></a>Query 1: Where’s the Index?</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>Consider the following sample database:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1(x <span class="type">INT</span>, y <span class="type">INT</span>, z <span class="type">INT</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> t1xy <span class="keyword">ON</span> t1(x, y);</span><br></pre></td></tr></table></figure>

<p>Now a user comes along and executes the following query.</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> x &gt;= <span class="number">90</span> <span class="keyword">AND</span> y = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>Even though there is an index on <code>t1.x</code> and <code>t1.y</code>, BusTub does not pick it for the scan!</p>
<p><strong>Recommended Optimizations:</strong> Use index scan for this query. Create a clustered index to store the value within the index (you may want to change the value type of index being created). Furthermore, add functionality to the B+ tree iterator to quickly skip keys. You may add your optimizer rule to <a href="https://github.com/cmu-db/bustub/blob/master/src/optimizer/optimizer_custom_rules.cpp"><code>optimizer_custom_rules.cpp</code></a>. You may also want to modify the index scan plan to save the predicate.</p>
</blockquote>
<p>经过实践可得，bustub只会将索引为关键字的order-by优化为index-scan：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 未优化为index<span class="operator">-</span>scan</span><br><span class="line">bustub<span class="operator">&gt;</span> explain (o) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> x <span class="operator">=</span> <span class="number">90</span> <span class="keyword">AND</span> y <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> OPTIMIZER <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line"> <span class="keyword">Filter</span> &#123; predicate<span class="operator">=</span>((#<span class="number">0.0</span><span class="operator">=</span><span class="number">90</span>)<span class="keyword">and</span>(#<span class="number">0.1</span><span class="operator">=</span><span class="number">10</span>)) &#125; </span><br><span class="line">   SeqScan &#123; <span class="keyword">table</span><span class="operator">=</span>t1 &#125;                       </span><br><span class="line"># 优化为index<span class="operator">-</span>scan</span><br><span class="line">bustub<span class="operator">&gt;</span> explain (o) <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> x, y;</span><br><span class="line"> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> OPTIMIZER <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>         </span><br><span class="line"> IndexScan &#123; index_oid<span class="operator">=</span><span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>故而，我们在这一小节的优化任务就是，将这种单表查询且条件只涉及索引与常量对比的filter+seqscan优化为index-scan。并且，由于bustub已经保证对于建立了索引的属性不会有键重复的情况，所以我们最需要关注的就是它说的这种范围查找。</p>
<p>并且，bustub对我们的要求事实上是简化了，我们只需优化leaderboard那一个case即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t1(x int, y int, z int);</span><br><span class="line">create index t1xy on t1(x, y);</span><br><span class="line"></span><br><span class="line">INSERT INTO t1 SELECT * FROM __mock_t1;</span><br><span class="line">----</span><br><span class="line">1000000</span><br><span class="line"></span><br><span class="line">explain (o) select * from t1 where x &gt;= 90 and y = 10;</span><br><span class="line"></span><br><span class="line">select * from t1 where x &gt;= 90 and y = 10;</span><br><span class="line">----</span><br><span class="line">91 10 910010</span><br><span class="line">92 10 920010</span><br><span class="line">95 10 950010</span><br><span class="line">93 10 930010</span><br><span class="line">98 10 980010</span><br><span class="line">96 10 960010</span><br><span class="line">90 10 900010</span><br><span class="line">99 10 990010</span><br><span class="line">97 10 970010</span><br><span class="line">94 10 940010</span><br></pre></td></tr></table></figure>

<p>我们可以将该任务分为三部分来实现：</p>
<ol>
<li><p>增加optimizer rule，优化filter+seq scan结点为index scan</p>
<p>其中filter结点的条件需要形如<code>column &lt;comparison&gt; constant</code>及其通过<code>AND</code>连接的这样的表达式。</p>
</li>
<li><p>修改index executor，使其支持区间范围查找（比如该case，区间即为<code>[(90,10), (+∞,10)]</code>）</p>
<p>故而，我们需要在index executor中新增两个字段，<code>current_iterator_</code>和<code>end_iterator_</code>，前者的初值和后者分别表示区间的左右端点。</p>
</li>
</ol>
<p>写了整整一天</p>
<h4 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h4><h5 id="optimizer-rule"><a href="#optimizer-rule" class="headerlink" title="optimizer rule"></a>optimizer rule</h5><p>我首先一步就是启用了未启用的<code>OptimizeMergeFilterScan</code>，也即合并filter和sequence scan。因此，需要修改seqscan executor的部分代码，在循环中加入对predicate条件的判定。因为我感觉确实合起来好处感觉比坏处多。</p>
<p>再然后，我们需要增加自定义规则。这里，我将该规则的优先级置于<code>OptimizeMergeFilterScan</code>，故而在判定时只需检测所有sequence scan结点即可。</p>
<p><code>OptimizeMergeFilterScan</code>我采取了与nlj-&gt;hash join差不多的写法（不如说其实整个架构是参照的<code>OptimizeOrderByAsIndexScan</code>），也即先检测出这个是个sequence scan结点，再对其filter expression进行合法性判断，合法则转化为index scan。不过，这里的实现会复杂许多，具体来说有如下几个问题需要注意：</p>
<ol>
<li><p>索引的匹配</p>
<p>在创建index scan plan node的时候，要求传入索引的序号。参考<code>OptimizeOrderByAsIndexScan</code>的写法，这里需要获取出条件中的column value的下标，然后根据schema获取列名，进行逐一比较即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;columns = index-&gt;key_schema_.<span class="built_in">GetColumns</span>();</span><br><span class="line"><span class="comment">// check index key schema == order by columns</span></span><br><span class="line"><span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (columns.<span class="built_in">size</span>() == column_indexes.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; columns.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (columns[i].<span class="built_in">GetName</span>() </span><br><span class="line">        != table_info-&gt;schema_.<span class="built_in">GetColumn</span>(column_indexes[i]).<span class="built_in">GetName</span>()) &#123;</span><br><span class="line">      valid = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">      <span class="comment">// do something and return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>check函数的实现</p>
<p>本次我们的目标是检测那些形如<code>column &lt;comparison&gt; constant</code>及其通过<code>AND</code>连接的表达式，并且与此同时获取所有的column value，以及上下界的值（通过具体判断”=””&gt;””&lt;”等符号来决定）。故而，我们的递归思路其实也不会太难。以下是一个简化的代码形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Optimizer::CheckIfColumnConstantConjunction</span><span class="params">(<span class="type">const</span> AbstractExpressionRef &amp;expr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 std::vector&lt;<span class="type">uint32_t</span>&gt; *column_indexes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 std::vector&lt;Value&gt; *first_values, std::vector&lt;Value&gt; *last_values)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// if is &quot;AND&quot;</span></span><br><span class="line">  <span class="comment">// 如果是AND，我们只需检测其左右孩子是否满足要求即可</span></span><br><span class="line">  <span class="keyword">if</span> (expr-&gt;type == LogicType::And) &#123;</span><br><span class="line">    <span class="comment">// check children</span></span><br><span class="line">    <span class="comment">// 这里是clang format要求用的std::all_of，确实是涨知识了</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">all_of</span>(expr-&gt;<span class="built_in">GetChildren</span>().<span class="built_in">begin</span>(), expr-&gt;<span class="built_in">GetChildren</span>().<span class="built_in">end</span>(),</span><br><span class="line">                       [<span class="keyword">this</span>, column_indexes, first_values, last_values](<span class="type">const</span> AbstractExpressionRef &amp;child) &#123;</span><br><span class="line">                         <span class="keyword">return</span> <span class="built_in">CheckIfColumnConstantConjunction</span>(child, column_indexes, first_values, last_values);</span><br><span class="line">                       &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if is the comparison expr</span></span><br><span class="line">  <span class="comment">// 否则的话，它只可能是比较表达式，并且左孩子为column value，右孩子为constant value</span></span><br><span class="line">  <span class="keyword">if</span> (expr-&gt;type == Comparison) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left_child is column) &#123;</span><br><span class="line">      <span class="keyword">if</span> (right_child is column) &#123;</span><br><span class="line">        <span class="comment">// fill in column_indexes, first_values, last_values</span></span><br><span class="line">        <span class="comment">// 此处我多做了一点功夫，也即更面向现实一点，进行了一个column index的去重。</span></span><br><span class="line">        <span class="comment">// 目的是处理这样的式子： v1 &gt; 10 AND v1 &lt; 20</span></span><br><span class="line">        <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">          <span class="comment">// 仅当不重复时才加入，并且两个value默认值都是0</span></span><br><span class="line">          idx = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(column_indexes-&gt;<span class="built_in">size</span>());</span><br><span class="line">          column_indexes-&gt;<span class="built_in">push_back</span>(column_value_expr-&gt;<span class="built_in">GetColIdx</span>());</span><br><span class="line">          first_values-&gt;<span class="built_in">push_back</span>(<span class="built_in">Value</span>(TypeId::INTEGER, <span class="number">0</span>));</span><br><span class="line">          last_values-&gt;<span class="built_in">push_back</span>(<span class="built_in">Value</span>(TypeId::INTEGER, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;Column&gt; columns;</span><br><span class="line">        <span class="keyword">auto</span> v = constant_value_expr-&gt;<span class="built_in">Evaluate</span>(<span class="literal">nullptr</span>, <span class="built_in">Schema</span>(columns));</span><br><span class="line">        <span class="comment">// 如果该比较表达式为&quot;&gt;&quot; &quot;&gt;=&quot;，就可能需要更新左区间</span></span><br><span class="line">        <span class="keyword">if</span> (comparison_expr-&gt;comp_type_ == ComparisonType::GreaterThan ||</span><br><span class="line">            comparison_expr-&gt;comp_type_ == ComparisonType::GreaterThanOrEqual) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((*first_values)[idx].<span class="built_in">CompareLessThan</span>(v) == CmpBool::CmpTrue) &#123;</span><br><span class="line">            (*first_values)[idx] = v;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 同理，如果该比较表达式为&quot;&lt;&quot; &quot;&lt;=&quot;，就可能需要更新右区间，如果该比较表达式为&quot;&lt;=&quot;，无条件更新两个区间</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，我事实上是指定了一个规则，也即如果valus里面的成员都是0的话，即表示无穷区间。故而，在主函数返回的时候，需要对这个进行处理。</p>
</li>
</ol>
<h5 id="修改executor"><a href="#修改executor" class="headerlink" title="修改executor"></a>修改executor</h5><p>相对而言也是较为简单的。我们只需增加对<code>current_iterator_</code>和<code>end_iterator_</code>的初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// end iterator差不多同理</span></span><br><span class="line"><span class="keyword">if</span> (plan_-&gt;first_key_.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">	current_iterator_ = std::<span class="built_in">make_unique</span>&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt;(</span><br><span class="line">    tree-&gt;<span class="built_in">GetBeginIterator</span>(plan_-&gt;first_key_.<span class="built_in">value</span>(), <span class="literal">true</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	current_iterator_ = std::<span class="built_in">make_unique</span>&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt;(tree-&gt;<span class="built_in">GetBeginIterator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改迭代条件即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (current_iterator_-&gt;<span class="built_in">IsEnd</span>() || *current_iterator_ == *end_iterator_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (tuple_meta.is_deleted_ ||</span><br><span class="line">         (plan_-&gt;<span class="built_in">Predicate</span>() != <span class="literal">nullptr</span> &amp;&amp; !(plan_-&gt;<span class="built_in">Predicate</span>()-&gt;<span class="built_in">Evaluate</span>(&amp;tuple, <span class="built_in">GetOutputSchema</span>()).<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;())));</span><br></pre></td></tr></table></figure>



<h5 id="修改底层b-树的实现"><a href="#修改底层b-树的实现" class="headerlink" title="修改底层b+树的实现"></a>修改底层b+树的实现</h5><p>在这里，我多做了一个本次实验未涉及的小问题，也即当左右区间端点并不是关键字的时候的解决方法。我通过模糊查询解决了此问题，也即：</p>
<ol>
<li>当左区间端点不是关键字，索引返回其所在叶结点的起始元素位置；</li>
<li>当右区间端点不是关键字，索引返回其所在叶结点的下一个叶结点的起始元素位置。</li>
</ol>
<p>其实就是lower-bound和upper-bound了（）</p>
<p>要实现此，就需要对b+树索引新增两个参数，一个是<code>is_ambiguous</code>，表示是否使用模糊查找（直接返回叶结点起始位置）；另一个是<code>is_end_ambiguous</code>，开启则返回所在叶结点下一个叶结点的起始元素位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (is_ambiguous) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_end_ambiguous) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(bpm_, root-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(bpm_, res_pgid);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = <span class="built_in">INDEXITERATOR_TYPE</span>(bpm_, res_pgid);</span><br><span class="line">  <span class="keyword">while</span> (!(it.<span class="built_in">IsEnd</span>() || <span class="built_in">comparator_</span>((*it).first, key) == <span class="number">0</span>)) &#123;</span><br><span class="line">    ++it;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能支持完美的范围模糊查找了。</p>
<h5 id="其他小问题"><a href="#其他小问题" class="headerlink" title="其他小问题"></a>其他小问题</h5><ol>
<li><p>与其他executor的兼容</p>
<p>众所周知，称为“迭代器”的东西都有一个毛病：不支持边遍历边修改。基于b+树迭代器的index scan也是一样。故而，面对“删”操作和“改”操作需要进行特殊处理。</p>
<p>对delete操作的处理，我一开始使用了一个小trick，也即记录一个<code>last_tuple</code>，每次在遍历到一个叶结点的时候，对该叶结点上一个结点进行修改。这样就能一定程度上避免当前迭代到的叶结点和delete操作的叶结点是两个结点了。</p>
<p>不过到后来，我觉得多做可能bug也跟着多了，所以直接简单粗暴，那就是，直接不对delete和update的子树进行index scan的优化……在optimizer rule中，如果遇到update或者delete结点，就迅速返回。只能说滑跪也是一门艺术（）</p>
</li>
<li><p>一个死锁bug</p>
<p>我原本的实现中，会在整个迭代器生命周期维护一个读锁，但这就会导致边迭代边修改过程产生死锁。然后我又听说迭代器似乎不要求并发保护，所以我就干脆先把这锁去掉了，尽管我目前简单粗暴的实现并不会边迭代边修改。</p>
</li>
</ol>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p>与此同时，我的实现有以下这几个不足，所以目前只能面向测试用例服务。</p>
<ol>
<li><p>模糊查找</p>
<p>上面详细讲述了我的模糊查找实现，只是很可惜的是，这样的模糊实现需要修改<code>b_plus_index.h</code>中的函数定义，而gradescope上不能交这个，所以很遗憾我还是只能把这个功能ban了，写了个左右区间端点必是关键字的版本。</p>
</li>
<li><p>部分索引</p>
<p>当有比如说<code>v1 = XX AND v2 &gt; XX AND v3 &lt; 10</code>的条件，并且只有在v1和v2的索引时，我的实现是不会将其转化为index scan的，因为我那边index的查找是做了全匹配。要实现真正的那个啥，就可能需要有最长公共子串匹配之类的算法了。</p>
</li>
</ol>
<h3 id="Query-2-Too-Many-Joins"><a href="#Query-2-Too-Many-Joins" class="headerlink" title="Query 2: Too Many Joins!"></a>Query 2: Too Many Joins!</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>Consider the following sample database:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t4(x int, y int);</span><br><span class="line">CREATE TABLE t5(x int, y int);</span><br><span class="line">CREATE TABLE t6(x int, y int);</span><br></pre></td></tr></table></figure>

<p>The user is not from CMU and they are writing terrible SQL. They forgot how write queries with joins so they puts all predicates in the <code>WHERE</code> clause.</p>
<p>草，有一说一这简直就是我。。。所以可见平时写sql的时候还是尽量多写join</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t4, t5, t6</span><br><span class="line">  WHERE (t4.x = t5.x) AND (t5.y = t6.y) AND (t4.y &gt;= 1000000)</span><br><span class="line">    AND (t4.y &lt; 1500000) AND (t6.x &gt;= 100000) AND (t6.x &lt; 150000);</span><br></pre></td></tr></table></figure>

<p><strong>Recommended Optimizations:</strong> Decompose the filter condition to extract hash join keys, and push down the remaining filter conditions to be below the hash join.</p>
</blockquote>
<p>这个就是我们在课上也学过的“尽早做选择”了，更学术一点的叫法是“<strong>谓词下推</strong>”。以leaderboard中的例子为例，它最终是要取得这样的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain (o) select count(*), max(__mock_t4_1m.x), max(__mock_t4_1m.y), max(__mock_t5_1m.x), max(__mock_t5_1m.y), max(__mock_t6_1m.x), max(__mock_t6_1m.y)</span><br><span class="line">    from __mock_t4_1m, __mock_t5_1m, __mock_t6_1m</span><br><span class="line">        where (__mock_t4_1m.x = __mock_t5_1m.x)</span><br><span class="line">            and (__mock_t6_1m.y = __mock_t5_1m.y)</span><br><span class="line">            and (__mock_t4_1m.y &gt;= 1000000)</span><br><span class="line">            and (__mock_t4_1m.y &lt; 1500000)</span><br><span class="line">            and (__mock_t6_1m.x &lt; 150000)</span><br><span class="line">            and (__mock_t6_1m.x &gt;= 100000);</span><br><span class="line">==============================================================</span><br><span class="line">Agg &#123; types=[count_star, max, max, max, max, max, max], aggregates=[1, #0.0, #0.1, #0.2, #0.3, #0.4, #0.5], group_by=[] &#125;</span><br><span class="line">  HashJoin &#123; type=Inner, left_key=[#0.3], right_key=[#1.1] &#125;</span><br><span class="line">    HashJoin &#123; type=Inner, left_key=[#0.0], right_key=[#1.0] &#125;</span><br><span class="line">      Filter &#123; predicate=((#0.1&gt;=1000000)and(#0.1&lt;1500000)) &#125;</span><br><span class="line">        MockScan &#123; table=__mock_t4_1m &#125;</span><br><span class="line">      MockScan &#123; table=__mock_t5_1m &#125;</span><br><span class="line">    Filter &#123; predicate=((#0.0&lt;150000)and(#0.0&gt;=100000)) &#125;</span><br><span class="line">      MockScan &#123; table=__mock_t6_1m &#125;</span><br></pre></td></tr></table></figure>

<p>这个图画得就很清楚：（<a href="https://zhuanlan.zhihu.com/p/629349099">from</a>）</p>
<p><img src="/2023/03/13/cmu15445/v2-e6f25de30bca4fd6f96a0cd85fc7dbc4_1440w.png" alt="img"></p>
<h4 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h4><h5 id="predicate-push-down"><a href="#predicate-push-down" class="headerlink" title="predicate push down"></a>predicate push down</h5><p>体感上，这个任务的思维难度和规则实现复杂度是远高于q1的，但由于q1涉及范围太广，所以最终两者耗时还是不相上下，写了我大概6、7个小时。</p>
<p>我的大体思路是，整一个这样的递归主体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Optimizer::PredicatePushdown</span><span class="params">(<span class="type">const</span> AbstractPlanNodeRef &amp;plan, AbstractExpressionRef &amp;expr)</span> -&gt; AbstractPlanNodeRef</span></span><br></pre></td></tr></table></figure>

<p>它接收一个plan对象和一个expr表达式，plan为当前处理的结点，expr表达式为其祖辈结点下推下来的选择谓词。</p>
<p>由于我将<code>OptimizePredicatePushdown</code>的处理放在了<code>OptimizeMergeFilterNLJ</code>和<code>OptimizeMergeFilterScan</code>之后，故而只需特别处理nlj结点、seq scan结点以及filter结点（小概率）。</p>
<ol>
<li><p>nlj结点</p>
<p>首先将祖辈下推的expr和自身的predicate通过AND连接，然后通过一个自定义的工具函数<code>SplitExpression</code>，将表达式分成三类：仅含左孩子的表达式（如<code>#0.0 = #0.3</code>、<code>#0.0 &gt; 100</code>）、仅含右孩子的表达式，以及左右孩子都包含的表达式（如<code>#0.1 &gt; #1.2</code>）。</p>
<p>然后，前两类表达式作为对左右孩子进行递归处理的参数，递归处理左右孩子；最后一类由于涉及左右孩子，故而留下作为当前nlj结点的predicate。</p>
</li>
<li><p>seq scan结点</p>
<p>只需遍历其孩子结点，递归调用谓词下推，然后将expr同它自身原本的predicate连接即可。</p>
</li>
<li><p>filter结点</p>
<p>经过了<code>OptimizeMergeFilterNLJ</code>和<code>OptimizeMergeFilterScan</code>前两步合并还幸存的filter结点，大概也算是个小概率的硬茬了，所以我这里对它的处理同seq scan相同。</p>
</li>
</ol>
<p>这样一来，就完成了谓词下推的总体处理逻辑。接下来，便是比较繁琐的<code>SplitExpression</code>的实现了。它其实逻辑上也没什么好说的，就是各种指针对象创建来创建去容易头晕。。。比如这一坨：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*child_expressions)[left_tuple_idx] = std::<span class="built_in">make_shared</span>&lt;ComparisonExpression&gt;(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, left_column_value_expr-&gt;<span class="built_in">GetColIdx</span>(), left_column_value_expr-&gt;<span class="built_in">GetReturnType</span>()), comparison_expr-&gt;<span class="built_in">GetChildAt</span>(<span class="number">1</span>), comparison_expr-&gt;comp_type_);</span><br></pre></td></tr></table></figure>

<p>然后还有一点要注意的是，<code>SplitExpression</code>还需要记得处理我们上面那三种情况都不满足条件的式子（比如别的测试用例中的<code>v1 + 5 = c1</code>），在上面那三种方法都匹配失败的时候，把它整进middle（也即第三类情况）即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(*middle)) &#123;</span><br><span class="line">	*middle = expr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	*middle = std::<span class="built_in">make_shared</span>&lt;LogicExpression&gt;(*middle, expr, LogicType::And);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="其他小问题-1"><a href="#其他小问题-1" class="headerlink" title="其他小问题"></a>其他小问题</h5><ol>
<li><p>关于<code>MockScan</code></p>
<p>一点很让人难绷的是，好像似乎没法对这东西进行merge filter，因为mock scan相关类我们都是不能修改的。故而，我的实现只能在遇到mockscan结点的时候，手动给它加一个filter爸爸了。</p>
</li>
<li><p><code>OptimizePredicatePushdown</code>的处理时机</p>
<p>与 <a href="https://zhuanlan.zhihu.com/p/629349099">这位博主</a>一样，我也纠结了许久<code>OptimizePredicatePushdown</code>的优先级：</p>
<blockquote>
<p>在处理谓词下推规则时，进行的时机让我纠结了一阵：</p>
<ul>
<li>如果在 <code>OptimizeMergeFilterNLJ</code> 规则之前，那么还需要进行 Filter 下标的重分配</li>
<li>如果在 <code>OptimizeMergeFilterNLJ</code> 规则之后，则下推后，又产生了没有被 Merge 的 Filter 节点</li>
</ul>
<p>最后考虑到实现尽可能简单，我在 <code>OptimizeMergeFilterNLJ</code> 规则之后进行谓词下推，并在递归处理子节点的谓词下推之前，对新产生的子节点再次调用 <code>OptimizeMergeFilterNLJ</code> 规则，完成了偷懒。</p>
</blockquote>
<p>我也采取了跟它类似的做法，不过是调用了该规则的helper函数<code>RewriteExpressionForJoin</code>，来处理上面传下来的这个未merge的filter expression：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nlj_plan.<span class="built_in">Predicate</span>() != <span class="literal">nullptr</span> &amp;&amp; nlj_plan.<span class="built_in">Predicate</span>()-&gt;<span class="built_in">ToString</span>() != <span class="string">&quot;true&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">SplitExpression</span>(nlj_plan.<span class="built_in">Predicate</span>(), &amp;child_expressions, &amp;middle, left_size, right_size);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (expr != <span class="literal">nullptr</span> &amp;&amp; expr-&gt;<span class="built_in">ToString</span>() != <span class="string">&quot;true&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// preprocess before split</span></span><br><span class="line">  expr = <span class="built_in">RewriteExpressionForJoin</span>(expr, left_size, right_size);</span><br><span class="line">  <span class="built_in">SplitExpression</span>(expr, &amp;child_expressions, &amp;middle, left_size, right_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Query-3-The-Mad-Data-Scientist"><a href="#Query-3-The-Mad-Data-Scientist" class="headerlink" title="Query 3: The Mad Data Scientist"></a>Query 3: The Mad Data Scientist</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>Consider the following example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT v, d1, d2 FROM (</span><br><span class="line">  SELECT v,</span><br><span class="line">         MAX(v1) AS d1, MIN(v1), MAX(v2), MIN(v2),</span><br><span class="line">         MAX(v1) + MIN(v1), MAX(v2) + MIN(v2),</span><br><span class="line">         MAX(v1) + MAX(v1) + MAX(v2) AS d2</span><br><span class="line">    FROM t7 LEFT JOIN (SELECT v4 FROM t8 WHERE 1 == 2) ON v &lt; v4</span><br><span class="line">    GROUP BY v</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>(This is not the same as the actual leaderboard query; refer to the test file.)</p>
<p><strong>Recommended Optimizations:</strong> </p>
<ol>
<li>Column pruning – you only need to compute v, d1, d2 from the left table in aggregation, </li>
<li>common expression elimination【公共子表达式消除】, </li>
<li>transform always false filter to dummy scan (values plan node of zero rows)</li>
</ol>
<p><strong>Hint:</strong> You do not need to implement a complete rule for optimizing these queries. (1) a complete predicate pushdown requires you to handle all plan nodes – limit, order by, etc. But to optimize for Q2, you only need to implement push down predicates over hash join / nested loop joins. (2) a complete join reordering requires you to handle predicates correctly (and maybe absorb filters in-between back to the join predicate), and you do not need to do that. Just make your optimizer work with those queries is enough.</p>
</blockquote>
<p>也就是说，本次实验要做的就是恒假选择剪枝、列剪裁这两件事。具体来说，我们可以分为三个步骤实现：</p>
<ol>
<li><p>消除恒假条件</p>
</li>
<li><p>消除无用的投影</p>
</li>
<li><p>消除公共表达式</p>
</li>
</ol>
<h4 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h4><h5 id="eliminate-always-false-filter"><a href="#eliminate-always-false-filter" class="headerlink" title="eliminate always false filter"></a>eliminate always false filter</h5><p>该优化必须要在<code>OptimizeMergeFilterScan</code>之前进行。</p>
<p>自顶向下遍历语法树，当检测到filter结点的条件恒假时，就将其子树替换为一个空白的value结点。</p>
<p>其中，检测条件恒假时，我只对用AND或者OR连接的、只涉及常量比较的表达式进行检测。当为AND，两个子表达式有一个恒假即可；当为OR，需要两个表达式都为恒假。</p>
<h5 id="column-pruning"><a href="#column-pruning" class="headerlink" title="column pruning"></a>column pruning</h5><p>在bustub实现中，实现完全的投影的下推感觉会比谓词下推稍显复杂一些。实现谓词下推需处理filter、scan、join这几种有谓词情况的结点，并且对predicate进行裁剪/连接即可。而投影下推也许需要记住当前投影所需列，然后遍历所有结点进行剪裁，感觉很是复杂。故而，这里为了简单起见，只处理多个连续projection结点情况及projection-aggregation结点情况。</p>
<p>我在<code>OptimizeMergeProjection</code>之后、其余合并谓词之前进行了该优化。</p>
<p>为了简单起见（面向测试用例……），我这里只处理了至少两个连续projection、并且父projection的选择列只有column value（也即没有d1+d2这样的表达式）的情况，就不考虑像谓词下推那样处理每个结点了。也即将这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select d1, d2 from</span><br><span class="line">	select v1 as d1, v1 + v2 as d2, v3 as d3 from t1;</span><br></pre></td></tr></table></figure>

<p>优化成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select v1, v1 + v2 from t1;</span><br></pre></td></tr></table></figure>

<p>故而，我们需要遍历父投影结点，仅留下其需要的列，从而创建一个新的子节点，并且再次递归处理它自身。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">OptimizeColumnPruning</span>(std::<span class="built_in">make_shared</span>&lt;ProjectionPlanNode&gt;(std::<span class="built_in">make_shared</span>&lt;Schema&gt;(parent_projection_plan.<span class="built_in">OutputSchema</span>()), expressions, child_plan.<span class="built_in">GetChildAt</span>(<span class="number">0</span>)));</span><br></pre></td></tr></table></figure>

<p>这样一来，就能将所有符合条件的连续投影合并为一个投影结点。</p>
<h5 id="common-expression-elimination"><a href="#common-expression-elimination" class="headerlink" title="common expression elimination"></a>common expression elimination</h5><p>也即做一个这样的优化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">========== before ==========</span><br><span class="line">select `#0.0`, `#0.1`, `((#0.2+#0.3)+#0.4)`</span><br><span class="line">	Agg &#123; types=[max, max, max, max], aggregates=[#0.1, #0.1, #0.1, #0.2], group_by=[#0.0] &#125; </span><br><span class="line"></span><br><span class="line">========== after ==========</span><br><span class="line">select `#0.0`, `#0.1`, `((#0.1+#0.1)+#0.2)`</span><br><span class="line">    Agg &#123; types=[max, max], aggregates=[#0.1, #0.2], group_by=[#0.0] &#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：aggregation的schema为group-by，aggregates。故而，#0.0为group-by列，#0.1开始才为aggregates列。</p>
</blockquote>
<p>我这里的处理思路是，在做完column pruning之后，再针对projection-aggregation这样的局部结点（面向测试用例）进行特殊处理。为了达到这样的效果，就需要做两件事：</p>
<ol>
<li>精简化aggregation的aggregates和types</li>
<li>改写projection的列名</li>
</ol>
<p>为了实现这两点，我引入了一个position map，对于每一个column value，key为原position，value为精简后的position。比如说，上例的position map应为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for group-by value #0.0, we assume that the group by columns are always in front after processing.</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">4</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>position map在精简化aggregation的aggregates和types时被填充，在改写projection的列名时被使用。这样一来，就成功完成了公共子表达式消除。</p>
]]></content>
  </entry>
  <entry>
    <title>源码解读</title>
    <url>/2023/03/13/cmu15445$lab5/</url>
    <content><![CDATA[<h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><blockquote>
<p><a href="https://www.skyzh.dev/blog/2022-10-05-bustub-query-processing/">https://www.skyzh.dev/blog/2022-10-05-bustub-query-processing/</a></p>
</blockquote>
<p><img src="/2023/03/13/cmu15445/image-20231227153858926.png" alt="image-20231227153858926"></p>
<p>对实验中未涉及的parser、binder、planner、storage等部分进行源码的阅读。</p>
<p>以前一直觉得事务是个很抽象的东西，看了bustub实现，才总算窥见了一点真相……我以前觉得事务是一个包含了执行代码的某个执行体，一直很好奇它具体是怎么实现的。现在才发现，事务其实并不算执行体，它只是相当于一个record，对某个执行过程进行一系列记录和维护，比如说维护读写集、维护锁集之类的。这样，当整个执行体结束之后，它就记录了整个执行体的结果，从而可以对其进行复原和释放锁之类的了，相当于是一个统筹全局的爸爸。感觉这也体现了一种解耦思想，将代码的执行和与数据库的交互（读写、锁）解耦，是一个非常伟大的思想。</p>
]]></content>
  </entry>
  <entry>
    <title>CMU15445</title>
    <url>/2023/03/13/cmu15445/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://15445.courses.cs.cmu.edu/spring2023/">实验官网</a></p>
<p><a href="https://github.com/xiunianjun/cmu15445">代码</a></p>
</blockquote>
<h3 id="Project0-C-Primer"><a href="#Project0-C-Primer" class="headerlink" title="Project0   C++ Primer"></a><a href="/2023/03/13/cmu15445$lab0">Project0   C++ Primer</a></h3><h3 id="Project1-Buffer-Pool"><a href="#Project1-Buffer-Pool" class="headerlink" title="Project1   Buffer Pool"></a><a href="/2023/03/13/cmu15445$lab1">Project1   Buffer Pool</a></h3><h3 id="Project2-B-Tree-Index"><a href="#Project2-B-Tree-Index" class="headerlink" title="Project2   B+Tree Index"></a><a href="/2023/03/13/cmu15445$lab2">Project2   B+Tree Index</a></h3><h3 id="Project3-Query-Execution"><a href="#Project3-Query-Execution" class="headerlink" title="Project3   Query Execution"></a><a href="/2023/03/13/cmu15445$lab3">Project3   Query Execution</a></h3><h3 id="Project4-Concurrency"><a href="#Project4-Concurrency" class="headerlink" title="Project4   Concurrency"></a><a href="/2023/03/13/cmu15445$lab4">Project4   Concurrency</a></h3><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a><a href="/2023/03/13/cmu15445$lab5">源码解读</a></h3>]]></content>
      <tags>
        <tag>labs</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理</title>
    <url>/2023/11/18/compilation_principle/</url>
    <content><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章  绪论"></a>第一章  绪论</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2023/11/18/compilation_principle/image-20231111140301743.png" alt="picture"></p>
<p>可重定位的代码通过linker和loader重定位这部分内容就是在之前那本书学过的。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111140605193.png" alt="picture"></p>
<p>从中，我们也可以看到有语法分析、中间代码的影子。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111140706414.png" alt="picture"></p>
<p>词法分析相当于通过DFA NFA捉出各类符号，形成简单的符号表和token list；语法分析相当于对token list组词成句，判断该句子是否符合语言规则；语义分析相当于对词句进行类型判断和中间代码的生成，获得基本语义。</p>
<h2 id="编译程序总体结构"><a href="#编译程序总体结构" class="headerlink" title="编译程序总体结构"></a>编译程序总体结构</h2><p><img src="/2023/11/18/compilation_principle/image-20230912150030956.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117195321134.png" alt="picture"></p>
<p><strong>语法制导翻译：语义分析和中间代码生成集成到语法分析中</strong></p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>将结果转化为token的形式。</p>
<p><img src="/2023/11/18/compilation_principle/image-20230912150219789.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111141534566.png" alt="picture"></p>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>从token list中识别出各个短语，并且构造语法分析树。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111141746384.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20230912150256855.png" alt="picture"></p>
<p>相当于是通过文法来进行归约（自底向上的语法分析），从而判断给定句子是否合法。</p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p><img src="/2023/11/18/compilation_principle/image-20231111142323311.png" alt="picture"></p>
<ol>
<li>收集标识符的属性信息，并将其存入符号表</li>
</ol>
<p><img src="/2023/11/18/compilation_principle/image-20231111142018960.png" alt="picture"></p>
<p>种属就是比如是函数还是数组之类的。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111142131418.png" alt="picture"></p>
<ol start="2">
<li>语义检查</li>
</ol>
<p><img src="/2023/11/18/compilation_principle/image-20231111142248100.png" alt="picture"></p>
<ol start="3">
<li><p>静态绑定</p>
<p>包括绑定代码相对地址（子程序）、数据相对地址（变量）</p>
</li>
</ol>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p><img src="/2023/11/18/compilation_principle/image-20231111142423484.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20230912150651183.png" alt="picture"></p>
<p>波兰也就是前序遍历二叉树（中左右），逆波兰也就是后序遍历二叉树（左右中）</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111142700484.png" alt="picture"></p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p><img src="/2023/11/18/compilation_principle/image-20230912150917534.png" alt="picture"></p>
<ol>
<li><p>无关机器</p>
<p><img src="/2023/11/18/compilation_principle/image-20230912150954990.png" alt="picture"></p>
</li>
<li><p>有关机器</p>
<p><img src="/2023/11/18/compilation_principle/image-20230912151022455.png" alt="picture"></p>
</li>
</ol>
<h3 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h3><p><img src="/2023/11/18/compilation_principle/image-20230912151115068.png" alt="picture"></p>
<h3 id="表格管理"><a href="#表格管理" class="headerlink" title="表格管理"></a>表格管理</h3><p>这也挺好理解，相当于管理符号表吧。</p>
<p><img src="/2023/11/18/compilation_principle/image-20230912151202843.png" alt="picture"></p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><img src="/2023/11/18/compilation_principle/image-20230912151224791.png" alt="picture"></p>
<h2 id="编译程序的组织"><a href="#编译程序的组织" class="headerlink" title="编译程序的组织"></a>编译程序的组织</h2><p>了解了编译程序的基本结构，那么我们就可以想想该怎么实现这个编译器了。</p>
<p>最直观的想法是，我们有几个步骤就对代码进行多少次扫描：</p>
<ol>
<li>首先扫一次，进行词法分析，将所有标识符写入到符号表中，同时进行语法分析，看看有没有错，如果出错了就转到错误处理，没有的话就进行语义分析；（三合一）</li>
<li>然后再针对得出来的语义分析树进行中间代码生成；</li>
<li>再对得出来的中间代码进行代码优化，最后对优化出来的代码进行翻译处理。（二合一）</li>
</ol>
<p><img src="/2023/11/18/compilation_principle/image-20230912151807557.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20230912151833383.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20230912151921220.png" alt="picture"></p>
<h2 id="实现编译器"><a href="#实现编译器" class="headerlink" title="实现编译器"></a>实现编译器</h2><p><img src="/2023/11/18/compilation_principle/image-20230912152940349.png" alt="picture"></p>
<h3 id="T形图"><a href="#T形图" class="headerlink" title="T形图"></a>T形图</h3><p><img src="/2023/11/18/compilation_principle/image-20230912153008796.png" alt="picture"></p>
<h3 id="自展"><a href="#自展" class="headerlink" title="自展"></a>自展</h3><p><img src="/2023/11/18/compilation_principle/image-20230912153133302.png" alt="picture"></p>
<p>也就是说：</p>
<ol>
<li>P0是汇编语言，可以用来编译C语言子集；（P0：汇编语言，C子集→汇编）</li>
<li>P1是机器语言，可以用来把汇编语言翻译为机器语言；（P1：机器语言，汇编→机器）</li>
<li>所以我们就得到了P2，也即一个可以用来编译C语言子集的机器语言程序；（P2：机器语言，C子集→汇编）</li>
<li>然后我们就可以用C语言子集来写C语言编译程序P3，再用P2翻译P3，就可以得到工具P4。（P4：汇编语言，C→汇编）</li>
</ol>
<p><img src="/2023/11/18/compilation_principle/image-20230912153726618.png" alt="image-20230912153726618"></p>
<p>帅的。</p>
<h3 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h3><p><img src="/2023/11/18/compilation_principle/image-20230912154048256.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20230912154039266.png" alt="picture"></p>
<h3 id="本机编译器的利用"><a href="#本机编译器的利用" class="headerlink" title="本机编译器的利用"></a>本机编译器的利用</h3><p><img src="/2023/11/18/compilation_principle/image-20230912154244842.png" alt="picture"></p>
<h3 id="编译程序的自动生成"><a href="#编译程序的自动生成" class="headerlink" title="编译程序的自动生成"></a>编译程序的自动生成</h3><p>这大概是描述了我们到时候会怎么实现这两个阶段代码。</p>
<p>不过确实，词法分析可以看作是正则匹配，语法分析可以看作是产生式。</p>
<p><img src="/2023/11/18/compilation_principle/image-20230912154325688.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20230912154336462.png" alt="picture"></p>
<h1 id="第二章-文法等概念"><a href="#第二章-文法等概念" class="headerlink" title="第二章  文法等概念"></a>第二章  文法等概念</h1><p><img src="/2023/11/18/compilation_principle/image-20231111160656018.png" alt="image-20231111160656018"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>字母表</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111143157256.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111143221621.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111143239147.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111143314759.png" alt="picture"></p>
</li>
<li><p>串</p>
<p>克林闭包中的每一个元素都称为是字母表Σ上的一个串</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111143409565.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111143432642.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111143446877.png" alt="picture"></p>
</li>
</ol>
<h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><p><img src="/2023/11/18/compilation_principle/image-20231111143548871.png" alt="picture"></p>
<p>如果文法用于描述单词，基本符号就是字母；用于描述句子，基本符号就是单词</p>
<ol>
<li><p>文法的形式化定义</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111143705962.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111143731539.png" alt="picture"></p>
<p>由于可以从它们推出其他语法成分，故而称之为非终结符</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111143847519.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111143913889.png" alt="picture"></p>
<p>还真是最大的语法成分</p>
</li>
<li><p>产生式</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111144029955.png" alt="picture"></p>
</li>
<li><p>符号约定</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111144058226.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111144118715.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111144152251.png" alt="picture"></p>
<p><strong>文法符号串</strong>应该就是指<strong>既包含终结符也包含非终结符的，也可能是空</strong>串的串。</p>
<p>注意终结符号串也包括空串。</p>
</li>
</ol>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p><img src="/2023/11/18/compilation_principle/image-20231111144248318.png" alt="picture"></p>
<p>这部分就是要讲怎么看一个串是否满足文法规则，那么我们就需要先从什么样的串是满足文法规则的串开始说起，也即引入“语言”的概念。</p>
<ol>
<li><p>推导与归约</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111144434533.png" alt="picture"></p>
<p>然后也分为最左推导和最右推导，对应最右归约和最左归约。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111144542412.png" alt="picture"></p>
<p>故而，如果<strong>从开始符号可以推导（派生）出该句子，或者从该句子可以归约到开始符号</strong>，那么该句子就是该语言的句子。</p>
</li>
<li><p>句子与句型</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111144904130.png" alt="picture"></p>
<p>句型就是可以有非终结符，句子就是只能有终结符</p>
</li>
<li><p>语言</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111144955639.png" alt="picture"></p>
<p><strong>文法解决了无穷语言的有穷表示问题。</strong></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111145104473.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111145137813.png" alt="picture"></p>
<p>emm，就是好像没有∩运算</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111145223966.png" alt="picture"></p>
<p>有正则那味了</p>
</li>
</ol>
<h2 id="乔姆斯基文法体系"><a href="#乔姆斯基文法体系" class="headerlink" title="乔姆斯基文法体系"></a>乔姆斯基文法体系</h2><p><img src="/2023/11/18/compilation_principle/image-20231111145335622.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111150037107.png" alt="picture"></p>
<ol>
<li><p>0型</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111145357478.png" alt="picture"></p>
</li>
<li><p>1型</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111145502020.png" alt="picture"></p>
<p>之所以是上下文有关，是因为只有A的上下文为a1和a2时才能替换为β【666666，第一次懂】</p>
<p>CSG不包含空产生式。</p>
</li>
<li><p>2型</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111145641168.png" alt="picture"></p>
<p>左部只能是<strong>一个</strong>非终结符。</p>
</li>
<li><p>3型</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111145753395.png" alt="picture"></p>
<p>产生式右部最多只有一个非终结符，且要在同一侧</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111145910824.png" alt="picture"></p>
<p>看起来还能转（是的，自动机教的已经全忘了（））</p>
</li>
</ol>
<h2 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h2><p><strong>正则文法用于判定大多数标识，但是无法判断句子构造</strong>。</p>
<ol>
<li>分析树</li>
</ol>
<p><img src="/2023/11/18/compilation_principle/image-20231111154812943.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111154859986.png" alt="picture"></p>
<p>也就是说，每个句型都有自己对应的分析树。那么接下来就介绍什么是句型的短语</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111154955368.png" alt="picture"></p>
<p>意思就是直接短语是高度为2的子树的边缘，<strong>直接短语一定是某个产生式的右部</strong>，但是产生式右部不一定是给定句型的直接短语（因为有可能给定句型的推导用不到那个产生式）</p>
<ol start="2">
<li>二义性文法</li>
</ol>
<p><img src="/2023/11/18/compilation_principle/image-20231111155639435.png" alt="picture"></p>
<p>通过自定义规则消除歧义</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111155714243.png" alt="picture"></p>
<h1 id="第三章-词法分析"><a href="#第三章-词法分析" class="headerlink" title="第三章  词法分析"></a>第三章  词法分析</h1><h2 id="正则语言"><a href="#正则语言" class="headerlink" title="正则语言"></a>正则语言</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><img src="/2023/11/18/compilation_principle/image-20231111163320026.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111163349819.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111163439700.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111163924572.png" alt="picture"></p>
<p>最后两条值得注意</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111163951955.png" alt="picture"></p>
<h3 id="正则定义"><a href="#正则定义" class="headerlink" title="正则定义"></a>正则定义</h3><p><img src="/2023/11/18/compilation_principle/image-20231111164041730.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111164151621.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111164242666.png" alt="picture"></p>
<h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/11/18/compilation_principle/image-20231111204434473.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111204442819.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111204551416.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111204616742.png" alt="picture"></p>
<p>所以真正的终止是输入带到末尾并且指向终态</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h4><p><img src="/2023/11/18/compilation_principle/image-20231111204710524.png" alt="picture"></p>
<h4 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h4><p><img src="/2023/11/18/compilation_principle/image-20231111204757584.png" alt="picture"></p>
<h4 id="NFA与DFA转化"><a href="#NFA与DFA转化" class="headerlink" title="NFA与DFA转化"></a>NFA与DFA转化</h4><p><img src="/2023/11/18/compilation_principle/image-20231111204853606.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111205038930.png" alt="picture"></p>
<h4 id="e-NFA"><a href="#e-NFA" class="headerlink" title="e-NFA"></a>e-NFA</h4><p><img src="/2023/11/18/compilation_principle/image-20231111205128195.png" alt="picture"></p>
<h4 id="e-NFA与NFA转化"><a href="#e-NFA与NFA转化" class="headerlink" title="e-NFA与NFA转化"></a>e-NFA与NFA转化</h4><p><img src="/2023/11/18/compilation_principle/image-20231111205228158.png" alt="picture"></p>
<h2 id="词法分析相关"><a href="#词法分析相关" class="headerlink" title="词法分析相关"></a>词法分析相关</h2><h3 id="识别单词的DFA"><a href="#识别单词的DFA" class="headerlink" title="识别单词的DFA"></a>识别单词的DFA</h3><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p><img src="/2023/11/18/compilation_principle/image-20231111212751036.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111212906336.png" alt="picture"></p>
<p>66666，还能这么捏起来</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111213005572.png" alt="picture"></p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p><img src="/2023/11/18/compilation_principle/image-20231111213140343.png" alt="picture"></p>
<h4 id="识别token"><a href="#识别token" class="headerlink" title="识别token"></a>识别token</h4><p><img src="/2023/11/18/compilation_principle/image-20231111213217067.png" alt="picture"></p>
<p>关键字是在识别完标识符之后进行查表识别的</p>
<h3 id="scanner的错误处理"><a href="#scanner的错误处理" class="headerlink" title="scanner的错误处理"></a>scanner的错误处理</h3><p>说实话没太看懂</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111213412934.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111213454870.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111213506162.png" alt="picture"></p>
<h1 id="第四章-语法分析"><a href="#第四章-语法分析" class="headerlink" title="第四章  语法分析"></a>第四章  语法分析</h1><p>根据给定文法，识别各类短语，构造分析树。所以关键就是怎么构建分析树</p>
<h2 id="自顶向下LL-1"><a href="#自顶向下LL-1" class="headerlink" title="自顶向下LL(1)"></a>自顶向下LL(1)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>可以看做是推导（派生）的过程。<br><strong>如果同一非终结符的各个产生式的可选集互不相交</strong>，就可以进行确定的自顶向下分析：</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111222323130.png" alt="picture"></p>
<p>这两个分析也是我们的分析方法需要解决的。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111222405544.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111222420530.png" alt="picture"></p>
<p>也就是说，在<u>自顶向下</u>分析时，采用的是<strong>最左推导</strong>；在<u>自底向上</u>分析时，<strong>最左归约和最右推导</strong>才是正道！</p>
<h3 id="通用算法"><a href="#通用算法" class="headerlink" title="通用算法"></a>通用算法</h3><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="/2023/11/18/compilation_principle/image-20231111222818446.png" alt="picture"></p>
<p>大概流程应该是，有产生式就展开，然后当产生式右部有多个候选式的时候再根据输入决定。</p>
<h4 id="递归下降分析"><a href="#递归下降分析" class="headerlink" title="递归下降分析"></a>递归下降分析</h4><p><img src="/2023/11/18/compilation_principle/image-20231111223024140.png" alt="picture"></p>
<p>如果有多个以输入终结符打头的右部候选，那就需要逐一尝试错了再回溯，因而效率较低。</p>
<h4 id="预测分析"><a href="#预测分析" class="headerlink" title="预测分析"></a>预测分析</h4><p><img src="/2023/11/18/compilation_principle/image-20231111223447888.png" alt="picture"></p>
<p>66666，这其实就可以类似于动态规划了吧</p>
<p><strong>【感觉这里也能窥见一些算法设计的思想。</strong></p>
<p><strong>仔细想想，我们在引入动态规划时，也是这个说辞：对于一些回溯问题，回溯效率太低，所以我们就可以提前通过动态规划的思想构造一个状态转移表，到时候只需从零开始按照表进行状态转移即可。</strong></p>
<p><strong>仔细想想，这不就是这里这个预测分析提出的思想吗！真的牛逼，6666</strong></p>
<p><strong>我记得KMP算法一开始也是这个思想，感觉十分神奇】</strong></p>
<h3 id="文法转换"><a href="#文法转换" class="headerlink" title="文法转换"></a>文法转换</h3><h4 id="什么情况需要改造"><a href="#什么情况需要改造" class="headerlink" title="什么情况需要改造"></a>什么情况需要改造</h4><p><img src="/2023/11/18/compilation_principle/image-20231111224131714.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111224251494.png" alt="picture"></p>
<h4 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h4><h5 id="直接左递归"><a href="#直接左递归" class="headerlink" title="直接左递归"></a>直接左递归</h5><p><img src="/2023/11/18/compilation_principle/image-20231111224542931.png" alt="picture"></p>
<p>这个左递归及其消除方法解释得很形象</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111224619133.png" alt="picture"></p>
<h5 id="间接左递归"><a href="#间接左递归" class="headerlink" title="间接左递归"></a>间接左递归</h5><p><img src="/2023/11/18/compilation_principle/image-20231111224717169.png" alt="picture"></p>
<p>先转化为直接左递归</p>
<h4 id="消除回溯"><a href="#消除回溯" class="headerlink" title="消除回溯"></a>消除回溯</h4><p><img src="/2023/11/18/compilation_principle/image-20231111224806610.png" alt="picture"></p>
<p>666666这个解读可以，感觉这个就跟：</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111224823978.png" alt="image-20231111224823978"></p>
<p>这个“向前看”有异曲同工之妙了。</p>
<h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><p><strong>LL(1)文法才能使用预测分析技术</strong>。判断是否是LL文法就得看<strong>具有相同左部的产生式的select集是否相交</strong>。</p>
<h4 id="S-文法"><a href="#S-文法" class="headerlink" title="S_文法"></a>S_文法</h4><p><img src="/2023/11/18/compilation_principle/image-20231111225923993.png" alt="picture"></p>
<p>S文法不包含空产生式</p>
<h4 id="q-文法"><a href="#q-文法" class="headerlink" title="q_文法"></a>q_文法</h4><p><img src="/2023/11/18/compilation_principle/image-20231111225909752.png" alt="picture"></p>
<p>也就是说，<strong>B的Follow集为{b,c}，只有当输入符号为b/c时才能使用空产生式</strong>。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111230333527.png" alt="picture"></p>
<p>first集和follow集不交。</p>
<p>这下总算知道这两个是什么玩意了。也就是这样：</p>
<ol>
<li><p>输入符号与B的First集元素匹配</p>
<p>直接用那个产生式</p>
</li>
<li><p>否则，看输入符号是否与Follow集元素匹配</p>
<ol>
<li><p>是</p>
<p>若B无空产生式，报错；否则，使用B的空产生式（相当于消了一个符号但不变输入带指针）</p>
</li>
<li><p>否</p>
<p>报错</p>
</li>
</ol>
</li>
</ol>
<p><img src="/2023/11/18/compilation_principle/image-20231111230647504.png" alt="picture"></p>
<p>这个感觉跟first集有点像，相当于是右部只能以终结符开始的形式，所以下面的LL文法会增强定义。</p>
<p><strong>当该非终结符对应的所有SELECT集不相交，就可以进行确定的自顶向下语法分析</strong>。这个思想也将贯穿下面的LL文法</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111231321301.png" alt="picture"></p>
<h4 id="LL-1-文法-1"><a href="#LL-1-文法-1" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h4><p><img src="/2023/11/18/compilation_principle/image-20231111231423131.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111231410702.png" alt="picture"></p>
<p>最后，<strong>如果同一非终结符的各个产生式的可选集互不相交</strong>，就可以进行确定的自顶向下分析：</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111231035186.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231111232758160.png" alt="picture"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这几个推理下来，真是让人感觉酣畅淋漓！</p>
<p>确定的自顶向下分析的核心就是，给定一个当前所处的非终结符和一个输入字符[E, a]，我们可以唯一确定一个产生式P用于构建语法分析树。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231111232654126.png" alt="picture"></p>
<p>也即，同一个非终结符的所有产生式的SELECT集必须是<strong>不交的</strong>【才能确保选择产生式的唯一性】。因而，<strong>问题就转化为了如何让SELECT集不交</strong>。</p>
<p>我们需要对空产生式和正常产生式的SELECT集计算做一个分类讨论。</p>
<ol>
<li><p>空产生式</p>
<p>由于可以推导出空，相当于把该符号啥了去读下一个符号，因此我们的问题就转化为输入字符a是否能够跟该符号后面紧跟着的字符相匹配。而紧跟着的字符集我们将其成为FOLLOW集，如果a在follow集中，那么就可以接受，否则不行。</p>
<p>对于LL(1)文法，相当于是进一步处理了简介推出空的串：</p>
<p>​        由于α串-&gt;*空，则α串必定仅由非终结符构成。那么它能推导出的<strong>所有可能</strong>即为SELECT集。故而为<code>First(α)∪Follow(α)</code></p>
</li>
<li><p>非空产生式</p>
<p>很简单，就是其First集。</p>
</li>
</ol>
<p>故而，只需要让这些计算出来的First集合不交，就能进行确定的自顶向下语法分析，构造确定的语法分析树。不得不说真的牛逼。</p>
<p>感觉其“预测分析”的“预测”主要体现在对空产生式的处理上。</p>
<p>总算懂了为什么LL(1)能够解决这个回溯效率太低的问题了，太牛逼。不过问题是怎么转化为LL(1)呢（）上面的消除回溯和左递归只是一部分而已吧。</p>
<h3 id="预测分析法"><a href="#预测分析法" class="headerlink" title="预测分析法"></a>预测分析法</h3><p><img src="/2023/11/18/compilation_principle/image-20231112152418378.png" alt="picture"></p>
<p>这个消除二义性是啥玩意？二轮的时候看看PPT怎么讲的</p>
<h4 id="递归的预测分析"><a href="#递归的预测分析" class="headerlink" title="递归的预测分析"></a>递归的预测分析</h4><p><img src="/2023/11/18/compilation_principle/image-20231112144111437.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112144432098.png" alt="picture"></p>
<p>66666，它这个计算follow集的方法就很直观</p>
<p>declistn有个空产生式，那么我们看得看②，而②的declistn排在最后，也就是说declistn的follow集就是其左部declist的follow集【6666】，所以我们看①，可以发现declist后面为:。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112144717729.png" alt="picture"></p>
<p>如果是终结符，就直接==比较；非终结符，就把token传入到其对应的过程。</p>
<h4 id="非递归的预测分析"><a href="#非递归的预测分析" class="headerlink" title="非递归的预测分析"></a>非递归的预测分析</h4><p><img src="/2023/11/18/compilation_principle/image-20231112145014440.png" alt="picture"></p>
<p>66666</p>
<p>感觉从中又能窥见动态规划的同样思想了。下推自动机其实感觉就像是递归思想（或者说顺序模拟递归，因为它甚至有一个栈，出栈相当于达成条件递归return），动态规划的话可能有点像是把每个不同状态以及不同状态时的栈顶元素整成一个2x2的表，所以感觉思想类似。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112145647129.png" alt="picture"></p>
<p>注意，是栈顶跟输入一样都是非终结符才会移动指针和出栈</p>
<p>值得注意的是，输出的产生式序列就对应了一个最左推导。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112145842176.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112152157112.png" alt="picture"></p>
<h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><p><img src="/2023/11/18/compilation_principle/image-20231112152452712.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112152538620.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112152727160.png" alt="picture"></p>
<p>其实也挺有道理，栈顶是非终结符，但是输入是它的follow集，那我们自然而然可以想到把这b赶跑，看看下面有没有真的它的follow集在嗷嗷待哺。</p>
<h2 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>正确识别句柄</strong>是一个关键问题。</p>
<p>句柄：当前句型的<strong>最左直接短语</strong>。【最左、子树高度为2】</p>
<h4 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h4><p><img src="/2023/11/18/compilation_principle/image-20231112153809849.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112154325377.png" alt="picture"></p>
<p>每次句柄形成就将它归约，因而保证一直是最左归约（recall that，句柄一定是某个产生式的右部，并且每次最左句柄一旦形成就归约）</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112154432092.png" alt="picture"></p>
<p>正如上面的LL分析，每次推导要选择哪个产生式是一个问题；这里的LR分析，每次归约要选择哪个产生式，也即<strong>正确识别句柄</strong>，也是一个关键问题。</p>
<p>所以，我们应该把句柄定义为当前句型的最左直接短语。</p>
<p>如下图所示，左下角是当前句型（画红线部分）的语法分析树，红字为在栈中的部分，蓝字为输入符号串剩余部分。当前句型的<strong>直接短语</strong>（相当于根节点的高度为二的子树，或者说子树前两层）有两个，一个是以<code>&lt;IDS&gt;</code>为根节点的<code>&lt;IDS&gt; , iB</code>，另一个是<code>&lt;T&gt;</code>为根节点的<code>real</code>。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112155014094.png" alt="picture"></p>
<p><strong>而LR分析技术的核心就是正确地识别了句柄</strong>。</p>
<h4 id="LR文法"><a href="#LR文法" class="headerlink" title="LR文法"></a>LR文法</h4><p><img src="/2023/11/18/compilation_principle/image-20231112155440980.png" alt="picture"></p>
<p>也就是说LR技术就是用来识别句柄的，识别完了句柄就可以构建类似自顶向下的预测分析那样的自动机表来进行转移。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112155547984.png" alt="picture"></p>
<ol>
<li><p>移进状态</p>
<p>·后为终结符</p>
</li>
<li><p>待约状态</p>
<p>·后为非终结符</p>
</li>
<li><p>归约状态</p>
<p>·后为空</p>
</li>
</ol>
<p><img src="/2023/11/18/compilation_principle/image-20231112155656933.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112160019688.png" alt="picture"></p>
<p>以前感觉一直很难理解GOTO表的作用，现在感觉稍微明白了点了，你想想，归约之后的那个结果是不是有可能是另一个产生式的右部成分之一，也即一个新的句柄？并且这个也是由你栈顶刚归约好的那个左部和下面的输入符号决定的。那么你自然而然需要切换一下当前状态，以便之后遇到那个产生式的时候能发现到了。</p>
<p>那么，剩下的问题就是如何构造LR分析表了：</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112160838128.png" alt="picture"></p>
<h3 id="算符分析"><a href="#算符分析" class="headerlink" title="算符分析"></a>算符分析</h3><p><img src="/2023/11/18/compilation_principle/image-20231116210010466.png" alt="picture"></p>
<p>也就是它会整一个终结符之间的优先级关系。。。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231116210045015.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231116210128893.png" alt="picture"></p>
<p>也就是说：</p>
<ol>
<li><p>a=b</p>
<p>相邻</p>
</li>
<li><p>a&lt;b</p>
<p>也即在A-&gt;aB时，b在FIRSTOP(B)中（理解一下，这个First指在前面。。。）</p>
</li>
<li><p>a&gt;b</p>
<p>也即在A-&gt;Bb时，a在LASTOP(B)中（理解一下，这个LAST指在后面。。。）</p>
</li>
</ol>
<p><img src="/2023/11/18/compilation_principle/image-20231116210403348.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231116210851975.png" alt="picture"></p>
<p>我服了</p>
<p><img src="/2023/11/18/compilation_principle/image-20231116211302726.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231116211508599.png" alt="picture"></p>
<p>好像#这个固定都是，横的为左，竖的为右</p>
<p><img src="/2023/11/18/compilation_principle/image-20231116212722404.png" alt="picture"></p>
<p>根据优先关系来判断移入和归约</p>
<p><img src="/2023/11/18/compilation_principle/image-20231116213212317.png" alt="picture"></p>
<h3 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h3><h4 id="LR-0"><a href="#LR-0" class="headerlink" title="LR(0)"></a>LR(0)</h4><p>每个分析方法其实都对应着一种构造LR分析表的方法。<br>LR(0)通过构造<strong>规范LR0项集族</strong>，从而构造LR分析表，从而构造LR0 DFA来最终进行语法分析。</p>
<p>每一个项目都对应着句柄识别的一个状态。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112161051362.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112161128029.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112161201907.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112161228677.png" alt="picture"></p>
<p>而肯定不可能整那么多个状态，所以我们需要进行状态合并。（这样也就很容易理解LR的状态族构建了。）</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112163815934.png" alt="picture"></p>
<p>它这里也很直观解释了为什么点遇到非终结符就需要加入其对应的所有产生式，因为在等待该非终结符就相当于在等待它的对应产生式的第一个字母。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112164459093.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112164735691.png" alt="picture"></p>
<p>上面这东西就是这个所谓的规范LR(0)项集族了。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112164916157.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112164957032.png" alt="picture"></p>
<p>但是会产生移进归约冲突：</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112165330771.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231112165351676.png" alt="picture"></p>
<p>还有归约归约冲突：</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112165427936.png" alt="picture"></p>
<p>所以我们就把没有冲突的叫LR(0)文法。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112165527201.png" alt="image-20231112165527201"></p>
<p>感觉上述两个问题都是因为有公共前缀【包括空产生式勉强也能算是这个情况】，导致信息不足无法判断应该怎么做，多读入一个字符（也即LR(1)）应该可以有效解决该问题。</p>
<h4 id="SLR分析"><a href="#SLR分析" class="headerlink" title="SLR分析"></a>SLR分析</h4><p>其实本质还是识别句柄问题，也即此时是归约还是移入，得看是不是句柄。故而LR0信息已经不能帮我们识别句柄了。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113141858123.png" alt="picture"></p>
<p>Follow集可以帮助我们判断。由该状态I2可知，输入一个*应该跳转到I7。如果在I2把T归约为一个E，由Follow集可知E后面不可能有一个*，也就说明在这里进行归约是错误的，应该进行移入。</p>
<p>这种依靠<strong>Follow集和下一个符号</strong>判断的思想，就会运用在SLR分析中。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113142206565.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113142258075.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113142434388.png" alt="picture"></p>
<p>但值得注意的是SLR分析的条件还是相对更严苛，它要求移进项目和归约项目的Follow集不相交，所以它也会产生像下图这样的冲突：</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113142546012.png" alt="picture"></p>
<h4 id="LR-1"><a href="#LR-1" class="headerlink" title="LR(1)"></a>LR(1)</h4><p><img src="/2023/11/18/compilation_principle/image-20231113142842691.png" alt="picture"></p>
<p>SLR将子集扩大到了全集，显然进行了概念扩大。</p>
<p>含义为只有当下一个输入符号是XX时，才能运用这个产生式归约。这个XX是产生式左部非终结符的Follow子集。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113143131304.png" alt="picture"></p>
<p>这玩意只有归约时会用到，这个很显然，毕竟前面提到的LR0的问题就是归约冲突。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113143406696.png" alt="picture"></p>
<p>对了，值得注意的是这个<code>FIRST(βa)</code>，它表示的并不是<code>FIRST(a)∪FIRST(β)</code>，里面的βa应该取连接意，也即，当β为非空时这玩意等于<code>FIRST(β)</code>，当β空时这玩意等于<code>FIRST(a)</code>。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113144055939.png" alt="picture"></p>
<p>刚刚老师对着这个状态转移图进行了一番强大的看图写话操作，我感觉还是十分地牛逼。她从这个图触发，讲述了状态I2为什么不能对R-&gt;L进行归约。</p>
<p>假如我们进行了归约，那么我们就需要弹出状态I2回到I0，压入符号R，I0遇到符号R进入了I3，I3继续归约回到I0，I0遇到符号S到状态I1，但1是接收状态，下一个符号是=不是$，所以错了。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113144119128.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113145133094.png" alt="picture"></p>
<p>比如说I8和I10就是同心的。左边的那个实际上是LR0项目集，所以这里的心指的是LR0。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113145254201.png" alt="picture"></p>
<h4 id="LALR分析"><a href="#LALR分析" class="headerlink" title="LALR分析"></a>LALR分析</h4><p>然而，LR(1)会导致状态急剧膨胀，影响效率，所以又提出了个LALR分析。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113145845546.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113150010199.png" alt="picture"></p>
<p>跟前面的SLR对比可以发现，相当于它就是多了个逗号后面的条件。但是这是可以瞎合的吗？不会出啥问题不。。。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113150304592.png" alt="picture"></p>
<p>好吧问题这就来了，LALR可能会产生归约归约冲突。但值得注意的是，它不可能出现归约移入冲突，因为LR1没有这个东西，而LALR只是修改右边的符号，所以也不会有这个。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113150701975.png" alt="picture"></p>
<p>因为LALR实际上是合并了展望符集合，这东西与移进没有关系，所以只会影响归约，不会影响移进。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113151101241.png" alt="picture"></p>
<p>LALR可能<strong>会产生归约归约冲突</strong>。但值得注意的是，它<strong>不可能出现归约移入冲突</strong>，因为LR1没有这个东西，而LALR只是修改右边的符号，所以也不会有这个。</p>
<p>它有可能做多余的归约动作，从而<strong>推迟错误的发现</strong>。</p>
<p>形式上与LR1相同；大小上与LR0/SLR相当；分析能力介于SLR和LR1之间；展望集仍为Follow集的子集。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>感觉一路看下来，思路还是很流畅的。LR0会产生归约移进冲突和归约归约冲突，所以我们在归约时根据下一个符号是在移进符号还是在Follow集中来判断是要归约还是要移进。但是SLR条件严苛，对于那些移进符号集和Follow集有交的不适用，并且这种情况其实很普遍。加之，出于这个motivation：其实不应该用整个Follow集判断，而是应该用其真子集，所以我们开发出来个LR1文法。然后LR1文法虽然效果好但是状态太多了，所以我们再次折中一下，造出来个效果没有那么好但是状态少的LALR文法。</p>
<h4 id="二义性文法的LR"><a href="#二义性文法的LR" class="headerlink" title="二义性文法的LR"></a>二义性文法的LR</h4><p><img src="/2023/11/18/compilation_principle/image-20231113153354856.png" alt="picture"></p>
<p>所以我们可以用LR对二义性文法进行分析</p>
<p>我们可以通过自定义规则来消除二义性文法的归约移入冲突</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113153518654.png" alt="picture"></p>
<p>对于状态7，此时输入+ or *会面临归约移入冲突。由于有E-&gt;E+E归约式子，可以知道此时栈中为E+E。当输入*，由于<strong>*运算优先级更高</strong>，所以我们在此时进行移入动作转移到I5；当输入+，由于<strong>同运算先执行左结合</strong>，所以我们此时可以安全归约。</p>
<p>对于状态8，由于*运算比+优先级高，且左结合，所以始终进行归约。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113153800860.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113153819450.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113153848078.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113153900879.png" alt="picture"></p>
<h4 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h4><p><img src="/2023/11/18/compilation_principle/image-20231113153954039.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113154034683.png" alt="picture"></p>
<p>它这个意思大概就是，符号栈和状态栈都一直pop，直到pop到一个状态，GOTO[符号栈顶，状态栈顶]有值【注意，始终保持<code>符号栈元素+1 == 状态栈元素数+1</code>】。然后，一直不断丢弃输入符号，直到输入符号在A的Follow集中。此时，就将GOTO值压入栈中继续分析。</p>
<p>【这其实也很有道理。如果输入符号在A的Follow集，说明A之后很有可能可以消耗这个输入符号。】</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113160838344.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113160923423.png" alt="picture"></p>
<h1 id="第五章-语义分析"><a href="#第五章-语义分析" class="headerlink" title="第五章  语义分析"></a>第五章  语义分析</h1><p>注意：</p>
<ol>
<li>语义翻译包含语义分析和中间代码生成</li>
<li>这笔包含了语法分析、语义分析、中间代码生成</li>
</ol>
<p>思想：</p>
<ol>
<li>通过为文法符号设置语义属性，来表达语义信息</li>
<li>通过与产生式（语法规则）相关联的语义规则来计算符号的语义属性值</li>
</ol>
<p>也可能是先入为主吧，感觉用实验的方法来理解语义分析比较便利。语义分析相当于定义一连串事件，附加在每个产生式上。当该产生式进行归约的时候，就执行对应的语义事件。而由于执行语义分析时需要的符号在语法分析栈中，所以我们也同样需要维护一个语义分析栈，在移进时也需要进栈。</p>
<h2 id="SDD-SDT概念"><a href="#SDD-SDT概念" class="headerlink" title="SDD/SDT概念"></a>SDD/SDT概念</h2><p>语义分析一般与语法分析一同实现，这一技术成为语法制导翻译。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113161709638.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113161819971.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113161834028.png" alt="picture"></p>
<h3 id="SDD"><a href="#SDD" class="headerlink" title="SDD"></a>SDD</h3><p><img src="/2023/11/18/compilation_principle/image-20231113162150197.png" alt="picture"></p>
<p>可以回忆一下实验，相当于对每个产生式进行一个switch-case，然后依照产生式的类别和代码规则进行出栈入栈来计算属性值。</p>
<h3 id="SDT"><a href="#SDT" class="headerlink" title="SDT"></a>SDT</h3><p><img src="/2023/11/18/compilation_principle/image-20231113162307565.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113162408135.png" alt="picture"></p>
<h2 id="SDD-1"><a href="#SDD-1" class="headerlink" title="SDD"></a>SDD</h2><p><img src="/2023/11/18/compilation_principle/image-20231113162650850.png" alt="picture"></p>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>一个很简单区分综合属性和继承属性的方法，就是如果定义的是产生式左部的属性，那就是综合属性；右部，那就是继承属性</p>
<h4 id="综合属性"><a href="#综合属性" class="headerlink" title="综合属性"></a>综合属性</h4><p><img src="/2023/11/18/compilation_principle/image-20231113162827636.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113163832788.png" alt="picture"></p>
<h4 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h4><p><img src="/2023/11/18/compilation_principle/image-20231113162854973.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113164116586.png" alt="picture"></p>
<p>这个东西就是我们实验里写的，副作用也是更新符号表。</p>
<h4 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h4><p>没有副作用的SDD称为属性文法。</p>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p><img src="/2023/11/18/compilation_principle/image-20231113164413558.png" alt="picture"></p>
<p>而感觉语法分析这个过程的产生式归约顺序就能一定程度上表示了这个求值顺序</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113164521479.png" alt="picture"></p>
<ol>
<li>继承属性放在结点左边，综合属性放在结点右边</li>
<li>如果属性值A依赖于属性值B，那么就有一条从B到A的箭头【B决定A】</li>
<li>对于副作用，我们将其看作一个<strong>虚综合属性</strong>【注意是综合的，虽然它看起来既由兄弟结点决定也由子节点决定】</li>
<li>可行的求值序列就是<strong>拓扑排序</strong></li>
</ol>
<p><img src="/2023/11/18/compilation_principle/image-20231113165433278.png" alt="picture"></p>
<p>蛤？这不是你自己规则设计有问题吗，关我屁事</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113165523187.png" alt="picture"></p>
<p>其实我还是不大理解，因为这个规则不是user定义的吗？所以产生环不也是它的事，难道说自顶向下或者自底向上分析还能优化SDD定义？？</p>
<p>感觉它意思应该是这样的，有一个方法能绝对不产生循环依赖环，也即将自底向上/自顶向下语法分析与语义分析结合的这个方法。这个方法就是它说的真子集。</p>
<p>所以我们接下来要研究的就是什么样的语义分析可以用自顶向下or自底向上语法分析一起制导。</p>
<h3 id="S-SDD"><a href="#S-SDD" class="headerlink" title="S-SDD"></a>S-SDD</h3><p><img src="/2023/11/18/compilation_principle/image-20231113170553095.png" alt="picture"></p>
<p>那确实，你自底向上想要计算继承属性好像也不大可能</p>
<h3 id="L-SDD"><a href="#L-SDD" class="headerlink" title="L-SDD"></a>L-SDD</h3><p><img src="/2023/11/18/compilation_principle/image-20231113170653148.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113170735475.png" alt="picture"></p>
<p>对应了自顶向下的<strong>最左推导</strong>顺序</p>
<p>S-SDD包含于L-SDD</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113171201608.png" alt="picture"></p>
<h2 id="SDT-1"><a href="#SDT-1" class="headerlink" title="SDT"></a>SDT</h2><p><img src="/2023/11/18/compilation_principle/image-20231113172215498.png" alt="picture"></p>
<h3 id="S-SDD-gt-SDT"><a href="#S-SDD-gt-SDT" class="headerlink" title="S-SDD -&gt; SDT"></a>S-SDD -&gt; SDT</h3><p><img src="/2023/11/18/compilation_principle/image-20231113172322388.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113172359082.png" alt="picture"></p>
<p>当归约发生时执行对应的语义动作</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113172513034.png" alt="picture"></p>
<p>还需要加个属性栈</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113172711030.png" alt="picture"></p>
<p>所以S-SDD+自底向上其实很简单，因为只需在归约的时候进行语义分析，在移进的时候push进属性栈就行了。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117013106735.png" alt="picture"></p>
<p>具体的S-SDD结合语法分析的分析过程可以看<a href="https://www.icourse163.org/learn/HIT-1002123007?tid=1450215473#/learn/content?type=detail&id=1214538609&sm=1">视频</a>。</p>
<p>这个例子还算简单的，毕竟只是综合属性的计算而已，只需要加个属性栈，保存值就行了。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117013424181.png" alt="picture"></p>
<p>我们可以来关注一下这个SDT的设计，也很简单。可以产生式和语义规则分离看待，这也给我们以后设计提供一定的启发。</p>
<h3 id="L-SDD-gt-SDT"><a href="#L-SDD-gt-SDT" class="headerlink" title="L-SDD -&gt; SDT"></a>L-SDD -&gt; SDT</h3><p><img src="/2023/11/18/compilation_principle/image-20231113173152660.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113173253496.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113173544340.png" alt="picture"></p>
<h4 id="非递归的预测分析-1"><a href="#非递归的预测分析-1" class="headerlink" title="非递归的预测分析"></a>非递归的预测分析</h4><p><img src="/2023/11/18/compilation_principle/image-20231113181234782.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113181656031.png" alt="picture"></p>
<p>这个是自顶向下的语法分析，本来只用一个栈就行了，现在需要进行扩展。T的综合属性存放在它的右边，继承属性存放在它的平行位置。</p>
<p>当属性值还没计算完时，不能出栈；当综合记录出栈时，它要将属性值借由语义动作复制给特定属性。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117015036335.png" alt="picture"></p>
<p>然后语义动作也得一起进栈。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117015114181.png" alt="image-20231117015114181"></p>
<p>digit是终结符，只有词法分析器提供值</p>
<p>此时，digit跟一个语义动作关联，所以我们需要把它的值复制给它关联的这个语义动作{a6}，然后才能出栈。</p>
<img src="/2023/11/18/compilation_principle/image-20231117015317921.png" alt="image-20231117015317921" style="zoom:50%;">

<blockquote>
<p>关联的另一个实例：</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117015508123.png" alt="image-20231117015508123"></p>
<p>此时由于T’.inh还要被a3用到，所以我们就得在T’出栈前把它的这个inh值复制给a3。</p>
</blockquote>
<p>当遇到语义动作之后，就执行动作，并且出栈语义动作。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113182558725.png" alt="picture"></p>
<p>它这意思应该是遇到每个产生式的每个符号要执行什么动作都是确定的，所以代码实现是可能的。</p>
<p>可以看到：</p>
<ol>
<li>语义动作代码就是执行</li>
<li>综合属性代码就是赋给关联语义动作</li>
<li>非终结符就是选一个它作为左部的产生式，然后看看要不要用到它自身的属性对右部子属性进行复制（体现了继承属性）</li>
</ol>
<h4 id="递归的预测分析-1"><a href="#递归的预测分析-1" class="headerlink" title="递归的预测分析"></a>递归的预测分析</h4><p><img src="/2023/11/18/compilation_principle/image-20231113183910480.png" alt="picture"></p>
<p>666666666</p>
<p>感觉这个值得深思，但反正现在的我思不出啥了。。。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231113184357577.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113184413140.png" alt="picture"></p>
<h4 id="LR分析-1"><a href="#LR分析-1" class="headerlink" title="LR分析"></a>LR分析</h4><p><img src="/2023/11/18/compilation_principle/image-20231113184535813.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231113184726388.png" alt="picture"></p>
<p>相当于把L-SDD转化为了个S-SDD。具体是这样，把原式子右边的变量替换为marker的继承属性，结果替换为marker的综合属性。那么新符号继承属性怎么算啊。。。不用担心，因为观察可知要使用的这两个非终结符一定已经在栈中了。</p>
<p>具体分析也看视频就好了。</p>
<h1 id="第六章-中间代码生成"><a href="#第六章-中间代码生成" class="headerlink" title="第六章  中间代码生成"></a>第六章  中间代码生成</h1><h2 id="中间代码的形式"><a href="#中间代码的形式" class="headerlink" title="中间代码的形式"></a>中间代码的形式</h2><p><img src="/2023/11/18/compilation_principle/image-20231117132802682.png" alt="picture"></p>
<h3 id="逆波兰（后缀）"><a href="#逆波兰（后缀）" class="headerlink" title="逆波兰（后缀）"></a>逆波兰（后缀）</h3><p><img src="/2023/11/18/compilation_principle/image-20231117132823037.png" alt="picture"></p>
<h3 id="三地址码"><a href="#三地址码" class="headerlink" title="三地址码"></a>三地址码</h3><p><img src="/2023/11/18/compilation_principle/image-20231117132857376.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117132928425.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117133032501.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117232308034.png" alt="picture"></p>
<p>false list就是if失败后的那个goto序号，true list是成功的那个goto序号，s.nextline是整个if的下一条指令</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117232356037.png" alt="picture"></p>
<h3 id="四元式"><a href="#四元式" class="headerlink" title="四元式"></a>四元式</h3><p><img src="/2023/11/18/compilation_principle/image-20231117133559846.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117133641799.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117133916946.png" alt="picture"></p>
<p>增量生成</p>
<h3 id="DAG图"><a href="#DAG图" class="headerlink" title="DAG图"></a>DAG图</h3><p><img src="/2023/11/18/compilation_principle/image-20231117134049564.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117134332304.png" alt="picture"></p>
<h2 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h2><h3 id="类型表达式"><a href="#类型表达式" class="headerlink" title="类型表达式"></a>类型表达式</h3><p><img src="/2023/11/18/compilation_principle/image-20231114134527011.png" alt="picture"></p>
<h3 id="一般声明"><a href="#一般声明" class="headerlink" title="一般声明"></a>一般声明</h3><h4 id="非嵌套"><a href="#非嵌套" class="headerlink" title="非嵌套"></a>非嵌套</h4><p><img src="/2023/11/18/compilation_principle/image-20231117141718821.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117141752196.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117141925619.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114135607007.png" alt="picture"></p>
<h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p><img src="/2023/11/18/compilation_principle/image-20231117142612678.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117143632516.png" alt="picture"></p>
<p>它这个相当于是把符号表和offset都整成了一个栈，毕竟确实过程调用就是得用栈结构的</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117144101729.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117144044829.png" alt="picture"></p>
<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p><img src="/2023/11/18/compilation_principle/image-20231117144159367.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117144240347.png" alt="picture"></p>
<p>之后用到该记录类型，就指向记录符号表即可。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117144732419.png" alt="picture"></p>
<h2 id="简单赋值语句"><a href="#简单赋值语句" class="headerlink" title="简单赋值语句"></a>简单赋值语句</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>这个就不用填符号表了，所以helper function都是用来产生中间代码的</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117144844789.png" alt="picture"></p>
<p>addr属性需要从符号表中获取</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117144953615.png" alt="picture"></p>
<h3 id="临时变量处理"><a href="#临时变量处理" class="headerlink" title="临时变量处理"></a>临时变量处理</h3><p><img src="/2023/11/18/compilation_principle/image-20231117145110693.png" alt="picture"></p>
<h2 id="数组元素寻址"><a href="#数组元素寻址" class="headerlink" title="数组元素寻址"></a>数组元素寻址</h2><p><img src="/2023/11/18/compilation_principle/image-20231117145328642.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114143941194.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117145550405.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117145640707.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117145651346.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117151832498.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117151857333.png" alt="picture"></p>
<h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>看个乐吧</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117152106296.png" alt="picture"></p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><img src="/2023/11/18/compilation_principle/image-20231117152118611.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117152148577.png" alt="picture"></p>
<p>在语义动作中实现</p>
<h2 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h2><h3 id="简单控制流"><a href="#简单控制流" class="headerlink" title="简单控制流"></a>简单控制流</h3><p><img src="/2023/11/18/compilation_principle/image-20231117153522776.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117154312081.png" alt="picture"></p>
<p>反正意思就是用S.next这个继承属性来表示S.code执行完后的下一个三地址码地址。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117154431688.png" alt="picture"></p>
<h4 id="if-then"><a href="#if-then" class="headerlink" title="if-then"></a>if-then</h4><p><img src="/2023/11/18/compilation_principle/image-20231117154604715.png" alt="picture"></p>
<h4 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if-then-else"></a>if-then-else</h4><p><img src="/2023/11/18/compilation_principle/image-20231117154706152.png" alt="picture"></p>
<h4 id="while-do"><a href="#while-do" class="headerlink" title="while-do"></a>while-do</h4><p><img src="/2023/11/18/compilation_principle/image-20231117154755243.png" alt="picture"></p>
<h4 id><a href="#" class="headerlink" title=";"></a>;</h4><p>其实不大懂这什么玩意</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117154934759.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114151544042.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114151804396.png" alt="picture"></p>
<p>抽象</p>
<p><img src="/2023/11/18/compilation_principle/image-20231114151941652.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114152025154.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114152151627.png" alt="picture"></p>
<h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h3><h4 id="布尔表达式翻译"><a href="#布尔表达式翻译" class="headerlink" title="布尔表达式翻译"></a>布尔表达式翻译</h4><h5 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h5><p><img src="/2023/11/18/compilation_principle/image-20231117153655955.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117153853340.png" alt="picture"></p>
<h5 id="数值表示"><a href="#数值表示" class="headerlink" title="数值表示"></a>数值表示</h5><p><img src="/2023/11/18/compilation_principle/image-20231117153943533.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117154033264.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117154205465.png" alt="picture"></p>
<h5 id="控制流表示"><a href="#控制流表示" class="headerlink" title="控制流表示"></a>控制流表示</h5><p><img src="/2023/11/18/compilation_principle/image-20231117155722232.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117155802643.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117155907176.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117160239307.png" alt="picture"></p>
<h4 id="混合模式布尔表达式"><a href="#混合模式布尔表达式" class="headerlink" title="混合模式布尔表达式"></a>混合模式布尔表达式</h4><p><img src="/2023/11/18/compilation_principle/image-20231117160402055.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117160511486.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117160632529.png" alt="picture"></p>
<h4 id="回填"><a href="#回填" class="headerlink" title="回填"></a>回填</h4><h5 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h5><p><img src="/2023/11/18/compilation_principle/image-20231117160714133.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117160746437.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117161920391.png" alt="picture"></p>
<p>这两个都是综合属性</p>
<p>相当于是一个waiting list</p>
<h5 id="布尔表达式的回填"><a href="#布尔表达式的回填" class="headerlink" title="布尔表达式的回填"></a>布尔表达式的回填</h5><p><img src="/2023/11/18/compilation_principle/image-20231117161657187.png" alt="picture"></p>
<p>可以理解为，B这个表达式可以分为两种情况，两种情况有一个为真B就为真。那么，B的真回填list相当于也被分为了两种情况，所以要求B的就是把它们合起来。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117161841553.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117161858720.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117162019665.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117162031648.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117162348542.png" alt="picture"></p>
<p>原来回填是这个意思</p>
<h5 id="控制流结构的回填"><a href="#控制流结构的回填" class="headerlink" title="控制流结构的回填"></a>控制流结构的回填</h5><p>nextline是一个综合属性</p>
<h6 id="if-then-1"><a href="#if-then-1" class="headerlink" title="if-then"></a>if-then</h6><p><img src="/2023/11/18/compilation_principle/image-20231117162621503.png" alt="picture"></p>
<h6 id="if-then-else-1"><a href="#if-then-else-1" class="headerlink" title="if-then-else"></a>if-then-else</h6><p><img src="/2023/11/18/compilation_principle/image-20231117162737368.png" alt="picture"></p>
<h6 id="while-do-1"><a href="#while-do-1" class="headerlink" title="while-do"></a>while-do</h6><p><img src="/2023/11/18/compilation_principle/image-20231117162844535.png" alt="picture"></p>
<h6 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h6><p><img src="/2023/11/18/compilation_principle/image-20231117162904611.png" alt="picture"></p>
<h6 id="for"><a href="#for" class="headerlink" title="for"></a>for</h6><p><img src="/2023/11/18/compilation_principle/image-20231117163627882.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117163826360.png" alt="picture"></p>
<h6 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h6><p><img src="/2023/11/18/compilation_principle/image-20231117163859976.png" alt="picture"></p>
<h6 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h6><p>TODO   这笔之后再看。。。。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117163919294.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117164058117.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117164119210.png" alt="picture"></p>
<h2 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h2><p><img src="/2023/11/18/compilation_principle/image-20231117164204857.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117164216783.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117164258301.png" alt="picture"></p>
<h2 id="输入输出语句"><a href="#输入输出语句" class="headerlink" title="输入输出语句"></a>输入输出语句</h2><p>TODO</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117164351180.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117164359025.png" alt="picture"></p>
<h2 id="题型1-四元序列"><a href="#题型1-四元序列" class="headerlink" title="题型1  四元序列"></a>题型1  四元序列</h2><p><img src="/2023/11/18/compilation_principle/image-20231117163537291.png" alt="picture"></p>
<h1 id="第七章-运行存储分配"><a href="#第七章-运行存储分配" class="headerlink" title="第七章  运行存储分配"></a>第七章  运行存储分配</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><h3 id="存储组织"><a href="#存储组织" class="headerlink" title="存储组织"></a>存储组织</h3><h4 id="活动记录"><a href="#活动记录" class="headerlink" title="活动记录"></a>活动记录</h4><p><img src="/2023/11/18/compilation_principle/image-20231117171051536.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117171128213.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117171228838.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117171300515.png" alt="picture"></p>
<h4 id="静态-动态链"><a href="#静态-动态链" class="headerlink" title="静态/动态链"></a>静态/动态链</h4><p><img src="/2023/11/18/compilation_principle/image-20231117175920514.png" alt="picture"></p>
<p>静态链也被称作访问链，用于访问存放于其他活动记录中的非局部数据。</p>
<p>动态链也被称作控制链，用于指向调用者的活动记录。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117180004684.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117180054430.png" alt="picture"></p>
<h4 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h4><p><img src="/2023/11/18/compilation_principle/image-20231117171950775.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/IMG_20231117_172022.jpg" alt="picture"></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><img src="/2023/11/18/compilation_principle/image-20231117170505088.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117170532844.png" alt="picture"></p>
<h3 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h3><h4 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h4><p><img src="/2023/11/18/compilation_principle/image-20231117170732952.png" alt="picture"></p>
<h4 id="传地址"><a href="#传地址" class="headerlink" title="传地址"></a>传地址</h4><p><img src="/2023/11/18/compilation_principle/image-20231117170800064.png" alt="picture"></p>
<h4 id="传值结果"><a href="#传值结果" class="headerlink" title="传值结果"></a>传值结果</h4><p><img src="/2023/11/18/compilation_principle/image-20231117170823344.png" alt="picture"></p>
<p>反正意思就是既要得到原来的A，又要修改A</p>
<h4 id="传名"><a href="#传名" class="headerlink" title="传名"></a>传名</h4><p><img src="/2023/11/18/compilation_principle/image-20231117170937326.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117172112207.png" alt="picture"></p>
<h2 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h2><p><img src="/2023/11/18/compilation_principle/image-20231117172148583.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114153012920.png" alt="picture"></p>
<h3 id="顺序分配法"><a href="#顺序分配法" class="headerlink" title="顺序分配法"></a>顺序分配法</h3><p><img src="/2023/11/18/compilation_principle/image-20231114153140663.png" alt="picture"></p>
<h3 id="层次分配法"><a href="#层次分配法" class="headerlink" title="层次分配法"></a>层次分配法</h3><p><img src="/2023/11/18/compilation_principle/image-20231117172408087.png" alt="picture"></p>
<h2 id="栈式存储分配"><a href="#栈式存储分配" class="headerlink" title="栈式存储分配"></a>栈式存储分配</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><img src="/2023/11/18/compilation_principle/image-20231117172511529.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114153656196.png" alt="picture"></p>
<p>也就是说左边及其所有子树全调完了，才能调下一个兄弟的。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231114153757311.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114153915178.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114154150835.png" alt="image-20231114154150835"></p>
<p>左边这几点设计规则都十分reasonable，很值得注意。</p>
<p>不过我其实挺好奇，参数存在那么后面该咋访问。。。。看xv6，似乎是fp指向前面，sp才指向local，也即用了两个栈指针。</p>
<p>这个控制链也是约定俗成的，具体可以想起来xv6也是类似结构：</p>
<p><img src="/2023/11/18/compilation_principle/image-20230112010749756.png" alt="picture"></p>
<p>当函数返回的时候，就会进行恢复现场，从而出栈一直到ra，很合理。</p>
<h3 id="调用-返回序列"><a href="#调用-返回序列" class="headerlink" title="调用/返回序列"></a>调用/返回序列</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><img src="/2023/11/18/compilation_principle/image-20231117172559365.png" alt="picture"></p>
<p>调用序列应该就是设置参数、填写栈帧一类，返回序列就是恢复现场</p>
<p><img src="/2023/11/18/compilation_principle/image-20231114163448345.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114163547096.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114163616550.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117172906559.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117172923420.png" alt="picture"></p>
<h4 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h4><p><img src="/2023/11/18/compilation_principle/image-20231117173436377.png" alt="picture"></p>
<h5 id="调用序列"><a href="#调用序列" class="headerlink" title="调用序列"></a>调用序列</h5><p>传变量、改变meta data、改变top和sp指针</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117173612717.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117173658051.png" alt="picture"></p>
<h5 id="返回序列"><a href="#返回序列" class="headerlink" title="返回序列"></a>返回序列</h5><p><img src="/2023/11/18/compilation_principle/image-20231117173808890.png" alt="picture"></p>
<h3 id="变长数据"><a href="#变长数据" class="headerlink" title="变长数据"></a>变长数据</h3><p><img src="/2023/11/18/compilation_principle/image-20231114163655037.png" alt="picture"></p>
<p>这段解释了下为什么不用堆，说得很好</p>
<p><img src="/2023/11/18/compilation_principle/image-20231114163755972.png" alt="picture"></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><img src="/2023/11/18/compilation_principle/image-20231117174306568.png" alt="picture"></p>
<p>第二点，比如malloc后不free</p>
<h2 id="栈中非局部数据的访问"><a href="#栈中非局部数据的访问" class="headerlink" title="栈中非局部数据的访问"></a>栈中非局部数据的访问</h2><p><img src="/2023/11/18/compilation_principle/image-20231114164346770.png" alt="picture"></p>
<h3 id="有过程嵌套"><a href="#有过程嵌套" class="headerlink" title="有过程嵌套"></a>有过程嵌套</h3><p><img src="/2023/11/18/compilation_principle/image-20231114164422157.png" alt="picture"></p>
<h4 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h4><h5 id="访问链"><a href="#访问链" class="headerlink" title="访问链"></a>访问链</h5><p><img src="/2023/11/18/compilation_principle/image-20231114164603745.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117174747278.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117174832911.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117174847771.png" alt="picture"></p>
<h5 id="建立访问链"><a href="#建立访问链" class="headerlink" title="建立访问链"></a>建立访问链</h5><p><img src="/2023/11/18/compilation_principle/image-20231114164851929.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114164943640.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114165052095.png" alt="picture"></p>
<h5 id="过程参数的访问链"><a href="#过程参数的访问链" class="headerlink" title="过程参数的访问链"></a>过程参数的访问链</h5><p><img src="/2023/11/18/compilation_principle/image-20231117175313877.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117175426674.png" alt="picture"></p>
<h4 id="Display表"><a href="#Display表" class="headerlink" title="Display表"></a>Display表</h4><h5 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h5><p>每一个嵌套深度的分配一个Display位</p>
<p>S嵌套深度1，所以占据d[1]；Y和X嵌套深度2，所以占据d[2]；Z嵌套深度3，所以占据d[3]。</p>
<p>然后，一开始遇到个S，d1指向S；然后调用Y，d2指向Y；然后Y中调用X，就修改d2指向X；然后调用Z，就修改d3指向Z。</p>
<p>总之显示栈就是这个变换指针的过程。</p>
<p>至于控制栈，要打印这里面的display表，就是看层数。如果d1那就打印当前层，d2就打印的12层，d3就123层【不是纯显示栈，是它自己内部的未变换指针的结果】</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117225959427.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117230032838.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117230042818.png" alt="picture"></p>
<p>结果：SXZ</p>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p><img src="/2023/11/18/compilation_principle/image-20231117175535226.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117175607305.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117180329608.png" alt="picture"></p>
<h5 id="访问流程"><a href="#访问流程" class="headerlink" title="访问流程"></a>访问流程</h5><p><img src="/2023/11/18/compilation_principle/image-20231117180235703.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117180438408.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117180730318.png" alt="picture"></p>
<h5 id="生成代码-1"><a href="#生成代码-1" class="headerlink" title="生成代码"></a>生成代码</h5><p><img src="/2023/11/18/compilation_principle/image-20231117180838505.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117181023249.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117181052032.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117181110982.png" alt="picture"></p>
<h4 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h4><p>静态作用域是空间上就近原则，动态是时间上。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231117181442971.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117181553476.png" alt="picture"></p>
<h3 id="无过程嵌套"><a href="#无过程嵌套" class="headerlink" title="无过程嵌套"></a>无过程嵌套</h3><p><img src="/2023/11/18/compilation_principle/image-20231114164528749.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114164541337.png" alt="picture"></p>
<p>也就是说这时候非局部的一定是全局变量或者静态的局部变量。</p>
<h3 id="堆管理"><a href="#堆管理" class="headerlink" title="堆管理"></a>堆管理</h3><p><img src="/2023/11/18/compilation_principle/image-20231117181646330.png" alt="picture"></p>
<h4 id="内存管理器"><a href="#内存管理器" class="headerlink" title="内存管理器"></a>内存管理器</h4><h4 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h4><p><img src="/2023/11/18/compilation_principle/image-20231117181818373.png" alt="picture"></p>
<h4 id="堆分配算法"><a href="#堆分配算法" class="headerlink" title="堆分配算法"></a>堆分配算法</h4><h4 id="人工回收请求"><a href="#人工回收请求" class="headerlink" title="人工回收请求"></a>人工回收请求</h4><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><h3 id="如题"><a href="#如题" class="headerlink" title="如题"></a>如题</h3><p><img src="/2023/11/18/compilation_principle/image-20231114165902157.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231114165945689.png" alt="picture"></p>
<p>如果是支持过程声明嵌套，顺着符号表就可以找到其父过程/子过程的数据。</p>
<p>符号表也可以用于构造访问链，因为过程名也是一种符号。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231114170305153.png" alt="picture"></p>
<h3 id="符号表的建立"><a href="#符号表的建立" class="headerlink" title="符号表的建立"></a>符号表的建立</h3><p><img src="/2023/11/18/compilation_principle/image-20231114170418929.png" alt="picture"></p>
<h1 id="第九章-代码生成"><a href="#第九章-代码生成" class="headerlink" title="第九章  代码生成"></a>第九章  代码生成</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p><img src="/2023/11/18/compilation_principle/image-20231117182248619.png" alt="picture"></p>
<h3 id="目标代码形式"><a href="#目标代码形式" class="headerlink" title="目标代码形式"></a>目标代码形式</h3><p><img src="/2023/11/18/compilation_principle/image-20231117182308855.png" alt="picture"></p>
<h3 id="指令选择"><a href="#指令选择" class="headerlink" title="指令选择"></a>指令选择</h3><p><img src="/2023/11/18/compilation_principle/image-20231117182349789.png" alt="picture"></p>
<h3 id="寄存器分配"><a href="#寄存器分配" class="headerlink" title="寄存器分配"></a>寄存器分配</h3><p><img src="/2023/11/18/compilation_principle/image-20231117182416592.png" alt="picture"></p>
<h3 id="计算顺序选择"><a href="#计算顺序选择" class="headerlink" title="计算顺序选择"></a>计算顺序选择</h3><p><img src="/2023/11/18/compilation_principle/image-20231117182448247.png" alt="picture"></p>
<p>不讨论这个</p>
<h2 id="目标语言"><a href="#目标语言" class="headerlink" title="目标语言"></a>目标语言</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><img src="/2023/11/18/compilation_principle/image-20231117182512496.png" alt="picture"></p>
<h3 id="指令开销"><a href="#指令开销" class="headerlink" title="指令开销"></a>指令开销</h3><p><img src="/2023/11/18/compilation_principle/image-20231117182528648.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117182539934.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117182558421.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117182608013.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117182623627.png" alt="picture"></p>
<h3 id="运行时刻地址"><a href="#运行时刻地址" class="headerlink" title="运行时刻地址"></a>运行时刻地址</h3><h2 id="简单的代码生成器"><a href="#简单的代码生成器" class="headerlink" title="简单的代码生成器"></a>简单的代码生成器</h2><h3 id="后续引用信息"><a href="#后续引用信息" class="headerlink" title="后续引用信息"></a>后续引用信息</h3><p><img src="/2023/11/18/compilation_principle/image-20231117182828515.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117182927404.png" alt="picture"></p>
<h3 id="寄存器与地址描述符"><a href="#寄存器与地址描述符" class="headerlink" title="寄存器与地址描述符"></a>寄存器与地址描述符</h3><p><img src="/2023/11/18/compilation_principle/image-20231117182951626.png" alt="picture"></p>
<h3 id="代码生成算法"><a href="#代码生成算法" class="headerlink" title="代码生成算法"></a>代码生成算法</h3><p><img src="/2023/11/18/compilation_principle/image-20231117183024194.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117183140104.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117183149744.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117183159507.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117183212350.png" alt="picture"></p>
<h2 id="窥孔优化"><a href="#窥孔优化" class="headerlink" title="窥孔优化"></a>窥孔优化</h2><p><img src="/2023/11/18/compilation_principle/image-20231117183238255.png" alt="picture"></p>
<h3 id="冗余指令消除"><a href="#冗余指令消除" class="headerlink" title="冗余指令消除"></a>冗余指令消除</h3><p><img src="/2023/11/18/compilation_principle/image-20231117183257632.png" alt="picture"></p>
<h3 id="不可达代码消除"><a href="#不可达代码消除" class="headerlink" title="不可达代码消除"></a>不可达代码消除</h3><p><img src="/2023/11/18/compilation_principle/image-20231117183311213.png" alt="picture"></p>
<h3 id="强度削弱"><a href="#强度削弱" class="headerlink" title="强度削弱"></a>强度削弱</h3><p><img src="/2023/11/18/compilation_principle/image-20231117183329528.png" alt="picture"></p>
<h3 id="特殊机器指令使用"><a href="#特殊机器指令使用" class="headerlink" title="特殊机器指令使用"></a>特殊机器指令使用</h3><p><img src="/2023/11/18/compilation_principle/image-20231117183354736.png" alt="picture"></p>
<h2 id="寄存器分配指派"><a href="#寄存器分配指派" class="headerlink" title="寄存器分配指派"></a>寄存器分配指派</h2><p><img src="/2023/11/18/compilation_principle/image-20231117183424301.png" alt="picture"></p>
<h3 id="全局寄存器分配"><a href="#全局寄存器分配" class="headerlink" title="全局寄存器分配"></a>全局寄存器分配</h3><p><img src="/2023/11/18/compilation_principle/image-20231117183509870.png" alt="picture"></p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p><img src="/2023/11/18/compilation_principle/image-20231117183531327.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117183553775.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117183750248.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117183815060.png" alt="picture"></p>
<p>所以这东西是用来决策寄存器分配的</p>
<h3 id="外层循环的寄存器指派"><a href="#外层循环的寄存器指派" class="headerlink" title="外层循环的寄存器指派"></a>外层循环的寄存器指派</h3><p><img src="/2023/11/18/compilation_principle/image-20231117183851562.png" alt="picture"></p>
<p><img src="/2023/11/18/compilation_principle/image-20231117183958719.png" alt="picture"></p>
<p>反正类似保护现场恢复现场</p>
<h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>在思考自动机和动态规划的关系时，胡乱搜索看到了AC自动机，于是来了解了一下。</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/569429689">算法学习笔记(89): AC自动机 - Pecco的文章 - 知乎</a></p>
</blockquote>
<blockquote>
<p>考虑一个问题：给出若干个模式串，如何构建一个<strong>DFA</strong>，接受所有<strong>以任一模式串结尾</strong>（称为与该模式串<strong>匹配</strong>）的文本串？</p>
<p>可以先思考一个更简单的问题：如何构建接受所有<strong>模式串</strong>的DFA？很明显，**<a href="https://zhuanlan.zhihu.com/p/173981140">字典树</a>**就可以看做符合要求的自动机。例如，有模式串<code>&quot;abab&quot;</code>、<code>&quot;abc&quot;</code>、<code>&quot;bca&quot;</code>、<code>&quot;cc&quot;</code> ，我们把它们插入字典树，可以得到：</p>
<p><img src="/2023/11/18/compilation_principle/v2-610bf072e6ca46f194b45dc2ff39fdc4_1440w.png" alt="picture"></p>
<p>为了使它不仅接受模式串，还接受以模式串结尾的文本串，一个看起来挺正确的改动是，使每个状态接受所有原先不能接受的字符，转移到<strong>初始状态</strong>（即根节点）。</p>
<p><img src="/2023/11/18/compilation_principle/v2-e295f3442cda25ff7e287920b293eaa1_1440w.png" alt="picture"></p>
<p>但是如果我们尝试<code>&quot;abca&quot;</code>，我们会发现我们的自动机并不能接受它。稍加观察发现，我们在状态5接受<code>a</code>应该跳到状态8才对，而不是初始状态。某种意义上来说，状态7是状态5<strong>退而求其次</strong>的选择，因为状态7在trie上对应的字符串<code>&quot;bc&quot;</code>是状态5对应的字符串<code>&quot;abc&quot;</code>的<strong>后缀</strong>。既然状态5原本不能接受<code>&quot;a&quot;</code>，我们完全可以退而求其次看看状态7是否可以接受。这看起来很像<strong>KMP算法</strong>，确实，AC自动机常常被人称作trie上KMP。</p>
<p>所以我们给每个状态分配一条<strong>fail边</strong>，它连向的是该状态对应字符串在trie上存在的<strong>最长真后缀</strong>所对应的状态。我们令所有状态p接受原来不能接受的字符c，转移到 next(fail(p),c) ，特别地，根节点转移到自己。为什么不需要像KMP算法一样，用一个循环不断进行退而求其次的选择呢？因为如果我们用<strong>BFS</strong>的方式进行上面的重构，我们可以保证 fail(p) 在p重构前已经重构完成了，类似于<strong>动态规划</strong>。</p>
<p><img src="/2023/11/18/compilation_principle/image-20231112151642625.png" alt="picture"></p>
<p>这样建fail边和重构完成后得到的自动机称为<strong>AC自动机</strong>（Aho-Corasick Automation）。</p>
<p>我们发现fail边也形成一棵树，所以其实AC自动机包含两棵树：<strong>trie树</strong>和<strong>fail树</strong>。一个重要的性质是，如果当前状态 p 在某个终止状态 s 的fail树的<strong>子树</strong>上，那么当前文本串就与 s 所对应模式串<strong>匹配</strong>。</p>
</blockquote>
<p>也就是说它的解决方法是加fall边（蓝色）和加新边（红色），</p>
]]></content>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2023/06/21/comporgan/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="冯诺依曼"><a href="#冯诺依曼" class="headerlink" title="冯诺依曼"></a>冯诺依曼</h3><p>以运算器为中心，指令和数据同等地位（不满足摩尔定律）</p>
<p><img src="/2023/06/21/comporgan/image-20230617133555268.png" alt="image-20230617133555268"></p>
<h3 id="存储器为中心"><a href="#存储器为中心" class="headerlink" title="存储器为中心"></a>存储器为中心</h3><p><img src="/2023/06/21/comporgan/image-20230617133840406.png" alt="image-20230617133840406"></p>
<h3 id="哈佛架构"><a href="#哈佛架构" class="headerlink" title="哈佛架构"></a>哈佛架构</h3><p>哈佛结构<strong>数据空间和程序空间是分开的</strong></p>
<p><strong>大部分ROM操作部分是采用了冯诺依曼结构</strong>，</p>
<p>有些需要CPU与ROM之间快速的响应和交互，采用的是<strong>5级流水的哈佛结构。</strong></p>
<p>早期（如X86）采用冯诺依曼</p>
<p>DSP和ARM用改进哈佛</p>
<p><img src="/2023/06/21/comporgan/image-20230617134010940.png" alt="image-20230617134010940"></p>
<h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><p><img src="/2023/06/21/comporgan/image-20230617134045099.png" alt="image-20230617134045099"></p>
<h1 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h1><h2 id="数的表示"><a href="#数的表示" class="headerlink" title="数的表示"></a>数的表示</h2><h3 id="无符号数与有符号数"><a href="#无符号数与有符号数" class="headerlink" title="无符号数与有符号数"></a>无符号数与有符号数</h3><h4 id="机器数与真值"><a href="#机器数与真值" class="headerlink" title="机器数与真值"></a>机器数与真值</h4><p><img src="/2023/06/21/comporgan/image-20230619211124996.png" alt="image-20230619211124996"></p>
<p>意思就是真值有±符号，机器数把±符号换成了数字罢了</p>
<h4 id="原码-补码-反码-移码"><a href="#原码-补码-反码-移码" class="headerlink" title="原码/补码/反码/移码"></a>原码/补码/反码/移码</h4><p><img src="/2023/06/21/comporgan/image-20230617142534411.png" alt="image-20230617142534411"></p>
<h5 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h5><p>整数用逗号隔开，小数用小数点隔开</p>
<h6 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h6><p><img src="/2023/06/21/comporgan/image-20230617140847726.png" alt="image-20230617140847726"></p>
<h6 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h6><p><img src="/2023/06/21/comporgan/image-20230617140920563.png" alt="image-20230617140920563"></p>
<h6 id="注意0的特殊情况"><a href="#注意0的特殊情况" class="headerlink" title="注意0的特殊情况"></a>注意0的特殊情况</h6><p><img src="/2023/06/21/comporgan/image-20230617141011120.png" alt="image-20230617141011120"></p>
<h5 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h5><blockquote>
<p>对于负数，原码-&gt;补码符号位不变，数值位按位取反再加一的理论由来。神奇的是对于补码-&gt;原码，也是按位取反再加一。</p>
<p>简单证明一下：</p>
<p>设x为补码，y为原码，n为位数</p>
<p>已知 x = !(y - 2^n) +1</p>
<p>则反转一下可得 y = !(x - 1) + 2^n</p>
</blockquote>
<p>符号位不变，按位取反再加一</p>
<h6 id="整数-1"><a href="#整数-1" class="headerlink" title="整数"></a>整数</h6><p><img src="/2023/06/21/comporgan/image-20230617141209384.png" alt="image-20230617141209384"></p>
<h6 id="小数-1"><a href="#小数-1" class="headerlink" title="小数"></a>小数</h6><p><img src="/2023/06/21/comporgan/image-20230617141232325.png" alt="image-20230617141232325"></p>
<h6 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h6><p><strong>[y]补</strong><u>连同符号位在内</u>，每位取反末位加1，即得**[-y]补**</p>
<p>后面那三个是真的抽象</p>
<p><img src="/2023/06/21/comporgan/image-20230617141627719.png" alt="image-20230617141627719"></p>
<h5 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h5><p>对于正数，反码和原码一致；</p>
<p>对于负数，反码为原码的数值位取反</p>
<h6 id="整数-2"><a href="#整数-2" class="headerlink" title="整数"></a>整数</h6><p><img src="/2023/06/21/comporgan/image-20230617141351461.png" alt="image-20230617141351461"></p>
<h6 id="小数-2"><a href="#小数-2" class="headerlink" title="小数"></a>小数</h6><p><img src="/2023/06/21/comporgan/image-20230617141418617.png" alt="image-20230617141418617"></p>
<h6 id="0"><a href="#0" class="headerlink" title="0"></a>0</h6><p><img src="/2023/06/21/comporgan/image-20230617141525918.png" alt="image-20230617141525918"></p>
<h5 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h5><blockquote>
<p>注意，移码只有整数形式的定义，这与它的用途有关。计算机中，移码通常用来标识浮点数的阶码【阶码是整数】。</p>
</blockquote>
<p>与补码数值位计算方式相同，区别是符号位相反</p>
<p><img src="/2023/06/21/comporgan/image-20230617142858076.png" alt="image-20230617142858076"></p>
<p><img src="/2023/06/21/comporgan/image-20230617145309340.png" alt="image-20230617145309340"></p>
<p>注意，移码的0为100000，最小值为000000</p>
<h3 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h3><h4 id="表示形式和范围"><a href="#表示形式和范围" class="headerlink" title="表示形式和范围"></a>表示形式和范围</h4><p><img src="/2023/06/21/comporgan/image-20230617143220170.png" alt="image-20230617143220170"></p>
<p>注意，这边的上溢和下溢只与阶码有关，与尾数无关。</p>
<p>这个溢出条件及其处理方式需要记，会考</p>
<p><img src="/2023/06/21/comporgan/image-20230617143328674.png" alt="image-20230617143328674"></p>
<h4 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h4><p><img src="/2023/06/21/comporgan/image-20230617143654003.png" alt="image-20230617143654003"></p>
<h5 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h5><p><img src="/2023/06/21/comporgan/image-20230617143731873.png" alt="image-20230617143731873"></p>
<h5 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h5><p><img src="/2023/06/21/comporgan/image-20230617143912465.png" alt="image-20230617143912465"></p>
<p><img src="/2023/06/21/comporgan/image-20230617145251169.png" alt="image-20230617145251169"></p>
<h5 id="题型-表示范围"><a href="#题型-表示范围" class="headerlink" title="题型 表示范围"></a>题型 表示范围</h5><p><img src="/2023/06/21/comporgan/image-20230617145826541.png" alt="image-20230617145826541"></p>
<p>看得我cpu快烧了</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/7b9dd240685c">https://www.jianshu.com/p/7b9dd240685c</a></p>
<p><img src="/2023/06/21/comporgan/image-20230617145857698.png" alt="image-20230617145857698"></p>
<p>之所以最小负数不一样，是因为原码不能表示-1，补码可以；</p>
<p>之所以规格化最大负数是那玩意，是因为最大负数本应为2^-8，为了规格化必须再加个2^-1，然后原码转补码就变成那样了</p>
</blockquote>
<h3 id="IEEE754标准"><a href="#IEEE754标准" class="headerlink" title="IEEE754标准"></a>IEEE754标准</h3><p>难绷，最沙比的来了</p>
<p><img src="/2023/06/21/comporgan/image-20230617150024955.png" alt="image-20230617150024955"></p>
<p>没有阶符和数符力</p>
<p><img src="/2023/06/21/comporgan/image-20230617150101092.png" alt="image-20230617150101092"></p>
<p><img src="/2023/06/21/comporgan/image-20230617150816446.png" alt="image-20230617150816446"></p>
<p>它就相当于指数是移码表示的，并且注意到一点就是指数的0和255被征用表示特殊的数了，所以指数范围为1-254</p>
<p><img src="/2023/06/21/comporgan/image-20230617151013979.png" alt="image-20230617151013979"></p>
<h4 id="题型-把数转化为IEEE754"><a href="#题型-把数转化为IEEE754" class="headerlink" title="题型 把数转化为IEEE754"></a>题型 把数转化为IEEE754</h4><p>首先背一下上面那个数的范围图，然后判断下是规格化还是非规格化，然后套公式就行了</p>
<p><img src="/2023/06/21/comporgan/image-20230617152014370.png" alt="image-20230617152014370"></p>
<p><img src="/2023/06/21/comporgan/image-20230617152309065.png" alt="image-20230617152309065"></p>
<h3 id="算术移位与逻辑移位"><a href="#算术移位与逻辑移位" class="headerlink" title="算术移位与逻辑移位"></a>算术移位与逻辑移位</h3><blockquote>
<p>来自 <a href="https://blog.csdn.net/qq_34283722/article/details/107093193">https://blog.csdn.net/qq_34283722/article/details/107093193</a> ：</p>
<p><img src="/2023/06/21/comporgan/wps1-1687348655099-311.jpg" alt="img"> </p>
<p>这应该与补码的运算机制有关。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230617152527973.png" alt="image-20230617152527973"></p>
<p>反码不论是左还是右都添1</p>
<p><img src="/2023/06/21/comporgan/image-20230617152938114.png" alt="image-20230617152938114"></p>
<p>注意，符号位不变！！！这点在左移的时候需要尤其注意，很容易出错</p>
<h2 id="RISC-V概述"><a href="#RISC-V概述" class="headerlink" title="RISC-V概述"></a>RISC-V概述</h2><h3 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h3><p>ISA位宽：通用寄存器的宽度，决定了寻址范围大小、数据运算强弱。</p>
<h4 id="CISC-RISC"><a href="#CISC-RISC" class="headerlink" title="CISC-RISC"></a>CISC-RISC</h4><p><img src="/2023/06/21/comporgan/image-20230619211742901.png" alt="image-20230619211742901"></p>
<h4 id="X86-amp-MIPS"><a href="#X86-amp-MIPS" class="headerlink" title="X86 &amp; MIPS"></a>X86 &amp; MIPS</h4><p>相比于上述的差异，还有以下几个：</p>
<ol>
<li>x86有8个通用寄存器，MIPS有32个</li>
<li>x86有标志寄存器，MIPS没有</li>
<li>x86为两地址指令，MIPS为三地址</li>
<li>x86有堆栈指令，MIPS没有</li>
<li>x86有IO指令，MIPS设备统一编址</li>
<li>x86函数参数只用栈帧，MIPS用4寄存器+栈帧</li>
<li><strong>X86的字为2字节，MIPS/RISC-V的字为4字节</strong></li>
</ol>
<h3 id="RISC-V的特点"><a href="#RISC-V的特点" class="headerlink" title="RISC-V的特点"></a>RISC-V的特点</h3><ol>
<li><p><strong>RISC-V是小端，也即低字节放在低地址</strong></p>
</li>
<li><p>支持<strong>字节（8位）、半字（16位）、字（32位）、双字（64位，64位架构）</strong>的数据传输</p>
<p>主存按照字节进行编址</p>
</li>
<li><p>采用<strong>哈佛结构</strong></p>
</li>
<li><p>三种特权模式</p>
<p><img src="/2023/06/21/comporgan/image-20230617155657577.png" alt="image-20230617155657577"></p>
</li>
<li><p>模块化设计</p>
<p><img src="/2023/06/21/comporgan/image-20230617155224429.png" alt="image-20230617155224429"></p>
</li>
</ol>
<h2 id="RISC-V汇编语言"><a href="#RISC-V汇编语言" class="headerlink" title="RISC-V汇编语言"></a>RISC-V汇编语言</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><img src="/2023/06/21/comporgan/image-20230619212236116.png" alt="image-20230619212236116"></p>
<p><img src="/2023/06/21/comporgan/image-20230617194244388.png" alt="image-20230617194244388"></p>
<p>x3的全局指的是全局的静态数据区</p>
<h3 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h3><p><img src="/2023/06/21/comporgan/image-20230617160729611.png" alt="image-20230617160729611"></p>
<h4 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h4><p>RISC-V 忽略溢出问题，<strong>高位被截断</strong>，低位写入目标寄存器</p>
<p>如果想要保留乘法所有位：</p>
<p><img src="/2023/06/21/comporgan/image-20230617183814367.png" alt="image-20230617183814367"></p>
<p><img src="/2023/06/21/comporgan/image-20230617183924758.png" alt="image-20230617183924758"></p>
<p><img src="/2023/06/21/comporgan/image-20230617184010487.png" alt="image-20230617184010487"></p>
<h4 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h4><p><img src="/2023/06/21/comporgan/image-20230617184151843.png" alt="image-20230617184151843"></p>
<h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><p><img src="/2023/06/21/comporgan/image-20230617185225785.png" alt="image-20230617185225785"></p>
<p>shift left logical，shift left arithmetic</p>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>ld/sd，lw/sw，lh/sh（半字，也即2字节），lb/sb，以及load指令对应的无符号数（+后缀u）版本。</p>
<p><strong>bAddrReg+offset为4的倍数，数据传输指令除了字节指令（lb sb lbu）外都需要按字对齐。</strong></p>
<p>注意，如果为有符号数取数，放入寄存器时会<strong>自动进行符号扩展</strong>。</p>
<p><img src="/2023/06/21/comporgan/image-20230617191543433.png" alt="image-20230617191543433"></p>
<h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><p><img src="/2023/06/21/comporgan/image-20230617192731684.png" alt="image-20230617192731684"></p>
<h4 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h4><p><img src="/2023/06/21/comporgan/image-20230617193045409.png" alt="image-20230617193045409"></p>
<h4 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h4><p><img src="/2023/06/21/comporgan/image-20230617193346852.png" alt="image-20230617193346852"></p>
<p>j：+label，用于实现无条件跳转，使用相对于当前 PC（程序计数器）的<strong>偏移量</strong>来计算目标地址，跳转范围较广</p>
<p>jr：+寄存器，用于实现通过寄存器的值进行跳转，跳转的目标是存储在寄存器中的地址，<strong>而不是</strong>相对于 PC 的偏移量</p>
<h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h4><p><img src="/2023/06/21/comporgan/image-20230617193450180.png" alt="image-20230617193450180"></p>
<p><img src="/2023/06/21/comporgan/image-20230617193521343.png" alt="image-20230617193521343"></p>
<h3 id="函数调用及栈的使用"><a href="#函数调用及栈的使用" class="headerlink" title="函数调用及栈的使用"></a>函数调用及栈的使用</h3><p><img src="/2023/06/21/comporgan/image-20230617195109547.png" alt="image-20230617195109547"></p>
<h3 id="六种指令格式"><a href="#六种指令格式" class="headerlink" title="六种指令格式"></a>六种指令格式</h3><p><img src="/2023/06/21/comporgan/image-20230617213801145.png" alt="image-20230617213801145"></p>
<p>注意，<strong>jalr属于I型指令</strong>，而非J型指令！！！</p>
<p><img src="/2023/06/21/comporgan/image-20230617213815058.png" alt="image-20230617213815058"></p>
<p><img src="/2023/06/21/comporgan/image-20230620164851924.png" alt="image-20230620164851924"></p>
<h4 id="R型指令"><a href="#R型指令" class="headerlink" title="R型指令"></a>R型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617214018489.png" alt="image-20230617214018489"></p>
<p><img src="/2023/06/21/comporgan/image-20230617214139338.png" alt="image-20230617214139338"></p>
<h4 id="I型指令"><a href="#I型指令" class="headerlink" title="I型指令"></a>I型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617214544561.png" alt="image-20230617214544561"></p>
<p><img src="/2023/06/21/comporgan/image-20230617214659517.png" alt="image-20230617214659517"></p>
<p><img src="/2023/06/21/comporgan/image-20230617214735023.png" alt="image-20230617214735023"></p>
<h5 id="特例1-load"><a href="#特例1-load" class="headerlink" title="特例1 load"></a>特例1 load</h5><p><img src="/2023/06/21/comporgan/image-20230617215007481.png" alt="image-20230617215007481"></p>
<h5 id="特例2-jalr"><a href="#特例2-jalr" class="headerlink" title="特例2 jalr"></a>特例2 jalr</h5><p><img src="/2023/06/21/comporgan/image-20230617215304022.png" alt="image-20230617215304022"></p>
<p>注意，jalr也属于I型指令，且<strong>其funct3为0</strong></p>
<h4 id="S型指令"><a href="#S型指令" class="headerlink" title="S型指令"></a>S型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617215730749.png" alt="image-20230617215730749"></p>
<p><img src="/2023/06/21/comporgan/image-20230617215842401.png" alt="image-20230617215842401"></p>
<h4 id="B型指令"><a href="#B型指令" class="headerlink" title="B型指令"></a>B型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617220521906.png" alt="image-20230617220521906"></p>
<p>这个计算过程很值得注意</p>
<p><img src="/2023/06/21/comporgan/image-20230617220833542.png" alt="image-20230617220833542"></p>
<p><img src="/2023/06/21/comporgan/image-20230617220903564.png" alt="image-20230617220903564"></p>
<p><img src="/2023/06/21/comporgan/image-20230617221131122.png" alt="image-20230617221131122"></p>
<h4 id="U型指令"><a href="#U型指令" class="headerlink" title="U型指令"></a>U型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617221220495.png" alt="image-20230617221220495"></p>
<p><img src="/2023/06/21/comporgan/image-20230617221323268.png" alt="image-20230617221323268"></p>
<p><img src="/2023/06/21/comporgan/image-20230617221508473.png" alt="image-20230617221508473"></p>
<p>666</p>
<h4 id="J型指令"><a href="#J型指令" class="headerlink" title="J型指令"></a>J型指令</h4><p><img src="/2023/06/21/comporgan/image-20230617222154873.png" alt="image-20230617222154873"></p>
<h2 id="寻址方式（x86）"><a href="#寻址方式（x86）" class="headerlink" title="寻址方式（x86）"></a>寻址方式（x86）</h2><blockquote>
<p><img src="/2023/06/21/comporgan/wps4-1687349010620-334.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps5-1687349010620-335.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps6-1687349010620-336.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps7-1687349010621-337.jpg" alt="img"><img src="/2023/06/21/comporgan/wps8-1687349010621-338.jpg" alt="img"> </p>
<p>尽管A很小，但可以让EA很大，从而扩展寻址范围。同时相对于上面的直接寻址，它更容易编程，因为只用修改A存储的那个地址值，而不用修改指令【比如说对数组进行循环，这个间接寻址就只用A++就行，而不用去修改指令里的那个“A”。】。</p>
<p>That is 指针【】</p>
<p><img src="/2023/06/21/comporgan/wps9-1687349010621-339.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps10-1687349010621-340.jpg" alt="img">至于为啥间接寻址不便于循环，也许是因为间接寻址是访存两次比较慢，要是真用来循环还了得</p>
<p><img src="/2023/06/21/comporgan/wps11-1687349010621-341.jpg" alt="img"><img src="/2023/06/21/comporgan/wps12-1687349010621-342.jpg" alt="img"> </p>
<p>程序动态定位</p>
<p><img src="/2023/06/21/comporgan/wps13-1687349010621-343.jpg" alt="img">循环数组时，可以用A作为数组地址，IX作为数组下标？？？【为什么不能用基址寻址？】</p>
<p>应该是因为基址寻址的基址是系统内定的，数组循环问题需要用户指定数组起始地址，所以不能用基址寻址，只能用面向用户的变址寻址。</p>
<p><img src="/2023/06/21/comporgan/wps14-1687349010621-344.jpg" alt="img">区别就在于直接寻址直接把指令参数****硬编码在内存****中，非常耗费空间。变址寻址则把指令参数作为变量了。</p>
<p><img src="/2023/06/21/comporgan/wps15-1687349010621-345.jpg" alt="img">更应该像是指令寻址方式。</p>
<p>程序浮动：程序在内存单元的位置出现变化【毕竟不可能同一个程序在每台电脑都是在同一个物理地址，相当于又减少了硬编码】</p>
<p><img src="/2023/06/21/comporgan/wps16.jpg" alt="img"><img src="/2023/06/21/comporgan/wps17.jpg" alt="img">【为2002H是因为假设字长为2byte】</p>
<p><img src="/2023/06/21/comporgan/wps18.jpg" alt="img"><img src="/2023/06/21/comporgan/wps19.jpg" alt="img"> </p>
<p>一般栈顶地址最低。 </p>
</blockquote>
<h1 id="运算方法"><a href="#运算方法" class="headerlink" title="运算方法"></a>运算方法</h1><h2 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h2><h3 id="一位乘法运算"><a href="#一位乘法运算" class="headerlink" title="一位乘法运算"></a>一位乘法运算</h3><h4 id="原码一位乘"><a href="#原码一位乘" class="headerlink" title="原码一位乘"></a>原码一位乘</h4><blockquote>
<p><img src="/2023/06/21/comporgan/image-20230621195833297.png" alt="image-20230621195833297"></p>
<p>大致明白了：</p>
<p>①乘积一共有四位，故而需要两个寄存器来保存。</p>
<p>②按照上面的原理公式，每次右移一位，被移出的那一位也是最后的结果（相当于竖式中每次相加的最后一位），需要把它存储在另一个寄存器中。</p>
<p>③我们选择了存乘数的寄存器，因为乘数已经乘过的位是没用的。存乘数的那个寄存器的乘数不断被结果的低位所替代。</p>
<p>故****基本流程****：</p>
<p>①准备阶段：清零ACC【置部分积=0】，在MQ中放乘数，X中放被乘数</p>
<p>②判断MQ中乘数最低位，若为1，则ACC部分积加上X中的被乘数；若为0，则ACC不变</p>
<p>③将ACC和MQ中四位数字视作一个整体，符号位也算上，进行逻辑右移，左侧补0.</p>
<p>④重复上述过程，按移位次数来控制结束。</p>
<p>⑤则最后，ACC中存储的就是乘法结果的高位，MQ中存储的结果就是乘法中的低位。</p>
<p>这其实就是我们用的列竖式一行一行加起来的一个过程。</p>
<p><img src="/2023/06/21/comporgan/wps2-1687348739116-313.jpg" alt="img"></p>
<p>S是符号位，GM是乘法标志位。</p>
<p>控制门：当最后一位是1时，控制门打开，X中的被乘数进入加法器。</p>
</blockquote>
<ol>
<li><p>部分积  乘数</p>
</li>
<li><p>乘数不用符号位，写数值位即可</p>
</li>
<li><p>按照是0是1，要么+被乘数要么+0</p>
</li>
<li><p>右移（连符号位一起逻辑右移）</p>
<p><img src="/2023/06/21/comporgan/image-20230620232152706.png" alt="image-20230620232152706"></p>
</li>
<li><p>直到乘数全部移完</p>
</li>
</ol>
<h4 id="Booth算法"><a href="#Booth算法" class="headerlink" title="Booth算法"></a>Booth算法</h4><ol>
<li><p>部分积 乘数 y补（一开始为0）</p>
</li>
<li><p>部分积双符号位，乘数单符号位且参与运算</p>
<p><img src="/2023/06/21/comporgan/image-20230620212054291.png" alt="image-20230620212054291"></p>
</li>
<li><p>每次依据乘数和y补的关系，进行是否加被乘数的决策：</p>
<p>注意右移不同于原码，是算术右移</p>
<p><img src="/2023/06/21/comporgan/image-20230620212122222.png" alt="image-20230620212122222"></p>
</li>
<li><p>最后一步不用移位</p>
<p><img src="/2023/06/21/comporgan/image-20230620212150280.png" alt="image-20230620212150280"></p>
</li>
</ol>
<h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p>逻辑左移</p>
<p><strong>最后得到的余数还得乘个2的-n次方</strong></p>
<h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><ol>
<li>被除数（余数）  商</li>
<li>先加上 - 除数的补</li>
<li>如果得到结果≥0，则上商1，左移</li>
<li>如果小于0，则上商0，+除数补，左移</li>
<li>左移5次（商包括符号位的所有数字被填满），最后一次上商不用移位</li>
</ol>
<h4 id="不恢复余数法（加减交替法）"><a href="#不恢复余数法（加减交替法）" class="headerlink" title="不恢复余数法（加减交替法）"></a>不恢复余数法（加减交替法）</h4><blockquote>
<p><img src="/2023/06/21/comporgan/image-20230621200001791.png" alt="image-20230621200001791"></p>
<p>总结一下，大概流程：</p>
<p>①准备阶段：MQ清零【存放商】，ACC放入被除数，X放入除数</p>
<p>②ACC - X中的值</p>
<p>③若ACC中值【上一轮的余数】为负，则上商0；为正，则上商1.ACC左移一位。判断MQ的最后一位【上商的值】，若为负，则ACC + X中的y<em>；为正，ACC - X中的y</em>。【注意，若为第一次减去X，则当余数为正时，就即刻发生溢出错误退出】</p>
<p>④重复③，直到移位n次。</p>
<p><img src="/2023/06/21/comporgan/wps3-1687348786857-315.jpg" alt="img"> </p>
<p>V表示是否溢出。 </p>
</blockquote>
<ol>
<li><p>被除数（余数） 商</p>
</li>
<li><p>先加上 - 除数的补</p>
</li>
<li><p>如果得到结果≥0，则上商1，左移，下一次继续加 - 除数的补</p>
</li>
<li><p>如果小于0，则上商0，左移，下一次加除数的补</p>
<p><img src="/2023/06/21/comporgan/image-20230620234054088.png" alt="image-20230620234054088"></p>
<p>逻辑左移</p>
</li>
<li><p>左移5次（商包括符号位的所有数字被填满），最后一次上商不用移位</p>
</li>
</ol>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><blockquote>
<p>（1）意思是，舍去的要是1，就在保留数+1.如果是0就直接舍去。</p>
<p><img src="/2023/06/21/comporgan/wps4-1687348858599-317.jpg" alt="img">这意思难道是说可以一次性右移，最后再看要不要+1，而不是移一下加一次1？【不过想了一下，这两种顺序得到的结果好像是一样的。】</p>
</blockquote>
<h2 id="快速进位链"><a href="#快速进位链" class="headerlink" title="快速进位链"></a>快速进位链</h2><blockquote>
<p><a href="https://www.bilibili.com/video/BV1AB4y1p7ax?spm_id_from=333.880.my_history.page.click&amp;vd_source=ac571aae41aa0b588dd184591f27f582">https://www.bilibili.com/video/BV1AB4y1p7ax?spm_id_from=333.880.my_history.page.click&amp;vd_source=ac571aae41aa0b588dd184591f27f582</a> </p>
<p>以及老师在这讲的也挺好的【p88】</p>
<p><img src="/2023/06/21/comporgan/wps5-1687348905962-319.jpg" alt="img"><img src="/2023/06/21/comporgan/wps6.jpg" alt="img"> </p>
<p>当AiBi都为1时，无论Ci是什么，都必定进位1；当AiBi有一个为1时，Ci才会起决定性作用；当AiBi都为0时，无论Ci是什么，都不会进位。因此，AiBi为本地进位，Ai+Bi为传送条件。（乘号表示且，加号表示或）</p>
<p><img src="/2023/06/21/comporgan/wps7.jpg" alt="img">进位链是影响加法器速度的瓶颈</p>
<p><img src="/2023/06/21/comporgan/wps8.jpg" alt="img">但问题是电路太复杂了，因此给出折中方案：</p>
<p><img src="/2023/06/21/comporgan/wps9.jpg" alt="img"> </p>
<p>4先产生进位，传给3，3再产生进位，传给4，依次下去。</p>
<p><img src="/2023/06/21/comporgan/wps10.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps11.jpg" alt="img"><img src="/2023/06/21/comporgan/wps12.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps13.jpg" alt="img"><img src="/2023/06/21/comporgan/wps14.jpg" alt="img"> </p>
<p>相当于又套了一层并行进位链。</p>
<p><img src="/2023/06/21/comporgan/wps15.jpg" alt="img">实在是太强了。感受到还要再套一层分组的必要性了。</p>
</blockquote>
<h1 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h1><h2 id="RISC-V数据通路的组件选择"><a href="#RISC-V数据通路的组件选择" class="headerlink" title="RISC-V数据通路的组件选择"></a>RISC-V数据通路的组件选择</h2><p><img src="/2023/06/21/comporgan/image-20230617232028775.png" alt="image-20230617232028775"></p>
<p><strong>RISC CPU采用哈佛架构。</strong></p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ol>
<li><p>DM Data Memory 数据存储器</p>
<p><strong>读异步</strong>，写有写使能</p>
</li>
<li><p>IM Instruction Memory 指令存储器</p>
<p>一般read only</p>
</li>
</ol>
<h3 id="寄存器堆"><a href="#寄存器堆" class="headerlink" title="寄存器堆"></a>寄存器堆</h3><p>同步写异步读</p>
<p><img src="/2023/06/21/comporgan/image-20230617233101214.png" alt="image-20230617233101214"></p>
<h3 id="立即数扩展（生成）部件"><a href="#立即数扩展（生成）部件" class="headerlink" title="立即数扩展（生成）部件"></a>立即数扩展（生成）部件</h3><p>零扩展、符号扩展</p>
<h3 id="PC（程序计数器）"><a href="#PC（程序计数器）" class="headerlink" title="PC（程序计数器）"></a>PC（程序计数器）</h3><p>支持两种加法：+4、+立即数</p>
<h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><blockquote>
<p>【以下运算器结构适用于累加型运算器。累加器好像意思是一次最多两个输入。 】</p>
<p>运算器的功能是运算，因此其核心就是ALU（算术逻辑单元）。ALU是一个组合电路，组合电路的特点是，如果输入撤销了，那么输出结果也会撤销【组合逻辑电路】。因而，为了让ALU的结果能被保存，必须在输入端加上两个寄存器来保证信号持续输入。这两个寄存器一个叫做ACC，另一个叫做x，也叫做数据寄存器。</p>
<p><img src="/2023/06/21/comporgan/wps1-1687346760932-291.jpg" alt="img">MQ也是寄存器，用于保存计算过程中溢出的位数。</p>
<p><img src="/2023/06/21/comporgan/wps2.jpg" alt="img">具体见第六章，弹幕说汇编语言也有讲。乘法要这样放是为了防止乘积低位覆盖乘数。</p>
<p><img src="/2023/06/21/comporgan/wps3.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps4.jpg" alt="img">ACC里存放着上面的操作或者与外部交流得到的被乘数，按照约定需要转移到X里。我猜M放在MQ而不是ACC，可能是因为第一二步是并行的，如果放在ACC就需要一些等待。</p>
<p>并且乘法做的是移位累加【可能相当于上面乘法原理的第一个图吧】，ACC用来存储这些累加的暂时交换成果，因而需要将ACC先清空为0.</p>
<p>这些操作的先后顺序由控制器进行控制。</p>
<p><img src="/2023/06/21/comporgan/wps5.jpg" alt="img"> </p>
<p>MQ也称乘商寄存器</p>
</blockquote>
<p>运算类型：加、减、或、比较、slt、nor</p>
<p>操作数：寄存器或立即数</p>
<p><img src="/2023/06/21/comporgan/image-20230619214753499.png" alt="image-20230619214753499"></p>
<h2 id="RISC-V部分指令的数据通路设计"><a href="#RISC-V部分指令的数据通路设计" class="headerlink" title="RISC-V部分指令的数据通路设计"></a>RISC-V部分指令的数据通路设计</h2><h3 id="取数指令的完成过程"><a href="#取数指令的完成过程" class="headerlink" title="取数指令的完成过程"></a>取数指令的完成过程</h3><blockquote>
<p><img src="/2023/06/21/comporgan/image-20230621192714673.png" alt="image-20230621192714673"></p>
<p>下面是取数指令的完成过程。</p>
<p>完成一条指令有三个阶段：取指令、分析指令、执行指令。</p>
<p>取指令：PC把地址送到MAR，MAR把地址送到存储体。存储体在控制器的控制下，把地址所对应的指令的内容发给MDR，MDR把取出的指令送到IR.</p>
<p>分析指令：IR将指令的操作码部分交予CU，CU控制IR，IR将指令中的地址码部分交予MAR，MAR给存储体，存储体在控制器控制下给MDR，MDR送给ACC。</p>
<p>【这个过程正像是计算机网络，只不过此处全靠硬件完成，计算机网络只能依靠协议】</p>
</blockquote>
<h3 id="流水线周期"><a href="#流水线周期" class="headerlink" title="流水线周期"></a>流水线周期</h3><h4 id="RISC-V-1"><a href="#RISC-V-1" class="headerlink" title="RISC-V"></a>RISC-V</h4><p><img src="/2023/06/21/comporgan/image-20230617233444017.png" alt="image-20230617233444017"></p>
<p><img src="/2023/06/21/comporgan/image-20230618170512788.png" alt="image-20230618170512788"></p>
<p>注意，在ID阶段还会发生读寄存器</p>
<p><img src="/2023/06/21/comporgan/image-20230617233433422.png" alt="image-20230617233433422"></p>
<h4 id="X86"><a href="#X86" class="headerlink" title="X86"></a>X86</h4><blockquote>
<p>一、指令周期</p>
<ol>
<li>基本概念</li>
</ol>
<p>① 指令周期</p>
<p>② 每条指令的指令周期不同</p>
<p><img src="/2023/06/21/comporgan/wps2-1687349142625-366.jpg" alt="img">ADD取指阶段和执行阶段都需要一次访存</p>
<p>③ 具有间接寻址的指令周期</p>
<p><img src="/2023/06/21/comporgan/wps3-1687349142626-367.jpg" alt="img"> </p>
<p>三个周期各需要访存一次。【****现在暂时还不知道这有毛用****】</p>
<p>④ 具有中断周期的指令周期</p>
<p><img src="/2023/06/21/comporgan/wps4-1687349142626-368.jpg" alt="img"> </p>
<p>⑤ 指令周期的流程</p>
<p><img src="/2023/06/21/comporgan/wps5-1687349142626-369.jpg" alt="img"> </p>
<p>⑥ CPU工作周期的标志</p>
<p>指令周期的不同阶段，控制器要做不同的操作，要发出不同的命令。因而，控制器需要知道当前处于指令周期的哪一个阶段。</p>
<p><img src="/2023/06/21/comporgan/wps6-1687349142626-370.jpg" alt="img">用四个触发器</p>
<ol start="2">
<li>指令周期的数据流</li>
</ol>
<p>① 取指周期</p>
<p><img src="/2023/06/21/comporgan/wps7-1687349142626-371.jpg" alt="img"> </p>
<p>首先，PC把自己里面存的地址放进MAR，再通过地址总线传输给存储器。</p>
<p>CU通过控制总线向存储器发出读控制信号。</p>
<p>存储器执行读操作，通过数据总线传输取到的指令给MDR，MDR再传给IR。</p>
<p>CU把加一后的地址保存在PC中，为下一条指令取指做准备。</p>
<p>② 间址周期</p>
<p><img src="/2023/06/21/comporgan/wps8-1687349142626-372.jpg" alt="img"> </p>
<p>如果指令的数据部分采用的是间接寻址的方式，那么此时，MDR中的地址部分不是有效地址，而是存储存储有效地址的存储单元的地址值。因而，我们需要再通过一次访存操作，把有效地址值存储在MDR中。</p>
<p>③ 执行周期</p>
<p><img src="/2023/06/21/comporgan/wps9-1687349142626-373.jpg" alt="img">留给第九章介绍。</p>
<p>④ 中断周期</p>
<p>做了三件事：保存断点、形成服务程序入口地址、中断返回</p>
<p><img src="/2023/06/21/comporgan/wps10-1687349142626-374.jpg" alt="img"> </p>
<p>首先，保存断点。由CU来确定断电保存在内存单元的哪里。CU把地址传给MAR,MAR将其发到存储器，CU给存储器写命令。PC将自己的值【也就是下一条要执行的命令的地址值】交付给MDR，MDR传给存储器。【MDR在读写操作时都充当了缓冲区的角色。】</p>
<p>然后，CU形成中断服务程序入口地址，并直接把它写入到CU。 </p>
</blockquote>
<h2 id="流水线处理器"><a href="#流水线处理器" class="headerlink" title="流水线处理器"></a>流水线处理器</h2><h3 id="流水线概述"><a href="#流水线概述" class="headerlink" title="流水线概述"></a>流水线概述</h3><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p><img src="/2023/06/21/comporgan/image-20230618150003983.png" alt="image-20230618150003983"></p>
<p>这点我觉得讲得挺好的。以前只知道流水线通过并行来加速指令执行，但这里给出了一个新的思路：如果是单周期处理器，则RISC-V的时钟周期受执行时间最长的指令限制；如果是流水线处理器，时钟周期就可以由某个步骤决定，主频就可以加快。这个出发点很有意思。</p>
<p>如果流水线各阶段平衡，也即每个阶段需要的执行时间差不多，则</p>
<p><img src="/2023/06/21/comporgan/image-20230618150515599.png" alt="image-20230618150515599"></p>
<p>也即在理想条件和有大量指令的情况下，<strong>流水线带来的加速比约等于流水线的级数</strong>，若各阶段不完全平衡，加速比会变小。</p>
<p>流水线技术是通过<strong>提高指令的吞吐率</strong>来提高性能的。</p>
<h4 id="RISC-V与流水线"><a href="#RISC-V与流水线" class="headerlink" title="RISC-V与流水线"></a>RISC-V与流水线</h4><p>我们可以看到，比起X86，<strong>RISC-V是面向流水线设计的</strong>，其特性与流水线高度相关：</p>
<ol>
<li><p><strong>指令长度相同</strong></p>
<p>简化IF和ID</p>
</li>
<li><p><strong>只有六种指令格式，格式整齐</strong></p>
<p>能在一个阶段内完成译码和读寄存器（ID）</p>
</li>
<li><p><strong>只通过load、store访存</strong></p>
<p>可以利用EX阶段计算存储器地址，然后在下一阶段访存（MEM）</p>
</li>
</ol>
<h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><p><img src="/2023/06/21/comporgan/image-20230618151040625.png" alt="image-20230618151040625"></p>
<h4 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h4><p><img src="/2023/06/21/comporgan/image-20230618151208189.png" alt="image-20230618151208189"></p>
<h4 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h4><p><img src="/2023/06/21/comporgan/image-20230618151243620.png" alt="image-20230618151243620"></p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><h6 id="前递"><a href="#前递" class="headerlink" title="前递"></a>前递</h6><p><img src="/2023/06/21/comporgan/image-20230618151601721.png" alt="image-20230618151601721"></p>
<h6 id="编译重排"><a href="#编译重排" class="headerlink" title="编译重排"></a>编译重排</h6><p><img src="/2023/06/21/comporgan/image-20230618151706080.png" alt="image-20230618151706080"></p>
<h6 id="停顿（气泡）"><a href="#停顿（气泡）" class="headerlink" title="停顿（气泡）"></a>停顿（气泡）</h6><p>实在不行只能暂停流水线了</p>
<p><img src="/2023/06/21/comporgan/image-20230618151637437.png" alt="image-20230618151637437"></p>
<h4 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h4><p><img src="/2023/06/21/comporgan/image-20230619220308876.png" alt="image-20230619220308876"></p>
<h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><h6 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h6><p><img src="/2023/06/21/comporgan/image-20230619220259945.png" alt="image-20230619220259945"></p>
<h6 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h6><ol>
<li><p>遇到分支预测就停顿</p>
</li>
<li><p>分支预测</p>
<ol>
<li><p>静态分支预测</p>
<p><img src="/2023/06/21/comporgan/image-20230618153106322.png" alt="image-20230618153106322"></p>
</li>
<li><p>动态分支预测</p>
<p><img src="/2023/06/21/comporgan/image-20230618153125295.png" alt="image-20230618153125295"></p>
</li>
</ol>
</li>
</ol>
<h3 id="流水线数据通路和控制"><a href="#流水线数据通路和控制" class="headerlink" title="流水线数据通路和控制"></a>流水线数据通路和控制</h3><h4 id="流水线数据通路"><a href="#流水线数据通路" class="headerlink" title="流水线数据通路"></a>流水线数据通路</h4><h5 id="流水线寄存器"><a href="#流水线寄存器" class="headerlink" title="流水线寄存器"></a>流水线寄存器</h5><p><img src="/2023/06/21/comporgan/image-20230618154028950.png" alt="image-20230618154028950"></p>
<p><img src="/2023/06/21/comporgan/image-20230618154608423.png" alt="image-20230618154608423"></p>
<p>66666，这个帅</p>
<p><img src="/2023/06/21/comporgan/image-20230618154815411.png" alt="image-20230618154815411"></p>
<h4 id="流水线控制"><a href="#流水线控制" class="headerlink" title="流水线控制"></a>流水线控制</h4><h3 id="数据冒险：前递与停顿"><a href="#数据冒险：前递与停顿" class="headerlink" title="数据冒险：前递与停顿"></a>数据冒险：前递与停顿</h3><h4 id="前递-1"><a href="#前递-1" class="headerlink" title="前递"></a>前递</h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>前递有两种情况：</p>
<p><img src="/2023/06/21/comporgan/image-20230618155952018.png" alt="image-20230618155952018"></p>
<h5 id="前递产生条件"><a href="#前递产生条件" class="headerlink" title="前递产生条件"></a>前递产生条件</h5><ol>
<li>RegWrite != 0（写有效）</li>
<li>Rd != x0</li>
</ol>
<h5 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h5><p>流水线寄存器解决：</p>
<p><img src="/2023/06/21/comporgan/image-20230618160141827.png" alt="image-20230618160141827"></p>
<p>并且增加前递所需硬件。</p>
<h4 id="停顿"><a href="#停顿" class="headerlink" title="停顿"></a>停顿</h4><p>流水线寄存器解决：</p>
<ol>
<li><p>置ID/EX寄存器中控制信号为0（防止寄存器和存储器被写入数据），执行空指令nop</p>
</li>
<li><p>禁止PC寄存器和IF/ID寄存器内容改变</p>
<p>下一条指令就能重新取指</p>
</li>
</ol>
<h3 id="控制冒险-1"><a href="#控制冒险-1" class="headerlink" title="控制冒险"></a>控制冒险</h3><p><img src="/2023/06/21/comporgan/image-20230618161320779.png" alt="image-20230618161320779"></p>
<p><img src="/2023/06/21/comporgan/image-20230618161333487.png" alt="image-20230618161333487"></p>
<p>缩短分支延迟的方法：</p>
<h4 id="硬件支持-1"><a href="#硬件支持-1" class="headerlink" title="硬件支持"></a>硬件支持</h4><p><img src="/2023/06/21/comporgan/image-20230618161429557.png" alt="image-20230618161429557"></p>
<h4 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h4><p><img src="/2023/06/21/comporgan/image-20230618161807387.png" alt="image-20230618161807387"></p>
<p><img src="/2023/06/21/comporgan/image-20230618161932429.png" alt="image-20230618161932429"></p>
<h4 id="计算目标地址"><a href="#计算目标地址" class="headerlink" title="计算目标地址"></a>计算目标地址</h4><p><img src="/2023/06/21/comporgan/image-20230618162114338.png" alt="image-20230618162114338"></p>
<h3 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h3><p><img src="/2023/06/21/comporgan/wps11-1687349247410-385.jpg" alt="img"> </p>
<p><img src="/2023/06/21/comporgan/wps12-1687349247410-386.jpg" alt="img"> </p>
<p>超流水技术要求一个时钟周期内不同的指令不能相互叠加干扰。</p>
<p><img src="/2023/06/21/comporgan/wps13-1687349247410-387.jpg" alt="img"> </p>
<p>意思就是多条指令并成一条，有公共的取指、译码、写回阶段，但是执行阶段各不相同且并行执行，应该是这样。 </p>
<h3 id="例外和中断"><a href="#例外和中断" class="headerlink" title="例外和中断"></a>例外和中断</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><img src="/2023/06/21/comporgan/image-20230618162247586.png" alt="image-20230618162247586"></p>
<p>内部的一定是例外，外部的只有<strong>IO请求和硬件故障</strong>是中断</p>
<p><img src="/2023/06/21/comporgan/image-20230618162302149.png" alt="image-20230618162302149"></p>
<p><img src="/2023/06/21/comporgan/image-20230618162437636.png" alt="image-20230618162437636"></p>
<p><img src="/2023/06/21/comporgan/image-20230618162500928.png" alt="image-20230618162500928"></p>
<p>哦哦哦WOC!!!!!</p>
<p>这让我想起来在做xv6的时候，的那个kerneltrap和usertrap，应该就是这里的这个统一入口地址。</p>
<p>xv6是RISC-V架构，故而发生中断的时候，就会跳转到统一的kernel trap，然后再在里面通过scause进行读取。666</p>
<p>不过盘问了下gpt，RISC-V对于exception和interruption的处理方式是不一样的：</p>
<p>在RISC-V中，异常通常是由于程序执行过程中的错误或非预期事件而引起的，包括<strong>故障（faults）、陷阱（traps）和中止（aborts）</strong>。中断（interrupts）则是由外部事件触发的，例如定时器到期、外部设备请求等。中断是异步事件，与当前正在执行的指令无关，因此会在任何时候发生。</p>
<p>例外是通过统一入口地址处理，中断则是中断向量的方式</p>
<h4 id="流水线中的例外"><a href="#流水线中的例外" class="headerlink" title="流水线中的例外"></a>流水线中的例外</h4><p><img src="/2023/06/21/comporgan/image-20230618163521639.png" alt="image-20230618163521639"></p>
<h2 id="微操作（X86）"><a href="#微操作（X86）" class="headerlink" title="微操作（X86）"></a>微操作（X86）</h2><p>X86将一条指令的执行分为多个微操作。</p>
<blockquote>
<p>一、微操作命令分析</p>
<p>微操作命令是控制单元在完成一大条指令时所需要细分完成的一条条微小的命令</p>
<p><img src="/2023/06/21/comporgan/image-20230621201435702.png" alt="image-20230621201435702"></p>
<ol>
<li><p>取值周期</p>
<p><img src="/2023/06/21/comporgan/image-20230621201345807.png" alt="image-20230621201345807"></p>
</li>
<li><p>间址周期</p>
<p><img src="/2023/06/21/comporgan/image-20230621201351939.png" alt="image-20230621201351939"></p>
</li>
<li><p>执行周期  ①访存指令  ②非访存指令  ③转移指令  ④三类指令的指令周期</p>
<p><img src="/2023/06/21/comporgan/image-20230621201358396.png" alt="image-20230621201358396"></p>
<p><img src="/2023/06/21/comporgan/wps1-1687349648125-391.jpg" alt="img"><img src="/2023/06/21/comporgan/wps2-1687349648126-392.jpg" alt="img"></p>
<p><img src="/2023/06/21/comporgan/image-20230621201423245.png" alt="image-20230621201423245"></p>
</li>
<li><p>中断周期  硬件法和软件法</p>
<p><img src="/2023/06/21/comporgan/wps3-1687349692211-395.jpg" alt="img"><img src="/2023/06/21/comporgan/wps4-1687349692211-396.jpg" alt="img"></p>
<p>硬件和软件法。</p>
</li>
</ol>
<p>二、控制单元的功能</p>
<ol>
<li><p>输入信号</p>
<p>①时钟信号  ②指令寄存器【控制信号与操作码有关】  ③标志  ④外来信号【中断请求、总线请求】</p>
</li>
<li><p>输出信号</p>
<p>①CPU内各种控制信号【比如（PC）+1-&gt;PC这种】</p>
<p>②送至控制总线的信号【比如中断响应、总线响应】</p>
</li>
<li><p>控制信号举例</p>
<p>①不使用内部总线</p>
<p>②采用内部总线</p>
</li>
<li><p>多级时序系统</p>
<ol>
<li><p>机器周期  </p>
<p><strong>取指周期=机器周期=最复杂的微操作所需时间【访存】</strong></p>
<p>在机器周期内部也需要有时钟来控制微操作的执行顺序</p>
</li>
<li><p>时钟周期（节拍、状态）</p>
<p>每个指令周期都可分为若干个机器周期，每个机器周期都可分为若干个节拍（时钟周期）。一个机器周期内包含多少节拍与需要发送多少控制信号、控制信号复杂度、控制信号能否并行有关。</p>
<p>时钟产生节拍信号，不同的节拍信号有不同的先后顺序。</p>
<p>一个时钟周期产生一个或几个【并行的几个，或者是操作时间很短，虽然有一定的先后顺序，但可以在一个节拍内完成】微操作命令</p>
<p>时钟信号利用上升沿让CU发出控制命令【微操作】控制各个不同部件。</p>
</li>
</ol>
</li>
<li><p>控制方式</p>
<p>①同步控制方式  采用<strong>定长的</strong>机器周期、<strong>不定长</strong>的机器周期、<strong>中央控制和局部控制相结合</strong></p>
<p>​    当指令大多都是可以提前确定的，就用同步。当一条微操作的时间很难控制，可以采用异步控制。</p>
<p>②异步控制方式  等待IO读写</p>
<p>③联合控制方式  同步与异步结合</p>
<p>④人工控制</p>
</li>
</ol>
<p>三、组合逻辑设计</p>
<ol>
<li><p>组合逻辑控制单元框图</p>
<p>①CU外特性  ②节拍信号</p>
</li>
<li><p>微操作的节拍安排</p>
<p>①安排微操作时序的原则</p>
<p>原则一：先后顺序不更改。</p>
<p>原则二：可以并行执行的，且微操作间没有先后顺序的，就尽量把它们安排在一个节拍中。</p>
<p>原则三：时间较短微操作尽量在一个节拍内且可以有先后顺序。</p>
<p>②取值周期间址周期执行周期的</p>
<p><img src="/2023/06/21/comporgan/image-20230621201709245.png" alt="image-20230621201709245"></p>
<p><img src="/2023/06/21/comporgan/image-20230621201717225.png" alt="image-20230621201717225"></p>
<p><img src="/2023/06/21/comporgan/image-20230621201722561.png" alt="image-20230621201722561"></p>
<p><img src="/2023/06/21/comporgan/image-20230621201732549.png" alt="image-20230621201732549"></p>
</li>
</ol>
</blockquote>
<h1 id="存储器-1"><a href="#存储器-1" class="headerlink" title="存储器"></a>存储器</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p><img src="/2023/06/21/comporgan/image-20230618183618033.png" alt="image-20230618183618033"></p>
<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><blockquote>
<p>寄存器分为两类，体系结构寄存器和非体系结构寄存器。前者可以让程序员调度使用，后者不行。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618183742599.png" alt="image-20230618183742599"></p>
<p><img src="/2023/06/21/comporgan/image-20230618183845067.png" alt="image-20230618183845067"></p>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><h4 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h4><blockquote>
<p>MAR中的地址需要经过译码器才能得到对应存储体中的位置。MDR中的数据是读是写需要通过读写电路控制，读写电路接收控制电路的读写信号。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618184214916.png" alt="image-20230618184214916"></p>
<h4 id="与CPU连接"><a href="#与CPU连接" class="headerlink" title="与CPU连接"></a>与CPU连接</h4><p><img src="/2023/06/21/comporgan/image-20230618211118255.png" alt="image-20230618211118255"></p>
<h4 id="小端模式"><a href="#小端模式" class="headerlink" title="小端模式"></a>小端模式</h4><p><img src="/2023/06/21/comporgan/image-20230618211717123.png" alt="image-20230618211717123"></p>
<h4 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h4><p><img src="/2023/06/21/comporgan/image-20230618211918511.png" alt="image-20230618211918511"></p>
<h3 id="半导体存储芯片简介"><a href="#半导体存储芯片简介" class="headerlink" title="半导体存储芯片简介"></a>半导体存储芯片简介</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="/2023/06/21/comporgan/image-20230618212044462.png" alt="image-20230618212044462"></p>
<p><img src="/2023/06/21/comporgan/image-20230618212116854.png" alt="image-20230618212116854"></p>
<h4 id="译码驱动方式"><a href="#译码驱动方式" class="headerlink" title="译码驱动方式"></a>译码驱动方式</h4><h5 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h5><p><img src="/2023/06/21/comporgan/image-20230618212207454.png" alt="image-20230618212207454"></p>
<h5 id="重合法"><a href="#重合法" class="headerlink" title="重合法"></a>重合法</h5><p><img src="/2023/06/21/comporgan/image-20230618212227553.png" alt="image-20230618212227553"></p>
<h3 id="RAM-随机存取存储器"><a href="#RAM-随机存取存储器" class="headerlink" title="RAM 随机存取存储器"></a>RAM 随机存取存储器</h3><h4 id="DRAM和SRAM"><a href="#DRAM和SRAM" class="headerlink" title="DRAM和SRAM"></a>DRAM和SRAM</h4><p><img src="/2023/06/21/comporgan/image-20230618222428159.png" alt="image-20230618222428159"></p>
<h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><h5 id="基本电路"><a href="#基本电路" class="headerlink" title="基本电路"></a>基本电路</h5><blockquote>
<p><img src="/2023/06/21/comporgan/image-20230621193330855.png" alt="image-20230621193330855"></p>
<p>核心就是利用****触发器（T1—T4）****来表示0和1的</p>
<p>用T5和T6行开关来控制对触发器部件读写，用T7和T8列开关……【对应上面说的重合法？】</p>
<p>写入要在A段写入数据，同时在A’段写入数据的非【因为触发器是双稳态的，要求两边输入的信号相反。】对应的，写选择那边输入数据也得对称经过门和非门。</p>
</blockquote>
<h5 id="经典芯片"><a href="#经典芯片" class="headerlink" title="经典芯片"></a>经典芯片</h5><p><img src="/2023/06/21/comporgan/image-20230618212447162.png" alt="image-20230618212447162"></p>
<h5 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h5><p><img src="/2023/06/21/comporgan/wps1.jpg" alt="img"></p>
<p>上面的部分是64*64的基本电路矩阵。我们按列分，每十六列为一组，则分成了四组。因为2^4=16，因而我们用四位来表示地址控制信号。</p>
<p>对于行，当地址控制信号为0000时，表示选择存储矩阵的第一行的数据，为0001时，选择第二行的……依此类推。</p>
<p>对于列，当地址控制信号为0000时，表示选择每一组的第一列的数据，为0001时，选择第二列的……依此类推。</p>
<p>每一组只能有一列被选中，这就达到了一次读写四位的目的。【一个字节分开存】</p>
<h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><h5 id="基本电路-1"><a href="#基本电路-1" class="headerlink" title="基本电路"></a>基本电路</h5><blockquote>
<p>主要是通过电容的充放电实现的</p>
<p><img src="/2023/06/21/comporgan/wps1-1687347239255-303.jpg" alt="img"> </p>
<p>左侧三管那个中，读数据线读出的跟存储的是相反的，存0读1，存1读0.但写入跟输入的信息是相同的。</p>
<p>右侧单管中，读出时数据线有电流则是1，没有则是0.写入时，对Cs充电则为1，Cs放电（输入信号为低电平）则为0.</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618215704699.png" alt="image-20230618215704699"></p>
<h5 id="经典芯片-读写"><a href="#经典芯片-读写" class="headerlink" title="经典芯片/读写"></a>经典芯片/读写</h5><p><img src="/2023/06/21/comporgan/image-20230618215803608.png" alt="image-20230618215803608"></p>
<blockquote>
<p><img src="/2023/06/21/comporgan/wps2-1687347264734-305.jpg" alt="img"></p>
<p>14位的地址分了两次传，分别作为行列地址。</p>
<p>RAS:行选控制信号 CAS：列选控制信号 WE：读写控制信号。产生的时钟控制了芯片内部的读写操作</p>
<p><img src="/2023/06/21/comporgan/wps3-1687347264735-306.jpg" alt="img"> </p>
<p>如果读放大器左边有电，那么右边输出没电；左没电右有电.这样，读放大器左边的部分，有电表示0，没电表示1 ；读放大器右边的部分，有电表示1，没电表示0.</p>
</blockquote>
<h5 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h5><p>为什么要刷新：</p>
<p><img src="/2023/06/21/comporgan/image-20230619224003589.png" alt="image-20230619224003589"></p>
<h6 id="集中刷新"><a href="#集中刷新" class="headerlink" title="集中刷新"></a>集中刷新</h6><p><img src="/2023/06/21/comporgan/image-20230618221439701.png" alt="image-20230618221439701"></p>
<h6 id="分散刷新"><a href="#分散刷新" class="headerlink" title="分散刷新"></a>分散刷新</h6><p><img src="/2023/06/21/comporgan/image-20230618221603727.png" alt="image-20230618221603727"></p>
<h6 id="异步刷新"><a href="#异步刷新" class="headerlink" title="异步刷新"></a>异步刷新</h6><p><img src="/2023/06/21/comporgan/image-20230618222049113.png" alt="image-20230618222049113"></p>
<h3 id="ROM-只读存储器"><a href="#ROM-只读存储器" class="headerlink" title="ROM 只读存储器"></a>ROM 只读存储器</h3><ol>
<li><p>掩膜ROM(MROM)  用户不能修改</p>
<p><img src="/2023/06/21/comporgan/image-20230618222716561.png" alt="image-20230618222716561"></p>
</li>
<li><p>PROM（一次性编程）  破坏性编程</p>
<p><img src="/2023/06/21/comporgan/image-20230618223116398.png" alt="image-20230618223116398"></p>
</li>
<li><p>EPROM（多次性编程）</p>
<p><img src="/2023/06/21/comporgan/image-20230618223151914.png" alt="image-20230618223151914"></p>
</li>
<li><p>EEPROM（电可擦写）</p>
<p><img src="/2023/06/21/comporgan/image-20230618223229585.png" alt="image-20230618223229585"></p>
</li>
<li><p>Flash Memory（闪速型存储器）</p>
<p><img src="/2023/06/21/comporgan/image-20230618223252821.png" alt="image-20230618223252821"></p>
</li>
</ol>
<h3 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h3><h4 id="存储器容量的扩展"><a href="#存储器容量的扩展" class="headerlink" title="存储器容量的扩展"></a>存储器容量的扩展</h4><h5 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h5><p><img src="/2023/06/21/comporgan/image-20230618224638384.png" alt="image-20230618224638384"></p>
<h5 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h5><p><img src="/2023/06/21/comporgan/image-20230618224745584.png" alt="image-20230618224745584"></p>
<p>带了片选思想</p>
<h5 id="位字扩展"><a href="#位字扩展" class="headerlink" title="位字扩展"></a>位字扩展</h5><p><img src="/2023/06/21/comporgan/image-20230618224955557.png" alt="image-20230618224955557"></p>
<h4 id="存储器与CPU的连接-1"><a href="#存储器与CPU的连接-1" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h4><h3 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h3><p><img src="/2023/06/21/comporgan/image-20230620221830055.png" alt="image-20230620221830055"></p>
<h4 id="汉明码组成"><a href="#汉明码组成" class="headerlink" title="汉明码组成"></a>汉明码组成</h4><p><img src="/2023/06/21/comporgan/image-20230620222021345.png" alt="image-20230620222021345"></p>
<p><img src="/2023/06/21/comporgan/image-20230620222133679.png" alt="image-20230620222133679"></p>
<p><img src="/2023/06/21/comporgan/image-20230620222301502.png" alt="image-20230620222301502"></p>
<p>n为数据的位数</p>
<p><img src="/2023/06/21/comporgan/image-20230620222225994.png" alt="image-20230620222225994"></p>
<p><img src="/2023/06/21/comporgan/image-20230620222518156.png" alt="image-20230620222518156"></p>
<h4 id="汉明码纠错"><a href="#汉明码纠错" class="headerlink" title="汉明码纠错"></a>汉明码纠错</h4><p><img src="/2023/06/21/comporgan/image-20230620222951821.png" alt="image-20230620222951821"></p>
<p>跟组成的步骤是一样的</p>
<h3 id="提高访存速度的措施"><a href="#提高访存速度的措施" class="headerlink" title="提高访存速度的措施"></a>提高访存速度的措施</h3><p><img src="/2023/06/21/comporgan/image-20230618233156234.png" alt="image-20230618233156234"></p>
<p><img src="/2023/06/21/comporgan/image-20230618233234559.png" alt="image-20230618233234559"></p>
<p><img src="/2023/06/21/comporgan/image-20230618233325427.png" alt="image-20230618233325427"></p>
<p><img src="/2023/06/21/comporgan/image-20230619224341497.png" alt="image-20230619224341497"></p>
<p><img src="/2023/06/21/comporgan/image-20230618233855438.png" alt="image-20230618233855438"></p>
<p>不过这里也帅得一批，非常有那种从小到大的抽象思维在。</p>
<p>之前的单独一块RAM芯片，一个字节是分开存；这里的一个主存堆，一个块是分主存存。</p>
<h2 id="Cache-高速缓冲存储器"><a href="#Cache-高速缓冲存储器" class="headerlink" title="Cache 高速缓冲存储器"></a>Cache 高速缓冲存储器</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/06/21/comporgan/image-20230618233726163.png" alt="image-20230618233726163"></p>
<h4 id="技术指标-1"><a href="#技术指标-1" class="headerlink" title="技术指标"></a>技术指标</h4><p><img src="/2023/06/21/comporgan/image-20230618233800847.png" alt="image-20230618233800847"></p>
<p><img src="/2023/06/21/comporgan/image-20230618234113714.png" alt="image-20230618234113714"></p>
<p>因为在一个存取周期当中，每体都可以取一个字，16体就可以取16字，因而一个存取周期可以取出16个字出来。</p>
<p><img src="/2023/06/21/comporgan/image-20230618234151529.png" alt="image-20230618234151529"></p>
<p>但是这个公式前提是访问cache和主存并行。如果换用另一个策略，即先看cache有没有，没有再去主存，计算公式就不一样。</p>
<h3 id="Cache的读写操作"><a href="#Cache的读写操作" class="headerlink" title="Cache的读写操作"></a>Cache的读写操作</h3><blockquote>
<p><img src="/2023/06/21/comporgan/wps1-1687103084226-2.jpg" alt="img"></p>
<p>cache接收CPU发来的地址信号。CPU发出的地址中的块内地址无需转换，而块号需要通过主存cache地址映射变换机构转化成cache内的块号。【所以说CPU访问cache的时候，传给cache的地址是主存的物理地址吧？然后再通过主存cache地址映射转化为cache的块内地址。】</p>
<p>如果命中，则转换机构工作，传递地址给cache存储体，存储体通过数据总线发送信号。</p>
<p>如果不命中，并且cache没装满，则发送信号给主存。</p>
<p>如果不命中，且cache装满了，则cache替换机构使用替换算法，淘汰cache中一些块，同时发送信号给主存。</p>
<p>主存收到信号，<strong>在数据总线上发给cpu要的东西之后，再将所在块发给cache</strong>。</p>
<p><img src="/2023/06/21/comporgan/image-20230621193732489.png" alt="image-20230621193732489"></p>
</blockquote>
<h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><p><img src="/2023/06/21/comporgan/image-20230618234639119.png" alt="image-20230618234639119"></p>
<h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><p><img src="/2023/06/21/comporgan/image-20230618234752772.png" alt="image-20230618234752772"></p>
<h3 id="Cache-主存映射"><a href="#Cache-主存映射" class="headerlink" title="Cache-主存映射"></a>Cache-主存映射</h3><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p><img src="/2023/06/21/comporgan/image-20230618234904098.png" alt="image-20230618234904098"></p>
<p><img src="/2023/06/21/comporgan/image-20230618234921789.png" alt="image-20230618234921789"></p>
<h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><p><img src="/2023/06/21/comporgan/image-20230618235007647.png" alt="image-20230618235007647"></p>
<h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><p><img src="/2023/06/21/comporgan/image-20230618235147739.png" alt="image-20230618235147739"></p>
<h3 id="缓存替换算法"><a href="#缓存替换算法" class="headerlink" title="缓存替换算法"></a>缓存替换算法</h3><p><img src="/2023/06/21/comporgan/image-20230618235750985.png" alt="image-20230618235750985"></p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><blockquote>
<p>现在很多处理器至少有三级cache。比如每个核一个cache，多个核还有一个公用的cache。</p>
<p>流水线计算机很多都分了指令cache和数据cache，避免资源冲突。</p>
<p>注意，每个层次的cache采用的映射可能不一样。</p>
<p><strong>靠近CPU采用直接相连或者路数（r）少的组相连【其实直接相连就相当于是一路的组相联了】。中间的用组相联。距离CPU较远的用全相联。</strong></p>
<p>距离越远，对速度要求越低，对利用率要求越高。</p>
</blockquote>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="与Cache的差异"><a href="#与Cache的差异" class="headerlink" title="与Cache的差异"></a>与Cache的差异</h3><p><img src="/2023/06/21/comporgan/image-20230619000944183.png" alt="image-20230619000944183"></p>
<h3 id="虚拟存储器-1"><a href="#虚拟存储器-1" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p><img src="/2023/06/21/comporgan/image-20230618235955557.png" alt="image-20230618235955557"></p>
<p><img src="/2023/06/21/comporgan/image-20230619000042556.png" alt="image-20230619000042556"></p>
<p>相当于把主存-辅存（磁盘）看成另一个cache-主存。这也就类似于内存页面换入换出了。原来这玩意叫虚拟存储器啊，不过这也类似于虚拟地址空间的叫法就是了。</p>
<p><img src="/2023/06/21/comporgan/image-20230619000208477.png" alt="image-20230619000208477"></p>
<p><img src="/2023/06/21/comporgan/image-20230619000304314.png" alt="image-20230619000304314"></p>
<h3 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h3><p><img src="/2023/06/21/comporgan/image-20230619000428020.png" alt="image-20230619000428020"></p>
<h3 id="访问流程"><a href="#访问流程" class="headerlink" title="访问流程"></a>访问流程</h3><p><img src="/2023/06/21/comporgan/image-20230619000542665.png" alt="image-20230619000542665"></p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p><img src="/2023/06/21/comporgan/image-20230619000628910.png" alt="image-20230619000628910"></p>
<p><img src="/2023/06/21/comporgan/image-20230619000804374.png" alt="image-20230619000804374"></p>
<p><img src="/2023/06/21/comporgan/image-20230619000827244.png" alt="image-20230619000827244"></p>
<p><img src="/2023/06/21/comporgan/image-20230619000851370.png" alt="image-20230619000851370"></p>
<h2 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h2><p>硬盘、U盘、软盘、磁带、光盘</p>
<h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p><img src="/2023/06/21/comporgan/image-20230619142112318.png" alt="image-20230619142112318"></p>
<p><img src="/2023/06/21/comporgan/image-20230619142148621.png" alt="image-20230619142148621"></p>
<p><img src="/2023/06/21/comporgan/image-20230619143428427.png" alt="image-20230619143428427"></p>
<p><img src="/2023/06/21/comporgan/image-20230619143411577.png" alt="image-20230619143411577"></p>
<h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><h3 id="是啥"><a href="#是啥" class="headerlink" title="是啥"></a>是啥</h3><p>总线两个特点：<strong>分时</strong>和<strong>共享</strong></p>
<p>遵循<strong>协议</strong>或<strong>标准，方便</strong>计算机系统集成、扩展和进化</p>
<p>总线的猝发传输方式：在一个总线周期内，传输存储地址连续的多个数据字的总线传输方式。</p>
<h3 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h3><p><img src="/2023/06/21/comporgan/image-20230618173335493.png" alt="image-20230618173335493"></p>
<p><img src="/2023/06/21/comporgan/image-20230618173414845.png" alt="image-20230618173414845"></p>
<h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><h3 id="单总线"><a href="#单总线" class="headerlink" title="单总线"></a>单总线</h3><p>注意，单总线是默认统一编址的？</p>
<p><img src="/2023/06/21/comporgan/image-20230618175005524.png" alt="image-20230618175005524"></p>
<h3 id="面向CPU的双总线"><a href="#面向CPU的双总线" class="headerlink" title="面向CPU的双总线"></a>面向CPU的双总线</h3><p><img src="/2023/06/21/comporgan/image-20230618175035406.png" alt="image-20230618175035406"></p>
<h3 id="存储器为中心-1"><a href="#存储器为中心-1" class="headerlink" title="存储器为中心"></a>存储器为中心</h3><p><img src="/2023/06/21/comporgan/image-20230618175435591.png" alt="image-20230618175435591"></p>
<h3 id="有通道的多总线结构"><a href="#有通道的多总线结构" class="headerlink" title="有通道的多总线结构"></a>有通道的多总线结构</h3><p><img src="/2023/06/21/comporgan/image-20230618175533637.png" alt="image-20230618175533637"></p>
<p><img src="/2023/06/21/comporgan/image-20230618175631552.png" alt="image-20230618175631552"></p>
<p>帅</p>
<p><img src="/2023/06/21/comporgan/image-20230618175705273.png" alt="image-20230618175705273"></p>
<p><img src="/2023/06/21/comporgan/image-20230618175743501.png" alt="image-20230618175743501"></p>
<h2 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h2><h3 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h3><p><img src="/2023/06/21/comporgan/image-20230618180345695.png" alt="image-20230618180345695"></p>
<p><img src="/2023/06/21/comporgan/image-20230618180704321.png" alt="image-20230618180704321"></p>
<p>注意，独立请求是最快的</p>
<h4 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h4><blockquote>
<p>所有设备可在BR线发布总线请求，主设备通过BG线表态，争得总线的设备要通过BS线告诉其他设备总线忙。</p>
<p>BG线中，总线同意信号会依次遍历每一个设备，直到找到第一个提出请求的设备。</p>
<p>可见，这个遍历顺序就代表了各个IO设备的优先级顺序。</p>
<p>这样相当于分离出格外的线来控制信号。这种方式对电路故障非常敏感。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618180431836.png" alt="image-20230618180431836"></p>
<h4 id="计数器定时查询"><a href="#计数器定时查询" class="headerlink" title="计数器定时查询"></a>计数器定时查询</h4><blockquote>
<p>意思好像是，在BR线提出请求，主设备接收到请求后，可以响应的情况下，启动计数器，计数器初始值为零。计数器的值通过设备地址线输出。如果计数器为0，则观察接口0有没有请求，没有的话计数器++，继续看下一个，以此类推，直到找到第一个对应接口，则开始传输数据，BS线启用。</p>
<p>设备地址线需要给所有设备地址进行编码，因此宽度与设备数有关。</p>
<p>这个的优点在于，优先级的确定更加灵活了。比如说，计数器不一定从零开始而是从上一次停止的地方开始（<strong>循环优先级</strong>，这样的话每个设备的机会均等），或者用软件控制优先级初始值，或者每一次不一定++而是有其他计算规则。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618180602116.png" alt="image-20230618180602116"></p>
<h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><blockquote>
<p>优先级由主设备内部逻辑（排队器）规定。也可以用自适应、计数器等等等。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618180645765.png" alt="image-20230618180645765"></p>
<h3 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h3><p><img src="/2023/06/21/comporgan/image-20230618180848436.png" alt="image-20230618180848436"></p>
<p>这玩意传输周期还考了</p>
<p><img src="/2023/06/21/comporgan/image-20230618180912414.png" alt="image-20230618180912414"></p>
<p>这个通信方式有哪几种也要求默写了</p>
<p><img src="/2023/06/21/comporgan/image-20230618181827840.png" alt="image-20230618181827840"></p>
<p>这个同步和异步的特点总结得很棒</p>
<p>同步、异步、半同步三者的共同点：</p>
<p><img src="/2023/06/21/comporgan/image-20230618181948854.png" alt="image-20230618181948854"></p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><blockquote>
<p><img src="/2023/06/21/comporgan/wps1-1687346993910-297.jpg" alt="img">定宽定距的时钟</p>
<p>白色菱形代表有地址、命令、数据；紫色阴影代表没有东西</p>
<p>数字电路中，数字电平从低电平（数字“0”）变为高电平（数字“1”）的那一瞬间（时刻）叫作上升沿。数字电平从高电平（数字“1”）变为低电平（数字“0”）的那一瞬间叫作下降沿。</p>
<p>有固定的时间点，和在每个固定时间点固定要做的事</p>
<p>第一部分：主设备要给出地址信号</p>
<p>第二部分：给出读命令（控制信号）</p>
<p>第三部分：从设备传输数据给主设备</p>
<p>第四部分：读命令、数据信号撤销</p>
<p>第五部分：地址信号撤销</p>
<p><img src="/2023/06/21/comporgan/wps2-1687346993911-298.jpg" alt="img"> </p>
<p><em><strong>*先给数据能保证命令到达立刻写入正确数据。菱形那段表示电平并非瞬间稳定*</strong></em></p>
<p><em><strong>*如果数据是并行就先给数据，再给读写信号，直接锁存；如果是串行数据，就先给读写信号，再给数据*</strong></em></p>
<p>有固定的时间点，和在每个固定时间点固定要做的事</p>
<p>第一部分：主设备要给出地址信号</p>
<p>第二部分：主设备给出数据信号</p>
<p>第三部分：主设备给出写入信号</p>
<p>第四部分：写入</p>
<p>第五部分：读命令、数据信号撤销</p>
<p>第六部分：地址信号撤销</p>
</blockquote>
<p>同步通信通常只适用于总线长度短的。</p>
<p>因为是并行总线，总线长度长了很难做到等长，到达设备后就不同步了</p>
<p>因为需要统一时标；总线长，需要迁就最远的设备；读写时间差距大，需要迁就最慢的设备</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p><img src="/2023/06/21/comporgan/image-20230618181416220.png" alt="image-20230618181416220"></p>
<h5 id="不互锁"><a href="#不互锁" class="headerlink" title="不互锁"></a>不互锁</h5><p>CPU从主存读信息</p>
<p>主要用在<strong>单机</strong>不同设备之间的通信中</p>
<h5 id="半互锁"><a href="#半互锁" class="headerlink" title="半互锁"></a>半互锁</h5><p><strong>多机</strong>系统中，某个CPU需要访问共享存储器时</p>
<h5 id="全互锁"><a href="#全互锁" class="headerlink" title="全互锁"></a>全互锁</h5><p>主要用于<strong>网络通信</strong>，如TCP三握手</p>
<h4 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h4><p>输入数据为例：</p>
<p><img src="/2023/06/21/comporgan/image-20230618181924196.png" alt="image-20230618181924196"></p>
<h4 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h4><blockquote>
<p>在子周期2中，从模块实际上从从模块变成了主模板，因为它发起了占用总线的请求。</p>
</blockquote>
<p><img src="/2023/06/21/comporgan/image-20230618182050912.png" alt="image-20230618182050912"></p>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><h3 id="发展概况"><a href="#发展概况" class="headerlink" title="发展概况"></a>发展概况</h3><p><img src="/2023/06/21/comporgan/image-20230619144243913.png" alt="image-20230619144243913"></p>
<p><img src="/2023/06/21/comporgan/image-20230619144359313.png" alt="image-20230619144359313"></p>
<p><img src="/2023/06/21/comporgan/image-20230619144452679.png" alt="image-20230619144452679"></p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="/2023/06/21/comporgan/image-20230619144602504.png" alt="image-20230619144602504"></p>
<blockquote>
<p>① IO指令</p>
<p>操作码相当于标志，标志这个指令是IO的。命令码才算是操作码，指出对IO设备做什么。设备码给出IO设备或者设备中某一个寄存器【端口】的编址。</p>
<p>② 通道指令</p>
<p>通道是小型DMA处理器，可以实现IO设备与主机之间进行信息交互。</p>
<p>通道有自己的控制器，有的通道还有存储器。</p>
<p>通道能够执行由通道指令组成的通道程序。</p>
<p>通常情况下，编程人员在应用程序当中，为了调用外部设备，应用程序中需要增加广义IO指令【这意思是封装吧】。广义IO指令要指出参加数据传输的IO设备、数据传输主存的首地址、传输数据的长度、传输方向。操作系统根据广义IO指令给出的参数以及要求的操作，会编写一个由通道指令组成的通道程序，并且会把程序放到内存或者是通道内存的指定位置，之后启动通道进行工作。</p>
</blockquote>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><h4 id="编址"><a href="#编址" class="headerlink" title="编址"></a>编址</h4><p><img src="/2023/06/21/comporgan/image-20230619144651480.png" alt="image-20230619144651480"></p>
<h4 id="选址和传送"><a href="#选址和传送" class="headerlink" title="选址和传送"></a>选址和传送</h4><p><img src="/2023/06/21/comporgan/image-20230619144727325.png" alt="image-20230619144727325"></p>
<h4 id="联络方式"><a href="#联络方式" class="headerlink" title="联络方式"></a>联络方式</h4><p><img src="/2023/06/21/comporgan/image-20230619144851937.png" alt="image-20230619144851937"></p>
<p><img src="/2023/06/21/comporgan/image-20230619145010236.png" alt="image-20230619145010236"></p>
<h4 id="连接方式-1"><a href="#连接方式-1" class="headerlink" title="连接方式"></a>连接方式</h4><p><img src="/2023/06/21/comporgan/image-20230619145037444.png" alt="image-20230619145037444"></p>
<h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><p><img src="/2023/06/21/comporgan/image-20230619145313853.png" alt="image-20230619145313853"></p>
<h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p><img src="/2023/06/21/comporgan/image-20230619145133293.png" alt="image-20230619145133293"></p>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p><img src="/2023/06/21/comporgan/image-20230619145154206.png" alt="image-20230619145154206"></p>
<p><img src="/2023/06/21/comporgan/image-20230619145214775.png" alt="image-20230619145214775"></p>
<h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p><img src="/2023/06/21/comporgan/image-20230619145252864.png" alt="image-20230619145252864"></p>
<h2 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/06/21/comporgan/image-20230619145414624.png" alt="image-20230619145414624"></p>
<h2 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/06/21/comporgan/image-20230619151239077.png" alt="image-20230619151239077"></p>
<h3 id="功能和组成"><a href="#功能和组成" class="headerlink" title="功能和组成"></a>功能和组成</h3><p><img src="/2023/06/21/comporgan/image-20230619151310223.png" alt="image-20230619151310223"></p>
<p><img src="/2023/06/21/comporgan/image-20230619151421396.png" alt="image-20230619151421396"></p>
<p><img src="/2023/06/21/comporgan/image-20230619151442848.png" alt="image-20230619151442848"></p>
<h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p><img src="/2023/06/21/comporgan/image-20230619151602920.png" alt="image-20230619151602920"></p>
<h2 id="程序查询方式-1"><a href="#程序查询方式-1" class="headerlink" title="程序查询方式"></a>程序查询方式</h2><p><img src="/2023/06/21/comporgan/image-20230619151713642.png" alt="image-20230619151713642"></p>
<p><img src="/2023/06/21/comporgan/image-20230619152130068.png" alt="image-20230619152130068"></p>
<p><img src="/2023/06/21/comporgan/image-20230619152909693.png" alt="image-20230619152909693"></p>
<h2 id="程序中断方式-1"><a href="#程序中断方式-1" class="headerlink" title="程序中断方式"></a>程序中断方式</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h4 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h4><p><img src="/2023/06/21/comporgan/image-20230619153352974.png" alt="image-20230619153352974"></p>
<p><img src="/2023/06/21/comporgan/image-20230619153557165.png" alt="image-20230619153557165"></p>
<h4 id="接口电路"><a href="#接口电路" class="headerlink" title="接口电路"></a>接口电路</h4><p><img src="/2023/06/21/comporgan/image-20230619153715848.png" alt="image-20230619153715848"></p>
<h5 id="中断请求触发器和中断屏蔽触发器"><a href="#中断请求触发器和中断屏蔽触发器" class="headerlink" title="中断请求触发器和中断屏蔽触发器"></a>中断请求触发器和中断屏蔽触发器</h5><p><img src="/2023/06/21/comporgan/image-20230619153949008.png" alt="image-20230619153949008"></p>
<p><img src="/2023/06/21/comporgan/image-20230619154445642.png" alt="image-20230619154445642"></p>
<h4 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h4><p>外部中断一般是<strong>由计算机外设发出的</strong>中断请求，如：键盘中断、打印机中断、定时器中断等。</p>
<p>外部中断一般指io高低电平(下降沿等由寄存器配置)来触发并响应io中断函数。</p>
<h3 id="接口电路-1"><a href="#接口电路-1" class="headerlink" title="接口电路"></a>接口电路</h3><h4 id="排队器"><a href="#排队器" class="headerlink" title="排队器"></a>排队器</h4><p><img src="/2023/06/21/comporgan/image-20230619155014803.png" alt="image-20230619155014803"></p>
<p><img src="/2023/06/21/comporgan/image-20230619155029933.png" alt="image-20230619155029933"></p>
<h5 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h5><p><img src="/2023/06/21/comporgan/image-20230619155054248.png" alt="image-20230619155054248"></p>
<blockquote>
<p>以下介绍的是链式排队器</p>
<ol>
<li>INTR默认为0，取非为1. 经&amp;后整个排队电路为1</li>
<li>当i设备发出请求，INTRi=1，取非为0，经&amp;后变为0，INTPi之后的电路清零，只有i之前的INTP为1</li>
<li>3在一连串的显示为 1 的INTP中，最后一个显示1的设备优先级最高。因为按照我们的分析，是它发出了请求</li>
</ol>
<p>使用与非+非而不是直接与门是因为与非门+非更便宜。</p>
<p>我猜这个意思是，链式排队的话，越前面的优先级越高，现在我们讲的是怎么快速****找出****最高的最前面的是哪一个。之所以为什么越前面的优先级最高，可从这个电路中得知。如果一个东西发出请求，那么它后面的INTPi’都会被置零，因而它肯定比它后面的高级。因此越前面的优先级越高。</p>
<p><a href="https://www.likecs.com/show-390301.html">https://www.likecs.com/show-390301.html</a> </p>
<p><img src="/2023/06/21/comporgan/wps1-1687348473779-309.jpg" alt="img"> </p>
<p>这个可以验证我的观点。至于这个轮询方式，应该在第三章的总线那边讲过，应该用的是链式查询。 </p>
</blockquote>
<h5 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h5><p>程序查询</p>
<p><img src="/2023/06/21/comporgan/image-20230619155116410.png" alt="image-20230619155116410"></p>
<h4 id="中断向量形成部件"><a href="#中断向量形成部件" class="headerlink" title="中断向量形成部件"></a>中断向量形成部件</h4><h5 id="硬件向量法"><a href="#硬件向量法" class="headerlink" title="硬件向量法"></a>硬件向量法</h5><p><img src="/2023/06/21/comporgan/image-20230619155154822.png" alt="image-20230619155154822"></p>
<h5 id="软件查询法"><a href="#软件查询法" class="headerlink" title="软件查询法"></a>软件查询法</h5><p><img src="/2023/06/21/comporgan/image-20230619161630629.png" alt="image-20230619161630629"></p>
<h4 id="接口电路组成"><a href="#接口电路组成" class="headerlink" title="接口电路组成"></a>接口电路组成</h4><p><img src="/2023/06/21/comporgan/image-20230619161803883.png" alt="image-20230619161803883"></p>
<blockquote>
<p>应该意思就是，参照上面那个程序电路图，首先CPU先发送一个启动IO设备的命令，然后就去忙了。</p>
<p>与此同时，IO接口接到命令开始准备，比如说对DBR的整理【因读写而异】。</p>
<p>IO接口准备完之后会卡在INTR那边，等待CPU的中断查询信号。</p>
<p>CPU本来一直在不断边干自己的活边发送中断查询信号【在每条指令执行阶段的结束前】，终于逮到这个时候发现IO接口已经准备好了，就回复中断响应信号，CPU进入中断周期，执行中断隐指令。</p>
<p>IO接口发出中断请求后就排好队选好设备了，收到CPU的中断响应信号，就给CPU发向量地址，CPU根据地址去内存中找到中断服务程序并开始执行，之后就可以开始数据传输了。</p>
<p>可见这个过程是异步的。</p>
</blockquote>
<h3 id="中断响应（中断处理过程）"><a href="#中断响应（中断处理过程）" class="headerlink" title="中断响应（中断处理过程）"></a>中断响应（中断处理过程）</h3><p><img src="/2023/06/21/comporgan/image-20230619162001376.png" alt="image-20230619162001376"></p>
<p><img src="/2023/06/21/comporgan/image-20230619162057309.png" alt="image-20230619162057309"></p>
<h4 id="IO中断处理过程"><a href="#IO中断处理过程" class="headerlink" title="IO中断处理过程"></a>IO中断处理过程</h4><p><img src="/2023/06/21/comporgan/image-20230619162142239.png" alt="image-20230619162142239"></p>
<p><img src="/2023/06/21/comporgan/image-20230619201800980.png" alt="image-20230619201800980"></p>
<h3 id="单重-多重中断服务流程（CPU）"><a href="#单重-多重中断服务流程（CPU）" class="headerlink" title="单重/多重中断服务流程（CPU）"></a>单重/多重中断服务流程（CPU）</h3><p><img src="/2023/06/21/comporgan/image-20230619201934346.png" alt="image-20230619201934346"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202014591.png" alt="image-20230619202014591"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202106846.png" alt="image-20230619202106846"></p>
<h3 id="中断屏蔽技术（CPU）"><a href="#中断屏蔽技术（CPU）" class="headerlink" title="中断屏蔽技术（CPU）"></a>中断屏蔽技术（CPU）</h3><p><img src="/2023/06/21/comporgan/image-20230619202207357.png" alt="image-20230619202207357"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202219859.png" alt="image-20230619202219859"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202321781.png" alt="image-20230619202321781"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202355070.png" alt="image-20230619202355070"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202434146.png" alt="image-20230619202434146"></p>
<h2 id="DMA方式-1"><a href="#DMA方式-1" class="headerlink" title="DMA方式"></a>DMA方式</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><img src="/2023/06/21/comporgan/image-20230619202548302.png" alt="image-20230619202548302"></p>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p><img src="/2023/06/21/comporgan/image-20230619202628150.png" alt="image-20230619202628150"></p>
<p>沙比</p>
<p><img src="/2023/06/21/comporgan/image-20230619202708423.png" alt="image-20230619202708423"></p>
<p><img src="/2023/06/21/comporgan/image-20230619202739633.png" alt="image-20230619202739633"></p>
<h3 id="功能和组成-1"><a href="#功能和组成-1" class="headerlink" title="功能和组成"></a>功能和组成</h3><p><img src="/2023/06/21/comporgan/image-20230619202841809.png" alt="image-20230619202841809"></p>
<p><img src="/2023/06/21/comporgan/image-20230619203043097.png" alt="image-20230619203043097"></p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><h4 id="DMA传送过程"><a href="#DMA传送过程" class="headerlink" title="DMA传送过程"></a>DMA传送过程</h4><p>预处理、数据传送、后处理</p>
<p><img src="/2023/06/21/comporgan/image-20230619203248171.png" alt="image-20230619203248171"></p>
<p>注意还有个传送字数，看来有点安全设定。如果溢出了就需要中断</p>
<p><img src="/2023/06/21/comporgan/image-20230619203423482.png" alt="image-20230619203423482"></p>
<p><img src="/2023/06/21/comporgan/image-20230619203535039.png" alt="image-20230619203535039"></p>
<h3 id="连接方式-2"><a href="#连接方式-2" class="headerlink" title="连接方式"></a>连接方式</h3><p><img src="/2023/06/21/comporgan/image-20230619204520342.png" alt="image-20230619204520342"></p>
<p><img src="/2023/06/21/comporgan/image-20230619204537086.png" alt="image-20230619204537086"></p>
<h3 id="与程序中断比较"><a href="#与程序中断比较" class="headerlink" title="与程序中断比较"></a>与程序中断比较</h3><p><img src="/2023/06/21/comporgan/image-20230619204641555.png" alt="image-20230619204641555"></p>
]]></content>
  </entry>
  <entry>
    <title>其他的对实验未涉及的思考</title>
    <url>/2023/02/25/cs144$else/</url>
    <content><![CDATA[<h1 id="其他的对实验未涉及的思考"><a href="#其他的对实验未涉及的思考" class="headerlink" title="其他的对实验未涉及的思考"></a>其他的对实验未涉及的思考</h1><h2 id="网络层实现"><a href="#网络层实现" class="headerlink" title="网络层实现"></a>网络层实现</h2><p>在我们的协议栈实现中，我们负责了运输层的TCP协议、网络层的ARP协议以及数据链路层的ETH协议的编写，剩下的网络层的IP协议则由官方给定。接下来我们就来探究下网络层的实现。</p>
<h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><blockquote>
<p><strong>You’ve done this already.</strong></p>
<p>In Lab 4, we gave:</p>
<ol>
<li>an object that represents an Internet datagram and knows how to parse and serialize itself (<code>tcp_helpers/ipv4_datagram.&#123;hh,cc&#125;</code>) 表示了Internet datagram的数据结构，它可以自己序列化。</li>
<li>the logic to encapsulate(封装) TCP segments in IP (now found in <code>tcp_helpers/tcp_over_ip.cc</code>).</li>
</ol>
<p>The <code>CS144TCPSocket</code> uses these tools to connect your <code>TCPConnection</code> to a TUN device.</p>
</blockquote>
<p>也即，IP协议主要由两个文件实现，一个是IP数据报抽象为的类<code>ipv4_datagram.&#123;hh,cc&#125;</code>，另一个是将TCP报文封装为IP报文的类<code>tcp_helpers/tcp_over_ip.cc</code>；除此之外，IP协议还负责与下次协议连接，在实验0-4中它通过<code>CS144TCPSocket</code>与TUN连接，在实验5-6则与TAN连接。</p>
<p>连接部分暂且先放到下一部分讲，下面来看看IP协议的具体实现。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="ipv4-datagram-hh-amp-amp-ipv4-header-hh"><a href="#ipv4-datagram-hh-amp-amp-ipv4-header-hh" class="headerlink" title="ipv4_datagram.hh &amp;&amp; ipv4_header.hh"></a>ipv4_datagram.hh &amp;&amp; ipv4_header.hh</h4><p><code>ipv4_datagram</code>没什么好说的，跟<code>TCPSegment</code>的结构一模一样。<code>ipv4_header</code>也没什么好说的，就纯纯是IP数据报的报头、</p>
<h4 id="tcp-over-ip"><a href="#tcp-over-ip" class="headerlink" title="tcp_over_ip"></a>tcp_over_ip</h4><h5 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h5><p>它的头文件很简单，只包含一个类的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A converter from TCP segments to serialized IPv4 datagrams</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPOverIPv4Adapter</span> : <span class="keyword">public</span> FdAdapterBase &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::optional&lt;TCPSegment&gt; <span class="title">unwrap_tcp_in_ip</span><span class="params">(<span class="type">const</span> InternetDatagram &amp;ip_dgram)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">InternetDatagram <span class="title">wrap_tcp_in_ip</span><span class="params">(TCPSegment &amp;seg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// SPONGE_LIBSPONGE_TCP_OVER_IP_HH</span></span></span><br></pre></td></tr></table></figure>

<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><p>可以看到，相比于TCP和ETH/ARP协议，IP协议的实现可以说是非常简单。它作为一个中间层，只需要把上面给的东西包装下再传到下面，或者把下面给的东西解包下再传给上面，无需其他复杂的算法和数据结构（比如TCP的reliable transmission和ETH/ARP的地址自学习），也无需跟外界打交道。</p>
<p>除了打包解包外，它只需确保一件事，那就是一台主机只能同时拥有一个TCP连接。这样一来也能简化其实现：填写IP协议头时，它就只需从自己保存的config中取参数就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来拆IP数据包为一个TCP数据包</span></span><br><span class="line"><span class="comment">//! If this succeeds, it then checks that the received segment is related to the</span></span><br><span class="line"><span class="comment">//! current connection. When a TCP connection has been established, this means</span></span><br><span class="line"><span class="comment">//  如果TCP连接已建立，则会检查src和dst端口号的正确性</span></span><br><span class="line"><span class="comment">//! checking that the source and destination ports in the TCP header are correct.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! If the TCP connection is listening 如果处于listening状态，并且参数为SYN报文</span></span><br><span class="line"><span class="comment">//! and the TCP segment read from the wire includes a SYN, this function clears the</span></span><br><span class="line"><span class="comment">//  就需要解除listening的flag，记录下src和dst的地址和端口号</span></span><br><span class="line"><span class="comment">//! `_listen` flag and records the source and destination addresses and port numbers</span></span><br><span class="line"><span class="comment">//  目的是为了 filter future reads</span></span><br><span class="line"><span class="comment">//  这说明我们的sponge实现是单线程的，也就是一台主机只能同时建立一个TCP连接</span></span><br><span class="line"><span class="comment">//  并且在此时会忽略其他主机发过来的数据包</span></span><br><span class="line"><span class="comment">//! from the TCP header; it uses this information to filter future reads.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  returns a std::optional&lt;TCPSegment&gt; that is empty if the segment was invalid or unrelated</span></span><br><span class="line"><span class="function">optional&lt;TCPSegment&gt; <span class="title">TCPOverIPv4Adapter::unwrap_tcp_in_ip</span><span class="params">(<span class="type">const</span> InternetDatagram &amp;ip_dgram)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// is the IPv4 datagram for us?</span></span><br><span class="line">    <span class="comment">// Note: it&#x27;s valid to bind to address &quot;0&quot; (INADDR_ANY) and reply from actual address contacted</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">listening</span>() <span class="built_in">and</span> (ip_dgram.<span class="built_in">header</span>().dst != <span class="built_in">config</span>().source.<span class="built_in">ipv4_numeric</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the IPv4 datagram from our peer?</span></span><br><span class="line">    <span class="comment">// 过滤非peer发来的其他数据包</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">listening</span>() <span class="built_in">and</span> (ip_dgram.<span class="built_in">header</span>().src != <span class="built_in">config</span>().destination.<span class="built_in">ipv4_numeric</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// does the IPv4 datagram claim that its payload is a TCP segment?</span></span><br><span class="line">    <span class="comment">// 我们只需解包TCP数据报</span></span><br><span class="line">    <span class="keyword">if</span> (ip_dgram.<span class="built_in">header</span>().proto != IPv4Header::PROTO_TCP) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the payload a valid TCP segment?</span></span><br><span class="line">    TCPSegment tcp_seg;</span><br><span class="line">    <span class="keyword">if</span> (ParseResult::NoError != tcp_seg.<span class="built_in">parse</span>(ip_dgram.<span class="built_in">payload</span>(), ip_dgram.<span class="built_in">header</span>().<span class="built_in">pseudo_cksum</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the TCP segment for us?</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_seg.<span class="built_in">header</span>().dport != <span class="built_in">config</span>().source.<span class="built_in">port</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should we target this source addr/port (and use its destination addr as our source) in reply?</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listening</span>()) &#123;</span><br><span class="line">        <span class="comment">// records the source and destination addresses and port numbers</span></span><br><span class="line">        <span class="keyword">if</span> (tcp_seg.<span class="built_in">header</span>().syn <span class="keyword">and</span> <span class="keyword">not</span> tcp_seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">            <span class="built_in">config_mutable</span>().source = &#123;<span class="built_in">inet_ntoa</span>(&#123;<span class="built_in">htobe32</span>(ip_dgram.<span class="built_in">header</span>().dst)&#125;), <span class="built_in">config</span>().source.<span class="built_in">port</span>()&#125;;</span><br><span class="line">            <span class="built_in">config_mutable</span>().destination = &#123;<span class="built_in">inet_ntoa</span>(&#123;<span class="built_in">htobe32</span>(ip_dgram.<span class="built_in">header</span>().src)&#125;), tcp_seg.<span class="built_in">header</span>().sport&#125;;</span><br><span class="line">            <span class="built_in">set_listening</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the TCP segment from our peer?</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_seg.<span class="built_in">header</span>().sport != <span class="built_in">config</span>().destination.<span class="built_in">port</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tcp_seg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Takes a TCP segment, sets port numbers as necessary, and wraps it in an IPv4 datagram</span></span><br><span class="line"><span class="comment">//! \param[in] seg is the TCP segment to convert</span></span><br><span class="line"><span class="function">InternetDatagram <span class="title">TCPOverIPv4Adapter::wrap_tcp_in_ip</span><span class="params">(TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set the port numbers in the TCP segment</span></span><br><span class="line">    seg.<span class="built_in">header</span>().sport = <span class="built_in">config</span>().source.<span class="built_in">port</span>();</span><br><span class="line">    seg.<span class="built_in">header</span>().dport = <span class="built_in">config</span>().destination.<span class="built_in">port</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an Internet Datagram and set its addresses and length</span></span><br><span class="line">    InternetDatagram ip_dgram;</span><br><span class="line">    ip_dgram.<span class="built_in">header</span>().src = <span class="built_in">config</span>().source.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    ip_dgram.<span class="built_in">header</span>().dst = <span class="built_in">config</span>().destination.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    <span class="comment">// uint8_t hlen = LENGTH / 4;  //!&lt; header length</span></span><br><span class="line">    <span class="comment">// uint8_t doff = LENGTH / 4;  //!&lt; data offset</span></span><br><span class="line">    ip_dgram.<span class="built_in">header</span>().len = ip_dgram.<span class="built_in">header</span>().hlen * <span class="number">4</span> + seg.<span class="built_in">header</span>().doff * <span class="number">4</span> + seg.<span class="built_in">payload</span>().<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set payload, calculating TCP checksum using information from IP header</span></span><br><span class="line">    ip_dgram.<span class="built_in">payload</span>() = seg.<span class="built_in">serialize</span>(ip_dgram.<span class="built_in">header</span>().<span class="built_in">pseudo_cksum</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ip_dgram;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Socket实现"><a href="#Socket实现" class="headerlink" title="Socket实现"></a>Socket实现</h2><p>最top的话可以分为<code>CS144TCPSocket</code>和<code>FullStackSocket</code>。</p>
<p>继承关系如下图：</p>
<p><img src="/2023/02/25/cs144/class_socket__inherit__graph.png" alt="Inheritance graph"></p>
<p>其中，<code>TCPSocket</code>是完完全全的包装类，它的所有协议栈都是在内核态中实现（也就是跟我们之后写的没半毛钱关系），它的存在意义应该是用在lab0来写<code>webget</code>的测试。而<code>CS144TCPSocket</code>就是我们在lab0-4用的了，它的数据链路层由内核实现，网络层和运输层由用户实现。<code>FullStackSocket</code>就是加上了我们在lab5做的用户态数据链路层。</p>
<p>最主要的部分是<code>TCPSpongeSocket</code>的实现，其他就是一些包装类没什么好说的。</p>
<h3 id="FileDescriptor"><a href="#FileDescriptor" class="headerlink" title="FileDescriptor"></a>FileDescriptor</h3><p>将socket看作是fd，将网络看作是IO，这一抽象简直是太伟大了，牛逼到爆。</p>
<h4 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! A reference-counted handle to a file descriptor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileDescriptor</span> &#123;</span><br><span class="line">    <span class="comment">//! \brief A handle on a kernel file descriptor.</span></span><br><span class="line">    <span class="comment">//! \details FileDescriptor objects contain a std::shared_ptr to a FDWrapper.</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FDWrapper</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> _fd;                    <span class="comment">// file descriptor number returned by the kernel</span></span><br><span class="line">        <span class="type">bool</span> _eof = <span class="literal">false</span>;          <span class="comment">// fd是否eof</span></span><br><span class="line">        <span class="type">bool</span> _closed = <span class="literal">false</span>;       <span class="comment">// fd是否close</span></span><br><span class="line">        <span class="comment">// fd被读写的次数</span></span><br><span class="line">        <span class="type">unsigned</span> _read_count = <span class="number">0</span>;   </span><br><span class="line">        <span class="type">unsigned</span> _write_count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Construct from a file descriptor number returned by the kernel</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">FDWrapper</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd)</span></span>;</span><br><span class="line">        <span class="comment">//! Closes the file descriptor upon destruction</span></span><br><span class="line">        ~<span class="built_in">FDWrapper</span>();</span><br><span class="line">        <span class="comment">//! Calls [close(2)](\ref man2::close) on FDWrapper::_fd</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//! An FDWrapper cannot be copied or moved</span></span><br><span class="line">        <span class="built_in">FDWrapper</span>(<span class="type">const</span> FDWrapper &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">        FDWrapper &amp;<span class="keyword">operator</span>=(<span class="type">const</span> FDWrapper &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="built_in">FDWrapper</span>(FDWrapper &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">        FDWrapper &amp;<span class="keyword">operator</span>=(FDWrapper &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! A reference-counted handle to a shared FDWrapper</span></span><br><span class="line">    std::shared_ptr&lt;FDWrapper&gt; _internal_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private constructor used to duplicate the FileDescriptor (increase the reference count)  这个构造函数会增加其参数传进来的那个fd的引用，也许相当于dump</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FileDescriptor</span><span class="params">(std::shared_ptr&lt;FDWrapper&gt; other_shared_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">register_read</span><span class="params">()</span> </span>&#123; ++_internal_fd-&gt;_read_count; &#125;    <span class="comment">//!&lt; increment read count</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">register_write</span><span class="params">()</span> </span>&#123; ++_internal_fd-&gt;_write_count; &#125;  <span class="comment">//!&lt; increment write count</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Construct from a file descriptor number returned by the kernel</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FileDescriptor</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Free the std::shared_ptr; the FDWrapper destructor calls close() when the refcount goes to zero.</span></span><br><span class="line">    ~<span class="built_in">FileDescriptor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  读写  */</span></span><br><span class="line">    <span class="function">std::string <span class="title">read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> limit = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::max())</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(std::string &amp;str, <span class="type">const</span> <span class="type">size_t</span> limit = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::max())</span></span>;</span><br><span class="line">    <span class="comment">// possibly blocking until all is written</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">write</span>(<span class="built_in">BufferViewList</span>(str), write_all); &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;str, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">write</span>(<span class="built_in">BufferViewList</span>(str), write_all); &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(BufferViewList buffer, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Close the underlying file descriptor</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; _internal_fd-&gt;<span class="built_in">close</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Copy a FileDescriptor explicitly, increasing the FDWrapper refcount</span></span><br><span class="line">    <span class="function">FileDescriptor <span class="title">duplicate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Set blocking(true) or non-blocking(false)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_blocking</span><span class="params">(<span class="type">const</span> <span class="type">bool</span> blocking_state)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p>差不多就是全程调用系统调用没什么好说的，记录下几个有意思的点</p>
<h5 id="包装系统调用"><a href="#包装系统调用" class="headerlink" title="包装系统调用"></a>包装系统调用</h5><p>可以看下其调用系统调用的方式，看起来很有意思：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileDescriptor::set_blocking</span><span class="params">(<span class="type">const</span> <span class="type">bool</span> blocking_state)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">SystemCall</span>(<span class="string">&quot;fcntl&quot;</span>, <span class="built_in">fcntl</span>(<span class="built_in">fd_num</span>(), F_GETFL));</span><br><span class="line">    <span class="keyword">if</span> (blocking_state) &#123;</span><br><span class="line">        flags ^= (flags &amp; O_NONBLOCK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags |= O_NONBLOCK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SystemCall</span>(<span class="string">&quot;fcntl&quot;</span>, <span class="built_in">fcntl</span>(<span class="built_in">fd_num</span>(), F_SETFL, flags));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说这里设置文件读写是否阻塞就是通过系统调用实现的。</p>
<p>在写os实验时，你应该就能很深刻感受到，很多时候调用完一个系统调用后，对它的返回结果进行合法性判断以及错误处理还是有点烦的（举例来说，如<code>if(kalloc() == 0)</code>或者<code>if(mappages() == 0)</code>，出错后杀死进程等等等）。在那会我们还可以直接就这么冗余地干了，但是这里不行，一是我们要用面向对象的思想，二是我们的重点事实上并不是操作系统而是网络，因而最好还是这么封装下以减少冗余代码。</p>
<p>而它除了会调用系统调用外，还使用了一个包装性的方法<code>SystemCall</code>来保障调用的安全性和合理性。看看<code>SystemCall</code>的具体实现方式，确实就是包了层安全检查。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SystemCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (return_value &gt;= <span class="number">0</span> || errno == errno_mask) &#123;</span><br><span class="line">        <span class="keyword">return</span> return_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">unix_error</span>(attempt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os内核看不懂c++，所以要注意转换为c-style的字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SystemCall</span><span class="params">(<span class="type">const</span> string &amp;attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SystemCall</span>(attempt.<span class="built_in">c_str</span>(), return_value, errno_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>没什么好说的，只是操作系统socket接口的包装类。</p>
<h4 id="头文件-2"><a href="#头文件-2" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base class for network sockets (TCP, UDP, etc.)</span></span><br><span class="line"><span class="comment">// Socket is generally used via a subclass. See TCPSocket and UDPSocket for usage examples.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span> : <span class="keyword">public</span> FileDescriptor &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! Get the local or peer address the socket is connected to</span></span><br><span class="line">    <span class="function">Address <span class="title">get_address</span><span class="params">(<span class="type">const</span> std::string &amp;name_of_function,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> std::function&lt;<span class="type">int</span>(<span class="type">int</span>, sockaddr *, <span class="type">socklen_t</span> *)&gt; &amp;function)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Socket</span>(<span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type);</span><br><span class="line">    <span class="built_in">Socket</span>(FileDescriptor &amp;&amp;fd, <span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> option_type&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setsockopt</span><span class="params">(<span class="type">const</span> <span class="type">int</span> level, <span class="type">const</span> <span class="type">int</span> option, <span class="type">const</span> option_type &amp;option_value)</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Bind a socket to a local address, usually for listen/accept</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bind</span><span class="params">(<span class="type">const</span> Address &amp;address)</span></span>;</span><br><span class="line">    <span class="comment">// Connect a socket to a peer address</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> Address &amp;address)</span></span>;</span><br><span class="line">    <span class="comment">// Shut down a socket</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">(<span class="type">const</span> <span class="type">int</span> how)</span></span>;</span><br><span class="line">    <span class="comment">//! Get local address of socket</span></span><br><span class="line">    <span class="function">Address <span class="title">local_address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//! Get peer address of socket</span></span><br><span class="line">    <span class="function">Address <span class="title">peer_address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//! Allow local address to be reused sooner</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_reuseaddr</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! A wrapper around [UDP sockets](\ref man7::udp)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UDPSocket</span> : <span class="keyword">public</span> Socket &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//! \brief Construct from FileDescriptor (used by TCPOverUDPSocketAdapter)</span></span><br><span class="line">    <span class="comment">//! \param[in] fd is the FileDescriptor from which to construct</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UDPSocket</span><span class="params">(FileDescriptor &amp;&amp;fd)</span> : Socket(std::move(fd), AF_INET, SOCK_DGRAM) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Default: construct an unbound, unconnected UDP socket</span></span><br><span class="line">    <span class="built_in">UDPSocket</span>() : <span class="built_in">Socket</span>(AF_INET, SOCK_DGRAM) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// carries received data and information about the sender</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">received_datagram</span> &#123;</span><br><span class="line">        Address source_address;  <span class="comment">//!&lt; Address from which this datagram was received</span></span><br><span class="line">        std::string payload;     <span class="comment">//!&lt; UDP datagram payload</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//! Receive a datagram and the Address of its sender</span></span><br><span class="line">    <span class="function">received_datagram <span class="title">recv</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> mtu = <span class="number">65536</span>)</span></span>;</span><br><span class="line">    <span class="comment">//! Receive a datagram and the Address of its sender (caller can allocate storage)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recv</span><span class="params">(received_datagram &amp;datagram, <span class="type">const</span> <span class="type">size_t</span> mtu = <span class="number">65536</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Send a datagram to specified Address</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendto</span><span class="params">(<span class="type">const</span> Address &amp;destination, <span class="type">const</span> BufferViewList &amp;payload)</span></span>;</span><br><span class="line">    <span class="comment">//! Send datagram to the socket&#x27;s connected address (must call connect() first)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> BufferViewList &amp;payload)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! A wrapper around [TCP sockets](\ref man7::tcp)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSocket</span> : <span class="keyword">public</span> Socket &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Construct from FileDescriptor (used by accept())</span></span><br><span class="line">    <span class="comment">// fd is the FileDescriptor from which to construct</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TCPSocket</span><span class="params">(FileDescriptor &amp;&amp;fd)</span> : Socket(std::move(fd), AF_INET, SOCK_STREAM) &#123;</span>&#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Default: construct an unbound, unconnected TCP socket</span></span><br><span class="line">    <span class="built_in">TCPSocket</span>() : <span class="built_in">Socket</span>(AF_INET, SOCK_STREAM) &#123;&#125;</span><br><span class="line">    <span class="comment">//! Mark a socket as listening for incoming connections</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">(<span class="type">const</span> <span class="type">int</span> backlog = <span class="number">16</span>)</span></span>;</span><br><span class="line">    <span class="comment">//! Accept a new incoming connection</span></span><br><span class="line">    <span class="function">TCPSocket <span class="title">accept</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! A wrapper around [Unix-domain stream sockets](\ref man7::unix)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LocalStreamSocket</span> : <span class="keyword">public</span> Socket &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...构造器</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// SPONGE_LIBSPONGE_SOCKET_HH</span></span></span><br></pre></td></tr></table></figure>

<h4 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="构造器的参数"><a href="#构造器的参数" class="headerlink" title="构造器的参数"></a>构造器的参数</h5><p><a href="https://blog.csdn.net/liuxingen/article/details/44995467">参考文章</a></p>
<p>也是系统调用socket的参数，了解一下知识多多益善。</p>
<ol>
<li><p>domain</p>
<p>在本次实验中只会取值前两个，即本地通信和IPv4网络通信</p>
<p><img src="/2023/02/25/cs144/image-20230309232045195.png" alt="image-20230309232045195"></p>
</li>
<li><p>type</p>
<p>好像比如说取<code>SOCK_DGRAM</code>就是UDP，取<code>SOCK_STREAM</code>就是TCP。</p>
</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Socket */</span></span><br><span class="line"><span class="comment">/* 构造器 */</span></span><br><span class="line"><span class="comment">// default constructor for socket of (subclassed) domain and type</span></span><br><span class="line">Socket::<span class="built_in">Socket</span>(<span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type) : <span class="built_in">FileDescriptor</span>(<span class="built_in">SystemCall</span>(<span class="string">&quot;socket&quot;</span>, <span class="built_in">socket</span>(domain, type, <span class="number">0</span>))) &#123;&#125;</span><br><span class="line"><span class="comment">// construct from file descriptor</span></span><br><span class="line">Socket::<span class="built_in">Socket</span>(FileDescriptor &amp;&amp;fd, <span class="type">const</span> <span class="type">int</span> domain, <span class="type">const</span> <span class="type">int</span> type) : <span class="built_in">FileDescriptor</span>(<span class="built_in">move</span>(fd)) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the local or peer address the socket is connected to</span></span><br><span class="line"><span class="comment">// 此为private函数，应该是用于方便下面那两个函数的，虽然我觉得这个设计意图没什么必要（）</span></span><br><span class="line"><span class="function">Address <span class="title">Socket::get_address</span><span class="params">(<span class="type">const</span> string &amp;name_of_function,<span class="type">const</span> function&lt;<span class="type">int</span>(<span class="type">int</span>, sockaddr *, <span class="type">socklen_t</span> *)&gt; &amp;function)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Address::Raw address;</span><br><span class="line">    <span class="type">socklen_t</span> size = <span class="built_in">sizeof</span>(address);</span><br><span class="line">	<span class="built_in">SystemCall</span>(name_of_function, <span class="built_in">function</span>(<span class="built_in">fd_num</span>(), address, &amp;size));</span><br><span class="line">    <span class="keyword">return</span> &#123;address, size&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Address <span class="title">Socket::local_address</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">get_address</span>(<span class="string">&quot;getsockname&quot;</span>, getsockname); &#125;</span><br><span class="line"><span class="function">Address <span class="title">Socket::peer_address</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">get_address</span>(<span class="string">&quot;getpeername&quot;</span>, getpeername); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">这两个函数是用于把socket连到CS的</span></span><br><span class="line"><span class="comment">将socket的一端连上本机，就需要调用bind；连上别的什么东西就要用connect</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// bind socket to a specified local address (usually to listen/accept)</span></span><br><span class="line"><span class="comment">// address is a local Address to bind</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::bind</span><span class="params">(<span class="type">const</span> Address &amp;address)</span> </span>&#123; <span class="built_in">SystemCall</span>(<span class="string">&quot;bind&quot;</span>, ::<span class="built_in">bind</span>(<span class="built_in">fd_num</span>(), address, address.<span class="built_in">size</span>())); &#125;</span><br><span class="line"><span class="comment">// connect socket to a specified peer address</span></span><br><span class="line"><span class="comment">// address is the peer&#x27;s Address</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::connect</span><span class="params">(<span class="type">const</span> Address &amp;address)</span> </span>&#123; <span class="built_in">SystemCall</span>(<span class="string">&quot;connect&quot;</span>, ::<span class="built_in">connect</span>(<span class="built_in">fd_num</span>(), address, address.<span class="built_in">size</span>())); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shut down a socket in the specified way</span></span><br><span class="line"><span class="comment">// how can be `SHUT_RD`, `SHUT_WR`, or `SHUT_RDWR`</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::shutdown</span><span class="params">(<span class="type">const</span> <span class="type">int</span> how)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SystemCall</span>(<span class="string">&quot;shutdown&quot;</span>, ::<span class="built_in">shutdown</span>(<span class="built_in">fd_num</span>(), how));</span><br><span class="line">    <span class="keyword">switch</span> (how) &#123;</span><br><span class="line">        <span class="keyword">case</span> SHUT_RD:</span><br><span class="line">            <span class="built_in">register_read</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set socket option，传入协议层以及要设置非选项的键和值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> option_type&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setsockopt</span><span class="params">(<span class="type">const</span> <span class="type">int</span> level, <span class="type">const</span> <span class="type">int</span> option, <span class="type">const</span> option_type &amp;option_value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SystemCall</span>(<span class="string">&quot;setsockopt&quot;</span>, ::<span class="built_in">setsockopt</span>(<span class="built_in">fd_num</span>(), level, option, &amp;option_value, <span class="built_in">sizeof</span>(option_value)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allow local address to be reused sooner, at the cost of some robustness</span></span><br><span class="line"><span class="comment">// 以鲁棒性为代价，让local address可复用</span></span><br><span class="line"><span class="comment">// Using `SO_REUSEADDR` may reduce the robustness of your application</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::set_reuseaddr</span><span class="params">()</span> </span>&#123; <span class="built_in">setsockopt</span>(SOL_SOCKET, SO_REUSEADDR, <span class="built_in">int</span>(<span class="literal">true</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UDPSocket */</span></span><br><span class="line"><span class="comment">// 从socket中接收数据并放进datagram中</span></span><br><span class="line"><span class="comment">// If mtu is too small to hold the received datagram, this method throws a runtime_error</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDPSocket::recv</span><span class="params">(received_datagram &amp;datagram, <span class="type">const</span> <span class="type">size_t</span> mtu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// receive source address and payload</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> recv_len = <span class="built_in">SystemCall</span>(</span><br><span class="line">        <span class="string">&quot;recvfrom&quot;</span>,</span><br><span class="line">        ::<span class="built_in">recvfrom</span>(</span><br><span class="line">            <span class="built_in">fd_num</span>(), datagram.payload.<span class="built_in">data</span>(), datagram.payload.<span class="built_in">size</span>(), MSG_TRUNC, datagram_source_address, &amp;fromlen));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UDPSocket::received_datagram <span class="title">UDPSocket::recv</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> mtu)</span> </span>&#123;</span><br><span class="line">    received_datagram ret&#123;&#123;<span class="literal">nullptr</span>, <span class="number">0</span>&#125;, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">recv</span>(ret, mtu);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向socket发送数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendmsg_helper</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd_num,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> sockaddr *destination_address,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="type">socklen_t</span> destination_address_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> BufferViewList &amp;payload)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> bytes_sent = <span class="built_in">SystemCall</span>(<span class="string">&quot;sendmsg&quot;</span>, ::<span class="built_in">sendmsg</span>(fd_num, &amp;message, <span class="number">0</span>));</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDPSocket::sendto</span><span class="params">(<span class="type">const</span> Address &amp;destination, <span class="type">const</span> BufferViewList &amp;payload)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sendmsg_helper</span>(<span class="built_in">fd_num</span>(), destination, destination.<span class="built_in">size</span>(), payload);</span><br><span class="line">    <span class="built_in">register_write</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDPSocket::send</span><span class="params">(<span class="type">const</span> BufferViewList &amp;payload)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sendmsg_helper</span>(<span class="built_in">fd_num</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>, payload);</span><br><span class="line">    <span class="built_in">register_write</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="TCPSpongeSocket"><a href="#TCPSpongeSocket" class="headerlink" title="* TCPSpongeSocket"></a>* TCPSpongeSocket</h3><p>上面那俩类其实就是两个包装类，用来将系统调用包装为c++类，看起来很抽象很迷惑。<strong>但到这就不一样了！我们开始用上我们之前写的TCP协议的代码了！</strong></p>
<p>除了跟fd以及socket一致的<code>read</code>、<code>write</code>以及<code>close</code>之外，<code>TCPSocket</code>最独特的功能，应该就是TCP连接的建立与释放了，其状态转移等逻辑已由我们在Lab0-4实现，此socket类仅实现<u>事件的监听</u>和<u>TCP协议对象生命周期的管理</u>。</p>
<h4 id="双线程"><a href="#双线程" class="headerlink" title="双线程"></a>双线程</h4><p>在详细说明其两个功能——事件监听和生命周期管理——之前，不妨先了解下其总体的架构。</p>
<p><code>TCPSpongeSocket</code>需要双线程实现。其中一个线程用来招待其owner：它会执行向owner public的connect、read、write等服务。另一个线程用来运行<code>TCPConnection</code>：它会时刻调用connection的tick方法，并且进行事件监听。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! \class TCPSpongeSocket</span></span><br><span class="line"><span class="comment">//! This class involves the simultaneous operation of two threads.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! One, the &quot;owner&quot; or foreground thread, interacts with this class in much the</span></span><br><span class="line"><span class="comment">//! same way as one would interact with a TCPSocket: it connects or listens, writes to</span></span><br><span class="line"><span class="comment">//! and reads from a reliable data stream, etc. Only the owner thread calls public</span></span><br><span class="line"><span class="comment">//! methods of this class.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! The other, the &quot;TCPConnection&quot; thread, takes care of the back-end tasks that the kernel would</span></span><br><span class="line"><span class="comment">//! perform for a TCPSocket: reading and parsing datagrams from the wire, filtering out</span></span><br><span class="line"><span class="comment">//! segments unrelated to the connection, etc.</span></span><br></pre></td></tr></table></figure>

<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>完成事件监听的核心部分是方法<code>_tcp_loop</code>以及<code>_initialize_TCP</code>中对<code>_eventloop</code>的初始化，还有<code>eventloop</code>的实现。</p>
<p>看下来其实理解难度不大（虽然细节很多并且我懒得研究了），但我认为很值得学习。</p>
<h5 id="initialize-TCP"><a href="#initialize-TCP" class="headerlink" title="_initialize_TCP"></a>_initialize_TCP</h5><p>主要功能是添加我们想监听的事件，有四个，分别是从app得到数据、有要向app发送的数据、从底层协议得到数据、有要向底层协议发送的数据。具体的话，代码和注释都写得很详细就不说了。</p>
<p>可以看到，TCP与协议栈交互【包括收发数据报】，是通过<code>AdaptT _datagram_adapter;</code>实现的；TCP与上层APP交互【包括传送数据】，是通过<code>LocalStreamSocket _thread_data;</code>实现的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::_initialize_TCP(<span class="type">const</span> TCPConfig &amp;config) &#123;</span><br><span class="line">    _tcp.<span class="built_in">emplace</span>(config);</span><br><span class="line">    <span class="comment">// Set up the event loop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are four possible events to handle:需要监听以下四种事件</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 1) Incoming datagram received (needs to be given to</span></span><br><span class="line">    <span class="comment">//    TCPConnection::segment_received method)得到底层协议栈送过来的data</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 2) Outbound bytes received from local application via a write()</span></span><br><span class="line">    <span class="comment">//    call (needs to be read from the local stream socket and</span></span><br><span class="line">    <span class="comment">//    given to TCPConnection::data_written method)得到上层app送过来的data</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 3) Incoming bytes reassembled by the TCPConnection</span></span><br><span class="line">    <span class="comment">//    (needs to be read from the inbound_stream and written</span></span><br><span class="line">    <span class="comment">//    to the local stream socket back to the application)TCP协议需要向app写入data</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 4) Outbound segment generated by TCP (needs to be</span></span><br><span class="line">    <span class="comment">//    given to underlying datagram socket)TCP需要向外界发送data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 1: read from filtered packet stream and dump into TCPConnection得到外界data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::In,</span><br><span class="line">                        [&amp;] &#123;</span><br><span class="line">                            <span class="keyword">auto</span> seg = _datagram_adapter.<span class="built_in">read</span>();</span><br><span class="line">                            <span class="keyword">if</span> (seg) &#123;</span><br><span class="line">                                _tcp-&gt;<span class="built_in">segment_received</span>(<span class="built_in">move</span>(seg.<span class="built_in">value</span>()));</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (_thread_data.<span class="built_in">eof</span>() <span class="keyword">and</span> _tcp.<span class="built_in">value</span>().<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> _fully_acked) &#123; _fully_acked = <span class="literal">true</span>; &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        [&amp;] &#123; <span class="keyword">return</span> _tcp-&gt;<span class="built_in">active</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 2: read from pipe into outbound buffer得到app data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">        <span class="comment">// LocalStreamSocket _thread_data;</span></span><br><span class="line">		<span class="comment">// 看来用户是通过socket写入的数据</span></span><br><span class="line">        _thread_data,</span><br><span class="line">        Direction::In,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> data = _thread_data.<span class="built_in">read</span>(_tcp-&gt;<span class="built_in">remaining_outbound_capacity</span>());</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> len = data.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> amount_written = _tcp-&gt;<span class="built_in">write</span>(<span class="built_in">move</span>(data));</span><br><span class="line">            <span class="keyword">if</span> (amount_written != len) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;TCPConnection::write() accepted less than advertised length&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (_thread_data.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">                _tcp-&gt;<span class="built_in">end_input_stream</span>();</span><br><span class="line">                _outbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        [&amp;] &#123; <span class="built_in">return</span> (_tcp-&gt;<span class="built_in">active</span>()) <span class="built_in">and</span> (<span class="keyword">not</span> _outbound_shutdown) <span class="built_in">and</span> (_tcp-&gt;<span class="built_in">remaining_outbound_capacity</span>() &gt; <span class="number">0</span>); &#125;,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            _tcp-&gt;<span class="built_in">end_input_stream</span>();</span><br><span class="line">            _outbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 3: read from inbound buffer into pipe向app写入data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(</span><br><span class="line">        _thread_data,</span><br><span class="line">        Direction::Out,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            ByteStream &amp;inbound = _tcp-&gt;<span class="built_in">inbound_stream</span>();</span><br><span class="line">            <span class="comment">// Write from the inbound_stream into the pipe</span></span><br><span class="line">            <span class="type">const</span> <span class="type">size_t</span> amount_to_write = <span class="built_in">min</span>(<span class="built_in">size_t</span>(<span class="number">65536</span>), inbound.<span class="built_in">buffer_size</span>());</span><br><span class="line">            <span class="type">const</span> std::string buffer = inbound.<span class="built_in">peek_output</span>(amount_to_write);</span><br><span class="line">            <span class="comment">// 通过向socket写实现</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> bytes_written = _thread_data.<span class="built_in">write</span>(<span class="built_in">move</span>(buffer), <span class="literal">false</span>);</span><br><span class="line">            inbound.<span class="built_in">pop_output</span>(bytes_written);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inbound.<span class="built_in">eof</span>() <span class="keyword">or</span> inbound.<span class="built_in">error</span>()) &#123;</span><br><span class="line">                _thread_data.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">                _inbound_shutdown = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="keyword">not</span> _tcp-&gt;<span class="built_in">inbound_stream</span>().<span class="built_in">buffer_empty</span>()) <span class="built_in">or</span></span><br><span class="line">                   ((_tcp-&gt;<span class="built_in">inbound_stream</span>().<span class="built_in">eof</span>() <span class="keyword">or</span> _tcp-&gt;<span class="built_in">inbound_stream</span>().<span class="built_in">error</span>()) <span class="keyword">and</span> <span class="keyword">not</span> _inbound_shutdown);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rule 4: read outbound segments from TCPConnection and send as datagrams向外界写data</span></span><br><span class="line">    _eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::Out,</span><br><span class="line">                        [&amp;] &#123;</span><br><span class="line">                            <span class="keyword">while</span> (<span class="keyword">not</span> _tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                                <span class="comment">// 通过对adapter写实现</span></span><br><span class="line">                                _datagram_adapter.<span class="built_in">write</span>(_tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">front</span>());</span><br><span class="line">                                _tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        [&amp;] &#123; <span class="keyword">return</span> <span class="keyword">not</span> _tcp-&gt;<span class="built_in">segments_out</span>().<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tcp-loop"><a href="#tcp-loop" class="headerlink" title="_tcp_loop"></a>_tcp_loop</h5><p>可以看到，<code>_tcp_loop</code>的功能就是，在<code>condition</code>为真的时候，一是监听我们之前塞进<code>_event_loop</code>的所有事件，二是调用<code>TCPConnection</code>的<code>tick</code>方法来管理时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// condition is a function returning true if loop should continue</span></span><br><span class="line"><span class="comment">// Process events while specified condition is true</span></span><br><span class="line"><span class="comment">// 周期性调用事件condition以达到监听等待事件的效果，管理TCP的tick</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::_tcp_loop(<span class="type">const</span> function&lt;<span class="built_in">bool</span>()&gt; &amp;condition) &#123;</span><br><span class="line">    <span class="keyword">auto</span> base_time = <span class="built_in">timestamp_ms</span>();</span><br><span class="line">    <span class="comment">// 当条件一直为真时，监听event</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">condition</span>()) &#123;</span><br><span class="line">        <span class="comment">// 持续监听eventloop中的各种event</span></span><br><span class="line">        <span class="keyword">auto</span> ret = _eventloop.<span class="built_in">wait_next_event</span>(TCP_TICK_MS);</span><br><span class="line">        <span class="comment">// 条件为退出/丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (ret == EventLoop::Result::Exit <span class="keyword">or</span> _abort) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果tcp还存活，则调用其tick方法</span></span><br><span class="line">        <span class="keyword">if</span> (_tcp.<span class="built_in">value</span>().<span class="built_in">active</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> next_time = <span class="built_in">timestamp_ms</span>();</span><br><span class="line">            _tcp.<span class="built_in">value</span>().<span class="built_in">tick</span>(next_time - base_time);</span><br><span class="line">            _datagram_adapter.<span class="built_in">tick</span>(next_time - base_time);</span><br><span class="line">            base_time = next_time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="eventloop"><a href="#eventloop" class="headerlink" title="eventloop"></a>eventloop</h5><p>eventloop具体是通过Linux提供的poll机制来进行事件监听的。</p>
<blockquote>
<p><a href="https://blog.csdn.net/m0_49328056/article/details/123454707">Linux poll机制</a></p>
<p>怎么说，又一次感受到了“<strong>网络就是IO</strong>”这个抽象的牛逼之处。操作系统的poll机制和poll函数本质上是针对IO读写来设计的，而正因为网络的本质是IO，正因为网络收发数据包、与上层app交互本质还是IO（因为通过文件描述符），才能在这里采用这种方式进行文件读写。</p>
<p>我的评价是佩服到五体投地好吧</p>
<p><img src="/2023/02/25/cs144/image-20230310185319115.png" alt="image-20230310185319115"></p>
<p><strong>poll函数就是IO等待的一种实现机制。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>事件类型events可以为下列值：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">POLLIN</span>:<span class="string">有数据可读</span></span><br><span class="line"><span class="attr">POLLRDNORM</span>:<span class="string">有普通数据可读，等效于POLLIN</span></span><br><span class="line"><span class="attr">POLLRDBAND</span>:<span class="string">有优先数据可读</span></span><br><span class="line"><span class="attr">POLLPRI</span>:<span class="string">有紧迫数据可读</span></span><br><span class="line"><span class="attr">POLLOUT</span>:<span class="string">写数据不会导致阻塞</span></span><br><span class="line"><span class="attr">POLLWRNORM</span>:<span class="string">写普通数据不会导致阻塞</span></span><br><span class="line"><span class="attr">POLLWRBAND</span>:<span class="string">写优先数据不会导致阻塞</span></span><br><span class="line"><span class="attr">POLLMSG</span>:<span class="string">SIGPOLL消息可用</span></span><br><span class="line"><span class="attr">POLLER</span>:<span class="string">指定的文件描述符发生错误</span></span><br><span class="line"><span class="attr">POLLHUP</span>:<span class="string">指定的文件描述符挂起事件</span></span><br><span class="line"><span class="attr">POLLNVAL</span>:<span class="string">无效的请求，打不开指定的文件描述符</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们在前面的eventloop的rule初始化中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::In,</span><br><span class="line">                        [&amp;] &#123; ... &#125;);</span><br></pre></td></tr></table></figure>

<p>这个的意思是针对<code>_datagram_adapter</code>这个文件的<code>Direction::In</code>这个事件发生时，就会执行<code>[&amp;]</code>中的事件。那么<code>Direction::In</code>是什么？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Direction</span> : <span class="type">short</span> &#123;</span><br><span class="line">    In = POLLIN,   <span class="comment">//!&lt; Callback will be triggered when Rule::fd is readable.</span></span><br><span class="line">    Out = POLLOUT  <span class="comment">//!&lt; Callback will be triggered when Rule::fd is writable.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见，eventloop具体是通过os提供的IO事件机制来进行监听的。</p>
<p>具体的监听以及执行逻辑由<code>wait_next_event</code>来实现。它主要干的就是，清理掉那些我们不感兴趣的或者已经似了（比如说对应的fd已经close之类的）的事件，然后找到那些触发到了的active的事件并且调用它们的caller。</p>
<p>具体代码还是有些微复杂的，有兴趣可以去看看，这里就不放了。</p>
<h4 id="生命周期的管理"><a href="#生命周期的管理" class="headerlink" title="生命周期的管理"></a>生命周期的管理</h4><p>核心部分为方法<code>connect</code>、<code>listen_and_accept</code>以及<code>_tcp_main</code>。</p>
<h5 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h5><p>由客户端调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client调用</span></span><br><span class="line"><span class="comment">// 未收到外界连接时，owner进程会阻塞</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::<span class="built_in">connect</span>(<span class="type">const</span> TCPConfig &amp;c_tcp, <span class="type">const</span> FdAdapterConfig &amp;c_ad) &#123;</span><br><span class="line">    <span class="comment">// 初始化tcp的事件监听</span></span><br><span class="line">    _initialize_TCP(c_tcp);</span><br><span class="line">    <span class="comment">// 初始化adapater</span></span><br><span class="line">    _datagram_adapter.<span class="built_in">config_mut</span>() = c_ad;</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: Connecting to &quot;</span> &lt;&lt; c_ad.destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;...\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 我们实现的：发送SYN报文</span></span><br><span class="line">    _tcp-&gt;<span class="built_in">connect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一的状态管理</span></span><br><span class="line">    <span class="type">const</span> TCPState expected_state = TCPState::State::SYN_SENT;</span><br><span class="line">    <span class="comment">// 等待直到条件为假，也即脱离SYN-SENT转移到ESTABLISHED</span></span><br><span class="line">    _tcp_loop([&amp;] &#123; <span class="keyword">return</span> _tcp-&gt;<span class="built_in">state</span>() == TCPState::State::SYN_SENT; &#125;);</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Successfully connected to &quot;</span> &lt;&lt; c_ad.destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立连接后开启connection进程, 执行_tcp_main，继续监听event直到死亡</span></span><br><span class="line">    _tcp_thread = <span class="built_in">thread</span>(&amp;TCPSpongeSocket::_tcp_main, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tcp-main"><a href="#tcp-main" class="headerlink" title="_tcp_main"></a>_tcp_main</h5><p>负责establish状态的监听以及之后关闭TCP连接的擦屁股工作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::_tcp_main() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> _tcp.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;no TCP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 持续监听直到死亡</span></span><br><span class="line">        _tcp_loop([] &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br><span class="line">        <span class="built_in">shutdown</span>(SHUT_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> _tcp.<span class="built_in">value</span>().<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;DEBUG: TCP connection finished &quot;</span></span><br><span class="line">                 &lt;&lt; (_tcp.<span class="built_in">value</span>().<span class="built_in">state</span>() == TCPState::State::RESET ? <span class="string">&quot;uncleanly&quot;</span> : <span class="string">&quot;cleanly.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _tcp.<span class="built_in">reset</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Exception in TCPConnection runner thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="listen-and-accept"><a href="#listen-and-accept" class="headerlink" title="listen_and_accept"></a>listen_and_accept</h5><p>由服务器端调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Server调用</span></span><br><span class="line"><span class="comment">// 未收到外界连接时，owner进程会阻塞</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="type">void</span> TCPSpongeSocket&lt;AdaptT&gt;::<span class="built_in">listen_and_accept</span>(<span class="type">const</span> TCPConfig &amp;c_tcp, <span class="type">const</span> FdAdapterConfig &amp;c_ad) &#123;</span><br><span class="line">     _initialize_TCP(c_tcp);</span><br><span class="line">    _datagram_adapter.<span class="built_in">config_mut</span>() = c_ad;</span><br><span class="line">    </span><br><span class="line">    _datagram_adapter.<span class="built_in">set_listening</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: Listening for incoming connection...\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 等待直到ESTABLISHED。注意下这里的状态条件</span></span><br><span class="line">    <span class="comment">// 其中各种收发报文的事件由tcp_loop中的event做</span></span><br><span class="line">    _tcp_loop([&amp;] &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> s = _tcp-&gt;<span class="built_in">state</span>();</span><br><span class="line">        <span class="built_in">return</span> (s == TCPState::State::LISTEN <span class="keyword">or</span> s == TCPState::State::SYN_RCVD <span class="keyword">or</span> s == TCPState::State::SYN_SENT);</span><br><span class="line">    &#125;);</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;New connection from &quot;</span> &lt;&lt; _datagram_adapter.<span class="built_in">config</span>().destination.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启connection进程</span></span><br><span class="line">    _tcp_thread = <span class="built_in">thread</span>(&amp;TCPSpongeSocket::_tcp_main, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CS144TCPSocket-和-FullStackSocket"><a href="#CS144TCPSocket-和-FullStackSocket" class="headerlink" title="CS144TCPSocket 和 FullStackSocket"></a>CS144TCPSocket 和 FullStackSocket</h3><p>主菜（上面那个）已经说完了，这两个就是简单的包装类，没什么好说的，大概就做了点传参工作，主要差异还是adapter。</p>
<h3 id="Adapter实现"><a href="#Adapter实现" class="headerlink" title="Adapter实现"></a>Adapter实现</h3><p>在我们的<code>TCPSpongeSocket</code>实现中，我们引入了“adapter”的概念。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//! Adapter to underlying datagram socket (e.g., UDP or IP)</span></span><br><span class="line">    AdaptT _datagram_adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> TCPOverUDPSpongeSocket = TCPSpongeSocket&lt;TCPOverUDPSocketAdapter&gt;;</span><br><span class="line"><span class="keyword">using</span> TCPOverIPv4SpongeSocket = TCPSpongeSocket&lt;TCPOverIPv4OverTunFdAdapter&gt;;</span><br><span class="line"><span class="keyword">using</span> TCPOverIPv4OverEthernetSpongeSocket = TCPSpongeSocket&lt;TCPOverIPv4OverEthernetAdapter&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LossyTCPOverUDPSpongeSocket = TCPSpongeSocket&lt;LossyTCPOverUDPSocketAdapter&gt;;</span><br><span class="line"><span class="keyword">using</span> LossyTCPOverIPv4SpongeSocket = TCPSpongeSocket&lt;LossyTCPOverIPv4OverTunFdAdapter&gt;;</span><br></pre></td></tr></table></figure>

<p>它很完美地以策略模式的形式，凝结出了我们本次实验所需的各种协议栈的共同代码，放进了<code>TCPSpongeSocket</code>，而将涉及到协议栈差异的部分用adapter完成。</p>
<p>在<code>TCPSpongeSocket</code>中，adapter主要完成了如下操作：</p>
<ol>
<li><p>adapter的tick函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in tcp_loop</span></span><br><span class="line">_tcp.<span class="built_in">value</span>().<span class="built_in">tick</span>(next_time - base_time);</span><br><span class="line">_datagram_adapter.<span class="built_in">tick</span>(next_time - base_time);</span><br></pre></td></tr></table></figure></li>
<li><p>作为订阅事件的IO流</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_eventloop.<span class="built_in">add_rule</span>(_datagram_adapter,</span><br><span class="line">                        Direction::In,</span><br><span class="line">                        [&amp;] &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li>
<li><p>TCP层通过对其读写来获取TCP segment</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">auto seg <span class="operator">=</span> _datagram_adapter.read()<span class="comment">;</span></span><br><span class="line">_datagram_adapter.write(_tcp-&gt;segments_out().front())<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
<li><p>记录各类参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">datagram_adapter.<span class="built_in">config</span>().destination.<span class="built_in">to_string</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/2023/02/25/cs144/class_fd_adapter_base__inherit__graph.png" alt="Inheritance graph"></p>
<p>具体实现说实话没什么好说的，确实无非也就是上面那几个方法，然后在里面包装下和操作系统提供的tun和tap的接口交互罢了，代码也比较简单，此处就不说了。</p>
<h2 id="apps"><a href="#apps" class="headerlink" title="apps"></a>apps</h2><p>除了对协议栈的实现之外，在app文件夹下还有许多对我们实现的协议栈的应用实例。我认为了解下应用实例也是很重要的。</p>
<h3 id="bidirectional-stream-copy"><a href="#bidirectional-stream-copy" class="headerlink" title="bidirectional_stream_copy"></a>bidirectional_stream_copy</h3><p>其作用就是建立stdin/stdout与socket的关联。它从stdin读输入，作为上层app的输入写入socket；从socket读输出，传给上层app，也即stdout输出。它的具体实现在stdin/stdout之间隔了两条bytestream，分别是<code>_inbound</code>和<code>_outbound</code>。</p>
<p>由于stdin、stdout、socket本质上都是fd，所以我们依然可以采用跟上面一样的事件驱动方式。我们只需在socket有输出时马上读给inbound bytestream，在inbound bytestream有输入时马上读给stdout，在stdin有输入时马上写入outbound bytestream，在outbound bytestream有输入时马上读给socket。遵守这4条rule就行了。</p>
<p>因而，具体实现就是<code>TCPSpongeSocket::_initialize_TCP</code>和<code>TCPSpongeSocket::_tcp_loop</code>的结合体，订阅事件+循环等待。由于跟前面类似，在此就不放代码了。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他都太复杂了，感觉我水平一般还不大能理解，也懒得看了【草】总之先咕咕咕</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2024/06/21/computer_network_course/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/2024/06/21/computer_network_course/image-20240616162640888.png" alt="image-20240616162640888"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>计算机网络的定义</p>
<p>计算机网络就是互连的、自治（无主从关系）的计算机集合。通过交换网络互连主机，交换结点指路由器or交换机</p>
</li>
<li><p>Internet的定义和组成</p>
<p>网络之网络，全球最大互联网络</p>
<ol>
<li><p>计算设备</p>
<p>主机=端系统</p>
</li>
<li><p>通信链路</p>
<p>光纤卫星铜缆</p>
</li>
<li><p>分组交换：转发分组</p>
<p>路由器、交换机</p>
</li>
<li><p>通信基础设施</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619195855812.png" alt="image-20240619195855812"></p>
</li>
<li><p>API</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619195914170.png" alt="image-20240619195914170"></p>
</li>
</ol>
</li>
<li><p>协议</p>
<p>硬件（主机、路由器、通信链路）是计算机网络的基础</p>
<p>数据交换必须依照定义好的规则：计算机网络的所有通信过程都必须遵守某种/些规则—协议</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616163247227.png" alt="image-20240616163247227"></p>
<p>协议的三要素：</p>
<ol>
<li><p>语法</p>
<p>数据与控制信息格式、信号电平</p>
</li>
<li><p>语义</p>
<p>何种控制信息、何种响应、差错控制</p>
</li>
<li><p>时序</p>
<p>事件顺序、速度匹配</p>
</li>
</ol>
</li>
<li><p>计算机网络分类</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616163411427.png" alt="image-20240616163411427"></p>
</li>
<li><p>ISP</p>
<p>Internet Service Provider，互联网服务提供商。</p>
<p>ISP 是提供互联网接入服务的公司或组织，它们允许用户通过各种方式连接到互联网。ISP 可以是商业公司、社区组织或政府机构，它们通常提供以下服务：</p>
<ol>
<li><strong>互联网接入</strong>：ISP 提供连接到全球互联网的途径，用户可以通过有线或无线方式接入。</li>
<li><strong>数据传输</strong>：ISP 负责传输用户的数据，包括网页浏览、电子邮件、文件下载和上传等。</li>
<li><strong>网络管理</strong>：ISP 管理其网络基础设施，确保网络的稳定性和可靠性。</li>
<li><strong>增值服务</strong>：许多ISP还提供额外的服务，如网络安全、云存储、域名注册等。</li>
<li><strong>网络监管</strong>：在某些情况下，ISP 可能需要遵守政府的监管政策，对用户的数据传输进行监控或过滤。</li>
</ol>
<p>ISP 可以是本地的小型服务提供商，也可以是覆盖全国或跨国的大型服务提供商。用户通常会根据价格、服务质量、速度和其他因素选择ISP。</p>
</li>
</ol>
<h2 id="计算机网络结构"><a href="#计算机网络结构" class="headerlink" title="计算机网络结构"></a>计算机网络结构</h2><p><img src="/2024/06/21/computer_network_course/image-20240616163427996.png" alt="image-20240616163427996"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616163438956.png" alt="image-20240616163438956"></p>
<h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><ol>
<li>主机（端系统）</li>
<li>CS结构</li>
<li>P2P结构，在对等实体之间通信</li>
</ol>
<h3 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h3><h4 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h4><p>将网络边缘接入核心网络（边缘路由器）</p>
<p>家庭的直连路由器，企业的一般连接交换机</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616164632454.png" alt="image-20240616164632454"></p>
<h4 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h4><ol>
<li><p>电话接入（DSL）</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616163638076.png" alt="image-20240616163638076"></p>
<blockquote>
<p>FDM（Frequency-Division Multiplexing，频分多路复用）指的是一种在特定频段内分配不同用途的通信方式。频率分配方式允许不同的通信服务或信号在同一物理通道上共存，但通过不同的频率范围来区分，确保它们不会互相干扰。</p>
<ul>
<li><strong>下行（下载）（Downlink）</strong>：指的是信号从基站（或中心节点）传输到移动设备（如手机、平板电脑等）的过程。</li>
<li><strong>上行（上传）（Uplink）</strong>：与下行相反，上行指的是信号从移动设备传输到基站（或中心节点）的过程。</li>
</ul>
</blockquote>
</li>
<li><p>电缆网络</p>
<p>使用FDM频分多路复用</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616163938017.png" alt="image-20240616163938017"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616163954071.png" alt="image-20240616163954071"></p>
</li>
<li><p>光纤到户（FTTH）</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616164305243.png" alt="image-20240616164305243"></p>
</li>
</ol>
<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>互联的路由器网络</p>
<p>网络核心的关键功能：路由+转发</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616164718533.png" alt="image-20240616164718533"></p>
<h3 id="网络之网络"><a href="#网络之网络" class="headerlink" title="网络之网络"></a>网络之网络</h3><p><img src="/2024/06/21/computer_network_course/image-20240616164829438.png" alt="image-20240616164829438"></p>
<p>如何互连数以万计的ISP？</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616164957169.png" alt="image-20240616164957169"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616165009288.png" alt="image-20240616165009288"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616165024115.png" alt="image-20240616165024115"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616165054260.png" alt="image-20240616165054260"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616165132950.png" alt="image-20240616165132950"></p>
<p>所以因此需要引入分级系统</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616165224049.png" alt="image-20240616165224049"></p>
<h2 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h2><p>recall: 互联的路由器网络Q：如何实现数据通过网络核心从源主机到达目的主机？A：<strong>数据交换</strong></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616165744420.png" alt="image-20240616165744420"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616165756475.png" alt="image-20240616165756475"></p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="/2024/06/21/computer_network_course/image-20240616165830421.png" alt="image-20240616165830421"></p>
<ol>
<li><p>电路交换</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616165916118.png" alt="image-20240616165916118"></p>
</li>
<li><p>报文交换（注意，这个是<strong>一整个文件直接发</strong>）</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616165954326.png" alt="image-20240616165954326"></p>
</li>
<li><p>分组交换（package switching）</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616170054572.png" alt="image-20240616170054572"></p>
</li>
</ol>
<h3 id="存储转发-报文vs分组"><a href="#存储转发-报文vs分组" class="headerlink" title="存储转发(报文vs分组)"></a>存储转发(报文vs分组)</h3><p>报文交换与分组交换都是存储-转发模式</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616171421826.png" alt="image-20240616171421826"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616171511041.png" alt="image-20240616171511041"></p>
<p>需要经过三段路程，每段5s</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616171807926.png" alt="image-20240616171807926"></p>
<p>相当于有了一层流水线。每一跳需要1ms，一共5000个报文，最后叠起来相当于1+5000+1=5002ms。</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616172342062.png" alt="image-20240616172342062"></p>
<p><strong>相当于（分组数+路由器数）*分组大小除以带宽 = (M/L)*L/R+(h-1)*L/R = M/R+nL/R</strong></p>
<h3 id="分组vs电路"><a href="#分组vs电路" class="headerlink" title="分组vs电路"></a>分组vs电路</h3><p><img src="/2024/06/21/computer_network_course/image-20240616172820593.png" alt="image-20240616172820593"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616172846770.png" alt="image-20240616172846770"></p>
<p>拥塞相对来说也是电路的优点，他本身自带可靠传输</p>
<h2 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h2><p><img src="/2024/06/21/computer_network_course/image-20240616202330010.png" alt="image-20240616202330010"></p>
<h3 id="速率-带宽-吞吐量"><a href="#速率-带宽-吞吐量" class="headerlink" title="速率/带宽/吞吐量"></a>速率/带宽/吞吐量</h3><p>“速率”在题目中一般都叫<strong>数据传输速率</strong></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616173033909.png" alt="image-20240616173033909"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616173114894.png" alt="image-20240616173114894"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616181328758.png" alt="image-20240616181328758"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616203154644.png" alt="image-20240616203154644"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616181338245.png" alt="image-20240616181338245"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616181350071.png" alt="image-20240616181350071"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616203239440.png" alt="image-20240616203239440"></p>
<h3 id="延迟-时延"><a href="#延迟-时延" class="headerlink" title="延迟/时延"></a>延迟/时延</h3><p><img src="/2024/06/21/computer_network_course/image-20240616203417746.png" alt="image-20240616203417746"></p>
<p>传输时延也叫发送时延</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616173223579.png" alt="image-20240616173223579"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616173254183.png" alt="image-20240616173254183"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616173400088.png" alt="image-20240616173400088"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616174928447.png" alt="image-20240616174928447"></p>
<p>也是非常颠覆我。。。不过确实传播延迟有时候相比传输延迟小得多，3kb就是其三百倍的样子，完全可以忽略不计。</p>
<ol>
<li><p>排队延迟</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616180702138.png" alt="image-20240616180702138"></p>
</li>
</ol>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p><img src="/2024/06/21/computer_network_course/image-20240616180834856.png" alt="image-20240616180834856"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616204331118.png" alt="image-20240616204331118"></p>
<p>相当于是体积了</p>
<h3 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h3><p><img src="/2024/06/21/computer_network_course/image-20240616180854331.png" alt="image-20240616180854331"></p>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><img src="/2024/06/21/computer_network_course/image-20240616181215148.png" alt="image-20240616181215148"></p>
<p>貌似上图认为ack是不携带数据的了，所以没算tack</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616211411078.png" alt="image-20240616211411078"></p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="/2024/06/21/computer_network_course/image-20240616213653142.png" alt="image-20240616213653142"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616213754255.png" alt="image-20240616213754255"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616213905748.png" alt="image-20240616213905748"></p>
<h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><p>开放系统互联（OSI）参考模型</p>
<p>异构网络系统互联的国际标准</p>
<p>7层：</p>
<ol>
<li><p>应用层</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619202757801.png" alt="image-20240619202757801"></p>
</li>
<li><p>表示层</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616214145639.png" alt="image-20240616214145639"></p>
</li>
<li><p>会话层</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619202732386.png" alt="image-20240619202732386"></p>
</li>
<li><p>传输层</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619202659578.png" alt="image-20240619202659578"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619202714592.png" alt="image-20240619202714592"></p>
</li>
<li><p>网络层</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619202634495.png" alt="image-20240619202634495"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619202647251.png" alt="image-20240619202647251"></p>
</li>
<li><p>数据链路层</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619202611749.png" alt="image-20240619202611749"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619202625291.png" alt="image-20240619202625291"></p>
</li>
<li><p>物理层</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619202558647.png" alt="image-20240619202558647"></p>
</li>
</ol>
<h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p><img src="/2024/06/21/computer_network_course/image-20240616214711678.png" alt="image-20240616214711678"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616215229447.png" alt="image-20240616215229447"></p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p><img src="/2024/06/21/computer_network_course/image-20240616215756098.png" alt="image-20240616215756098"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616220035337.png" alt="image-20240616220035337"></p>
<p>Data Terminal Equipment</p>
<p>Data Circuit-terminating Equipment</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616220640069.png" alt="image-20240616220640069"></p>
<h2 id="数据通信基础"><a href="#数据通信基础" class="headerlink" title="数据通信基础"></a>数据通信基础</h2><p><img src="/2024/06/21/computer_network_course/image-20240616220652893.png" alt="image-20240616220652893"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616220709453.png" alt="image-20240616220709453"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616221049587.png" alt="image-20240616221049587"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616221117853.png" alt="image-20240616221117853"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616221155335.png" alt="image-20240616221155335"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616221243562.png" alt="image-20240616221243562"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616221348498.png" alt="image-20240616221348498"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616221603304.png" alt="image-20240616221603304"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616221618414.png" alt="image-20240616221618414"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616221658885.png" alt="image-20240616221658885"></p>
<h2 id="物理介质"><a href="#物理介质" class="headerlink" title="物理介质"></a>物理介质</h2><h3 id="导引型"><a href="#导引型" class="headerlink" title="导引型"></a>导引型</h3><p><img src="/2024/06/21/computer_network_course/image-20240616222102887.png" alt="image-20240616222102887"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616222115067.png" alt="image-20240616222115067"></p>
<h3 id="非导引型"><a href="#非导引型" class="headerlink" title="非导引型"></a>非导引型</h3><p><img src="/2024/06/21/computer_network_course/image-20240616222129402.png" alt="image-20240616222129402"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616222138465.png" alt="image-20240616222138465"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616222148014.png" alt="image-20240616222148014"></p>
<h2 id="信道与信道容量"><a href="#信道与信道容量" class="headerlink" title="信道与信道容量"></a>信道与信道容量</h2><p><img src="/2024/06/21/computer_network_course/image-20240616222218890.png" alt="image-20240616222218890"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616222252100.png" alt="image-20240616222252100"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616222701784.png" alt="image-20240616222701784"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616222822912.png" alt="image-20240616222822912"></p>
<p>第一个给了个理想无噪声，第二个给了个噪声的</p>
<h2 id="信道共享-多路复用"><a href="#信道共享-多路复用" class="headerlink" title="信道共享-多路复用"></a>信道共享-多路复用</h2><p><img src="/2024/06/21/computer_network_course/image-20240616223922180.png" alt="image-20240616223922180"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616223943863.png" alt="image-20240616223943863"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616224005008.png" alt="image-20240616224005008"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616224030951.png" alt="image-20240616224030951"></p>
<p>感觉意思就是说有的用户用高频的有的用低频的，到时候再解调什么的就行</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616224618995.png" alt="image-20240616224618995"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616224629990.png" alt="image-20240616224629990"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616224556890.png" alt="image-20240616224556890"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616224607722.png" alt="image-20240616224607722"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616224737866.png" alt="image-20240616224737866"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616224747385.png" alt="image-20240616224747385"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616224936523.png" alt="image-20240616224936523"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616224820667.png" alt="image-20240616224820667"></p>
<h2 id="基带传输基础"><a href="#基带传输基础" class="headerlink" title="基带传输基础"></a>基带传输基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="/2024/06/21/computer_network_course/image-20240616225148922.png" alt="image-20240616225148922"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616225217233.png" alt="image-20240616225217233"></p>
<h3 id="典型编码"><a href="#典型编码" class="headerlink" title="典型编码"></a>典型编码</h3><h4 id="不-归零"><a href="#不-归零" class="headerlink" title="(不)归零"></a>(不)归零</h4><p><img src="/2024/06/21/computer_network_course/image-20240616225226497.png" alt="image-20240616225226497"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616225244776.png" alt="image-20240616225244776"></p>
<p>就是说把0变成了-1</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616225330691.png" alt="image-20240616225330691"></p>
<p>就是每个1只占一点点，估计可以用来区分连续的1</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616225413268.png" alt="image-20240616225413268"></p>
<h4 id="差分码"><a href="#差分码" class="headerlink" title="差分码"></a>差分码</h4><p><img src="/2024/06/21/computer_network_course/image-20240616225434216.png" alt="image-20240616225434216"></p>
<h4 id="AMI码"><a href="#AMI码" class="headerlink" title="AMI码"></a>AMI码</h4><p><img src="/2024/06/21/computer_network_course/image-20240616225456510.png" alt="image-20240616225456510"></p>
<h4 id="双相码-曼彻斯特码"><a href="#双相码-曼彻斯特码" class="headerlink" title="双相码(曼彻斯特码)"></a>双相码(曼彻斯特码)</h4><p><img src="/2024/06/21/computer_network_course/image-20240616230207351.png" alt="image-20240616230207351"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616230238237.png" alt="image-20240616230238237"></p>
<p>有点类似双极归零，就是归是不是零，只在1和-1跳变</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616230450904.png" alt="image-20240616230450904"></p>
<h4 id="nBmB"><a href="#nBmB" class="headerlink" title="nBmB"></a>nBmB</h4><p>谜语人看不懂</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616230536060.png" alt="image-20240616230536060"></p>
<h2 id="频带传输基础"><a href="#频带传输基础" class="headerlink" title="频带传输基础"></a>频带传输基础</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>基带信号低通特性，可在低通特性信号传输</p>
<p>许多带通信道不具有低通特性，故而需要调制基带信号为与对应信道传输特性相匹配的信号</p>
<p>利用模拟基带信号调制载波：模拟调制</p>
<p>数字：数字调制</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616230702685.png" alt="image-20240616230702685"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="2ASK"><a href="#2ASK" class="headerlink" title="2ASK"></a>2ASK</h4><p><img src="/2024/06/21/computer_network_course/image-20240616230743496.png" alt="image-20240616230743496"></p>
<p>就是说0就没有了</p>
<h4 id="2FSK"><a href="#2FSK" class="headerlink" title="2FSK"></a>2FSK</h4><p><img src="/2024/06/21/computer_network_course/image-20240616230758129.png" alt="image-20240616230758129"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616230809912.png" alt="image-20240616230809912"></p>
<p>就是说1的更密集更高频</p>
<h4 id="2PSK"><a href="#2PSK" class="headerlink" title="2PSK"></a>2PSK</h4><p><img src="/2024/06/21/computer_network_course/image-20240616230832981.png" alt="image-20240616230832981"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616230841958.png" alt="image-20240616230841958"></p>
<p>就是说1和0的相位不一样</p>
<h4 id="2DPSK"><a href="#2DPSK" class="headerlink" title="2DPSK"></a>2DPSK</h4><p><img src="/2024/06/21/computer_network_course/image-20240616230850371.png" alt="image-20240616230850371"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616230910866.png" alt="image-20240616230910866"></p>
<p>就是说相位不一样代表差分，还是跟差分差不多的概念</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ol>
<li><p>频带利用率</p>
<p>ASK、PSK、DPSK频带利用率相同，FSK的最低，因为他是通过改变频率区分的1和0</p>
</li>
<li><p>误码率</p>
<p>PSK误码率最低，ASK误码率最高</p>
<p>PSK＞FSK＞ASK</p>
</li>
<li><p>对信道特性敏感性</p>
<p>ASK最高，性能最差</p>
<p>FSK和PSK不敏感</p>
</li>
</ol>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="多进制数字调制"><a href="#多进制数字调制" class="headerlink" title="多进制数字调制"></a>多进制数字调制</h4><p><img src="/2024/06/21/computer_network_course/image-20240616231133229.png" alt="image-20240616231133229"></p>
<h4 id="正交幅值调制QAM"><a href="#正交幅值调制QAM" class="headerlink" title="正交幅值调制QAM"></a>正交幅值调制QAM</h4><p><img src="/2024/06/21/computer_network_course/image-20240616231154175.png" alt="image-20240616231154175"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616231205807.png" alt="image-20240616231205807"></p>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><p><img src="/2024/06/21/computer_network_course/image-20240616231219905.png" alt="image-20240616231219905"></p>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h2><p><img src="/2024/06/21/computer_network_course/image-20240616232113016.png" alt="image-20240616232113016"></p>
<p>原来MAC是这个意思草</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616232407049.png" alt="image-20240616232407049"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616232157584.png" alt="image-20240616232157584"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616232823849.png" alt="image-20240616232823849"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616233746618.png" alt="image-20240616233746618"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616233814494.png" alt="image-20240616233814494"></p>
<h2 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h2><h3 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h3><p><img src="/2024/06/21/computer_network_course/image-20240616232914447.png" alt="image-20240616232914447"></p>
<p>MTU只计算帧的数据部分</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616233431887.png" alt="image-20240616233431887"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616232500015.png" alt="image-20240616232500015"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616232538632.png" alt="image-20240616232538632"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616232604440.png" alt="image-20240616232604440"></p>
<p>使用转义字节</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616232633324.png" alt="image-20240616232633324"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616232656255.png" alt="image-20240616232656255"></p>
<p>这个是只要有5个1就马上添0，不管下一个是不是1，这样一来接收只要数五个1就去一个0就行。</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616233409528.png" alt="image-20240616233409528"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616233359684.png" alt="image-20240616233359684"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><img src="/2024/06/21/computer_network_course/image-20240616233628418.png" alt="image-20240616233628418"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616233651637.png" alt="image-20240616233651637"></p>
<h2 id="差错检测与纠正"><a href="#差错检测与纠正" class="headerlink" title="差错检测与纠正"></a>差错检测与纠正</h2><p><img src="/2024/06/21/computer_network_course/image-20240616234121634.png" alt="image-20240616234121634"></p>
<p>因材施教兄弟</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616233932787.png" alt="image-20240616233932787"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616234207525.png" alt="image-20240616234207525"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616234431464.png" alt="image-20240616234431464"></p>
<h3 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h3><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><p><img src="/2024/06/21/computer_network_course/image-20240616234850541.png" alt="image-20240616234850541"></p>
<p>不论是奇校验还是偶校验：</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616234909419.png" alt="image-20240616234909419"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616235017331.png" alt="image-20240616235017331"></p>
<p>这个二维的很有意思</p>
<h4 id="Internet校验和-Checksum"><a href="#Internet校验和-Checksum" class="headerlink" title="Internet校验和(Checksum)"></a>Internet校验和(Checksum)</h4><p><img src="/2024/06/21/computer_network_course/image-20240616235111428.png" alt="image-20240616235111428"></p>
<h4 id="循环冗余校验码-CRC"><a href="#循环冗余校验码-CRC" class="headerlink" title="循环冗余校验码(CRC)"></a>循环冗余校验码(CRC)</h4><p><img src="/2024/06/21/computer_network_course/image-20240616235132449.png" alt="image-20240616235132449"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616235140156.png" alt="image-20240616235140156"></p>
<h3 id="差错纠正"><a href="#差错纠正" class="headerlink" title="差错纠正"></a>差错纠正</h3><p><img src="/2024/06/21/computer_network_course/image-20240616235240477.png" alt="image-20240616235240477"></p>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p><img src="/2024/06/21/computer_network_course/image-20240616235356246.png" alt="image-20240616235356246"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616235407324.png" alt="image-20240616235407324"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240616235426886.png" alt="image-20240616235426886"></p>
<h3 id="RDT1"><a href="#RDT1" class="headerlink" title="RDT1"></a>RDT1</h3><p>保证底层信道完全可靠，所以无需做可靠传输保障处理</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616235455451.png" alt="image-20240616235455451"></p>
<h3 id="RDT2"><a href="#RDT2" class="headerlink" title="RDT2"></a>RDT2</h3><p>信道可能发生错误，但不发送丢包，需要引入重传机制</p>
<p><img src="/2024/06/21/computer_network_course/image-20240616235525116.png" alt="image-20240616235525116"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617135412820.png" alt="image-20240617135412820"></p>
<p>传送等待模式</p>
<p>也就是说发送方如果收到正确ACK，发送下一个数据包；否则，收到错误ACK，重传上一个数据包</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617135729694.png" alt="image-20240617135729694"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617135817642.png" alt="image-20240617135817642"></p>
<p>重复ACK指的是这次收到的是ackno为0的，下次还是ackno为0，说明新传过来的校验和GG了，这时候就要重传1的数据包。</p>
<h3 id="RDT3"><a href="#RDT3" class="headerlink" title="RDT3"></a>RDT3</h3><p>信道既可能发生错误，也可能丢包</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617141001279.png" alt="image-20240617141001279"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617141913685.png" alt="image-20240617141913685"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617141040533.png" alt="image-20240617141040533"></p>
<p>只在收到ACK才发下一个包，因为只有2个序列号（停等操作）</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617141147763.png" alt="image-20240617141147763"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617141319092.png" alt="image-20240617141319092"></p>
<h3 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h3><p><img src="/2024/06/21/computer_network_course/image-20240617141347228.png" alt="image-20240617141347228"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617141424824.png" alt="image-20240617141424824"></p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><img src="/2024/06/21/computer_network_course/image-20240617142026623.png" alt="image-20240617142026623"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617142047615.png" alt="image-20240617142047615"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617142846912.png" alt="image-20240617142846912"></p>
<p>这里的dp指的应该是单向传播速度吧，下面那什么沙比公式别记了</p>
<h4 id="GBN后退N帧"><a href="#GBN后退N帧" class="headerlink" title="GBN后退N帧"></a>GBN后退N帧</h4><p><img src="/2024/06/21/computer_network_course/image-20240617143855886.png" alt="image-20240617143855886"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617143943076.png" alt="image-20240617143943076"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617144018370.png" alt="image-20240617144018370"></p>
<h4 id="SR选择重传"><a href="#SR选择重传" class="headerlink" title="SR选择重传"></a>SR选择重传</h4><p><img src="/2024/06/21/computer_network_course/image-20240617144127788.png" alt="image-20240617144127788"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617144143849.png" alt="image-20240617144143849"></p>
<p>值得注意的是跟TCP的可靠传输还是不一样的，ACK只针对单个分组，而非从xx到xx都ACK了</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617144332678.png" alt="image-20240617144332678"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617144543878.png" alt="image-20240617144543878"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617144649342.png" alt="image-20240617144649342"></p>
<p>确实，需要注意序号位数。。。</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617145235961.png" alt="image-20240617145235961"></p>
<p>这个是通过右上角那个图推出来的：</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617145249283.png" alt="image-20240617145249283"></p>
<p>这个就相当于Ws+Wr，Ws+Wr内的序号不能重复，所以需要&lt;=2^k。</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617145338385.png" alt="image-20240617145338385"></p>
<h2 id="多路访问控制-MAC-协议"><a href="#多路访问控制-MAC-协议" class="headerlink" title="多路访问控制(MAC)协议"></a>多路访问控制(MAC)协议</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>链路有两类：</p>
<ol>
<li><p>点对点</p>
<p>拨号、交换机和主机中间</p>
</li>
<li><p>广播链路（共享介质）</p>
<p>以太网总线、HFC上行、无线局域网</p>
</li>
</ol>
<p>第二种链路会<strong>单一共享广播信道</strong>，故而会产生结点传输<strong>冲突</strong>，故而需要MAC协议。</p>
<p>采用分布式算法决定结点如何、何时共享信道。</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617151255800.png" alt="image-20240617151255800"></p>
<p>三种类型</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617151320726.png" alt="image-20240617151320726"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617152947735.png" alt="image-20240617152947735"></p>
<h3 id="信道划分MAC协议"><a href="#信道划分MAC协议" class="headerlink" title="信道划分MAC协议"></a>信道划分MAC协议</h3><p><img src="/2024/06/21/computer_network_course/image-20240619213046037.png" alt="image-20240619213046037"></p>
<h4 id="TDMA"><a href="#TDMA" class="headerlink" title="TDMA"></a>TDMA</h4><p><img src="/2024/06/21/computer_network_course/image-20240617151356249.png" alt="image-20240617151356249"></p>
<h4 id="FDMA"><a href="#FDMA" class="headerlink" title="FDMA"></a>FDMA</h4><p><img src="/2024/06/21/computer_network_course/image-20240617151418660.png" alt="image-20240617151418660"></p>
<p>又是经典的分时VS分频，这个思想也是非常CS，套到OS调度上就是经典的并发和并行。</p>
<h3 id="随机访问MAC协议"><a href="#随机访问MAC协议" class="headerlink" title="随机访问MAC协议"></a>随机访问MAC协议</h3><p><img src="/2024/06/21/computer_network_course/image-20240619213059025.png" alt="image-20240619213059025"></p>
<p>没有实现的结点间协调，要发的时候就利用信道100%速率发送，故而需要定义如何检测和恢复冲突</p>
<h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><p><img src="/2024/06/21/computer_network_course/image-20240617152006883.png" alt="image-20240617152006883"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617152047676.png" alt="image-20240617152047676"></p>
<p>虽然感觉好像怪怪的这个算法</p>
<h4 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h4><p><img src="/2024/06/21/computer_network_course/image-20240617151640273.png" alt="image-20240617151640273"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617151944158.png" alt="image-20240617151944158"></p>
<h4 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h4><p><img src="/2024/06/21/computer_network_course/image-20240617152121248.png" alt="image-20240617152121248"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617152329788.png" alt="image-20240617152329788"></p>
<h5 id="坚持与非坚持"><a href="#坚持与非坚持" class="headerlink" title="坚持与非坚持"></a>坚持与非坚持</h5><p><img src="/2024/06/21/computer_network_course/image-20240617152838831.png" alt="image-20240617152838831"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617152419399.png" alt="image-20240617152419399"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617152445809.png" alt="image-20240617152445809"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617152551773.png" alt="image-20240617152551773"></p>
<h5 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h5><p><img src="/2024/06/21/computer_network_course/image-20240617152221946.png" alt="image-20240617152221946"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617153136999.png" alt="image-20240617153136999"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617153315952.png" alt="image-20240617153315952"></p>
<p>只要经过2t时间没有检测到碰撞，说明一定没发生碰撞</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617153442538.png" alt="image-20240617153442538"></p>
<p>希望在检测到碰撞时帧还没发完。按书上的理解是发送方无法检测到碰撞所以不会重发，可能是因为<strong>发送方在发送完数据后就不再监听</strong>。</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617153731821.png" alt="image-20240617153731821"></p>
<p>这里也就是带宽吧</p>
<h3 id="轮转访问MAC协议"><a href="#轮转访问MAC协议" class="headerlink" title="轮转访问MAC协议"></a>轮转访问MAC协议</h3><p>综合上述二者的优点</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617154353847.png" alt="image-20240617154353847"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617154402238.png" alt="image-20240617154402238"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617154414777.png" alt="image-20240617154414777"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617154442028.png" alt="image-20240617154442028"></p>
<h2 id="局域网技术"><a href="#局域网技术" class="headerlink" title="局域网技术"></a>局域网技术</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>注意48位、16进制表示</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617200332236.png" alt="image-20240617200332236"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617200448053.png" alt="image-20240617200448053"></p>
<p>MAC地址由IEEE统一管理分配，网卡生产商购买MAC地址空间<strong>（前24比特）</strong></p>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><h4 id="协议概述"><a href="#协议概述" class="headerlink" title="协议概述"></a>协议概述</h4><p>统治地位的有线LAN技术，造价低廉应用广泛</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617200602916.png" alt="image-20240617200602916"></p>
<p>确实，所以CSMA也是陈年老技术了</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617200834603.png" alt="image-20240617200834603"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617202113727.png" alt="image-20240617202113727"></p>
<h4 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h4><p><img src="/2024/06/21/computer_network_course/image-20240617202210793.png" alt="image-20240617202210793"></p>
<p>注意只在MAC一样才接受</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617202339307.png" alt="image-20240617202339307"></p>
<p>注意，这里PPT规定了最小帧长为64B，所以最小数据量为46B</p>
<h4 id="ETH标准"><a href="#ETH标准" class="headerlink" title="ETH标准"></a>ETH标准</h4><p><img src="/2024/06/21/computer_network_course/image-20240617202358145.png" alt="image-20240617202358145"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617202458531.png" alt="image-20240617202458531"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617202601001.png" alt="image-20240617202601001"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617203116637.png" alt="image-20240617203116637"></p>
<p>没看懂具体改了啥。。。</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617203133629.png" alt="image-20240617203133629"></p>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p><img src="/2024/06/21/computer_network_course/image-20240617203242041.png" alt="image-20240617203242041"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617203344888.png" alt="image-20240617203344888"></p>
<h5 id="交换表"><a href="#交换表" class="headerlink" title="交换表"></a>交换表</h5><p><img src="/2024/06/21/computer_network_course/image-20240617203440103.png" alt="image-20240617203440103"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617203454330.png" alt="image-20240617203454330"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617212316590.png" alt="image-20240617212316590"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617212336995.png" alt="image-20240617212336995"></p>
<h5 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h5><p><img src="/2024/06/21/computer_network_course/image-20240617212900812.png" alt="image-20240617212900812"></p>
<h4 id="集线器中继器交换机路由器"><a href="#集线器中继器交换机路由器" class="headerlink" title="集线器中继器交换机路由器"></a>集线器中继器交换机路由器</h4><p><strong>交换机可以隔绝冲突域，路由器可以隔绝广播域</strong></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617213052333.png" alt="image-20240617213052333"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617232544193.png" alt="image-20240617232544193"></p>
<blockquote>
<p>直通传输（Cut-through）是一种网络交换技术，用于描述数据包在网络设备（如交换机或路由器）中的传输方式。在直通传输模式下，数据包一旦开始被接收，就会立即开始传输到输出端口，而不必等待整个数据包被完全接收。这种方式可以减少数据包的传输延迟，提高网络性能</p>
<p>这个概念我忘了前面哪里有说。。TODO记得留意一下</p>
</blockquote>
<ol>
<li><strong>集线器（Hub）</strong>：<ul>
<li>集线器是一种基本的网络设备，用于连接多个设备到一个网络。</li>
<li>它在物理层（OSI模型的第一层）工作，不具备智能处理数据包的能力。</li>
<li>集线器将接收到的信号进行放大或再生，然后广播到所有其他端口，不管数据包的目的地是哪里。</li>
<li>这会导致所有连接到集线器的设备<strong>共享同一个冲突域和广播域</strong>。</li>
<li>集线器通常用于小型或成本敏感的网络环境。</li>
</ul>
</li>
<li><strong>中继器（Repeater）</strong>：<ul>
<li>中继器用于扩展网络的距离，它接收信号，重新生成该信号，然后将其发送到网络的下一个部分。</li>
<li>它同样在物理层工作，不进行任何数据包的智能处理。</li>
<li>中继器可以是无源的，仅放大信号，或有源的，提供信号再生和放大。</li>
<li>中继器不区分数据包的目的地，它简单地复制信号到所有连接的设备。</li>
<li>中继器通常用于连接两个网络段或扩展以太网电缆的长度。</li>
</ul>
</li>
<li><strong>交换机（Switch）</strong>：<ul>
<li>交换机是一种更高级的网络设备，用于连接多个设备并管理数据包的传输。</li>
<li>它在数据链路层（OSI模型的第二层）工作，具有智能处理能力，可以识别数据包的目的地。</li>
<li>交换机使用MAC地址表来确定数据包的转发路径，只将数据包发送到正确的端口，而不是所有端口。</li>
<li>这使得每个交换机端口都是一个独立的冲突域，减少了冲突的可能性，并提高了网络效率。</li>
<li>交换机还支持全双工通信，允许同时发送和接收数据，进一步提高了性能。</li>
<li>交换机通常用于构建更复杂和高效的网络结构。</li>
</ul>
</li>
</ol>
<h2 id="VLANs"><a href="#VLANs" class="headerlink" title="VLANs"></a>VLANs</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><img src="/2024/06/21/computer_network_course/image-20240617221048575.png" alt="image-20240617221048575"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617221202352.png" alt="image-20240617221202352"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617221226966.png" alt="image-20240617221226966"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617221245948.png" alt="image-20240617221245948"></p>
<h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p><img src="/2024/06/21/computer_network_course/image-20240617221400830.png" alt="image-20240617221400830"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617221419637.png" alt="image-20240617221419637"></p>
<h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><ul>
<li><strong>PPP</strong>: 是一种点对点的链路层协议，主要用于直接连接两个网络节点的链路层。PPP广泛用于拨号和专线连接，如通过电话线、光纤或无线链路连接的网络。</li>
<li><strong>Ethernet</strong>: 是一种局域网技术，用于在局域网内连接多个设备。它定义了包括物理层和数据链路层的规范。</li>
</ul>
<p>PPP协议本身不使用MAC地址。PPP协议在链路层工作，但它是为点对点连接设计的，不涉及广播或多播，因此不需要使用MAC地址来识别多个设备。PPP连接的每一端都有一个唯一的标识符，通常是通过配置或协商得到的，而不是通过MAC地址。</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617222436513.png" alt="image-20240617222436513"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617222506820.png" alt="image-20240617222506820"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617222547789.png" alt="image-20240617222547789"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617222601401.png" alt="image-20240617222601401"></p>
<h3 id="帧格式-1"><a href="#帧格式-1" class="headerlink" title="帧格式"></a>帧格式</h3><p><img src="/2024/06/21/computer_network_course/image-20240617222627210.png" alt="image-20240617222627210"></p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p><img src="/2024/06/21/computer_network_course/image-20240617223701607.png" alt="image-20240617223701607"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617223711957.png" alt="image-20240617223711957"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617223752787.png" alt="image-20240617223752787"></p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><img src="/2024/06/21/computer_network_course/image-20240617223937417.png" alt="image-20240617223937417"></p>
<h3 id="PPPoE"><a href="#PPPoE" class="headerlink" title="PPPoE"></a>PPPoE</h3><p><img src="/2024/06/21/computer_network_course/image-20240617224027232.png" alt="image-20240617224027232"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617224314169.png" alt="image-20240617224314169"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617224447644.png" alt="image-20240617224447644"></p>
<p>反正就是说新增两个设备，设备之间用PPP协议通信，设备和主机间用ETH协议通信</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617224514776.png" alt="image-20240617224514776"></p>
<p>这个就是去掉pppoe client，使得主机和服务器直接PPP通信</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617224537191.png" alt="image-20240617224537191"></p>
<h2 id="链路虚拟化"><a href="#链路虚拟化" class="headerlink" title="链路虚拟化"></a>链路虚拟化</h2><p>反正感觉看起来就是网络之网络，就是说网络内部独立的，网络之间就是网级层</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617224554966.png" alt="image-20240617224554966"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617224605793.png" alt="image-20240617224605793"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617224655233.png" alt="image-20240617224655233"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617224725975.png" alt="image-20240617224725975"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617224735292.png" alt="image-20240617224735292"></p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>每个主机和路由器都运行网络层协议，路由器检查所有穿越他的IP数据报头部</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617224924311.png" alt="image-20240617224924311"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617224947404.png" alt="image-20240617224947404"></p>
<p>注意连接建立原来也算是网络层概念。。。不过只能说直观上确实是这样的</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617225048181.png" alt="image-20240617225048181"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617225112357.png" alt="image-20240617225112357"></p>
<p>现在感觉就对应着第一种无连接的数据报网络了</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>分组在路由器丢失or排队</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617225156251.png" alt="image-20240617225156251"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617225221714.png" alt="image-20240617225221714"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617225236818.png" alt="image-20240617225236818"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617225249263.png" alt="image-20240617225249263"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617225256920.png" alt="image-20240617225256920"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617225325749.png" alt="image-20240617225325749"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617225338894.png" alt="image-20240617225338894"></p>
<h4 id="ATM-ABR拥塞控制"><a href="#ATM-ABR拥塞控制" class="headerlink" title="ATM ABR拥塞控制"></a>ATM ABR拥塞控制</h4><p><img src="/2024/06/21/computer_network_course/image-20240617225423505.png" alt="image-20240617225423505"></p>
<p>右边那个就有点像TCP了，或者说TCP也能算是二者结合吧</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617230202667.png" alt="image-20240617230202667"></p>
<h2 id="虚电路网络与数据报网络"><a href="#虚电路网络与数据报网络" class="headerlink" title="虚电路网络与数据报网络"></a>虚电路网络与数据报网络</h2><p><img src="/2024/06/21/computer_network_course/image-20240617225112357.png" alt="image-20240617225112357"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617230323253.png" alt="image-20240617230323253"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617230943325.png" alt="image-20240617230943325"></p>
<h3 id="虚电路网络-VC"><a href="#虚电路网络-VC" class="headerlink" title="虚电路网络(VC)"></a>虚电路网络(VC)</h3><p><img src="/2024/06/21/computer_network_course/image-20240617230344903.png" alt="image-20240617230344903"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617230427699.png" alt="image-20240617230427699"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617230526121.png" alt="image-20240617230526121"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617230544090.png" alt="image-20240617230544090"></p>
<p>这种就显得太固定了，然后需要用的路由器也比较多</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617230621209.png" alt="image-20240617230621209"></p>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><p><img src="/2024/06/21/computer_network_course/image-20240617230635080.png" alt="image-20240617230635080"></p>
<h4 id="数据转发表"><a href="#数据转发表" class="headerlink" title="数据转发表"></a>数据转发表</h4><p><img src="/2024/06/21/computer_network_course/image-20240617230700651.png" alt="image-20240617230700651"></p>
<p>同时为了防止表项过多，会进行聚合：</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617230724221.png" alt="image-20240617230724221"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617230739847.png" alt="image-20240617230739847"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617230822290.png" alt="image-20240617230822290"></p>
<p>这点在化简路由表时很有用</p>
<h2 id="路由器体系结构"><a href="#路由器体系结构" class="headerlink" title="路由器体系结构"></a>路由器体系结构</h2><p><img src="/2024/06/21/computer_network_course/image-20240617231712939.png" alt="image-20240617231712939"></p>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p><img src="/2024/06/21/computer_network_course/image-20240617231800325.png" alt="image-20240617231800325"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617231945435.png" alt="image-20240617231945435"></p>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3><p><img src="/2024/06/21/computer_network_course/image-20240617232003411.png" alt="image-20240617232003411"></p>
<h4 id="经内存交换"><a href="#经内存交换" class="headerlink" title="经内存交换"></a>经内存交换</h4><p><img src="/2024/06/21/computer_network_course/image-20240617232047786.png" alt="image-20240617232047786"></p>
<h4 id="经总线"><a href="#经总线" class="headerlink" title="经总线"></a>经总线</h4><p><img src="/2024/06/21/computer_network_course/image-20240617232112865.png" alt="image-20240617232112865"></p>
<h4 id="经网络"><a href="#经网络" class="headerlink" title="经网络"></a>经网络</h4><p><img src="/2024/06/21/computer_network_course/image-20240617232136619.png" alt="image-20240617232136619"></p>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p><img src="/2024/06/21/computer_network_course/image-20240617232208920.png" alt="image-20240617232208920"></p>
<p>草，果然每个需要排队的地方必有调度算法。。。不过我感觉路由的话FIFO不就行了吗，也不好说，可能因为目的端口不同？</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617232314481.png" alt="image-20240617232314481"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617232323289.png" alt="image-20240617232323289"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617232342886.png" alt="image-20240617232342886"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617232352272.png" alt="image-20240617232352272"></p>
<p>多级队列是吧</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617232418578.png" alt="image-20240617232418578"></p>
<p>感觉相比于FIFO，相当于不是在满的时候马上出队然后丢弃，而是先滞留内存了</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617232502788.png" alt="image-20240617232502788"></p>
<p>感觉应该就是优先级越高δ服务量越高之类的吧</p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p><img src="/2024/06/21/computer_network_course/image-20240617232729411.png" alt="image-20240617232729411"></p>
<h3 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h3><p><img src="/2024/06/21/computer_network_course/image-20240617232837062.png" alt="image-20240617232837062"></p>
<ol>
<li><p>版本号</p>
<p>4代表IPv4,6代表v6</p>
</li>
<li><p>首部长度</p>
<p>IP分组首部长度，<strong>以4字节为单位</strong></p>
<p>如，=5代表IP首部长度为20字节</p>
</li>
<li><p>服务类型（TOS）</p>
<p>指示期望获得哪种类型的服务</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233253384.png" alt="image-20240617233253384"></p>
</li>
<li><p>总长度</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233333197.png" alt="image-20240617233333197"></p>
</li>
<li><p>标识(ID)</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233739506.png" alt="image-20240617233739506"></p>
<p>就是IP分组编号。值得注意的是，所有分片的标识都是一样的</p>
</li>
<li><p>标志位</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233758145.png" alt="image-20240617233758145"></p>
</li>
<li><p>片偏移</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233824278.png" alt="image-20240617233824278"></p>
</li>
<li><p>生存时间(TTL)</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233350192.png" alt="image-20240617233350192"></p>
</li>
<li><p>协议</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233401743.png" alt="image-20240617233401743"></p>
</li>
<li><p>首部校验和</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233417504.png" alt="image-20240617233417504"></p>
</li>
<li><p>地址</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233429113.png" alt="image-20240617233429113"></p>
</li>
<li><p>选项</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233441371.png" alt="image-20240617233441371"></p>
</li>
<li><p>填充</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233501863.png" alt="image-20240617233501863"></p>
<p>注意IP报文是4字节对齐的</p>
</li>
</ol>
<h3 id="MTU与分片"><a href="#MTU与分片" class="headerlink" title="MTU与分片"></a>MTU与分片</h3><p><img src="/2024/06/21/computer_network_course/image-20240617233641741.png" alt="image-20240617233641741"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233706280.png" alt="image-20240617233706280"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617233946734.png" alt="image-20240617233946734"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617234011068.png" alt="image-20240617234011068"></p>
<h3 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p><img src="/2024/06/21/computer_network_course/image-20240617234622985.png" alt="image-20240617234622985"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617234902380.png" alt="image-20240617234902380"></p>
<p><img src="/2024/06/21/computer_network_course/10c942a1deb2f67d629fd8c9814df1a0.png" alt="10c942a1deb2f67d629fd8c9814df1a0"></p>
<h4 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h4><p><img src="/2024/06/21/computer_network_course/image-20240617234927264.png" alt="image-20240617234927264"></p>
<p>也就是只有交换机什么的</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618153018611.png" alt="image-20240618153018611"></p>
<p><a href="https://blog.csdn.net/Initial_Mind/article/details/125473927">https://blog.csdn.net/Initial_Mind/article/details/125473927</a></p>
<p>这个使用哈夫曼树的理解非常有意思。</p>
<h4 id="分类和特殊地址"><a href="#分类和特殊地址" class="headerlink" title="分类和特殊地址"></a>分类和特殊地址</h4><p><img src="/2024/06/21/computer_network_course/image-20240617235038774.png" alt="image-20240617235038774"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617235212716.png" alt="image-20240617235212716"></p>
<p>注意全0可以作为源地址</p>
<p><img src="/2024/06/21/computer_network_course/image-20240617235331287.png" alt="image-20240617235331287"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617235322399.png" alt="image-20240617235322399"></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p><img src="/2024/06/21/computer_network_course/image-20240617235357868.png" alt="image-20240617235357868"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617235408591.png" alt="image-20240617235408591"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617235441174.png" alt="image-20240617235441174"></p>
<h4 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h4><p><img src="/2024/06/21/computer_network_course/image-20240617235609747.png" alt="image-20240617235609747"></p>
<p>算是一种表示方法和思想吧</p>
<h5 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h5><p><img src="/2024/06/21/computer_network_course/image-20240617235628961.png" alt="image-20240617235628961"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617235637974.png" alt="image-20240617235637974"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617235704926.png" alt="image-20240617235704926"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617235712983.png" alt="image-20240617235712983"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240617235731528.png" alt="image-20240617235731528"></p>
<p>一个子网属于一个广播域是吧</p>
<p>刚刚在想为什么不同子网一定要路由器不能直接交换机MAC。。这其实就是为什么不能只有MAC没有IP的问题。感觉估计还是因为IP地址比较好表示吧</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618000347600.png" alt="image-20240618000347600"></p>
<p>主要MAC是不变的，很多情况下可变IP大有作用，所以很麻烦</p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h4><p><img src="/2024/06/21/computer_network_course/image-20240618150425487.png" alt="image-20240618150425487"></p>
<p>禁止分片的话是怎么处理MTU的呢。。。</p>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p><img src="/2024/06/21/computer_network_course/image-20240618150529656.png" alt="image-20240618150529656"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618150710104.png" alt="image-20240618150710104"></p>
<p>128位地址，每个冒号分割16位，也即四位十六进制</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618150821249.png" alt="image-20240618150821249"></p>
<p>注意，没有广播的概念了</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618151100637.png" alt="image-20240618151100637"></p>
<p><strong>多播=组播</strong></p>
<p>IPv6没有传统意义上的广播地址，这是因为IPv6采用了一种不同的方法来处理广播和多播消息。</p>
<p>在IPv4中，广播地址允许一个网络段内的所有主机接收到发送到这个地址的数据包。IPv6中，广播的概念被多播地址所取代。多播地址允许向一组特定的主机发送消息，这些主机都对特定的多播组感兴趣。</p>
<p>IPv6的多播地址范围从 <code>FF00::/8</code> 开始，这意味着所有以 “FF” 开头的IPv6地址都是多播地址。多播地址进一步分为几个范围，包括：</p>
<ul>
<li>节点本地多播地址：<code>FF01::/16</code></li>
<li>链路本地多播地址：<code>FF02::/16</code></li>
<li>点对点多播地址：<code>FF05::/16</code></li>
<li>组播地址：<code>FF08::/16</code> 到 <code>FF0F::/16</code></li>
</ul>
<p>链路本地多播地址特别类似于IPv4中的广播地址，因为它仅在同一链路上有效，并且所有在同一链路上的设备都会接收到发送到这个地址的数据包。</p>
<p>总的来说，IPv6使用多播地址来实现广播的功能，但它们提供了更多的灵活性和控制能力。</p>
<ol>
<li><strong>组播（Multicast）</strong>：<ul>
<li>组播是一种将数据包发送到一组特定主机的方法，这些主机都对特定的数据流或服务感兴趣。</li>
<li>组播地址是D类地址（IPv4）或具有特定前缀的地址（IPv6）。</li>
<li>组播使用特定的组播地址，所有加入该组播组的主机都会接收到发送到该地址的数据包。</li>
<li>组播流量是优化的，网络设备如路由器和交换机使用组播转发树来确保数据包只沿着必要的路径传播，避免不必要的复制和传输。</li>
</ul>
</li>
<li><strong>任意播（Anycast）</strong>：<ul>
<li>任意播是一种将数据包发送到最近的一个服务器或主机的方法，这些服务器或主机拥有相同的IP地址。</li>
<li>任意播地址通常用于提供高可用性和负载均衡，例如DNS服务。</li>
<li>任意播地址在逻辑上是单播地址，但是可以分配给多个接口，通常是在不同的地理位置。</li>
<li>当数据包发送到任意播地址时，网络会根据路由度量（如跳数、延迟或路径成本）选择最近的接口来接收该数据包。</li>
</ul>
</li>
</ol>
<h4 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h4><p><img src="/2024/06/21/computer_network_course/image-20240618151201617.png" alt="image-20240618151201617"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618151318717.png" alt="image-20240618151318717"></p>
<h2 id="IP相关协议"><a href="#IP相关协议" class="headerlink" title="IP相关协议"></a>IP相关协议</h2><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p><img src="/2024/06/21/computer_network_course/image-20240618161506572.png" alt="image-20240618161506572"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618161551482.png" alt="image-20240618161551482"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618161621830.png" alt="image-20240618161621830"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618161654416.png" alt="image-20240618161654416"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618161747765.png" alt="image-20240618161747765"></p>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p><img src="/2024/06/21/computer_network_course/image-20240618162021930.png" alt="image-20240618162021930"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618162036966.png" alt="image-20240618162036966"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618162109115.png" alt="image-20240618162109115"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618162126479.png" alt="image-20240618162126479"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618162155300.png" alt="image-20240618162155300"></p>
<p>这八字节应该是传输层数据报前八字节，包含端口号</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618162325095.png" alt="image-20240618162325095"></p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p><img src="/2024/06/21/computer_network_course/image-20240618162505592.png" alt="image-20240618162505592"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618162514274.png" alt="image-20240618162514274"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618162642055.png" alt="image-20240618162642055"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618162704324.png" alt="image-20240618162704324"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618162716676.png" alt="image-20240618162716676"></p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p><img src="/2024/06/21/computer_network_course/image-20240618162746811.png" alt="image-20240618162746811"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618163043373.png" alt="image-20240618163043373"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618163104196.png" alt="image-20240618163104196"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618163117011.png" alt="image-20240618163117011"></p>
<p>注意收发都会修改</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618163201299.png" alt="image-20240618163201299"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618163225383.png" alt="image-20240618163225383"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618163238551.png" alt="image-20240618163238551"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618163308591.png" alt="image-20240618163308591"></p>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p><img src="/2024/06/21/computer_network_course/image-20240618163548086.png" alt="image-20240618163548086"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618163557037.png" alt="image-20240618163557037"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618163604517.png" alt="image-20240618163604517"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618163614834.png" alt="image-20240618163614834"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618164719201.png" alt="image-20240618164719201"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618164855676.png" alt="image-20240618164855676"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618164905484.png" alt="image-20240618164905484"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618164913493.png" alt="image-20240618164913493"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618164921074.png" alt="image-20240618164921074"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618164929713.png" alt="image-20240618164929713"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618164937957.png" alt="image-20240618164937957"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618164945815.png" alt="image-20240618164945815"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618164953974.png" alt="image-20240618164953974"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618165000559.png" alt="image-20240618165000559"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618165007411.png" alt="image-20240618165007411"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618165015153.png" alt="image-20240618165015153"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618165022338.png" alt="image-20240618165022338"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618165030566.png" alt="image-20240618165030566"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618165039247.png" alt="image-20240618165039247"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618165046772.png" alt="image-20240618165046772"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618165102352.png" alt="image-20240618165102352"></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2024/06/21/computer_network_course/image-20240618165548450.png" alt="image-20240618165548450"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618165557644.png" alt="image-20240618165557644"></p>
<h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><p><img src="/2024/06/21/computer_network_course/image-20240618192003082.png" alt="image-20240618192003082"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192014118.png" alt="image-20240618192014118"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192033186.png" alt="image-20240618192033186"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192115751.png" alt="image-20240618192115751"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192154023.png" alt="image-20240618192154023"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192215676.png" alt="image-20240618192215676"></p>
<h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><p><img src="/2024/06/21/computer_network_course/image-20240620205538807.png" alt="image-20240620205538807"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618193032157.png" alt="image-20240618193032157"></p>
<h3 id="AS内部路由"><a href="#AS内部路由" class="headerlink" title="AS内部路由"></a>AS内部路由</h3><p><img src="/2024/06/21/computer_network_course/image-20240618192238854.png" alt="image-20240618192238854"></p>
<p>OSFP向系统所有路由器泛洪发送邻近路由器链路状态，当链路状态变化或者固定时间间隔发送消息</p>
<h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>分布式的基于距离向量的路由选择</p>
<p>RIP和相邻路由器以固定时间间隔交换自己的路由表信息</p>
<p>基于UDP，有更新报文和请求报文</p>
<p>不支持认证，UDP不可靠；使用IPv6</p>
<ol>
<li>和哪些路由器交换信息？仅和<strong>相邻</strong>路由器交换信息</li>
<li>交换什么信息？当前本路由器的<strong>路由表</strong></li>
<li>在什么时候交换信息？按<strong>固定的时间间隔</strong>交换路由信息</li>
</ol>
<p><img src="/2024/06/21/computer_network_course/image-20240620200047975.png" alt="image-20240620200047975"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240620200358715.png" alt="image-20240620200358715"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240620201335773.png" alt="image-20240620201335773"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192323279.png" alt="image-20240618192323279"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192406794.png" alt="image-20240618192406794"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192417364.png" alt="image-20240618192417364"></p>
<h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p><img src="/2024/06/21/computer_network_course/image-20240620201616033.png" alt="image-20240620201616033"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240620204424274.png" alt="image-20240620204424274"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240620204628967.png" alt="image-20240620204628967"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240620205022504.png" alt="image-20240620205022504"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192644100.png" alt="image-20240618192644100"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192709385.png" alt="image-20240618192709385"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192728098.png" alt="image-20240618192728098"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192738654.png" alt="image-20240618192738654"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192753724.png" alt="image-20240618192753724"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192814736.png" alt="image-20240618192814736"></p>
<h3 id="AS间路由协议-BGP"><a href="#AS间路由协议-BGP" class="headerlink" title="AS间路由协议:BGP"></a>AS间路由协议:BGP</h3><p><img src="/2024/06/21/computer_network_course/image-20240620205222356.png" alt="image-20240620205222356"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240620205412346.png" alt="image-20240620205412346"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240620205446030.png" alt="image-20240620205446030"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240620205508740.png" alt="image-20240620205508740"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192844369.png" alt="image-20240618192844369"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192917775.png" alt="image-20240618192917775"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192926730.png" alt="image-20240618192926730"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192934573.png" alt="image-20240618192934573"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192949106.png" alt="image-20240618192949106"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618192957126.png" alt="image-20240618192957126"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618193004081.png" alt="image-20240618193004081"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618193017397.png" alt="image-20240618193017397"></p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层服务"><a href="#传输层服务" class="headerlink" title="传输层服务"></a>传输层服务</h2><p><img src="/2024/06/21/computer_network_course/image-20240618193450070.png" alt="image-20240618193450070"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618193716070.png" alt="image-20240618193716070"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618193726277.png" alt="image-20240618193726277"></p>
<p>注意，<strong>均不保证延迟和带宽</strong>？</p>
<h2 id="传输层多路复用-分用"><a href="#传输层多路复用-分用" class="headerlink" title="传输层多路复用/分用"></a>传输层多路复用/分用</h2><p><img src="/2024/06/21/computer_network_course/image-20240618194838864.png" alt="image-20240618194838864"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618194858354.png" alt="image-20240618194858354"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618201625231.png" alt="image-20240618201625231"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618201710169.png" alt="image-20240618201710169"></p>
<p>断句：传输层 无连接 分用</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618201747119.png" alt="image-20240618201747119"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202105750.png" alt="image-20240618202105750"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202313891.png" alt="image-20240618202313891"></p>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p><img src="/2024/06/21/computer_network_course/image-20240618202341271.png" alt="image-20240618202341271"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202350669.png" alt="image-20240618202350669"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202431694.png" alt="image-20240618202431694"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202440304.png" alt="image-20240618202440304"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202545388.png" alt="image-20240618202545388"></p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><p><img src="/2024/06/21/computer_network_course/image-20240618202614351.png" alt="image-20240618202614351"></p>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p><img src="/2024/06/21/computer_network_course/image-20240618202625592.png" alt="image-20240618202625592"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202637730.png" alt="image-20240618202637730"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618204307775.png" alt="image-20240618204307775"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202820008.png" alt="image-20240618202820008"></p>
<p>这点跟IP报文还是一样的</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202832949.png" alt="image-20240618202832949"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202841833.png" alt="image-20240618202841833"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202858749.png" alt="image-20240618202858749"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202906257.png" alt="image-20240618202906257"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618202913210.png" alt="image-20240618202913210"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618203606879.png" alt="image-20240618203606879"></p>
<p>最大段长度（Maximum Segment Size，MSS）是TCP（传输控制协议）中的一个重要参数，它定义了TCP段的最大有效载荷大小。MSS不包括TCP头部，只计算数据部分的大小。MSS的主要作用是为了避免在网络传输过程中出现数据包的分片（fragmentation），因为某些网络层（如以太网）对传输的数据包大小有限制。</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618203814711.png" alt="image-20240618203814711"></p>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p><img src="/2024/06/21/computer_network_course/image-20240618204341149.png" alt="image-20240618204341149"></p>
<p>注意，<strong>收到重复ACK也会重传？</strong></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618204548608.png" alt="image-20240618204548608"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618204614075.png" alt="image-20240618204614075"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618210136182.png" alt="image-20240618210136182"></p>
<p>值得注意的是，TCP应该只重发最早没被确认的段，也即只对他启动计时器？所以这里收到ACK重启定时器，并且是之前从未确认过的，说明就是它检测的那个段收到了确认，所以需要。。。</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618210301720.png" alt="image-20240618210301720"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618210316345.png" alt="image-20240618210316345"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618210323455.png" alt="image-20240618210323455"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618210539722.png" alt="image-20240618210539722"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618210618952.png" alt="image-20240618210618952"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618210628800.png" alt="image-20240618210628800"></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><img src="/2024/06/21/computer_network_course/image-20240618211534446.png" alt="image-20240618211534446"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618211549677.png" alt="image-20240618211549677"></p>
<p><strong>处理零窗口探测</strong>：在某些情况下，发送方可能会使用零窗口探测（Zero Window Probe）机制，即发送一个小的TCP段（通常只有1字节的数据），以询问接收方是否可以接收更多的数据。如果接收方仍然无法接收数据，它会再次发送一个窗口大小为0的确认（ACK）。</p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p><img src="/2024/06/21/computer_network_course/image-20240618211806133.png" alt="image-20240618211806133"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618211823684.png" alt="image-20240618211823684"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618211854530.png" alt="image-20240618211854530"></p>
<p>server直接关闭，client需要等待</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618211911581.png" alt="image-20240618211911581"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618211922483.png" alt="image-20240618211922483"></p>
<h3 id="拥塞控制-1"><a href="#拥塞控制-1" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p><img src="/2024/06/21/computer_network_course/image-20240619194551482.png" alt="image-20240619194551482"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618212439358.png" alt="image-20240618212439358"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618213120626.png" alt="image-20240618213120626"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618213209314.png" alt="image-20240618213209314"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618213220412.png" alt="image-20240618213220412"></p>
<p>就是说又会翻倍又会加一</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618213240899.png" alt="image-20240618213240899"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618213318352.png" alt="image-20240618213318352"></p>
<p>就是说会动态随着丢失事件调整慢启动的阈值</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618213430806.png" alt="image-20240618213430806"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618214156127.png" alt="image-20240618214156127"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618214206324.png" alt="image-20240618214206324"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618214217979.png" alt="image-20240618214217979"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619194917186.png" alt="image-20240619194917186"></p>
<p>一收到确认就马上翻倍</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619195047477.png" alt="image-20240619195047477"></p>
<h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><p><img src="/2024/06/21/computer_network_course/image-20240618214406004.png" alt="image-20240618214406004"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618214428764.png" alt="image-20240618214428764"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618214436967.png" alt="image-20240618214436967"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618215258277.png" alt="image-20240618215258277"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618215305709.png" alt="image-20240618215305709"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618215316682.png" alt="image-20240618215316682"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618215324148.png" alt="image-20240618215324148"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618215411254.png" alt="image-20240618215411254"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618215418322.png" alt="image-20240618215418322"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618215425559.png" alt="image-20240618215425559"></p>
<h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p><img src="/2024/06/21/computer_network_course/image-20240618215441930.png" alt="image-20240618215441930"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618215454248.png" alt="image-20240618215454248"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618215523827.png" alt="image-20240618215523827"></p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="网络应用体系结构"><a href="#网络应用体系结构" class="headerlink" title="网络应用体系结构"></a>网络应用体系结构</h2><p><img src="/2024/06/21/computer_network_course/image-20240618220317520.png" alt="image-20240618220317520"></p>
<h3 id="CS结构"><a href="#CS结构" class="headerlink" title="CS结构"></a>CS结构</h3><p><img src="/2024/06/21/computer_network_course/image-20240618220434549.png" alt="image-20240618220434549"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618220517328.png" alt="image-20240618220517328"></p>
<h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p><img src="/2024/06/21/computer_network_course/image-20240618220534023.png" alt="image-20240618220534023"></p>
<h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><p><img src="/2024/06/21/computer_network_course/image-20240618220602439.png" alt="image-20240618220602439"></p>
<h2 id="网络应用通信原理"><a href="#网络应用通信原理" class="headerlink" title="网络应用通信原理"></a>网络应用通信原理</h2><p><img src="/2024/06/21/computer_network_course/image-20240618220639660.png" alt="image-20240618220639660"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618220720588.png" alt="image-20240618220720588"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618220738943.png" alt="image-20240618220738943"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221057603.png" alt="image-20240618221057603"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221236135.png" alt="image-20240618221236135"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221248379.png" alt="image-20240618221248379"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221257061.png" alt="image-20240618221257061"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221349342.png" alt="image-20240618221349342"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221436878.png" alt="image-20240618221436878"></p>
<h2 id="域名解析DNS"><a href="#域名解析DNS" class="headerlink" title="域名解析DNS"></a>域名解析DNS</h2><p><img src="/2024/06/21/computer_network_course/image-20240618221749782.png" alt="image-20240618221749782"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221815201.png" alt="image-20240618221815201"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221829595.png" alt="image-20240618221829595"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221843336.png" alt="image-20240618221843336"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221901172.png" alt="image-20240618221901172"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221926589.png" alt="image-20240618221926589"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618221944449.png" alt="image-20240618221944449"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618222038803.png" alt="image-20240618222038803"></p>
<p>注意两种查询方法</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618222131272.png" alt="image-20240618222131272"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618222214261.png" alt="image-20240618222214261"></p>
<p>这个没太看懂。。。</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618222233927.png" alt="image-20240618222233927"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618222245052.png" alt="image-20240618222245052"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618222302715.png" alt="image-20240618222302715"></p>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p><img src="/2024/06/21/computer_network_course/image-20240618222444161.png" alt="image-20240618222444161"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618222600012.png" alt="image-20240618222600012"></p>
<p>TODO 没看懂跟什么带外传送有关系，，，</p>
<p>带外传送（Out-of-Band, OOB）是一种数据传输机制，允许在正常的数据通信通道之外发送紧急或高优先级的信号或数据</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618222741470.png" alt="image-20240618222741470"></p>
<h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><p><img src="/2024/06/21/computer_network_course/image-20240618233741098.png" alt="image-20240618233741098"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618233847057.png" alt="image-20240618233847057"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618233933077.png" alt="image-20240618233933077"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618234144230.png" alt="image-20240618234144230"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618234155432.png" alt="image-20240618234155432"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618234350183.png" alt="image-20240618234350183"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618234400615.png" alt="image-20240618234400615"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618234416410.png" alt="image-20240618234416410"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618234438812.png" alt="image-20240618234438812"></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h3><p>CS结构</p>
<p>TCP，无状态</p>
<p>消息类型：请求和响应</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618235544921.png" alt="image-20240618235544921"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618235641463.png" alt="image-20240618235641463"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240618235657924.png" alt="image-20240618235657924"></p>
<p>方法POST，GET</p>
<p><img src="/2024/06/21/computer_network_course/image-20240618235629851.png" alt="image-20240618235629851"></p>
<h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><ol>
<li><p>一个TCP一个对象，非持久性连接（默认）</p>
</li>
<li><p>过程</p>
<ol>
<li>TCP连接请求</li>
<li>TCP建立连接</li>
<li>发送HTTP请求</li>
<li>接收并响应</li>
<li>为每个对象重复上述过程</li>
</ol>
</li>
<li><p>时间分析</p>
<p>每个对象需要2RTT</p>
</li>
<li><p>并行连接</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619000049410.png" alt="image-20240619000049410"></p>
<p>需要4个RTT（2个for WEB RTT，2个for 其他对象）</p>
</li>
</ol>
<h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><ol>
<li><p>持久连接（默认选项）</p>
<p>3个RTT（2个for WEB RTT，1个for 其他对象）</p>
</li>
</ol>
<p><img src="/2024/06/21/computer_network_course/image-20240619000552227.png" alt="image-20240619000552227"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619000205953.png" alt="image-20240619000205953"></p>
<ol start="2">
<li>调度问题</li>
</ol>
<p><img src="/2024/06/21/computer_network_course/image-20240619000902686.png" alt="image-20240619000902686"></p>
<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p><img src="/2024/06/21/computer_network_course/image-20240619000942458.png" alt="image-20240619000942458"></p>
<h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><p>QUIC</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619001800702.png" alt="image-20240619001800702"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619001901149.png" alt="image-20240619001901149"></p>
<h3 id="WEB缓存"><a href="#WEB缓存" class="headerlink" title="WEB缓存"></a>WEB缓存</h3><p><img src="/2024/06/21/computer_network_course/image-20240619002002256.png" alt="image-20240619002002256"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619002022497.png" alt="image-20240619002022497"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619002628777.png" alt="image-20240619002628777"></p>
<h3 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h3><p><img src="/2024/06/21/computer_network_course/image-20240619002747068.png" alt="image-20240619002747068"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619002756641.png" alt="image-20240619002756641"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619002811422.png" alt="image-20240619002811422"></p>
<h3 id="VS-SMTP"><a href="#VS-SMTP" class="headerlink" title="VS SMTP"></a>VS SMTP</h3><p><img src="/2024/06/21/computer_network_course/image-20240619003018034.png" alt="image-20240619003018034"></p>
<h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><p>没有服务器</p>
<h3 id="文件分发"><a href="#文件分发" class="headerlink" title="文件分发"></a>文件分发</h3><p><img src="/2024/06/21/computer_network_course/image-20240619003330317.png" alt="image-20240619003330317"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619003600452.png" alt="image-20240619003600452"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619003757604.png" alt="image-20240619003757604"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619003808852.png" alt="image-20240619003808852"></p>
<h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p><img src="/2024/06/21/computer_network_course/image-20240619003902008.png" alt="image-20240619003902008"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619003933827.png" alt="image-20240619003933827"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619003945397.png" alt="image-20240619003945397"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004006809.png" alt="image-20240619004006809"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004024449.png" alt="image-20240619004024449"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004033179.png" alt="image-20240619004033179"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004101029.png" alt="image-20240619004101029"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004110999.png" alt="image-20240619004110999"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004118612.png" alt="image-20240619004118612"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004127628.png" alt="image-20240619004127628"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004136394.png" alt="image-20240619004136394"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004144892.png" alt="image-20240619004144892"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004153800.png" alt="image-20240619004153800"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004201501.png" alt="image-20240619004201501"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004229422.png" alt="image-20240619004229422"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004241426.png" alt="image-20240619004241426"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004253899.png" alt="image-20240619004253899"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004312024.png" alt="image-20240619004312024"></p>
<h1 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h1><h2 id="无线与移动网络概述"><a href="#无线与移动网络概述" class="headerlink" title="无线与移动网络概述"></a>无线与移动网络概述</h2><ol>
<li><p>无线</p>
<p>通过无线链路进行通信</p>
</li>
<li><p>移动</p>
<p>处理改变网络接入点的移动用户</p>
</li>
</ol>
<p>无线网络的要素</p>
<ol>
<li><p>无线主机</p>
</li>
<li><p>基站</p>
<p>中继，通常连接到有线网络，负责区域内有线x无线通信</p>
</li>
<li><p>无线链路</p>
<p>使用MAC（多路访问控制）协议协调</p>
</li>
</ol>
<p>无线网络模式</p>
<ol>
<li><p>基础设施模式</p>
<p>基站将移动主机连接到有线网络</p>
<p>移动主机不通信</p>
</li>
<li><p>自组织网络模式  ad hoc mode</p>
<p>无基站</p>
<p>只能连接到无线链路范围其他结点</p>
<p>内部路由</p>
</li>
</ol>
<p>无线网络分类</p>
<ol>
<li><p>基础设施</p>
</li>
<li><p>无基础设施</p>
<p>没有基站，没有连接到更大互联网（蓝牙、ad hoc）</p>
</li>
</ol>
<p><img src="/2024/06/21/computer_network_course/image-20240619004647930.png" alt="image-20240619004647930"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004723968.png" alt="image-20240619004723968"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619004937368.png" alt="image-20240619004937368"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619005007856.png" alt="image-20240619005007856"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619005029451.png" alt="image-20240619005029451"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619005053048.png" alt="image-20240619005053048"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619005107867.png" alt="image-20240619005107867"></p>
<h2 id="无线链路与网络特性"><a href="#无线链路与网络特性" class="headerlink" title="无线链路与网络特性"></a>无线链路与网络特性</h2><p>特性</p>
<ol>
<li>信号强度衰减</li>
<li>其他源干扰</li>
<li>多径传播</li>
<li>信噪比和比特差错率需要权衡（SNR、BER）</li>
<li>额外问题（除了MAC）<ol>
<li>隐蔽站问题</li>
<li>信号衰减</li>
</ol>
</li>
</ol>
<p><img src="/2024/06/21/computer_network_course/image-20240619005130554.png" alt="image-20240619005130554"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619005144009.png" alt="image-20240619005144009"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619005317930.png" alt="image-20240619005317930"></p>
<h2 id="无线局域网：IEEE802-11"><a href="#无线局域网：IEEE802-11" class="headerlink" title="无线局域网：IEEE802.11"></a>无线局域网：IEEE802.11</h2><h3 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h3><p><img src="/2024/06/21/computer_network_course/image-20240619005421307.png" alt="image-20240619005421307"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619005522041.png" alt="image-20240619005522041"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619005603395.png" alt="image-20240619005603395"></p>
<p><img src="/2024/06/21/computer_network_course/image-20240619005633370.png" alt="image-20240619005633370"></p>
<h3 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>发送数据前先检测是否空闲（需要空闲DIFS时间），发RTS预约帧，接收端收到RTS广播（延迟SIFS）发送CTS响应，收到CTS开始传数据</p>
<p>CRC校验</p>
<p>停等协议</p>
<p>如果信道忙就开始退避</p>
<p><img src="/2024/06/21/computer_network_course/image-20240619005827749-1719580324630-26.png" alt="image-20240619005827749"></p>
<p>反正就是DIFS之后才发帧，然后SIFS后才确认，源站相当于收到了CTS进行确认故而发的SIFS</p>
<h4 id="与CD比较"><a href="#与CD比较" class="headerlink" title="与CD比较"></a>与CD比较</h4><ol>
<li><p>相同点</p>
<p>先听再说，有限重传（二进制指数退避）</p>
</li>
<li><p>不同点</p>
<ol>
<li>传输介质</li>
<li>载波检测方式</li>
</ol>
</li>
<li><p>CD检测，CA避免</p>
</li>
</ol>
<h3 id="帧结构及地址"><a href="#帧结构及地址" class="headerlink" title="帧结构及地址"></a>帧结构及地址</h3><p><img src="/2024/06/21/computer_network_course/image-20240619005849838.png" alt="image-20240619005849838"></p>
]]></content>
  </entry>
  <entry>
    <title>密码学基础</title>
    <url>/2023/11/26/cryptography/</url>
    <content><![CDATA[<blockquote>
<p>学习目的：顺利过考试，以及获取基本的密码学知识，数学原理不重要</p>
</blockquote>
<h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章  概述"></a>第一章  概述</h1><p><img src="/2023/11/26/cryptography/image-20231119222018039.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119222126715.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119222336625.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119222430082.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119222511355.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119222553180.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119222645238.png" alt="image"></p>
<h1 id="第二章-传统密码技术"><a href="#第二章-传统密码技术" class="headerlink" title="第二章  传统密码技术"></a>第二章  传统密码技术</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/2023/11/26/cryptography/image-20231119222823479.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119222901974.png" alt="image"></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="置换密码"><a href="#置换密码" class="headerlink" title="置换密码"></a>置换密码</h3><p><img src="/2023/11/26/cryptography/image-20231119222954074.png" alt="image"></p>
<h4 id="列置换密码"><a href="#列置换密码" class="headerlink" title="列置换密码"></a>列置换密码</h4><h5 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h5><p><img src="/2023/11/26/cryptography/image-20231119223053645.png" alt="image"></p>
<h5 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h5><p><img src="/2023/11/26/cryptography/image-20231119223108082.png" alt="image"></p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p><img src="/2023/11/26/cryptography/image-20231119223136725.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119223200642.png" alt="image"></p>
<h4 id="周期置换密码"><a href="#周期置换密码" class="headerlink" title="周期置换密码"></a>周期置换密码</h4><p><img src="/2023/11/26/cryptography/image-20231119223305282.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119223332354.png" alt="image"></p>
<h3 id="代换密码"><a href="#代换密码" class="headerlink" title="代换密码"></a>代换密码</h3><p><img src="/2023/11/26/cryptography/image-20231119223403058.png" alt="image"></p>
<h4 id="单表代换"><a href="#单表代换" class="headerlink" title="单表代换"></a>单表代换</h4><p><img src="/2023/11/26/cryptography/image-20231119223428493.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119223511223.png" alt="image"></p>
<h4 id="多表代换"><a href="#多表代换" class="headerlink" title="多表代换"></a>多表代换</h4><p><img src="/2023/11/26/cryptography/image-20231119223604772.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119223555870.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119223613426.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119223621319.png" alt="image"></p>
<h2 id="传统密码体制分析"><a href="#传统密码体制分析" class="headerlink" title="传统密码体制分析"></a>传统密码体制分析</h2><h3 id="频率（单表代换）"><a href="#频率（单表代换）" class="headerlink" title="频率（单表代换）"></a>频率（单表代换）</h3><p><img src="/2023/11/26/cryptography/image-20231119223727942.png" alt="image"></p>
<h3 id="重合指数（多表代换）"><a href="#重合指数（多表代换）" class="headerlink" title="重合指数（多表代换）"></a>重合指数（多表代换）</h3><p><img src="/2023/11/26/cryptography/image-20231119223857071.png" alt="image"></p>
<h3 id="明文-密文对（hill密码）"><a href="#明文-密文对（hill密码）" class="headerlink" title="明文-密文对（hill密码）"></a>明文-密文对（hill密码）</h3><p><img src="/2023/11/26/cryptography/image-20231119223930902.png" alt="image"></p>
<h1 id="第三章-分组密码-DES"><a href="#第三章-分组密码-DES" class="headerlink" title="第三章  分组密码-DES"></a>第三章  分组密码-DES</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2023/11/26/cryptography/image-20231119224132702.png" alt="image"></p>
<ol>
<li>分组密码一般指对称分组密码</li>
</ol>
<p><img src="/2023/11/26/cryptography/image-20231119224232150.png" alt="image"></p>
<ol>
<li>明文经编码表示后变成二进制序列</li>
<li>二进制序列固定长度分组</li>
<li>每组在密钥控制下转为密文分组</li>
<li>本质上是明文到密文的一一映射</li>
<li>一般明文长度=密文长度，密钥长度不一定</li>
</ol>
<p><img src="/2023/11/26/cryptography/image-20231119224412729.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119224441289.png" alt="image"></p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p><img src="/2023/11/26/cryptography/image-20231119224551695.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119224630628.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119224726050.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119224747586.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119224800319.png" alt="image"></p>
<h2 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h2><p><img src="/2023/11/26/cryptography/image-20231119224918813.png" alt="image"></p>
<h3 id="子密钥生成算法"><a href="#子密钥生成算法" class="headerlink" title="子密钥生成算法"></a>子密钥生成算法</h3><p><img src="/2023/11/26/cryptography/image-20231119224859830.png" alt="image"></p>
<h3 id="轮函数"><a href="#轮函数" class="headerlink" title="轮函数"></a>轮函数</h3><p><img src="/2023/11/26/cryptography/image-20231119224936549.png" alt="image"></p>
<h3 id="迭代轮数"><a href="#迭代轮数" class="headerlink" title="迭代轮数"></a>迭代轮数</h3><p><img src="/2023/11/26/cryptography/image-20231119225029970.png" alt="image"></p>
<h2 id="DES算法"><a href="#DES算法" class="headerlink" title="DES算法"></a>DES算法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/11/26/cryptography/image-20231119225153271.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119225142819.png" alt="image"></p>
<h3 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h3><h4 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h4><p><img src="/2023/11/26/cryptography/image-20231119225209591.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119225217619.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119225227761.png" alt="image"></p>
<h4 id="选择扩展置换E"><a href="#选择扩展置换E" class="headerlink" title="选择扩展置换E"></a>选择扩展置换E</h4><p><img src="/2023/11/26/cryptography/image-20231119225353795.png" alt="image"></p>
<h4 id="子密钥生成"><a href="#子密钥生成" class="headerlink" title="子密钥生成"></a>子密钥生成</h4><p><img src="/2023/11/26/cryptography/image-20231119225449569.png" alt="image"></p>
<h4 id="压缩替代S-盒"><a href="#压缩替代S-盒" class="headerlink" title="压缩替代S-盒"></a>压缩替代S-盒</h4><p><img src="/2023/11/26/cryptography/image-20231119225511882.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119225521899.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119225530038.png" alt="image"></p>
<h4 id="置换p-盒"><a href="#置换p-盒" class="headerlink" title="置换p-盒"></a>置换p-盒</h4><p><img src="/2023/11/26/cryptography/image-20231119225600458.png" alt="image"></p>
<h3 id="解密流程"><a href="#解密流程" class="headerlink" title="解密流程"></a>解密流程</h3><p><img src="/2023/11/26/cryptography/image-20231119225621050.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119225631527.png" alt="image"></p>
<h3 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h3><p><img src="/2023/11/26/cryptography/image-20231119225647975.png" alt="image"></p>
<h4 id="互补性"><a href="#互补性" class="headerlink" title="互补性"></a>互补性</h4><p><img src="/2023/11/26/cryptography/image-20231119225732681.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119225758954.png" alt="image"></p>
<h4 id="弱密钥"><a href="#弱密钥" class="headerlink" title="弱密钥"></a>弱密钥</h4><p><img src="/2023/11/26/cryptography/image-20231119225848805.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119225913300.png" alt="image"></p>
<h4 id="差分分析"><a href="#差分分析" class="headerlink" title="差分分析"></a>差分分析</h4><p>只有理论上意义</p>
<p><img src="/2023/11/26/cryptography/image-20231119225953474.png" alt="image"></p>
<h4 id="线性分析"><a href="#线性分析" class="headerlink" title="线性分析"></a>线性分析</h4><p>实际上不可行</p>
<p><img src="/2023/11/26/cryptography/image-20231119230028597.png" alt="image"></p>
<h4 id="密钥搜索"><a href="#密钥搜索" class="headerlink" title="密钥搜索"></a>密钥搜索</h4><p><img src="/2023/11/26/cryptography/image-20231119230129822.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119230138963.png" alt="image"></p>
<h3 id="多重DES"><a href="#多重DES" class="headerlink" title="多重DES"></a>多重DES</h3><p><img src="/2023/11/26/cryptography/image-20231119230207518.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119230338089.png" alt="image"></p>
<h4 id="二重"><a href="#二重" class="headerlink" title="二重"></a>二重</h4><p><img src="/2023/11/26/cryptography/image-20231119230315584.png" alt="image"></p>
<h4 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h4><p>你也是过渡阶段？</p>
<p><img src="/2023/11/26/cryptography/image-20231119230417525.png" alt="image"></p>
<h1 id="第四章-有限域"><a href="#第四章-有限域" class="headerlink" title="第四章  有限域"></a>第四章  有限域</h1><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><p><img src="/2023/11/26/cryptography/image-20231119234428038.png" alt="image"></p>
<p>逆元：</p>
<p><img src="/2023/11/26/cryptography/image-20231119235319197.png" alt="image-20231119235319197"></p>
<p>比如说在G(7)中，2的逆元为4。</p>
<p>也即，任意整数a，则存在x，a / 2 == a * 4 (mod 7)，4为2模7的乘法逆元，记为 2(-1)(mod 7) = 4。</p>
<p><img src="/2023/11/26/cryptography/image-20231119235512984.png" alt="image"></p>
<p><strong>求逆元的方法是求b^(m-2) mod m。如2^(5) mod 7 = 4。</strong></p>
<h2 id="群环域"><a href="#群环域" class="headerlink" title="群环域"></a>群环域</h2><h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><p><img src="/2023/11/26/cryptography/image-20231119232126377.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119232205801.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119232231570.png" alt="image"></p>
<p>确实封闭且结合且单位元且逆元</p>
<h3 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h3><p><img src="/2023/11/26/cryptography/image-20231119232310488.png" alt="image"></p>
<h3 id="环"><a href="#环" class="headerlink" title="环"></a>环</h3><p><img src="/2023/11/26/cryptography/image-20231119232407147.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119232429044.png" alt="image"></p>
<p>确实是环</p>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p><img src="/2023/11/26/cryptography/image-20231119232459199.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119232519529.png" alt="image"></p>
<h2 id="有限域GF-p"><a href="#有限域GF-p" class="headerlink" title="有限域GF(p)"></a>有限域GF(p)</h2><p>有限域就是阶为素数幂的域？</p>
<p><img src="/2023/11/26/cryptography/image-20231119232608646.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119232659953.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119232717361.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119233220659.png" alt="image-20231119233220659"></p>
<h2 id="多项式运算"><a href="#多项式运算" class="headerlink" title="多项式运算"></a>多项式运算</h2><p><img src="/2023/11/26/cryptography/image-20231119232756603.png" alt="image"></p>
<h3 id="普通多项式运算"><a href="#普通多项式运算" class="headerlink" title="普通多项式运算"></a>普通多项式运算</h3><p><img src="/2023/11/26/cryptography/image-20231119232847173.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119232903459.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119232932738.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119234528189.png" alt="image"></p>
<h3 id="系数模p运算的多项式运算"><a href="#系数模p运算的多项式运算" class="headerlink" title="系数模p运算的多项式运算"></a>系数模p运算的多项式运算</h3><p><img src="/2023/11/26/cryptography/image-20231119233037803.png" alt="image"></p>
<p>确实，毕竟系数本身就是域了，除了没定义逆元外别的都满足。</p>
<p><img src="/2023/11/26/cryptography/image-20231119233145548.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231119235731638.png" alt="image"></p>
<h2 id="有限域GF-2-n"><a href="#有限域GF-2-n" class="headerlink" title="有限域GF(2^n)"></a>有限域GF(2^n)</h2><p><img src="/2023/11/26/cryptography/image-20231119235923333.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120000001505.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120000059341.png" alt="image"></p>
<h1 id="第五章-高级加密标准-AES"><a href="#第五章-高级加密标准-AES" class="headerlink" title="第五章  高级加密标准-AES"></a>第五章  高级加密标准-AES</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/2023/11/26/cryptography/image-20231120000312185.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120000338186.png" alt="image"></p>
<p>Nr=Nk的幂数x2</p>
<h3 id="简化版AES"><a href="#简化版AES" class="headerlink" title="简化版AES"></a>简化版AES</h3><p><img src="/2023/11/26/cryptography/image-20231120000355105.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120000416467.png" alt="image"></p>
<p>具体算法详见PPT。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="/2023/11/26/cryptography/image-20231120000651715.png" alt="image"></p>
<h2 id="总体流程-1"><a href="#总体流程-1" class="headerlink" title="总体流程"></a>总体流程</h2><p><img src="/2023/11/26/cryptography/image-20231120005931885.png" alt="image"></p>
<h2 id="加密流程-1"><a href="#加密流程-1" class="headerlink" title="加密流程"></a>加密流程</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="/2023/11/26/cryptography/image-20231120000700599.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120000710645.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120000736578.png" alt="image"></p>
<h3 id="状态矩阵"><a href="#状态矩阵" class="headerlink" title="状态矩阵"></a>状态矩阵</h3><p><img src="/2023/11/26/cryptography/image-20231120000800220.png" alt="image"></p>
<h3 id="字节代替"><a href="#字节代替" class="headerlink" title="字节代替"></a>字节代替</h3><p><img src="/2023/11/26/cryptography/image-20231120000819900.png" alt="image"></p>
<h3 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h3><p><img src="/2023/11/26/cryptography/image-20231120000919476.png" alt="image"></p>
<h3 id="列混淆"><a href="#列混淆" class="headerlink" title="列混淆"></a>列混淆</h3><p><img src="/2023/11/26/cryptography/image-20231120000942609.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120004913600.png" alt="image"></p>
<p>可以关注下是怎么通过C矩阵求出这个固定多项式的：</p>
<p><img src="/2023/11/26/cryptography/image-20231120005148896.png" alt="image"></p>
<h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p><img src="/2023/11/26/cryptography/image-20231120005543314.png" alt="image"></p>
<h3 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h3><p><img src="/2023/11/26/cryptography/image-20231120005619394.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120005710994.png" alt="image"></p>
<p>感觉也是类似对明文做的操作</p>
<h2 id="安全评估"><a href="#安全评估" class="headerlink" title="安全评估"></a>安全评估</h2><p><img src="/2023/11/26/cryptography/image-20231120010110331.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120010133230.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120010213720.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120010306206.png" alt="image"></p>
<h2 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h2><p><img src="/2023/11/26/cryptography/image-20231120010341891.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120010419437.png" alt="image"></p>
<h1 id="第六章-分组密码的工作模式"><a href="#第六章-分组密码的工作模式" class="headerlink" title="第六章  分组密码的工作模式"></a>第六章  分组密码的工作模式</h1><p><img src="/2023/11/26/cryptography/image-20231120010546141.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120010602333.png" alt="image"></p>
<h2 id="电码本ECB"><a href="#电码本ECB" class="headerlink" title="电码本ECB"></a>电码本ECB</h2><p><img src="/2023/11/26/cryptography/image-20231120010651747.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120010728539.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120010752497.png" alt="image"></p>
<h2 id="密码分组链接CBC"><a href="#密码分组链接CBC" class="headerlink" title="密码分组链接CBC"></a>密码分组链接CBC</h2><p><img src="/2023/11/26/cryptography/image-20231120010859316.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120011015824.png" alt="image"></p>
<h2 id="密码反馈CFB"><a href="#密码反馈CFB" class="headerlink" title="密码反馈CFB"></a>密码反馈CFB</h2><p><img src="/2023/11/26/cryptography/image-20231120011206708.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120011223318.png" alt="image"></p>
<h2 id="输出反馈OFB"><a href="#输出反馈OFB" class="headerlink" title="输出反馈OFB"></a>输出反馈OFB</h2><p><img src="/2023/11/26/cryptography/image-20231120011303048.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120011315644.png" alt="image"></p>
<h2 id="计数器Counter"><a href="#计数器Counter" class="headerlink" title="计数器Counter"></a>计数器Counter</h2><p><img src="/2023/11/26/cryptography/image-20231120011352581.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120011421043.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120011449708.png" alt="image"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/11/26/cryptography/image-20231120011535294.png" alt="image"></p>
<h1 id="第七章-序列密码"><a href="#第七章-序列密码" class="headerlink" title="第七章  序列密码"></a>第七章  序列密码</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>序列密码的密钥序列是随机的。</p>
<p><img src="/2023/11/26/cryptography/image-20231120011915630.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120011858378.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120012030717.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120012047534.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120130156719.png" alt="image"></p>
<h2 id="总体流程-2"><a href="#总体流程-2" class="headerlink" title="总体流程"></a>总体流程</h2><p><img src="/2023/11/26/cryptography/image-20231120012144122.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120012213133.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120012223035.png" alt="image"></p>
<h2 id="密钥产生器KG"><a href="#密钥产生器KG" class="headerlink" title="密钥产生器KG"></a>密钥产生器KG</h2><h3 id="总体构成"><a href="#总体构成" class="headerlink" title="总体构成"></a>总体构成</h3><p><img src="/2023/11/26/cryptography/image-20231120012322953.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120012442030.png" alt="image"></p>
<h3 id="线性反馈移位寄存器理论"><a href="#线性反馈移位寄存器理论" class="headerlink" title="线性反馈移位寄存器理论"></a>线性反馈移位寄存器理论</h3><p><img src="/2023/11/26/cryptography/image-20231120012517094.png" alt="image"></p>
<h4 id="反馈移位寄存器"><a href="#反馈移位寄存器" class="headerlink" title="反馈移位寄存器"></a>反馈移位寄存器</h4><p><img src="/2023/11/26/cryptography/image-20231120012601294.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120012733361.png" alt="image"></p>
<h4 id="线性反馈移位寄存器"><a href="#线性反馈移位寄存器" class="headerlink" title="线性反馈移位寄存器"></a>线性反馈移位寄存器</h4><p><img src="/2023/11/26/cryptography/image-20231120012859837.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120012940587.png" alt="image"></p>
<p>确实，感觉相比上面的这笔就是换了个反馈函数，就达到了2^n-1的周期</p>
<h4 id="m序列"><a href="#m序列" class="headerlink" title="m序列"></a>m序列</h4><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><p><img src="/2023/11/26/cryptography/image-20231120013224616.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120013316147.png" alt="image"></p>
<h5 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h5><p><img src="/2023/11/26/cryptography/image-20231120013909570.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014004584.png" alt="image"></p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p><img src="/2023/11/26/cryptography/image-20231120014019199.png" alt="image"></p>
<h5 id="破译"><a href="#破译" class="headerlink" title="破译"></a>破译</h5><p><img src="/2023/11/26/cryptography/image-20231120014041211.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014141526.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014151431.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014201800.png" alt="image"></p>
<h3 id="常见序列生成算法"><a href="#常见序列生成算法" class="headerlink" title="常见序列生成算法"></a>常见序列生成算法</h3><h4 id="Geffe序列生成器"><a href="#Geffe序列生成器" class="headerlink" title="Geffe序列生成器"></a>Geffe序列生成器</h4><p><img src="/2023/11/26/cryptography/image-20231120014417326.png" alt="image"></p>
<h4 id="Pless生成器"><a href="#Pless生成器" class="headerlink" title="Pless生成器"></a>Pless生成器</h4><p><img src="/2023/11/26/cryptography/image-20231120014449805.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014500613.png" alt="image"></p>
<h4 id="A5算法"><a href="#A5算法" class="headerlink" title="A5算法"></a>A5算法</h4><p><img src="/2023/11/26/cryptography/image-20231120014523770.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014558492.png" alt="image"></p>
<h4 id="ZUC算法"><a href="#ZUC算法" class="headerlink" title="ZUC算法"></a>ZUC算法</h4><p><img src="/2023/11/26/cryptography/image-20231120014640285.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014734459.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014755386.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014805642.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014816175.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014831607.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120014855757.png" alt="image"></p>
<h2 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><img src="/2023/11/26/cryptography/image-20231120014946331.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120122751771.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120125826761.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120130044271.png" alt="image"></p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="数据表S的初始状态"><a href="#数据表S的初始状态" class="headerlink" title="数据表S的初始状态"></a>数据表S的初始状态</h4><p><img src="/2023/11/26/cryptography/image-20231120125942805.png" alt="image"></p>
<h4 id="数据表S的初始置换"><a href="#数据表S的初始置换" class="headerlink" title="数据表S的初始置换"></a>数据表S的初始置换</h4><p><img src="/2023/11/26/cryptography/image-20231120125958131.png" alt="image"></p>
<h4 id="密钥流的生成"><a href="#密钥流的生成" class="headerlink" title="密钥流的生成"></a>密钥流的生成</h4><p><img src="/2023/11/26/cryptography/image-20231120130013630.png" alt="image"></p>
<h1 id="第八章-数论基础"><a href="#第八章-数论基础" class="headerlink" title="第八章  数论基础"></a>第八章  数论基础</h1><h2 id="整除性和带余除法，最大公因子"><a href="#整除性和带余除法，最大公因子" class="headerlink" title="整除性和带余除法，最大公因子"></a>整除性和带余除法，最大公因子</h2><p><img src="/2023/11/26/cryptography/image-20231120130409497.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120130440133.png" alt="image"></p>
<h2 id="素数和模运算"><a href="#素数和模运算" class="headerlink" title="素数和模运算"></a>素数和模运算</h2><p><img src="/2023/11/26/cryptography/image-20231120130547431.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120130642217.png" alt="image"></p>
<p>也就是说求最大公因子实际上可以只求共有素数因子</p>
<p><img src="/2023/11/26/cryptography/image-20231120130737986.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120130803079.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120130829841.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120130925631.png" alt="image"></p>
<h2 id="欧几里得算法和扩展欧几里得算法"><a href="#欧几里得算法和扩展欧几里得算法" class="headerlink" title="欧几里得算法和扩展欧几里得算法"></a>欧几里得算法和扩展欧几里得算法</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p><img src="/2023/11/26/cryptography/image-20231120131006626.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131055843.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131106562.png" alt="image"></p>
<h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p><img src="/2023/11/26/cryptography/image-20231120131139829.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131157809.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131217894.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131236610.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131252821.png" alt="image"></p>
<h2 id="费马小定理和欧拉定理"><a href="#费马小定理和欧拉定理" class="headerlink" title="费马小定理和欧拉定理"></a>费马小定理和欧拉定理</h2><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p><img src="/2023/11/26/cryptography/image-20231120131345269.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131424728.png" alt="image"></p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p><img src="/2023/11/26/cryptography/image-20231120131503053.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131520824.png" alt="image"></p>
<h2 id="素性检测"><a href="#素性检测" class="headerlink" title="素性检测"></a>素性检测</h2><h3 id="miller-rabin"><a href="#miller-rabin" class="headerlink" title="miller-rabin"></a>miller-rabin</h3><p><img src="/2023/11/26/cryptography/image-20231120131622208.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131633256.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131644338.png" alt="image"></p>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p><img src="/2023/11/26/cryptography/image-20231120131806941.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131839111.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131902358.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131913274.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120131923158.png" alt="image"></p>
<h2 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h2><p><img src="/2023/11/26/cryptography/image-20231120131950878.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120132055511.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120132116772.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120132127205.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120132136434.png" alt="image"></p>
<h1 id="第九章-公钥加密体系-RSA"><a href="#第九章-公钥加密体系-RSA" class="headerlink" title="第九章  公钥加密体系-RSA"></a>第九章  公钥加密体系-RSA</h1><p><img src="/2023/11/26/cryptography/image-20231120143522814.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120144501838.png" alt="image"></p>
<h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p><img src="/2023/11/26/cryptography/image-20231120135241601.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120135407679.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120135512877.png" alt="image"></p>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="/2023/11/26/cryptography/image-20231120135608242.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120135620907.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120135701846.png" alt="image"></p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p><img src="/2023/11/26/cryptography/image-20231120135845287.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120135820650.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120135903836.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120140103096.png" alt="image"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><img src="/2023/11/26/cryptography/image-20231120140203652.png" alt="image"></p>
<h2 id="Rabin加密"><a href="#Rabin加密" class="headerlink" title="Rabin加密"></a>Rabin加密</h2><p><img src="/2023/11/26/cryptography/image-20231120140242955.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120140336387.png" alt="image"></p>
<h2 id="MH背包密码"><a href="#MH背包密码" class="headerlink" title="MH背包密码"></a>MH背包密码</h2><p><img src="/2023/11/26/cryptography/image-20231120141028954.png" alt="image"></p>
<h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><img src="/2023/11/26/cryptography/image-20231120140750253.png" alt="image"></p>
<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p><img src="/2023/11/26/cryptography/image-20231120140829715.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120140840672.png" alt="image"></p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p><img src="/2023/11/26/cryptography/image-20231120140853720.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120140903758.png" alt="image"></p>
<h3 id="安全性分析-1"><a href="#安全性分析-1" class="headerlink" title="安全性分析"></a>安全性分析</h3><p><img src="/2023/11/26/cryptography/image-20231120140945341.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120140958783.png" alt="image"></p>
<h2 id="EIGamal加密"><a href="#EIGamal加密" class="headerlink" title="EIGamal加密"></a>EIGamal加密</h2><p><img src="/2023/11/26/cryptography/image-20231120141206972.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120141238676.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120141249195.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120141259944.png" alt="image"></p>
<h2 id="椭圆曲线密码体制"><a href="#椭圆曲线密码体制" class="headerlink" title="椭圆曲线密码体制"></a>椭圆曲线密码体制</h2><p><img src="/2023/11/26/cryptography/image-20231120141330799.png" alt="image"></p>
<h3 id="数学理论"><a href="#数学理论" class="headerlink" title="数学理论"></a>数学理论</h3><p><img src="/2023/11/26/cryptography/image-20231120141400589.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120141435895.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120141507133.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120141607447.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120141618687.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120141710812.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120141722046.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120141731872.png" alt="image"></p>
<h3 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h3><p><img src="/2023/11/26/cryptography/image-20231120141846851.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120142534621.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120142550338.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120142623919.png" alt="image"></p>
<h2 id="IBE算法"><a href="#IBE算法" class="headerlink" title="IBE算法"></a>IBE算法</h2><p><img src="/2023/11/26/cryptography/image-20231120142723677.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120144717838.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120142831940.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120142902007.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120144558010.png" alt="image"></p>
<p>看起来意思就是公钥完全明文，用的是用户的身份ID；私钥用户自己存着。</p>
<p><img src="/2023/11/26/cryptography/image-20231120144627486.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120144638527.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120144650277.png" alt="image"></p>
<h2 id="后量子密码"><a href="#后量子密码" class="headerlink" title="后量子密码"></a>后量子密码</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/11/26/cryptography/image-20231120144753993.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120144814756.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120144855045.png" alt="image"></p>
<h3 id="格"><a href="#格" class="headerlink" title="格"></a>格</h3><p><img src="/2023/11/26/cryptography/image-20231120144933569.png" alt="image"></p>
<h3 id="NTRU"><a href="#NTRU" class="headerlink" title="NTRU"></a>NTRU</h3><h4 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h4><p><img src="/2023/11/26/cryptography/image-20231120145003171.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120145012234.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120145021085.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120145030571.png" alt="image"></p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><img src="/2023/11/26/cryptography/image-20231120145040656.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120145052273.png" alt="image"></p>
<h4 id="安全性-1"><a href="#安全性-1" class="headerlink" title="安全性"></a>安全性</h4><p><img src="/2023/11/26/cryptography/image-20231120145152439.png" alt="image"></p>
<h1 id="第十一章-哈希函数"><a href="#第十一章-哈希函数" class="headerlink" title="第十一章  哈希函数"></a>第十一章  哈希函数</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p><img src="/2023/11/26/cryptography/image-20231120145302190.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120145320584.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120145336379.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120145402153.png" alt="image"></p>
<p>这个角度很有意思，确实是名字一样原理相近，但是目的完全不一样：</p>
<p><img src="/2023/11/26/cryptography/image-20231120145443084.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120145522364.png" alt="image"></p>
<h2 id="常见哈希函数"><a href="#常见哈希函数" class="headerlink" title="常见哈希函数"></a>常见哈希函数</h2><h3 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h3><p><img src="/2023/11/26/cryptography/image-20231120145748479.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120145815746.png" alt="image"></p>
<h3 id="SM3"><a href="#SM3" class="headerlink" title="SM3"></a>SM3</h3><p><img src="/2023/11/26/cryptography/image-20231120145847528.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120145909541.png" alt="image"></p>
<h2 id="安全性-2"><a href="#安全性-2" class="headerlink" title="安全性"></a>安全性</h2><p><img src="/2023/11/26/cryptography/image-20231120145944858.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120150350329.png" alt="image"></p>
<h3 id="暴力攻击"><a href="#暴力攻击" class="headerlink" title="暴力攻击"></a>暴力攻击</h3><p><img src="/2023/11/26/cryptography/image-20231120150026999.png" alt="image"></p>
<h3 id="生日攻击"><a href="#生日攻击" class="headerlink" title="生日攻击"></a>生日攻击</h3><p><img src="/2023/11/26/cryptography/image-20231120150156790.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120150210059.png" alt="image"></p>
<h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><p><img src="/2023/11/26/cryptography/image-20231120150259286.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120150325686.png" alt="image"></p>
<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p><img src="/2023/11/26/cryptography/image-20231120150417722.png" alt="image"></p>
<h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p><img src="/2023/11/26/cryptography/image-20231120150500141.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120150526243.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120150541718.png" alt="image"></p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p><img src="/2023/11/26/cryptography/image-20231120150732074.png" alt="image"></p>
<p>也就是中途会哈希两次吼。</p>
<h1 id="第十二章-消息认证码-MAC"><a href="#第十二章-消息认证码-MAC" class="headerlink" title="第十二章  消息认证码 (MAC)"></a>第十二章  消息认证码 (MAC)</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p><img src="/2023/11/26/cryptography/image-20231120150947443.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120151022827.png" alt="image"></p>
<p>一样的话就是说明消息没被篡改</p>
<p><img src="/2023/11/26/cryptography/image-20231120151059584.png" alt="image"></p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p><img src="/2023/11/26/cryptography/image-20231120151238803.png" alt="image"></p>
<h2 id="基于哈希函数的MAC"><a href="#基于哈希函数的MAC" class="headerlink" title="基于哈希函数的MAC"></a>基于哈希函数的MAC</h2><p><img src="/2023/11/26/cryptography/image-20231120151305811.png" alt="image"></p>
<h3 id="直观构造"><a href="#直观构造" class="headerlink" title="直观构造"></a>直观构造</h3><p><img src="/2023/11/26/cryptography/image-20231120151318715.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120151418534.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120151440440.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120151453462.png" alt="image"></p>
<h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h3><p><img src="/2023/11/26/cryptography/image-20231120151517403.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120151529467.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120151555084.png" alt="image"></p>
<h2 id="基于分组密码的MAC"><a href="#基于分组密码的MAC" class="headerlink" title="基于分组密码的MAC"></a>基于分组密码的MAC</h2><p><img src="/2023/11/26/cryptography/image-20231120151622333.png" alt="image"></p>
<h3 id="数据认证算法DAA"><a href="#数据认证算法DAA" class="headerlink" title="数据认证算法DAA"></a>数据认证算法DAA</h3><p><img src="/2023/11/26/cryptography/image-20231120151648013.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120151659361.png" alt="image"></p>
<h3 id="CMAC"><a href="#CMAC" class="headerlink" title="CMAC"></a>CMAC</h3><p><img src="/2023/11/26/cryptography/image-20231120151739695.png" alt="image"></p>
<h2 id="认证加密"><a href="#认证加密" class="headerlink" title="认证加密"></a>认证加密</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/11/26/cryptography/image-20231120151923762.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120151940364.png" alt="image"></p>
<h3 id="CCM"><a href="#CCM" class="headerlink" title="CCM"></a>CCM</h3><p><img src="/2023/11/26/cryptography/image-20231120152019396.png" alt="image"></p>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p><img src="/2023/11/26/cryptography/image-20231120152117383.png" alt="image"></p>
<h1 id="第十三章-数字签名PKI"><a href="#第十三章-数字签名PKI" class="headerlink" title="第十三章  数字签名PKI"></a>第十三章  数字签名PKI</h1><h2 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p><img src="/2023/11/26/cryptography/image-20231120152316017.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120152345163.png" alt="image"></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="/2023/11/26/cryptography/image-20231120152419065.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120152948628.png" alt="image"></p>
<h3 id="安全性-3"><a href="#安全性-3" class="headerlink" title="安全性"></a>安全性</h3><p><img src="/2023/11/26/cryptography/image-20231120152440512.png" alt="image"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2023/11/26/cryptography/image-20231120152504878.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120152522261.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120152544925.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120152611098.png" alt="image"></p>
<h2 id="常见实现"><a href="#常见实现" class="headerlink" title="常见实现"></a>常见实现</h2><p>都包含签名算法、验证算法、正确性证明、举例，详细看PPT吧。</p>
<h3 id="基于RSA"><a href="#基于RSA" class="headerlink" title="基于RSA"></a>基于RSA</h3><p><img src="/2023/11/26/cryptography/image-20231120152725005.png" alt="image"></p>
<h3 id="基于离散对数"><a href="#基于离散对数" class="headerlink" title="基于离散对数"></a>基于离散对数</h3><p><img src="/2023/11/26/cryptography/image-20231120152913083.png" alt="image"></p>
<h4 id="ELGamal"><a href="#ELGamal" class="headerlink" title="ELGamal"></a>ELGamal</h4><h4 id="Schnorr"><a href="#Schnorr" class="headerlink" title="Schnorr"></a>Schnorr</h4><h4 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h4><h3 id="盲签名"><a href="#盲签名" class="headerlink" title="盲签名"></a>盲签名</h3><p><img src="/2023/11/26/cryptography/image-20231120153036032.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120153105386.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120153128838.png" alt="image"></p>
<h3 id="群（组）签名"><a href="#群（组）签名" class="headerlink" title="群（组）签名"></a>群（组）签名</h3><p><img src="/2023/11/26/cryptography/image-20231120153205988.png" alt="image"></p>
<h1 id="第十四章-密码协议"><a href="#第十四章-密码协议" class="headerlink" title="第十四章  密码协议"></a>第十四章  密码协议</h1><h2 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h2><p><img src="/2023/11/26/cryptography/image-20231120153338455.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120153350781.png" alt="image"></p>
<h2 id="分割和选择协议"><a href="#分割和选择协议" class="headerlink" title="分割和选择协议"></a>分割和选择协议</h2><p><img src="/2023/11/26/cryptography/image-20231120153410259.png" alt="image"></p>
<h2 id="掷硬币协议"><a href="#掷硬币协议" class="headerlink" title="掷硬币协议"></a>掷硬币协议</h2><p><img src="/2023/11/26/cryptography/image-20231120153422523.png" alt="image"></p>
<h3 id="单向函数"><a href="#单向函数" class="headerlink" title="单向函数"></a>单向函数</h3><p><img src="/2023/11/26/cryptography/image-20231120153506987.png" alt="image"></p>
<h3 id="模p指数运算"><a href="#模p指数运算" class="headerlink" title="模p指数运算"></a>模p指数运算</h3><p><img src="/2023/11/26/cryptography/image-20231120153526109.png" alt="image"></p>
<h2 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h2><p><img src="/2023/11/26/cryptography/image-20231120153558284.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120153634521.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120153703210.png" alt="image"></p>
<h2 id="比特承诺"><a href="#比特承诺" class="headerlink" title="比特承诺"></a>比特承诺</h2><p><img src="/2023/11/26/cryptography/image-20231120153738627.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120153826721.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120153845437.png" alt="image"></p>
<h2 id="安全多方计算"><a href="#安全多方计算" class="headerlink" title="安全多方计算"></a>安全多方计算</h2><p>这个有点复杂，可以看看PPT。</p>
<h1 id="第十五章-密钥管理"><a href="#第十五章-密钥管理" class="headerlink" title="第十五章  密钥管理"></a>第十五章  密钥管理</h1><h2 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h2><p><img src="/2023/11/26/cryptography/image-20231120154112340.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120154132318.png" alt="image"></p>
<h2 id="密钥分配"><a href="#密钥分配" class="headerlink" title="密钥分配"></a>密钥分配</h2><p><img src="/2023/11/26/cryptography/image-20231120154223106.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120154240202.png" alt="image"></p>
<h3 id="无中心"><a href="#无中心" class="headerlink" title="无中心"></a>无中心</h3><p><img src="/2023/11/26/cryptography/image-20231120154253690.png" alt="image"></p>
<h3 id="中心模式"><a href="#中心模式" class="headerlink" title="中心模式"></a>中心模式</h3><p><img src="/2023/11/26/cryptography/image-20231120154310454.png" alt="image"></p>
<h3 id="基于公钥密钥"><a href="#基于公钥密钥" class="headerlink" title="基于公钥密钥"></a>基于公钥密钥</h3><p><img src="/2023/11/26/cryptography/image-20231120171038334.png" alt="image"></p>
<h3 id="密钥协商"><a href="#密钥协商" class="headerlink" title="密钥协商"></a>密钥协商</h3><p><img src="/2023/11/26/cryptography/image-20231120171136701.png" alt="image"></p>
<h3 id="Diffie-Hellman密钥交换方案"><a href="#Diffie-Hellman密钥交换方案" class="headerlink" title="Diffie-Hellman密钥交换方案"></a>Diffie-Hellman密钥交换方案</h3><p><img src="/2023/11/26/cryptography/image-20231120171226274.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120171239893.png" alt="image"></p>
<h2 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h2><p><img src="/2023/11/26/cryptography/image-20231120171317621.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120171419713.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120171447133.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120171531614.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120171635093.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120171647680.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120171707454.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120171822452.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120172019321.png" alt="image"></p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><h3 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/11/26/cryptography/image-20231120172522718.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120172807821.png" alt="image"></p>
<h3 id="底层协议"><a href="#底层协议" class="headerlink" title="底层协议"></a>底层协议</h3><p><img src="/2023/11/26/cryptography/image-20231120172838611.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120173036008.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120173212444.png" alt="image"></p>
<h3 id="上层协议"><a href="#上层协议" class="headerlink" title="上层协议"></a>上层协议</h3><h4 id="警告协议"><a href="#警告协议" class="headerlink" title="警告协议"></a>警告协议</h4><p><img src="/2023/11/26/cryptography/image-20231120173251742.png" alt="image"></p>
<h4 id="握手协议-密码变化协议"><a href="#握手协议-密码变化协议" class="headerlink" title="握手协议/密码变化协议"></a>握手协议/密码变化协议</h4><p><img src="/2023/11/26/cryptography/image-20231120173313816.png" alt="image"></p>
<h3 id="密钥交换（四握手）"><a href="#密钥交换（四握手）" class="headerlink" title="密钥交换（四握手）"></a>密钥交换（四握手）</h3><p><img src="/2023/11/26/cryptography/image-20231120173339869.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120173417546.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120173456613.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120173556901.png" alt="image"></p>
<p><img src="/2023/11/26/cryptography/image-20231120173613948.png" alt="image"></p>
]]></content>
  </entry>
  <entry>
    <title>Lab3   TCPSender</title>
    <url>/2023/02/25/cs144$lab3/</url>
    <content><![CDATA[<h1 id="Lab3-TCPSender"><a href="#Lab3-TCPSender" class="headerlink" title="Lab3   TCPSender"></a>Lab3   TCPSender</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在TCP协议中，<code>TCPSender</code>负责对ack进行处理，将字节流封装为TCP报文，根据拥塞窗口的大小传输数据，以及管理超时重传。</p>
<p>我们的<code>TCPSender</code>需要做的是：</p>
<ol>
<li><p>维护拥塞窗口</p>
<p><img src="/2023/02/25/cs144/image-20230228105405827.png" alt="image-20230228105405827"></p>
<p>我们需要通过ackno和window_size两个参数维护拥塞窗口的大小</p>
</li>
<li><p>填充拥塞窗口</p>
<p>必须as possible。除非拥塞窗口满或者<code>ByteStream</code>空才不填。</p>
<p>对于从<code>ByteStream</code>读出的数据，我们需要把其封装为一个<code>TCPSegment</code>再向<code>_segment_out</code>输出</p>
</li>
<li><p>记录哪一部分ack了，哪一部分没有ack</p>
<p>我们需要在发送segment的同时暂存segment，当且仅当接收到ack，并且ack为segment.seqno+length的时候才能将其释放。</p>
</li>
<li><p>管理超时重传</p>
<p>当对方超过一段时间还没有收到数据时，需要进行超时重传</p>
<p>以segment为单位，一个segment重传具有原子性。</p>
<p>在sender和暂存segment的数据结构中保存时钟滴答</p>
</li>
</ol>
<p>特别的，指导书上有一段话表述得很有意思：</p>
<p><img src="/2023/02/25/cs144/image-20230228110046088.png" alt="image-20230228110046088"></p>
<p>这体现了<code>TCPReceiver</code>和<code>TCPSender</code>之间的对偶关系，这种细节性的设计理念值得学习。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>写完<code>TCPSender</code>后我还是觉得有些迷茫……就跟<code>TCPReceiver</code>一样。说不出来具体是哪里不清楚，但总感觉隐隐约约有些怪怪的？总感觉相互之间接口有点混乱，对它们之间是怎么交互的一概不知。我想这是由于我们是自底向上实现TCP协议所带来的问题。希望这种感觉在实现完<code>TCPConnection</code>之后可以好转吧。</p>
<p><code>TCPReceiver</code>的主要任务是把segment拼接成字节流，以及维护即将要告知<code>TCPSender</code>的ackno和拥塞窗口大小。而<code>TCPSender</code>的作用就是把字节流切成segment，并且根据ackno和拥塞窗口大小，进行数据的填充以及超时重传的管理。可以看到，它们是对偶的关系。</p>
<h3 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h3><p>看完指导书以及各种接口定义可以得知，我们需要：</p>
<ol>
<li><p>增加成员变量</p>
<ol>
<li><p>window_size    拥塞窗口的大小</p>
</li>
<li><p>ackono      记录当前收到的最大ackno</p>
</li>
<li><p>ticks           记录sender从出生到现在的时钟滴答</p>
</li>
<li><p>tmp_size    记录tmp_segments  中的数据字节数（注意算上SYN和FIN）</p>
</li>
<li><p>tmp_segments  暂存segment，等待收到ack</p>
<p>数据结构：</p>
<p>list，自定义struct，结构体内有</p>
<ul>
<li>TCPSegment</li>
<li>seqno  记录该segment的起始数据的seq</li>
<li>data_size    记录该segment携带数据的长度</li>
</ul>
</li>
<li><p>cons_retran  记录连续的超时重传次数</p>
</li>
<li><p>syn    标记当前是否为第一个segment</p>
</li>
<li><p>fin</p>
</li>
<li><p>rto    记录当前的RTO</p>
</li>
<li><p>timer_start    记录timer是否等待中</p>
</li>
<li><p>timer_ticks     记录timer开启时的时间</p>
</li>
</ol>
</li>
<li><p>实现一个定时函数</p>
<p>第一次从bytestream取出数据包装为segment的时候（也即发送SYN报文）开启它，当所有data都收到ack的时候（也即FIN报文也被成功ACK）关闭它</p>
<p>应该在ticks中被调用</p>
<blockquote>
<p>Every time a segment containing data (nonzero length in sequence space) is sent (whether it’s the first time or a retransmission), if the timer is not running, <strong>start it</strong> <strong>running</strong> so that it will expire after RTO milliseconds.</p>
</blockquote>
<p>当timer触发时，我们需要重传tmp_segments  队列头。</p>
<p>如果空间足够，直接重传就行了，然后double RTO，然后用RTO reset timer，然后再次启动timer。</p>
<p>如果空间不足够，只做上面那个的后两步，也即reset timer，然后再次启动timer。</p>
</li>
<li><p><code>ack_received</code></p>
<ol>
<li><p>更新window_size和ackno</p>
</li>
<li><p>重置超时重传</p>
<p>如果接收到的ackno比以前的大，则重置RTO，重启timer（如果tmp_segments不为空），重置cons_retran  </p>
</li>
<li><p>从tmp_segments中删除元素</p>
</li>
<li><p>调用<code>fill_window</code></p>
</li>
</ol>
</li>
<li><p><code>fill_window</code></p>
<p>如果window_size - tmp_size &lt;= 0 或者 byte stream空，则什么也不做</p>
<p>否则根据syn和fin标记创建一个new segment，然后写入out stream</p>
<blockquote>
<p> no bigger than the value given by TCPConfig::MAX PAYLOAD SIZE (1452 bytes)</p>
</blockquote>
<blockquote>
<p>If the receiver has announced a window size of zero, the fifill window method should act like the window size is <strong>one</strong>. </p>
</blockquote>
</li>
</ol>
<h3 id="细节补充"><a href="#细节补充" class="headerlink" title="细节补充"></a>细节补充</h3><p>实现起来虽然很复杂，但思路确实很简单，正确思路和初见思路差不多，指导书写得很好很详细【以至于一开始我被指导书这么多内容给吓到了】。在这里只记录点实现过程中遇到的一些小错误以及我各个部分的实现细节补充。</p>
<h4 id="timer实现"><a href="#timer实现" class="headerlink" title="timer实现"></a>timer实现</h4><p>指导书的建议是实现一个类，但是我太懒了（）而且确实这个timer的状态也很少，因而我就直接把它写在sender里面了。</p>
<h4 id="SYN报文是否可以带数据"><a href="#SYN报文是否可以带数据" class="headerlink" title="SYN报文是否可以带数据"></a>SYN报文是否可以带数据</h4><p>此实验未涉及这个。本次全部的测试用例都是SYN报文不携带数据的情况。【因为发出syn报文之后才将window_size设置为非0情况】</p>
<p>如果需要SYN报文不携带数据，可以在<code>fill_window</code>中把这句话：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(_stream.<span class="built_in">buffer_empty</span>() || remaining == <span class="number">0</span>)) &#123;</span><br></pre></td></tr></table></figure>

<p>修改为这句话：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!segment.<span class="built_in">header</span>().syn&amp;&amp;!(_stream.<span class="built_in">buffer_empty</span>() || remaining == <span class="number">0</span>)) &#123;</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSender</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// our initial sequence number, the number for our SYN.</span></span><br><span class="line">    WrappingInt32 _isn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// outbound queue of segments that the TCPSender wants sent</span></span><br><span class="line">    std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retransmission timer for the connection</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _initial_retransmission_timeout;<span class="comment">// 初始的超时重传时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// outgoing stream of bytes that have not yet been sent</span></span><br><span class="line">    ByteStream _stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the (absolute) sequence number for the next byte to be sent</span></span><br><span class="line">    <span class="type">uint64_t</span> _next_seqno&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">OutSegment</span> &#123; <span class="comment">// outstanding segment的包装类</span></span><br><span class="line">        TCPSegment segment;</span><br><span class="line">        <span class="type">uint64_t</span> seqno;</span><br><span class="line">        <span class="type">size_t</span> data_size;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::list&lt;OutSegment&gt; tmp_segments&#123;&#125;;<span class="comment">// 内部存储结构</span></span><br><span class="line">    <span class="type">size_t</span> tmp_size = <span class="number">0</span>;<span class="comment">// 存储结构中含有的segment的总字节数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意此处一定要初始化为1</span></span><br><span class="line">    <span class="type">size_t</span> window_size = <span class="number">1</span>;<span class="comment">// 拥塞窗口大小</span></span><br><span class="line">    <span class="type">uint64_t</span> ackno = <span class="number">0</span>;<span class="comment">// 最大的ackno</span></span><br><span class="line">    <span class="type">size_t</span> ticks = <span class="number">0</span>;<span class="comment">// 从出生到当前经过的时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cons_retran = <span class="number">0</span>;  <span class="comment">// 超时重传连续次数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rto;<span class="comment">// 当前超时重传时间</span></span><br><span class="line">    <span class="type">bool</span> timer_start = <span class="literal">false</span>;<span class="comment">// 超时重传timer是否开启</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> timer_ticks = <span class="number">0</span>;<span class="comment">// timer开启时的时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> syn = <span class="literal">false</span>;<span class="comment">// 是否发送了SYN报文</span></span><br><span class="line">    <span class="type">bool</span> fin = <span class="literal">false</span>;<span class="comment">// 是否发送了FIN报文</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send_empty_rst_segment</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send_empty_ack_segment</span><span class="params">(WrappingInt32 t_ackno)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fully_acked</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _next_seqno == ackno; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TCPSender::<span class="built_in">TCPSender</span>(<span class="type">const</span> <span class="type">size_t</span> capacity, <span class="type">const</span> <span class="type">uint16_t</span> retx_timeout, <span class="type">const</span> std::optional&lt;WrappingInt32&gt; fixed_isn)</span><br><span class="line">    : _isn(fixed_isn.<span class="built_in">value_or</span>(WrappingInt32&#123;<span class="built_in">random_device</span>()()&#125;))</span><br><span class="line">    , _initial_retransmission_timeout&#123;retx_timeout&#125;</span><br><span class="line">    , _stream(capacity)</span><br><span class="line">    , rto&#123;retx_timeout&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tmp_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽可能地创造segment并且填充到segment output中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// should act like the window size is one</span></span><br><span class="line">    <span class="type">size_t</span> t_win_size = window_size == <span class="number">0</span> ? <span class="number">1</span> : window_size;</span><br><span class="line">    <span class="type">size_t</span> remaining = t_win_size - tmp_size;</span><br><span class="line">    <span class="comment">// 防止数值溢出的情况</span></span><br><span class="line">    <span class="keyword">if</span> (t_win_size &lt; tmp_size)</span><br><span class="line">        remaining = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill as possible</span></span><br><span class="line">    <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// create and fill in a segment</span></span><br><span class="line">        TCPSegment segment = <span class="built_in">TCPSegment</span>();</span><br><span class="line">        <span class="comment">// 如果处于CLOSED状态</span></span><br><span class="line">        <span class="keyword">if</span> (!syn) &#123;</span><br><span class="line">            <span class="comment">// 转移到SYN_SENT状态</span></span><br><span class="line">            <span class="comment">// first segment</span></span><br><span class="line">            segment.<span class="built_in">header</span>().syn = <span class="literal">true</span>;</span><br><span class="line">            segment.<span class="built_in">header</span>().seqno = _isn;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">            syn = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// should start the timer here</span></span><br><span class="line">            rto = _initial_retransmission_timeout;</span><br><span class="line">            timer_start = <span class="literal">true</span>;</span><br><span class="line">            timer_ticks = ticks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fill in the payload</span></span><br><span class="line">        <span class="keyword">if</span> (!segment.<span class="built_in">header</span>().syn &amp;&amp; !(_stream.<span class="built_in">buffer_empty</span>() || remaining == <span class="number">0</span>)) &#123;</span><br><span class="line">            string data = _stream.<span class="built_in">read</span>(<span class="built_in">min</span>(remaining, TCPConfig::MAX_PAYLOAD_SIZE));</span><br><span class="line">            remaining -= data.<span class="built_in">length</span>();</span><br><span class="line">            Buffer buf = <span class="built_in">Buffer</span>(<span class="built_in">move</span>(data));</span><br><span class="line">            segment.<span class="built_in">payload</span>() = buf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转移到FIN_SENT状态</span></span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !fin &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// last segment</span></span><br><span class="line">            segment.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">            fin = <span class="literal">true</span>;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// segment为空（不为SYN、FIN，也不携带任何数据）</span></span><br><span class="line">        <span class="keyword">if</span> (segment.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        segment.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);</span><br><span class="line">        _next_seqno += segment.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">        <span class="comment">// push into the outstanding segments</span></span><br><span class="line">        tmp_segments.<span class="built_in">push_back</span>(</span><br><span class="line">            &#123;segment, <span class="built_in">unwrap</span>(segment.<span class="built_in">header</span>().seqno, _isn, _next_seqno), segment.<span class="built_in">length_in_sequence_space</span>()&#125;);</span><br><span class="line">        tmp_size += segment.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">        <span class="comment">// push into the segment out queue</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ack, <span class="type">const</span> <span class="type">uint16_t</span> wind_size)</span> </span>&#123;</span><br><span class="line">    window_size = wind_size;</span><br><span class="line">    <span class="type">uint64_t</span> a_ack = <span class="built_in">unwrap</span>(ack, _isn, ackno);</span><br><span class="line">    <span class="keyword">if</span> (a_ack &gt; _next_seqno)</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// impossible ack is ignored</span></span><br><span class="line">    <span class="keyword">if</span> (a_ack &gt; ackno) &#123;</span><br><span class="line">        <span class="comment">// reset the retransmission</span></span><br><span class="line">        rto = _initial_retransmission_timeout;</span><br><span class="line">        timer_ticks = ticks;</span><br><span class="line">        cons_retran = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// erase elements from the tmp_segments</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = tmp_segments.<span class="built_in">begin</span>(); it != tmp_segments.<span class="built_in">end</span>();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a_ack &gt;= it-&gt;seqno + it-&gt;data_size) &#123;</span><br><span class="line">                tmp_size -= (it-&gt;segment).<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">                <span class="comment">// 如果FIN报文被成功接收，就关闭timer</span></span><br><span class="line">                <span class="comment">// FIN_ACKED</span></span><br><span class="line">                <span class="keyword">if</span> (it-&gt;segment.<span class="built_in">header</span>().fin)</span><br><span class="line">                    timer_start = <span class="literal">false</span>;</span><br><span class="line">                it = tmp_segments.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                it++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ackno = a_ack;</span><br><span class="line">    <span class="built_in">fill_window</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ticks &gt; ticks + ms_since_last_tick) &#123;</span><br><span class="line">        <span class="comment">// 进行简单的溢出处理，还是有可能溢出</span></span><br><span class="line">        ticks -= timer_ticks;</span><br><span class="line">        timer_ticks = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ticks += ms_since_last_tick;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timer_start &amp;&amp; ticks &gt; timer_ticks &amp;&amp; ticks - timer_ticks &gt;= rto) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tmp_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// resend</span></span><br><span class="line">            _segments_out.<span class="built_in">push</span>(tmp_segments.<span class="built_in">front</span>().segment);</span><br><span class="line">            <span class="keyword">if</span> (window_size != <span class="number">0</span>) &#123;</span><br><span class="line">                cons_retran++;</span><br><span class="line">                rto *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer_ticks = ticks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cons_retran; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  在TCPConnection中被使用的辅助方法们  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TCPSegment segment = <span class="built_in">TCPSegment</span>();</span><br><span class="line">    segment.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_empty_ack_segment</span><span class="params">(WrappingInt32 t_ackno)</span> </span>&#123;</span><br><span class="line">    TCPSegment segment = <span class="built_in">TCPSegment</span>();</span><br><span class="line">    segment.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);</span><br><span class="line">    segment.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">    segment.<span class="built_in">header</span>().ackno = t_ackno;</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_empty_rst_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TCPSegment segment = <span class="built_in">TCPSegment</span>();</span><br><span class="line">    segment.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);</span><br><span class="line">    segment.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Lab0</title>
    <url>/2023/02/25/cs144$lab0/</url>
    <content><![CDATA[<h1 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a>Lab0</h1><blockquote>
<p>本次实验一直在强调的一点就是，TCP的功能是将底层的零散数据包，拼接成一个reliable in-order的byte stream。这个对我来说非常“振聋发聩”（夸张了233），以前只是背诵地知道TCP的可靠性，这次我算是第一次知道了所谓“可靠”究竟可靠在哪：一是保证了序列有序性，二是保证了数据不丢失（从软件层面）。</p>
<p>还有一个就是大致了解了cs144的主题：实现TCP协议。也就是说，运输层下面的那些层是不用管的吗？不过这样也挺恰好，我正好在学校的实验做过对下面这些层的实现了，就差一个TCP23333这样一来，我的协议栈就可以完整了。</p>
</blockquote>
<blockquote>
<p>本次实验与TCP的关系：</p>
<p>在我们的<code>webget</code>实现中，正是由于TCP的可靠传输，才能使我们的http request正确地被服务器接收，才能使服务器的response正确地被我们接收打印。</p>
<p>而在<code>ByteStream</code>中，我们也做了跟TCP类似的工作：接收substring，并且将它们拼接为in-order的byte stream【由于在内存中/单线程，所以这个工作看起来非常简单】：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(is_input_end == <span class="literal">false</span>&amp;&amp;pointer&lt;length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buffer.<span class="built_in">size</span>() == capacity)   <span class="keyword">break</span>;</span><br><span class="line">    buffer.<span class="built_in">push_back</span>(data[pointer]);</span><br><span class="line">    pointer++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Fetch-a-Web-page"><a href="#Fetch-a-Web-page" class="headerlink" title="Fetch a Web page"></a>Fetch a Web page</h2><p>主要是介绍了<code>telnet</code>指令</p>
<p><img src="/2023/02/25/cs144/194758.png" alt="屏幕截图 2023-02-23 194758"></p>
<h2 id="Send-yourself-an-email"><a href="#Send-yourself-an-email" class="headerlink" title="Send yourself an email"></a>Send yourself an email</h2><p>用的是telnet带smtp参</p>
<h2 id="Listening-and-connecting"><a href="#Listening-and-connecting" class="headerlink" title="Listening and connecting"></a>Listening and connecting</h2><p>上面的telnet是一个client program。接下来我们要把自己放在server的位置上。</p>
<p>用的是<code>netcat</code>指令。</p>
<p><img src="/2023/02/25/cs144/image-20230223202202509.png" alt="image-20230223202202509"></p>
<h2 id="Use-socket-to-write-webget"><a href="#Use-socket-to-write-webget" class="headerlink" title="Use socket to write webget"></a>Use socket to write webget</h2><p>这个确实不难，就是这个地方有点坑：</p>
<blockquote>
<p>Please note that in HTTP, each line must be ended with “\r\n” (it’s not sufficient to use just “\n” or endl).</p>
</blockquote>
<p>导致我跟400 Bad Request大眼瞪小眼了好久。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">	TCPSocket sock;</span><br><span class="line">    string tmp;</span><br><span class="line"><span class="comment">//    sock.set_blocking(true);// 默认情况下即为true</span></span><br><span class="line">    sock.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host,<span class="string">&quot;http&quot;</span>));</span><br><span class="line">    sock.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span> + </span><br><span class="line">               host + <span class="string">&quot;\r\nConnection: close\r\n\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((tmp = sock.<span class="built_in">read</span>(<span class="number">1</span>)) != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        cout &lt;&lt; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	上面那个写法不大规范，更规范的写法：</span></span><br><span class="line"><span class="comment">    while(!sock.eof())&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; sock.read(1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    sock.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一点值得注意的是，当我这样时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TCPSocket sock;</span><br><span class="line">   sock.<span class="built_in">set_blocking</span>(<span class="literal">false</span>);</span><br><span class="line">   sock.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host,<span class="string">&quot;http&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>会报错<code>Operation now in progress</code>。</p>
<blockquote>
<p><a href="https://blog.csdn.net/liujiakunit/article/details/9791461">关于socket通信中在connect()遇到的Operation now in progress错误</a></p>
<p>遇到此错误是因为将在connect()函数之前将套接字socket设为了非阻塞模式。改为在connect()函数之后设置即可。</p>
</blockquote>
<p>我觉得这个实验设计得挺好的，写的时候感觉很有意思。我推荐看下 <a href="https://github.com/shootfirst/CS144/blob/main/lab-0/apps/webget.cc">https://github.com/shootfirst/CS144/blob/main/lab-0/apps/webget.cc</a> 里的注释，写得很好很规范，让我明白了很多本来没搞懂的地方，比如说<code>shutdown</code>的用法。</p>
<h2 id="An-in-memory-reliable-byte-stream"><a href="#An-in-memory-reliable-byte-stream" class="headerlink" title="An in-memory reliable byte stream"></a>An in-memory reliable byte stream</h2><blockquote>
<p>实现一个<code>ByteStream</code>类，可以通过<code>read</code>和<code>write</code>对其两端进行读写。是单线程程序，因而无需考虑阻塞。</p>
</blockquote>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>这东西其实是很简单的，但是我还是花了一定的时间，主要原因有两点，一是我不懂c++，所以一些地方错得我很懵逼，二是因为我是sb。</p>
<p>下面就记录下三个我印象比较深刻的错误吧。</p>
<h5 id="错误1-member-initialization-list"><a href="#错误1-member-initialization-list" class="headerlink" title="错误1 member initialization list"></a>错误1 member initialization list</h5><p>构造函数我一开始是这么写的：</p>
<p><img src="/2023/02/25/cs144/image-20230224113108208.png" alt="image-20230224113108208"></p>
<p>结果爆出了这样的错：</p>
<p><img src="/2023/02/25/cs144/image-20230224112056879.png" alt="image-20230224112056879"></p>
<p>搜了半天也没看懂怎么回事，去求助了下某场外c艹选手，才知道了还有成员变量初始化列表这玩意，这个东西似乎比较高效安全。</p>
<p>于是我改成了这么写：</p>
<p><img src="/2023/02/25/cs144/image-20230224113333962.png" alt="image-20230224113333962"></p>
<p>它告诉我<code>buffer</code>也得初始化。于是我又这么写：</p>
<p><img src="/2023/02/25/cs144/image-20230224113358856.png" alt="image-20230224113358856"></p>
<p>又是奇奇怪怪的错误，说明vector不能这么初始化。</p>
<p>场外c艹选手看到了这个：</p>
<p><img src="/2023/02/25/cs144/image-20230224113456432.png" alt="image-20230224113456432"></p>
<p>所以说vector应该这样初始化：</p>
<p><img src="/2023/02/25/cs144/image-20230224113549970.png" alt="image-20230224113549970"></p>
<h5 id="错误2-使用了vector作为buffer的载体"><a href="#错误2-使用了vector作为buffer的载体" class="headerlink" title="错误2 使用了vector作为buffer的载体"></a>错误2 使用了<code>vector</code>作为buffer的载体</h5><p>应该使用的是可以从front删除数据的数据结构，比如说deque。【vector也行，但是效率较低】</p>
<p>具体为什么，可以以数据流为cat为例。执行<code>peek(2)</code>时，使用vector得到的是at，使用deque得到的是ca。</p>
<h5 id="错误3-错误地阻塞"><a href="#错误3-错误地阻塞" class="headerlink" title="错误3 错误地阻塞"></a>错误3 错误地阻塞</h5><p>一开始在<code>write</code>方法，我是这么写的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> length = data.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">while</span>(is_input_end == <span class="literal">false</span>&amp;&amp;pointer&lt;length)&#123;</span><br><span class="line">    <span class="keyword">while</span>(buffer.<span class="built_in">size</span>() == capacity);</span><br><span class="line">    buffer.<span class="built_in">push_back</span>(data[pointer]);</span><br><span class="line">    pointer++;</span><br><span class="line">    total_write ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果就是测试用例Timeout。我找了很久都不知道错在了哪，最后求助了场外观众【罪过……这次实验太不独立了】，学着他把length改成了这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> length = <span class="built_in">min</span>(data.<span class="built_in">length</span>(),capacity-buffer.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<p>发现成了。</p>
<p>我去看了看testbench，猜测应该是因为阻塞了，我还以为是deque自身会阻塞【是的，我完全没注意到自己顺手把阻塞写了下去】，查了半天发现不会，最后才发现是自己不小心搞错了呃呃…………</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="头文件声明"><a href="#头文件声明" class="headerlink" title="头文件声明"></a>头文件声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This doesn&#x27;t need to be a sophisticated data structure at</span></span><br><span class="line">    <span class="comment">// all, but if any of your tests are taking longer than a second,</span></span><br><span class="line">    <span class="comment">// that&#x27;s a sign that you probably want to keep exploring</span></span><br><span class="line">    <span class="comment">// different approaches.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> total_write;</span><br><span class="line">    <span class="type">size_t</span> total_read;</span><br><span class="line">    <span class="type">bool</span> is_input_end;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> capacity;</span><br><span class="line">    deque&lt;<span class="type">char</span>&gt; buffer;</span><br></pre></td></tr></table></figure>

<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> cap) : <span class="built_in">total_write</span>(<span class="number">0</span>),<span class="built_in">total_read</span>(<span class="number">0</span>),<span class="built_in">is_input_end</span>(<span class="literal">false</span>),<span class="built_in">capacity</span>(cap),<span class="built_in">buffer</span>()&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Write a string of bytes into the stream. Write as many</span></span><br><span class="line">    <span class="comment">//! as will fit, and return how many were written.</span></span><br><span class="line">    <span class="comment">//! \returns the number of bytes accepted into the stream</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is_input_end == <span class="literal">true</span>)    is_input_end = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> pointer = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> length = data.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span>(is_input_end == <span class="literal">false</span>&amp;&amp;pointer&lt;length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buffer.<span class="built_in">size</span>() == capacity)   <span class="keyword">break</span>;</span><br><span class="line">        buffer.<span class="built_in">push_back</span>(data[pointer]);</span><br><span class="line">        pointer++;</span><br><span class="line">    &#125;</span><br><span class="line">    total_write+=pointer;</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//! Peek at next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        i++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Remove bytes from the buffer</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    total_read+=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string res = <span class="built_in">peek_output</span>(len);</span><br><span class="line">    <span class="built_in">pop_output</span>(len);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123;is_input_end = <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_input_end; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_input_end &amp;&amp; buffer.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> total_write; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> total_read; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> capacity - buffer.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Lab1  StreamReassembler</title>
    <url>/2023/02/25/cs144$lab1/</url>
    <content><![CDATA[<h1 id="Lab1-StreamReassembler"><a href="#Lab1-StreamReassembler" class="headerlink" title="Lab1   StreamReassembler"></a>Lab1   StreamReassembler</h1><blockquote>
<p>TCP managed to produce a pair of <em>reliable in-order byte streams</em> (one from you to the server, and one in the opposite direction), even though the underlying network only delivers “best-effort” datagrams. </p>
<p>You also implemented the byte-stream abstraction yourself, in memory within one computer. </p>
<p>Over the next four weeks, you’ll implement TCP, to <strong>provide the byte-stream abstraction between a pair of computers</strong> separated by an unreliable datagram network.</p>
</blockquote>
<p>我们的任务是实现一个<code>StreamReassembler</code>。它的具体功能相信看下数据传输路径就很明了了：</p>
<blockquote>
<p>receiver的数据传输路径：network → StreamReassembler整流 →（write）ByteStream（read）→ app</p>
</blockquote>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>先放个通关截图在这。</p>
<p><img src="/2023/02/25/cs144/image-20230225192145829.png" alt="image-20230225192145829"></p>
<p>这个实验我前前后后总共做了大概有9h+……写我下面放上来的屎山代码可能大概用了5h+。我总共使用了140+行代码实现我的核心函数<code>push_substring</code>。</p>
<p>整个过程，包括思路和代码都十分复杂，但最后的表现相比于别人好像也没好到哪去，让我不禁怀疑自己是不是想错了……以及，这样的复杂性也给我带来很多担忧，担心会不会在以后的实验因为这个的bug而寄，毕竟我在写笔记的同时都已经找到了不止一个bug了（）希望人没事。</p>
<p>总而言之，先把我的思路和一步步的代码拆解放上来吧。</p>
<blockquote>
<p>后记：</p>
<p>不得不说，这个东西太健壮了，给后面的<code>TCPReceiver</code>省去了好多功夫……</p>
<p>比如说，<code>TCPReceiver</code>无需考虑ack怎么算，因为这里就帮你算好了；<code>TCPReceiver</code>无需考虑数据包重叠或者重复，因为这里已经考虑到这个情况了；<code>TCPReceiver</code>无需担忧FIN是否会因为容量满丢弃一部分数据而未达到真正的FIN，只需调用其相关接口判断就行。</p>
<p>它虽然帮助了<code>TCPReceiver</code>那么多，但很神奇的是，它们的耦合性并不高。你把<code>StreamReassembler</code>单独拆出来看，左看右看，它都<u>确实仅仅只是一个健壮的区间合并算法</u>。</p>
<p>这得益于实验设计的精良，得益于设计<code>TCPReceiver</code>时的野心。这些边界情况都这么麻烦，而且都只与区间合并有关，那么我们为什么不直接把它抽象进区间合并进行处理呢？这种想法极富胆识，事实证明最后也确实能实现。这种设计理念让我受益很深。</p>
</blockquote>
<h2 id="为什么我的思路那么复杂"><a href="#为什么我的思路那么复杂" class="headerlink" title="为什么我的思路那么复杂"></a>为什么我的思路那么复杂</h2><p>看了<a href="https://github.com/shootfirst/CS144/">感恩</a>的代码，我发现我俩的大题思路其实差不多是一模一样的，都是先进行两轮的区间合并，然后再处理但为啥我看起来就那么复杂呢？</p>
<p>一是题意理解问题。</p>
<p>我发现他对<code>_capacity</code>的理解跟我的理解不一样emmm……</p>
<p>额好像怪我没认真看指导书的图。</p>
<p><img src="/2023/02/25/cs144/image-20230225232723083-1677339210527-2.png" alt="image-20230225232723083-1677339210527-2"></p>
<p>我理解的capacity：绿色部分和红色部分的净含量</p>
<p>似乎是真正的capacity：绿色部分+红色部分+空部分，也就是说capacity只是一个跟index差不多的索引下标…………</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// out of bound</span></span><br><span class="line"><span class="keyword">if</span> (start &gt;= hope_to_rec + _capacity - _output.<span class="built_in">buffer_size</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这也是很合理的，很符合其语义。我这样错误理解的话，相当于是内存开销增大了，丢包减少了。不过暂时等之后寄掉了再回来改吧。</p>
<blockquote>
<p>UPDATE: 确实寄掉了，并且已经改过来了，也不复杂，只需要添加对<code>right</code>边界的处理就行。【指去掉超出<code>start+capacity</code>的部分。】</p>
</blockquote>
<p>二是代码规范问题。</p>
<p>首先他代码规范性强，看起来非常舒服。其次他会用类似<code>upper_bound()</code>这样的函数（反观我压根没想起来），这样就显得比我的循环简洁了很多很多。</p>
<p>三是设计问题。</p>
<p>他用的是<code>map</code>我用的是<code>set</code>。确实是map比较合理，它既有find功能也兼具了有序的特性。</p>
<h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>我们要做的，是将零散的数据包拼接成完整的字节流，并且将整流过的数据送入<code>ByteStream</code>中，这通过核心函数<code>push_substring</code>实现。我们可以先来看看<code>push_substring</code>的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>;</span><br></pre></td></tr></table></figure>

<p><code>data</code>为数据包，<code>index</code>为<code>data</code>中第一个字符在整个字节流的下标，<code>eof</code>用来标识这是字节流的最后一个数据包。</p>
<blockquote>
<p>详细说明：</p>
<p>比方说有字节流“abcdefg”，则合法的参数对有如：{“abc”,0,0},{“cdef”,2,0},{“g”,6,1}</p>
</blockquote>
<p>通俗来说，我们这个函数的功能就是，把一堆起始下标为<code>index</code>的<code>data</code>（无序、可能重叠）拼接为一个完整的字节流。</p>
<p>听起来有没有觉得很耳熟？是的，我认为这正是“区间合并”问题。我接下来便通过区间合并的思想，对问题进行如下数据结构以及算法的设计。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h4><p>由于是区间合并问题，所以就先需要定义区间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> left;   <span class="comment">// 当前data位于总体的左index（闭）</span></span><br><span class="line">    <span class="type">size_t</span> right;  <span class="comment">// 右index（开）</span></span><br><span class="line">    string data;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;b) <span class="type">const</span> &#123; <span class="keyword">return</span> left &lt; b.left; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>我们需要维护一个左端点升序的区间集合，故使用内部红黑树实现的有序集合set。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;node&gt; buffer;   <span class="comment">// 存储结构</span></span><br></pre></td></tr></table></figure>

<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>我们要做的，是对数据包进行整流，并且把整流过的部分输送到<code>ByteStream</code>中。由于存储结构存在<code>_capacity</code>的上限，因而，我们需要尽可能早地把存储结构中已经整流好的数据送入<code>ByteStream</code>中。</p>
<p>那么，如何定义“已经整流好的数据”呢？它需要满足跟“之前已经整流好了的数据”的有序性，也即，比方说[0,1000]已经整流完毕送入app，那么下一个送入app的数据一定满足<code>index=1001</code>。</p>
<p>因而，我们可以维护一个变量<code>left_bound</code>，表示下一个将被app接受的数据的index（如上例的1001）。为了达到“尽早”目的，我们需要在每次<code>push_substring</code>执行完区间合并之后，检查<code>buffer</code>的第一个区间的左端点是否与<code>left_bound</code>相等，是的话则将第一个区间写入<code>ByteStream</code>，不是的话就什么也不做。</p>
<p>因而，在<code>push_substring</code>中，对于一个新来的数据包，我们大致需要进行以下几步：</p>
<ol>
<li>将参数所给的区间( <code>[index, index+data.length())</code> )并入区间集合<code>buffer</code>中</li>
<li>查看是否需要<code>ByteStream</code></li>
</ol>
<h4 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h4><h5 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h5><p>问题可抽象为：</p>
<blockquote>
<p>给定一个有序区间集合<code>buffer</code>，以及一个小区间<code>node</code>，你需要把<code>node</code>塞进<code>buffer</code>里。</p>
<p>Example： buffer = {[1,3),[5,7)} , node = [6,8) 输出：buffer = {[1,3), [5,8)}</p>
</blockquote>
<h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><p>判断区间重叠统一只检查左端点。注意，两次重叠的判断条件不一样，是因为相对性发生了改变。第一次相当于node的左端点在buffer[i]中，第二次相当于buffer[i]的左端点在node中。</p>
<ol>
<li><p>对<code>buffer</code>进行第一轮扫描</p>
<p>如果node与buffer[i]产生重叠（<code>(left &gt;= it-&gt;left &amp;&amp; left &lt;= it-&gt;right)</code>），那么更新node为node∪buffer[i]，并且将buffer[i]从buffer中删去。</p>
<p>在第一次找到重叠的区间，就应该break退出第一轮循环。</p>
</li>
<li><p>对<code>buffer</code>进行第二轮扫描</p>
<p>如果node与buffer[i]产生重叠（<code> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right)</code>），那么更新node为node∪buffer[i]，并且将buffer[i]从buffer中删去。</p>
</li>
</ol>
<p>我们在合并区间时，不仅需要对<code>struct node</code>的左端点<code>left</code>和右端点<code>right</code>进行更新，还需要对其数据域<code>data</code>也进行合并拼接。我们维护变量<code>res</code>作为维护的目标区间的数据域。对于res，我们应该进行如下操作：</p>
<ol>
<li><p>初始化为data</p>
</li>
<li><p>除去[left, left_bound)这一区间内的数据</p>
<p>这部分数据我们已经整流过并且写入<code>ByteStream</code></p>
</li>
<li><p>在两轮合并中对其进行正确拼接</p>
</li>
</ol>
<h5 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h5><p><img src="/2023/02/25/cs144/image-20230225200605175.png" alt="image-20230225200605175"></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> left = index, right = index + data.<span class="built_in">length</span>();  <span class="comment">// 初始化左右区间</span></span><br><span class="line"><span class="type">size_t</span> o_left = left, o_right = right;               <span class="comment">// keep the original value</span></span><br><span class="line">node tmp = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right &lt; left_bound)	<span class="keyword">return</span>;                <span class="comment">// must be duplicated</span></span><br><span class="line">left = left &lt; left_bound ? left_bound : left;  <span class="comment">// 左边已经接受过的数据就不要了</span></span><br><span class="line">string res = data.<span class="built_in">substr</span>(left - o_left, right - left);<span class="comment">// 掐头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开始区间合并。需要扫描两次 */</span></span><br><span class="line"><span class="comment">// 第一次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= it-&gt;left &amp;&amp; left &lt;= it-&gt;right) &#123; <span class="comment">// 区间重叠</span></span><br><span class="line">        <span class="type">size_t</span> r = right,l = left;</span><br><span class="line">        <span class="comment">// 更新左右端点</span></span><br><span class="line">        right = <span class="built_in">max</span>(right, it-&gt;right);</span><br><span class="line">        left = <span class="built_in">min</span>(left, it-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= it-&gt;right) <span class="comment">// 如果目标区间被包裹在it内</span></span><br><span class="line">            <span class="comment">// res需要更新为it头+data掐头后的全长+it尾，也即将it中间重叠部分用data替换</span></span><br><span class="line">            res = it-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, l - it-&gt;left) + data.<span class="built_in">substr</span>(l - o_left) +</span><br><span class="line">            it-&gt;data.<span class="built_in">substr</span>(r - it-&gt;left, it-&gt;right - r);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            res = it-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, l - it-&gt;left) + data.<span class="built_in">substr</span>(l - o_left);</span><br><span class="line">        <span class="comment">// 删除原来的结点</span></span><br><span class="line">        buffer.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;right &lt;= right);<span class="comment">// it这个区间被包含在目标区间内，则什么也不做</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 需要加上it的尾</span></span><br><span class="line">            res += it-&gt;data.<span class="built_in">substr</span>(right - it-&gt;left, it-&gt;right - right);</span><br><span class="line">            <span class="comment">// 更新右端点</span></span><br><span class="line">            right = it-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        buffer.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将维护区间插入区间集合</span></span><br><span class="line">tmp = &#123;left, right, res&#125;;</span><br><span class="line">buffer.<span class="built_in">insert</span>(tmp);</span><br></pre></td></tr></table></figure>

<h4 id="写入ByteStream"><a href="#写入ByteStream" class="headerlink" title="写入ByteStream"></a>写入<code>ByteStream</code></h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>我们需要检查buffer内的第一个区间，如果其左端点与left_bound相等，则把第一个区间填入<code>ByteStream</code>，然后更新left_bound，从buffer中删去该区间；如果不相等（只可能是left &gt; left_bound）则什么也不做。</p>
<p>在把区间数据填入<code>ByteStream</code>的过程中，可能造成<code>ByteStream</code>满。因而我们就只能填入第一个区间内的一部分数据，更新left_bound，将第一个区间的剩余数据继续存在buffer中。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> iterator = buffer.<span class="built_in">begin</span>();  </span><br><span class="line">iterator = buffer.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// write into the ByteStream</span></span><br><span class="line"><span class="keyword">if</span> (iterator != buffer.<span class="built_in">end</span>() &amp;&amp; iterator-&gt;left == left_bound) &#123;</span><br><span class="line">    <span class="comment">// 防止_output的容量超过</span></span><br><span class="line">    <span class="type">size_t</span> out_rem = _output.<span class="built_in">remaining_capacity</span>();</span><br><span class="line">    <span class="keyword">if</span> (out_rem &lt; iterator-&gt;data.<span class="built_in">length</span>()) &#123; <span class="comment">// ByteStream剩余容量小于第一个区间长度</span></span><br><span class="line">        _output.<span class="built_in">write</span>(iterator-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, out_rem));<span class="comment">// 写入尽量多数据</span></span><br><span class="line">        left_bound = iterator-&gt;left + out_rem;<span class="comment">// 更新左边界</span></span><br><span class="line">        <span class="comment">// 由于iterator只读，因而我们不能直接修改其左端点和data域</span></span><br><span class="line">        tmp = &#123;left_bound, iterator-&gt;right, iterator-&gt;data.<span class="built_in">substr</span>(out_rem)&#125;;</span><br><span class="line">        buffer.<span class="built_in">erase</span>(iterator);</span><br><span class="line">        buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _output.<span class="built_in">write</span>(iterator-&gt;data);</span><br><span class="line">        left_bound = iterator-&gt;right;</span><br><span class="line">        buffer.<span class="built_in">erase</span>(iterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="buffer的最大容量-capacity"><a href="#buffer的最大容量-capacity" class="headerlink" title="buffer的最大容量_capacity"></a>buffer的最大容量_capacity</h4><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>维护“存储结构的容量不超过capacity”这个不变性条件可以说是这个实验最恶心最难的地方……也正是它，让我的代码写成了一坨shit山（）</p>
<p>为什么说它最难最恶心呢？其实它本来也许不算难，但在这个思路下想要保持这个不变性条件，就显得非常地困难。</p>
<p>一开始没过脑子的时候，我觉得这样就行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(data.<span class="built_in">length</span>() + <span class="built_in">unassemble_bytes</span>() &gt; capacity)	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样很明显有两个问题。</p>
<p>一是就算你超过了，你也不能直接丢弃掉data，得把没超过的部分填满。</p>
<p>二是，<code>data.length() + unassemble_bytes()</code>有时，甚至是很多时候，都不会是将data并入buffer之后buffer的容量。因为data和buffer很大概率会存在重叠区间。</p>
<p>那么，你能不能在区间合并完之后，再进行该不变性条件的判断，并且将没超过的部分填满，超过的部分丢弃呢？</p>
<p>答案是，也不能。因为经过两轮合并，你的data和buffer里原有的数据早已你中有我我中有你了，你无法在最后将它们分开，找出data超过capacity的数据并且丢弃它。</p>
<p>因而，头尾都不行的话，唯一的答案就是，<strong>我们只能在两轮区间合并中途，去时刻追踪当前容量是否超过capacity</strong>。</p>
<p>这听起来就令人十分地头大。但事实证明，并不是无法实现的，坚持下去，就算是shit山也能跑起来（）下面便是我的实现思路。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>维护一个变量<code>remaining</code>，表示当前还有多少容量。维护<code>start</code>，表示未判断是否可以写入buffer的数据起点。我们要做的事：</p>
<ol>
<li>初始化remaining为capacity - 当前容量，start为掐头后的left</li>
<li>在第一轮循环中更新start</li>
<li>在第二轮循环中通过start和remaining来判断是否能够写入buffer。尽可能多地写入，把写入不了的部分丢弃。</li>
</ol>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>下面举个例子来说明整个流程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">initial:  </span><br><span class="line">buffer = &#123; [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">5</span>,<span class="number">8</span>],[<span class="number">10</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>] &#125; , capacity = <span class="number">12</span>, remaining = <span class="number">12</span><span class="number">-9</span>=<span class="number">3</span>, data = [<span class="number">2</span>,<span class="number">11</span>], start = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>start为2，是因为data的从2开始的这段数据还不知道能不能被成功存入buffer中。</p>
<p>第一次合并后，buffer = { [5,8],[10,12],[13,14] } ，data=[1,11]，start = 3.</p>
<p>start为3，是因为[2,11]与[1,3]合并，由于[2,3]这段本来就在buffer中，因而可以不用占用remaining，但从3开始这段数据还不知道能不能成功存入buffer中。</p>
<p>在第二轮合并中，首先扫描到[5,8]。由于[start,it-&gt;left]也即[3,5]这段数据长度为2&lt;remaining=3，故而这段数据可以存入buffer，remaining更新为3-2=1，start更新为it-&gt;right=8.</p>
<p>/*</p>
<p>注意，此处无需再对[9,10]进行同样的操作。对于这种情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">buffer = &#123; [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">5</span>,<span class="number">8</span>] &#125; , capacity = <span class="number">12</span>, remaining = <span class="number">12</span><span class="number">-9</span>=<span class="number">3</span>, data = [<span class="number">2</span>,<span class="number">11</span>], start = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>在循环结束的这里已经处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (remaining &lt; right - start) &#123;</span><br><span class="line">    right = remaining + start;</span><br><span class="line">    <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">        is_eof = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*/</p>
<p>然后扫描到[10,12]。由于[start,it-&gt;left]也即[8,10]这段数据长度为2&gt;remaining=1，故而这段数据只能把[8,9]这部分存入buffer。因而，我们把到此为止的[1,9]结点存入buffer，剩下的[10,11]部分直接丢弃，也即直接跳入到最后的写入<code>ByteStream</code>部分。</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> remaining = _capacity - <span class="built_in">unassembled_bytes</span>();  <span class="comment">// how much room left?</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> left = index, right = index + data.<span class="built_in">length</span>();  <span class="comment">// 初始化左右区间</span></span><br><span class="line">    <span class="type">size_t</span> o_left = left, o_right = right;               <span class="comment">// keep the original value</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> start = left;  <span class="comment">// the begin of the unused data-zone of variable data</span></span><br><span class="line">    <span class="comment">// if(remaining == 0)	goto end; // buffer满</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始区间合并。需要扫描两次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= it-&gt;left &amp;&amp; left &lt;= it-&gt;right) &#123;</span><br><span class="line">            right = <span class="built_in">max</span>(right, it-&gt;right);</span><br><span class="line">            left = <span class="built_in">min</span>(left, it-&gt;left);</span><br><span class="line">            <span class="comment">// 说明目标区间完全被包裹，也即目标区间一定可以塞进buffer中</span></span><br><span class="line">            <span class="keyword">if</span> (right == it-&gt;right) 	start = o_right;</span><br><span class="line">            <span class="comment">// 说明仅仅部分重叠，去重部分从it-&gt;right开始</span></span><br><span class="line">            <span class="keyword">else</span>	start = it-&gt;right;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 比remaining满</span></span><br><span class="line">            <span class="comment">// 第一个条件是为了防止unsigned溢出</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;left &gt; start &amp;&amp; remaining &lt; it-&gt;left - start) &#123;</span><br><span class="line">                <span class="comment">// 截取能塞得下的部分</span></span><br><span class="line">                tmp = &#123;left, start + remaining, res.<span class="built_in">substr</span>(<span class="number">0</span>, start - left + remaining)&#125;;</span><br><span class="line">                remaining = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 此时塞进去是肯定不重叠的，因为tmp.right &lt; it-&gt;left</span></span><br><span class="line">                buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">                <span class="comment">// 剩下的直接丢弃</span></span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 塞得下</span></span><br><span class="line">            remaining -= it-&gt;left - start;</span><br><span class="line">            start = it-&gt;right;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界处理</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt; right - start) &#123;</span><br><span class="line">        <span class="comment">// 扔掉塞不下的部分</span></span><br><span class="line">        right = remaining + start;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = &#123;left, right, res&#125;;</span><br><span class="line">    buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    iterator = buffer.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// write into the ByteStream</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="capacity还没结束"><a href="#capacity还没结束" class="headerlink" title="capacity还没结束"></a>capacity还没结束</h4><h5 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h5><p>你以为做到上面那个小标题那样就万无一失了吗？答案是，并不！</p>
<p>我们还有哪里想得不周全呢？考虑这样一个案例，<code>ByteStream</code>未满，但是在更新remaining时发现buffer已满塞不下了。这时候，我们上面的做法是直接扔掉塞不下的部分。但其实，我们还可以查看buffer的一部分数据是否能够再塞进<code>ByteStream</code>，如果能的话，就又能省下一笔空间了！</p>
<p>所以，我们在发现remaining不够时，应该首先检查能不能塞一部分buffer的数据进入<code>ByteStream</code>中用来腾出空间。</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 比remaining满</span></span><br><span class="line">        <span class="comment">// 第一个条件是为了防止unsigned溢出</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;left &gt; start &amp;&amp; remaining &lt; it-&gt;left - start) &#123;</span><br><span class="line">            <span class="comment">// 先看看能不能塞进ByteStream腾空间。需要满足两个条件</span></span><br><span class="line">            <span class="comment">// buffer的第一个区间正好是left_bound</span></span><br><span class="line">            <span class="keyword">if</span> (left == left_bound) &#123;</span><br><span class="line">                <span class="type">size_t</span> out_mem = _output.<span class="built_in">remaining_capacity</span>();</span><br><span class="line">                <span class="comment">// ByteStream有位置</span></span><br><span class="line">                <span class="keyword">if</span> (out_mem &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 腾出的空间很充足，完全可以不改变remaining</span></span><br><span class="line">                    <span class="keyword">if</span> (out_mem &gt;= it-&gt;left - start) &#123;</span><br><span class="line">                        <span class="comment">// 写入ByteStream</span></span><br><span class="line">                        _output.<span class="built_in">write</span>(res.<span class="built_in">substr</span>(<span class="number">0</span>, it-&gt;left - start));</span><br><span class="line">                        <span class="comment">// 更新</span></span><br><span class="line">                        res = res.<span class="built_in">substr</span>(it-&gt;left - start);</span><br><span class="line">                        left_bound = it-&gt;left - start + left;</span><br><span class="line">                        left = left_bound;</span><br><span class="line">                        <span class="comment">// 加上腾出的空间【在ok标签处减掉】</span></span><br><span class="line">                        remaining += it-&gt;left-start;</span><br><span class="line">                        <span class="keyword">goto</span> ok;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 空间不足以完全不改变remaining</span></span><br><span class="line">                        _output.<span class="built_in">write</span>(res.<span class="built_in">substr</span>(<span class="number">0</span>, out_mem));</span><br><span class="line">                        res = res.<span class="built_in">substr</span>(out_mem);</span><br><span class="line">                        left_bound = out_mem + left;</span><br><span class="line">                        left = left_bound;</span><br><span class="line">                        <span class="comment">// 加上腾出的空间</span></span><br><span class="line">                        remaining += out_mem;</span><br><span class="line">                        <span class="comment">// 如果两个加起来就行，则ok</span></span><br><span class="line">                        <span class="keyword">if</span>(it-&gt;left&gt;start &amp;&amp; remaining&gt;=it-&gt;left - start)&#123;</span><br><span class="line">                                <span class="keyword">goto</span> ok;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 否则remaining依然不充足</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 截取能塞得下的部分</span></span><br><span class="line">            tmp = &#123;left, start + remaining, res.<span class="built_in">substr</span>(<span class="number">0</span>, start - left + remaining)&#125;;</span><br><span class="line">            remaining = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 此时塞进去是肯定不重叠的，因为tmp.right &lt; it-&gt;left</span></span><br><span class="line">            buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">            <span class="comment">// 剩下的直接丢弃</span></span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    ok:</span><br><span class="line">        <span class="comment">// 塞得下</span></span><br><span class="line">        remaining -= it-&gt;left - start;</span><br><span class="line">        start = it-&gt;right;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h5><p>因而，在一开始发现remaining满的时候，不能直接goto end。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if(remaining == 0)	goto end; // buffer满</span></span><br></pre></td></tr></table></figure>

<p>因为还得看看<code>ByteStream</code>能不能腾空间。</p>
<h4 id="eof"><a href="#eof" class="headerlink" title="eof"></a>eof</h4><p>对于eof的处理也是需要注意的一个小细节。</p>
<p>我们不能这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (eof)</span><br><span class="line">    _output.<span class="built_in">end_input</span>();</span><br></pre></td></tr></table></figure>

<p>原因有二，一是最后一个数据包有可能是部分丢失，二是整流可能还未结束。</p>
<p>所以我们应该在成员变量中维护<code>is_eof</code>，记录是否收到过最后一个数据包，并且在最后一个数据包部分丢失的时候置它为false。当且仅当<code>is_eof == true</code>且buffer非空时，才能说明输入结束。</p>
<p>相关代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">        is_eof = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 第二次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 此时空间不够，先尝试下能不能写入一部分到_output中</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;left &gt; start &amp;&amp; remaining &lt; it-&gt;left - start) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                tmp = &#123;left, start + remaining, res.<span class="built_in">substr</span>(<span class="number">0</span>, start - left + remaining)&#125;;</span><br><span class="line">                remaining = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">                    is_eof = <span class="literal">false</span>;</span><br><span class="line">                buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">        ok:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (remaining &lt; right - start) &#123;</span><br><span class="line">        right = remaining + start;</span><br><span class="line">        <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">            is_eof = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">end:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 满足两个条件才是真的eof</span></span><br><span class="line">    <span class="keyword">if</span> (is_eof &amp;&amp; buffer.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        is_eof = <span class="literal">false</span>;</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><h3 id="头文件声明"><a href="#头文件声明" class="headerlink" title="头文件声明"></a>头文件声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StreamReassembler</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> left;   <span class="comment">// 当前data位于总体的左index（闭）</span></span><br><span class="line">        <span class="type">size_t</span> right;  <span class="comment">// 右index（开）</span></span><br><span class="line">        string data;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;b) <span class="type">const</span> &#123; <span class="keyword">return</span> left &lt; b.left; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">bool</span> is_eof;        <span class="comment">// 文件的末尾是否接收成功</span></span><br><span class="line">    <span class="type">size_t</span> left_bound;  <span class="comment">// 当前已经成功接收到left_bound之前的数据</span></span><br><span class="line">    set&lt;node&gt; buffer;   <span class="comment">// 存储结构</span></span><br><span class="line"></span><br><span class="line">    ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// used by the TCPReceiver</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_is_eof</span><span class="params">()</span> </span>&#123; is_eof = <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stream_reassembler.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">StreamReassembler::<span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity)</span><br><span class="line">    : <span class="built_in">is_eof</span>(<span class="literal">false</span>), <span class="built_in">left_bound</span>(<span class="number">0</span>), <span class="built_in">buffer</span>(), _output(capacity), _capacity(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">        is_eof = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> unass = <span class="built_in">unassembled_bytes</span>();</span><br><span class="line">    <span class="type">size_t</span> remaining = _capacity &gt; unass ? _capacity - unass : <span class="number">0</span>;  <span class="comment">// how much room left?</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> left = index, right = index + data.<span class="built_in">length</span>();  <span class="comment">// 初始化左右区间</span></span><br><span class="line">    <span class="type">size_t</span> o_left = left, o_right = right;               <span class="comment">// keep the original value</span></span><br><span class="line">    <span class="keyword">auto</span> iterator = buffer.<span class="built_in">begin</span>();                 <span class="comment">// 这些变量在这里声明是为了防止后面goto报错</span></span><br><span class="line">    node tmp = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &lt; left_bound)	<span class="keyword">return</span>;                <span class="comment">// must be duplicated</span></span><br><span class="line">    left = left &lt; left_bound ? left_bound : left;  <span class="comment">// 左边已经接受过的数据就不要了</span></span><br><span class="line">    right = right &lt;= left_bound + _capacity ? right : left_bound + _capacity;  <span class="comment">// 右边越界的也不要</span></span><br><span class="line">    o_right = right;</span><br><span class="line">    string res = data.<span class="built_in">substr</span>(left - o_left, right - left);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> start = left;  <span class="comment">// the begin of the unused data-zone of variable data</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">compare</span>(<span class="string">&quot;&quot;</span>) == <span class="number">0</span> || res.<span class="built_in">compare</span>(<span class="string">&quot;&quot;</span>) == <span class="number">0</span>)	<span class="keyword">goto</span> end;  <span class="comment">// 如果data是空串也直接不要</span></span><br><span class="line">    <span class="keyword">if</span> (o_left &gt;= left_bound + _capacity)	<span class="keyword">goto</span> end;  <span class="comment">// 越界的不要</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始区间合并。需要扫描两次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= it-&gt;left &amp;&amp; left &lt;= it-&gt;right) &#123;</span><br><span class="line">            <span class="type">size_t</span> r = right;</span><br><span class="line">            <span class="type">size_t</span> l = left;</span><br><span class="line">            right = <span class="built_in">max</span>(right, it-&gt;right);</span><br><span class="line">            left = <span class="built_in">min</span>(left, it-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (right == it-&gt;right) &#123;</span><br><span class="line">                start = o_right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = it-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r &lt;= it-&gt;right) &#123;</span><br><span class="line">                res = it-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, l - it-&gt;left) + data.<span class="built_in">substr</span>(l - o_left) +</span><br><span class="line">                      it-&gt;data.<span class="built_in">substr</span>(r - it-&gt;left, it-&gt;right - r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = it-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, l - it-&gt;left) + data.<span class="built_in">substr</span>(l - o_left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除这一步很关键。</span></span><br><span class="line">            buffer.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;left &gt;= left &amp;&amp; it-&gt;left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 此时空间不够，先尝试下能不能写入一部分到_output中</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;left &gt; start &amp;&amp; remaining &lt; it-&gt;left - start) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == left_bound) &#123;</span><br><span class="line">                    <span class="type">size_t</span> out_mem = _output.<span class="built_in">remaining_capacity</span>();</span><br><span class="line">                    <span class="keyword">if</span> (out_mem &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// out的区域本身就很充足</span></span><br><span class="line">                        <span class="keyword">if</span> (out_mem &gt;= it-&gt;left - start) &#123;</span><br><span class="line">                            <span class="comment">// 写入ByteStream</span></span><br><span class="line">                            _output.<span class="built_in">write</span>(res.<span class="built_in">substr</span>(<span class="number">0</span>, it-&gt;left - start));</span><br><span class="line">                            <span class="comment">// 更新</span></span><br><span class="line">                            res = res.<span class="built_in">substr</span>(it-&gt;left - start);</span><br><span class="line">                            left_bound = it-&gt;left - start + left;</span><br><span class="line">                            left = left_bound;</span><br><span class="line">                            remaining += it-&gt;left - start;</span><br><span class="line">                            <span class="comment">// out剩下的空位会在最后写入</span></span><br><span class="line">                            <span class="keyword">goto</span> ok;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 光是out不够的话，那就先能腾多少空间腾多少</span></span><br><span class="line">                            _output.<span class="built_in">write</span>(res.<span class="built_in">substr</span>(<span class="number">0</span>, out_mem));</span><br><span class="line">                            res = res.<span class="built_in">substr</span>(out_mem);</span><br><span class="line">                            left_bound = out_mem + left;</span><br><span class="line">                            left = left_bound;</span><br><span class="line">                            remaining += out_mem;</span><br><span class="line">                            <span class="comment">// 如果腾出空间加上原来空间足够，那就非常ok</span></span><br><span class="line">                            <span class="keyword">if</span> (it-&gt;left &gt; start &amp;&amp; remaining &gt;= it-&gt;left - start) &#123;</span><br><span class="line">                                <span class="keyword">goto</span> ok;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 否则进入错误处理代码</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp = &#123;left, start + remaining, res.<span class="built_in">substr</span>(<span class="number">0</span>, start - left + remaining)&#125;;</span><br><span class="line">                remaining = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">                    is_eof = <span class="literal">false</span>;</span><br><span class="line">                buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">        ok:</span><br><span class="line">            remaining -= it-&gt;left - start;</span><br><span class="line">            start = it-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;right &gt; right)&#123;</span><br><span class="line">                res += it-&gt;data.<span class="built_in">substr</span>(right - it-&gt;left, it-&gt;right - right);</span><br><span class="line">                right = it-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (start &lt; o_right &amp;&amp; remaining &lt; o_right - start) &#123;</span><br><span class="line">        right = start + remaining;</span><br><span class="line">        <span class="keyword">if</span> (eof == <span class="number">1</span>)</span><br><span class="line">            is_eof = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = &#123;left, right, res&#125;;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    	buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    iterator = buffer.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// write into the ByteStream</span></span><br><span class="line">    <span class="keyword">if</span> (iterator != buffer.<span class="built_in">end</span>() &amp;&amp; iterator-&gt;left == left_bound) &#123;</span><br><span class="line">        <span class="type">size_t</span> out_rem = _output.<span class="built_in">remaining_capacity</span>();</span><br><span class="line">        <span class="keyword">if</span> (out_rem &lt; iterator-&gt;data.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            _output.<span class="built_in">write</span>(iterator-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, out_rem));</span><br><span class="line">            left_bound = iterator-&gt;left + out_rem;</span><br><span class="line">            tmp = &#123;left_bound, iterator-&gt;right, iterator-&gt;data.<span class="built_in">substr</span>(out_rem)&#125;;</span><br><span class="line">            buffer.<span class="built_in">erase</span>(iterator);</span><br><span class="line">            buffer.<span class="built_in">insert</span>(tmp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _output.<span class="built_in">write</span>(iterator-&gt;data);</span><br><span class="line">            left_bound = iterator-&gt;right;</span><br><span class="line">            buffer.<span class="built_in">erase</span>(iterator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 满足两个条件才是真的eof</span></span><br><span class="line">    <span class="keyword">if</span> (is_eof &amp;&amp; buffer.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        is_eof = <span class="literal">false</span>;</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">StreamReassembler::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以跟上面的write合起来的，但在此处我采取了最保守的做法。</span></span><br><span class="line">    <span class="type">size_t</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = buffer.<span class="built_in">begin</span>(); it != buffer.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        res += it-&gt;right - it-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">empty</span>()&amp;&amp;is_eof; &#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Lab5   NetworkInterface</title>
    <url>/2023/02/25/cs144$lab5/</url>
    <content><![CDATA[<h1 id="Lab5-NetworkInterface"><a href="#Lab5-NetworkInterface" class="headerlink" title="Lab5   NetworkInterface"></a>Lab5   NetworkInterface</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在前面的lab0-4中，我们实现了TCP协议。而在本次实验，以及接下来的实验6中，我们会将目光从顶层转移到底层——我们将着眼于运输层以下的协议。在本次实验中，我们将实现<strong>ETH协议</strong>，实现<u>对IP数据报的封装以及对物理地址的查询转发</u>；在下一次实验中，我们将实现网络层的路由转发算法。</p>
<h3 id="承上启下"><a href="#承上启下" class="headerlink" title="承上启下"></a>承上启下</h3><h4 id="协议栈架构"><a href="#协议栈架构" class="headerlink" title="协议栈架构"></a>协议栈架构</h4><p>我们在前面的实验已经实现了TCP协议，那么，TCP报文究竟是如何进行封装，最终到达peer那边的？我们的协议栈架构究竟是怎么样的？对于这个过程的实现协议栈，我们可以有如下三种选择。</p>
<h5 id="TCP-UDP-IP"><a href="#TCP-UDP-IP" class="headerlink" title="TCP-UDP-IP"></a>TCP-UDP-IP</h5><p>在此架构中，TCP不由操作系统的内核实现，而是运行在<strong>用户态</strong>。【事实上这三种选择TCP都是运行在用户态的，正如我们实现的这样】</p>
<p>用户态会将上层app传来的数据封装在TCP报文段中，用户态只需向操作系统提供的一个接口传入TCP报文段以及目的地址进入该接口就行。在此接口中，操作系统会给用户传进来的数据报文增加UDP、IP、ETH等等协议头，添加端口号等等等。</p>
<blockquote>
<p>所以说，其实操作系统<strong>默认只支持</strong>UDP-IP-ETH呀！新加的一层TCP反倒是靠用户实现的！</p>
<p>如果只需UDP协议，用户只需传入上层app的数据就行；如果还想要TCP，那就得由用户自己实现TCP协议，把上层app的数据封装成TCP报文，然后再发送给系统调用做进一步的封装。</p>
</blockquote>
<blockquote>
<p>其实不仅是TCP，HTTP应该也是用户自己实现的。对于web开发来说，大概应该是这样：top app data→ HTTP request/response → TCP segment → 操作系统接口 → UDP → IP → ETH frame</p>
</blockquote>
<blockquote>
<p>这个“TCP是用户态实现的”的观点让我非常震撼，在计网理论学的东西现在我们居然已经亲手实现出来了，有种网友面基的震撼。</p>
<p><a href="https://www.51cto.com/article/679964.html">TCP/IP协议栈到底是内核态好还是用户态好？</a>这篇文章好像写得很好，但是我没怎么看懂就先放在这【经典】不过里面对于NAK和ACK机制的对比学习写得挺有意思的，看了感觉很有收获。</p>
</blockquote>
<h5 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP-IP"></a>TCP-IP</h5><p>TCP当然也可以越过UDP协议，直接与IP层相连。但这由于不用了操作系统提供的那一层UDP，我们要做的事情就会变多变<strong>复杂</strong>。这也是我们经常听到的所谓“TCP/IP协议”的意义。</p>
<blockquote>
<p>Linux provides an interface, called a <code>TUN</code> device, that lets application supply <strong>an entire Internet datagram</strong>, and the kernel takes care of the rest (writing the Ethernet header, and actually sending via the physical Ethernet card, etc.). But now the application has to <u>construct the full IP header itself, not just the payload.</u>【要做的事变多了】</p>
<p>不过这里的这个填IP header的事情，在学校已经做过了，只是这个点的话确实没什么好说的</p>
</blockquote>
<p>听起来有没有很耳熟？是的，这个TCP-IP架构，我们在lab0-4已经实现了！其TCP部分是由我们自己写的，而IP部分则是由官方给的代码写的。</p>
<blockquote>
<p><strong>You’ve done this already.</strong></p>
<p>In Lab 4, we gave: </p>
<ol>
<li>an object that represents an Internet datagram and knows how to parse and serialize itself (<code>tcp_helpers/ipv4_datagram.&#123;hh,cc&#125;</code>) 表示了Internet datagram的数据结构，它可以自己序列化。</li>
<li>the logic to encapsulate(封装) TCP segments in IP (now found in <code>tcp_helpers/tcp_over_ip.cc</code>).</li>
</ol>
<p> The <code>CS144TCPSocket</code> uses these tools to connect your <code>TCPConnection</code> to a TUN device.</p>
<p>【我关于这些代码的研究放在了<code>其他的对实验未涉及的思考</code>模块中了】</p>
<p>所以说，</p>
<p>发送数据时，数据流向：上层app→（通过<code>CS144TCPSocket</code>）<code>TCPConnection</code>→（通过<code>write</code>方法）<code>ByteStream</code>→<code>TCPSender</code>→（通过从<code>_sender.segments_out</code>读）<code>TCPConnection</code>→（通过<code>CS144TCPSocket</code>绑定的事件从<code>segments_out</code>传输）<code>TUN</code></p>
<p>接收数据时，数据流向：<code>TUN</code>→（通过<code>CS144TCPSocket</code>绑定的事件调用<code>segment_received</code>）<code>TCPConnection</code>→<code>TCPReceiver</code>→（中间经过<code>StreamAssembler</code>）<code>BYteStream</code>→（通过<code>CS144TCPSocket</code>读）上层app</p>
<p>TUN以内隐藏的复杂逻辑，都由操作系统来帮我们实现。除去我们本次实验要做的ETH协议之外，剩下的其实好像就是我们在6.S081中做的networking driver了！再接下去就是数据链路层和物理层的工作了，这些就是硬件实现的范畴了。</p>
<p>感觉写到这，心情非常地澎湃。我们居然真的真的，亲手将计算机网络全部实现了出来，心中真是无限<strong>感→动↑</strong>啊！</p>
</blockquote>
<h5 id="TCP-IP-ETH"><a href="#TCP-IP-ETH" class="headerlink" title="TCP-IP-ETH"></a>TCP-IP-ETH</h5><p>而在整个sponge实现中，我们不拘泥于仅实现<code>TCP/IP</code>。我们还要实现属于我们自己的ETH协议。</p>
<p>就跟<code>TCP/IP</code>的实现中，将IP数据包发送给操作系统需要通过<code>TUN</code>接口一样，我们需要把包装的ETH数据报发送给<code>TAN</code>接口。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>因而，通过以上表述，我们知道了本次实验的目的是实现数据链路层，以及为什么要实现数据链路层。下面将详细介绍数据链路层的具体功能以及实现。</p>
<h3 id="数据链路层的实现"><a href="#数据链路层的实现" class="headerlink" title="数据链路层的实现"></a>数据链路层的实现</h3><p>要明白数据链路层怎么实现，首先要知道其功能。</p>
<h4 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h4><p>可大概分为两点：</p>
<ol>
<li><p>通过ETH协议，封装/拆封数据包</p>
<p>这个没什么好说的。</p>
<blockquote>
<p>“交付给上层协议栈”的这个“交付”动作是怎么用代码实现的呢？在成员变量里保留对上层协议栈的成员的引用？或者是像TCP那样，维护一个_out和一个received方法，其它具体连接由socket的事件驱动？</p>
<p>答案应该是像TCP这样。</p>
<p>但其实也不完全像TCP。TCP与其上层，也即app的交互是通过socket；但interface没有这个机制，它只能在frame_received的时候直接return它收到的数据报。啊不过，也许从eth得到数据报然后交给ip也是socket的任务？</p>
<p>我记得在本校的计网实验中，似乎是归结到了一个函数内实现，其接收一个void*类型的指针，好像还有代表报文格式的枚举类。</p>
</blockquote>
</li>
<li><p>通过ARP协议，将IP地址转化为物理地址</p>
<p>我们学过，在数据链路层（还是说是物理层？）endpoint的交互是通过物理地址的，但在网络层以上，endpoint的交互是通过IP地址（域名也会被解析为IP地址）的。因而，在ETH层，我们首先需要将IP地址转化为其对应的物理地址。</p>
<blockquote>
<p>在这里可以梳理一下计算机网络中所谓“地址”的<strong>转化路径</strong>：</p>
<p>我们通过约定俗成的<strong>域名</strong>访问某个主机，该域名会被DNS解析为<strong>IP地址</strong>，该IP地址会在网络层，也就是IP协议这边经过路由转发【<u>如果是用户host的话会发给自己的default路由器</u>】，然后在ETH层会根据这个要去的地方的IP地址通过ARP协议查表，得到下一站应该要去的<strong>物理地址</strong>。</p>
<p>与此同时我们也可以归纳出lab6的内容。我们的lab6就是要做这个“转发”功能。根据所学可知，实质上只有路由器才算起着真实的路由转发功能【host的路由转发只是转发给自己的海关路由器】。而路由器不需要什么TCP协议，所以lab6只基于lab5，跟lab0-4没有半毛钱关系。</p>
</blockquote>
</li>
</ol>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p><img src="/2023/02/25/cs144/image-20230307193836409.png" alt="image-20230307193836409"></p>
<p>H1知道R1的IP地址是因为设置了默认网关，而路由器之间知道彼此的IP地址是通过路由协议相互通信。</p>
<p>为什么H1知道要发给H2就需要经过R1，以及为什么H1知道R1的IP地址，R1知道R2的IP地址，这都是网络层的路由协议在起作用。</p>
<p>而H1怎么知道的R1的MAC地址，这就是ARP协议研究的内容了。是ARP将已知的IP地址翻译为MAC。</p>
<p>ARP协议的具体内容看视频就好，在此不赘述。具体有ARP请求报文（广播）、ARP响应报文（单播）</p>
<p>如果发现不知道MAC地址就发ARP request，收到ARP request的host如果发现是自己的，就需要做两件事，一个是记下来者，另一个是发送ARP响应报文。</p>
<p><img src="/2023/02/25/cs144/image-20230307194650945.png" alt="image-20230307194650945"></p>
<h3 id="network-interface"><a href="#network-interface" class="headerlink" title="network interface"></a>network interface</h3><p>介绍完上面的种种，终于来到了本次实验要实现的正题：<strong>network interface</strong>。</p>
<p>正如同在网络层，各个主机通过IP协议，凭借自己的IP地址相互打交道一样，在数据链路层，各个network interface通过ARP协议和ETH协议，凭借MAC地址相互打交道。</p>
<blockquote>
<p>可以看出，数据链路层的“network interface”与网络层的“主机”是相近的。它们的区别是什么呢？</p>
<p>答案是，一个主机可以有多个网卡，因而可以有多个network interface。</p>
<p><img src="/2023/02/25/cs144/image-20230307193102495.png" alt="image-20230307193102495"></p>
</blockquote>
<blockquote>
<p>不过这里的这个对应还是很有意思的，它反映出了计算机网络的抽象：一次网络传输可以看作是单层之间的相互交流，可以忽略其他层。不得不感慨，设计出网络层级模型的人真是天才。</p>
</blockquote>
<p>因而，在我们的数据链路层，也即我们的network interface中，我们需要实现ARP协议和ETH协议，完成数据包的收发。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>这次实验内容其实有一说一挺复杂的，既要管理各种超时，又要写收发管理。它其实跟<code>TCPSender</code>有点像，只不过本次实验的难点在数据结构的管理，<code>TCPSender</code>的难点在各种状态机的细枝末节。由于有<code>TCPSender</code>的基础，本次实验完成难度大大减小，我甚至写完代码后不出二十分钟就pass掉了测试用例（骄傲←）不过，它的编码过程及数据结构确实还是有点复杂的。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h4><p>整理一下我们的interface可能收到/发送的报文，思路就很简单了</p>
<p>收：</p>
<ol>
<li><p>来自外部的数据</p>
<p>比较MAC地址跟自己一不一样</p>
<p>需要去掉其ETH头，交付给上层</p>
</li>
<li><p>ARP请求</p>
<p>比对请求的IP地址跟自己的一不一样。</p>
<p>如果一样，就把该报文的src MAC记录进ARP，并且发送一个ARP响应进入frame_out</p>
</li>
<li><p>ARP响应</p>
<p>记录MAC地址；将放入等待暂存队列的数据包取出重新发送</p>
</li>
</ol>
<p>发：</p>
<ol>
<li><p>来自上层的数据报</p>
<p>查询ARP表，如果MAC地址已知就发，未知的话放入等待队列，并且发送ARP请求</p>
</li>
<li><p>ARP请求</p>
</li>
<li><p>ARP响应</p>
</li>
</ol>
<p>所以我们需要写以下几个函数：</p>
<ol>
<li><p>frame_received</p>
</li>
<li><p>send_arp_response</p>
<p>创建一个新的frame，填上自己的MAC地址和srcMAC</p>
</li>
<li><p>send_arp_request</p>
<p>创建一个新的frame，填上自己的MAC地址、IP地址和目的IP地址</p>
</li>
<li><p>frame_send</p>
<p>发送从上层来的报文</p>
</li>
<li><p>ARP操作    ARP表是一个map映射</p>
</li>
</ol>
<p>以及如下成员变量：</p>
<ol>
<li><p>ARP映射的数据结构</p>
<p>map&lt;IP地址，{MAC地址，ticks}&gt;</p>
</li>
<li><p>等待队列</p>
<p>map&lt;IP地址，{未填写dst的frame们，latest_ticks}&gt;</p>
</li>
<li><p>ticks  代表当前经过的时间</p>
</li>
</ol>
<h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>可以看到，官方提供给我们的接口定义，以及在指导书中对函数实现的详细拆分，确实跟初见思路所想的差不多完全一样【但我更推荐看指导书的版本，它枚列得更加清晰】，可以说思路还是很直观的。所以就不多bb了直接看代码吧。</p>
<h4 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h4><ol>
<li><p>等待在同一个IP地址的帧可能不止一个，所以在数据结构中需要以vector集合形式管理</p>
</li>
<li><p>在接收以太帧时，应该首先检查最外层的ETH协议的MAC地址，作用是判断这个帧是不是发给自己的。</p>
<p>如果帧内封装的是IP数据包，这样做就很OK了，因为能确保此时自己一定可以收这个包；</p>
<p>但是如果帧内封装的是ARP数据包，这样做是不OK的。因为依照ARP协议，若是此为ARP REQUEST，则其ETH header是广播地址，而它真正想要届到的对象的信息是在ARP header中的target IP。因而，对于ARP协议，我们还得判断header中的target IP和本机IP是否相等。</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkInterface</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// arp映射的元素定义</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">arp_node</span> &#123;</span><br><span class="line">        EthernetAddress mac;<span class="comment">// ip地址key对应的mac地址</span></span><br><span class="line">        <span class="type">size_t</span> ticks;<span class="comment">// 该条记录被记录时的时间</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ARP映射，&lt;IP地址，元素结点&gt;</span></span><br><span class="line">    std::map&lt;<span class="type">uint32_t</span>, arp_node&gt; arp_mappings&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">waiting_node</span> &#123;</span><br><span class="line">        std::vector&lt;EthernetFrame&gt; frames&#123;&#125;;<span class="comment">// 等待在该IP地址的以太帧们</span></span><br><span class="line">        <span class="type">size_t</span> latest_ticks = <span class="number">0</span>;  <span class="comment">// 等候中的frame们最晚放入者的时间</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 等待队列，&lt;IP地址，元素结点&gt;</span></span><br><span class="line">    std::map&lt;<span class="type">uint32_t</span>, waiting_node&gt; waiting_frames&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> ticks = <span class="number">0</span>;<span class="comment">// 出生到现在经过的时钟滴答</span></span><br><span class="line">    <span class="comment">// 自定义方法，用于发送一个arp报文【请求/响应】</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send_arp</span><span class="params">(<span class="type">uint32_t</span> target_ip, EthernetAddress eth_add, <span class="type">uint16_t</span> opcode)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network_interface.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;arp_message.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ethernet_frame.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NetworkInterface::<span class="built_in">NetworkInterface</span>(<span class="type">const</span> EthernetAddress &amp;ethernet_address, <span class="type">const</span> Address &amp;ip_address)</span><br><span class="line">    : _ethernet_address(ethernet_address), _ip_address(ip_address) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// param: target ip address , target ethernet address , and the arp opcode</span></span><br><span class="line"><span class="comment">// if is the request, pass BROADCAST as the param;</span></span><br><span class="line"><span class="comment">// if is the response, pass arprequest.eth_add as the param.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::send_arp</span><span class="params">(<span class="type">uint32_t</span> target_ip, EthernetAddress eth_add, <span class="type">uint16_t</span> opcode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// create the eth frame</span></span><br><span class="line">    EthernetFrame frame;</span><br><span class="line">    <span class="comment">/* create the payload */</span></span><br><span class="line">    <span class="comment">// create the arp message</span></span><br><span class="line">    ARPMessage arp_mes;</span><br><span class="line">    arp_mes.sender_ethernet_address = _ethernet_address;</span><br><span class="line">    arp_mes.sender_ip_address = _ip_address.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    arp_mes.opcode = opcode;</span><br><span class="line">    arp_mes.target_ip_address = target_ip;</span><br><span class="line">    <span class="keyword">if</span> (opcode == ARPMessage::OPCODE_REPLY)</span><br><span class="line">        arp_mes.target_ethernet_address = eth_add;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// if is the REQUEST, arp target mac is unknown and should be set to zero</span></span><br><span class="line">        arp_mes.target_ethernet_address = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// serialize and put it into the payload</span></span><br><span class="line">    frame.<span class="built_in">payload</span>() = <span class="built_in">BufferList</span>(arp_mes.<span class="built_in">serialize</span>());</span><br><span class="line">    <span class="comment">/* fill in the header */</span></span><br><span class="line">    EthernetHeader header;</span><br><span class="line">    header.src = _ethernet_address;</span><br><span class="line">    header.dst = eth_add;</span><br><span class="line">    header.type = EthernetHeader::TYPE_ARP;</span><br><span class="line">    frame.<span class="built_in">header</span>() = header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send it</span></span><br><span class="line">    _frames_out.<span class="built_in">push</span>(frame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] dgram the IPv4 datagram to be sent</span></span><br><span class="line"><span class="comment">//! \param[in] next_hop the IP address of the interface to send it to (typically a router or default gateway, but may also be another host if directly connected to the same network as the destination)</span></span><br><span class="line"><span class="comment">//! (Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) with the Address::ipv4_numeric() method.)</span></span><br><span class="line"><span class="comment">// 处理从上层协议接收到的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::send_datagram</span><span class="params">(<span class="type">const</span> InternetDatagram &amp;dgram, <span class="type">const</span> Address &amp;next_hop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// convert IP address of next hop to raw 32-bit representation (used in ARP header)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> next_hop_ip = next_hop.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    <span class="comment">// create the eth frame</span></span><br><span class="line">    EthernetFrame frame;</span><br><span class="line">    <span class="comment">// fill in the payload</span></span><br><span class="line">    frame.<span class="built_in">payload</span>() = dgram.<span class="built_in">serialize</span>();</span><br><span class="line">    <span class="comment">// fill in the header</span></span><br><span class="line">    EthernetHeader header;</span><br><span class="line">    <span class="comment">// dst is reserved</span></span><br><span class="line">    header.src = _ethernet_address;</span><br><span class="line">    header.type = EthernetHeader::TYPE_IPv4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> tmp_arp = arp_mappings.<span class="built_in">find</span>(next_hop_ip);<span class="comment">// find the mac from the arp mappings</span></span><br><span class="line">    <span class="keyword">if</span> (tmp_arp == arp_mappings.<span class="built_in">end</span>()) &#123;  <span class="comment">// not exist</span></span><br><span class="line">        frame.<span class="built_in">header</span>() = header;          <span class="comment">// remember that the dst field is reserved</span></span><br><span class="line">        <span class="keyword">auto</span> tmp_wait = waiting_frames.<span class="built_in">find</span>(next_hop_ip);<span class="comment">// is there a waiting queue?</span></span><br><span class="line">        <span class="comment">// the arp request hasn&#x27;t been sent if there is not a waiting queue, </span></span><br><span class="line">        <span class="keyword">if</span> (tmp_wait == waiting_frames.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// create the waiting queue</span></span><br><span class="line">            vector&lt;EthernetFrame&gt; frames;</span><br><span class="line">            frames.<span class="built_in">push_back</span>(frame);</span><br><span class="line">            waiting_node node;</span><br><span class="line">            node.frames = frames;</span><br><span class="line">            node.latest_ticks = ticks;</span><br><span class="line">            waiting_frames.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(next_hop_ip, node));</span><br><span class="line">            <span class="comment">// send arp request</span></span><br><span class="line">            <span class="built_in">send_arp</span>(next_hop_ip, ETHERNET_BROADCAST, ARPMessage::OPCODE_REQUEST);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// the arp request has been sended</span></span><br><span class="line">            <span class="keyword">if</span> (ticks - tmp_wait-&gt;second.latest_ticks &gt; <span class="number">5</span>*<span class="number">1000</span>) &#123;<span class="comment">// send before 5 seconds</span></span><br><span class="line">                <span class="comment">// resend arp request</span></span><br><span class="line">                <span class="built_in">send_arp</span>(next_hop_ip, ETHERNET_BROADCAST, ARPMessage::OPCODE_REQUEST);</span><br><span class="line">                <span class="comment">// update the time only when the arp request was sent</span></span><br><span class="line">                tmp_wait-&gt;second.latest_ticks = ticks;  </span><br><span class="line">            &#125;</span><br><span class="line">            tmp_wait-&gt;second.frames.<span class="built_in">push_back</span>(frame);<span class="comment">// add the frame to the waiting list</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recall that the dst field is reserved</span></span><br><span class="line">    header.dst = tmp_arp-&gt;second.mac;</span><br><span class="line">    frame.<span class="built_in">header</span>() = header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send it right away</span></span><br><span class="line">    _frames_out.<span class="built_in">push</span>(frame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] frame the incoming Ethernet frame</span></span><br><span class="line"><span class="function">optional&lt;InternetDatagram&gt; <span class="title">NetworkInterface::recv_frame</span><span class="params">(<span class="type">const</span> EthernetFrame &amp;frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().dst != _ethernet_address &amp;&amp; frame.<span class="built_in">header</span>().dst != ETHERNET_BROADCAST)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;  <span class="comment">// should not accept</span></span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().type == EthernetHeader::TYPE_IPv4) &#123;</span><br><span class="line">        InternetDatagram ip_data;</span><br><span class="line">        ParseResult res = ip_data.<span class="built_in">parse</span>(frame.<span class="built_in">payload</span>());</span><br><span class="line">        <span class="keyword">if</span> (res == ParseResult::NoError) &#123;</span><br><span class="line">            <span class="keyword">return</span> ip_data; <span class="comment">// return to send it to the upper protocal</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().type != EthernetHeader::TYPE_ARP)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    ARPMessage arp_mes;</span><br><span class="line">    ParseResult res = arp_mes.<span class="built_in">parse</span>(frame.<span class="built_in">payload</span>());</span><br><span class="line">    <span class="keyword">if</span> (res != ParseResult::NoError)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// I&#x27;m not the arp target</span></span><br><span class="line">    <span class="keyword">if</span> (arp_mes.target_ip_address != _ip_address.<span class="built_in">ipv4_numeric</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> tmp_arp = arp_mappings.<span class="built_in">find</span>(arp_mes.sender_ip_address);</span><br><span class="line">    <span class="keyword">if</span> (tmp_arp == arp_mappings.<span class="built_in">end</span>()) &#123;  <span class="comment">// arp mapping not exist, create one</span></span><br><span class="line">        arp_node node;</span><br><span class="line">        node.ticks = ticks;</span><br><span class="line">        node.mac = arp_mes.sender_ethernet_address;</span><br><span class="line">        arp_mappings.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(arp_mes.sender_ip_address, node));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp_arp-&gt;second.ticks = ticks;  <span class="comment">// update the record ticks</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arp_mes.opcode == ARPMessage::OPCODE_REQUEST) &#123;</span><br><span class="line">        <span class="built_in">send_arp</span>(arp_mes.sender_ip_address, arp_mes.sender_ethernet_address, ARPMessage::OPCODE_REPLY);</span><br><span class="line">        <span class="comment">// shouldn&#x27;t return now, maybe we are also waiting for the sender&#x27;s mac address</span></span><br><span class="line">        <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send all frames in the waiting queue</span></span><br><span class="line">    <span class="keyword">auto</span> tmp_wait = waiting_frames.<span class="built_in">find</span>(arp_mes.sender_ip_address);</span><br><span class="line">    <span class="comment">// have no frames waiting for the address</span></span><br><span class="line">    <span class="keyword">if</span> (tmp_wait == waiting_frames.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!tmp_wait-&gt;second.frames.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        EthernetFrame f = tmp_wait-&gt;second.frames.<span class="built_in">back</span>();</span><br><span class="line">        <span class="comment">// recall that the dst field is reserved</span></span><br><span class="line">        f.<span class="built_in">header</span>().dst = arp_mes.sender_ethernet_address;  </span><br><span class="line">        _frames_out.<span class="built_in">push</span>(f);</span><br><span class="line">        tmp_wait-&gt;second.frames.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// erase all the waiting frames</span></span><br><span class="line">    waiting_frames.<span class="built_in">erase</span>(tmp_wait);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    ticks += ms_since_last_tick;</span><br><span class="line">    <span class="comment">// walk the arp mappings to check whether a mapping is out-of-date</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = arp_mappings.<span class="built_in">begin</span>(); it != arp_mappings.<span class="built_in">end</span>();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticks - it-&gt;second.ticks &gt; <span class="number">30</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">            it = arp_mappings.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Lab2   TCPReceiver</title>
    <url>/2023/02/25/cs144$lab2/</url>
    <content><![CDATA[<h1 id="Lab2-TCPReceiver"><a href="#Lab2-TCPReceiver" class="headerlink" title="Lab2   TCPReceiver"></a>Lab2   TCPReceiver</h1><h2 id="前置学习"><a href="#前置学习" class="headerlink" title="前置学习"></a>前置学习</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><h4 id="承上启下"><a href="#承上启下" class="headerlink" title="承上启下"></a>承上启下</h4><p>在前两个实验中，我们可以说只是做了点算法上的抽象工作，跟TCP协议还是没什么显著的关系的。但来到了本次实验，一切就都不一样了。</p>
<p><img src="/2023/02/25/cs144/image-20230226194708398.png" alt="image-20230226194708398"></p>
<p>依然还是这张图。相信此时做过前两个实验之后，看到这张图就会有了不一样的发现。</p>
<p>我们对TCP协议的实现是由内向外的，先实现里面再实现最外层。前两节实验，我们由内而外实现了<code>ByteStream</code>和<code>StreamReassembler</code>；在这次实验中，我们会实现更外层一点的<code>TCPReceiver</code>。</p>
<p>根据我们前两次实验内容，我们可以知道，<code>TCPReceiver</code>的功能之一就是，将数据包<code>TCPSegment</code>拆分成一个个<code>data</code>，并且通过<code>seq</code>生成出这些<code>data</code>的<code>index</code>，然后传递给<code>StreamReassembler</code>。</p>
<h4 id="由外而内"><a href="#由外而内" class="headerlink" title="由外而内"></a>由外而内</h4><h5 id="TCPConnection"><a href="#TCPConnection" class="headerlink" title="TCPConnection"></a>TCPConnection</h5><p>在说明<code>TCPReceiver</code>的其他功能前，不妨先从外面的<code>TCPConnection</code>说起，由外而内回忆一下整个TCP协议过程。</p>
<p><img src="/2023/02/25/cs144/image-20230226200935395.png" alt="image-20230226200935395"></p>
<p><img src="/2023/02/25/cs144/image-20230226202631406.png" alt="image-20230226202631406"></p>
<p>这期间最关键需要理解的，是SYN FIN ACK ack seq这些东西究竟是什么东西。</p>
<h5 id="对象说明"><a href="#对象说明" class="headerlink" title="对象说明"></a>对象说明</h5><h6 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h6><p>seq用来标识字节流中某个字节的序号，在TCP报文中，它表示的是该报文携带的数据的第一个字节的序号。</p>
<p>与我们在Lab1实现的<code>StreamReassembler</code>的参数index相比，它有三方面不同：</p>
<ol>
<li><p>seq为32位，index为64位</p>
<p>当一个字节流的数据超过2^32字节（实际上比这少就会环绕）时，seq就会产生环绕。如，当前seq为0xFFFFFFFF，则下一个seq就是0x00000000。</p>
</li>
<li><p>seq不从0开始，index从0开始</p>
<p>为了确保传输过程中的安全性，一个字节流的起始seq不为0，而是一个<strong>随机数</strong>，称其为<strong>ISN</strong>。</p>
</li>
<li><p>seq有不携带数据的两个逻辑报文SYN和FIN，index没有</p>
</li>
</ol>
<h6 id="SYN"><a href="#SYN" class="headerlink" title="SYN"></a>SYN</h6><p>SYN是TCP“三握手”中服务器端接收到的来自客户端的第一个报文。它是TCP报文中的一个标识位：</p>
<p><img src="/2023/02/25/cs144/image-20230227135255525.png" alt="image-20230227135255525"></p>
<p>它用以标识数据传输的开始，并且<strong>携带</strong>seq最初随机的序号ISN。</p>
<blockquote>
<p>除了确保收到所有字节的数据外，TCP必须确保也能收到流的开始和结束</p>
<p>这个说得非常好，完美解释了为什么需要占据一个seqno</p>
</blockquote>
<h6 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a>ACK</h6><p>ACK也是一个标识位，它代表当前报文是一个确认收到的报文ACK，也即报文中的ackno<strong>值有效</strong>。</p>
<h6 id="ack"><a href="#ack" class="headerlink" title="ack"></a>ack</h6><p>ack表示当前endpoint【包括客户端和服务器端】希望接收到的下一个数据流的起始字节的seq。</p>
<blockquote>
<p>关于seq和ack，听起来还是有点抽象，不如以连接释放图中ack和seq的值变化为例来说明。</p>
<p><img src="/2023/02/25/cs144/image-20230226202631406.png" alt="image-20230226202631406"></p>
<p>为什么一开始seq=u，ack=v，但下一个就是seq=v，ack=u+1？</p>
<p>这是因为，ack和seq的语义对于客户端和服务器端都是不变的。ack为已经收到的数据的seq+1表示第一个应该接收的值，seq为已经发送的数据的seq+1表示已经发送的值。并且还需要意识到，图中其实有两个数据流（一个是C→S，另一个是S→C），也即有两套seq和ack。</p>
<ul>
<li><p>ack</p>
<p>服务器从客户端接收信号。ack表示服务器希望接收到的下一个序列号，也即为它从客户端收到的数据的seq+1。</p>
<p>对于此情况，虽然终止报文不携带数据，但其依然占据一个序列号seq。</p>
<p>因而服务器的ack=u+1.</p>
</li>
<li><p>seq</p>
<p>服务器向客户端发送数据。ack表示客户端希望接收到的下一个序号，因而服务器端就应该发送ack这个序号的数据，也即v。</p>
</li>
</ul>
</blockquote>
<h6 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h6><p>FIN也是一个标识位，标识着数据传输的结束</p>
<h5 id="接收报文类型"><a href="#接收报文类型" class="headerlink" title="接收报文类型"></a>接收报文类型</h5><p>因而，从图中可以看出，TCP连接中大概会收到以下几类报文：</p>
<ol>
<li><p>特殊报文</p>
<ol>
<li><p>SYN = 1</p>
<ol>
<li><p>C的连接请求  携带了ISN</p>
</li>
<li><p>S的连接请求确认，ACK = 1，携带了S的ISN</p>
</li>
</ol>
</li>
<li><p>ACK = 1</p>
<p>额我觉得这是TCPSender管的。这大概是Connection知道了之后通知下TCPSender吧，应该跟我们这次实验没关系</p>
</li>
<li><p>FIN = 1</p>
</li>
</ol>
</li>
<li><p>普通的数据</p>
</li>
</ol>
<h5 id="TCPReceiver的作用"><a href="#TCPReceiver的作用" class="headerlink" title="TCPReceiver的作用"></a>TCPReceiver的作用</h5><p>我们的<code>TCPReceiver</code>需要负责TCP协议中部分关键对象的管理。我们需要生成ackno以及拥塞窗口大小；我们需要接收SYN和FIN等信号；我们需要对seq进行处理，将其变为<code>StreamReassembler</code>所想要的index。</p>
<h4 id="总结TCPReceiver的作用"><a href="#总结TCPReceiver的作用" class="headerlink" title="总结TCPReceiver的作用"></a>总结TCPReceiver的作用</h4><ol>
<li><p>处理数据</p>
<p>把Internet过来的一个个TCP报文变成一个个小data，小data再由整流器整流为完整的data，外界再通过socket从ByteStream读取完整的data。</p>
</li>
<li><p>反馈信息</p>
<p>向发送方反馈自己当前的一些状态信息，如拥塞窗口的大小以及ack等。</p>
<ol>
<li><p>ackno</p>
<p>本质上是“index of the first unassembled byte”</p>
</li>
<li><p>window size</p>
<p>本质上是“the distance between the first unassembled index and the first unacceptable index”</p>
</li>
</ol>
<p>也即，ackno为拥塞窗口的左端点，ackno+window_size为拥塞窗口的右端点</p>
</li>
</ol>
<h3 id="64-bit-indexes-←→-32-bit-seqnos"><a href="#64-bit-indexes-←→-32-bit-seqnos" class="headerlink" title="64-bit indexes ←→ 32-bit seqnos"></a>64-bit indexes ←→ 32-bit seqnos</h3><p>从Overview中可以看出来，至关重要的一点就是，将环绕的32bit的seq转化为我们在<code>StreamReassembler</code>中使用的index。</p>
<p>我们不妨再引入一个中间变量<code>abstract seqno</code>。则<code>seqno</code>、<code>abstract seqno</code>、<code>stream index</code>三者关系如下图：</p>
<p><img src="/2023/02/25/cs144/image-20230227141242426.png" alt="image-20230227141242426"></p>
<p>显然从<code>seqno</code>转化为<code>abstract seqno</code>更加复杂。因而，我们要做的第一个实验部分就是实现这个转化。</p>
<p>我们需要实现类<code>WrappingInt32</code>。它的<code>wrap</code>函数将64位的<code>abstract seqno</code>转化为32位的<code>seqno</code>，它的<code>unwrap</code>将32位的<code>seqno</code>转化为64位的<code>abstract seqno</code>。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><h3 id="64-bit-indexes-←→-32-bit-seqnos-1"><a href="#64-bit-indexes-←→-32-bit-seqnos-1" class="headerlink" title="64-bit indexes ←→ 32-bit seqnos"></a>64-bit indexes ←→ 32-bit seqnos</h3><p>这个实验完美地触及到了我的雷点：对这种环绕来环绕去的东西非常头疼……因而昨天晚上做的时候晕晕乎乎的什么也思考不了，今天过来边画了下图才知道要怎么做。</p>
<p><code>wrap</code>很简单我就不说了。对于<code>unwrap</code>，我的做法是，先让checkpoint和n-isn都处在同一个区间（红圈）内【也即都让它们对2^32取余】，再通过几个东西之间的关系来确定最终的res是否需要+-HEAD_ONE：</p>
<p>【蓝线表示n-isn，橙线表示红圈区间的中点】</p>
<p><img src="/2023/02/25/cs144/image-20230227133550293.png" alt="image-20230227133550293"></p>
<p>具体的就不多说了。直接看下面的代码，多画画图就能明白了。</p>
<h3 id="TCPReceiver"><a href="#TCPReceiver" class="headerlink" title="TCPReceiver"></a>TCPReceiver</h3><p><img src="/2023/02/25/cs144/image-20230227231044428.png" alt="image-20230227231044428"></p>
<h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>我一开始头晕晕地去写，对很多地方产生了疑问，激情地写下了一些消极的话语。刚刚出去吹了会儿风回来，bug全都改对了，于是狂喜着把消极的话语全部删掉了（）</p>
<p>怎么说呢，我的错误发生是因为我<strong>没有意识到</strong>sponge的TCP也许算是一个“简化版”。</p>
<p>在学习本章内容之前，我特地先去回顾了下TCP协议的全过程，并且所有的SYN，FIN等等等概念都是按照网上的概念来的。因而我在面对自己的错误时真的是一脸懵逼……好在，吹完风之后我还是及时醒悟了。</p>
<p>思路还是很简单的，细节也不像Lab1那样那么多那么破防，就是一些奇奇怪怪的恶心小毛病太多了，导致我出错频频，并且都是些很sb的问题，让人直接心态爆炸。</p>
<p>先不吐槽了，接下来就来讲讲总体的思路，以及我产生疑惑的一些地方吧。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h5><p>得益于Lab1那个复杂算法的健壮性和多功能性，我们对<code>TCPReceiver</code>的实现就可以变得更加简洁。我们不再需要关心报文是否能够被成功接收、报文是否重叠等等等。我们仅需对SYN和FIN这样的报文做特殊的参数处理，将seqno转化为index，然后直接传入我们的<code>StreamReassembler</code>中就行了。</p>
<p>也即，基本流程为：</p>
<ol>
<li>如果收到SYN报文，则对一些参数进行初始化，并且标记数据传输开始信号syn为true</li>
<li>如果syn为true，则计算index后传入整流器</li>
<li>判断是否需要加上FIN报文的比特位</li>
</ol>
<h5 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h5><h6 id="SYN和FIN各占一个seqno"><a href="#SYN和FIN各占一个seqno" class="headerlink" title="SYN和FIN各占一个seqno"></a>SYN和FIN各占一个seqno</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SYN</span></span><br><span class="line">    <span class="keyword">if</span>(!syn&amp;&amp;header.syn)&#123; <span class="comment">// is the first packet</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        isn = header.seqno;</span><br><span class="line">        seqno = seqno + <span class="number">1</span>; <span class="comment">// plus one to skip the SYN byte</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// FIN</span></span><br><span class="line">	<span class="keyword">if</span>(header.fin)      fin = <span class="literal">true</span>; <span class="comment">// 这个一定要写在上面那个if的后面</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span>(_reassembler.<span class="built_in">empty</span>() &amp;&amp; fin)&#123;</span><br><span class="line">    	ack += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>SYN很直观，没什么好说的。</p>
<p>FIN比较烧。之所以不是这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(header.fin)&#123;</span><br><span class="line">   	ack += <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>也即一发现FIN报文到了就++，是因为可能会发生这种情况：</p>
<p><img src="/2023/02/25/cs144/image-20230227224055002.png" alt="image-20230227224055002"></p>
<p>也即FIN报文虽然到了，但是中间有一段数据还没到，ack应该等于中间那段数据的开头，你这时候想要跳过FIN而把ack+1那肯定是不对的。</p>
<p>也因而，我们需要记录fin是否有过，并且仅当：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">empty</span>()&amp;&amp;is_eof; &#125;</span><br></pre></td></tr></table></figure>

<p>成立时，才能表示数据传输真正结束，让ack++。</p>
<h6 id="以abstract-seqno的形式保存ackno"><a href="#以abstract-seqno的形式保存ackno" class="headerlink" title="以abstract seqno的形式保存ackno"></a>以abstract seqno的形式保存ackno</h6><p>说实话我一开始ackno的数据结构是WrappingInt32。为了这么搞，我还得特地维护一个checkpoint变量用来做unwrap的参数，然后ackno也不能用<code>_reassembler.get_left_bound()</code>来获取，总之就搞得非常非常麻烦。这时候我不小心【是故意的还是不小心的？】看到了<a href="https://github.com/shootfirst/CS144/">感恩</a>的代码，对其用abstract seqno保存ackno这个想法大为赞叹，于是就果断地沿用了（）果然设计思想方面我还是有很大不足啊。</p>
<h4 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h4><h5 id="关于特殊报文"><a href="#关于特殊报文" class="headerlink" title="关于特殊报文"></a>关于特殊报文</h5><p>我一开始被这个图以及百度得到的结果受影响：</p>
<p><img src="/2023/02/25/cs144/image-20230227224429692.png" alt="image-20230227224429692"></p>
<p><img src="/2023/02/25/cs144/image-20230227224449780.png" alt="image-20230227224449780"></p>
<p>认为SYN报文不能携带数据【同理FIN也是】，因而在最初实现的时候看到test case人都麻透了开始怀疑人生……</p>
<p>不过这也怪我没有意识到实验和业界可能是不一样的，但指导书也没说SYN和FIN到底会不会携带数据……emm，我感觉这一点做得不够详细，也许可以改进一下。</p>
<h5 id="关于window-size的定义"><a href="#关于window-size的定义" class="headerlink" title="关于window size的定义"></a>关于window size的定义</h5><p>我现在还是搞不懂这东西究竟是什么玩意……</p>
<p>指导书上是这么说的：</p>
<blockquote>
<p>the distance between the “first <strong>unassembled</strong>” index and the “first <strong>unacceptable</strong>” index.</p>
<p>This is called the “<strong>window size</strong>”.</p>
</blockquote>
<p>所谓的“first <strong>unassembled</strong>”正是ackno。而，我正是理解错了所谓“first <strong>unacceptable</strong>” 的意思，才导致我想了好久好久都没想出来，最后看了答案被薄纱到现在。</p>
<p>看到这个“first <strong>unacceptable</strong>” ，我的第一反应就是，维护一个变量right_bound，当packet过来的时候，如果packet的index范围(seqno + data.length())比right_bound大就更新。我认为这才叫做“first <strong>unacceptable</strong>”。但其实！我会这么想是因为我英语不好……</p>
<p>“first <strong>unacceptable</strong>” ，unacceptable，意为<strong>无法接受的</strong>，也就是说，它跟容量有关。第一个无法接受的，就是第一个超出容量的。而结合我们上面的那张图：</p>
<p><img src="/2023/02/25/cs144/image-20230225232723083-1677510449924-1.png" alt="image-20230225232723083"></p>
<p>可以看出，事实上window size就是黑框部分，也即紫框部分减去绿色部分，也即<code>ByteStream</code>的<code>remaining_capacity()</code>……</p>
<p>而我以为它是<strong>还未收到的</strong>的意思，故而才理解成了上面那样。</p>
<p>看来英语不好也是原罪23333</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="64-bit-indexes-←→-32-bit-seqnos-2"><a href="#64-bit-indexes-←→-32-bit-seqnos-2" class="headerlink" title="64-bit indexes ←→ 32-bit seqnos"></a>64-bit indexes ←→ 32-bit seqnos</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! Transform an &quot;absolute&quot; 64-bit sequence number (zero-indexed) into a WrappingInt32</span></span><br><span class="line"><span class="comment">//! \param n The input absolute 64-bit sequence number</span></span><br><span class="line"><span class="comment">//! \param isn The initial sequence number</span></span><br><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tmp = (n &amp; TAIL_MASK);</span><br><span class="line">    <span class="keyword">return</span> isn + tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Transform a WrappingInt32 into an &quot;absolute&quot; 64-bit sequence number (zero-indexed)</span></span><br><span class="line"><span class="comment">//! \param n The relative sequence number</span></span><br><span class="line"><span class="comment">//! \param isn The initial sequence number</span></span><br><span class="line"><span class="comment">//! \param checkpoint A recent absolute 64-bit sequence number</span></span><br><span class="line"><span class="comment">//! \returns the 64-bit sequence number that wraps to `n` and is closest to `checkpoint`</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! \note Each of the two streams of the TCP connection has its own ISN. One stream</span></span><br><span class="line"><span class="comment">//! runs from the local TCPSender to the remote TCPReceiver and has one ISN,</span></span><br><span class="line"><span class="comment">//! and the other stream runs from the remote TCPSender to the local TCPReceiver and</span></span><br><span class="line"><span class="comment">//! has a different ISN.</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="type">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tmp_n = n.<span class="built_in">raw_value</span>() - isn.<span class="built_in">raw_value</span>();</span><br><span class="line">    <span class="type">uint64_t</span> res = (checkpoint &amp; HEAD_MASK);</span><br><span class="line">    <span class="type">uint32_t</span> tmp_cp = (checkpoint &amp; TAIL_MASK);</span><br><span class="line"></span><br><span class="line">    res |= tmp_n;</span><br><span class="line">    <span class="keyword">if</span>(tmp_cp &lt; FLAG)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp_n &gt; tmp_cp + FLAG)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &gt;= HEAD_ONE) res -= HEAD_ONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp_cp &gt; FLAG)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp_n &lt; tmp_cp - FLAG)       res += HEAD_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TCPReceiver-1"><a href="#TCPReceiver-1" class="headerlink" title="TCPReceiver"></a>TCPReceiver</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPReceiver</span> &#123;</span><br><span class="line">    StreamReassembler _reassembler;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _capacity;</span><br><span class="line">    <span class="type">uint64_t</span> ack = <span class="number">0</span>;</span><br><span class="line">    WrappingInt32 isn = <span class="built_in">WrappingInt32</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> syn = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> fin = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    TCPHeader header = seg.<span class="built_in">header</span>();</span><br><span class="line">    WrappingInt32 seqno = header.seqno;</span><br><span class="line">    string data = seg.<span class="built_in">payload</span>().<span class="built_in">copy</span>();</span><br><span class="line">    <span class="type">size_t</span> index = <span class="number">0</span>; <span class="comment">// the param of the reassembler</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LISTENING -&gt; SYN_SENT</span></span><br><span class="line">    <span class="keyword">if</span>(!syn&amp;&amp;header.syn)&#123; <span class="comment">// is the first packet</span></span><br><span class="line">        _reassembler.<span class="built_in">set_is_eof</span>();<span class="comment">// reset the eof flag</span></span><br><span class="line">        fin = <span class="literal">false</span>;<span class="comment">// reset the fin flag</span></span><br><span class="line">        isn = header.seqno;</span><br><span class="line">        seqno = seqno + <span class="number">1</span>; <span class="comment">// plus one to skip the SYN byte</span></span><br><span class="line">        syn = <span class="literal">true</span>;<span class="comment">// mark the start of the byte stream</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// must keep after the last if branch to avoid the case &quot;flag = SF&quot;</span></span><br><span class="line">    <span class="comment">// FIN_RECEIVED</span></span><br><span class="line">    <span class="keyword">if</span>(header.fin)      fin = <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">if</span>(syn)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> abs_seqno = <span class="built_in">unwrap</span>(seqno,isn,ack);</span><br><span class="line">        index = abs_seqno - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (abs_seqno != <span class="number">0</span>)<span class="comment">// write into the assembler</span></span><br><span class="line">        	_reassembler.<span class="built_in">push_substring</span>(data,index,header.fin);</span><br><span class="line">        ack = _reassembler.<span class="built_in">get_left_bound</span>() + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; fin)</span><br><span class="line">            ack += <span class="number">1</span>;<span class="comment">// plus one to skip the FIN byte</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(syn)     <span class="keyword">return</span> <span class="built_in">wrap</span>(ack,isn);</span><br><span class="line">    <span class="keyword">else</span>        <span class="keyword">return</span> &#123;&#125;;<span class="comment">// empty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stream_out</span>().<span class="built_in">remaining_capacity</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Lab4   TCPConnection</title>
    <url>/2023/02/25/cs144$lab4/</url>
    <content><![CDATA[<h1 id="Lab4-TCPConnection"><a href="#Lab4-TCPConnection" class="headerlink" title="Lab4   TCPConnection"></a>Lab4   TCPConnection</h1><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="耗时情况"><a href="#耗时情况" class="headerlink" title="耗时情况"></a>耗时情况</h3><p>【长舒一口气】</p>
<p>最开始先记录下总体耗时情况吧。本次实验共耗费我16h+【不包括接下来写笔记的时间23333】，共耗费三个工作日。第一天看完了指导书，写完了代码，过掉了<code>#45 reorder</code>之前的所有测试。第二天过掉了<code>#55 t_ucS_1M_32k</code>之前的所有测试，直到第三天才过完了所有测试。</p>
<p>我觉得这整个过程还是挺有意义的，每天都有新的进展，看到test case越过越多是真的很高兴。但是可以说第二天以来就都是面向测试用例改bug了，非常折磨非常坐牢，既要去再次理清之前写过的shit山，又得搞清楚很多让人一头雾水不知从何下手的地方。但总之，这三天很充实，并不会让人觉得心累。</p>
<p>放个通关截图吧，感人至深。</p>
<p><img src="/2023/02/25/cs144/image-20230305160608116.png" alt="image-20230305160608116"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在<code>TCPConnection</code>中具体要做什么，指导书已经写得很详细了，跟着指导书就行。代码部分还是不折磨的，思路直观清晰。</p>
<h4 id="指导书内容"><a href="#指导书内容" class="headerlink" title="指导书内容"></a>指导书内容</h4><blockquote>
<p>Here are the basic rules the TCPConnection has to follow:</p>
</blockquote>
<ol>
<li><p><strong>Receiving segments</strong></p>
<p>大概是在<code>segment_received</code>中做</p>
<p><img src="/2023/02/25/cs144/image-20230303103640065.png" alt="image-20230303103640065"></p>
<ol>
<li><p>检查RST flag</p>
<p>如果RST被设置，sets <strong>both</strong> the inbound and outbound streams to the <strong>error state</strong>，杀死当前connection</p>
<p>return;</p>
<p>具体实现中，杀死connection可以置<code>_linger_after_streams_finish</code>为false。<code> the inbound and outbound streams</code>对应着receiver和sender里的stream。让它们都处于error状态，只需设置<code>ByteStream</code>中的error字段</p>
</li>
<li><p>如果收到的segment with an invalid sequence number，connection需要发送empty segment应答</p>
<p><img src="/2023/02/25/cs144/image-20230303110238265.png" alt="image-20230303110238265"></p>
</li>
<li><p>转发segment给receiver</p>
</li>
<li><p>如果ACK，则把ackno和win_size给sender</p>
</li>
</ol>
</li>
<li><p><strong>Sending segments</strong></p>
<ol>
<li>任何时候sender把segment放进其out流，你都要从中取出来</li>
<li>从receiver处获取ackno和window_size，填入segment中</li>
<li>放到自己的segment_out中</li>
</ol>
<p>从上述表述中，我们需要注意两点：</p>
<ol>
<li><p>顺带ACK</p>
<p>可以看到，这跟我们上课的时候所学的一样，是“顺带ACK”，也即ACK报文并非独立发送，而是在下一次要发送其他数据报文的时候携带发送。这也一定程度上使得ack报文发送不会太频繁也不会太稀疏。</p>
</li>
<li><p>一定要经由sender</p>
<p>我们如果想要发送一个报文，一定得先把它存入sender中，再从sender的segment_out中取出来。这样做的目的是把该报文列入sender的超时重传管辖范围，你如果直接把报文发送到自己的segment_out中，就无法管理其超时重传了</p>
</li>
</ol>
</li>
<li><p><strong>When time passes</strong></p>
<p>在<code>tick()</code>中</p>
<ol>
<li>调用sender的<code>tick()</code></li>
<li>检查sender的连续超时重传次数，如果大于<code>MAX RETX ATTEMPTS</code>，则关闭连接，并且发送RST标志的空报文</li>
<li>end the connection cleanly if necessary</li>
</ol>
</li>
</ol>
<p>再注意一点对于connection的关闭。它要求有一个time pass</p>
<p><img src="/2023/02/25/cs144/image-20230303111131650.png" alt="image-20230303111131650"></p>
<p><img src="/2023/02/25/cs144/image-20230303112817891.png" alt="image-20230303112817891"></p>
<p>第一点挺好实现的，第二点需要在析构函数中检测。</p>
<p>最后的5.1部分值得一看。</p>
<h4 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h4><p><code>TCPConnection</code>的public函数接口定义以及具体要做什么如下。结合上面的指导书内容，<code>TCPConnection</code>的实现就很简单了，我就不多bb了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   TCPConfig _cfg;</span><br><span class="line">   <span class="comment">// 一个endpoint可以同时作为sender和receiver。</span></span><br><span class="line">   TCPReceiver _receiver&#123;_cfg.recv_capacity&#125;;</span><br><span class="line">   TCPSender _sender&#123;_cfg.send_capacity, _cfg.rt_timeout, _cfg.fixed_isn&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! outbound queue of segments that the TCPConnection wants sent</span></span><br><span class="line">   <span class="comment">// 把要发送的segment放在这里就行了</span></span><br><span class="line">   std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Should the TCPConnection stay active (and keep ACKing)</span></span><br><span class="line">   <span class="comment">//! for 10 * _cfg.rt_timeout milliseconds after both streams have ended,</span></span><br><span class="line">   <span class="comment">//! in case the remote TCPConnection doesn&#x27;t know we&#x27;ve received its whole stream?</span></span><br><span class="line">   <span class="type">bool</span> _linger_after_streams_finish&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 也许需要调用TCPSender的fill_window()，然后从其segment_out中取出来，再发送给自己的segment_out</span></span><br><span class="line">   <span class="comment">// Initiate a connection by sending a SYN segment初始化connection并且发送SYN</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  这几个都很好实现，都很直观，只需调sender和receiver的API就行  */</span></span><br><span class="line">   <span class="comment">// 由上层socket调用，data路径 socket-&gt;connection-&gt;sender.stream_in().write()</span></span><br><span class="line">   <span class="comment">//! \brief Write data to the outbound byte stream, and send it over TCP if possible</span></span><br><span class="line">   <span class="comment">//! \returns the number of bytes from `data` that were actually written.</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;data)</span></span>;</span><br><span class="line">   <span class="comment">//! \returns the number of `bytes` that can be written right now.</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="comment">//! \brief Shut down the outbound byte stream (still allows reading incoming data)</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">end_input_stream</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//! \brief The inbound byte stream received from the peer</span></span><br><span class="line">   <span class="function">ByteStream &amp;<span class="title">inbound_stream</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">stream_out</span>(); &#125;</span><br><span class="line">   <span class="comment">// number of bytes sent and not yet acknowledged, counting SYN/FIN each as one byte</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">bytes_in_flight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="comment">//! \brief number of bytes not yet reassembled</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">unassembled_bytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief Number of milliseconds since the last segment was received</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// debug用</span></span><br><span class="line">   <span class="comment">//!&lt; \brief summarize the state of the sender, receiver, and the connection</span></span><br><span class="line">   <span class="function">TCPState <span class="title">state</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &#123;_sender, _receiver, <span class="built_in">active</span>(), _linger_after_streams_finish&#125;; &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这些函数都会由上层在某些时候调用</span></span><br><span class="line">   <span class="comment">// 时钟滴答、收到segment以及从segment_out中取数据，这些都是由os调用相应函数实现的</span></span><br><span class="line">   <span class="comment">// 这也正是所谓“协议”的接口意义！</span></span><br><span class="line">   <span class="comment">//! \name Methods for the owner or operating system to call</span></span><br><span class="line">   <span class="comment">//! Called when a new segment has been received from the network</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Called periodically when time elapses</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief TCPSegments that the TCPConnection has enqueued for transmission.</span></span><br><span class="line">   <span class="comment">//! \note The owner or operating system will dequeue these and</span></span><br><span class="line">   <span class="comment">//! put each one into the payload of a lower-layer datagram (usually Internet datagrams (IP),</span></span><br><span class="line">   <span class="comment">//! but could also be user datagrams (UDP) or any other kind).</span></span><br><span class="line">   <span class="function">std::queue&lt;TCPSegment&gt; &amp;<span class="title">segments_out</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _segments_out; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \brief Is the connection still alive in any way?</span></span><br><span class="line">   <span class="comment">//! \returns `true` if either stream is still running or if the TCPConnection is lingering</span></span><br><span class="line">   <span class="comment">//! after both streams have finished (e.g. to ACK retransmissions from the peer)</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">active</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! Construct a new connection from a configuration</span></span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">TCPConnection</span><span class="params">(<span class="type">const</span> TCPConfig &amp;cfg)</span> : _cfg&#123;</span>cfg&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! \name construction and destruction</span></span><br><span class="line">   <span class="comment">//! moving is allowed; copying is disallowed; default construction not possible</span></span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">TCPConnection</span>();  <span class="comment">//!&lt; destructor sends a RST if the connection is still open</span></span><br><span class="line">   <span class="built_in">TCPConnection</span>() = <span class="keyword">delete</span>;</span><br><span class="line">   <span class="built_in">TCPConnection</span>(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">   TCPConnection &amp;<span class="keyword">operator</span>=(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">   <span class="built_in">TCPConnection</span>(<span class="type">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">   TCPConnection &amp;<span class="keyword">operator</span>=(<span class="type">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>这部分暂时还不大明白，随便瞎写一点（）</p>
<p>首先是socket实现，似乎要涉及到对一些事件，比如说<code>segment receive</code>的监听。它具体是这么做的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_helper/tcp_sponge_socket.cc  _initialize_TCP()</span></span><br><span class="line">    <span class="comment">// Set up the event loop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are four possible events to handle:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 1) Incoming datagram received (needs to be given to</span></span><br><span class="line">    <span class="comment">//    TCPConnection::segment_received method)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 2) Outbound bytes received from local application via a write()</span></span><br><span class="line">    <span class="comment">//    call (needs to be read from the local stream socket and</span></span><br><span class="line">    <span class="comment">//    given to TCPConnection::data_written method)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 3) Incoming bytes reassembled by the TCPConnection</span></span><br><span class="line">    <span class="comment">//    (needs to be read from the inbound_stream and written</span></span><br><span class="line">    <span class="comment">//    to the local stream socket back to the application)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 4) Outbound segment generated by TCP (needs to be</span></span><br><span class="line">    <span class="comment">//    given to underlying datagram socket)</span></span><br></pre></td></tr></table></figure>

<p>比如说event4：</p>
<p><img src="/2023/02/25/cs144/image-20230304171810877.png" alt="image-20230304171810877"></p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_61233877/article/details/124349171">什么是eventloop</a></p>
<p>事件循环（event loop）就是 任务在主线程不断进栈出栈的一个循环过程。任务会在将要执行时进入主线程，在执行完毕后会退出主线程。</p>
<p>这里的大致意思就是增加了一个监听事件，一旦tcp_connection的segments_out有元素，就会马上取出来</p>
</blockquote>
<p>这部分不大懂，不知道后面会不会涉及对socket的编写？</p>
<p>还有一点是对测试脚本好像有了点了解。比如在<code>build/CTestTestfile.cmake</code>中可以看到每个测试的对应脚本以及使用的options：</p>
<p><img src="/2023/02/25/cs144/image-20230304170132380.png" alt="image-20230304170132380"></p>
<p>如果不知道option的用法可以这么做：</p>
<p><img src="/2023/02/25/cs144/image-20230305232621024.png" alt="image-20230305232621024"></p>
<p>这些脚本实现的对应代码在<code>sponge/apps</code>中。</p>
<p>又比如，在<code>sponge/etc/tests.cmake</code>中，可以找到各个测试程序执行的参数，就可以比如说修改测试的Timeout时间：</p>
<p><img src="/2023/02/25/cs144/image-20230305232913611.png" alt="image-20230305232913611"></p>
<h3 id="总结：状态机"><a href="#总结：状态机" class="headerlink" title="总结：状态机"></a>总结：状态机</h3><p>我们已经完整实现了整个TCP协议，是时候该对其做出一个总结了。</p>
<p>TCP协议本质上是一个<strong>状态机</strong>。</p>
<p>在我们的sponge TCP中，我们将一个endpoint的TCP协议分成了两个状态机，一个是<code>TCPReceiver</code>的状态机，另一个是<code>TCPSender</code>的状态机。它们依据外界的输入【从app或者互联网】来进行状态的转移。</p>
<p>以下几张图完美地体现了状态转移关系【具体的状态体现标注在代码中了】：</p>
<p><img src="/2023/02/25/cs144/image-20230226200935395.png" alt="image-20230226200935395"></p>
<p><img src="/2023/02/25/cs144/image-20230226202631406.png" alt="image-20230226202631406"></p>
<p><img src="/2023/02/25/cs144/image-20230305225738049.png" alt="image-20230305225738049"></p>
<p><img src="/2023/02/25/cs144/image-20230225232723083-1678028236763-1.png" alt="image-20230225232723083"></p>
<p>而<code>TCPConnection</code>并不是状态机，它是两个状态机和外界联通的<u>桥梁</u>。它的职能有：</p>
<ol>
<li><p>给状态机提供输入</p>
<p>包括：</p>
<ol>
<li>app调用<code>write</code>传进来的数据</li>
<li>peer通过<code>segment_received</code>传进来的数据</li>
</ol>
</li>
<li><p>处理状态机的输出</p>
<p>包括：</p>
<ol>
<li>app调用receiver的stream接口获取数据</li>
<li>通过<code>send_segment</code>向peer传递数据</li>
</ol>
</li>
</ol>
<p>也可以说，它具有显式推动状态机状态转移的作用，比如说：</p>
<ol>
<li>给状态机传递外界数据让他们转移</li>
<li><code>connect</code>通过调用<code>fill_window</code>推动<code>_sender</code>从CLOSED状态转移到SYN_SENT状态</li>
<li>转移到ERROR状态的条件判断</li>
</ol>
<p>等等等。</p>
<p>也因而，<code>TCPConnection</code>并不包含复杂的逻辑和算法，它仅仅是做一些条件判断，以及一些数据转发的工作。</p>
<h3 id="喜闻乐见的bug合集"><a href="#喜闻乐见的bug合集" class="headerlink" title="喜闻乐见的bug合集"></a>喜闻乐见的bug合集</h3><p>相比于代码的编写，本次实验最难的部分是测试。由于lab4基于lab0-3，因而前面没有发现的bug在本次黑压压162个测试之下会全部涌现出来。有些bug我还是不知道怎么回事，并且debug过程也不像xv6那样条理清晰步步为营，感觉充满着不少玄幻色彩，所以<strong>也没有很多干货好说</strong>。在这里就先记录下印象比较深刻，耗时比较久的bug吧。</p>
<h4 id="TCP-produced-‘ackno-1’"><a href="#TCP-produced-‘ackno-1’" class="headerlink" title="TCP produced ‘ackno=1’"></a>TCP produced ‘ackno=1’</h4><p><img src="/2023/02/25/cs144/image-20230303214944132.png" alt="image-20230303214944132"></p>
<p>需要发送一个ackno=2的帧，但是不知道为什么却发送了一个ackno=1的，并且无论我怎么找，在哪里print，都只能找到一个ackno=2的，连1的影子都看不到。这个现象确实很诡异，但其实它的内因很简单。它是由于我对空的ACK帧发送条件限制得不恰当才出现的。</p>
<blockquote>
<p>有没有觉得这里有点跳跃？我是怎么通过这个现象得知是ACK发送不恰当导致的？</p>
<p>答案是我当时也没想到这一点，无头苍蝇般转了可能有一个小时，这里print一下那里print一下都没有发现异常。最后我放弃了这个用例去看下一个错误的用例，才发现了这个小bug，改了一下发现这个也一起过了【绷】</p>
</blockquote>
<p>本来我是这么写的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把_sender的所有segment都发送出去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当没有要发送的帧，无法进行顺带ACK时，就只能发送一个只有ACK的空帧</span></span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            _sender.<span class="built_in">send_empty_ack_segment</span>(_receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in segment_received()</span></span><br><span class="line">    <span class="comment">//if (seg.length_in_sequence_space() != 0) &#123;</span></span><br><span class="line">    <span class="comment">//    empty_ack_send();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br></pre></td></tr></table></figure>

<p>如果这么写的话，当这台endpoint收到peer的一个empty ACK后，它就也会以示敬意回复一个empty ACK，这样除了本应发过去的ackno=2的报文，就多了个幽灵般的ackno=1的empty ACK，从而导致上面的错误。</p>
<p>因而，正确的做法是，我们在receive时只对**!empty**的seg进行ACK回复就行。具体写法可以看看我下面的代码。</p>
<h4 id="超时重传时间翻倍问题"><a href="#超时重传时间翻倍问题" class="headerlink" title="超时重传时间翻倍问题"></a>超时重传时间翻倍问题</h4><p><img src="/2023/02/25/cs144/image-20230303224104016.png" alt="image-20230303224104016"></p>
<p><img src="/2023/02/25/cs144/image-20230303224053277.png" alt="image-20230303224053277"></p>
<p>可以看到，它是想要我们在1000ms后再发一次FIN的，也即rto依然等于1000，但是我们的rto却是2000.为啥呢？那就去看看超时重传呗。</p>
<p>原来的超时重传代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_sender.cc</span></span><br><span class="line"><span class="keyword">if</span> (timer_start &amp;&amp; ticks &gt; timer_ticks &amp;&amp; ticks - timer_ticks &gt;= rto) &#123;</span><br><span class="line">    <span class="comment">// resend</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(tmp_segments.<span class="built_in">front</span>().segment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (window_size != <span class="number">0</span>) &#123;</span><br><span class="line">        cons_retran++;</span><br><span class="line">        rto *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer_ticks = ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改完后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (timer_start &amp;&amp; ticks &gt; timer_ticks &amp;&amp; ticks - timer_ticks &gt;= rto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tmp_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// resend</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(tmp_segments.<span class="built_in">front</span>().segment);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (window_size != <span class="number">0</span>) &#123;</span><br><span class="line">            cons_retran++;</span><br><span class="line">            rto *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    timer_ticks = ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想想超时重传的定义，是不是重传了之后才会double时间呀（）</p>
<h4 id="assembler"><a href="#assembler" class="headerlink" title="assembler"></a>assembler</h4><p><img src="/2023/02/25/cs144/image-20230304163111298.png" alt="image-20230304163111298"></p>
<p>这个test花了我半个下午的时间排查和修改。大致流程及报错信息是，一方发了65000个byte，但是另一方只能收到&lt;&lt;65000个。最后print了一下，发现是<code>streamassembler</code>写错了，在stream end的时候仍然有很大一部分数据未被整流。</p>
<blockquote>
<p>这个直面屎山的经历极大地鼓舞了我</p>
</blockquote>
<p>之前在写<code>streamassembler</code>的时候就知道有个地方是错的了，那就是我对capacity的理解【具体见前面的笔记】。现在只用改一下就好了。修改方式很简单，加上这两句话就行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">right = right &lt;= left_bound + _capacity ? right : left_bound + _capacity;  <span class="comment">// 右边越界的也不要</span></span><br><span class="line"><span class="keyword">if</span> (o_left &gt;= left_bound + _capacity)       <span class="keyword">goto</span> end;  <span class="comment">// 越界的不要</span></span><br></pre></td></tr></table></figure>

<h4 id="t-udp-client-send超时"><a href="#t-udp-client-send超时" class="headerlink" title="t_udp_client_send超时"></a><code>t_udp_client_send</code>超时</h4><p><img src="/2023/02/25/cs144/image-20230304215748823.png" alt="image-20230304215748823"></p>
<p>这个错因非常地诡异，我到最后也还是没有自己找出来。直到我瞎搜来搜去看到了这篇文章：</p>
<blockquote>
<p>我也是真的很佩服这篇文章的作者能找到这个点</p>
<p><img src="/2023/02/25/cs144/image-20230304221420748.png" alt="image-20230304221420748"></p>
<p><a href="https://www.cnblogs.com/lawliet12/p/17066719.html">https://www.cnblogs.com/lawliet12/p/17066719.html</a></p>
</blockquote>
<p><img src="/2023/02/25/cs144/image-20230305215310021.png" alt="image-20230305215310021"></p>
<p>噔噔咚。</p>
<p>我为什么不用<code>_cfg.rt_timeout</code>呢？答案是我当初脑子一抽以为<code>rt_timeout</code>是static、const的，就写了个<code>TCPConfig::rt_timeout</code>然后报错了，我懒得思考了就换成了上面的那个，结果……就这东西，又花费了我好久好久【悲】怪我没有认真看，没发现<code>rt_timeout</code>不是一个静态常量。</p>
<h4 id="t-ucS-1M-32K超时"><a href="#t-ucS-1M-32K超时" class="headerlink" title="t_ucS_1M_32K超时"></a><code>t_ucS_1M_32K</code>超时</h4><p><img src="/2023/02/25/cs144/image-20230305162239877.png" alt="image-20230305162239877"></p>
<p>以及其后面的其他test也都超时了。</p>
<p>说实话我真是百思不得其解，这里打印来那里打印去，也都看得眼花缭乱什么也看不出来，使用指导书那些手动测试的方法，还有抓包，都十分地正常，但它自动测试就是会timeout。</p>
<p>我折腾来折腾去，这里print那里print，最后还怀疑是电脑问题就放到服务器上跑了一下结果还是不行。绝望之际，我只能使出了<strong>万策尽之时的迫不得已的非法手段</strong>：将我的一部分代码替换成别人的看看会怎么样。【传统艺能23333】</p>
<p>最终我定位发现是<code>TCPSender</code>出了问题，我猜测是因为状态机出错了。我比对着别人的代码【知道这不对，但我心态已经崩了。。。】，以及指导书提供的状态机，发现是这个地方出了小问题：</p>
<p><img src="/2023/02/25/cs144/image-20230305220614819.png" alt="image-20230305220614819"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in tcp_sender.cc fill_window()</span></span><br><span class="line">		<span class="comment">// 注释的是以前写的错误版本</span></span><br><span class="line">        <span class="comment">// if (_stream.input_ended() &amp;&amp; !fin &amp;&amp; remaining &gt; 0) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !fin &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// last segment</span></span><br><span class="line">            segment.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">            fin = <span class="literal">true</span>;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里不应该是<code>input_ended</code>，而应该是<code>eof</code>……</p>
<p>改了之后立刻所有测试都能跑通了【悲】</p>
<blockquote>
<p>那么问题来了，为什么错误版本就会timeout呢？我的猜测如下：</p>
<p>eof的条件如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_input_end &amp;&amp; buffer.<span class="built_in">empty</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，eof既要求input_ended，又要求缓冲区内所有数据成功发送。这也很符合FIN_SENT的语义：在数据流终止时（所有数据成功发送，不要求fully acked）发送FIN。</p>
<p>如果按照我错误版本的写法，会导致数据还没发送完毕（<code>!buffer.empty()</code>），就发送了FIN。之后数据虽然还能正常进入receiver的bytestream，并且发送给peer的receiver。但是会存在这也一个空窗期：FIN之后的数据还没到的时候，peer的receiver接收到FIN，并且peer的app从socket将receiver接收到的数据全部读出。出现了这样的空窗期，就会导致peer的receiver的stream达到eof状态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in tcp_receiver.cc segment_received()</span></span><br><span class="line">     <span class="keyword">if</span> (abs_seqno != <span class="number">0</span>)</span><br><span class="line">         _reassembler.<span class="built_in">push_substring</span>(data, index, header.fin);</span><br><span class="line"><span class="comment">// in streamassembler.cc</span></span><br><span class="line"> <span class="keyword">if</span> (is_eof &amp;&amp; buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">     _output.<span class="built_in">end_input</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>【接下来就是猜了】由于bytestream eof了，socket就停止读了。后来的数据再来，receiver的stream的缓冲区就满了，receiver就只能一直丢包。【接下来是真的<strong>纯猜</strong>】而且由于测试脚本问题，在这之后都不会调用tick方法了，故而超时重传检测不会被触发，而sender也会因为没有ack，而一直重传重传，就死循环然后timeout寄掉了。</p>
<p>纯猜部分的依据是：</p>
<p><img src="/2023/02/25/cs144/image-20230305173110776.png" alt="image-20230305173110776"></p>
<p><img src="/2023/02/25/cs144/image-20230305173152469.png" alt="image-20230305173152469"></p>
<p>可以看到，tick方法一直被调用，但是ticks却不变。数据报文一直被重传，但是retran一直不变。ticks-timer_ticks一直大于rto，但却始终无法进入那句if（经测试是这样的）。这非常奇怪，我也不知道为什么。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>【珍贵的调试用代码没删的版本放在github了。】</p>
<h3 id="TCPConnection-hh"><a href="#TCPConnection-hh" class="headerlink" title="TCPConnection.hh"></a>TCPConnection.hh</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPConnection</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="type">size_t</span> rec_tick&#123;&#125;;<span class="comment">// 上一次收到segment时的ticks数</span></span><br><span class="line">    <span class="type">size_t</span> ticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">segment_send</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">empty_ack_send</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_rst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="TCPConnection-cc"><a href="#TCPConnection-cc" class="headerlink" title="TCPConnection.cc"></a>TCPConnection.cc</h3><p>如果想要以状态机的视角来看待，可以看看<a href="https://github.com/shootfirst/CS144/">感恩</a>的代码。他写得很清晰。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_connection.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ticks - rec_tick; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一个只有ACK的空帧，仅在segment_received中调用</span></span><br><span class="line"><span class="comment">// 当没有要发送的帧，无法进行顺带ACK时，</span></span><br><span class="line"><span class="comment">// 为了保障一定有ACK发送，就只能发送一个只有ACK的空帧</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::empty_ack_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            _sender.<span class="built_in">send_empty_ack_segment</span>(_receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把_sender的所有segment都发送出去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// 顺带ACK</span></span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connection被置为error状态的部分必要操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::set_rst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重置发送的ticks</span></span><br><span class="line">    rec_tick = ticks;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        <span class="comment">// RST is set</span></span><br><span class="line">        <span class="built_in">set_rst</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回复对方问你是死是活的信息</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        seg.<span class="built_in">header</span>().seqno - _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">        <span class="built_in">segment_send</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123; <span class="comment">// ack_received也会调用fill_window</span></span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 只在本次收到的seg需要被ACK的时候才要ACK。</span></span><br><span class="line">    <span class="comment">// 需要被ACK：FIN/SYN/携带数据   总之就是length!=0</span></span><br><span class="line">    <span class="comment">// 不得不说，FIN和SYN都会占一个序列号这个点给ACK设计带来了简便，同时也增加了安全性</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">empty_ack_send</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If the inbound stream ends before the TCPConnection has reached EOF </span></span><br><span class="line">    <span class="comment">// on its outbound stream, this variable needs to be set to false</span></span><br><span class="line">    <span class="comment">// 如果receiver的那个stream比sender的stream早结束，就不用等待</span></span><br><span class="line">    <span class="comment">// 为什么呢？因为receiver的stream结束说明了全部的seg都成功接收并且全部整流【参见assembler实现】</span></span><br><span class="line">    <span class="comment">// 也就说明对方不发送数据了，并且已经把FIN也发过来了</span></span><br><span class="line">    <span class="comment">// 也即对方进入了FIN_WAIT状态</span></span><br><span class="line">    <span class="comment">// 而我们的sender还在输出，也即我们在CLOSE_WAIT状态</span></span><br><span class="line">    <span class="comment">// 因而我们只需输出完剩余数据再发送AF,最后直接关闭就行</span></span><br><span class="line">    <span class="comment">// 因为我们知道对方已经关闭了，无需再进行linger。</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; !_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        <span class="comment">// peer:FIN_WAIT   self:CLOSE_WAIT</span></span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="comment">// 处于error状态</span></span><br><span class="line">    <span class="keyword">if</span> (!_linger_after_streams_finish &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">error</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">error</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 满足条件1-3</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp;</span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">fully_acked</span>()) &#123;</span><br><span class="line">        <span class="comment">// 无需等待的话就直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!_linger_after_streams_finish)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 否则需要等待10*timeout</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">time_since_last_segment_received</span>() &gt;= <span class="number">10</span> * _cfg.rt_timeout)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> res = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    <span class="comment">// 注意此处需要手动调一下fill_window和send方法</span></span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ms_since_last_tick: number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    ticks += ms_since_last_tick;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; _cfg.MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>())</span><br><span class="line">            _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();  <span class="comment">// 清除sender遗留的所有帧</span></span><br><span class="line">        _sender.<span class="built_in">send_empty_rst_segment</span>();<span class="comment">// 只发送rst帧</span></span><br><span class="line">        <span class="built_in">set_rst</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// end the connection cleanly if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp;</span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">fully_acked</span>()</span><br><span class="line">	&amp;&amp; <span class="built_in">time_since_last_segment_received</span>() &gt;= <span class="number">10</span> * _cfg.rt_timeout) &#123;</span><br><span class="line">        <span class="comment">// 等待结束</span></span><br><span class="line">	    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">segment_send</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="comment">// send_segment重复代码。目的是防止发送SYN外还发送别的东西</span></span><br><span class="line">    <span class="keyword">if</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// shutdown uncleanly</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">	    	<span class="built_in">set_rst</span>();</span><br><span class="line">            _sender.<span class="built_in">send_empty_rst_segment</span>();</span><br><span class="line">            <span class="built_in">segment_send</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="debug函数"><a href="#debug函数" class="headerlink" title="debug函数"></a>debug函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in libsponge/tcp_helper/tcp_segment.hh</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_seg</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">         std::cerr&lt;&lt;<span class="string">&quot;  flag=&quot;</span>&lt;&lt;(<span class="built_in">header</span>().syn?<span class="string">&quot;S&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;(<span class="built_in">header</span>().ack?<span class="string">&quot;A&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;(<span class="built_in">header</span>().fin?<span class="string">&quot;F&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">            &lt;&lt;<span class="string">&quot;  seqno=&quot;</span>&lt;&lt;<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>()&lt;&lt;<span class="string">&quot;   ackno=&quot;</span>&lt;&lt;<span class="built_in">header</span>().ackno.<span class="built_in">raw_value</span>()</span><br><span class="line">            &lt;&lt;<span class="string">&quot;  payload_size:&quot;</span>&lt;&lt;<span class="built_in">payload</span>().<span class="built_in">size</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>in libsponge/tcp_helper/fd_adapter.cc</code></p>
<p><img src="/2023/02/25/cs144/image-20230304172207234.png" alt="image-20230304172207234"></p>
]]></content>
  </entry>
  <entry>
    <title>Lab6   Router</title>
    <url>/2023/02/25/cs144$lab6/</url>
    <content><![CDATA[<h1 id="Lab6-Router"><a href="#Lab6-Router" class="headerlink" title="Lab6   Router"></a>Lab6   Router</h1><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="要做什么"><a href="#要做什么" class="headerlink" title="要做什么"></a>要做什么</h3><p>本次实验要实现的是IP层的路由工作，但是只用实现对路由表进行操作的部分，比如说增加表项以及查询路由表等，其他的什么RIP、OSPF都不用我们实现，所以这样一来其实就简单非常多了（）</p>
<p>有一点需要注意的是，它一直在强调一个“最长前缀匹配”。也就是：</p>
<p><img src="/2023/02/25/cs144/image-20230309142032359.png" alt="image-20230309142032359"></p>
<p><img src="/2023/02/25/cs144/image-20230309141949757.png" alt="image-20230309141949757"></p>
<p>还有一点需要注意的是路由的结构：</p>
<p><img src="/2023/02/25/cs144/image-20230308142934287.png" alt="image-20230308142934287"></p>
<p>实际上就是路由表+一堆网络接口，这些端口都是network interface。</p>
<blockquote>
<p>路由器可分为两部分，一部分控制路由协议，包括完善路由表之类的；另一部分负责数据转发。</p>
<p>负责接收数据的端口既可能收到数据，也可能收到路由信息报文。收到前者，则需要查询转发表然后进行路由转发；收到后者，就需要将其交付给路由选择处理机进行处理。</p>
<p>它有一个地方说得很有意思：路由表需要对网络拓扑最优化，转发表需要使查找过程最优化</p>
<p>也就是说，路由表只是key为目的IP地址，value为下一跳IP地址的一个普通map，可以是unordered_map，因为无需对它进行查找操作；转发表的内容可能跟路由表差不多，但是由于它要被进行频繁的查找工作，因而其数据结构需要对查找的消耗较低。</p>
<p>不过在我们这边，一般不区分路由表和转发表的概念。</p>
</blockquote>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>说实话思路很直观很简单，懒得说了，直接看代码吧【开摆】</p>
<p>我唯一卡得比较久的有两个地方，一个是一开始数据结构选用的是set，图它的天然排序，针对<code>prefix_length</code>排序来优化查找，但是没有意识到，对于自定义比较运算符的结构体，set也是会自动去重的（）而不同路由项的<code>prefix_length</code>显然可以重复。因而这样是达咩的，最后不得已选用了一个普通的list。</p>
<p>另一个是子网掩码计算问题，刚开始一个小地方想错了。这个没什么好说的，纯纯脑子一抽。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">route_node</span> &#123;</span><br><span class="line">        <span class="type">uint32_t</span> route_prefix = <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint8_t</span> prefix_length = <span class="number">0</span>;</span><br><span class="line">        std::optional&lt;Address&gt; next_hop&#123;&#125;;</span><br><span class="line">        <span class="type">size_t</span> interface_num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 降序</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> route_node &amp;b) <span class="type">const</span> &#123; <span class="keyword">return</span> prefix_length &gt; b.prefix_length; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::list&lt;route_node&gt; route_table&#123;&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::add_route</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="type">size_t</span> interface_num)</span> </span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: adding route &quot;</span> &lt;&lt; Address::<span class="built_in">from_ipv4_numeric</span>(route_prefix).<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">int</span>(prefix_length)</span><br><span class="line">         &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; (next_hop.<span class="built_in">has_value</span>() ? next_hop-&gt;<span class="built_in">ip</span>() : <span class="string">&quot;(direct)&quot;</span>) &lt;&lt; <span class="string">&quot; on interface &quot;</span> &lt;&lt; interface_num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    route_node node;</span><br><span class="line">    node.route_prefix = route_prefix;</span><br><span class="line">    node.prefix_length = prefix_length;</span><br><span class="line">    node.next_hop = next_hop;</span><br><span class="line">    node.interface_num = interface_num;</span><br><span class="line">    route_table.<span class="built_in">push_back</span>(node);</span><br><span class="line">    route_table.<span class="built_in">sort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] dgram The datagram to be routed</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::route_one_datagram</span><span class="params">(InternetDatagram &amp;dgram)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 减少TTL</span></span><br><span class="line">    <span class="keyword">if</span> (dgram.<span class="built_in">header</span>().ttl &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// drop</span></span><br><span class="line">    dgram.<span class="built_in">header</span>().ttl -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> target_ip = dgram.<span class="built_in">header</span>().dst;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = route_table.<span class="built_in">begin</span>(); it != route_table.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> mask = <span class="number">0</span>;</span><br><span class="line">        mask = (((~mask) &gt;&gt; (<span class="number">32</span>-it-&gt;prefix_length)) &lt;&lt; (<span class="number">32</span>-it-&gt;prefix_length));</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;prefix_length == <span class="number">0</span> || ((it-&gt;route_prefix &amp; mask) == (target_ip &amp; mask)))&#123;</span><br><span class="line">            <span class="comment">// 发送报文</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;next_hop.<span class="built_in">has_value</span>())</span><br><span class="line">                <span class="built_in">interface</span>(it-&gt;interface_num).<span class="built_in">send_datagram</span>(dgram, it-&gt;next_hop.<span class="built_in">value</span>());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">interface</span>(it-&gt;interface_num).<span class="built_in">send_datagram</span>(dgram,</span><br><span class="line">Address::<span class="built_in">from_ipv4_numeric</span>(dgram.<span class="built_in">header</span>().dst));</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 一定是最长前缀</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Go through all the interfaces, and route every incoming datagram to its proper outgoing interface.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;interface : _interfaces) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;queue = interface.<span class="built_in">datagrams_out</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">not</span> queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">route_one_datagram</span>(queue.<span class="built_in">front</span>());</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>cs144</title>
    <url>/2023/02/25/cs144/</url>
    <content><![CDATA[<blockquote>
<p>总耗时：65h  约17天</p>
<p><a href="https://cs144.github.io/">实验官网</a></p>
<p><a href="https://github.com/shootfirst/CS144/">感恩</a></p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本实验总体思维和代码上的难度还是不难的（至少比xv6简单），我认为其难点主要集中在TCP协议本身就很复杂很多的细节问题，以及需要我们有一种面向测试用例编程、直面自己往日写过的屎山的勇气（。</p>
<p>下面，我将对本实验的完成情况即心得进行一个总结，也算是本篇博客/本次实验的一个<strong>导读</strong>。</p>
<blockquote>
<p><strong>类似于这样的块引用中的部分是我自认为的精华部分</strong>。</p>
</blockquote>
<p>本实验对TCP-IP-ETH协议栈的实验是自顶向下的，其中对TCP协议的实现是由内而外的。</p>
<p>后者很容易导致，在对TCP协议的实现中，当你写完了lab0-3，你还是不知道自己到底写了个啥，以及TCP又究竟怎么通过你写的那几个类run起来。直到lab4结束，你完成了对TCP状态机的组织，并且出于debug目的钻研过部分socket的代码、熟悉了（其实差不多已经背下来了）TCP的三握手四挥手的过程，至此你才会对TCP的实现有较为清晰的理解。这个过程很痛苦，但是也真的非常爽。</p>
<blockquote>
<p>关于TCP状态机的理解总结，请参见<a href="https://xiunianjun.github.io/2023/02/25/cs144$lab4/#:~:text=%E7%9A%84Timeout%E6%97%B6%E9%97%B4%EF%BC%9A-,%E6%80%BB%E7%BB%93%EF%BC%9A%E7%8A%B6%E6%80%81%E6%9C%BA,-%E6%88%91%E4%BB%AC%E5%B7%B2%E7%BB%8F%E5%AE%8C%E6%95%B4">Lab4 TCPConnection——心得——总结：状态机</a>部分。</p>
</blockquote>
<p>然而，实现了TCP协议之后，我们还是不知道，在<code>TCPConnection</code>中发送的数据包，又是如何到达网络上的另一个host处的，我们究竟又写了个啥。</p>
<p>这时，官方贴心地为我们指了条明路：它告诉我们，我们在lab0-4实现的是TCP-IP协议栈，其中运输层和网络层由用户实现，其他更底层则由内核实现，二者通过操作系统提供的TUN接口进行交互。也即，我们之前实现的是<strong>用户态TCP协议</strong>！而我们接下来的学习目标，就是从内核中再夺走一些权力：数据链路层也要由我们自己实现！</p>
<blockquote>
<p>关于此处的TCP-IP架构等，请参见<a href="https://xiunianjun.github.io/2023/02/25/cs144$lab5/#:~:text=%E7%94%B1%E8%BD%AC%E5%8F%91%E7%AE%97%E6%B3%95%E3%80%82-,%E6%89%BF%E4%B8%8A%E5%90%AF%E4%B8%8B,-%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%9E%B6%E6%9E%84">Lab5 NetworkInterface——Overview——承上启下</a></p>
</blockquote>
<p>故而，接下来，我们将实现用户态的TCP-IP-ETH协议栈。在lab5，我们将目光投向TCP层以下的数据链路层(网络层官方已经帮我们实现了)，实现ETH协议和ARP协议；在lab6，我们则需要实现路由查找的功能。</p>
<p>至此，所有实验已经结束。写完了上述实验，我们对协议栈已经具有了很深刻的了解，对TCP—IP—ETH—TAN—Internet—TAN—ETH—IP—TCP的这个数据传输过程也已经是懂王了。</p>
<p>然而，我们在<code>TCPConnection</code>，只知道会有<strong>好心人</strong>，在上层app有数据传进来的时候调用<code>write</code>、在下层协议栈有segment传进来的时候调用<code>segment_received</code>、取出<code>_segment_out</code>的segment向底层协议栈发送、读走<code>outputstream</code>的内容。但是这个所谓的“好心人”具体是怎么做到的，怎么实现的，我们一概不知。</p>
<p>答案是，这个所谓的“好心人”，其实就是我们的<code>TCPSpongeSocket</code>。它向上将协议栈与上层app连接，向下又将协议栈与TAN接口结合。</p>
<blockquote>
<p>发送数据时，数据流向：上层app→（通过<code>TCPSpongeSocket</code>）<code>TCPConnection</code>→（通过<code>write</code>方法）<code>ByteStream</code>→<code>TCPSender</code>→（通过从<code>_sender.segments_out</code>读）<code>TCPConnection</code>→（通过<code>TCPSpongeSocket</code>的adapter）<code>TAN</code></p>
<p>接收数据时，数据流向：<code>TAN</code>→（通过<code>TCPSpongeSocket</code>的adapter）<code>TCPConnection</code>→<code>TCPReceiver</code>→（中间经过<code>StreamAssembler</code>）<code>BYteStream</code>→（通过<code>TCPSpongeSocket</code>读）上层app</p>
<p>在<code>TCPSpongeSocket</code>的adapter中：TCPsegment←→IP数据报←→ETH帧</p>
<p>至于ETH帧进入TAN之后的过程？在xv6的网卡驱动那一节我们事实上已经实现过了！</p>
</blockquote>
<p><code>CS144TCPSocket</code>和<code>FullStackTCPSokect</code>都继承自<code>TCPSpongeSocket</code>。<code>TCPSpongeSocket</code>通过一个包装了操作系统提供的socket的包装类<code>_thread_data</code>来与上层app进行交互，通过adapter<code>_datagram_adapter</code>来与协议栈进行交互（adapter本质上也是调用了操作系统的TUN/TAN接口）。</p>
<p>由于<code>_thread_data</code>和<code>_datagram_adapter</code>本质上都是文件描述符【牛逼吧】，因而，<code>TCPSpongeSocket</code>需要跟上下层进行交互的需求，就可以通过操作系统提供的<strong>POLL机制</strong>来实现，也即，app←→TCP、TCP←→协议栈的这四种数据交互情况，都用<strong>事件监听</strong>来实现！当有datagram需要传入的时候会在事件处理体之中调用我们实现的tcp协议的segment_receive，同样在tcp的segement_out非空时将其发送。这样就能做到“及时”“高效”了。</p>
<blockquote>
<p>关于此处<code>TCPSpongeSocket</code>的事件监听机制以及其它实现细节，详见<a href="https://xiunianjun.github.io/2023/02/25/cs144$else/#:~:text=*-,TCPSpongeSocket,-%E4%B8%8A%E9%9D%A2%E9%82%A3%E4%BF%A9">其它的对…——Socket实现——TCPSpongeSocket</a></p>
</blockquote>
<p>至此以来，我们的协议栈才算真正完整了。</p>
<h3 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a><a href="/2023/02/25/cs144$lab0">Lab0</a></h3><h3 id="Lab1-StreamReassembler"><a href="#Lab1-StreamReassembler" class="headerlink" title="Lab1   StreamReassembler"></a><a href="/2023/02/25/cs144$lab1">Lab1   StreamReassembler</a></h3><h3 id="Lab2-TCPReceiver"><a href="#Lab2-TCPReceiver" class="headerlink" title="Lab2   TCPReceiver"></a><a href="/2023/02/25/cs144$lab2">Lab2   TCPReceiver</a></h3><h3 id="Lab3-TCPSender"><a href="#Lab3-TCPSender" class="headerlink" title="Lab3   TCPSender"></a><a href="/2023/02/25/cs144$lab3">Lab3   TCPSender</a></h3><h3 id="Lab4-TCPConnection"><a href="#Lab4-TCPConnection" class="headerlink" title="Lab4   TCPConnection"></a><a href="/2023/02/25/cs144$lab4">Lab4   TCPConnection</a></h3><h3 id="Lab5-NetworkInterface"><a href="#Lab5-NetworkInterface" class="headerlink" title="Lab5   NetworkInterface"></a><a href="/2023/02/25/cs144$lab5">Lab5   NetworkInterface</a></h3><h3 id="Lab6-Router"><a href="#Lab6-Router" class="headerlink" title="Lab6   Router"></a><a href="/2023/02/25/cs144$lab6">Lab6   Router</a></h3><h3 id="其他的对实验未涉及的思考"><a href="#其他的对实验未涉及的思考" class="headerlink" title="其他的对实验未涉及的思考"></a><a href="/2023/02/25/cs144$else">其他的对实验未涉及的思考</a></h3>]]></content>
      <tags>
        <tag>labs</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统</title>
    <url>/2024/07/05/csapp/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/2024/07/05/csapp/image-20240702224531198.png" alt="image-20240702224531198"></p>
<h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="BG"><a href="#BG" class="headerlink" title="BG"></a>BG</h3><p><img src="/2024/07/05/csapp/image-20240628002814940.png" alt="image-20240628002814940"></p>
<p><img src="/2024/07/05/csapp/image-20240628002830814.png" alt="image-20240628002830814"></p>
<p><img src="/2024/07/05/csapp/image-20240628002854006.png" alt="image-20240628002854006"></p>
<h3 id="IEEE"><a href="#IEEE" class="headerlink" title="IEEE"></a>IEEE</h3><p><img src="/2024/07/05/csapp/image-20240628002940522.png" alt="image-20240628002940522"></p>
<p><img src="/2024/07/05/csapp/image-20240628003037704.png" alt="image-20240628003037704"></p>
<p><img src="/2024/07/05/csapp/image-20240628003205567.png" alt="image-20240628003205567"></p>
<p><img src="/2024/07/05/csapp/image-20240628003604607.png" alt="image-20240628003604607"></p>
<p><img src="/2024/07/05/csapp/image-20240628003738042.png" alt="image-20240628003738042"></p>
<p><img src="/2024/07/05/csapp/image-20240628003850523.png" alt="image-20240628003850523"></p>
<p><img src="/2024/07/05/csapp/image-20240628004039980.png" alt="image-20240628004039980"></p>
<p>TODO为什么。。。</p>
<p><img src="/2024/07/05/csapp/image-20240628004109379.png" alt="image-20240628004109379"></p>
<p><img src="/2024/07/05/csapp/image-20240628004127673.png" alt="image-20240628004127673"></p>
<h3 id="示例与性质"><a href="#示例与性质" class="headerlink" title="示例与性质"></a>示例与性质</h3><p><img src="/2024/07/05/csapp/image-20240628004419912.png" alt="image-20240628004419912"></p>
<p><img src="/2024/07/05/csapp/image-20240628004606462.png" alt="image-20240628004606462"></p>
<p><img src="/2024/07/05/csapp/image-20240628004644488.png" alt="image-20240628004644488"></p>
<p><img src="/2024/07/05/csapp/image-20240628004709127.png" alt="image-20240628004709127"></p>
<p>TODO这几张图非常值得细看</p>
<p><img src="/2024/07/05/csapp/image-20240628004748518.png" alt="image-20240628004748518"></p>
<h3 id="舍入、加法、乘法"><a href="#舍入、加法、乘法" class="headerlink" title="舍入、加法、乘法"></a>舍入、加法、乘法</h3><p><img src="/2024/07/05/csapp/image-20240628004826845.png" alt="image-20240628004826845"></p>
<h4 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h4><p><img src="/2024/07/05/csapp/image-20240628004920214.png" alt="image-20240628004920214"></p>
<p><img src="/2024/07/05/csapp/image-20240628004956444.png" alt="image-20240628004956444"></p>
<p><img src="/2024/07/05/csapp/image-20240702230246859.png" alt="image-20240702230246859"></p>
<h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p><img src="/2024/07/05/csapp/image-20240628005030397.png" alt="image-20240628005030397"></p>
<h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p><img src="/2024/07/05/csapp/image-20240628005049221.png" alt="image-20240628005049221"></p>
<h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p><img src="/2024/07/05/csapp/image-20240628005122778.png" alt="image-20240628005122778"></p>
<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><h3 id="位表示"><a href="#位表示" class="headerlink" title="位表示"></a>位表示</h3><p><img src="/2024/07/05/csapp/image-20240629153141129.png" alt="image-20240629153141129"></p>
<p><img src="/2024/07/05/csapp/image-20240629153204463.png" alt="image-20240629153204463"></p>
<p><img src="/2024/07/05/csapp/image-20240629153356447.png" alt="image-20240629153356447"></p>
<p><img src="/2024/07/05/csapp/image-20240629153411140.png" alt="image-20240629153411140"></p>
<p><img src="/2024/07/05/csapp/image-20240629153429921.png" alt="image-20240629153429921"></p>
<p><img src="/2024/07/05/csapp/image-20240629153605927.png" alt="image-20240629153605927"></p>
<p><img src="/2024/07/05/csapp/image-20240629153625384.png" alt="image-20240629153625384"></p>
<p><img src="/2024/07/05/csapp/image-20240629153635004.png" alt="image-20240629153635004"></p>
<p><img src="/2024/07/05/csapp/image-20240629153701055.png" alt="image-20240629153701055"></p>
<p><img src="/2024/07/05/csapp/image-20240629153722963.png" alt="image-20240629153722963"></p>
<p><img src="/2024/07/05/csapp/image-20240629153736890.png" alt="image-20240629153736890"></p>
<p><img src="/2024/07/05/csapp/image-20240629153744355.png" alt="image-20240629153744355"></p>
<p>注意指针</p>
<h3 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h3><h4 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h4><p><img src="/2024/07/05/csapp/image-20240629153906940.png" alt="image-20240629153906940"></p>
<p><img src="/2024/07/05/csapp/image-20240629153941254.png" alt="image-20240629153941254"></p>
<p><img src="/2024/07/05/csapp/image-20240629154024724.png" alt="image-20240629154024724"></p>
<p><img src="/2024/07/05/csapp/image-20240629154052292.png" alt="image-20240629154052292"></p>
<h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><p><img src="/2024/07/05/csapp/image-20240629154136148.png" alt="image-20240629154136148"></p>
<p>最后一句没看懂，如果是补码表示那确实都是了吧</p>
<h3 id="整型数"><a href="#整型数" class="headerlink" title="整型数"></a>整型数</h3><h4 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h4><p><img src="/2024/07/05/csapp/image-20240629154220534.png" alt="image-20240629154220534"></p>
<p><img src="/2024/07/05/csapp/image-20240629154229618.png" alt="image-20240629154229618"></p>
<p><img src="/2024/07/05/csapp/image-20240629154235938.png" alt="image-20240629154235938"></p>
<p><img src="/2024/07/05/csapp/image-20240629161141314.png" alt="image-20240629161141314"></p>
<p><img src="/2024/07/05/csapp/image-20240629161217510.png" alt="image-20240629161217510"></p>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p><img src="/2024/07/05/csapp/image-20240629161314409.png" alt="image-20240629161314409"></p>
<p><img src="/2024/07/05/csapp/image-20240629161333420.png" alt="image-20240629161333420"></p>
<p><img src="/2024/07/05/csapp/image-20240702233325227.png" alt="image-20240702233325227"></p>
<p><img src="/2024/07/05/csapp/image-20240629161447550.png" alt="image-20240629161447550"></p>
<p><img src="/2024/07/05/csapp/image-20240629161509178.png" alt="image-20240629161509178"></p>
<p><img src="/2024/07/05/csapp/image-20240629161602993.png" alt="image-20240629161602993"></p>
<p><img src="/2024/07/05/csapp/image-20240629161612858.png" alt="image-20240629161612858"></p>
<p><img src="/2024/07/05/csapp/image-20240629162956106.png" alt="image-20240629162956106"></p>
<p><img src="/2024/07/05/csapp/image-20240629164841992.png" alt="image-20240629164841992"></p>
<h4 id="扩展和截断"><a href="#扩展和截断" class="headerlink" title="扩展和截断"></a>扩展和截断</h4><p><img src="/2024/07/05/csapp/image-20240629161645313.png" alt="image-20240629161645313"></p>
<p><img src="/2024/07/05/csapp/image-20240629161701432.png" alt="image-20240629161701432"></p>
<p>注意默认符号</p>
<p><img src="/2024/07/05/csapp/image-20240629161727622.png" alt="image-20240629161727622"></p>
<p><img src="/2024/07/05/csapp/image-20240629161810378.png" alt="image-20240629161810378"></p>
<h4 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h4><p><img src="/2024/07/05/csapp/image-20240629162126645.png" alt="image-20240629162126645"></p>
<p><img src="/2024/07/05/csapp/image-20240629162237623.png" alt="image-20240629162237623"></p>
<p><img src="/2024/07/05/csapp/image-20240629162303813.png" alt="image-20240629162303813"></p>
<p><img src="/2024/07/05/csapp/image-20240629162436304.png" alt="image-20240629162436304"></p>
<p><img src="/2024/07/05/csapp/image-20240629162454909.png" alt="image-20240629162454909"></p>
<p><img src="/2024/07/05/csapp/image-20240629162512325.png" alt="image-20240629162512325"></p>
<p><img src="/2024/07/05/csapp/image-20240629162537705.png" alt="image-20240629162537705"></p>
<p><img src="/2024/07/05/csapp/image-20240629162552931.png" alt="image-20240629162552931"></p>
<p><img src="/2024/07/05/csapp/image-20240629162619437.png" alt="image-20240629162619437"></p>
<p>注意向零舍入</p>
<p><img src="/2024/07/05/csapp/image-20240629162827843.png" alt="image-20240629162827843"></p>
<p><img src="/2024/07/05/csapp/image-20240629162839410.png" alt="image-20240629162839410"></p>
<p><img src="/2024/07/05/csapp/image-20240629162900059.png" alt="image-20240629162900059"></p>
<h3 id="内存指针字符串表示"><a href="#内存指针字符串表示" class="headerlink" title="内存指针字符串表示"></a>内存指针字符串表示</h3><p><img src="/2024/07/05/csapp/image-20240629164920573.png" alt="image-20240629164920573"></p>
<p><img src="/2024/07/05/csapp/image-20240629164957997.png" alt="image-20240629164957997"></p>
<p><img src="/2024/07/05/csapp/image-20240629165017470.png" alt="image-20240629165017470"></p>
<p>注意一直都是字节编址的</p>
<p><img src="/2024/07/05/csapp/image-20240629165444674.png" alt="image-20240629165444674"></p>
<p>貌似IA32、Sun都是32位的</p>
<p><img src="/2024/07/05/csapp/image-20240629165503459.png" alt="image-20240629165503459"></p>
<p>所以对于小端系统字符串读取就有点意思</p>
<p><img src="/2024/07/05/csapp/image-20240629165939717.png" alt="image-20240629165939717"></p>
<h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><img src="/2024/07/05/csapp/image-20240629170051669.png" alt="image-20240629170051669"></p>
<p><img src="/2024/07/05/csapp/image-20240629170351822.png" alt="image-20240629170351822"></p>
<h3 id="8086CPU"><a href="#8086CPU" class="headerlink" title="8086CPU"></a>8086CPU</h3><p><img src="/2024/07/05/csapp/image-20240629170440224.png" alt="image-20240629170440224"></p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="/2024/07/05/csapp/image-20240629170510220.png" alt="image-20240629170510220"></p>
<p><img src="/2024/07/05/csapp/image-20240629170520093.png" alt="image-20240629170520093"></p>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><h5 id="数据和指针寄存器"><a href="#数据和指针寄存器" class="headerlink" title="数据和指针寄存器"></a>数据和指针寄存器</h5><p><img src="/2024/07/05/csapp/image-20240629170604953.png" alt="image-20240629170604953"></p>
<p><img src="/2024/07/05/csapp/image-20240629170637945.png" alt="image-20240629170637945"></p>
<p><img src="/2024/07/05/csapp/image-20240629170722076.png" alt="image-20240629170722076"></p>
<p><img src="/2024/07/05/csapp/image-20240629170732259.png" alt="image-20240629170732259"></p>
<p><img src="/2024/07/05/csapp/image-20240629171138833.png" alt="image-20240629171138833"></p>
<p><img src="/2024/07/05/csapp/image-20240629171202406.png" alt="image-20240629171202406"></p>
<p><img src="/2024/07/05/csapp/image-20240629171245825.png" alt="image-20240629171245825"></p>
<h5 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h5><p><img src="/2024/07/05/csapp/image-20240629171256030.png" alt="image-20240629171256030"></p>
<p><img src="/2024/07/05/csapp/image-20240629171304302.png" alt="image-20240629171304302"></p>
<ol>
<li><p>CF</p>
<p><img src="/2024/07/05/csapp/image-20240629171321061.png" alt="image-20240629171321061"></p>
</li>
<li><p>ZF</p>
<p><img src="/2024/07/05/csapp/image-20240629171331939.png" alt="image-20240629171331939"></p>
</li>
<li><p>SF</p>
<p><img src="/2024/07/05/csapp/image-20240629171349228.png" alt="image-20240629171349228"></p>
</li>
<li><p>PF</p>
<p><img src="/2024/07/05/csapp/image-20240629171403897.png" alt="image-20240629171403897"></p>
</li>
<li><p>OF</p>
<p><img src="/2024/07/05/csapp/image-20240629171445755.png" alt="image-20240629171445755"></p>
<p><img src="/2024/07/05/csapp/image-20240629171507896.png" alt="image-20240629171507896"></p>
<p><img src="/2024/07/05/csapp/image-20240629171527864.png" alt="image-20240629171527864"></p>
<p><img src="/2024/07/05/csapp/image-20240629171551841.png" alt="image-20240629171551841"></p>
<p><img src="/2024/07/05/csapp/image-20240629171610688.png" alt="image-20240629171610688"></p>
</li>
<li><p>AF</p>
<p><img src="/2024/07/05/csapp/image-20240629171636058.png" alt="image-20240629171636058"></p>
</li>
</ol>
<h5 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h5><p><img src="/2024/07/05/csapp/image-20240629171727426.png" alt="image-20240629171727426"></p>
<h4 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h4><p>8086／8088的指令系统包含了六种类型，其中数据传送指令14条，算术运算指令20条，逻辑运算指令13条，串操作指令10条，控制转移指令28条，处理器控制指令12条。</p>
<h5 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h5><p><img src="/2024/07/05/csapp/image-20240629171907296.png" alt="image-20240629171907296"></p>
<p>存储器寻址花样比较多</p>
<p><img src="/2024/07/05/csapp/image-20240629171931179.png" alt="image-20240629171931179"></p>
<h3 id="IA32处理器体系结构"><a href="#IA32处理器体系结构" class="headerlink" title="IA32处理器体系结构"></a>IA32处理器体系结构</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="/2024/07/05/csapp/image-20240629172043968.png" alt="image-20240629172043968"></p>
<p><img src="/2024/07/05/csapp/image-20240629172051621.png" alt="image-20240629172051621"></p>
<h4 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h4><p><img src="/2024/07/05/csapp/image-20240629172644379.png" alt="image-20240629172644379"></p>
<h5 id="基本寄存器"><a href="#基本寄存器" class="headerlink" title="基本寄存器"></a>基本寄存器</h5><p><img src="/2024/07/05/csapp/image-20240629172702238.png" alt="image-20240629172702238"></p>
<p><img src="/2024/07/05/csapp/image-20240629172710920.png" alt="image-20240629172710920"></p>
<p><img src="/2024/07/05/csapp/image-20240629172721939.png" alt="image-20240629172721939"></p>
<p>就是启动那会儿的对吧</p>
<p><img src="/2024/07/05/csapp/image-20240629172911651.png" alt="image-20240629172911651"></p>
<p><img src="/2024/07/05/csapp/image-20240629172942789.png" alt="image-20240629172942789"></p>
<p>保护模式就是启动完了开启映射了</p>
<p><img src="/2024/07/05/csapp/image-20240629173003354.png" alt="image-20240629173003354"></p>
<p><img src="/2024/07/05/csapp/image-20240629173027302.png" alt="image-20240629173027302"></p>
<p>状态就是反应状态，控制就是可以用来控制CPU</p>
<p><img src="/2024/07/05/csapp/image-20240629173100198.png" alt="image-20240629173100198"></p>
<p>注意标红的就行，注意奇偶标志的范围。跟8086差不多。</p>
<h5 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器*"></a>系统寄存器*</h5><p><img src="/2024/07/05/csapp/image-20240629173220305.png" alt="image-20240629173220305"></p>
<p>值得注意调试的也在！还有任务寄存器，应该就是进程虚拟地址之类的相关的了吧</p>
<h5 id="浮点单元FPU"><a href="#浮点单元FPU" class="headerlink" title="浮点单元FPU*"></a>浮点单元FPU*</h5><p><img src="/2024/07/05/csapp/image-20240629173255252.png" alt="image-20240629173255252"></p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理*"></a>内存管理*</h4><p>TODO，这部分我打算之后再复习一下OS</p>
<h5 id="实地址模式"><a href="#实地址模式" class="headerlink" title="实地址模式"></a>实地址模式</h5><p><img src="/2024/07/05/csapp/image-20240629173320431.png" alt="image-20240629173320431"></p>
<h5 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h5><p><img src="/2024/07/05/csapp/image-20240629173356263.png" alt="image-20240629173356263"></p>
<p><img src="/2024/07/05/csapp/image-20240629173420997.png" alt="image-20240629173420997"></p>
<h4 id="指令执行周期"><a href="#指令执行周期" class="headerlink" title="指令执行周期"></a>指令执行周期</h4><p><img src="/2024/07/05/csapp/image-20240629173654565.png" alt="image-20240629173654565"></p>
<p><img src="/2024/07/05/csapp/image-20240629173713560.png" alt="image-20240629173713560"></p>
<h4 id="程序如何运行"><a href="#程序如何运行" class="headerlink" title="程序如何运行"></a>程序如何运行</h4><p><img src="/2024/07/05/csapp/image-20240629173744806.png" alt="image-20240629173744806"></p>
<p><img src="/2024/07/05/csapp/image-20240629173801306.png" alt="image-20240629173801306"></p>
<p><img src="/2024/07/05/csapp/image-20240629173820041.png" alt="image-20240629173820041"></p>
<p><img src="/2024/07/05/csapp/image-20240629173837010.png" alt="image-20240629173837010"></p>
<p><img src="/2024/07/05/csapp/image-20240629173849453.png" alt="image-20240629173849453"></p>
<h4 id="计算机如何启动"><a href="#计算机如何启动" class="headerlink" title="计算机如何启动"></a>计算机如何启动</h4><p><img src="/2024/07/05/csapp/image-20240629173914760.png" alt="image-20240629173914760"></p>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><h4 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程*"></a>发展历程*</h4><p><img src="/2024/07/05/csapp/image-20240629174031407.png" alt="image-20240629174031407"></p>
<p><img src="/2024/07/05/csapp/image-20240629174038941.png" alt="image-20240629174038941"></p>
<p><img src="/2024/07/05/csapp/image-20240629174051144.png" alt="image-20240629174051144"></p>
<p><img src="/2024/07/05/csapp/image-20240629174105278.png" alt="image-20240629174105278"></p>
<p><img src="/2024/07/05/csapp/image-20240629174113473.png" alt="image-20240629174113473"></p>
<p><img src="/2024/07/05/csapp/image-20240629174122908.png" alt="image-20240629174122908"></p>
<p><img src="/2024/07/05/csapp/image-20240629174131584.png" alt="image-20240629174131584"></p>
<p><img src="/2024/07/05/csapp/image-20240629174138746.png" alt="image-20240629174138746"></p>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><img src="/2024/07/05/csapp/image-20240629175818512.png" alt="image-20240629175818512"></p>
<p><img src="/2024/07/05/csapp/image-20240629180520973.png" alt="image-20240629180520973"></p>
<p><img src="/2024/07/05/csapp/image-20240629180540476.png" alt="image-20240629180540476"></p>
<p><img src="/2024/07/05/csapp/image-20240629180923392.png" alt="image-20240629180923392"></p>
<p><img src="/2024/07/05/csapp/image-20240629180931787.png" alt="image-20240629180931787"></p>
<h4 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h4><h5 id="寄存器-2"><a href="#寄存器-2" class="headerlink" title="寄存器"></a>寄存器</h5><p><img src="/2024/07/05/csapp/image-20240629181016885.png" alt="image-20240629181016885"></p>
<p><img src="/2024/07/05/csapp/image-20240629181028511.png" alt="image-20240629181028511"></p>
<p><img src="/2024/07/05/csapp/image-20240629181042536.png" alt="image-20240629181042536"></p>
<h5 id="操作数和数据传送"><a href="#操作数和数据传送" class="headerlink" title="操作数和数据传送"></a>操作数和数据传送</h5><p><img src="/2024/07/05/csapp/image-20240629181108519.png" alt="image-20240629181108519"></p>
<p><img src="/2024/07/05/csapp/image-20240629181116760.png" alt="image-20240629181116760"></p>
<p><img src="/2024/07/05/csapp/image-20240629181135761.png" alt="image-20240629181135761"></p>
<p><img src="/2024/07/05/csapp/image-20240629181150927.png" alt="image-20240629181150927"></p>
<p><img src="/2024/07/05/csapp/image-20240629181213241.png" alt="image-20240629181213241"></p>
<p><img src="/2024/07/05/csapp/image-20240629181223042.png" alt="image-20240629181223042"></p>
<p>不愧是CISC</p>
<p><img src="/2024/07/05/csapp/image-20240629181238528.png" alt="image-20240629181238528"></p>
<p><img src="/2024/07/05/csapp/image-20240629181246277.png" alt="image-20240629181246277"></p>
<p><img src="/2024/07/05/csapp/image-20240629181256555.png" alt="image-20240629181256555"></p>
<p><img src="/2024/07/05/csapp/image-20240629181312739.png" alt="image-20240629181312739"></p>
<p><img src="/2024/07/05/csapp/image-20240629181320748.png" alt="image-20240629181320748"></p>
<p><img src="/2024/07/05/csapp/image-20240629181443984.png" alt="image-20240629181443984"></p>
<h5 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h5><p><img src="/2024/07/05/csapp/image-20240629181459835.png" alt="image-20240629181459835"></p>
<p><img src="/2024/07/05/csapp/image-20240629181515327.png" alt="image-20240629181515327"></p>
<p><img src="/2024/07/05/csapp/image-20240629181523184.png" alt="image-20240629181523184"></p>
<p>比如说数组元素访问，a[2]，其中Rb就是a的基址，Ri就是这个2，S就是sizeof(a[0])。D可能就是具体这个a[2]的某个字节了。</p>
<h5 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h5><p><img src="/2024/07/05/csapp/image-20240629181752917.png" alt="image-20240629181752917"></p>
<p><img src="/2024/07/05/csapp/image-20240629181808216.png" alt="image-20240629181808216"></p>
<h4 id="算术和逻辑运算"><a href="#算术和逻辑运算" class="headerlink" title="算术和逻辑运算"></a>算术和逻辑运算</h4><p><img src="/2024/07/05/csapp/image-20240629182416903.png" alt="image-20240629182416903"></p>
<p>我靠，注意这个leaq还可以作为这种计算算术表达式的操作，6666</p>
<p><img src="/2024/07/05/csapp/image-20240629182430734.png" alt="image-20240629182430734"></p>
<p><img src="/2024/07/05/csapp/image-20240629182438714.png" alt="image-20240629182438714"></p>
<p><img src="/2024/07/05/csapp/image-20240629182606816.png" alt="image-20240629182606816"></p>
<p>怎么感觉有点沙比</p>
<p><img src="/2024/07/05/csapp/image-20240629182850116.png" alt="image-20240629182850116"></p>
<p>66666</p>
<h4 id="比较和跳转"><a href="#比较和跳转" class="headerlink" title="比较和跳转"></a>比较和跳转</h4><p><img src="/2024/07/05/csapp/image-20240629182942737.png" alt="image-20240629182942737"></p>
<h5 id="布尔指令"><a href="#布尔指令" class="headerlink" title="布尔指令"></a>布尔指令</h5><p><img src="/2024/07/05/csapp/image-20240629183049780.png" alt="image-20240629183049780"></p>
<p><img src="/2024/07/05/csapp/image-20240629183112219.png" alt="image-20240629183112219"></p>
<p>这个牛逼</p>
<p><img src="/2024/07/05/csapp/image-20240629183127524.png" alt="image-20240629183127524"></p>
<p><img src="/2024/07/05/csapp/image-20240629183143024.png" alt="image-20240629183143024"></p>
<p><img src="/2024/07/05/csapp/image-20240629183154740.png" alt="image-20240629183154740"></p>
<p><img src="/2024/07/05/csapp/image-20240629183202322.png" alt="image-20240629183202322"></p>
<p><img src="/2024/07/05/csapp/image-20240629183229936.png" alt="image-20240629183229936"></p>
<h5 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h5><p><img src="/2024/07/05/csapp/image-20240629183256285.png" alt="image-20240629183256285"></p>
<p><img src="/2024/07/05/csapp/image-20240629183304590.png" alt="image-20240629183304590"></p>
<h5 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h5><p><img src="/2024/07/05/csapp/image-20240629183327424.png" alt="image-20240629183327424"></p>
<p><img src="/2024/07/05/csapp/image-20240629183333183.png" alt="image-20240629183333183"></p>
<p><img src="/2024/07/05/csapp/image-20240629183343729.png" alt="image-20240629183343729"></p>
<p><img src="/2024/07/05/csapp/image-20240629183353963.png" alt="image-20240629183353963"></p>
<p><img src="/2024/07/05/csapp/image-20240629183401113.png" alt="image-20240629183401113"></p>
<h3 id="Linux汇编程序"><a href="#Linux汇编程序" class="headerlink" title="Linux汇编程序"></a>Linux汇编程序</h3><p>典中典</p>
<p><img src="/2024/07/05/csapp/image-20240629174244456.png" alt="image-20240629174244456"></p>
<p><img src="/2024/07/05/csapp/image-20240629174525821.png" alt="image-20240629174525821"></p>
<p>TODO 这里没懂</p>
<p><img src="/2024/07/05/csapp/image-20240629174539249.png" alt="image-20240629174539249"></p>
<p><img src="/2024/07/05/csapp/image-20240629174609163.png" alt="image-20240629174609163"></p>
<p><img src="/2024/07/05/csapp/image-20240629174631990.png" alt="image-20240629174631990"></p>
<p><img src="/2024/07/05/csapp/image-20240629174649526.png" alt="image-20240629174649526"></p>
<h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p><img src="/2024/07/05/csapp/image-20240629183513168.png" alt="image-20240629183513168"></p>
<h3 id="流程控制-条件码"><a href="#流程控制-条件码" class="headerlink" title="流程控制:条件码"></a>流程控制:条件码</h3><p><img src="/2024/07/05/csapp/image-20240629183547473.png" alt="image-20240629183547473"></p>
<p>就是标志寄存器呗</p>
<p><img src="/2024/07/05/csapp/image-20240629183619040.png" alt="image-20240629183619040"></p>
<p><img src="/2024/07/05/csapp/image-20240629183723813.png" alt="image-20240629183723813"></p>
<p><img src="/2024/07/05/csapp/image-20240629183731735.png" alt="image-20240629183731735"></p>
<p>注意这个访问条件码，新东西</p>
<p><img src="/2024/07/05/csapp/image-20240629183812043.png" alt="image-20240629183812043"></p>
<p>感觉他这说得好谜语，总之意思大概就是根据条件码的值然后设置寄存器的值，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp al, 0x05  ; 比较 AL 寄存器的值和立即数5</span><br><span class="line">sete bl       ; 如果 AL 等于 5，则将 BL 寄存器设置为1，否则设置为0</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/05/csapp/image-20240629183940888.png" alt="image-20240629183940888"></p>
<h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><p><img src="/2024/07/05/csapp/image-20240629184007086.png" alt="image-20240629184007086"></p>
<p><del>（SF^OF）就是说除了 负数^溢出 这种情况，也即只有11和00的情况会被考虑，后者是普通情况，前者只有正数-负数这种情况会出现，而此时必定是大于。同时</del>ZF代表排除==的情况。</p>
<p>然后，SF=1，OF=0表示的是相减负数，SF=0，OF=1表示的是负溢出，此时必定为负数-正数，所以必是小于。</p>
<p>而对于无符号数，只有在结果为负数，也即小于的情况会溢出，所以只需判断CF标志</p>
<p><img src="/2024/07/05/csapp/image-20240629184027469.png" alt="image-20240629184027469"></p>
<p><img src="/2024/07/05/csapp/image-20240629184044655.png" alt="image-20240629184044655"></p>
<p><img src="/2024/07/05/csapp/image-20240629184100233.png" alt="image-20240629184100233"></p>
<p><img src="/2024/07/05/csapp/image-20240629184106808.png" alt="image-20240629184106808"></p>
<p><img src="/2024/07/05/csapp/image-20240629184137328.png" alt="image-20240629184137328"></p>
<p>确实</p>
<p><img src="/2024/07/05/csapp/image-20240629184150880.png" alt="image-20240629184150880"></p>
<p>相当于是两个分支都算一遍，最后再用这个条件传送指令决定哪个是哪个</p>
<p><img src="/2024/07/05/csapp/image-20240629184305948.png" alt="image-20240629184305948"></p>
<p>确实。。。</p>
<h3 id="循环结构的实现"><a href="#循环结构的实现" class="headerlink" title="循环结构的实现"></a>循环结构的实现</h3><h4 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h4><p><img src="/2024/07/05/csapp/image-20240629184327058.png" alt="image-20240629184327058"></p>
<p><img src="/2024/07/05/csapp/image-20240629184338809.png" alt="image-20240629184338809"></p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><h5 id="跳到中间"><a href="#跳到中间" class="headerlink" title="跳到中间"></a>跳到中间</h5><p><img src="/2024/07/05/csapp/image-20240629184352822.png" alt="image-20240629184352822"></p>
<p>GCC的 <code>-Og</code> 选项是一种优化级别，旨在提供编译速度和运行时性能之间的平衡。这个选项从GCC 4.7版本开始引入，目的是在不牺牲太多编译速度的情况下，优化生成的代码以提高程序的运行效率。</p>
<ul>
<li><strong>优化级别</strong>：<code>-Og</code> 通常提供比 <code>-O0</code>（没有优化）更高的优化级别，但低于 <code>-O1</code>、<code>-O2</code> 和 <code>-O3</code>。它专注于那些不太耗时且能够带来明显性能提升的优化。</li>
<li><strong>调试友好</strong>：<code>-Og</code> 选项生成的代码旨在保持与源代码的可读性和对应性，使得调试过程更加容易。这与 <code>-O0</code> 类似，但 <code>-Og</code> 仍然会应用一些优化，以提高程序的运行性能。</li>
</ul>
<p><img src="/2024/07/05/csapp/image-20240629184417054.png" alt="image-20240629184417054"></p>
<p><img src="/2024/07/05/csapp/image-20240629184439472.png" alt="image-20240629184439472"></p>
<h5 id="guarded-do"><a href="#guarded-do" class="headerlink" title="guarded-do"></a>guarded-do</h5><p><img src="/2024/07/05/csapp/image-20240629184549604.png" alt="image-20240629184549604"></p>
<p>就是说又转化了一层</p>
<p>感觉像是在第一次进去的时候少了一次goto</p>
<p><img src="/2024/07/05/csapp/image-20240629184748001.png" alt="image-20240629184748001"></p>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p><img src="/2024/07/05/csapp/image-20240629184807369.png" alt="image-20240629184807369"></p>
<h5 id="for-while"><a href="#for-while" class="headerlink" title="for-while"></a>for-while</h5><p><img src="/2024/07/05/csapp/image-20240629184816225.png" alt="image-20240629184816225"></p>
<p><img src="/2024/07/05/csapp/image-20240629184825669.png" alt="image-20240629184825669"></p>
<h5 id="for-dowhile"><a href="#for-dowhile" class="headerlink" title="for-dowhile"></a>for-dowhile</h5><p><img src="/2024/07/05/csapp/image-20240629184839514.png" alt="image-20240629184839514"></p>
<h3 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h3><p><img src="/2024/07/05/csapp/image-20240629184909493.png" alt="image-20240629184909493"></p>
<p>总结到位</p>
<p><img src="/2024/07/05/csapp/image-20240629184944779.png" alt="image-20240629184944779"></p>
<p>6666</p>
<p><img src="/2024/07/05/csapp/image-20240629185053919.png" alt="image-20240629185053919"></p>
<p><img src="/2024/07/05/csapp/image-20240629185106744.png" alt="image-20240629185106744"></p>
<p><img src="/2024/07/05/csapp/image-20240629185523195.png" alt="image-20240629185523195"></p>
<p><img src="/2024/07/05/csapp/image-20240629185552179.png" alt="image-20240629185552179"></p>
<p>注意这个fall-through的处理</p>
<p>甚至还是在switch case里才初始化的w，也确实不是每个case都得初始化</p>
<p><img src="/2024/07/05/csapp/image-20240629185636197.png" alt="image-20240629185636197"></p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><img src="/2024/07/05/csapp/image-20240629214313618.png" alt="image-20240629214313618"></p>
<h3 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h3><p><img src="/2024/07/05/csapp/image-20240629214417784.png" alt="image-20240629214417784"></p>
<p>这个内存管理应该指的是栈上不是堆上。。</p>
<p><img src="/2024/07/05/csapp/image-20240629214456115.png" alt="image-20240629214456115"></p>
<p><img src="/2024/07/05/csapp/image-20240629214610483.png" alt="image-20240629214610483"></p>
<p><img src="/2024/07/05/csapp/image-20240629214713468.png" alt="image-20240629214713468"></p>
<h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><h4 id="传递控制"><a href="#传递控制" class="headerlink" title="传递控制"></a>传递控制</h4><p><img src="/2024/07/05/csapp/image-20240629215705403.png" alt="image-20240629215705403"></p>
<h4 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h4><p>x86-64架构中常见的几个用于函数参数传递的寄存器：</p>
<ul>
<li>**<code>RDI</code>**：通常用作第一个整数或指针类型的函数参数。</li>
<li>**<code>RSI</code>**：用作第二个整数或指针类型的函数参数。</li>
<li>**<code>RDX</code>**：用作第三个整数或指针类型的函数参数。</li>
<li>**<code>RCX</code>**：用作第四个整数或指针类型的函数参数。</li>
<li><strong><code>R8</code></strong> 和 **<code>R9</code>**：在需要更多参数的情况下，从这些寄存器开始。</li>
</ul>
<p><img src="/2024/07/05/csapp/image-20240629215823440.png" alt="image-20240629215823440"></p>
<p>所以多的参数是由后往前推的，返回地址最后推。</p>
<p><img src="/2024/07/05/csapp/image-20240629221044803.png" alt="image-20240629221044803"></p>
<h4 id="管理局部数据"><a href="#管理局部数据" class="headerlink" title="管理局部数据"></a>管理局部数据</h4><p><img src="/2024/07/05/csapp/image-20240629215949003.png" alt="image-20240629215949003"></p>
<p><img src="/2024/07/05/csapp/image-20240629220044988.png" alt="image-20240629220044988"></p>
<p><img src="/2024/07/05/csapp/image-20240629220241130.png" alt="image-20240629220241130"></p>
<p>就是说callee的参数其实理论上是叫放在caller的栈帧的</p>
<p><img src="/2024/07/05/csapp/image-20240629220343050.png" alt="image-20240629220343050"></p>
<p><img src="/2024/07/05/csapp/image-20240629220619265.png" alt="image-20240629220619265"></p>
<p><img src="/2024/07/05/csapp/image-20240629220700065.png" alt="image-20240629220700065"></p>
<p><img src="/2024/07/05/csapp/image-20240629220710873.png" alt="image-20240629220710873"></p>
<p><img src="/2024/07/05/csapp/image-20240629221510150.png" alt="image-20240629221510150"></p>
<p>我去，简答题</p>
<h4 id="寄存器保存约定"><a href="#寄存器保存约定" class="headerlink" title="寄存器保存约定"></a>寄存器保存约定</h4><p>在x86-64位架构中，callee-saved registers通常包括：</p>
<ul>
<li><strong>RBX</strong>，r12,r13,r14</li>
<li><strong>RSP</strong>（栈指针，如果被修改）</li>
<li><strong>RBP</strong>（基指针，如果被用作帧指针）</li>
</ul>
<p>caller-save寄存器：</p>
<ul>
<li><strong>RAX</strong>：用于存储函数的返回值。</li>
<li>rdi/rsi/rdx/rcx/r8/r9：参数</li>
<li><strong>R10,R11</strong>：被调用过程可修改</li>
</ul>
<p><img src="/2024/07/05/csapp/image-20240629221605026.png" alt="image-20240629221605026"></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><img src="/2024/07/05/csapp/image-20240629222028179.png" alt="image-20240629222028179"></p>
<p><img src="/2024/07/05/csapp/image-20240629222108223.png" alt="image-20240629222108223"></p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p><img src="/2024/07/05/csapp/image-20240629222321520.png" alt="image-20240629222321520"></p>
<p><img src="/2024/07/05/csapp/image-20240630000257041.png" alt="image-20240630000257041"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><img src="/2024/07/05/csapp/image-20240629222455645.png" alt="image-20240629222455645"></p>
<p>64位系统是吧</p>
<p><img src="/2024/07/05/csapp/image-20240629222601321.png" alt="image-20240629222601321"></p>
<p><img src="/2024/07/05/csapp/image-20240629222634282.png" alt="image-20240629222634282"></p>
<p><img src="/2024/07/05/csapp/image-20240629222659076.png" alt="image-20240629222659076"></p>
<p><img src="/2024/07/05/csapp/image-20240629222709361.png" alt="image-20240629222709361"></p>
<p><img src="/2024/07/05/csapp/image-20240629223847665.png" alt="image-20240629223847665"></p>
<p>对，相当于A3是一个指向3*int的指针，然后A4其实就跟A2是一个道理，相当于*(A4[0])为int。</p>
<p><img src="/2024/07/05/csapp/image-20240629224333393.png" alt="image-20240629224333393"></p>
<p><img src="/2024/07/05/csapp/image-20240629224451182.png" alt="image-20240629224451182"></p>
<p><img src="/2024/07/05/csapp/image-20240629230258371.png" alt="image-20240629230258371"></p>
<p><img src="/2024/07/05/csapp/image-20240629230315624.png" alt="image-20240629230315624"></p>
<p><img src="/2024/07/05/csapp/image-20240629230451483.png" alt="image-20240629230451483"></p>
<p><img src="/2024/07/05/csapp/image-20240629230513156.png" alt="image-20240629230513156"></p>
<p><img src="/2024/07/05/csapp/image-20240629230657214.png" alt="image-20240629230657214"></p>
<p><img src="/2024/07/05/csapp/image-20240629230713454.png" alt="image-20240629230713454"></p>
<p><img src="/2024/07/05/csapp/image-20240629230809676.png" alt="image-20240629230809676"></p>
<p><img src="/2024/07/05/csapp/image-20240629230821364.png" alt="image-20240629230821364"></p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p><img src="/2024/07/05/csapp/image-20240629230917379.png" alt="image-20240629230917379"></p>
<p><img src="/2024/07/05/csapp/image-20240629232052538.png" alt="image-20240629232052538"></p>
<p><img src="/2024/07/05/csapp/image-20240629232120725.png" alt="image-20240629232120725"></p>
<p><img src="/2024/07/05/csapp/image-20240629233035806.png" alt="image-20240629233035806"></p>
<p><img src="/2024/07/05/csapp/image-20240629233050110.png" alt="image-20240629233050110"></p>
<p><img src="/2024/07/05/csapp/image-20240629233145636.png" alt="image-20240629233145636"></p>
<p>注意c后面还得7B的padding</p>
<p><img src="/2024/07/05/csapp/image-20240629233228570.png" alt="image-20240629233228570"></p>
<p><img src="/2024/07/05/csapp/image-20240629233258201.png" alt="image-20240629233258201"></p>
<h3 id="浮点数-1"><a href="#浮点数-1" class="headerlink" title="浮点数*"></a>浮点数*</h3><h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><p><img src="/2024/07/05/csapp/image-20240629233620950.png" alt="image-20240629233620950"></p>
<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p><img src="/2024/07/05/csapp/image-20240629233704820.png" alt="image-20240629233704820"></p>
<p><img src="/2024/07/05/csapp/image-20240629233751563.png" alt="image-20240629233751563"></p>
<p><img src="/2024/07/05/csapp/image-20240629233818527.png" alt="image-20240629233818527"></p>
<p>巨长的data段。。</p>
<h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><h4 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h4><p><img src="/2024/07/05/csapp/image-20240629233905182.png" alt="image-20240629233905182"></p>
<p><img src="/2024/07/05/csapp/image-20240629233915558.png" alt="image-20240629233915558"></p>
<p><img src="/2024/07/05/csapp/image-20240629233936070.png" alt="image-20240629233936070"></p>
<p><img src="/2024/07/05/csapp/image-20240629234000472.png" alt="image-20240629234000472"></p>
<p><img src="/2024/07/05/csapp/image-20240629234014638.png" alt="image-20240629234014638"></p>
<p><img src="/2024/07/05/csapp/image-20240629234042302.png" alt="image-20240629234042302"></p>
<p><img src="/2024/07/05/csapp/image-20240629234049319.png" alt="image-20240629234049319"></p>
<p><img src="/2024/07/05/csapp/image-20240629234104831.png" alt="image-20240629234104831"></p>
<p><img src="/2024/07/05/csapp/image-20240629234131782.png" alt="image-20240629234131782"></p>
<p><img src="/2024/07/05/csapp/image-20240629234145352.png" alt="image-20240629234145352"></p>
<h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h4><p><img src="/2024/07/05/csapp/image-20240629234207160.png" alt="image-20240629234207160"></p>
<p><img src="/2024/07/05/csapp/image-20240629234217727.png" alt="image-20240629234217727"></p>
<p><img src="/2024/07/05/csapp/image-20240629235604349.png" alt="image-20240629235604349"></p>
<p><img src="/2024/07/05/csapp/image-20240629235622372.png" alt="image-20240629235622372"></p>
<h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><p><img src="/2024/07/05/csapp/image-20240629234300252.png" alt="image-20240629234300252"></p>
<p><img src="/2024/07/05/csapp/image-20240629234315480.png" alt="image-20240629234315480"></p>
<p><img src="/2024/07/05/csapp/image-20240629235225142.png" alt="image-20240629235225142"></p>
<p><img src="/2024/07/05/csapp/image-20240629235253787.png" alt="image-20240629235253787"></p>
<p><img src="/2024/07/05/csapp/image-20240629235349536.png" alt="image-20240629235349536"></p>
<p><img src="/2024/07/05/csapp/image-20240629235358006.png" alt="image-20240629235358006"></p>
<p>感觉看起来主要还是检查ra</p>
<h3 id="联合union"><a href="#联合union" class="headerlink" title="联合union"></a>联合union</h3><p><img src="/2024/07/05/csapp/image-20240629235753374.png" alt="image-20240629235753374"></p>
<p><img src="/2024/07/05/csapp/image-20240629235804300.png" alt="image-20240629235804300"></p>
<p><img src="/2024/07/05/csapp/image-20240629235935481.png" alt="image-20240629235935481"></p>
<p><img src="/2024/07/05/csapp/image-20240630000000489.png" alt="image-20240630000000489"></p>
<p><img src="/2024/07/05/csapp/image-20240630000034088.png" alt="image-20240630000034088"></p>
<p><img src="/2024/07/05/csapp/image-20240630000125056.png" alt="image-20240630000125056"></p>
<p><img src="/2024/07/05/csapp/image-20240630000140734.png" alt="image-20240630000140734"></p>
<p><img src="/2024/07/05/csapp/image-20240630000152893.png" alt="image-20240630000152893"></p>
<h1 id="处理器体系结构"><a href="#处理器体系结构" class="headerlink" title="处理器体系结构"></a>处理器体系结构</h1><h2 id="指令集体系结构"><a href="#指令集体系结构" class="headerlink" title="指令集体系结构"></a>指令集体系结构</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><img src="/2024/07/05/csapp/image-20240630000445224.png" alt="image-20240630000445224"></p>
<p><img src="/2024/07/05/csapp/image-20240630000517112.png" alt="image-20240630000517112"></p>
<p><img src="/2024/07/05/csapp/image-20240630000724760.png" alt="image-20240630000724760"></p>
<p><img src="/2024/07/05/csapp/image-20240630001151603.png" alt="image-20240630001151603"></p>
<p><img src="/2024/07/05/csapp/image-20240630001300168.png" alt="image-20240630001300168"></p>
<p><img src="/2024/07/05/csapp/image-20240630001344591.png" alt="image-20240630001344591"></p>
<p><img src="/2024/07/05/csapp/image-20240630001504382.png" alt="image-20240630001504382"></p>
<p><img src="/2024/07/05/csapp/image-20240630001603829.png" alt="image-20240630001603829"></p>
<h3 id="Y86-64"><a href="#Y86-64" class="headerlink" title="Y86-64"></a>Y86-64</h3><p><img src="/2024/07/05/csapp/image-20240630000411251.png" alt="image-20240630000411251"></p>
<p><img src="/2024/07/05/csapp/image-20240630000619748.png" alt="image-20240630000619748"></p>
<p><img src="/2024/07/05/csapp/image-20240630001645731.png" alt="image-20240630001645731"></p>
<p><img src="/2024/07/05/csapp/image-20240630001715603.png" alt="image-20240630001715603"></p>
<p>指令操作码包含8位，低4位指示具体操作类型fn</p>
<p><img src="/2024/07/05/csapp/image-20240630001810469.png" alt="image-20240630001810469"></p>
<p><img src="/2024/07/05/csapp/image-20240630001918709.png" alt="image-20240630001918709"></p>
<p><img src="/2024/07/05/csapp/image-20240630001933825.png" alt="image-20240630001933825"></p>
<p><img src="/2024/07/05/csapp/image-20240630002240880.png" alt="image-20240630002240880"></p>
<p>注意这个无寄存器含义</p>
<p><img src="/2024/07/05/csapp/image-20240630002341294.png" alt="image-20240630002341294"></p>
<p><img src="/2024/07/05/csapp/image-20240630002425220.png" alt="image-20240630002425220"></p>
<p><img src="/2024/07/05/csapp/image-20240630002511971.png" alt="image-20240630002511971"></p>
<p><img src="/2024/07/05/csapp/image-20240630002629778.png" alt="image-20240630002629778"></p>
<p><img src="/2024/07/05/csapp/image-20240630002653765.png" alt="image-20240630002653765"></p>
<p><img src="/2024/07/05/csapp/image-20240630002707921.png" alt="image-20240630002707921"></p>
<p><img src="/2024/07/05/csapp/image-20240630002744417.png" alt="image-20240630002744417"></p>
<p><img src="/2024/07/05/csapp/image-20240630002803889.png" alt="image-20240630002803889"></p>
<p><img src="/2024/07/05/csapp/image-20240630002838792.png" alt="image-20240630002838792"></p>
<p><img src="/2024/07/05/csapp/image-20240630002922874.png" alt="image-20240630002922874"></p>
<p><img src="/2024/07/05/csapp/image-20240630002953146.png" alt="image-20240630002953146"></p>
<p><img src="/2024/07/05/csapp/image-20240630003015562.png" alt="image-20240630003015562"></p>
<p><img src="/2024/07/05/csapp/image-20240630003033119.png" alt="image-20240630003033119"></p>
<p><img src="/2024/07/05/csapp/image-20240630003132644.png" alt="image-20240630003132644"></p>
<p><img src="/2024/07/05/csapp/image-20240630003226956.png" alt="image-20240630003226956"></p>
<p><img src="/2024/07/05/csapp/image-20240630003308339.png" alt="image-20240630003308339"></p>
<p><img src="/2024/07/05/csapp/image-20240630003345142.png" alt="image-20240630003345142"></p>
<p><img src="/2024/07/05/csapp/image-20240630003412147.png" alt="image-20240630003412147"></p>
<h2 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h2><p><img src="/2024/07/05/csapp/image-20240630005121767.png" alt="image-20240630005121767"></p>
<h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><img src="/2024/07/05/csapp/image-20240630003633436.png" alt="image-20240630003633436"></p>
<p><img src="/2024/07/05/csapp/image-20240630003651801.png" alt="image-20240630003651801"></p>
<p><img src="/2024/07/05/csapp/image-20240630003711963.png" alt="image-20240630003711963"></p>
<p><img src="/2024/07/05/csapp/image-20240630003725861.png" alt="image-20240630003725861"></p>
<p><img src="/2024/07/05/csapp/image-20240630003831380.png" alt="image-20240630003831380"></p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p><img src="/2024/07/05/csapp/image-20240630003914161.png" alt="image-20240630003914161"></p>
<p><img src="/2024/07/05/csapp/image-20240630003929456.png" alt="image-20240630003929456"></p>
<p><img src="/2024/07/05/csapp/image-20240630003954287.png" alt="image-20240630003954287"></p>
<p><img src="/2024/07/05/csapp/image-20240630004016749.png" alt="image-20240630004016749"></p>
<p><img src="/2024/07/05/csapp/image-20240630004029661.png" alt="image-20240630004029661"></p>
<p><img src="/2024/07/05/csapp/image-20240630004052308.png" alt="image-20240630004052308"></p>
<p><img src="/2024/07/05/csapp/image-20240630004139622.png" alt="image-20240630004139622"></p>
<p><img src="/2024/07/05/csapp/image-20240630004207913.png" alt="image-20240630004207913"></p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p><img src="/2024/07/05/csapp/image-20240630004812398.png" alt="image-20240630004812398"></p>
<p><img src="/2024/07/05/csapp/image-20240630004839398.png" alt="image-20240630004839398"></p>
<p><img src="/2024/07/05/csapp/image-20240630003711963.png" alt="image-20240630003711963"></p>
<p><img src="/2024/07/05/csapp/image-20240630004934849.png" alt="image-20240630004934849"></p>
<p><img src="/2024/07/05/csapp/image-20240630004949715.png" alt="image-20240630004949715"></p>
<p><img src="/2024/07/05/csapp/image-20240630005016582.png" alt="image-20240630005016582"></p>
<h2 id="顺序执行处理器"><a href="#顺序执行处理器" class="headerlink" title="顺序执行处理器"></a>顺序执行处理器</h2><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p><img src="/2024/07/05/csapp/image-20240630005231234.png" alt="image-20240630005231234"></p>
<p><img src="/2024/07/05/csapp/image-20240630005304559.png" alt="image-20240630005304559"></p>
<p><img src="/2024/07/05/csapp/image-20240630005333867.png" alt="image-20240630005333867"></p>
<p><img src="/2024/07/05/csapp/image-20240630005350153.png" alt="image-20240630005350153"></p>
<h3 id="SEQ实现"><a href="#SEQ实现" class="headerlink" title="SEQ实现"></a>SEQ实现</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p><img src="/2024/07/05/csapp/image-20240630005446870.png" alt="image-20240630005446870"></p>
<p><img src="/2024/07/05/csapp/image-20240630005523225.png" alt="image-20240630005523225"></p>
<h4 id="指令具体步骤"><a href="#指令具体步骤" class="headerlink" title="指令具体步骤"></a>指令具体步骤</h4><p><img src="/2024/07/05/csapp/image-20240630005548958.png" alt="image-20240630005548958"></p>
<p><img src="/2024/07/05/csapp/image-20240630010421000.png" alt="image-20240630010421000"></p>
<p><img src="/2024/07/05/csapp/image-20240630005620242.png" alt="image-20240630005620242"></p>
<p><img src="/2024/07/05/csapp/image-20240630005657734.png" alt="image-20240630005657734"></p>
<p>译码会解析寄存器含义了</p>
<p><img src="/2024/07/05/csapp/image-20240630005817597.png" alt="image-20240630005817597"></p>
<p>M是指令。</p>
<p>取指阶段会对指令进行解读，看出rA、rB、imm什么的都是指令的啥部位，同时会更新PC</p>
<p>译码阶段会读取寄存器值</p>
<p><img src="/2024/07/05/csapp/image-20240630005830578.png" alt="image-20240630005830578"></p>
<p><img src="/2024/07/05/csapp/image-20240630005908039.png" alt="image-20240630005908039"></p>
<p><img src="/2024/07/05/csapp/image-20240630005931093.png" alt="image-20240630005931093"></p>
<p><img src="/2024/07/05/csapp/image-20240630010005681.png" alt="image-20240630010005681"></p>
<p><img src="/2024/07/05/csapp/image-20240630010017237.png" alt="image-20240630010017237"></p>
<p>注意这个执行，很有意思，设为0xF比直接中断好</p>
<p><img src="/2024/07/05/csapp/image-20240630010102762.png" alt="image-20240630010102762"></p>
<p><img src="/2024/07/05/csapp/image-20240630010135763.png" alt="image-20240630010135763"></p>
<p><img src="/2024/07/05/csapp/image-20240630010157513.png" alt="image-20240630010157513"></p>
<p><img src="/2024/07/05/csapp/image-20240630010231380.png" alt="image-20240630010231380"></p>
<p><img src="/2024/07/05/csapp/image-20240630010243854.png" alt="image-20240630010243854"></p>
<p><img src="/2024/07/05/csapp/image-20240630010307773.png" alt="image-20240630010307773"></p>
<p><img src="/2024/07/05/csapp/image-20240630010325132.png" alt="image-20240630010325132"></p>
<h4 id="硬件逻辑"><a href="#硬件逻辑" class="headerlink" title="硬件逻辑"></a>硬件逻辑</h4><p><img src="/2024/07/05/csapp/image-20240630010555172.png" alt="image-20240630010555172"></p>
<p><img src="/2024/07/05/csapp/image-20240630010611643.png" alt="image-20240630010611643"></p>
<p><img src="/2024/07/05/csapp/image-20240630010632517.png" alt="image-20240630010632517"></p>
<p><img src="/2024/07/05/csapp/image-20240630010644321.png" alt="image-20240630010644321"></p>
<p><img src="/2024/07/05/csapp/image-20240630010655931.png" alt="image-20240630010655931"></p>
<p><img src="/2024/07/05/csapp/image-20240630010708660.png" alt="image-20240630010708660"></p>
<p><img src="/2024/07/05/csapp/image-20240630010723802.png" alt="image-20240630010723802"></p>
<p><img src="/2024/07/05/csapp/image-20240630010741891.png" alt="image-20240630010741891"></p>
<p><img src="/2024/07/05/csapp/image-20240630010757282.png" alt="image-20240630010757282"></p>
<p><img src="/2024/07/05/csapp/image-20240630010813278.png" alt="image-20240630010813278"></p>
<p><img src="/2024/07/05/csapp/image-20240630010826316.png" alt="image-20240630010826316"></p>
<p><img src="/2024/07/05/csapp/image-20240630010840550.png" alt="image-20240630010840550"></p>
<p><img src="/2024/07/05/csapp/image-20240630010851970.png" alt="image-20240630010851970"></p>
<p><img src="/2024/07/05/csapp/image-20240630010908920.png" alt="image-20240630010908920"></p>
<h2 id="流水线基础"><a href="#流水线基础" class="headerlink" title="流水线基础"></a>流水线基础</h2><h3 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h3><p><img src="/2024/07/05/csapp/image-20240630011348702.png" alt="image-20240630011348702"></p>
<p><img src="/2024/07/05/csapp/image-20240630011431579.png" alt="image-20240630011431579"></p>
<p><img src="/2024/07/05/csapp/image-20240630011513826.png" alt="image-20240630011513826"></p>
<p><img src="/2024/07/05/csapp/image-20240630011538449.png" alt="image-20240630011538449"></p>
<p><img src="/2024/07/05/csapp/image-20240630011613462.png" alt="image-20240630011613462"></p>
<h3 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h3><p><img src="/2024/07/05/csapp/image-20240630011631666.png" alt="image-20240630011631666"></p>
<p><img src="/2024/07/05/csapp/image-20240630011652103.png" alt="image-20240630011652103"></p>
<p><img src="/2024/07/05/csapp/image-20240630011743540.png" alt="image-20240630011743540"></p>
<p><img src="/2024/07/05/csapp/image-20240630011757158.png" alt="image-20240630011757158"></p>
<p><img src="/2024/07/05/csapp/image-20240630011827695.png" alt="image-20240630011827695"></p>
<p><img src="/2024/07/05/csapp/image-20240630011845172.png" alt="image-20240630011845172"></p>
<p><img src="/2024/07/05/csapp/image-20240630011904991.png" alt="image-20240630011904991"></p>
<p><img src="/2024/07/05/csapp/image-20240630011934056.png" alt="image-20240630011934056"></p>
<h2 id="冒险处理"><a href="#冒险处理" class="headerlink" title="冒险处理"></a>冒险处理</h2><p><img src="/2024/07/05/csapp/image-20240630013307359.png" alt="image-20240630013307359"></p>
<h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3><h4 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h4><p><img src="/2024/07/05/csapp/image-20240630012139978.png" alt="image-20240630012139978"></p>
<p><img src="/2024/07/05/csapp/image-20240630012255568.png" alt="image-20240630012255568"></p>
<p><img src="/2024/07/05/csapp/image-20240630012324420.png" alt="image-20240630012324420"></p>
<h4 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h4><p><img src="/2024/07/05/csapp/image-20240630012416757.png" alt="image-20240630012416757"></p>
<p><img src="/2024/07/05/csapp/image-20240630012502683.png" alt="image-20240630012502683"></p>
<p><img src="/2024/07/05/csapp/image-20240630012549684.png" alt="image-20240630012549684"></p>
<p><img src="/2024/07/05/csapp/image-20240630012612209.png" alt="image-20240630012612209"></p>
<h3 id="加载使用冒险"><a href="#加载使用冒险" class="headerlink" title="加载使用冒险"></a>加载使用冒险</h3><p><img src="/2024/07/05/csapp/image-20240630012627079.png" alt="image-20240630012627079"></p>
<p><img src="/2024/07/05/csapp/image-20240630012655123.png" alt="image-20240630012655123"></p>
<p><img src="/2024/07/05/csapp/image-20240630012719752.png" alt="image-20240630012719752"></p>
<h3 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h3><p><img src="/2024/07/05/csapp/image-20240630012743913.png" alt="image-20240630012743913"></p>
<p><img src="/2024/07/05/csapp/image-20240630012853884.png" alt="image-20240630012853884"></p>
<p><img src="/2024/07/05/csapp/image-20240630012916659.png" alt="image-20240630012916659"></p>
<p><img src="/2024/07/05/csapp/image-20240630012931439.png" alt="image-20240630012931439"></p>
<p><img src="/2024/07/05/csapp/image-20240630012948209.png" alt="image-20240630012948209"></p>
<h3 id="控制组合"><a href="#控制组合" class="headerlink" title="控制组合"></a>控制组合</h3><p><img src="/2024/07/05/csapp/image-20240630013014298.png" alt="image-20240630013014298"></p>
<p><img src="/2024/07/05/csapp/image-20240630013111622.png" alt="image-20240630013111622"></p>
<p><img src="/2024/07/05/csapp/image-20240630013125796.png" alt="image-20240630013125796"></p>
<p><img src="/2024/07/05/csapp/image-20240630013138985.png" alt="image-20240630013138985"></p>
<p><img src="/2024/07/05/csapp/image-20240630013152159.png" alt="image-20240630013152159"></p>
<p><img src="/2024/07/05/csapp/image-20240630013208512.png" alt="image-20240630013208512"></p>
<h2 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h2><p>CPI：执行每条指令所需的平均时钟周期数</p>
<p><img src="/2024/07/05/csapp/image-20240704174855401.png" alt="image-20240704174855401"></p>
<p>注意这个算式，因为流水线执行，近似认为1个cycle一条指令</p>
<p>数据冒险可以用暂停和数据转发实现（想想就知道），加载使用必须插1个气泡，控制冒险插2个，ret插3个</p>
<p><img src="/2024/07/05/csapp/image-20240630012743913.png" alt="image-20240630012743913"></p>
<p><img src="/2024/07/05/csapp/image-20240630012916659.png" alt="image-20240630012916659"></p>
<p><img src="/2024/07/05/csapp/image-20240704175143438.png" alt="image-20240704175143438"></p>
<h1 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h1><p><img src="/2024/07/05/csapp/image-20240630133748010.png" alt="image-20240630133748010"></p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p><img src="/2024/07/05/csapp/image-20240630133811094.png" alt="image-20240630133811094"></p>
<p><img src="/2024/07/05/csapp/image-20240630133856073.png" alt="image-20240630133856073"></p>
<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p><img src="/2024/07/05/csapp/image-20240630134011707.png" alt="image-20240630134011707"></p>
<p><img src="/2024/07/05/csapp/image-20240630134040373.png" alt="image-20240630134040373"></p>
<p><img src="/2024/07/05/csapp/image-20240630134109151.png" alt="image-20240630134109151"></p>
<p><img src="/2024/07/05/csapp/image-20240630135959526.png" alt="image-20240630135959526"></p>
<h2 id="各种优化方法"><a href="#各种优化方法" class="headerlink" title="各种优化方法"></a>各种优化方法</h2><p><img src="/2024/07/05/csapp/image-20240630134138846.png" alt="image-20240630134138846"></p>
<p><img src="/2024/07/05/csapp/image-20240630134156618.png" alt="image-20240630134156618"></p>
<p>一般都是转为指针访问</p>
<p><img src="/2024/07/05/csapp/image-20240630134519002.png" alt="image-20240630134519002"></p>
<p><img src="/2024/07/05/csapp/image-20240630134556944.png" alt="image-20240630134556944"></p>
<p><img src="/2024/07/05/csapp/image-20240630134615112.png" alt="image-20240630134615112"></p>
<p><img src="/2024/07/05/csapp/image-20240630134710745.png" alt="image-20240630134710745"></p>
<p><img src="/2024/07/05/csapp/image-20240630134734845.png" alt="image-20240630134734845"></p>
<p><img src="/2024/07/05/csapp/image-20240630134748924.png" alt="image-20240630134748924"></p>
<p><img src="/2024/07/05/csapp/image-20240630134923171.png" alt="image-20240630134923171"></p>
<p><img src="/2024/07/05/csapp/image-20240630134944225.png" alt="image-20240630134944225"></p>
<p>66666</p>
<p><img src="/2024/07/05/csapp/image-20240630135352615.png" alt="image-20240630135352615"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2024/07/05/csapp/image-20240630135509167.png" alt="image-20240630135509167"></p>
<p><img src="/2024/07/05/csapp/image-20240630135759205.png" alt="image-20240630135759205"></p>
<h3 id="基础优化"><a href="#基础优化" class="headerlink" title="基础优化"></a>基础优化</h3><p><img src="/2024/07/05/csapp/image-20240630140204862.png" alt="image-20240630140204862"></p>
<h3 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h3><p><img src="/2024/07/05/csapp/image-20240630140352288.png" alt="image-20240630140352288"></p>
<p><img src="/2024/07/05/csapp/image-20240630140409146.png" alt="image-20240630140409146"></p>
<p><img src="/2024/07/05/csapp/image-20240630140448474.png" alt="image-20240630140448474"></p>
<p><img src="/2024/07/05/csapp/image-20240630225409553.png" alt="image-20240630225409553"></p>
<p><img src="/2024/07/05/csapp/image-20240630225438683.png" alt="image-20240630225438683"></p>
<p><img src="/2024/07/05/csapp/image-20240630225456483.png" alt="image-20240630225456483"></p>
<p><img src="/2024/07/05/csapp/image-20240630225508254.png" alt="image-20240630225508254"></p>
<p><img src="/2024/07/05/csapp/image-20240630225614641.png" alt="image-20240630225614641"></p>
<p><img src="/2024/07/05/csapp/image-20240630225642406.png" alt="image-20240630225642406"></p>
<p><img src="/2024/07/05/csapp/image-20240630225658504.png" alt="image-20240630225658504"></p>
<p><img src="/2024/07/05/csapp/image-20240630225719047.png" alt="image-20240630225719047"></p>
<p><img src="/2024/07/05/csapp/image-20240630225728826.png" alt="image-20240630225728826"></p>
<p><img src="/2024/07/05/csapp/image-20240630225745030.png" alt="image-20240630225745030"></p>
<p><img src="/2024/07/05/csapp/image-20240630225817123.png" alt="image-20240630225817123"></p>
<p><img src="/2024/07/05/csapp/image-20240630225836771.png" alt="image-20240630225836771"></p>
<p><img src="/2024/07/05/csapp/image-20240630225848400.png" alt="image-20240630225848400"></p>
<p><img src="/2024/07/05/csapp/image-20240630225902072.png" alt="image-20240630225902072"></p>
<p><img src="/2024/07/05/csapp/image-20240630230021815.png" alt="image-20240630230021815"></p>
<p><img src="/2024/07/05/csapp/image-20240630230036198.png" alt="image-20240630230036198"></p>
<p><img src="/2024/07/05/csapp/image-20240630230051794.png" alt="image-20240630230051794"></p>
<p><img src="/2024/07/05/csapp/image-20240630230418357.png" alt="image-20240630230418357"></p>
<p><img src="/2024/07/05/csapp/image-20240630230428557.png" alt="image-20240630230428557"></p>
<p><img src="/2024/07/05/csapp/image-20240630230501629.png" alt="image-20240630230501629"></p>
<p><img src="/2024/07/05/csapp/image-20240630230541510.png" alt="image-20240630230541510"></p>
<p><img src="/2024/07/05/csapp/image-20240630230647983.png" alt="image-20240630230647983"></p>
<p><img src="/2024/07/05/csapp/image-20240630230710718.png" alt="image-20240630230710718"></p>
<p><img src="/2024/07/05/csapp/image-20240630230919375.png" alt="image-20240630230919375"></p>
<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><h2 id="存储器层级结构与局部性"><a href="#存储器层级结构与局部性" class="headerlink" title="存储器层级结构与局部性"></a>存储器层级结构与局部性</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><img src="/2024/07/05/csapp/image-20240630231448071.png" alt="image-20240630231448071"></p>
<p><img src="/2024/07/05/csapp/image-20240630231736879.png" alt="image-20240630231736879"></p>
<p><img src="/2024/07/05/csapp/image-20240630232656362.png" alt="image-20240630232656362"></p>
<p><img src="/2024/07/05/csapp/image-20240630232337513.png" alt="image-20240630232337513"></p>
<p><img src="/2024/07/05/csapp/image-20240630232414904.png" alt="image-20240630232414904"></p>
<p><img src="/2024/07/05/csapp/image-20240630232820913.png" alt="image-20240630232820913"></p>
<p><img src="/2024/07/05/csapp/image-20240630233029450.png" alt="image-20240630233029450"></p>
<p><img src="/2024/07/05/csapp/image-20240630233112434.png" alt="image-20240630233112434"></p>
<h3 id="存储器结构"><a href="#存储器结构" class="headerlink" title="存储器结构"></a>存储器结构</h3><p><img src="/2024/07/05/csapp/image-20240630233214840.png" alt="image-20240630233214840"></p>
<p><img src="/2024/07/05/csapp/image-20240630233608614.png" alt="image-20240630233608614"></p>
<p><img src="/2024/07/05/csapp/image-20240630233709252.png" alt="image-20240630233709252"></p>
<p><img src="/2024/07/05/csapp/image-20240630233801245.png" alt="image-20240630233801245"></p>
<p><img src="/2024/07/05/csapp/image-20240630233955535.png" alt="image-20240630233955535"></p>
<p><img src="/2024/07/05/csapp/image-20240630234008062.png" alt="image-20240630234008062"></p>
<p><img src="/2024/07/05/csapp/image-20240630234225579.png" alt="image-20240630234225579"></p>
<p><img src="/2024/07/05/csapp/image-20240630234250107.png" alt="image-20240630234250107"></p>
<p><img src="/2024/07/05/csapp/image-20240630234314688.png" alt="image-20240630234314688"></p>
<p><img src="/2024/07/05/csapp/image-20240630234429142.png" alt="image-20240630234429142"></p>
<p><img src="/2024/07/05/csapp/image-20240630234442022.png" alt="image-20240630234442022"></p>
<p><img src="/2024/07/05/csapp/image-20240630234458920.png" alt="image-20240630234458920"></p>
<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><p><img src="/2024/07/05/csapp/image-20240630234532013.png" alt="image-20240630234532013"></p>
<p><img src="/2024/07/05/csapp/image-20240630234546448.png" alt="image-20240630234546448"></p>
<p><img src="/2024/07/05/csapp/image-20240630234558321.png" alt="image-20240630234558321"></p>
<p><img src="/2024/07/05/csapp/image-20240630234726167.png" alt="image-20240630234726167"></p>
<p><img src="/2024/07/05/csapp/image-20240630234739157.png" alt="image-20240630234739157"></p>
<p><img src="/2024/07/05/csapp/image-20240630234754773.png" alt="image-20240630234754773"></p>
<p><img src="/2024/07/05/csapp/image-20240630234801631.png" alt="image-20240630234801631"></p>
<p><img src="/2024/07/05/csapp/image-20240630234808895.png" alt="image-20240630234808895"></p>
<p><img src="/2024/07/05/csapp/image-20240630234817762.png" alt="image-20240630234817762"></p>
<p><img src="/2024/07/05/csapp/image-20240630234839700.png" alt="image-20240630234839700"></p>
<p><img src="/2024/07/05/csapp/image-20240630234851304.png" alt="image-20240630234851304"></p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p><img src="/2024/07/05/csapp/image-20240630234915634.png" alt="image-20240630234915634"></p>
<p><img src="/2024/07/05/csapp/image-20240630234933851.png" alt="image-20240630234933851"></p>
<p><img src="/2024/07/05/csapp/image-20240630235117792.png" alt="image-20240630235117792"></p>
<h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>磁盘容量的计算方法 容量 = 每个扇区可记录的字节数 x 扇区总数</p>
<p><img src="/2024/07/05/csapp/image-20240630235225773.png" alt="image-20240630235225773"></p>
<p><img src="/2024/07/05/csapp/image-20240630235439929.png" alt="image-20240630235439929"></p>
<p><img src="/2024/07/05/csapp/image-20240630235448405.png" alt="image-20240630235448405"></p>
<p><img src="/2024/07/05/csapp/image-20240630235540406.png" alt="image-20240630235540406"></p>
<p><img src="/2024/07/05/csapp/image-20240630235551978.png" alt="image-20240630235551978"></p>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>磁盘访问的平均读取时间 访问时间 = 寻道时间 + 平均旋转延迟 + 数据传输时间</p>
<p>平均旋转延迟就是假设每次转半圈，也即1/2 * (1/RPM)*60 秒</p>
<p>数据传输时间就是，转一圈时间 / 每圈扇区数，其中每圈扇区数 = 平均扇区数 / 磁道数</p>
<p><img src="/2024/07/05/csapp/image-20240630235722678.png" alt="image-20240630235722678"></p>
<p><img src="/2024/07/05/csapp/image-20240630235628333.png" alt="image-20240630235628333"></p>
<p><img src="/2024/07/05/csapp/image-20240630235702316.png" alt="image-20240630235702316"></p>
<p><img src="/2024/07/05/csapp/image-20240630235758288.png" alt="image-20240630235758288"></p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p><img src="/2024/07/05/csapp/image-20240701000025738.png" alt="image-20240701000025738"></p>
<p><img src="/2024/07/05/csapp/image-20240701000038474.png" alt="image-20240701000038474"></p>
<p><img src="/2024/07/05/csapp/image-20240701000141180.png" alt="image-20240701000141180"></p>
<p><img src="/2024/07/05/csapp/image-20240701000216168.png" alt="image-20240701000216168"></p>
<p><img src="/2024/07/05/csapp/image-20240701000226791.png" alt="image-20240701000226791"></p>
<p><img src="/2024/07/05/csapp/image-20240701000240550.png" alt="image-20240701000240550"></p>
<p><img src="/2024/07/05/csapp/image-20240701000259526.png" alt="image-20240701000259526"></p>
<h4 id="与CPU交互"><a href="#与CPU交互" class="headerlink" title="与CPU交互"></a>与CPU交互</h4><p><img src="/2024/07/05/csapp/image-20240701000327650.png" alt="image-20240701000327650"></p>
<p><img src="/2024/07/05/csapp/image-20240701000344179.png" alt="image-20240701000344179"></p>
<p><img src="/2024/07/05/csapp/image-20240701000358729.png" alt="image-20240701000358729"></p>
<p><img src="/2024/07/05/csapp/image-20240701000412445.png" alt="image-20240701000412445"></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><img src="/2024/07/05/csapp/image-20240701000505024.png" alt="image-20240701000505024"></p>
<p><img src="/2024/07/05/csapp/image-20240701000515106.png" alt="image-20240701000515106"></p>
<p><img src="/2024/07/05/csapp/image-20240701000609925.png" alt="image-20240701000609925"></p>
<h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p><img src="/2024/07/05/csapp/image-20240701000620354.png" alt="image-20240701000620354"></p>
<p><img src="/2024/07/05/csapp/image-20240701000633149.png" alt="image-20240701000633149"></p>
<p><img src="/2024/07/05/csapp/image-20240701000648470.png" alt="image-20240701000648470"></p>
<p><img src="/2024/07/05/csapp/image-20240701000658527.png" alt="image-20240701000658527"></p>
<p><img src="/2024/07/05/csapp/image-20240701000717439.png" alt="image-20240701000717439"></p>
<p><img src="/2024/07/05/csapp/image-20240701000759240.png" alt="image-20240701000759240"></p>
<p><img src="/2024/07/05/csapp/image-20240701000959815.png" alt="image-20240701000959815"></p>
<p><img src="/2024/07/05/csapp/image-20240701001026637.png" alt="image-20240701001026637"></p>
<p>66666说得很本质</p>
<p><img src="/2024/07/05/csapp/image-20240701001130245.png" alt="image-20240701001130245"></p>
<h2 id="高速缓冲器Cache"><a href="#高速缓冲器Cache" class="headerlink" title="高速缓冲器Cache"></a>高速缓冲器Cache</h2><h3 id="高速缓存存储器组织结构和操作"><a href="#高速缓存存储器组织结构和操作" class="headerlink" title="高速缓存存储器组织结构和操作"></a>高速缓存存储器组织结构和操作</h3><p><img src="/2024/07/05/csapp/image-20240701001304028.png" alt="image-20240701001304028"></p>
<p><img src="/2024/07/05/csapp/image-20240701001315744.png" alt="image-20240701001315744"></p>
<p><img src="/2024/07/05/csapp/image-20240701001331218.png" alt="image-20240701001331218"></p>
<p><img src="/2024/07/05/csapp/image-20240701001417754.png" alt="image-20240701001417754"></p>
<p><img src="/2024/07/05/csapp/image-20240701001648953.png" alt="image-20240701001648953"></p>
<p><img src="/2024/07/05/csapp/image-20240701001737776.png" alt="image-20240701001737776"></p>
<p><img src="/2024/07/05/csapp/image-20240701001751156.png" alt="image-20240701001751156"></p>
<p><img src="/2024/07/05/csapp/image-20240701001830506.png" alt="image-20240701001830506"></p>
<p><img src="/2024/07/05/csapp/image-20240701001932525.png" alt="image-20240701001932525"></p>
<p><img src="/2024/07/05/csapp/image-20240701001954052.png" alt="image-20240701001954052"></p>
<p><img src="/2024/07/05/csapp/image-20240701002012687.png" alt="image-20240701002012687"></p>
<p><img src="/2024/07/05/csapp/image-20240701002043426.png" alt="image-20240701002043426"></p>
<p><img src="/2024/07/05/csapp/image-20240701002106379.png" alt="image-20240701002106379"></p>
<p><img src="/2024/07/05/csapp/image-20240701002201179.png" alt="image-20240701002201179"></p>
<p><img src="/2024/07/05/csapp/image-20240701002247066.png" alt="image-20240701002247066"></p>
<p><img src="/2024/07/05/csapp/image-20240701002257639.png" alt="image-20240701002257639"></p>
<p><img src="/2024/07/05/csapp/image-20240701002929917.png" alt="image-20240701002929917"></p>
<p><img src="/2024/07/05/csapp/image-20240701002946176.png" alt="image-20240701002946176"></p>
<p><img src="/2024/07/05/csapp/image-20240701003014200.png" alt="image-20240701003014200"></p>
<p><img src="/2024/07/05/csapp/image-20240701003031669.png" alt="image-20240701003031669"></p>
<p><img src="/2024/07/05/csapp/image-20240701003213303.png" alt="image-20240701003213303"></p>
<p><img src="/2024/07/05/csapp/image-20240701003250061.png" alt="image-20240701003250061"></p>
<p><img src="/2024/07/05/csapp/image-20240701003307383.png" alt="image-20240701003307383"></p>
<p><img src="/2024/07/05/csapp/image-20240701003401049.png" alt="image-20240701003401049"></p>
<p><img src="/2024/07/05/csapp/image-20240701003422937.png" alt="image-20240701003422937"></p>
<h3 id="高速缓存对程序性能的影响"><a href="#高速缓存对程序性能的影响" class="headerlink" title="高速缓存对程序性能的影响"></a>高速缓存对程序性能的影响</h3><h4 id="不命中率"><a href="#不命中率" class="headerlink" title="不命中率"></a>不命中率</h4><p>这个不命中率的计算：</p>
<p><img src="/2024/07/05/csapp/image-20240705122255695.png" alt="image-20240705122255695"></p>
<p><img src="/2024/07/05/csapp/image-20240705123753331.png" alt="image-20240705123753331"></p>
<p>那就是说一个块可以放B/4个int，然后每隔B/4个int就会出现冲突不命中，这个时候就要加载进去就是1/B/4</p>
<h4 id="存储器山"><a href="#存储器山" class="headerlink" title="存储器山"></a>存储器山</h4><p><img src="/2024/07/05/csapp/image-20240701003543629.png" alt="image-20240701003543629"></p>
<p><img src="/2024/07/05/csapp/image-20240701003601477.png" alt="image-20240701003601477"></p>
<h4 id="重新排列提高空间局部性"><a href="#重新排列提高空间局部性" class="headerlink" title="重新排列提高空间局部性"></a>重新排列提高空间局部性</h4><p><img src="/2024/07/05/csapp/image-20240701003627431.png" alt="image-20240701003627431"></p>
<p><img src="/2024/07/05/csapp/image-20240701003638009.png" alt="image-20240701003638009"></p>
<p><img src="/2024/07/05/csapp/image-20240701105851119.png" alt="image-20240701105851119"></p>
<p><img src="/2024/07/05/csapp/image-20240701110000652.png" alt="image-20240701110000652"></p>
<p><img src="/2024/07/05/csapp/image-20240701110048277.png" alt="image-20240701110048277"></p>
<p>6666</p>
<p>不过这样的话，如果放宽到整个，那A依然还是不怎么那个的吧</p>
<p><img src="/2024/07/05/csapp/image-20240701110200830.png" alt="image-20240701110200830"></p>
<p>所以感觉还是这个最好</p>
<h4 id="使用块提高时间局部性"><a href="#使用块提高时间局部性" class="headerlink" title="使用块提高时间局部性"></a>使用块提高时间局部性</h4><p><img src="/2024/07/05/csapp/image-20240701110519231.png" alt="image-20240701110519231"></p>
<p><img src="/2024/07/05/csapp/image-20240701110718021.png" alt="image-20240701110718021"></p>
<p><img src="/2024/07/05/csapp/image-20240701110732339.png" alt="image-20240701110732339"></p>
<p><img src="/2024/07/05/csapp/image-20240701110812570.png" alt="image-20240701110812570"></p>
<p><img src="/2024/07/05/csapp/image-20240701110825808.png" alt="image-20240701110825808"></p>
<p><img src="/2024/07/05/csapp/image-20240701110837443.png" alt="image-20240701110837443"></p>
<p><img src="/2024/07/05/csapp/image-20240701111903105.png" alt="image-20240701111903105"></p>
<p><img src="/2024/07/05/csapp/image-20240701111914613.png" alt="image-20240701111914613"></p>
<p>确实，养成好习惯</p>
<p><img src="/2024/07/05/csapp/image-20240705205842958.png" alt="image-20240705205842958"></p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2024/07/05/csapp/image-20240704211635823.png" alt="image-20240704211635823"></p>
<p><img src="/2024/07/05/csapp/image-20240704211737812.png" alt="image-20240704211737812"></p>
<p><img src="/2024/07/05/csapp/image-20240704211953231.png" alt="image-20240704211953231"></p>
<p><img src="/2024/07/05/csapp/image-20240704212021758.png" alt="image-20240704212021758"></p>
<p><img src="/2024/07/05/csapp/image-20240704213240297.png" alt="image-20240704213240297"></p>
<p><img src="/2024/07/05/csapp/image-20240704213511788.png" alt="image-20240704213511788"></p>
<p>重定位</p>
<p><img src="/2024/07/05/csapp/image-20240704213719440.png" alt="image-20240704213719440"></p>
<p><img src="/2024/07/05/csapp/image-20240704213738517.png" alt="image-20240704213738517"></p>
<p><img src="/2024/07/05/csapp/image-20240704214226162.png" alt="image-20240704214226162"></p>
<h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/07/05/csapp/image-20240701112241696.png" alt="image-20240701112241696"></p>
<p><img src="/2024/07/05/csapp/image-20240701112305467.png" alt="image-20240701112305467"></p>
<p><img src="/2024/07/05/csapp/image-20240701112315389.png" alt="image-20240701112315389"></p>
<p><img src="/2024/07/05/csapp/image-20240701112349299.png" alt="image-20240701112349299"></p>
<p><img src="/2024/07/05/csapp/image-20240701112433533.png" alt="image-20240701112433533"></p>
<p><img src="/2024/07/05/csapp/image-20240701112656526.png" alt="image-20240701112656526"></p>
<p><img src="/2024/07/05/csapp/image-20240701113135807.png" alt="image-20240701113135807"></p>
<p><img src="/2024/07/05/csapp/image-20240701113206887.png" alt="image-20240701113206887"></p>
<p><img src="/2024/07/05/csapp/image-20240701113246732.png" alt="image-20240701113246732"></p>
<p><img src="/2024/07/05/csapp/image-20240701113604991.png" alt="image-20240701113604991"></p>
<h2 id="目标文件及格式"><a href="#目标文件及格式" class="headerlink" title="目标文件及格式"></a>目标文件及格式</h2><p><img src="/2024/07/05/csapp/image-20240701113633547.png" alt="image-20240701113633547"></p>
<p><img src="/2024/07/05/csapp/image-20240701115555150.png" alt="image-20240701115555150"></p>
<p><img src="/2024/07/05/csapp/image-20240701115608457.png" alt="image-20240701115608457"></p>
<p><img src="/2024/07/05/csapp/image-20240701115925301.png" alt="image-20240701115925301"></p>
<p><img src="/2024/07/05/csapp/image-20240701120329045.png" alt="image-20240701120329045"></p>
<p><img src="/2024/07/05/csapp/image-20240701120411699.png" alt="image-20240701120411699"></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><p><img src="/2024/07/05/csapp/image-20240701173414489.png" alt="image-20240701173414489"></p>
<p><img src="/2024/07/05/csapp/image-20240701173551499.png" alt="image-20240701173551499"></p>
<p><img src="/2024/07/05/csapp/image-20240701173621134.png" alt="image-20240701173621134"></p>
<p><img src="/2024/07/05/csapp/image-20240701173806738.png" alt="image-20240701173806738"></p>
<p><img src="/2024/07/05/csapp/image-20240701174036766.png" alt="image-20240701174036766"></p>
<p>在默认情况下，<code>gcc</code> 使用一个叫做 “common” 的机制来处理未初始化的全局变量和静态变量。这种机制允许多个编译单元（例如多个源文件）共享同一个未初始化的全局变量或静态变量。然而，这可能导致一些不可预见的行为，尤其是在多线程环境中。</p>
<p>使用 <code>-fno-common</code> 选项可以关闭这种默认行为，强制 <code>gcc</code> 为每个使用未初始化全局变量或静态变量的编译单元创建一个唯一的符号。这样做可以避免潜在的共享问题，但可能会增加程序的内存使用量。</p>
<p><img src="/2024/07/05/csapp/image-20240701175729290.png" alt="image-20240701175729290"></p>
<p><img src="/2024/07/05/csapp/image-20240701180215212.png" alt="image-20240701180215212"></p>
<h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p><img src="/2024/07/05/csapp/image-20240701180353769.png" alt="image-20240701180353769"></p>
<p><img src="/2024/07/05/csapp/image-20240701180448296.png" alt="image-20240701180448296"></p>
<p><img src="/2024/07/05/csapp/image-20240701180614927.png" alt="image-20240701180614927"></p>
<p><img src="/2024/07/05/csapp/image-20240701180648979.png" alt="image-20240701180648979"></p>
<p><img src="/2024/07/05/csapp/image-20240701180725265.png" alt="image-20240701180725265"></p>
<p><img src="/2024/07/05/csapp/image-20240701180734185.png" alt="image-20240701180734185"></p>
<p><img src="/2024/07/05/csapp/image-20240701180908786.png" alt="image-20240701180908786"></p>
<p><img src="/2024/07/05/csapp/image-20240701181256913.png" alt="image-20240701181256913"></p>
<p><img src="/2024/07/05/csapp/image-20240701181312762.png" alt="image-20240701181312762"></p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p><img src="/2024/07/05/csapp/image-20240701181428456.png" alt="image-20240701181428456"></p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p><img src="/2024/07/05/csapp/image-20240701181559394.png" alt="image-20240701181559394"></p>
<p><img src="/2024/07/05/csapp/image-20240701181653520.png" alt="image-20240701181653520"></p>
<p><img src="/2024/07/05/csapp/image-20240701181702426.png" alt="image-20240701181702426"></p>
<p><img src="/2024/07/05/csapp/image-20240701181713380.png" alt="image-20240701181713380"></p>
<p><img src="/2024/07/05/csapp/image-20240701181721497.png" alt="image-20240701181721497"></p>
<p><img src="/2024/07/05/csapp/image-20240701181817409.png" alt="image-20240701181817409"></p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p><img src="/2024/07/05/csapp/image-20240701181902374.png" alt="image-20240701181902374"></p>
<p><img src="/2024/07/05/csapp/image-20240701181951703.png" alt="image-20240701181951703"></p>
<p><img src="/2024/07/05/csapp/image-20240701182256860.png" alt="image-20240701182256860"></p>
<h2 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h2><h1 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h1><h2 id="异常和进程"><a href="#异常和进程" class="headerlink" title="异常和进程"></a>异常和进程</h2><h3 id="异常控制流-1"><a href="#异常控制流-1" class="headerlink" title="异常控制流"></a>异常控制流</h3><p><img src="/2024/07/05/csapp/image-20240701183024791.png" alt="image-20240701183024791"></p>
<p><img src="/2024/07/05/csapp/image-20240701183101895.png" alt="image-20240701183101895"></p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p><img src="/2024/07/05/csapp/image-20240701183120279.png" alt="image-20240701183120279"></p>
<p><img src="/2024/07/05/csapp/image-20240701183213271.png" alt="image-20240701183213271"></p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><img src="/2024/07/05/csapp/image-20240701183224377.png" alt="image-20240701183224377"></p>
<p><img src="/2024/07/05/csapp/image-20240701183317047.png" alt="image-20240701183317047"></p>
<p><img src="/2024/07/05/csapp/image-20240701183408486.png" alt="image-20240701183408486"></p>
<p><img src="/2024/07/05/csapp/image-20240701183508635.png" alt="image-20240701183508635"></p>
<p><img src="/2024/07/05/csapp/image-20240701183529030.png" alt="image-20240701183529030"></p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><img src="/2024/07/05/csapp/image-20240701183538986.png" alt="image-20240701183538986"></p>
<p><img src="/2024/07/05/csapp/image-20240701183614572.png" alt="image-20240701183614572"></p>
<p><img src="/2024/07/05/csapp/image-20240701183628668.png" alt="image-20240701183628668"></p>
<p><img src="/2024/07/05/csapp/image-20240701183636280.png" alt="image-20240701183636280"></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><img src="/2024/07/05/csapp/image-20240701183655575.png" alt="image-20240701183655575"></p>
<p><img src="/2024/07/05/csapp/image-20240701183708454.png" alt="image-20240701183708454"></p>
<p><img src="/2024/07/05/csapp/image-20240701183717705.png" alt="image-20240701183717705"></p>
<p><img src="/2024/07/05/csapp/image-20240701183729258.png" alt="image-20240701183729258"></p>
<p><img src="/2024/07/05/csapp/image-20240701183738316.png" alt="image-20240701183738316"></p>
<p><img src="/2024/07/05/csapp/image-20240701183748785.png" alt="image-20240701183748785"></p>
<p><img src="/2024/07/05/csapp/image-20240701183806132.png" alt="image-20240701183806132"></p>
<p><img src="/2024/07/05/csapp/image-20240701183837685.png" alt="image-20240701183837685"></p>
<p><img src="/2024/07/05/csapp/image-20240701183852388.png" alt="image-20240701183852388"></p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p><img src="/2024/07/05/csapp/image-20240701183942673.png" alt="image-20240701183942673"></p>
<p><img src="/2024/07/05/csapp/image-20240701184010877.png" alt="image-20240701184010877"></p>
<p><img src="/2024/07/05/csapp/image-20240701184035892.png" alt="image-20240701184035892"></p>
<p><img src="/2024/07/05/csapp/image-20240701184055783.png" alt="image-20240701184055783"></p>
<p><img src="/2024/07/05/csapp/image-20240701184104258.png" alt="image-20240701184104258"></p>
<p><img src="/2024/07/05/csapp/image-20240701184125859.png" alt="image-20240701184125859"></p>
<p><img src="/2024/07/05/csapp/image-20240701184139058.png" alt="image-20240701184139058"></p>
<p><img src="/2024/07/05/csapp/image-20240701184236414.png" alt="image-20240701184236414"></p>
<p><img src="/2024/07/05/csapp/image-20240701184244012.png" alt="image-20240701184244012"></p>
<p><img src="/2024/07/05/csapp/image-20240701184441815.png" alt="image-20240701184441815"></p>
<p><img src="/2024/07/05/csapp/image-20240701184453139.png" alt="image-20240701184453139"></p>
<p><img src="/2024/07/05/csapp/image-20240701184508224.png" alt="image-20240701184508224"></p>
<p><img src="/2024/07/05/csapp/image-20240701184519568.png" alt="image-20240701184519568"></p>
<p><img src="/2024/07/05/csapp/image-20240701184529392.png" alt="image-20240701184529392"></p>
<p><img src="/2024/07/05/csapp/image-20240701184536701.png" alt="image-20240701184536701"></p>
<p><img src="/2024/07/05/csapp/image-20240701184554813.png" alt="image-20240701184554813"></p>
<p><img src="/2024/07/05/csapp/image-20240701184603458.png" alt="image-20240701184603458"></p>
<p><img src="/2024/07/05/csapp/image-20240701184612098.png" alt="image-20240701184612098"></p>
<p><img src="/2024/07/05/csapp/image-20240701184619563.png" alt="image-20240701184619563"></p>
<p><img src="/2024/07/05/csapp/image-20240701184633673.png" alt="image-20240701184633673"></p>
<p><img src="/2024/07/05/csapp/image-20240701184655814.png" alt="image-20240701184655814"></p>
<p><img src="/2024/07/05/csapp/image-20240701184703717.png" alt="image-20240701184703717"></p>
<p><img src="/2024/07/05/csapp/image-20240701184718272.png" alt="image-20240701184718272"></p>
<p><img src="/2024/07/05/csapp/image-20240701184727503.png" alt="image-20240701184727503"></p>
<p><img src="/2024/07/05/csapp/image-20240701184735380.png" alt="image-20240701184735380"></p>
<p><img src="/2024/07/05/csapp/image-20240701184745282.png" alt="image-20240701184745282"></p>
<p><img src="/2024/07/05/csapp/image-20240701184756389.png" alt="image-20240701184756389"></p>
<h2 id="信号与非本地跳转"><a href="#信号与非本地跳转" class="headerlink" title="信号与非本地跳转"></a>信号与非本地跳转</h2><p><img src="/2024/07/05/csapp/image-20240701185121530.png" alt="image-20240701185121530"></p>
<h3 id="Shells"><a href="#Shells" class="headerlink" title="Shells"></a>Shells</h3><p><img src="/2024/07/05/csapp/image-20240701185158635.png" alt="image-20240701185158635"></p>
<p><img src="/2024/07/05/csapp/image-20240701185247526.png" alt="image-20240701185247526"></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p><img src="/2024/07/05/csapp/image-20240701185344198.png" alt="image-20240701185344198"></p>
<p><img src="/2024/07/05/csapp/image-20240701185357427.png" alt="image-20240701185357427"></p>
<p><img src="/2024/07/05/csapp/image-20240701203244422.png" alt="image-20240701203244422"></p>
<p><img src="/2024/07/05/csapp/image-20240701203359433.png" alt="image-20240701203359433"></p>
<p><img src="/2024/07/05/csapp/image-20240701203526794.png" alt="image-20240701203526794"></p>
<p><img src="/2024/07/05/csapp/image-20240701203558046.png" alt="image-20240701203558046"></p>
<p><img src="/2024/07/05/csapp/image-20240701203629240.png" alt="image-20240701203629240"></p>
<p><img src="/2024/07/05/csapp/image-20240701203651652.png" alt="image-20240701203651652"></p>
<p><img src="/2024/07/05/csapp/image-20240701203711313.png" alt="image-20240701203711313"></p>
<p><img src="/2024/07/05/csapp/image-20240701203727977.png" alt="image-20240701203727977"></p>
<p><img src="/2024/07/05/csapp/image-20240701204830000.png" alt="image-20240701204830000"></p>
<p><img src="/2024/07/05/csapp/image-20240701204909119.png" alt="image-20240701204909119"></p>
<p><img src="/2024/07/05/csapp/image-20240701204945220.png" alt="image-20240701204945220"></p>
<p><img src="/2024/07/05/csapp/image-20240701204956451.png" alt="image-20240701204956451"></p>
<p><img src="/2024/07/05/csapp/image-20240701205006962.png" alt="image-20240701205006962"></p>
<p><img src="/2024/07/05/csapp/image-20240701205025116.png" alt="image-20240701205025116"></p>
<p><img src="/2024/07/05/csapp/image-20240701205101889.png" alt="image-20240701205101889"></p>
<p><img src="/2024/07/05/csapp/image-20240701205627208.png" alt="image-20240701205627208"></p>
<h3 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h3><p><img src="/2024/07/05/csapp/image-20240701205710019.png" alt="image-20240701205710019"></p>
<p><img src="/2024/07/05/csapp/image-20240701205739557.png" alt="image-20240701205739557"></p>
<p><img src="/2024/07/05/csapp/image-20240701205820601.png" alt="image-20240701205820601"></p>
<p>6666</p>
<p><img src="/2024/07/05/csapp/image-20240701205918314.png" alt="image-20240701205918314"></p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p><img src="/2024/07/05/csapp/image-20240701210602068.png" alt="image-20240701210602068"></p>
<p><img src="/2024/07/05/csapp/image-20240701210616879.png" alt="image-20240701210616879"></p>
<p><img src="/2024/07/05/csapp/image-20240701210720176.png" alt="image-20240701210720176"></p>
<p><img src="/2024/07/05/csapp/image-20240701210736379.png" alt="image-20240701210736379"></p>
<p><img src="/2024/07/05/csapp/image-20240701210818329.png" alt="image-20240701210818329"></p>
<p><img src="/2024/07/05/csapp/image-20240701211017636.png" alt="image-20240701211017636"></p>
<h3 id="虚拟内存作用"><a href="#虚拟内存作用" class="headerlink" title="虚拟内存作用"></a>虚拟内存作用</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p><img src="/2024/07/05/csapp/image-20240701211208304.png" alt="image-20240701211208304"></p>
<p>碎片化</p>
<p><img src="/2024/07/05/csapp/image-20240701211505551.png" alt="image-20240701211505551"></p>
<p><img src="/2024/07/05/csapp/image-20240701211525884.png" alt="image-20240701211525884"></p>
<p><img src="/2024/07/05/csapp/image-20240701211550731.png" alt="image-20240701211550731"></p>
<p><img src="/2024/07/05/csapp/image-20240701211603952.png" alt="image-20240701211603952"></p>
<p><img src="/2024/07/05/csapp/image-20240701211647612.png" alt="image-20240701211647612"></p>
<p><img src="/2024/07/05/csapp/image-20240701211710372.png" alt="image-20240701211710372"></p>
<p><img src="/2024/07/05/csapp/image-20240701211722090.png" alt="image-20240701211722090"></p>
<h4 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h4><p><img src="/2024/07/05/csapp/image-20240701211830620.png" alt="image-20240701211830620"></p>
<p><img src="/2024/07/05/csapp/image-20240701211848944.png" alt="image-20240701211848944"></p>
<p><img src="/2024/07/05/csapp/image-20240701211936967.png" alt="image-20240701211936967"></p>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p><img src="/2024/07/05/csapp/image-20240701212003103.png" alt="image-20240701212003103"></p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p><img src="/2024/07/05/csapp/image-20240701212321094.png" alt="image-20240701212321094"></p>
<p><img src="/2024/07/05/csapp/image-20240701212337020.png" alt="image-20240701212337020"></p>
<p><img src="/2024/07/05/csapp/image-20240701212359103.png" alt="image-20240701212359103"></p>
<p><img src="/2024/07/05/csapp/image-20240701212450773.png" alt="image-20240701212450773"></p>
<p><img src="/2024/07/05/csapp/image-20240701212634781.png" alt="image-20240701212634781"></p>
<p><img src="/2024/07/05/csapp/image-20240701212644887.png" alt="image-20240701212644887"></p>
<p><img src="/2024/07/05/csapp/image-20240701212707265.png" alt="image-20240701212707265"></p>
<p><img src="/2024/07/05/csapp/image-20240701212727989.png" alt="image-20240701212727989"></p>
<p><img src="/2024/07/05/csapp/image-20240701212746777.png" alt="image-20240701212746777"></p>
<p><img src="/2024/07/05/csapp/image-20240701212758718.png" alt="image-20240701212758718"></p>
<p><img src="/2024/07/05/csapp/image-20240701212819032.png" alt="image-20240701212819032"></p>
<p><img src="/2024/07/05/csapp/image-20240701212905986.png" alt="image-20240701212905986"></p>
<p><img src="/2024/07/05/csapp/image-20240701213408370.png" alt="image-20240701213408370"></p>
<p><img src="/2024/07/05/csapp/image-20240701213419824.png" alt="image-20240701213419824"></p>
<h2 id="系统举例"><a href="#系统举例" class="headerlink" title="系统举例"></a>系统举例</h2><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p><img src="/2024/07/05/csapp/image-20240701213652719.png" alt="image-20240701213652719"></p>
<p><img src="/2024/07/05/csapp/image-20240701213913835.png" alt="image-20240701213913835"></p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/2024/07/05/csapp/image-20240701215250961.png" alt="image-20240701215250961"></p>
<p><img src="/2024/07/05/csapp/image-20240701215411425.png" alt="image-20240701215411425"></p>
<p><img src="/2024/07/05/csapp/image-20240701215532824.png" alt="image-20240701215532824"></p>
<p><img src="/2024/07/05/csapp/image-20240701215734067.png" alt="image-20240701215734067"></p>
<p><img src="/2024/07/05/csapp/image-20240701215825849.png" alt="image-20240701215825849"></p>
<p><img src="/2024/07/05/csapp/image-20240701220116450.png" alt="image-20240701220116450"></p>
<p><img src="/2024/07/05/csapp/image-20240701220126617.png" alt="image-20240701220126617"></p>
<p><img src="/2024/07/05/csapp/image-20240701220137656.png" alt="image-20240701220137656"></p>
<p><img src="/2024/07/05/csapp/image-20240701220258050.png" alt="image-20240701220258050"></p>
<p><img src="/2024/07/05/csapp/image-20240701220311488.png" alt="image-20240701220311488"></p>
<p><img src="/2024/07/05/csapp/image-20240701220336591.png" alt="image-20240701220336591"></p>
<p><img src="/2024/07/05/csapp/image-20240701220429050.png" alt="image-20240701220429050"></p>
<p><img src="/2024/07/05/csapp/image-20240701220527191.png" alt="image-20240701220527191"></p>
<p><img src="/2024/07/05/csapp/image-20240701220632256.png" alt="image-20240701220632256"></p>
<p><img src="/2024/07/05/csapp/image-20240701220652325.png" alt="image-20240701220652325"></p>
<p><img src="/2024/07/05/csapp/image-20240701220705254.png" alt="image-20240701220705254"></p>
<p><img src="/2024/07/05/csapp/image-20240701221126769.png" alt="image-20240701221126769"></p>
<p><img src="/2024/07/05/csapp/image-20240701221218263.png" alt="image-20240701221218263"></p>
<p><img src="/2024/07/05/csapp/image-20240701221209603.png" alt="image-20240701221209603"></p>
<p><img src="/2024/07/05/csapp/image-20240701221245255.png" alt="image-20240701221245255"></p>
<p><img src="/2024/07/05/csapp/image-20240701221413712.png" alt="image-20240701221413712"></p>
<p><img src="/2024/07/05/csapp/image-20240701221445932.png" alt="image-20240701221445932"></p>
<h2 id="高级概念"><a href="#高级概念" class="headerlink" title="高级概念"></a>高级概念</h2><h3 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h3><p><img src="/2024/07/05/csapp/image-20240701222744422.png" alt="image-20240701222744422"></p>
<p><img src="/2024/07/05/csapp/image-20240701222857308.png" alt="image-20240701222857308"></p>
<p><img src="/2024/07/05/csapp/image-20240701222930510.png" alt="image-20240701222930510"></p>
<p><img src="/2024/07/05/csapp/image-20240701222951641.png" alt="image-20240701222951641"></p>
<p><img src="/2024/07/05/csapp/image-20240701223023701.png" alt="image-20240701223023701"></p>
<p><img src="/2024/07/05/csapp/image-20240701223217289.png" alt="image-20240701223217289"></p>
<h3 id="分离空闲链表"><a href="#分离空闲链表" class="headerlink" title="分离空闲链表"></a>分离空闲链表</h3><p><img src="/2024/07/05/csapp/image-20240701223303514.png" alt="image-20240701223303514"></p>
<p><img src="/2024/07/05/csapp/image-20240701223540733.png" alt="image-20240701223540733"></p>
<p><img src="/2024/07/05/csapp/image-20240701223550670.png" alt="image-20240701223550670"></p>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p><img src="/2024/07/05/csapp/image-20240701223835382.png" alt="image-20240701223835382"></p>
<p><img src="/2024/07/05/csapp/image-20240701223920204.png" alt="image-20240701223920204"></p>
<p><img src="/2024/07/05/csapp/image-20240701223940709.png" alt="image-20240701223940709"></p>
<p><img src="/2024/07/05/csapp/image-20240701224013235.png" alt="image-20240701224013235"></p>
<p><img src="/2024/07/05/csapp/image-20240701224117241.png" alt="image-20240701224117241"></p>
<p><img src="/2024/07/05/csapp/image-20240701224214330.png" alt="image-20240701224214330"></p>
<h3 id="内存相关风险"><a href="#内存相关风险" class="headerlink" title="内存相关风险"></a>内存相关风险</h3><p><img src="/2024/07/05/csapp/image-20240701224252768.png" alt="image-20240701224252768"></p>
<h1 id="系统级IO"><a href="#系统级IO" class="headerlink" title="系统级IO"></a>系统级IO</h1><h2 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p><img src="/2024/07/05/csapp/image-20240701224616595.png" alt="image-20240701224616595"></p>
<p><img src="/2024/07/05/csapp/image-20240701224705416.png" alt="image-20240701224705416"></p>
<p><img src="/2024/07/05/csapp/image-20240701224728445.png" alt="image-20240701224728445"></p>
<p><img src="/2024/07/05/csapp/image-20240701224842783.png" alt="image-20240701224842783"></p>
<p><img src="/2024/07/05/csapp/image-20240701224905732.png" alt="image-20240701224905732"></p>
<p><img src="/2024/07/05/csapp/image-20240701224923019.png" alt="image-20240701224923019"></p>
<p><img src="/2024/07/05/csapp/image-20240701224935827.png" alt="image-20240701224935827"></p>
<p><img src="/2024/07/05/csapp/image-20240701225212610.png" alt="image-20240701225212610"></p>
<p><img src="/2024/07/05/csapp/image-20240701225224047.png" alt="image-20240701225224047"></p>
<p><img src="/2024/07/05/csapp/image-20240701225243365.png" alt="image-20240701225243365"></p>
<p><img src="/2024/07/05/csapp/image-20240701225253867.png" alt="image-20240701225253867"></p>
<p><img src="/2024/07/05/csapp/image-20240701225309429.png" alt="image-20240701225309429"></p>
<h2 id="RIO包"><a href="#RIO包" class="headerlink" title="RIO包"></a>RIO包</h2><p><img src="/2024/07/05/csapp/image-20240701225444810.png" alt="image-20240701225444810"></p>
<p><img src="/2024/07/05/csapp/image-20240701225457477.png" alt="image-20240701225457477"></p>
<p><img src="/2024/07/05/csapp/image-20240701225509309.png" alt="image-20240701225509309"></p>
<p><img src="/2024/07/05/csapp/image-20240701225525914.png" alt="image-20240701225525914"></p>
<h2 id="读取文件元数据，共享和重定位"><a href="#读取文件元数据，共享和重定位" class="headerlink" title="读取文件元数据，共享和重定位"></a>读取文件元数据，共享和重定位</h2><p><img src="/2024/07/05/csapp/image-20240701225638863.png" alt="image-20240701225638863"></p>
<p><img src="/2024/07/05/csapp/image-20240701230745789.png" alt="image-20240701230745789"></p>
<p><img src="/2024/07/05/csapp/image-20240701231003886.png" alt="image-20240701231003886"></p>
<p><img src="/2024/07/05/csapp/image-20240701231028158.png" alt="image-20240701231028158"></p>
<p><img src="/2024/07/05/csapp/image-20240701231100947.png" alt="image-20240701231100947"></p>
<p><img src="/2024/07/05/csapp/image-20240701231131628.png" alt="image-20240701231131628"></p>
<p><img src="/2024/07/05/csapp/image-20240701231217074.png" alt="image-20240701231217074"></p>
<h2 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h2><p><img src="/2024/07/05/csapp/image-20240701231258600.png" alt="image-20240701231258600"></p>
<p><img src="/2024/07/05/csapp/image-20240701231309548.png" alt="image-20240701231309548"></p>
<p><img src="/2024/07/05/csapp/image-20240701231332860.png" alt="image-20240701231332860"></p>
<p><img src="/2024/07/05/csapp/image-20240701231344798.png" alt="image-20240701231344798"></p>
<p><img src="/2024/07/05/csapp/image-20240701231424516.png" alt="image-20240701231424516"></p>
<p>666</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p><img src="/2024/07/05/csapp/image-20240701231457387.png" alt="image-20240701231457387"></p>
<p><img src="/2024/07/05/csapp/image-20240701231506057.png" alt="image-20240701231506057"></p>
<p><img src="/2024/07/05/csapp/image-20240701231515701.png" alt="image-20240701231515701"></p>
]]></content>
  </entry>
  <entry>
    <title>数据库原理</title>
    <url>/2023/11/26/database/</url>
    <content><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章  绪论"></a>第一章  绪论</h1><p>可以看到，选择题主要考了一下几个概念：</p>
<ol>
<li><p>基于文件系统的管理方法</p>
<p>数据存储于文件中，由应用程序经过文件系统进行管理。</p>
<p>缺点：</p>
<ol>
<li><p>每当文件格式发生变化，就要修改应用程序</p>
</li>
<li><p>文件中存在<strong>冗余</strong>数据</p>
</li>
<li><p>文件修改中可能造成<strong>数据不一致</strong></p>
</li>
<li><p>文件修改可能破坏<strong>数据正确性</strong></p>
</li>
<li><p>没有<strong>索引</strong>，数据访问效率低</p>
</li>
<li><p>只能对<strong>整个文件</strong>进行<strong>访问控制</strong>，数据安全性差【这点确实说得很好】</p>
</li>
<li><p>没有<strong>并发控制</strong>，多个应用程序同时读写文件可能发生冲突</p>
</li>
</ol>
</li>
<li><p>数据库系统包括：数据库、数据库管理系统、数据库应用程序、数据库管理员、计算机与网络基本系统</p>
<p><img src="/2023/11/26/database/image-20231121123536384-1700982197120-1.png" alt="image-20231121123536384"></p>
</li>
<li><p>数据库管理系统：通过数据库语言让用户操作进而提供数据库定义、数据库操纵和数据库控制功能的系统，同时提供了一系列程序能够实现对数据库的各种存储与维护</p>
</li>
<li><p>用户角度，数据库管理系统包括：数据库定义/操纵/控制/维护</p>
</li>
<li><p>模式相关</p>
<p>主要是“三级模式两层映像”结构。</p>
<p>三级模式：</p>
<ol>
<li>用户模式 = 外模式 = 局部模式 =？子模式</li>
<li>概念模式 = 逻辑模式 = 全局模式</li>
<li>物理模式 = 内模式 = 存储模式</li>
</ol>
<p>“模式”默认指概念模式。</p>
<p>两层映像：</p>
<ol>
<li>外模式到概念模式的映像实现了数据的<strong>逻辑独立性</strong></li>
<li>概念模式到内模式的映像实现了数据的<strong>物理独立性</strong></li>
</ol>
<p>数据库系统的数据独立性是指不会因为<u>系统数据存储结构与数据逻辑结构的变化而影响应用程序</u>。</p>
<p><strong>抽象程度：数据模型 &gt; 模式 &gt; 视图【关系模型 - 表结构 - 表数据】</strong></p>
</li>
<li><p>数据模型</p>
<p>重点记各个模型的优缺点。。。</p>
<ol>
<li>层次模型<ol>
<li>优点<ol>
<li>数据结构简单清晰</li>
<li>查询效率高，记录联系指针实现</li>
<li>性能&gt;关系数据库，&lt;=网状数据库</li>
</ol>
</li>
<li>缺点<ol>
<li>现实中很多联系是非层次性的</li>
<li>查询子女必须经过双亲，结构严密，层次命令趋于程序化（这个怎么你了）</li>
</ol>
</li>
</ol>
</li>
<li>网状模型<ol>
<li>优点<ol>
<li>直观</li>
<li>性能好，存取效率高</li>
</ol>
</li>
<li>缺点<ol>
<li>结构复杂</li>
<li>DDL和数据管理语言复杂</li>
<li>应用程序编写困难，联系通过存取路径实现</li>
</ol>
</li>
</ol>
</li>
<li>对象-关系数据库<ol>
<li>可有效支持不满足关系第一范式的数据项</li>
<li>以对象形式封装数据项</li>
<li>行对象与列对象；聚集对象与结构对象</li>
</ol>
</li>
</ol>
</li>
<li><p>发展史</p>
<p>第一代数据库系统是指基于网状模型或层次模型的数据库系统。</p>
<p>第二代数据库系统是指基于关系模型的数据库系统。</p>
</li>
</ol>
<h1 id="第二章-关系代数"><a href="#第二章-关系代数" class="headerlink" title="第二章 关系代数"></a>第二章 关系代数</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ol>
<li><p>表/关系，列/属性，行/元组</p>
</li>
<li><p>列的取值范围成为域</p>
<p><img src="/2023/11/26/database/image-20231109195637757.png" alt="image"></p>
</li>
<li><p>元组定义——域的笛卡尔积元素</p>
<p><img src="/2023/11/26/database/image-20231109195437913.png" alt="image"></p>
</li>
<li><p>关系的定义</p>
<p><img src="/2023/11/26/database/image-20231109195514991.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109195613406.png" alt="image"></p>
</li>
<li><p><strong>关系模式相当于表结构，关系就是在表结构的基础上填数据</strong></p>
</li>
<li><p>关系的特性</p>
<p><img src="/2023/11/26/database/image-20231121124828337.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109200020572.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109200035038.png" alt="image"></p>
</li>
<li><p>码</p>
<p><img src="/2023/11/26/database/image-20231109200106492.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109200126332.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109200157646.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109200219924.png" alt="image"></p>
<p>超码：包含候选码的集合</p>
<p><img src="/2023/11/26/database/image-20231109200405923.png" alt="image"></p>
</li>
</ol>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p><img src="/2023/11/26/database/image-20231109200456953.png" alt="image-20231109200456953"></p>
<h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><h5 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h5><p>主码不能为空</p>
<h5 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h5><p>外键属性值要么为空，要么为对方的主码值</p>
<h5 id="用户自定义的完整性"><a href="#用户自定义的完整性" class="headerlink" title="用户自定义的完整性"></a>用户自定义的完整性</h5><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p>关系代数结果是一个新的关系。</p>
<p><img src="/2023/11/26/database/image-20231109200834107.png" alt="image"></p>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><p>集合运算（除了笛卡尔积）需满足<strong>并相容性</strong>。</p>
<p><img src="/2023/11/26/database/image-20231109200953412.png" alt="image"></p>
<h4 id="并"><a href="#并" class="headerlink" title="并"></a>并</h4><p>记得去重</p>
<h4 id="差"><a href="#差" class="headerlink" title="差"></a>差</h4><p>R-S：出现在R中但不在S中</p>
<h4 id="交"><a href="#交" class="headerlink" title="交"></a>交</h4><h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p><img src="/2023/11/26/database/image-20231109201241065.png" alt="image"></p>
<h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>选择的是元组</p>
<p><img src="/2023/11/26/database/image-20231109202046281.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109202346027.png" alt="image"></p>
<p>这还能非</p>
<p><img src="/2023/11/26/database/image-20231109202442726.png" alt="image-20231109202442726"></p>
<p>注意且和或的优先级</p>
<h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>选择的是列，记得<strong>去重</strong></p>
<p><img src="/2023/11/26/database/image-20231109202614947.png" alt="image"></p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><h5 id="seta-连接"><a href="#seta-连接" class="headerlink" title="seta-连接"></a>seta-连接</h5><p>带条件的</p>
<p><img src="/2023/11/26/database/image-20231109202913382.png" alt="image"></p>
<h5 id="与自身连接"><a href="#与自身连接" class="headerlink" title="与自身连接"></a>与自身连接</h5><p>用ρ更名</p>
<p><img src="/2023/11/26/database/image-20231109203359159.png" alt="image"></p>
<h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><p>还是得带条件，指明要哪两个属性相等</p>
<p><img src="/2023/11/26/database/image-20231109203621403.png" alt="image"></p>
<p>值得注意的是，最后<strong>B和H两列都会保留</strong></p>
<p><img src="/2023/11/26/database/image-20231121130151846.png" alt="image"></p>
<h5 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h5><p>值得注意的是，会选取所有相同的<strong>属性组</strong>，<strong>把它们合成同一个属性列</strong>！</p>
<p>【也只有自然连接会做这个合并操作了，别的都是会保留两个列】</p>
<p><img src="/2023/11/26/database/image-20231109203757731.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231121130248222.png" alt="image"></p>
<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>常用于求解“查询全部的/所有的”问题。</p>
<p><strong>R ÷ S = B，B × S的所有元组都在R中。</strong></p>
<p><img src="/2023/11/26/database/image-20231109210237641.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109210440538.png" alt="image"></p>
<p>注意是要每一个元组</p>
<p><img src="/2023/11/26/database/image-20231109211009353.png" alt="image"></p>
<p>除法一般用于带有“全部”“所有”类似字样的题目中</p>
<p><img src="/2023/11/26/database/image-20231121151331409.png" alt="image-20231121151331409"></p>
<p>TODO：抓人对个答案</p>
<p><img src="/2023/11/26/database/IMG_20231121_151752.jpg" alt="image"></p>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>emmm就是不知道什么时候需要用外连接呢？题目会显式说明吗</p>
<p><img src="/2023/11/26/database/image-20231109215008447.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109215026710.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109215056255.png" alt="image"></p>
<h1 id="第三章-SQL语言"><a href="#第三章-SQL语言" class="headerlink" title="第三章 SQL语言"></a>第三章 SQL语言</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2023/11/26/database/image-20231109220809335.png" alt="image"></p>
<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ol>
<li><p>create database canteen;</p>
</li>
<li><p>create table</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dish(</span><br><span class="line">   dish_id              int not null,</span><br><span class="line">   dish_intro           varchar(128),</span><br><span class="line">   dish_price           numeric(4,1) not null,</span><br><span class="line">   primary key (dish_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/26/database/image-20231109220936927.png" alt="image"></p>
<p>这个类型估计得背</p>
<p><img src="/2023/11/26/database/image-20231109221007704.png" alt="image"></p>
</li>
</ol>
<h4 id="撤销与修改"><a href="#撤销与修改" class="headerlink" title="撤销与修改"></a>撤销与修改</h4><ol>
<li><p>drop table student;</p>
</li>
<li><p>alter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table cmt add constraint FK_CMT_ORDER_COM_ORDERS foreign key (order_id)</span><br><span class="line">      references orders (order_id) on delete restrict on update restrict;</span><br><span class="line">      </span><br><span class="line">alter table cmt </span><br><span class="line">      drop foreign key FK_CMT_ORDER_COM_ORDERS;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/26/database/image-20231111014015615.png" alt="image"></p>
</li>
</ol>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h5 id="基操"><a href="#基操" class="headerlink" title="基操"></a>基操</h5><ol>
<li><p>基操</p>
<p>注意逻辑运算符、运算优先级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select Tname</span><br><span class="line">from Teacher</span><br><span class="line">where (Salary &lt; 1500 or Salary &gt; 2000) and D# = &#x27;03&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>distinct</p>
<p><strong>关系模型的投影和选择结果自动去重</strong>，但是DBMS<strong>允许重复元组</strong>，所以结果<strong>不会</strong>自动去重。</p>
<p>关系的无重复元组<strong>通过主键和唯一性约束保证</strong>，检索结果的无重复元组<strong>通过DISTINCT</strong>保留字保证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select DISTINCT S#</span><br><span class="line">from SC</span><br><span class="line">where Score &gt; 80;</span><br></pre></td></tr></table></figure></li>
<li><p>order by</p>
<p>通过order by对检索结果降序/升序排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select S#, Sname</span><br><span class="line">from Student</span><br><span class="line">Order by S# ASC/DESC;</span><br></pre></td></tr></table></figure></li>
<li><p>like</p>
<p>后接类正则表达式</p>
<p><img src="/2023/11/26/database/image-20231121142004671.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 所有姓张学生</span><br><span class="line">select S#, Sname </span><br><span class="line">from Student</span><br><span class="line">where Sname like &quot;张%&quot;</span><br><span class="line"></span><br><span class="line">-- 所有不姓张学生</span><br><span class="line">select S#, Sname </span><br><span class="line">from Student</span><br><span class="line">where Sname not like &quot;张%&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>多表查询</p>
<p>通过在WHERE中写连接条件来实现。</p>
<p><img src="/2023/11/26/database/image-20231121142256057.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select Sname</span><br><span class="line">from Student (as) stu, SC, Course</span><br><span class="line">where stu.S# = SC.S# and SC.C# = Course.C# and Cname = &#x27;数据库&#x27;</span><br><span class="line">order by Score DESC;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><ol>
<li><p>IN</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student</span><br><span class="line">where Sname in (&quot;张三&quot;, &quot;王三&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/2023/11/26/database/image-20231109230840372.png" alt="image"></p>
<ol start="2">
<li><p>相关子查询</p>
<p><img src="/2023/11/26/database/image-20231121144220622.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231121144254821.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select Sname from Student S</span><br><span class="line">where `S#` in (</span><br><span class="line">	select `S#` from SC</span><br><span class="line">    where S.S# = SC.S# and `C#` = &#x27;001&#x27;</span><br><span class="line">	);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以这么理解，<strong>非相关子查询相当于复杂度On</strong>，先计算出子查询的结果，然后再遍历父查询元组看看是否符合条件；<strong>相关子查询相当于复杂度On方</strong>，需要把父循环变量i代进子循环j中。</p>
<ol start="3">
<li><p>SOME/ALL谓词</p>
<p><img src="/2023/11/26/database/image-20231109231255454.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231121144628369.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select Tname from Teacher</span><br><span class="line">where Salary &lt;= all (</span><br><span class="line">	select Salary from Teacher</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/26/database/image-20231109232924888.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109233209020.png" alt="image"></p>
<p>这个确实得注意，一看就很坑爹</p>
</li>
<li><p>exists</p>
<p><img src="/2023/11/26/database/image-20231121145845264.png" alt="image"></p>
<p>意思就是看看子查询结果中有没有元组，有则成立，无则不成立。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select DISTINCT Sname from Student</span><br><span class="line">where exists (</span><br><span class="line">	select * </span><br><span class="line">    from SC, Course, Teacher</span><br><span class="line">    where SC.C# = Course.C# and Course.T# = Teacher.T#</span><br><span class="line">    	and SC.S# = Student.S#	# 这个值得注意！</span><br><span class="line">    	and Teacher.Tname = &quot;李明&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>关系代数的除法模型可以用exists来实现。做出来一题，之后的就可以类比了。</p>
<p><img src="/2023/11/26/database/image-20231109234204566.png" alt="image"></p>
</li>
</ol>
<p><img src="/2023/11/26/database/image-20231109234243468.png" alt="image"></p>
<h5 id="结果计算与聚集函数"><a href="#结果计算与聚集函数" class="headerlink" title="结果计算与聚集函数"></a>结果计算与聚集函数</h5><p><img src="/2023/11/26/database/image-20231121215822395.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select T1.Tname as TR1, T2.Tname as TR2, T1.Salary - T2.Salary as Salary_Diff</span><br><span class="line">from Teacher T1, Teacher T2</span><br><span class="line">where T1.Salary &gt; T2.Salary;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/26/database/image-20231109234407853.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231109234423901.png" alt="image"></p>
<h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h5><h6 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h6><p><img src="/2023/11/26/database/image-20231109234509235.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 求每一门课程的平均成绩</span><br><span class="line">select Course.Cname, AVG(Score) as avg_score</span><br><span class="line">from SC, Course</span><br><span class="line">where SC.C# = Course.C#</span><br><span class="line">group by `C#`;</span><br><span class="line"></span><br><span class="line"># 求每一个学生的平均成绩</span><br><span class="line">select `S#`, AVG(Score) as avg_score</span><br><span class="line">from SC</span><br><span class="line">group by `S#`;</span><br></pre></td></tr></table></figure>

<p>使用了group by之后，聚合函数的对象就会自动变成分组，而非整个表了。</p>
<h6 id="having"><a href="#having" class="headerlink" title="having"></a>having</h6><p><img src="/2023/11/26/database/image-20231111012216860.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111012237853.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111012316446.png" alt="image"></p>
<p>可以看到，我们可以对一个group by分组内通过having来使用聚合函数。</p>
<p><img src="/2023/11/26/database/image-20231121220428247.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231121220551795.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select `S#`, AVG(Score) from SC</span><br><span class="line">where `S#` in ( # 找出两门以上不及格课程的同学</span><br><span class="line">	select `S#` from SC</span><br><span class="line">    where Score &lt; 60</span><br><span class="line">    group by `S#` having Count(*) &gt; 2</span><br><span class="line">)</span><br><span class="line">group by `S#`; # 才对它求average</span><br></pre></td></tr></table></figure>

<h5 id="并交差"><a href="#并交差" class="headerlink" title="并交差"></a>并交差</h5><p><img src="/2023/11/26/database/image-20231111012533896.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231121221445287.png" alt="image"></p>
<h5 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h5><p><img src="/2023/11/26/database/image-20231111012929784.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111012955593.png" alt="image"></p>
<h5 id="内连接与外连接"><a href="#内连接与外连接" class="headerlink" title="内连接与外连接"></a>内连接与外连接</h5><p><img src="/2023/11/26/database/image-20231111013032299.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111013154276.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111013347377.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231121221816452.png" alt="image-20231121221816452"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from Teacher left outer join Course natural</span><br><span class="line">order by `T#` ASC;</span><br></pre></td></tr></table></figure>



<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>这几个都是：</p>
<ol>
<li><p>where省略更新所有</p>
</li>
<li><p>不符合用户定义的完整性约束就不执行</p>
<p><img src="/2023/11/26/database/image-20231121222750111.png" alt="image-20231121222750111"></p>
</li>
</ol>
<h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><p><img src="/2023/11/26/database/image-20231111013525250.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into Student</span><br><span class="line">values (&#x27;1111&#x27;, &#x27;哈哈&#x27;, &#x27;男&#x27;, 20, &#x27;03&#x27;, &#x27;919324&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/26/database/image-20231121222615336.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into St</span><br><span class="line">	select `S#`, Sname, AVG(Score)</span><br><span class="line">	from SC, Student</span><br><span class="line">	where SC.S# = Student.S#</span><br><span class="line">	group by Student.`S#`</span><br></pre></td></tr></table></figure>

<h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p><img src="/2023/11/26/database/image-20231111013618088.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231121222824895.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from SC where `S#` = &#x27;34556578&#x27;;</span><br><span class="line"></span><br><span class="line">delete from Student where `D#` in</span><br><span class="line">	(select `D#` from Dept where Dname = &quot;自动控制&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/26/database/image-20231121223059620.png" alt="image"></p>
<h5 id="update"><a href="#update" class="headerlink" title="update"></a>update</h5><p><img src="/2023/11/26/database/image-20231121223128938.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231121223139369.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update Teacher set Salary = Salary * 1.05;</span><br><span class="line"></span><br><span class="line">update Teacher</span><br><span class="line">set Salary = Salary * 1.1</span><br><span class="line">where `D#` in</span><br><span class="line">	(select `D#` from Dept where Dname = &#x27;计算机&#x27;);</span><br></pre></td></tr></table></figure>

<h5 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h5><p><img src="/2023/11/26/database/image-20231121224230727.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231121224345581.png" alt="image"></p>
<h5 id="alter"><a href="#alter" class="headerlink" title="alter"></a>alter</h5><p><img src="/2023/11/26/database/image-20231121224312950.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231121224329749.png" alt="image"></p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>基本表和视图的概念可以了解一下</p>
<p><img src="/2023/11/26/database/image-20231111014301942.png" alt="image"></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="/2023/11/26/database/image-20231111014355319.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111014424107.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view CompStud as( 	</span><br><span class="line">    select * from Student</span><br><span class="line">    where `D#` in (select `D#` from dept where Dname = &#x27;计算机&#x27;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create view Teach as(</span><br><span class="line">	select T.Tname, C,Cname, Credit</span><br><span class="line">    from Teacher T, Course C</span><br><span class="line">    where T.T# = C.C#</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/26/database/image-20231121234202656.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view StudStat(`S#`, Sname, AvgS, MinS, MaxS, CNT) as (</span><br><span class="line">	select `S#`, Sname, AVG(Score), MIN(Score), MAX(Score), Count(*)</span><br><span class="line">    from Student S, SC where S.S# = SC.S#</span><br><span class="line">    group by S.S#</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/26/database/image-20231121234145286.png" alt="image"></p>
<h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><p><img src="/2023/11/26/database/image-20231111014546929.png" alt="image"></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img src="/2023/11/26/database/image-20231111014613344.png" alt="image"></p>
<h1 id="第四章-数据库的安全性和完整性"><a href="#第四章-数据库的安全性和完整性" class="headerlink" title="第四章 数据库的安全性和完整性"></a>第四章 数据库的安全性和完整性</h1><h2 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>本课程中的完整性指的是语义完整性。</p>
<p><img src="/2023/11/26/database/image-20231111014723556.png" alt="image"></p>
<p><strong>用户定义完整性约束规则保障完整性</strong></p>
<p><img src="/2023/11/26/database/image-20231111014823002.png" alt="image"></p>
<h3 id="完整性约束-1"><a href="#完整性约束-1" class="headerlink" title="完整性约束"></a>完整性约束</h3><p><img src="/2023/11/26/database/image-20231111014855286.png" alt="image"></p>
<h4 id="按约束对象分类"><a href="#按约束对象分类" class="headerlink" title="按约束对象分类"></a>按约束对象分类</h4><ol>
<li><p>域完整性约束</p>
<p><img src="/2023/11/26/database/image-20231122010803741.png" alt="image"></p>
</li>
<li><p>关系完整性约束</p>
<p><img src="/2023/11/26/database/image-20231122010817456.png" alt="image"></p>
</li>
</ol>
<h4 id="按约束来源分类"><a href="#按约束来源分类" class="headerlink" title="按约束来源分类"></a>按约束来源分类</h4><ol>
<li><p>结构约束</p>
<p><img src="/2023/11/26/database/image-20231122010937095.png" alt="image"></p>
</li>
<li><p>内容约束</p>
<p><img src="/2023/11/26/database/image-20231122010950618.png" alt="image"></p>
</li>
</ol>
<h4 id="按约束状态分类"><a href="#按约束状态分类" class="headerlink" title="按约束状态分类"></a>按约束状态分类</h4><ol>
<li><p>静态约束</p>
<p><img src="/2023/11/26/database/image-20231122011109813.png" alt="image"></p>
</li>
<li><p>动态约束</p>
<p><img src="/2023/11/26/database/image-20231122011118787.png" alt="image"></p>
</li>
</ol>
<h3 id="sql中的约束"><a href="#sql中的约束" class="headerlink" title="sql中的约束"></a>sql中的约束</h3><p><img src="/2023/11/26/database/image-20231111015144785.png" alt="image"></p>
<p>触发器是动态约束这个说法真新奇</p>
<h4 id="静态约束"><a href="#静态约束" class="headerlink" title="静态约束"></a>静态约束</h4><p><img src="/2023/11/26/database/image-20231111015324897.png" alt="image"></p>
<h5 id="列约束"><a href="#列约束" class="headerlink" title="列约束"></a>列约束</h5><p><img src="/2023/11/26/database/image-20231111015428210.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111015512202.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table Student(`S#` char(8) not null unique, Sname char(10),</span><br><span class="line">			Ssex char(2) constraint ctssex check(Ssex = &#x27;男&#x27; or Ssex = &#x27;女&#x27;),</span><br><span class="line">            Sage integer check(Sage &gt;= 1 and Sage&lt;150),</span><br><span class="line">            `D#` char(2) references Dept(`D#`) on delete cascade,</span><br><span class="line">            Sclass char(6)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="表约束"><a href="#表约束" class="headerlink" title="表约束"></a>表约束</h5><p><img src="/2023/11/26/database/image-20231111015614160.png" alt="image"></p>
<p>可以看到，它是在表定义中处于跟属性定义同级的低位。</p>
<p><img src="/2023/11/26/database/image-20231111015703791.png" alt="image"></p>
<h5 id="撤销-追加"><a href="#撤销-追加" class="headerlink" title="撤销/追加"></a>撤销/追加</h5><p><img src="/2023/11/26/database/image-20231111015800368.png" alt="image"></p>
<h4 id="动态约束（触发器）"><a href="#动态约束（触发器）" class="headerlink" title="动态约束（触发器）"></a>动态约束（触发器）</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>具体的触发器代码写在when里的statement处</p>
<p><img src="/2023/11/26/database/image-20231111020035783.png" alt="image"></p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p><img src="/2023/11/26/database/image-20231111020152266.png" alt="image"></p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p><img src="/2023/11/26/database/image-20231111020344690.png" alt="image"></p>
<h3 id="自主安全性"><a href="#自主安全性" class="headerlink" title="自主安全性"></a>自主安全性</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p><img src="/2023/11/26/database/image-20231111020410876.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111020503479.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111020546406.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111020616230.png" alt="image"></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="存储矩阵"><a href="#存储矩阵" class="headerlink" title="存储矩阵"></a>存储矩阵</h5><p><img src="/2023/11/26/database/image-20231111020810822.png" alt="image"></p>
<h5 id="视图-1"><a href="#视图-1" class="headerlink" title="视图"></a>视图</h5><p>第二点值得注意，可能意思就是用户A只能读P#为它自己ID的存储，可见存储矩阵。</p>
<p><img src="/2023/11/26/database/image-20231111020846307.png" alt="image"></p>
<h4 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h4><h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h5><p><img src="/2023/11/26/database/image-20231111020939917.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231122015539538.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231122015621305.png" alt="image"></p>
<h5 id="收权"><a href="#收权" class="headerlink" title="收权"></a>收权</h5><p><img src="/2023/11/26/database/image-20231111021113614.png" alt="image"></p>
<h3 id="强制安全性"><a href="#强制安全性" class="headerlink" title="强制安全性"></a>强制安全性</h3><p><img src="/2023/11/26/database/image-20231111192308082.png" alt="image"></p>
<p>反正意思就是说：</p>
<ol>
<li>行列权限冲突，就算是高权限</li>
<li>可以读权限小于等于它的，写权限大于等于它的</li>
</ol>
<p><img src="/2023/11/26/database/image-20231111194055826.png" alt="image"></p>
<p>emmm，也就是说数据的机密性不能降级，只能升级？</p>
<p><img src="/2023/11/26/database/image-20231122015720593.png" alt="image"></p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>为啥这东西归在这里。。。</p>
<p><img src="/2023/11/26/database/image-20231111193132506.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111193207294.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111193224740.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231111193241833.png" alt="image"></p>
<p>66666666666666，这两个例子值得注意</p>
<p><img src="/2023/11/26/database/image-20231111193259298.png" alt="image"></p>
<h1 id="第五章-数据库设计和ER模型"><a href="#第五章-数据库设计和ER模型" class="headerlink" title="第五章 数据库设计和ER模型"></a>第五章 数据库设计和ER模型</h1><p>TODO，这章还没怎么看</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p><img src="/2023/11/26/database/image-20231113010401041.png" alt="image"></p>
<h2 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h2><p><strong>E-R模型：Entity-Relationship Model</strong></p>
<p>草，原来ER是这个意思</p>
<h3 id="实体-联系模型"><a href="#实体-联系模型" class="headerlink" title="实体-联系模型"></a>实体-联系模型</h3><p><img src="/2023/11/26/database/image-20231113010459243.png" alt="image"></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="/2023/11/26/database/image-20231113010629959.png" alt="image"></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><img src="/2023/11/26/database/image-20231113010701168.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113010749959.png" alt="image"></p>
<h4 id="码"><a href="#码" class="headerlink" title="码"></a>码</h4><p><img src="/2023/11/26/database/image-20231113010829126.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113010928446.png" alt="image"></p>
<p>蛤，不都是主码主键吗。。。。。。</p>
<h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><p><img src="/2023/11/26/database/image-20231113011019127.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113011036122.png" alt="image"></p>
<h5 id="一元联系"><a href="#一元联系" class="headerlink" title="一元联系"></a>一元联系</h5><p><img src="/2023/11/26/database/image-20231113011124300.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113011226270.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113011307326.png" alt="image"></p>
<p>我不造啊</p>
<h5 id="二元联系"><a href="#二元联系" class="headerlink" title="二元联系"></a>二元联系</h5><p><img src="/2023/11/26/database/image-20231113011337567.png" alt="image"></p>
<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><h5 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h5><p><img src="/2023/11/26/database/image-20231113011423171.png" alt="image"></p>
<h5 id="参与基数"><a href="#参与基数" class="headerlink" title="参与基数"></a>参与基数</h5><p><img src="/2023/11/26/database/image-20231113011827929.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113011931587.png" alt="image"></p>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><h4 id="Chen画法"><a href="#Chen画法" class="headerlink" title="Chen画法"></a>Chen画法</h4><p>尼玛，这个总不至于要背吧呃呃，应该大概看懂了差不多得了</p>
<p><img src="/2023/11/26/database/image-20231113012059764.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113012200327.png" alt="image"></p>
<p>还是这个比较阳间</p>
<p><img src="/2023/11/26/database/image-20231113012234387.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113012326072.png" alt="image"></p>
<p>还要尤其注意这张图，还他妈的不一样。。。</p>
<p><img src="/2023/11/26/database/image-20231113012426565.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113012452568.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113012505042.png" alt="image"></p>
<p>它那边还有个案例分析，我懒得看了，反正也是忘了。。。</p>
<h4 id="Crow’s-Foot"><a href="#Crow’s-Foot" class="headerlink" title="Crow’s Foot"></a>Crow’s Foot</h4><p>尼玛，这个阳间多了，上面那个是不是因为是中国人才介绍的，乌鱼子</p>
<p><img src="/2023/11/26/database/image-20231113012612518.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113012726559.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113012712524.png" alt="image"></p>
<p>1就是竖线，0就是圈圈，多就是开叉</p>
<p><img src="/2023/11/26/database/image-20231113012736223.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113012849587.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113012920654.png" alt="image"></p>
<p>也挺好理解，那边有个圈圈代表0</p>
<p><img src="/2023/11/26/database/image-20231113013000789.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113013045058.png" alt="image"></p>
<h3 id="ER图-gt-关系模式"><a href="#ER图-gt-关系模式" class="headerlink" title="ER图-&gt;关系模式"></a>ER图-&gt;关系模式</h3><p><img src="/2023/11/26/database/image-20231113013124582.png" alt="image"></p>
<h4 id="属性的转换"><a href="#属性的转换" class="headerlink" title="属性的转换"></a>属性的转换</h4><p><img src="/2023/11/26/database/image-20231113013154673.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113013226139.png" alt="image"></p>
<p>oh！原来是这样，确实这样减少了冗余</p>
<h4 id="联系的转换"><a href="#联系的转换" class="headerlink" title="联系的转换"></a>联系的转换</h4><p><img src="/2023/11/26/database/image-20231113013337455.png" alt="image"></p>
<p>确实也避免了大量空值，不过如果双方均部分参与，新关系是不是还得再多一列什么序号作为关键字？还是一个为空直接啥了，不大懂啊</p>
<p><img src="/2023/11/26/database/image-20231113013435709.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113013515583.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113013756973.png" alt="image"></p>
<h4 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h4><p><img src="/2023/11/26/database/image-20231113013849488.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113013956590.png" alt="image"></p>
<p>也就是说弱实体虽然有键，但是不够作为主键？什么鬼</p>
<p>这个箭头可以看出，弱实体完全参与联系，且为1:m关系。</p>
<h4 id="具化-泛化"><a href="#具化-泛化" class="headerlink" title="具化/泛化"></a>具化/泛化</h4><p><img src="/2023/11/26/database/image-20231113014230792.png" alt="image"></p>
<p>这个的意思就是person是对customer和employee的泛化，customer和employee是对person的具化。</p>
<h3 id="实体联系设计问题"><a href="#实体联系设计问题" class="headerlink" title="实体联系设计问题"></a>实体联系设计问题</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h5><p><img src="/2023/11/26/database/image-20231113014350739.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113014404705.png" alt="image"></p>
<h5 id="删除异常"><a href="#删除异常" class="headerlink" title="删除异常"></a>删除异常</h5><p><img src="/2023/11/26/database/image-20231113014444491.png" alt="image"></p>
<h4 id="设计准则"><a href="#设计准则" class="headerlink" title="设计准则"></a>设计准则</h4><p><img src="/2023/11/26/database/image-20231113014524064.png" alt="image"></p>
<h2 id="物理数据库"><a href="#物理数据库" class="headerlink" title="物理数据库"></a>物理数据库</h2><p><img src="/2023/11/26/database/image-20231113014638476.png" alt="image"></p>
<h1 id="第六章-数据库规范"><a href="#第六章-数据库规范" class="headerlink" title="第六章  数据库规范"></a>第六章  数据库规范</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><h4 id="函数依赖-1"><a href="#函数依赖-1" class="headerlink" title="函数依赖"></a>函数依赖</h4><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><p><img src="/2023/11/26/database/image-20231113211856809.png" alt="image"></p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><p><img src="/2023/11/26/database/image-20231113212058941.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113212140731.png" alt="image"></p>
<h4 id="部分-完全-传递依赖"><a href="#部分-完全-传递依赖" class="headerlink" title="部分/完全/传递依赖"></a>部分/完全/传递依赖</h4><h5 id="部分-完全"><a href="#部分-完全" class="headerlink" title="部分/完全"></a>部分/完全</h5><p><img src="/2023/11/26/database/image-20231113212231783.png" alt="image"></p>
<h5 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h5><p><img src="/2023/11/26/database/image-20231113212333058.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113212420802.png" alt="image"></p>
<h4 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h4><p><img src="/2023/11/26/database/image-20231113212459348.png" alt="image"></p>
<p>注意必须得是<strong>完全依赖</strong>，也就是说要满足<strong>极小性</strong>。</p>
<h2 id="公理系统"><a href="#公理系统" class="headerlink" title="公理系统"></a>公理系统</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><h4 id="逻辑蕴含"><a href="#逻辑蕴含" class="headerlink" title="逻辑蕴含"></a>逻辑蕴含</h4><p><img src="/2023/11/26/database/image-20231113212630097.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113212726856.png" alt="image"></p>
<h3 id="公理、定理"><a href="#公理、定理" class="headerlink" title="公理、定理"></a>公理、定理</h3><p><img src="/2023/11/26/database/image-20231113212849611.png" alt="image"></p>
<p>注意看我加的黑字批注。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>从而由此可以定义某个属性/属性组的闭包：</p>
<p><img src="/2023/11/26/database/image-20231113213213906.png" alt="image"></p>
<p>也即存放的是通过这个什么定理，从X开始可以导出的所有属性。</p>
<p><img src="/2023/11/26/database/image-20231113214310299.png" alt="image"></p>
<p>TODO，这个没懂</p>
<p>好像意思就是，如果F的闭包等于自身，那么它就是一个全函数依赖族。可以联想一下什么情况会闭包等于自身呢？感觉差不多就是消除了所有的传递依赖之类的。</p>
<p><img src="/2023/11/26/database/image-20231113214519838.png" alt="image"></p>
<h3 id="函数依赖集"><a href="#函数依赖集" class="headerlink" title="函数依赖集"></a>函数依赖集</h3><p>如果两个函数依赖的函数依赖完备集等价，则两个函数依赖等价。</p>
<p><img src="/2023/11/26/database/image-20231113214540305.png" alt="image"></p>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p><img src="/2023/11/26/database/image-20231113214602249.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113214841795.png" alt="image"></p>
<p>这个最小函数依赖注意一下，反正意思就是右边就一个，然后木有冗余依赖和冗余属性。</p>
<p><img src="/2023/11/26/database/image-20231113215013715.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231122153306160.png" alt="image"></p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p><img src="/2023/11/26/database/image-20231122153909431.png" alt="image"></p>
<h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p><img src="/2023/11/26/database/image-20231113215054699.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113215118293.png" alt="image"></p>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p><img src="/2023/11/26/database/image-20231113215147245.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113215200534.png" alt="image"></p>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p><img src="/2023/11/26/database/image-20231113215241582.png" alt="image"></p>
<p>消除了非主属性对主属性的传递依赖。</p>
<p>也就是说，最后的情况就是非主属性完全且非传递依赖于主属性</p>
<h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p><img src="/2023/11/26/database/image-20231113215556843.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113215721769.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231122153643590.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231122153705584.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231122153839955.png" alt="image"></p>
<h2 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h2><p><img src="/2023/11/26/database/image-20231113223249688.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231113223400726.png" alt="image"></p>
<p>沙比，说得那么曲折，反正意思就是，ρ是一个模式分解，然后如果对ρ里面每个属性进行投影，最后把这些结果连接起来，最后的东西就叫做这个mr，也即投影连接。【就是这个连接不知道是笛卡尔积还是什么玩意】</p>
<p><img src="/2023/11/26/database/image-20231113223851503.png" alt="image"></p>
<h3 id="无损连接分解"><a href="#无损连接分解" class="headerlink" title="无损连接分解"></a>无损连接分解</h3><p><img src="/2023/11/26/database/image-20231113223925420.png" alt="image"></p>
<h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><h4 id="无损分解BCNF"><a href="#无损分解BCNF" class="headerlink" title="无损分解BCNF"></a>无损分解BCNF</h4><h3 id="保持依赖分解"><a href="#保持依赖分解" class="headerlink" title="保持依赖分解"></a>保持依赖分解</h3><p><img src="/2023/11/26/database/image-20231113224430739.png" alt="image"></p>
<p>反正意思就是，F中的左部右部都在Ri这个属性的，这些式子能推导出F中其他式子，那么就叫保持依赖。</p>
<h4 id="判断方法-1"><a href="#判断方法-1" class="headerlink" title="判断方法"></a>判断方法</h4><h4 id="保持依赖分解3NF"><a href="#保持依赖分解3NF" class="headerlink" title="保持依赖分解3NF"></a>保持依赖分解3NF</h4><h4 id="又无损又保持依赖"><a href="#又无损又保持依赖" class="headerlink" title="又无损又保持依赖"></a>又无损又保持依赖</h4><h1 id="第七章-数据库物理存储"><a href="#第七章-数据库物理存储" class="headerlink" title="第七章  数据库物理存储"></a>第七章  数据库物理存储</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="存储体系"><a href="#存储体系" class="headerlink" title="存储体系"></a>存储体系</h3><p><img src="/2023/11/26/database/image-20231115132944815.png" alt="image"></p>
<h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p><img src="/2023/11/26/database/image-20231115133555203.png" alt="image"></p>
<p>圆盘-盘面-磁道-扇区</p>
<p><img src="/2023/11/26/database/image-20231115133655340.png" alt="image"></p>
<p>这个例子值得注意，<strong>不论一个文件多小，它都是占一个磁盘块</strong>。</p>
<p>一般情况下，一个磁盘块包含多个扇区。</p>
<h4 id="读写时间"><a href="#读写时间" class="headerlink" title="读写时间"></a>读写时间</h4><p><img src="/2023/11/26/database/image-20231115133929771.png" alt="image"></p>
<h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p><img src="/2023/11/26/database/image-20231115134119332.png" alt="image"></p>
<h2 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h2><h3 id="存储查询实现"><a href="#存储查询实现" class="headerlink" title="存储查询实现"></a>存储查询实现</h3><p><img src="/2023/11/26/database/image-20231115134323356.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115134454134.png" alt="image"></p>
<p>真感觉有必要写一下cmu15445</p>
<h3 id="与磁盘映射"><a href="#与磁盘映射" class="headerlink" title="与磁盘映射"></a>与磁盘映射</h3><p><img src="/2023/11/26/database/image-20231115134602408.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115134655136.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115134827256.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115134925277.png" alt="image"></p>
<h3 id="文件组织方法"><a href="#文件组织方法" class="headerlink" title="文件组织方法"></a>文件组织方法</h3><p><img src="/2023/11/26/database/image-20231115135034520.png" alt="image"></p>
<h4 id="无序"><a href="#无序" class="headerlink" title="无序"></a>无序</h4><p><img src="/2023/11/26/database/image-20231115135058681.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115135157120.png" alt="image"></p>
<h4 id="有序"><a href="#有序" class="headerlink" title="有序"></a>有序</h4><p><img src="/2023/11/26/database/image-20231115135315193.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115135345701.png" alt="image"></p>
<p>你也要GC是吧</p>
<h4 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h4><p><img src="/2023/11/26/database/image-20231115135428682.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115135521383.png" alt="image"></p>
<h4 id="聚簇文件"><a href="#聚簇文件" class="headerlink" title="聚簇文件"></a>聚簇文件</h4><p><img src="/2023/11/26/database/image-20231115135620701.png" alt="image"></p>
<h1 id="第八章-数据库索引"><a href="#第八章-数据库索引" class="headerlink" title="第八章  数据库索引"></a>第八章  数据库索引</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p><img src="/2023/11/26/database/image-20231115135854375.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115135930380.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115140030138.png" alt="image"></p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p><img src="/2023/11/26/database/image-20231115140225181.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115140257842.png" alt="image"></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>总之总结一下，其实大概就是稀疏索引和稠密索引。</p>
<p>然后：</p>
<ol>
<li><p>根据<strong>主属性</strong>排序的主文件+稀疏索引 = 主索引</p>
</li>
<li><p>根据<strong>某个属性</strong>排序的主文件+稀疏/稠密索引 = 聚簇索引【可以注意下跟主索引的差别】</p>
<p><img src="/2023/11/26/database/image-20231122204416032.png" alt="image"></p>
</li>
<li><p>根据<strong>非主属性</strong>排序的主文件+稠密索引 = 辅助索引</p>
</li>
<li><p>对某个非排序属性进行稠密索引 = 非聚簇索引</p>
</li>
</ol>
<p><img src="/2023/11/26/database/image-20231115141956215.png" alt="image-20231115141956215"></p>
<h3 id="稀疏与稠密"><a href="#稀疏与稠密" class="headerlink" title="稀疏与稠密"></a>稀疏与稠密</h3><p><img src="/2023/11/26/database/image-20231115140404429.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115140515180.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115140604736.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115140638660.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115140708009.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115140722861.png" alt="image"></p>
<p>还得是折中，加层</p>
<h3 id="主-辅助索引"><a href="#主-辅助索引" class="headerlink" title="主/辅助索引"></a>主/辅助索引</h3><p>这个就是我们dblab5干的</p>
<p><img src="/2023/11/26/database/image-20231115140928530.png" alt="image"></p>
<p>注意，它确实就引入了个链表，关注Downtown字段。</p>
<p><img src="/2023/11/26/database/image-20231115141010417.png" alt="image"></p>
<p>不用排序是因为相当于加了一层哈希了。</p>
<p><img src="/2023/11/26/database/image-20231115141331158.png" alt="image"></p>
<p>TODO，说实话那句话真没看懂</p>
<h3 id="聚簇-非聚簇"><a href="#聚簇-非聚簇" class="headerlink" title="聚簇/非聚簇"></a>聚簇/非聚簇</h3><p><img src="/2023/11/26/database/image-20231115141418904.png" alt="image"></p>
<p>上面那个是稀疏索引，相当于不是根据主码而是根据别的属性了</p>
<p><img src="/2023/11/26/database/image-20231115141910100.png" alt="image"></p>
<p>与主索引差别：</p>
<p><img src="/2023/11/26/database/image-20231115141922272.png" alt="image-20231115141922272"></p>
<p><img src="/2023/11/26/database/image-20231115141948107.png" alt="image"></p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p><img src="/2023/11/26/database/image-20231115142026440.png" alt="image"></p>
<p>这个算不算content-based hhh</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><img src="/2023/11/26/database/image-20231115142120497.png" alt="image"></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>TODO</p>
<h3 id="存储约定"><a href="#存储约定" class="headerlink" title="存储约定"></a>存储约定</h3><p><img src="/2023/11/26/database/image-20231115142159191.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115142217001.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115172301194.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115172425562.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115172510107.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115172532333.png" alt="image"></p>
<h3 id="建立不同索引"><a href="#建立不同索引" class="headerlink" title="建立不同索引"></a>建立不同索引</h3><h4 id="主键稠密"><a href="#主键稠密" class="headerlink" title="主键稠密"></a>主键稠密</h4><p><img src="/2023/11/26/database/image-20231115172830947.png" alt="image"></p>
<h4 id="主键稀疏"><a href="#主键稀疏" class="headerlink" title="主键稀疏"></a>主键稀疏</h4><p><img src="/2023/11/26/database/image-20231115172906059.png" alt="image"></p>
<h4 id="非键稠密"><a href="#非键稠密" class="headerlink" title="非键稠密"></a>非键稠密</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p><img src="/2023/11/26/database/image-20231115173121363.png" alt="image"></p>
<h5 id="不排序"><a href="#不排序" class="headerlink" title="不排序"></a>不排序</h5><p><img src="/2023/11/26/database/image-20231115173136033.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231115173207528.png" alt="image"></p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p><img src="/2023/11/26/database/image-20231115173603230.png" alt="image"></p>
<h3 id="插入删除"><a href="#插入删除" class="headerlink" title="插入删除"></a>插入删除</h3><p><img src="/2023/11/26/database/image-20231115173820682.png" alt="image"></p>
<p>这些就结合下cmu的跟ppt的算法复习一下吧，考前再说。</p>
<h2 id="散列-1"><a href="#散列-1" class="headerlink" title="散列"></a>散列</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><img src="/2023/11/26/database/image-20231116010611468.png" alt="image"></p>
<h3 id="散列索引"><a href="#散列索引" class="headerlink" title="散列索引"></a>散列索引</h3><p><img src="/2023/11/26/database/image-20231116010731538.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116010749789.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116010831995.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116010856907.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116010934162.png" alt="image"></p>
<h3 id="动态散列索引"><a href="#动态散列索引" class="headerlink" title="动态散列索引"></a>动态散列索引</h3><p><img src="/2023/11/26/database/image-20231122212544718.png" alt="image"></p>
<h4 id="可扩展散列索引"><a href="#可扩展散列索引" class="headerlink" title="可扩展散列索引"></a>可扩展散列索引</h4><p><img src="/2023/11/26/database/image-20231116011209676.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116011419364.png" alt="image"></p>
<p>注意，<strong>其它不变</strong>，每次只需重新散列涉及到的那个桶。此时00和01两个桶还是指向的0010这个快。</p>
<p><img src="/2023/11/26/database/image-20231116011505704.png" alt="image"></p>
<p>这时候i无需增加</p>
<p><img src="/2023/11/26/database/image-20231116011552196.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116011608595.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116011645585.png" alt="image"></p>
<h4 id="线性散列索引"><a href="#线性散列索引" class="headerlink" title="线性散列索引"></a>线性散列索引</h4><p><img src="/2023/11/26/database/image-20231116011904472.png" alt="image"></p>
<p>它这个意思应该是mask有log2n位，也即hash函数为k &amp; (2^log2n - 1)</p>
<p><img src="/2023/11/26/database/image-20231116012244325.png" alt="image"></p>
<p>也即把最高位改为0.</p>
<p><img src="/2023/11/26/database/image-20231116012302912.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116012316867.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116012333634.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116012347681.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116012400882.png" alt="image"></p>
<h1 id="第九章-数据库查询算法实现"><a href="#第九章-数据库查询算法实现" class="headerlink" title="第九章  数据库查询算法实现"></a>第九章  数据库查询算法实现</h1><h2 id="连接的实现"><a href="#连接的实现" class="headerlink" title="连接的实现"></a>连接的实现</h2><p><img src="/2023/11/26/database/image-20231122223551840.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116012707470.png" alt="image"></p>
<p>注意，主存每页容量等于一个磁盘块容量，此处做了简化感觉。</p>
<p><img src="/2023/11/26/database/image-20231116012743745.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116012826999.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116013059644.png" alt="image"></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>用于一元操作</p>
<p><img src="/2023/11/26/database/image-20231122223740337.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231122223825605.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231122223906478.png" alt="image"></p>
<h2 id="一趟扫描算法"><a href="#一趟扫描算法" class="headerlink" title="一趟扫描算法"></a>一趟扫描算法</h2><p><img src="/2023/11/26/database/image-20231116012640064.png" alt="image"></p>
<h3 id="一趟扫描"><a href="#一趟扫描" class="headerlink" title="一趟扫描"></a>一趟扫描</h3><p>没看懂</p>
<p><img src="/2023/11/26/database/image-20231116013431764.png" alt="image"></p>
<h3 id="基于索引"><a href="#基于索引" class="headerlink" title="基于索引"></a>基于索引</h3><p><img src="/2023/11/26/database/image-20231116013511895.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116013541689.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116013601971.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231116013618237.png" alt="image"></p>
<h2 id="两趟扫描"><a href="#两趟扫描" class="headerlink" title="两趟扫描"></a>两趟扫描</h2><h3 id="内外排序"><a href="#内外排序" class="headerlink" title="内外排序"></a>内外排序</h3><p><img src="/2023/11/26/database/image-20231119012808663.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119012834989.png" alt="image"></p>
<h3 id="两阶段多路归并排序TPMMS"><a href="#两阶段多路归并排序TPMMS" class="headerlink" title="两阶段多路归并排序TPMMS"></a>两阶段多路归并排序TPMMS</h3><p><img src="/2023/11/26/database/image-20231119012927069.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119012951384.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119013038924.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119013130221.png" alt="image"></p>
<p>干净一点的图：</p>
<p><img src="/2023/11/26/database/image-20231119013233922.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119013337946.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119013413380.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119013444525.png" alt="image"></p>
<p>可以画个树理解一下</p>
<h1 id="第十章-数据库查询优化技术"><a href="#第十章-数据库查询优化技术" class="headerlink" title="第十章  数据库查询优化技术"></a>第十章  数据库查询优化技术</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src="/2023/11/26/database/image-20231119013805179.png" alt="image"></p>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p><img src="/2023/11/26/database/image-20231119013920839.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119014421415.png" alt="image"></p>
<h3 id="语义优化"><a href="#语义优化" class="headerlink" title="语义优化"></a>语义优化</h3><p>也就是SQL语句层面的优化</p>
<p><img src="/2023/11/26/database/image-20231119014020926.png" alt="image"></p>
<h3 id="语法优化"><a href="#语法优化" class="headerlink" title="语法优化"></a>语法优化</h3><p>也就是关系运算层面的优化</p>
<p><img src="/2023/11/26/database/image-20231119014108270.png" alt="image"></p>
<p>6</p>
<p><img src="/2023/11/26/database/image-20231119014334329.png" alt="image"></p>
<h2 id="语法优化（逻辑层优化）"><a href="#语法优化（逻辑层优化）" class="headerlink" title="语法优化（逻辑层优化）"></a>语法优化（逻辑层优化）</h2><h3 id="示例背景"><a href="#示例背景" class="headerlink" title="示例背景"></a>示例背景</h3><p><img src="/2023/11/26/database/image-20231119014551414.png" alt="image"></p>
<h3 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h3><p><img src="/2023/11/26/database/image-20231119014849382.png" alt="image"></p>
<p>这个就相当于把XLOANS这个视图定义展开为语法树了</p>
<h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><p><img src="/2023/11/26/database/image-20231119015111213.png" alt="image"></p>
<p>人话：</p>
<ol>
<li>早做投影和选择</li>
<li>选择投影尽量挨在一起</li>
<li>没懂。。。</li>
<li>选择+笛卡尔积换成条件连接</li>
<li>预处理，如建立索引</li>
<li>找公共子表达式（如语法图）</li>
</ol>
<p><img src="/2023/11/26/database/image-20231119015334132.png" alt="image"></p>
<p>我服了，体会一下吧。</p>
<h2 id="关系代数操作次序交换的等价性"><a href="#关系代数操作次序交换的等价性" class="headerlink" title="关系代数操作次序交换的等价性"></a>关系代数操作次序交换的等价性</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p><img src="/2023/11/26/database/image-20231119015421114.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119015501977.png" alt="image"></p>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p><img src="/2023/11/26/database/image-20231119015636537.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119015742343.png" alt="image"></p>
<p>意思就是这个l3可以用来：</p>
<ol>
<li>两遍扫描-&gt;一遍扫描</li>
<li>拓展语法树，便于用之后其它定理化简</li>
</ol>
<p><img src="/2023/11/26/database/image-20231119020008946.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119020046524.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119020217677.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119020334738.png" alt="image"></p>
<p>这个也体现了，反向使用定理L3，然后再用L7这个组合技达到的优化效果</p>
<p><img src="/2023/11/26/database/image-20231119020537578.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119020720230.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119020808244.png" alt="image"></p>
<p>注意，投影和差是<strong>没有</strong>交换律的。</p>
<p>虽然都确实直观吧，但我感觉我服了。。。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>TODO</p>
<p>这个具体看PPT吧，还有它后面的例子，或者听下网课，感觉快死了。</p>
<p><img src="/2023/11/26/database/image-20231119020856546.png" alt="image"></p>
<h2 id="物理查询优化"><a href="#物理查询优化" class="headerlink" title="物理查询优化"></a>物理查询优化</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p><img src="/2023/11/26/database/image-20231119021044424.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119021145310.png" alt="image"></p>
<p>TODO，为啥非聚簇，用索引就得每个元组扫一遍？？？不是取决于索引表大小吗，我真服了</p>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><img src="/2023/11/26/database/image-20231119021321176.png" alt="image"></p>
<h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h3><h4 id="评估方案"><a href="#评估方案" class="headerlink" title="评估方案"></a>评估方案</h4><p><img src="/2023/11/26/database/image-20231119150057910.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119152230253.png" alt="image"></p>
<h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><p><img src="/2023/11/26/database/image-20231119152401771.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119152423660.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119152439551.png" alt="image"></p>
<h4 id="代价估算"><a href="#代价估算" class="headerlink" title="代价估算"></a>代价估算</h4><p><img src="/2023/11/26/database/image-20231119152546619.png" alt="image"></p>
<h5 id="投影-1"><a href="#投影-1" class="headerlink" title="投影"></a>投影</h5><p><img src="/2023/11/26/database/image-20231119152859873.png" alt="image"></p>
<h5 id="选择-1"><a href="#选择-1" class="headerlink" title="选择"></a>选择</h5><p><img src="/2023/11/26/database/image-20231119153300067.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119153440102.png" alt="image"></p>
<p>好吧，m和n也是这么估算的：</p>
<p><img src="/2023/11/26/database/image-20231119153527373.png" alt="image"></p>
<p>最后那个简单估计，是意思是复杂度主要由第二个条件决定吗？想想确实很直观。</p>
<h5 id="连接-1"><a href="#连接-1" class="headerlink" title="连接"></a>连接</h5><p><img src="/2023/11/26/database/image-20231119154954477.png" alt="image"></p>
<h5 id="简要结论"><a href="#简要结论" class="headerlink" title="简要结论"></a>简要结论</h5><p><img src="/2023/11/26/database/image-20231119155035281.png" alt="image"></p>
<h1 id="第十一章-数据库事务处理技术"><a href="#第十一章-数据库事务处理技术" class="headerlink" title="第十一章  数据库事务处理技术"></a>第十一章  数据库事务处理技术</h1><p>反正大概意思就是：</p>
<p><img src="/2023/11/26/database/image-20231119182623273.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119182635136.png" alt="image"></p>
<p>本章就是围绕这两个问题来的。</p>
<h2 id="不一致现象"><a href="#不一致现象" class="headerlink" title="不一致现象"></a>不一致现象</h2><p><img src="/2023/11/26/database/image-20231119155331420.png" alt="image"></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p><img src="/2023/11/26/database/image-20231119155547636.png" alt="image"></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><img src="/2023/11/26/database/image-20231119160029653.png" alt="image"></p>
<h4 id="宏观性"><a href="#宏观性" class="headerlink" title="宏观性"></a>宏观性</h4><p><img src="/2023/11/26/database/image-20231119155848115.png" alt="image"></p>
<h4 id="微观性"><a href="#微观性" class="headerlink" title="微观性"></a>微观性</h4><p><img src="/2023/11/26/database/image-20231119160001927.png" alt="image"></p>
<h3 id="特性：ACID"><a href="#特性：ACID" class="headerlink" title="特性：ACID"></a>特性：ACID</h3><p><img src="/2023/11/26/database/image-20231119160134524.png" alt="image"></p>
<h3 id="调度与可串行性"><a href="#调度与可串行性" class="headerlink" title="调度与可串行性"></a>调度与可串行性</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><img src="/2023/11/26/database/image-20231119160217938.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119160233528.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119160252158.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119160636318.png" alt="image"></p>
<p>图中最右错误，是因为这样的话B=B-20这个操作事实上就会被覆盖了。这两个事务不关心读的是不是B origin，只需要+10和-20操作都做了就行。</p>
<h4 id="事务模型"><a href="#事务模型" class="headerlink" title="事务模型"></a>事务模型</h4><p><img src="/2023/11/26/database/image-20231119181536555.png" alt="image"></p>
<h4 id="冲突与可串行性"><a href="#冲突与可串行性" class="headerlink" title="冲突与可串行性"></a>冲突与可串行性</h4><blockquote>
<p>强烈推荐：<a href="https://zhuanlan.zhihu.com/p/516557516">冲突可串行化、事务优先图</a>。PPT讲的不知道啥玩意</p>
</blockquote>
<blockquote>
<p>也就是说，如果一个schedule经过一系列对任意两个不冲突操作的调换动作后，可以变成一个完全串行的schedule，那么我们就称其为冲突可串行化。</p>
</blockquote>
<p><img src="/2023/11/26/database/image-20231119181654164.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119181749410.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119184216295.png" alt="image-20231119184216295"></p>
<p><img src="/2023/11/26/database/image-20231119184114564.png" alt="image-20231119184114564"></p>
<p><img src="/2023/11/26/database/v2-5a263633d1f4259956ad533927d0da75_1440w.webp" alt="image"></p>
<p>如果一个 schedule 和某个串行 schedule 冲突等价，则称该 schedule 是<strong>冲突可串行化（conflict serializable）</strong>的。</p>
<p><img src="/2023/11/26/database/image-20231119184602488.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119181901614.png" alt="image"></p>
<p>真不懂</p>
<p><img src="/2023/11/26/database/image-20231119181923979.png" alt="image"></p>
<h2 id="冲突可串行判别算法"><a href="#冲突可串行判别算法" class="headerlink" title="冲突可串行判别算法"></a>冲突可串行判别算法</h2><p><img src="/2023/11/26/database/image-20231119190122097.png" alt="image"></p>
<p>一种就是上面那个图片例子，一直交换直到得到串行调度；</p>
<p>另一种就是下面要介绍的这个画图了。</p>
<p>说实话真没懂这啥玩意冲突可串行</p>
<p><img src="/2023/11/26/database/image-20231119182129408.png" alt="image"></p>
<p>也没搞懂这灰线又tm哪来的。。。</p>
<p><img src="/2023/11/26/database/image-20231119182448346.png" alt="image"></p>
<h2 id="基于封锁的并发控制"><a href="#基于封锁的并发控制" class="headerlink" title="基于封锁的并发控制"></a>基于封锁的并发控制</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/11/26/database/image-20231119182722379.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119182748239.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119182825428.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119182902211.png" alt="image"></p>
<p>不满足</p>
<h3 id="考虑因素"><a href="#考虑因素" class="headerlink" title="考虑因素"></a>考虑因素</h3><h4 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h4><p><img src="/2023/11/26/database/image-20231119183008208.png" alt="image"></p>
<h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><p><img src="/2023/11/26/database/image-20231119183437646.png" alt="image"></p>
<h5 id="相容性矩阵"><a href="#相容性矩阵" class="headerlink" title="相容性矩阵"></a>相容性矩阵</h5><p><img src="/2023/11/26/database/image-20231119183052554.png" alt="image"></p>
<h5 id="加解锁时机"><a href="#加解锁时机" class="headerlink" title="加解锁时机"></a>加解锁时机</h5><p><img src="/2023/11/26/database/image-20231119183354649.png" alt="image"></p>
<h5 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h5><p><img src="/2023/11/26/database/image-20231119183424841.png" alt="image"></p>
<h3 id="两段封锁协议"><a href="#两段封锁协议" class="headerlink" title="两段封锁协议"></a>两段封锁协议</h3><p>两段封锁协议是一种基于锁的并发控制方法。</p>
<p><img src="/2023/11/26/database/image-20231119183734987.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119183809930.png" alt="image"></p>
<p>满足</p>
<p><img src="/2023/11/26/database/image-20231119190000255.png" alt="image"></p>
<p>注意这个两端锁与前面那个只用锁的差距。两段锁把B加锁也移到前面了，所以可以保证冲突可串行性。</p>
<p><img src="/2023/11/26/database/image-20231119184848690.png" alt="image"></p>
<p>读nm，不读再见</p>
<p>可以看到，图中确实是满足两段锁协议要求的，加锁段里确实没有解锁段。消除死锁的方式应该就是按照一定顺序获取锁。</p>
<p><img src="/2023/11/26/database/image-20231119185021920.png" alt="image"></p>
<h2 id="基于时间戳的并发控制方法"><a href="#基于时间戳的并发控制方法" class="headerlink" title="基于时间戳的并发控制方法"></a>基于时间戳的并发控制方法</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/11/26/database/image-20231119185219724.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119185313831.png" alt="image"></p>
<h3 id="简单的调度规则"><a href="#简单的调度规则" class="headerlink" title="简单的调度规则"></a>简单的调度规则</h3><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p><img src="/2023/11/26/database/image-20231119185426363.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119185809229.png" alt="image"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="/2023/11/26/database/image-20231119190647080.png" alt="image"></p>
<p>真没看懂为什么要撤回T2和T3</p>
<p><img src="/2023/11/26/database/image-20231119190713620.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119190722939.png" alt="image"></p>
<h4 id="冲突是否可串行"><a href="#冲突是否可串行" class="headerlink" title="冲突是否可串行"></a>冲突是否可串行</h4><p><img src="/2023/11/26/database/image-20231119190732156.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119190753184.png" alt="image"></p>
<h3 id="另一种调度规则"><a href="#另一种调度规则" class="headerlink" title="另一种调度规则"></a>另一种调度规则</h3><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p><img src="/2023/11/26/database/image-20231119190857194.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119190912445.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119190934097.png" alt="image"></p>
<p>也就是说U没有提交，所以T要更新的反而也丢了，变得更加过时（）</p>
<h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><p><img src="/2023/11/26/database/image-20231119191015552.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119191045159.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119191054856.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119191104080.png" alt="image"></p>
<h2 id="基于有效性确认的并发控制"><a href="#基于有效性确认的并发控制" class="headerlink" title="基于有效性确认的并发控制"></a>基于有效性确认的并发控制</h2><p><img src="/2023/11/26/database/image-20231119191209359.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119191232017.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119191239423.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119191248063.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119191258181.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119191307118.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119191316150.png" alt="image"></p>
<h1 id="第十二章-数据库事务恢复技术"><a href="#第十二章-数据库事务恢复技术" class="headerlink" title="第十二章  数据库事务恢复技术"></a>第十二章  数据库事务恢复技术</h1><h2 id="故障类型与影响"><a href="#故障类型与影响" class="headerlink" title="故障类型与影响"></a>故障类型与影响</h2><p><img src="/2023/11/26/database/image-20231119192002472.png" alt="image"></p>
<h2 id="恢复基本思路"><a href="#恢复基本思路" class="headerlink" title="恢复基本思路"></a>恢复基本思路</h2><p><img src="/2023/11/26/database/image-20231119192440160.png" alt="image"></p>
<h3 id="事务故障"><a href="#事务故障" class="headerlink" title="事务故障"></a>事务故障</h3><p><img src="/2023/11/26/database/image-20231119192026862.png" alt="image"></p>
<h3 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a>系统故障</h3><p><img src="/2023/11/26/database/image-20231119192052667.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119192116624.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119192149089.png" alt="image"></p>
<h3 id="介质故障"><a href="#介质故障" class="headerlink" title="介质故障"></a>介质故障</h3><p><img src="/2023/11/26/database/image-20231119192243058.png" alt="image"></p>
<p>冗余阵列</p>
<p><img src="/2023/11/26/database/image-20231119192428709.png" alt="image"></p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p><img src="/2023/11/26/database/image-20231119192539099.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119192914170.png" alt="image"></p>
<p>此时应该上层已经确保了事务的调度是冲突可串行化的，所以这里不用考虑会不会脏读问题。</p>
<p><img src="/2023/11/26/database/image-20231119193119271.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119193150204.png" alt="image"></p>
<h3 id="Undo型日志"><a href="#Undo型日志" class="headerlink" title="Undo型日志"></a>Undo型日志</h3><h4 id="记录规则"><a href="#记录规则" class="headerlink" title="记录规则"></a>记录规则</h4><p>这对应的应该是Steal</p>
<p><img src="/2023/11/26/database/image-20231119193328297.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119193341453.png" alt="image"></p>
<h4 id="恢复步骤"><a href="#恢复步骤" class="headerlink" title="恢复步骤"></a>恢复步骤</h4><p><img src="/2023/11/26/database/image-20231119195347779.png" alt="image"></p>
<h4 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h4><p><img src="/2023/11/26/database/image-20231119195518473.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119195544728.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119195556555.png" alt="image"></p>
<h3 id="Redo型日志"><a href="#Redo型日志" class="headerlink" title="Redo型日志"></a>Redo型日志</h3><h4 id="记录规则-1"><a href="#记录规则-1" class="headerlink" title="记录规则"></a>记录规则</h4><p>这对应的应该是No Steal</p>
<p><img src="/2023/11/26/database/image-20231119195713826.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119195819326.png" alt="image"></p>
<h4 id="恢复步骤-1"><a href="#恢复步骤-1" class="headerlink" title="恢复步骤"></a>恢复步骤</h4><p><img src="/2023/11/26/database/image-20231119195930925.png" alt="image"></p>
<h4 id="检查点-1"><a href="#检查点-1" class="headerlink" title="检查点"></a>检查点</h4><p><img src="/2023/11/26/database/image-20231119200045529.png" alt="image"></p>
<h3 id="结合型日志"><a href="#结合型日志" class="headerlink" title="结合型日志"></a>结合型日志</h3><p><img src="/2023/11/26/database/image-20231119200151170.png" alt="image"></p>
<h4 id="记录规则-2"><a href="#记录规则-2" class="headerlink" title="记录规则"></a>记录规则</h4><p><img src="/2023/11/26/database/image-20231119200249519.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119200303286.png" alt="image"></p>
<h4 id="恢复步骤-2"><a href="#恢复步骤-2" class="headerlink" title="恢复步骤"></a>恢复步骤</h4><p><img src="/2023/11/26/database/image-20231119200359441.png" alt="image"></p>
<p>感觉得先undo再redo？</p>
<p><img src="/2023/11/26/database/image-20231119200437439.png" alt="image"></p>
<p><img src="/2023/11/26/database/image-20231119200447605.png" alt="image"></p>
]]></content>
  </entry>
  <entry>
    <title>GC相关</title>
    <url>/2023/12/09/deduplication_GC/</url>
    <content><![CDATA[<p>本次先暂时只做个速读了</p>
<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>The Logic of Physical Garbage Collection in Deduplicating Storage</p>
<p>这篇文章看起来像是说他提出了两种GC方法，一个是PGC（physical），另一个是LGC（logical），没太看明白。</p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ol>
<li><p>这段话大致介绍了GC的重要性，感觉写得很不错，一些词可以参考一下<br>Most storage systems that write in a log-structured manner need a mechanism for garbage collection (GC), <strong>reclaiming and consolidating space by identifying unused areas on disk</strong>. In a deduplicating storage system, GC is complicated by <strong>the possibility of numerous references to the same underlying data</strong>.</p>
<p>Freeing unreferenced space is a basic storage system operation.</p>
</li>
<li><p>determining the liveness of chunks  判断chunk是否应该活着</p>
</li>
</ol>
<h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>A_Focused_Garbage_Collection_Approach_for_Primary_Deduplicated_Storage_with_Low_Memory_Overhead</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大概是提出了一种用于优化GC的Mark&amp;Sweep中的Mark阶段的方法，也即使用一个什么<em>Austere RefGraph</em>。它大概意思就是每次GC可以不针对全部文件，而是只针对那些被删除的文件及其他relative file（含有共享块），从而由此可以把deleted file的chunk分为两种类型：no-shared和shared。所以问题就转化为如何找到一个文件的relative file。然后我们通过refgraph来保存这些相关的meta data。</p>
<p>感觉大体上就是Odess的GC所用的方法，也许OdessGC对其做了一些简化。之后有兴趣可以钻验一下Odess以前的commit，了解一下这个项目是怎么一步步地被开发出来到今天这么庞大的。</p>
<p>不过看起来，好像本文是针对“Primary storage”，也即主存的？emmm，我们的大概是基于disk storage的。这点可能得注意一下。</p>
<p>针对主存的话，很重要的一点就是其CPU占用率、速度等因素。to-disk的话就不一定了。</p>
<p><img src="/2023/12/09/deduplication_GC/image-20231209224653551.png" alt="image-20231209224653551"></p>
<p>确实，你说得好啊，我们之前的Odess是针对的backup storage，所以检测一个块能否被删除可以判断其是否“out-of-date”。而针对primary storage的去重只能判断其refcnt和“版本内”重复。相当于backup storage是多个版本比较，这个primary storage是一个版本内比较。体会一下这两种场景的差异性。</p>
<p>同时，我也悟了一点，就是测pmem场景的时候老师为什么要求的是比较那个trace内部的重复率，而不是比较两个trace之间的了。因为pmem也是主存场景（非易失性内存）。那个trace的具体场景应该是存放在内存中的文件系统。所以他的意思是Odess加上这个就可以新概念拓宽数据集了。</p>
<p>我考，这下真悟了，66666我大彻大悟</p>
<p>所以主流的对Mark&amp;sweep的优化都不大适合于primary storage，毕竟它没有什么备份版本，或者什么内存cpu占用率太高了。</p>
<p>而且对于这种primary storage，感觉现在单位不是container了，而是不固定大小的file。比如本篇文章，就是根据file内部chunk的共享信息，来搭建起file之间联系的graph的：</p>
<p><img src="/2023/12/09/deduplication_GC/image-20231209234315248.png" alt="image-20231209234315248"></p>
<p><strong>明天估计得根据今天的领悟去重新思考一下老师说的第三个问题了。</strong></p>
<p>这个图画的很帅</p>
<p><img src="/2023/12/09/deduplication_GC/image-20231209234806628.png" alt="image-20231209234806628"></p>
<h2 id="摘抄-1"><a href="#摘抄-1" class="headerlink" title="摘抄"></a>摘抄</h2><ol>
<li><p> <strong>reclaim</strong> <strong>stale</strong> chunks in large-scale primary deduplication systems 在大规模的主去重系统中回收陈旧chunk</p>
</li>
<li><p>介绍什么是去重</p>
<p>Data deduplication, which allows files to <u>share their ”common” (i.e., duplicated) data in chunk-level [1],</u> has been used in many use cases, including backup storage [2], [3], data syncing [4], and flash storage [5].</p>
</li>
<li><p>为什么去重会影响GC的性能（这里由于target是主存，所以学习一下语法思路等即可）</p>
<p>Specifically, duplicated chunks will be physically stored only once, and these ”common” chunks in different files will be referenced many times. With the storage data evolution (i.e., caused by file operations), the deduplicated systems are full of active chunks (i.e., still referenced by some files) and stale chunks(i.e., no longer referenced by any file). And GC workflow has to recognize and remove stale chunks by tracking references of all chunks. Considering the number of chunks can be at billion-level in primary storage, GC will be a heavy task(very time- and memory-consuming), and it may lead to system stalls or worse latency, which are critical issues for primary storage.</p>
</li>
<li><p>可以看看related work的A部分。可以看到比较契合我写的部分</p>
<p><img src="/2023/12/09/deduplication_GC/image-20231209225429890.png" alt="image-20231209225429890"></p>
<p>可以着重参考一下</p>
</li>
<li></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完了全文，现在来提炼一下其大致摘要吧。</p>
<p>本篇文章主要针对对Primary Storage的去重系统中的GC阶段开销大问题，提出了FGC的解决方法。</p>
<p>当前主流最常用的GC方法是Mark &amp; Sweep，但由于它需要在Mark阶段扫描所有的文件来判断一个chunk的liveness，所以它的开销还是非常大。针对此，FGC提出了，无需扫描所有文件。它将删除文件中的chunk分为shared和non-shared两种类型，故而每次Mark阶段理论上只需找出所有shared的chunk，也即只需扫描与删除文件存在共享chunk关系的其他相关文件即可。</p>
<p>故而，我们需要维护一个数据结构，来记录这样的关联关系。顶点为一个文件，两个顶点有边表示两个文件共享了某个chunk。</p>
<p>然而，如果记录这样一个全图是相当耗费空间的，因此又提出了新的优化点：对于每个chunk，我们只需记录当前文件与每个chunk对应的base file之间的引用关系即可，也即一个file至多有chunk数条边。</p>
<p><img src="/2023/12/09/deduplication_GC/image-20231210162344305.png" alt="image-20231210162344305"></p>
<p>并且通过统计可得，大部分情况下一个文件通常只对应一个base file就够了。</p>
<p>因而综上所述，这样一来我们就完美减少了GC的Mark阶段所涉及的文件数。它原本需要扫描所有的文件，现在只需要扫描delete file及其related file这几个（大多数情况下就两个）文件就行了。</p>
<p>不过这个RefGraph大小虽然够小了，但是要维护它还是有一定的开销：</p>
<ol>
<li>宏观上，新增graph的边被抽象为无序的异步命令序列；但是删除就需要获取锁。</li>
<li>微观上，新增graph的边只需要扫描新文件即可；但是删除就可能需要遍历所有的related file进行graph的重构。</li>
</ol>
<p>并且，在实际的primary storage场景中，增删改（改可视为增删操作的混合）十分频繁，每次都进行real-time的更新是不现实的。</p>
<p>故此，我们将这个维护graph的步骤，也跟tracker一起放在了GC的pre-calcu阶段。</p>
<p>不过我很好奇，这个听起来很牛逼，为啥只投了个CCFB呢？</p>
<p><img src="/2023/12/09/deduplication_GC/image-20231210163157842.png" alt="image-20231210163157842"></p>
<p><img src="/2023/12/09/deduplication_GC/image-20231210163341573.png" alt="image-20231210163341573"></p>
<p>难道是因为速度比不过RC-Optimal吗，但是memory overhead确实挺不错。。。算了，不明白，也许山外山人外人吧。</p>
<p>总之，看下来感觉还是对primary storage这个应用场景有了更进一步的了解，也对GC的整体算法框架有了一定的了解。</p>
<p>不过感觉这篇文章主要聚焦的还是GC过程的效率，而Odess的话应该聚焦的是GC过程对<strong>碎片化问题</strong>的解决，侧重点还是各有不同。不过感觉Odess应该也是很前沿了，它用的cache-centered的算法应该也是很牛逼的。</p>
<p>感觉还是对所谓“idea”的产生理解比较抽象。也许都是初步有个雏形，知道这个方面暂时前沿还没有人做过，然后慢慢开始增加新的point的吧。。。所以最关键还是要先对这个领域的研究现状有一个全面完整的了解。加油吧只能说，还得是沉淀！</p>
]]></content>
  </entry>
  <entry>
    <title>综述读后笔记</title>
    <url>/2023/12/10/deduplication_overview/</url>
    <content><![CDATA[<blockquote>
<p>Xia W, Jiang H, Feng D, et al. A comprehensive study of the past, present, and future of data deduplication[J]. Proceedings of the IEEE, 2016, 104(9): 1681-1710.</p>
</blockquote>
<h1 id="Data-Reduction"><a href="#Data-Reduction" class="headerlink" title="Data Reduction"></a>Data Reduction</h1><p>一开始主要是一步步讲述了Data Deduplication这个概念提出的历程。</p>
<h2 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a>Compression</h2><p>最一开始，都是用的压缩<strong>Compression</strong>。compression分为lossy和lossless（有损压缩和无损压缩），前者是通过去除一些不必要的信息来不可逆地减少数据大小（如JPEG图片压缩），后者是通过编码或者算术等方法可逆地减少数据大小（如GZIP、LZW等）。由于大规模存储系统（large-scale storage system）主要聚焦于无损压缩，因而下文也主要介绍这个。（<u>deduplication也可以视为无损压缩的一种方法</u>）</p>
<h3 id="entropy-encoding"><a href="#entropy-encoding" class="headerlink" title="entropy encoding"></a>entropy encoding</h3><h4 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h4><p>提到压缩，就不得不提到信息熵。一个变量X的信息熵可以如下计算：</p>
<p><img src="/2023/12/10/deduplication_overview/image-20231210221755122.png" alt="image-20231210221755122"></p>
<p>比如说通过字符串abaaacabba，我们可以计算其所构成字母的信息熵：</p>
<p><img src="/2023/12/10/deduplication_overview/image-20231210221846621.png" alt="image-20231210221846621"></p>
<p>其实际含义是，对于“abaaacabba”这个上下文，<code>&#123;a, b, c&#125;</code>集合的<strong>每个字母至少需要1.295个bit来表示</strong>，也即<strong>字符串“abaaacabba”至少由12.95个bits来表示</strong>。也即，信息熵实际上是算出了<strong>压缩的极限</strong>。</p>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>早期的压缩理论就是根据信息熵来的，这种我们称为“entropy encoding”或者“statistical-model-based coding”，因为它需要基于某个上下文（statistics）来计算信息熵。最常见的就是哈夫曼树，它用一个frequency-sorted binary tree来生成前缀编码，从而对信息进行压缩。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>然而，显而易见的是这种entropy encoding你首先就得有合适的statistics，这是不scalable的。所以它一般也不适用于现代的storage system的压缩要求。</p>
<h3 id="dictionary-model-based-coding"><a href="#dictionary-model-based-coding" class="headerlink" title="dictionary-model-based coding"></a>dictionary-model-based coding</h3><p>因而，“dictionary-model-based coding”就此浮出水面。它从<strong>string-level</strong>来识别重复数据，从而简化和加速了压缩。它的主要思想是通过滑动窗口识别重复字符串，并用位置和长度来替代这些重复的。（相当于是unique string只存储一次）代表性的是LZ压缩。</p>
<p>然而，它由于是string-level，所以需要对整个系统的所有string进行扫描，需要在compression ratio和speed之间trade off。</p>
<h3 id="delta-compression"><a href="#delta-compression" class="headerlink" title="delta compression"></a>delta compression</h3><p>它的提出是针对于小文件/相似chunk的。它的思想感觉有点类似密码学，大概是这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">given file <span class="selector-tag">A</span>,<span class="selector-tag">B</span></span><br><span class="line">calc △ab，</span><br><span class="line">我们就可以通过△ab和<span class="selector-tag">B</span>来恢复出一个<span class="selector-tag">A</span>。</span><br></pre></td></tr></table></figure>

<p>目前正在尝试把它纳入到deduplication system中。不过目前的瓶颈似乎是这样的，delta compression是要求要将当前chunk同base chunk进行对比，所以怎么找到base chunk就成了问题。</p>
<h3 id="Deduplication"><a href="#Deduplication" class="headerlink" title="Deduplication"></a>Deduplication</h3><p>总之，在compression byte-by-byte识别redundant data这样粒度太小的劣势下，通过计算“cryptographically secure hash-based fingerprints”来识别redundant data的chunk-level的deduplication优势就来了！</p>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/2023/12/10/deduplication_overview/image-20231210223322234.png" alt="image-20231210223322234"></p>
<p>这里也是给了一张很棒的图来总结了上文。</p>
<h2 id="Key-Features"><a href="#Key-Features" class="headerlink" title="Key Features"></a>Key Features</h2><p>这个部分大概是说<strong>key features有两个，一个是chunking，另一个是fingerprinting</strong>。</p>
<p>chunking有两种方法，fixed-size和variable-size，前者会出现boundary-shift问题，后者更加泛用。</p>
<p>fingerprinting的主流方法还是基于SHA1（现在也用SHA256了）【Cryptographically Secure Hash-Based Fingerprinting】，主要是讨论了它哈希碰撞的可能性很小所以使用安全，还有就是讨论了fingerprint的特性：</p>
<ol>
<li><p>很难找到两个不同msg指纹相同</p>
</li>
<li><p>很难从fp倒推出一个msg</p>
</li>
</ol>
<h2 id="Basic-Workflow"><a href="#Basic-Workflow" class="headerlink" title="Basic Workflow"></a>Basic Workflow</h2><blockquote>
<p>A typical data deduplication system follows the workflow of:</p>
<ol>
<li>chunking</li>
<li>fingerprinting</li>
<li>indexing</li>
<li>further compression</li>
<li>storage management<ol>
<li>data restore</li>
<li>garbage collection</li>
<li>fragment elimination</li>
<li>reliability</li>
<li>security</li>
</ol>
</li>
</ol>
</blockquote>
<h1 id="Deduplication-1"><a href="#Deduplication-1" class="headerlink" title="Deduplication"></a>Deduplication</h1><blockquote>
<p>In this section, we examine the state-of-the-art works on data deduplication in sufficient depth to understand their key and distinguishing features.</p>
</blockquote>
<p>本节终于要开始对deduplication的关键技术做详尽的介绍和讨论了。</p>
<h2 id="A-Chunking"><a href="#A-Chunking" class="headerlink" title="A.Chunking"></a>A.Chunking</h2><p>这部分确实如他所言主要介绍了chunking。它先是介绍了主流的CDC算法Rabin（具体在FastCDC那篇文章介绍过这部分了，这里就不再赘述），然后讲述了Rabin算法的三个主要缺点：chunk size方差大、计算量大、去重检测还不够精确。</p>
<p>针对这三个缺点，分别有各种文献提出了这几类关键技术（顺序与缺点一一对应）：</p>
<ol>
<li><p>Reducing Chunk Size Variance by <strong>Imposing Limits on MAX/MIN Chunk Sizes</strong> for CDC</p>
<p>当chunk size过大，虽然会加速后续的indexing等步骤，减少space消耗，但是会影响去重率；chunk size过小，虽然会增加去重率，但是会增大后续indexing等步骤的工作量。这又是一个trade-off。</p>
<p>这里主要介绍了各个主流方法都是怎么限制chunk size的，比如说LBFS简单粗暴，还有别的什么依据极值、非对称滑动窗口等做法。感觉还是FastCDC那个做法更加灵活聪明。</p>
</li>
<li><p>Reducing Computation to Accelerate the Chunking Process</p>
<p>也是有比如说Gear等等算法或者硬件层面上的改进。</p>
</li>
<li><p>Improving Duplicate-Detection Accuracy by <strong>Rechunking Nonduplicate Chunks</strong></p>
<p>这个问题也是比较普遍，比如如图所示的C2和C5之间就可以再做进一步去重：</p>
<p><img src="/2023/12/10/deduplication_overview/image-20231210235904637.png" alt="image-20231210235904637"></p>
<p>具体方法有比如说频率分析法选定某些频繁访问的chunk进行rechunking、把几个小的nonduplicate chunk给merge为一个大的然后rechunking等等。</p>
<p>这个可能对网络场景也有适用，毕竟网络传输也就主要是通过一个个很小的network package数据包。</p>
</li>
<li><p>Impact of Interspersed Metadata</p>
<p>主要是说如果数据集内meta data和主要数据混在一起可能干扰去重，比如说block header、还有tar打包后产生的文件的包含时间戳等信息的file header等等。</p>
<p>解决方法大概就是预处理之类的。</p>
</li>
</ol>
<h2 id="B-Accelerate-Computational-Tasks"><a href="#B-Accelerate-Computational-Tasks" class="headerlink" title="B. Accelerate Computational Tasks"></a>B. Accelerate Computational Tasks</h2><p>这个部分大概就是提出了两种方法，一个是通过将deduplication system给pipeline了（就是Odess那个做法），然后再结合multithreading来对它进行多线程加速；另一个就是通过开发GPU相关库来对deduplication做支持，从而使用GPGPU架构来进行硬件加速。</p>
<p><img src="/2023/12/10/deduplication_overview/image-20231211141021880.png" alt="image-20231211141021880"></p>
<h2 id="C-Indexing"><a href="#C-Indexing" class="headerlink" title="C. Indexing"></a>C. Indexing</h2><p><img src="/2023/12/10/deduplication_overview/image-20231211141035597.png" alt="image-20231211141035597"></p>
<p>不知道这个indexing是不是就是我们pipeline中的dedup阶段，感觉是的。</p>
<p>这个阶段面临的问题就是，数据量太大，导致指纹量也很大装不进内存，也就是说可能得根据磁盘中的指纹进行快速的索引。</p>
<p>indexing大致有两种思路，一个是精准的indexing，另一个就是命中率较低但内存占用也低的indexing。感觉capping有可能也有点后者的感觉（）</p>
<p>然后目前流行的也是有四类方法：locality-based, similarity-based, flash-assisted, and cluster deduplication approaches。</p>
<ol>
<li><p>locality-based</p>
<p>大概意思就是说利用数据的局部性，每次要某个指纹不是只读它一个，而是顺带把磁盘中这个指纹后面几个也读进内存，磁盘中的也是按照数据局部性存储的。</p>
<p>除此之外，DDFS结合Bloom filter使用来精准检测重复。</p>
<blockquote>
<p> A Bloom filter [22] is a space-efficient data structure that uses a bit array with several independent hash functions to represent membership of a set of items (e.g., fingerprints).</p>
</blockquote>
<p>而Sparse indexing则采取“抽样”的方式。</p>
<p>这个一般用于提高performance。</p>
</li>
<li><p>similarity-based</p>
<p>最常见的方法是用一个fp set的最大值or最小值来表示一个file，然后对这个建立一个主索引。如果两个文件的代表fp相同，那么这两个文件很有可能重复读极高。</p>
<p>它这里提到了一个比较值得思考的观点：locality-based是利用了physical-locality，similarity-based是利用了logical-locality。前者还是比较容易理解的，因为它要求磁盘中的指纹按局部性存储，后者我是真没明白。。。之后有兴趣再看看相关论文了解一下吧。</p>
<p>这个一般用于reduce RAM overhead。</p>
</li>
<li><p>flash-assisted</p>
<p>感觉这个没啥特别的，相当于换了个闪存介质而不是磁盘来存储index。</p>
</li>
<li><p>Cluster Deduplication</p>
<p>这个相当于加了层分布式，将输入的数据流分成几个种类（比如说按前缀分）然后送到多个结点上并行地进行去重处理，然后每个结点内部又可以用别的算法了之类的。这就需要涉及到负载均衡、路由算法等等了。</p>
<p>缺点是可能降低deduplication ratio（可能是因为一些路由算法实现？）。</p>
</li>
</ol>
<h2 id="D-Post-Deduplication-Compression"><a href="#D-Post-Deduplication-Compression" class="headerlink" title="D. Post-Deduplication Compression"></a>D. Post-Deduplication Compression</h2><p><img src="/2023/12/10/deduplication_overview/image-20231212224322111.png" alt="image-20231212224322111"></p>
<p>不过即便如此，一个chunk内可能还是有一些小地方是dunplicate的（internal redundancy），这时候压缩就大有用处了。并且多个chunk一起压缩，比单个单个压缩的压缩率更高。</p>
<p>这个还适用于上面说到的一种情况，也即那个用到rechunk的地方，完全可以用delta compression来代替，而且感觉后者可能还更通用（）感觉被薄纱。</p>
<p>主要面临的挑战来自于这几个方面：resemblance detection, reading base chunks, and delta encoding。</p>
<ol>
<li><p>resemblance detection</p>
<p>目前大概有这几种方法：</p>
<ol>
<li>Manber：计算polynomial-based fingerprints，两个文件的相似性取决于它们相同的这个fp的数量。</li>
<li>superfeature：抽样选取一些Rabin fp作为feature，并把它们合起来成为一个大的superfeature，对这个东西进行index。这个好像应用比较广泛。</li>
<li>TAPER：每个file都是一个bloom filter，比较filter相同的bit位数。</li>
</ol>
</li>
<li><p>delta encoding</p>
</li>
<li><p>Additional Delta Compression Challenges</p>
</li>
</ol>
<h2 id="E-Data-Restore"><a href="#E-Data-Restore" class="headerlink" title="E. Data Restore"></a>E. Data Restore</h2><p>这里笔墨最多的还是在说碎片化问题，同时也简要介绍了去重系统的三个主要应用场景：primary storage、backup storage、cloud storage，以及碎片化问题给它们的薄弱方面的狠狠一击（）</p>
<ol>
<li><p>primary storage</p>
<p>它最主要的问题还是IO-sensitive</p>
</li>
<li><p>backup storage</p>
<p>它最主要的问题是随着备份版本增多碎片化问题的愈发严重</p>
</li>
<li><p>cloud storage</p>
<p>它最主要的问题是速度，其受网络带宽、碎片化的限制。</p>
</li>
</ol>
<h2 id="F-Garbage-Collection"><a href="#F-Garbage-Collection" class="headerlink" title="F. Garbage Collection"></a>F. Garbage Collection</h2><p>这部分也大概是讲了GC常见的两种方法，一个是reference count，另一个是mark &amp; sweep。</p>
<p>前者需要<strong>inline</strong>地维护refcnt，后者则可以<strong>offline</strong>运行。</p>
<p>并且在backup system中，GC一般是删除了几个备份版本之后的background process。而在primary storage中，GC通常是inline的。</p>
]]></content>
  </entry>
  <entry>
    <title>Deduplication System相关文章</title>
    <url>/2023/12/10/deduplication_system_articles/</url>
    <content><![CDATA[<blockquote>
<p>各个超链接导向对应的文章分链接。</p>
</blockquote>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a><a href="/2023/12/10/deduplication_overview">综述</a></h1><h1 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a><a href="/2023/11/11/Indexing">Indexing</a></h1><h1 id="Chunking"><a href="#Chunking" class="headerlink" title="Chunking"></a>Chunking</h1><h2 id="FastCDC"><a href="#FastCDC" class="headerlink" title="FastCDC"></a><a href="/2023/12/08/fastcdc">FastCDC</a></h2><h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><h2 id="data-layout"><a href="#data-layout" class="headerlink" title="data layout"></a>data layout</h2><h3 id="MFDedup"><a href="#MFDedup" class="headerlink" title="MFDedup"></a><a href="/2023/10/11/MFDedup">MFDedup</a></h3><h2 id="Rewriting"><a href="#Rewriting" class="headerlink" title="Rewriting"></a><a href="/2024/05/11/Rewriting">Rewriting</a></h2><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a><a href="/2023/12/09/deduplication_GC">GC</a></h1>]]></content>
      <tags>
        <tag>research</tag>
      </tags>
  </entry>
  <entry>
    <title>FastCDC</title>
    <url>/2023/12/08/fastcdc/</url>
    <content><![CDATA[<h1 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h1><p><strong>FastCDC: a Fast and Efficient Content-Defined</strong> <strong>Chunking Approach for Data Deduplication</strong></p>
<p>首先还是一如既往见题知义环节。名字很简明，就是一个高效的<strong>按内容分块</strong>技术，用于dedup。</p>
<p>回忆一下按内容分块，大抵就是什么哈希值什么玩意的（说实话一点不懂），还需要界定分块范围。不过我感觉哈希技术应该都比较固定，所以我觉得这篇文章可能更聚焦于如何界定分块边界，比如有没有用什么滑动窗口算法？之类的。具体着实是不大明白，所以这篇论文的background部分也得好好研究。</p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>CDC：Content-Defined Chunking  按内容分块</p>
<p>以前的CDC【目前的大boss，Gear-based CDC】：一个字节一个字节地计算rolling hash从而划分chunk point，CPU占用率高。</p>
<p>解决方法：</p>
<ol>
<li><p>simplifying and enhancing the hash judgment  简化并且增强hash judgment</p>
<p>解决CPU占用率高问题</p>
</li>
<li><p>skipping sub-minimum chunk cut-point  跳过次小chunk cut-point</p>
<p>进一步加速</p>
</li>
<li><p>normalizing the chunk-size distribution in a small specified region  让chunk size分布更密集</p>
<p>解决了由于cut-point跳跃而导致的deduplication radio降低的问题</p>
</li>
</ol>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ol>
<li><p>deduplication通过加密安全哈希签名【<em>cryptographically secure hash signatures</em> (e.g., SHA1 fingerprint)】标识重复内容。</p>
</li>
<li><p>chunk-level &gt; file-level，因为其粒度更细。</p>
</li>
<li><p>常见chunk分类：FDC、CDC（解决boundary-shift problem）。</p>
</li>
<li><p>CDC经典通过Rabin fingerprint来解决探查边界问题，有效但是time-consuming；</p>
<p>因而有替代hash算法：Gear，SampeByte，AE</p>
</li>
<li><p>一般来说CDC分为两个阶段：</p>
<ol>
<li><p>hashing</p>
<p>生成fp</p>
</li>
<li><p>hashing judgment</p>
<p>将生成的fp与given value对比从而确定chunk的cut-point</p>
</li>
</ol>
</li>
<li><p>observation</p>
<ol>
<li><p>Gear-based CDC，快，但是low deduplication radio，因为在hashing judgment阶段滑动窗口太小</p>
</li>
<li><p>hashing judgment阶段成为新的性能瓶颈，因为Gear的hash阶段已经够快了</p>
</li>
<li><p>predefined的最小chunk size（一般用于防止生成一丝丝小的chunk）能被用于CDC的<em>cut-point skipping</em>（跳过cut-point，也即对该region取消CDC的使用）。</p>
<p>如果放大该大小，可以加速chunking【很容易理解，因为跳过的变多了就不用chunk了】，但是会降低deduplication radio【也很容易理解，因为跳过了就无视了一些重复块】。</p>
</li>
</ol>
<p>由1、2，我们提出 <em>enhancing and simplifying the <strong>hash judgment</strong></em>来减少CPU开销，加速Gear-based CDC。</p>
<p>针对3，我们提出 <em>a novel normalized Content-Defined Chunking scheme</em>, 也即<strong>normalized</strong> <strong>chunking</strong>，来让chunk size分布更密集。</p>
</li>
<li><p>三个关键技术</p>
<ol>
<li><p><strong>Simplified but enhanced hash judgment</strong></p>
<ol>
<li><p>增大Gear算法hashing judgment stage的<strong>滑动窗口大小</strong>，by <strong>padding</strong> several zero bits into the mask value for the <u>hash-judging statement</u> of the CDC algorithm.</p>
<p>通过此，成功使Gear达到Rabin那样的去重率。</p>
</li>
<li><p>更深简化优化hashing judgment stage</p>
<p>通过此，降低CPU占用率</p>
</li>
</ol>
</li>
<li><p><strong>Sub-minimum chunk cut-point skipping</strong></p>
<p>我们通过normalized chunking来达到扩大minimum chunk size，加速chunking的同时，又保持deduplication radio不会太菜。</p>
<p>normalized chunking：By <strong>selectively changing the number of mask bits ‘1’</strong> in the <u>hash-judging</u> statement of CDC.</p>
<p>【想了想确实，因为chunk的最小size越大，那么chunking越快。如果块集中分布在某个区域，那不就是可以“扩大minimum size”了（对正态分布外的那堆丝丝跳过），就可以加速chunking。</p>
<p>我们就需要知道它这个集中分布到底是怎么做的，为什么在hashing judgment阶段做那个就可以规范，这估计需要来点background或者等下看看真实的代码了】</p>
<p>这样一来，我们就可以：</p>
<ol>
<li>reduce big chunk size：增加去重比（因为相当于小于最小size的部分变少了）</li>
<li>add cut-point skipping technique：可以运用这个玩意从而增加chunking速率了</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><ol>
<li><p>CDC一般都是使用滑动窗口来计算hash值，当哈希值满足某种条件时，我们就把滑动窗口对应的这个数据块作为一个chunk进行切割。</p>
</li>
<li><p>rolling hash：能以迭代方式进行计算的hash算法。这也跟滑动窗口的思想很吻合</p>
</li>
<li><p>Rabin Hash的定义式：</p>
<p><img src="/2023/12/08/fastcdc/image-20231031185552413.png" alt="image-20231031185552413"></p>
<p>如果滑动窗口hash值的最低log2D位与阈值r匹配，也即<code>fp mod D = r</code>，则当前位置被标记为块切点</p>
<p><img src="/2023/12/08/fastcdc/image-20231031185838418.png" alt="image-20231031185838418"></p>
<p>如图所示，计算得C7的fp不满足条件，故而C7不算是一个cut-point，而C3的可以。</p>
</li>
<li><p>由于Rabin hash是byte-by-byte，所以效率较低。解决方法：</p>
<ol>
<li><p>算法加速</p>
<p>Gear、AE、SampleByte。具体算法是怎么做的详见文章。</p>
</li>
<li><p>硬件加速</p>
</li>
</ol>
</li>
<li><p>还有提到了一个很有意思的点：<strong>typical data deduplication system workflow</strong></p>
<ol>
<li><p>chunking</p>
</li>
<li><p>fingerprinting</p>
<p>computes the cryptographically secure hash signatures(e.g., SHA1) of data chunks</p>
<p><strong>在具体实现中感觉这玩意应该可以跟chunking合起来使用？好像不行，看看Odess怎么做的</strong></p>
<p>【其实有一点还不大明白，就是fp的生成算法和chunking中的hash算法一样吗？有待观察】</p>
</li>
<li><p>indexing</p>
<p>identifying the identical fingerprints for checking duplicate chunks </p>
<p>识别指纹，从而进行重复块检测</p>
</li>
<li><p>storage management</p>
<p>指non-deduplicated chunks及其meta data的存储、可能的deduplication后的后处理，为了为之后的<strong>去碎片化、压缩、可靠性、安全性</strong>服务。</p>
<p>【这个是不是就有点豁然开朗了？咱们之前研究的各种data layout、rewrite什么什么的，其本质上就是通过修改改善storage system的meta data，以及进行一些去重后处理，从而达到去碎片化效果的。感觉它这个概括是真的很精炼，让我对storage system的全貌有了更深的理解。】</p>
</li>
</ol>
</li>
</ol>
<h1 id="Observation-and-Motivation"><a href="#Observation-and-Motivation" class="headerlink" title="Observation and Motivation"></a>Observation and Motivation</h1><ol>
<li><p>Gear Hash</p>
<img src="/2023/12/08/fastcdc/image-20231112220004763.png" alt="image-20231112220004763" style="zoom: 80%;">

<p>通过两个关键方法使生成的哈希值均匀分布。</p>
<ol>
<li><p>映射</p>
<p>每个字节都映射为一个64位的整数值，也即图中的G函数。也即G大致定义为：<code>uint64_t G[256]</code></p>
</li>
<li><p>运算</p>
<p>通过“+”将滑动窗口最新一个byte加入哈希信息，通过“&lt;&lt;”将滑动窗口最旧一个byte剥离出哈希信息。</p>
</li>
</ol>
<p>这里也可以形象化理解。滑动窗口的哈希值事实上保留的是许多最近版本的信息值。每次左移，都会剥离掉旧版本的一部分信息【别忘了都是64位，所以还有一部分信息存留在保留的哈希值中】，而每次+，就会加入新版本的信息。故而，一个字节的信息生命周期为8次滑动窗口移动。可见，它可以同时保留有用的、一部分生命周期的新旧版本信息，体现了其Content-Defined的思想。</p>
<p>也因它每8次扔掉一次信息，所以它可能不大准确，开销较大的Rabin rolling看起来还再度利用了扔掉的a的消息，所以虽然开销较大，但是去重率较高：（N是滑动窗口大小）</p>
<p><img src="/2023/12/08/fastcdc/image-20231112220726753.png" alt="image-20231112220726753"></p>
<p>虽然感觉水平还是不够，不大懂究竟为什么uniform了。。。</p>
</li>
<li></li>
</ol>
<h1 id="Design-and-Implementation"><a href="#Design-and-Implementation" class="headerlink" title="Design and Implementation"></a>Design and Implementation</h1><h2 id="Optimizing-Hash-Judgment"><a href="#Optimizing-Hash-Judgment" class="headerlink" title="Optimizing Hash Judgment"></a>Optimizing Hash Judgment</h2><p>感觉还挺期待。回忆一下hash judgment是啥过程来着？是根据当前滑动窗口内的哈希值，还有这个经典模运算：<img src="/2023/12/08/fastcdc/image-20231112225718484.png" alt="image-20231112225718484" style="zoom:50%;">，来确定cut-point。而hash judgment之所以产生性能瓶颈，有一个原因是因为滑动窗口太小了，所以我们需要增大窗口大小。但是窗口大小与mask比特数恒等【mask就是这个mod的D的2的幂数吧】，所以我们也需要改变mask。那么怎么改变呢？下面将给出答案。</p>
<ol>
<li><p>Enlarging the sliding window size by zero padding</p>
<p>这里首先是一针见血给出了那个模式子的形象理解：低比特位决定cut-point。</p>
<blockquote>
<p>a certain number of the lowest bits of the fingerprint are used to declare the chunk cut-point</p>
</blockquote>
<p>mask的大小也就是D的幂数，Gear hash的特性决定滑动窗口大小必须跟mask大小一样。</p>
<p>说实话没太看懂为什么。。。这俩图都没看懂</p>
<p><img src="/2023/12/08/fastcdc/image-20231112230835674.png" alt="image-20231112230835674"></p>
</li>
<li><p>Simplifying the hash judgment to accelerate CDC</p>
<p>反正意思就是不用模运算了，也不用跟r比了，还是没看懂。。。</p>
</li>
</ol>
<h2 id="Cut-point-Skipping"><a href="#Cut-point-Skipping" class="headerlink" title="Cut-point Skipping"></a>Cut-point Skipping</h2><p>这一节主要是介绍了下cut-point skipping。</p>
<ol>
<li><p>Rabin-hash的chunk size分布：</p>
<img src="/2023/12/08/fastcdc/image-20231112232830182.png" alt="image-20231112232830182" style="zoom:50%;">

<p><img src="/2023/12/08/fastcdc/image-20231112232851343.png" alt="image-20231112232851343"></p>
<p>可以看到跟我们理想中的正态分布不一样，很大一部分（22%）为小于minimum size的chunk，导致skip增加，去重率降低。</p>
</li>
<li><p>skip对judgment的增速</p>
<p>可以通过几个方面理解：</p>
<ol>
<li>skip事实上增大了chunk的平均大小，增加的大小等于minimum chunk size</li>
<li>skip可以免去一些judgment计算</li>
</ol>
<p>这两点原因其实本质比较重合，但是考虑角度不同。</p>
</li>
</ol>
<h2 id="Normalized-Chunking"><a href="#Normalized-Chunking" class="headerlink" title="Normalized Chunking"></a>Normalized Chunking</h2><p>感觉最牛逼的还是这个，主要实在想不通均匀分块是怎么做到的，因为不是content-based不</p>
<p>它好像操作是selectively change the number of effective mask bits ，也就是改那个模数D</p>
<blockquote>
<p>For the traditional CDC approach with expected chunk size of 8KB (i.e., 213), 13 effective mask bits are used for hash judgment (e.g., *fp &amp; 0x1fff==*<em>r</em>).  一般情况，都只用13位mask</p>
<p>For normal ized chunking, more than 13 effective mask bits are used for hash judgment (e.g., *fp &amp; 0x7fff==*<em>r</em>) when the current chunking position is smaller than 8KB, which makes it harder to generate chunks of size smaller than 8KB. </p>
</blockquote>
<p>我们是会根据情况看用多少位mask，如果当前chunk太小就多用几位（相当于分块条件严苛了），太大了就少用几位（从而更容易生成大chunk），这样就能限制小chunk数量和大chunk数量。</p>
<blockquote>
<p>这里有一点需要理解一下。多用几位限制小chunk数量可以理解，那为什么少用几位可以限制大chunk数量呢？</p>
<p>试想一下，大chunk是怎么形成的。是因为条件太严苛，所以得很久很久之后才有一个cut-point。</p>
<p>因而，小chunk是因为条件太松，大chunk是因为条件太严苛，所以我们对小chunk多用几位，对大chunk少用几位即可。</p>
</blockquote>
<p>很好，感觉这也许就是一种adaptive（高情商）怪不得在提出COS那个自适应时夏老师说很常见，原来是使过了这个招hhhh</p>
<p><img src="/2023/12/08/fastcdc/image-20231112234855679.png" alt="image-20231112234855679"></p>
<p>这样一来，与skip结合，既使得小chunk少致使去重率不会太低，又使得我们可以扩大minimum size的大小（所有块更加紧凑，自然最小块大小也就变大向中间靠拢了）</p>
<p>值得注意的是，最高level的FastCDC其实就相当于FSC（固定大小分块技术）。</p>
<p>【感觉这个思想很有意思，果然做什么都是要中庸之道，永远是结合两者的才是永远的神（）这里相当于从分布上使用了中庸之道。】</p>
<h2 id="altogether"><a href="#altogether" class="headerlink" title="altogether"></a>altogether</h2><p><img src="/2023/12/08/fastcdc/image-20231207232441772.png" alt="image-20231207232441772"></p>
<h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><p>性能评估是分别针对这三个优化点进行分析的。</p>
<h2 id="Hash-Judgment"><a href="#Hash-Judgment" class="headerlink" title="Hash Judgment"></a>Hash Judgment</h2><p>对于第一个优化点hash-judge，我们重点比较的指标是<strong>chunking的速度和去重率</strong>，并且比较的是它跟其他几种去重算法的对应指标。这也是很显然的，因为hash-judge主要影响的是生成的块的大小和准确率，前者影响速度，后者影响去重率。</p>
<p>chunking速率我们合并统计了hash阶段和hash-judge阶段。</p>
<p>Gear算法hash快但judge慢，Rabin算法hash慢但judge快，FastCDC充分结合二者优点。</p>
<p>去重率也是列了张很清晰的表，感觉可以学习一下它这个表画的：</p>
<p><img src="/2023/12/08/fastcdc/image-20231207234447543.png" alt="image-20231207234447543"></p>
<h2 id="cut-point-skipping"><a href="#cut-point-skipping" class="headerlink" title="cut-point skipping"></a>cut-point skipping</h2><p>它主要比较的是FastCDC自身在不同Min-ChunkSize之间的chunking speed、去重率以及平均chunk大小，相当于起一个调参的启发性作用。</p>
<p>一个值得注意的点是，它这里强调了：</p>
<blockquote>
<p> For the metric of the average generated chunk size in FastCDC, it is approximately equal to the summation of the expected chunk size and the applied minimum chunk size.</p>
</blockquote>
<p>FastCDC生成的平均chunk大小为expected chunk + minimum chunk。</p>
]]></content>
  </entry>
  <entry>
    <title>git使用记录</title>
    <url>/2023/10/07/git/</url>
    <content><![CDATA[<blockquote>
<p>记录一些git的原理学习，以及工作学习中遇到的一些git的操作问题。</p>
</blockquote>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="pull-request"><a href="#pull-request" class="headerlink" title="pull request"></a>pull request</h2><ol>
<li><p>第一次提pr</p>
<ol>
<li>fork原仓库</li>
<li>本地clone，两个remote，fork和origin</li>
<li>checkout -b new-branch</li>
<li>修改，add，commit，push</li>
<li>在github提pr</li>
</ol>
</li>
<li><p>修改提过的pr</p>
<ol>
<li><p>本地仓库与远程同步</p>
<p>直接修改，然后push到fork的对应分支就行，会自动更新。</p>
</li>
<li><p>本地仓库与远程不同步</p>
<p>以下操作都在new-branch分支上</p>
<ol>
<li>git fetch origin</li>
<li>git rebase origin/master</li>
<li>如果有冲突则解决，然后<code>git rebase --continue</code>继续rebase</li>
<li>push fork</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p><a href="https://zhuanlan.zhihu.com/p/659979063">修改 git 的历史 commit，你能想到几种方案？</a>  详细介绍了rebase基本用法</p>
<h2 id="object损坏"><a href="#object损坏" class="headerlink" title="object损坏"></a>object损坏</h2><p><img src="/2023/10/07/git/image-20231030100954710.png" alt="image-20231030100954710"></p>
<p>如图，我也不知道为什么突然就寄了。。。</p>
<p>总之进行了这些操作，虽然不知道是哪个起作用了，但总算好了：</p>
<p><a href="https://blog.csdn.net/xiaoqixiaoguai/article/details/128591332">https://blog.csdn.net/xiaoqixiaoguai/article/details/128591332</a></p>
<p>首先删除空白对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> .git</span><br><span class="line">find . -<span class="built_in">type</span> f -empty -delete -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>

<p>然后更新ref到某个版本号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">tail</span> -n 2 .git/logs/refs/heads/master</span><br><span class="line">git show xxxx(版本号)</span><br><span class="line">git update-ref HEAD xxxx(版本号)</span><br><span class="line">git fsck</span><br></pre></td></tr></table></figure>

<p>如果还不能用，继续：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> .git/index</span><br><span class="line">git reset</span><br><span class="line">git fsck</span><br></pre></td></tr></table></figure>

<p>我到这里之后显示：</p>
<p><img src="/2023/10/07/git/image-20231030101123181.png" alt="image-20231030101123181"></p>
<p>继续执行：</p>
<ol>
<li><p><strong>修复 refs/remotes/origin/master：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bashCopy codegit update-ref -d refs/remotes/origin/master</span><br><span class="line">git fetch origin</span><br></pre></td></tr></table></figure>

<p>这将删除损坏的 <code>origin/master</code> 引用，然后从远程仓库重新获取。</p>
</li>
<li><p><strong>修复 dangling blob：</strong></p>
<p>如果 <code>git fsck</code> 显示了 <code>dangling blob</code>，你可以尝试删除这些对象：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bashCopy codegit reflog expire --expire=now --all</span><br><span class="line">git gc --prune=now</span><br></pre></td></tr></table></figure>

<p>这将清理无用的 dangling 对象。</p>
</li>
</ol>
<p>成功。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ol>
<li><p>merge与rebase的差异</p>
<p>merge：</p>
<p><img src="/2023/10/07/git/merge.png" alt="merge"></p>
<p>rebase：</p>
<p><img src="/2023/10/07/git/rebase.png" alt="rebase"></p>
</li>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>驱动开发小记</title>
    <url>/2023/10/27/driver_develop/</url>
    <content><![CDATA[<p>此为<a href="https://github.com/lazyparser/weloveinterns/blob/master/open-internships.md#bj71-rt-thread-%E7%A4%BE%E5%8C%BA%E5%AE%9E%E4%B9%A0%E7%94%9F-3%E4%B8%AA%E5%90%8D%E9%A2%9D">PLCT Lab BJ71</a>实习内容，我的工作是为RT-Thread完善Milk-v Duo开发板支持。</p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><p><a href="https://xiunianjun.github.io/2023/10/19/open-source-9.19-10.19/#:~:text=%E7%AC%94%E4%BB%A3%E7%A0%81%E8%B4%9F%E8%B4%A3%E3%80%82-,gpio%20driver,-pr%EF%BC%9A">感受</a>之前已经详细记录过了，在此便不再赘述。这里只写一些开发流程和最终代码框架展示。</p>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="10-13—概述"><a href="#10-13—概述" class="headerlink" title="10.13—概述"></a>10.13—概述</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>首先了解一下gpio是什么。</p>
<p>芯片上的引脚一般分为 4 类：电源、时钟、控制与 I/O，I/O 口在使用模式上又分为 General Purpose Input Output（通用输入 / 输出），简称 GPIO，与功能复用 I/O（如 SPI/I2C/UART 等）。</p>
<blockquote>
<p><a href="https://blog.csdn.net/m0_56694518/article/details/131207367">https://blog.csdn.net/m0_56694518/article/details/131207367</a></p>
<p>GPIO是英文<strong>General Purpose Input/Output</strong>的缩写，中文翻译为通用输入/输出。它是一种在数字电子系统中常见的接口类型，用于与外部设备进行通信和控制。</p>
<p>GPIO接口可以作为输入或输出引脚使用。作为输入引脚时，GPIO可以接收来自外部设备的电信号，并将其转换为数字信号，供系统内部使用。作为输出引脚时，GPIO可以将数字信号发送到外部设备，从而实现对其的控制。</p>
<ol>
<li><p>引脚：GPIO接口通常由一组引脚组成，每个引脚都可以用作输入或输出。每个引脚都有一个唯一的标识符，如GPIO0、GPIO1等。</p>
</li>
<li><p>输入模式：当GPIO引脚配置为输入模式时，它可以接收外部设备发送的电信号。通常，输入引脚可以读取高电平（1）或低电平（0）状态，或者在某些系统中可以读取模拟信号。</p>
</li>
<li><p>输出模式：当GPIO引脚配置为输出模式时，它可以向外部设备发送数字信号。输出引脚可以设置为高电平（1）或低电平（0），以控制连接的设备的状态。</p>
</li>
<li><p>状态和电平：GPIO引脚的状态表示当前引脚的输入或输出电平。高电平通常表示逻辑1，低电平表示逻辑0。在某些系统中，还可以使用其他状态，如浮空、上拉和下拉等。</p>
</li>
<li><p>控制寄存器：<strong>为了配置和控制GPIO引脚的功能，通常需要通过写入特定的控制寄存器来设置引脚的模式、状态和电平。这些寄存器的具体配置取决于所使用的硬件平台和操作系统。</strong>【这个估计就是我们驱动要干的】</p>
</li>
</ol>
</blockquote>
<p>也就是意思就是，这个gpio相当于一个接口，能够把系统的信号传给硬件，也能把硬件信号传给系统。所以有时候我们可以通过读写其寄存器来与硬件交互。比如， GPIO每个引脚连接着一个led，那么我们通过读写gpio的控制寄存器，控制每个引脚输出1/0，就可以控制led灯亮or灭。</p>
<blockquote>
<p>GPIO的实际应用非常广泛，以下是一些常见的示例：</p>
<ol>
<li><p>控制LED：将GPIO引脚配置为输出模式，可以通过设置引脚的高低电平状态来<strong>控制</strong>LED的亮灭。</p>
</li>
<li><p>按钮输入：将GPIO引脚配置为输入模式，可以连接按钮或开关，并通过读取引脚的电平状态来<strong>检测</strong>按钮是否被按下或开关是否打开。</p>
</li>
<li><p>传感器接口：通过GPIO引脚，可以连接各种传感器，如温度传感器、湿度传感器、光照传感器等。传感器的<strong>输出</strong>信号可以通过读取GPIO引脚的状态来获取。</p>
</li>
<li><p>驱动电机：通过GPIO引脚，可以连接电机驱动器，并通过设置引脚的高低电平状态来<strong>控制</strong>电机的运行方向和速度。</p>
</li>
<li><p>与外部设备通信：通过GPIO引脚，可以与其他外部设备进行通信，如显示器、LCD屏幕、数码管等。通过设置引脚的状态和电平，可以<strong>发送数据或控制命令</strong>。</p>
</li>
<li><p>脉冲宽度调制（PWM）输出：一些GPIO引脚支持PWM功能，可以生成模拟信号，用于<strong>控制</strong>电机速度、调节LED亮度等需要模拟输出的应用。</p>
</li>
<li><p><strong>扩展IO功能：通过使用扩展芯片或GPIO扩展板，可以增加系统的GPIO引脚数量，从而实现更多外部设备的控制和通信。</strong></p>
</li>
</ol>
</blockquote>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><blockquote>
<p><strong>4 个 32 位 配 置 寄 存 器</strong></p>
<ol>
<li><p>GPIOx_MODER 模式寄存器</p>
<p>用于配置GPIO引脚的模式（<strong>输入或输出</strong>）。<u>每个引脚通常使用两个位表示模式</u>，例如00表示输入模式，01表示输出模式。</p>
</li>
<li><p>GPIOx_OTYPER 输出模式寄存器</p>
<p>用于配置GPIO引脚的输出类型。<u>每个引脚通常使用一个位表示输出类型</u>，例如0表示推挽输出，1表示开漏输出。</p>
</li>
<li><p>GPIOx_ OSPEEDR 输出速度寄存器</p>
<p>用于配置GPIO引脚的输出速度。<u>每个引脚通常使用两个位表示输出速度</u>，例如00表示低速，11表示高速。</p>
</li>
<li><p>GPIOx_PUPDR 上拉下拉寄存器</p>
<p>用于配置GPIO引脚的上拉或下拉电阻。<u>每个引脚通常使用两个位表示上拉/下拉配置</u>，例如00表示无上拉/下拉，01表示上拉，10表示下拉。</p>
</li>
</ol>
<p><strong>2 个 32 位数据寄存器</strong><br>GPIOx_IDR 输入数据寄存器<br>GPIOx_ODR 输出数据寄存器</p>
<p>每个位对应一个引脚，读取/写入该位。</p>
<p><strong>1个 32 位置位 / 复位寄存器</strong><br>GPIOx_BSRR 置位 / 复位寄存器</p>
<p>用于通过设置或复位位来控制GPIO引脚的输出电平。每个引脚通常使用两个位，一个位用于置位（设置为1），另一个位用于复位（设置为0）。</p>
<p><strong>2 个 32 位复用功能寄存器</strong><br>GPIOx_AFRH<br>GPIOx_AFRL</p>
<p>用于配置GPIO引脚的复用功能，例如将引脚用作特定的外设功能（如UART、SPI等）。这些寄存器通常将32位分为两个部分，每个部分对应一组引脚。</p>
</blockquote>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/612333717?utm_id=0">https://zhuanlan.zhihu.com/p/612333717?utm_id=0</a></p>
</blockquote>
<p><img src="/2023/10/27/driver_develop/v2-9ece20d4c5fb58bd9c9736a14e952403_1440w.webp" alt="v2-9ece20d4c5fb58bd9c9736a14e952403_1440w"></p>
<p>原来上下拉是这个意思啊，就是缺省值呗。</p>
<p>一般来说，开漏输出连接上拉输入或浮空输入的外部元件，推挽输出连接下拉输入的外部元件。</p>
<p>当引脚具有复用功能时，它可以在不同的工作模式下切换为不同的功能，而无需切换整个 GPIO 模式。</p>
<h4 id="找到测试程序"><a href="#找到测试程序" class="headerlink" title="找到测试程序"></a>找到测试程序</h4><p>感觉其实思路还是比较清晰。看这个：</p>
<blockquote>
<p><a href="https://milkv.io/zh/docs/duo/application-development/wiringx">https://milkv.io/zh/docs/duo/application-development/wiringx</a></p>
<p><a href="https://github.com/milkv-duo/duo-examples/blob/main/README-zh.md">https://github.com/milkv-duo/duo-examples/blob/main/README-zh.md</a></p>
</blockquote>
<p>也即我最后gpio的效果就是能够运行它给的这个blink example就行。等下回去试下用linux和rtt试试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> DUO_LED = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    rt_pin_mode(DUO_LED, PIN_MODE_OUTPUT);</span><br><span class="line">    rt_pin_write(DUO_LED, PIN_LOW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123; <span class="comment">// 闪烁十次</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;Duo LED GPIO (wiringX) %d: High\n&quot;</span>, DUO_LED);</span><br><span class="line">        rt_pin_write(DUO_LED, PIN_HIGH);</span><br><span class="line">        rt_thread_delay(RT_TICK_PER_SECOND);</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Duo LED GPIO (wiringX) %d: Low\n&quot;</span>, DUO_LED);</span><br><span class="line">        rt_pin_write(DUO_LED, PIN_LOW);</span><br><span class="line">        rt_thread_delay(RT_TICK_PER_SECOND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之明天试着开始写吧，我也不知道怎么办了该。可以先问下老师确认led是哪个。我看文档写的GPIOC24但是压根没那东西。</p>
<h3 id="10-14—找到型号"><a href="#10-14—找到型号" class="headerlink" title="10.14—找到型号"></a>10.14—找到型号</h3><p>感觉可以从相同型号的gpio入手。查了下compatible，这东西好像是什么海思研发的什么the synopsys DW gpio。</p>
<blockquote>
<p>/home/xiunian/rt-thread/milkv-duo-buildroot-sdk/linux_5.10/drivers/gpio/gpio-dwapb.c</p>
<p><a href="https://lkml.org/lkml/2020/8/22/19">https://lkml.org/lkml/2020/8/22/19</a> commit patch</p>
<p><a href="https://www.elecfans.com/d/2184124.html">Milk-V Duo开发板免费体验 GPIO分析</a></p>
<p><a href="https://blog.csdn.net/weixin_49457347/article/details/126146947">DesignWare_APB_GPIO模块DUT&amp;Testbench仿真</a></p>
<p><a href="https://blog.csdn.net/weixin_42703045/article/details/127778250">RK3399之8250串口驱动</a></p>
<p><a href="https://blog.csdn.net/qq_41696915/article/details/132173191">linux驱动 内核层适配485驱动控制引脚</a></p>
</blockquote>
<p>我现在发现了milkv的gpio型号是dwapb，找到了它对应的驱动手册【<code>DW_apb_gpio_databook</code> 浅看了下，里面至少有介绍寄存器是在干什么】，还有linux【<code>drivers/gpio/gpio-dwapb.c</code>  <code>drivers/gpio/gpio-pl061.c</code>】和rtt【<code>bsp/ft2004/libraries/bsp/ft_gpio/ft_gpio.c</code>】同一型号的驱动代码，我准备对照着这几个参考弄下</p>
<p>然后各个回调的介绍可以看<code>documentation/device/pin/pin.md</code>。</p>
<p>总之，不就是看寄存器都是啥东西，然后对应实现read write嘛！概念上是不难的，好好研究，相信可以！</p>
<p>接下来的思路就是，看下那几个寄存器具体的description，理解下两个参考的代码，就可以慢慢开始写了。测试可能需要再花点心思因为毕竟那个还跑步起来。。。总之方向算是比较明确了（至少比前几天明确）加油捏。</p>
<h3 id="10-15—寄存器了解"><a href="#10-15—寄存器了解" class="headerlink" title="10.15—寄存器了解"></a>10.15—寄存器了解</h3><p>这东西甚至是一个bit一个bit控制的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTA_DR		0x00 <span class="comment">//A 组端口输出寄存器</span></span></span><br><span class="line">写入该寄存器的值独立控制端口A中对应数据位的方向。<span class="number">0</span>是input，<span class="number">1</span>是output</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTA_DDR	0x04 <span class="comment">//A 组端口方向控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTB_DR		0x0c <span class="comment">//B 组端口输出寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTB_DDR	0x10 <span class="comment">//B 组端口方向控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTC_DR		0x18 <span class="comment">//C 组端口输出寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTC_DDR	0x1c <span class="comment">//C 组端口方向控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTD_DR		0x24 <span class="comment">//D 组端口输出寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORTD_DDR	0x28 <span class="comment">//D 组端口方向控制寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 这个东西可以用来控制每个bit的开关中断</span><br><span class="line"><span class="number">2.</span> 默认关中断</span><br><span class="line"><span class="number">3.</span> Output时关中断</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTEN		    0x30 <span class="comment">//A 组端口中断使能寄存器</span></span></span><br><span class="line">mask为<span class="number">1</span>表示屏蔽</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTMASK		0x34 <span class="comment">//A 组端口中断屏蔽寄存器</span></span></span><br><span class="line">控制是电平敏感中断还是边缘敏感</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTTYPE_LEVEL	0x38 <span class="comment">//A 组端口中断等级寄存器</span></span></span><br><span class="line">极性</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INT_POLARITY	0x3c <span class="comment">//A 组端口中断极性寄存器</span></span></span><br><span class="line">只读</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTSTATUS		0x40 <span class="comment">//A 组端口中断状态寄存器</span></span></span><br><span class="line">是否需要消抖【是不是很熟悉hhh】</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PORTA_DEBOUNCE	0x48 <span class="comment">//A 组端口防反跳配置寄存器</span></span></span><br><span class="line">清除A/所有中断</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PORTA_EOI		0x4c <span class="comment">//A 组端口中断清除寄存器</span></span></span><br><span class="line"></span><br><span class="line">只读，表示A端口连接的数据信号（也即input信号）</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_EXT_PORTA		0x50 <span class="comment">//A 组端口输入寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_EXT_PORTB		0x54 <span class="comment">//B 组端口输入寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_EXT_PORTC		0x58 <span class="comment">//C 组端口输入寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_EXT_PORTD		0x5c <span class="comment">//D 组端口输入寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DWAPB_DRIVER_NAME	<span class="string">&quot;gpio-dwapb&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DWAPB_MAX_PORTS		4</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 步长。可以看到如它所言，确实GPIO_EXT_PORT每个差4，GPIO_SWPORTA_DR和GPIO_SWPORTA_DDR每个差12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_EXT_PORT_STRIDE	0x04 <span class="comment">/* register stride 32 bits */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORT_DR_STRIDE	0x0c <span class="comment">/* register stride 3*32 bits */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORT_DDR_STRIDE	0x0c <span class="comment">/* register stride 3*32 bits */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_REG_OFFSET_V2	1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTMASK_V2		0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTTYPE_LEVEL_V2	0x34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INT_POLARITY_V2	0x38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTSTATUS_V2	0x3c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PORTA_EOI_V2	0x40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DWAPB_NR_CLOCKS		2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DWAPB_GPIO_BASE     0x03020000</span></span><br></pre></td></tr></table></figure>

<p>难道说，我有一个猜想，就是这个实际表示是说GPIO Port A/C的第16/17、9/10位吗。。。。</p>
<p><img src="/2023/10/27/driver_develop/image-20231027203332238.png" alt="image-20231027203332238"></p>
<p>所以现在很需要这个pin和port的转换。。。</p>
<p>一个是内核传过来的pin是什么数，还有它上面那个是不是端口和位的意思，这两点需要弄清楚</p>
<p>总之先向来是确认下我的想法：那个图的灰色块和引脚号是同一个东西，GPIOA17这样的字符表示GPIO的A端口寄存器的第16个bit。</p>
<p>如果是这样的话，那么思路就很自然了。我们可以通过图中引脚和GPIO这种的分布，从而得知当前是要写入什么端口什么寄存器，这样就能编写代码了。Good。</p>
<h3 id="10-17—整亮led"><a href="#10-17—整亮led" class="headerlink" title="10.17—整亮led"></a>10.17—整亮led</h3><p>也许可以搜一下schematic该怎么看，说不定就能知道哪位是引脚号了。</p>
<p>现在先假设GPIO C 24表示GPIO C端口的第24个bit，也即 (1&lt;&lt;23)吧。所以我们在读取和写入的时候，都是先读出原来的值，然后再把对应位设为1or0。但是为啥qemu是一字节一字节写。。。算了相信自己，总之先试试</p>
<blockquote>
<p>然后就去研究了下linux中的gpio……发现了其内部映射。</p>
</blockquote>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">~# cat <span class="regexp">/sys/</span><span class="keyword">class</span><span class="regexp">/gpio/g</span>piochip</span><br><span class="line">gpiochip352<span class="regexp">/  gpiochip384/</span>  gpiochip416<span class="regexp">/  gpiochip448/</span>  gpiochip480/</span><br></pre></td></tr></table></figure>

<p>384是GPIOD，416是C，448是B，480是A，每个间距32。而LED对应的是GPIO C 24，所以号是416+24 = 440。</p>
<p>416+24 = 440，也就是说，GPIOC24是port C的第24号，也即第25位。</p>
<blockquote>
<p>然后慢慢整理问题……</p>
</blockquote>
<p>整理一下目前的问题。</p>
<p>首先，我是不是想错了？？？</p>
<p>按照刚刚在Linux下看到的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ <span class="built_in">cat</span> /sys/class/gpio/gpiochip</span><br><span class="line">gpiochip352/  gpiochip384/  gpiochip416/  gpiochip448/  gpiochip480/</span><br></pre></td></tr></table></figure>

<p>五个gpio，bank name分别为porte、d、c、b、a。那么问题来了，这个port跟我们在dw_apb手册里看到的gpio的abcd四个port是一个概念吗？？</p>
<p>已知，dwapb gpio有ABCD四个Port，因而有四组寄存器。有一点值得注意，到底是一个字节控制一个设备，还是一个bit？</p>
<p>那么我感觉的是，板上有5个gpio，每个gpio都各自有4个port和4K地址空间，每个port都有这样一堆寄存器：</p>
<p><img src="/2023/10/27/driver_develop/image-20231027203540506.png" alt="image-20231027203540506"></p>
<p>而GPIOC24的意思就是，它是第四个gpio？port夺少？说实话我真的很迷惑。。。</p>
<p>而且我那个写入为什么一点效果没有。。。好痛苦我的天</p>
<p>好，刚刚终于成功把led整亮了。所以是这样的，它那个GPIOABCD并不是一个GPIO的Port ABCD的意思，应该就是纯纯有多个GPIO芯片。然后GPIOC24的意思就是第三块GPIO的A组寄存器第32位，为什么是A不是别的我也不大懂，反正我看了Linux的驱动代码，好像一般也是只用A组端口。</p>
<h3 id="10-18-19—中断"><a href="#10-18-19—中断" class="headerlink" title="10.18/19—中断"></a>10.18/19—中断</h3><p>很好，目前已经基本完成了数据的读写这部分，接下来要做的就是中断了，中断还是先看看数据手册在做。中断的话，决定先研究下wiringX的那个example，然后来看看中断怎么进行有效性验证。</p>
<p>很好，把测试程序搬了过来，还有学习了下qemu的架构也搬过来了，现在剩下的任务就是看寄存器了</p>
<p>目前是这样，<code>dwapb_pin_attach_irq</code>和<code>dwapb_pin_detach_irq</code>负责注册回调函数，<code>dwapb_pin_irq_enable</code>负责开关中断。然后，我们通过<code>rt_hw_interrupt_install(DWAPB_GPIOE_IRQNUM, rt_hw_gpio_isr, &amp;gpio_idx, &quot;gpio&quot;);</code>注册中断函数，这样一来每次DWAPB_GPIOE_IRQNUM中断时就会触发该函数，从而执行<code>rt_hw_gpio_isr</code>中遍历所有hdr并执行一遍的流程了。</p>
<p>整理一下它目前需要有哪些寄存器。首先是<code>rt_hw_gpio_isr</code>，需要有一个pending功能；然后是<code>dwapb_pin_attach_irq</code>，需要能设置是电平/边缘触发以及触发的极性；最后是<code>dwapb_pin_irq_enable</code>，需要有个能开关中断的寄存器。</p>
<p>目前是这样，理论上，我通过rt_pin_irq_enable向INTEN写入数据，这b对应的GPIO引脚就会产生一个中断，然后将中断传递给CPU，CPU通过其中断号从而调用中断处理函数，然后就吊我们在it_install中安装的那个回调。然而不知怎的没调。我觉得原因可能两个，一个寄存器看错了，另一个安装没装好。明天对照Linux源码看下吧。</p>
<p>应该不是，还是得靠外界输入才能触发中断。明天问问老师怎么做。</p>
<p>新进展，发现C9C10互连，然后C10间隔输出就行23333这样就可以触发中断，perfect。</p>
<p>不过我目前的问题似乎是，触发了中断之后，不知道为什么没有进入pending处理，导致中断一直未处理从而寄。</p>
<p>牛逼，成了！！！明天改下码风，多写几个测试，应该就结了。好像目前是both有点问题。明天把这个修下。</p>
<p><img src="/2023/10/27/driver_develop/image-20231027203706048.png" alt="image-20231027203706048"></p>
<p>BOTH_EDGE有点问题，好像那啥玩意没效果，依然保持着上次设置的lowedge。现在去学习下linux的both edge怎么写的。</p>
<p>很好，bug已除。</p>
<h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><p>GPIO实际上就是一个单纯的在板子和外设之间搬运字节的东西，所以本质上只需做好寄存器配置，以及引脚映射即可。接下来将从几个方面拆解我的代码。</p>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>在rtt中，提供了一系列回调函数用于实现gpio：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_pin_ops</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 设置gpio的模式（读/写）</span></span><br><span class="line">    <span class="type">void</span> (*pin_mode)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin, <span class="type">rt_uint8_t</span> mode);</span><br><span class="line">    <span class="comment">// 读写gpio</span></span><br><span class="line">    <span class="type">void</span> (*pin_write)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin, <span class="type">rt_uint8_t</span> value);</span><br><span class="line">    <span class="type">rt_int8_t</span>  (*pin_read)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin);</span><br><span class="line">    <span class="comment">// rtt特有中断回调，mode可以设置为电平/边缘触发，以及触发极性</span></span><br><span class="line">    <span class="type">rt_err_t</span> (*pin_attach_irq)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin,</span><br><span class="line">            <span class="type">rt_uint8_t</span> mode, <span class="type">void</span> (*hdr)(<span class="type">void</span> *args), <span class="type">void</span> *args);</span><br><span class="line">    <span class="type">rt_err_t</span> (*pin_detach_irq)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin);</span><br><span class="line">    <span class="type">rt_err_t</span> (*pin_irq_enable)(<span class="keyword">struct</span> rt_device *device, <span class="type">rt_base_t</span> pin, <span class="type">rt_uint8_t</span> enabled);</span><br><span class="line">    <span class="comment">// 引脚映射</span></span><br><span class="line">    <span class="type">rt_base_t</span> (*pin_get)(<span class="type">const</span> <span class="type">char</span> *name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>milkv上有ABCDE五个gpio组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">gpio@<span class="number">03020000</span> &#123;</span><br><span class="line">        bank-name = <span class="string">&quot;porta&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio@<span class="number">03021000</span> &#123;</span><br><span class="line">        bank-name = <span class="string">&quot;portb&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio@<span class="number">03022000</span> &#123;</span><br><span class="line">        bank-name = <span class="string">&quot;portc&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio@<span class="number">03023000</span> &#123;</span><br><span class="line">        bank-name = <span class="string">&quot;portd&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio@<span class="number">05021000</span> &#123;</span><br><span class="line">        bank-name = <span class="string">&quot;porte&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是，在实现中，这五个gpio组件会被注册为同一个设备，而不是像uart那样有多少个就注册多少个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_device_pin_register(<span class="string">&quot;gpio&quot;</span>, &amp;_dwapb_ops, RT_NULL);</span><br></pre></td></tr></table></figure>

<h3 id="外界交互"><a href="#外界交互" class="headerlink" title="外界交互"></a>外界交互</h3><p>应用程序会通过引脚名，使用<code>rt_pin_get</code>获取驱动内部自定义的引脚号，然后就可以通过引脚号对其进行模式设置和读写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> DUO_LED = rt_pin_get(<span class="string">&quot;C24&quot;</span>);</span><br><span class="line">rt_pin_mode(DUO_LED, PIN_MODE_OUTPUT);</span><br><span class="line">rt_pin_write(DUO_LED, PIN_LOW);</span><br></pre></td></tr></table></figure>

<h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>这坨宏我是从linux里搬过来的。各个寄存器的含义可以详见data book，在此不多赘述。</p>
<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>在rtt中，外设地址也是统一编址到内存地址空间的。由其它gpio实现可知，当开启<code>RT_USING_LWP</code>（轻量级进程支持）时，外设地址不再是一一映射，需要我们手动在init中调用<code>ioremap</code>进行映射：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_LWP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_IOREMAP_GPIO_DEVICE(no)     \</span></span><br><span class="line"><span class="meta">    rt_ioremap((void *)(DWAPB_GPIOA_BASE + (no) * DWAPB_GPIO_SIZE), DWAPB_GPIO_SIZE);</span></span><br><span class="line"></span><br><span class="line">    dwapb_gpio_base = (<span class="type">rt_size_t</span>)BSP_IOREMAP_GPIO_DEVICE(<span class="number">0</span>);</span><br><span class="line">    BSP_IOREMAP_GPIO_DEVICE(<span class="number">1</span>);</span><br><span class="line">    BSP_IOREMAP_GPIO_DEVICE(<span class="number">2</span>);</span><br><span class="line">    BSP_IOREMAP_GPIO_DEVICE(<span class="number">3</span>);</span><br><span class="line">    dwapb_gpio_base_e = (<span class="type">rt_size_t</span>)rt_ioremap((<span class="type">void</span> *)DWAPB_GPIOE_BASE, DWAPB_GPIO_SIZE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后，之后就可以在各个方法中借助这两个函数传入寄存器地址直接进行读写了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rt_inline <span class="type">rt_uint32_t</span> <span class="title function_">dwapb_read32</span><span class="params">(<span class="type">rt_ubase_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> HWREG32(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rt_inline <span class="type">void</span> <span class="title function_">dwapb_write32</span><span class="params">(<span class="type">rt_ubase_t</span> addr, <span class="type">rt_uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    HWREG32(addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HWREG32(x)          (*((volatile rt_uint32_t *)(x)))</span></span><br></pre></td></tr></table></figure>

<h3 id="引脚映射"><a href="#引脚映射" class="headerlink" title="引脚映射"></a>引脚映射</h3><p>摸索了半天，最终还是猜测这个引脚映射规定应该是自己决定的，于是我就从别的bsp那边把规则搬了过来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// port &amp;&amp; no -&gt; pin</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_NUM(port, no)   (((((port) &amp; 0xFu) &lt;&lt; 8) | ((no) &amp; 0xFFu)))</span></span><br><span class="line"><span class="comment">// pin -&gt; port</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_PORT(pin)       ((uint8_t)(((pin) &gt;&gt; 8) &amp; 0xFu))</span></span><br><span class="line"><span class="comment">// pin -&gt; no</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN_NO(pin)         ((uint8_t)((pin) &amp; 0xFFu))</span></span><br></pre></td></tr></table></figure>

<p>例如，“C24”就可转化为<code>(((((&#39;C&#39; - &#39;A&#39;) &amp; 0xFu) &lt;&lt; 8) | ((24) &amp; 0xFFu)))</code>。</p>
<p>根据此规则实现<code>get_pin</code>回调即可。具体板子上哪个引脚是哪个port，详见milkv的schematic book。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h4 id="回调执行"><a href="#回调执行" class="headerlink" title="回调执行"></a>回调执行</h4><p>rtt提供了很好用的中断回调。参考别的bsp以及以前的经验，很容易知道<code>attach_irq</code>和<code>detach_irq</code>就是注册和注销回调函数。那么，回调是什么时候被调用的呢？查阅其他bsp，也可得知它这是采取了一个非常巧妙的委托：在rtt给的<code>rt_hw_interrupt_install(DWAPB_GPIOE_IRQNUM, rt_hw_gpio_isr, RT_NULL, &quot;gpio&quot;);</code>注册的<code>rt_hw_gpio_isr</code>中做即可。这个层层外包的思想让我不禁想起Linux的调度类机制和用户态调度框架的实现原理，实在是牛逼至极。</p>
<p>为了记录所有回调签名，我们需要为每个gpio组件整一个数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dwapb_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*(hdr[DWAPB_GPIO_NR]))(<span class="type">void</span> *args);</span><br><span class="line">    <span class="type">void</span> *args[DWAPB_GPIO_NR];</span><br><span class="line">    <span class="type">rt_uint8_t</span> is_both_edge[DWAPB_GPIO_NR];</span><br><span class="line">&#125; _dwapb_events[DWAPB_GPIO_PORT_NR];</span><br></pre></td></tr></table></figure>

<p>在<code>rt_hw_gpio_isr</code>中：</p>
<ol>
<li>根据硬件寄存器判断是否发生中断</li>
<li>调用相应回调</li>
<li>清除中断位表明完成中断处理</li>
</ol>
<p>即可。</p>
<h4 id="both-edge实现"><a href="#both-edge实现" class="headerlink" title="both-edge实现"></a>both-edge实现</h4><p>这个是抄自linux。本质逻辑就是先设个上升沿触发，然后在<code>rt_hw_gpio_isr</code>执行完回调后再改成反方向也即下降沿触发，以此类推。不得不说确实帅。</p>
<h1 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h1><p>Wait todo…</p>
]]></content>
      <tags>
        <tag>intern</tag>
      </tags>
  </entry>
  <entry>
    <title>内核编译</title>
    <url>/2023/08/12/kernel_compile/</url>
    <content><![CDATA[<h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><p>安装内核编译所需包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install build-essential gcc g++ make libncurses5-dev libssl-dev bison flex bc libelf-dev</span><br></pre></td></tr></table></figure>

<p>生成内核编译配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make localmodconfig</span><br></pre></td></tr></table></figure>

<p>修改<code>.config</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim .config</span><br></pre></td></tr></table></figure>

<ol>
<li><p>删除系统吊销密钥</p>
<p>查找<code>CONFIG_PSI</code>，将其对应行修改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONFIG_SYSTEM_REVOCATION_KEYS=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>然后就可以进行内核编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j8 &amp;&amp; sudo make modules_install &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<h1 id="修改grub"><a href="#修改grub" class="headerlink" title="修改grub"></a>修改grub</h1><p>打开grub配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br></pre></td></tr></table></figure>

<p>进行以下修改：</p>
<ol>
<li>注释<code>GRUB_TIMEOUT_STYLE=hidden</code></li>
<li>将<code>GRUB_CMDLINE_LINUX_DEFAULT</code>设置为”text”</li>
<li>将<code>GRUB_TIMEOUT</code>修改成30</li>
</ol>
<p>然后保存退出，更新grub：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>

<h1 id="进入内核"><a href="#进入内核" class="headerlink" title="进入内核"></a>进入内核</h1><p>完成上述步骤后，重启虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<p>在进入GRUB界面时选择<code>Advanced Ubuntu</code>，然后选择内核版本6.4.0+即可。</p>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><ol>
<li><p>ALERT! root=UUIDxxx does not exist. Dropping to a shell!</p>
<p>因缺少磁盘驱动挂载文件系统失败</p>
</li>
<li><p>init进程启动失败，error code为-8</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Starting init: /sbin/init exists but couldn<span class="number">&#x27;</span>t execute <span class="title function_">it</span> <span class="params">(error <span class="number">-8</span>)</span></span><br><span class="line">然后init进程被杀死了，然后就进入BusyBox Shell</span><br></pre></td></tr></table></figure>

<p>最后发现是不知道为什么它将启动参数中的text误认为init进程的启动参数了，最后的解决方案是删掉启动参数里的text（具体方法可以看GRUB介绍部分，看完大概就懂了）</p>
</li>
<li><p>cannot set terminal proccess group(-1): Inappropriate ioctl for device.</p>
<p>不知道为啥重启下就好了。偶尔出现偶尔不出现，很奇怪</p>
</li>
<li><p>initrd.img Unable to mount root fs on Unknown-block(0,0)</p>
<p>最后发现好像是这个initrd.img损坏了，最后执行<code>mkinitramfs -o /boot/initrd.img-xxx</code>重新做了个initrd.img解决问题。</p>
</li>
<li><p>Kernel panic - not syncing: No working init found. Try passing init= option to kernel.</p>
<p>按它说的那样，在GRUB参数加个比方说<code>init=/bin/bash</code>就行了</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>网络与系统安全</title>
    <url>/2024/06/15/network_system_security/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p><img src="/2024/06/15/network_system_security/image-20240609230412322.png" alt="image-20240609230412322"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609230354811.png" alt="image-20240609230354811"></p>
<p><strong>计算机系统安全防护的基本原则</strong></p>
<p>整体性原则（木桶理论）、分层性、最小授权、简单性</p>
<p><img src="/2024/06/15/network_system_security/image-20240609230553438.png" alt="image-20240609230553438"></p>
<h1 id="2-物理安全"><a href="#2-物理安全" class="headerlink" title="2 物理安全"></a>2 物理安全</h1><p><strong>旁路攻击</strong></p>
<p>常见针对键盘的旁路攻击是通过硬件型键盘记录器。攻击者还可以利用键盘输入视频、按键手姿、按键声音、按键振动甚至按键温度获得键盘输入内容</p>
<p><img src="/2024/06/15/network_system_security/image-20240609230803234.png" alt="image-20240609230803234"></p>
<ol>
<li><p>数据中心</p>
<p>分级，ABC，电磁安全</p>
</li>
<li><p>PC</p>
<p><img src="/2024/06/15/network_system_security/image-20240609230920795.png" alt="image-20240609230920795"></p>
</li>
<li><p>移动</p>
<p><img src="/2024/06/15/network_system_security/image-20240609230957354.png" alt="image-20240609230957354"></p>
</li>
</ol>
<h1 id="3-操作系统安全"><a href="#3-操作系统安全" class="headerlink" title="3 操作系统安全"></a>3 操作系统安全</h1><p><img src="/2024/06/15/network_system_security/image-20240609231042296.png" alt="image-20240609231042296"></p>
<h2 id="主要安全机制"><a href="#主要安全机制" class="headerlink" title="主要安全机制"></a>主要安全机制</h2><p><img src="/2024/06/15/network_system_security/image-20240609231126685.png" alt="image-20240609231126685"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231140145.png" alt="image-20240609231140145"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231149076.png" alt="image-20240609231149076"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231204544.png" alt="image-20240609231204544"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231217360.png" alt="image-20240609231217360"></p>
<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p><strong>身份凭证信息</strong></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231302114.png" alt="image-20240609231302114"></p>
<p><strong>身份认证机制</strong></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231443166.png" alt="image-20240609231443166"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231505967.png" alt="image-20240609231505967"></p>
<p>如验证码、动态口令</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p><img src="/2024/06/15/network_system_security/image-20240609231552018.png" alt="image-20240609231552018"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231634037.png" alt="image-20240609231634037"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231643410.png" alt="image-20240609231643410"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231715814.png" alt="image-20240609231715814"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231740966.png" alt="image-20240609231740966"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231813369.png" alt="image-20240609231813369"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231858233.png" alt="image-20240609231858233"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609231911770.png" alt="image-20240609231911770"></p>
<h2 id="Windows系统安全"><a href="#Windows系统安全" class="headerlink" title="Windows系统安全"></a>Windows系统安全</h2><p><img src="/2024/06/15/network_system_security/image-20240609232048001.png" alt="image-20240609232048001"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609232115672.png" alt="image-20240609232115672"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609232137753.png" alt="image-20240609232137753"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609232149313.png" alt="image-20240609232149313"></p>
<h2 id="Linux系统安全"><a href="#Linux系统安全" class="headerlink" title="Linux系统安全"></a>Linux系统安全</h2><p><img src="/2024/06/15/network_system_security/image-20240609232414156.png" alt="image-20240609232414156"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609232425757.png" alt="image-20240609232425757"></p>
<h1 id="4-数据库安全"><a href="#4-数据库安全" class="headerlink" title="4 数据库安全"></a>4 数据库安全</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p><img src="/2024/06/15/network_system_security/image-20240609232713141.png" alt="image-20240609232713141"></p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p><img src="/2024/06/15/network_system_security/image-20240609232725237.png" alt="image-20240609232725237"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609232748848.png" alt="image-20240609232748848"></p>
<h2 id="访问控制-1"><a href="#访问控制-1" class="headerlink" title="访问控制"></a>访问控制</h2><p><img src="/2024/06/15/network_system_security/image-20240609232804787.png" alt="image-20240609232804787"></p>
<p>用户认证、访问控制、加密存储</p>
<p><img src="/2024/06/15/network_system_security/image-20240609232843383.png" alt="image-20240609232843383"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609232851040.png" alt="image-20240609232851040"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609232900453.png" alt="image-20240609232900453"></p>
<h2 id="完整性控制"><a href="#完整性控制" class="headerlink" title="完整性控制"></a>完整性控制</h2><p><img src="/2024/06/15/network_system_security/image-20240609232938287.png" alt="image-20240609232938287"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609232953381.png" alt="image-20240609232953381"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233011532.png" alt="image-20240609233011532"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233022591.png" alt="image-20240609233022591"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233044829.png" alt="image-20240609233044829"></p>
<h2 id="可用性保护"><a href="#可用性保护" class="headerlink" title="可用性保护"></a>可用性保护</h2><p>备份与恢复</p>
<p><img src="/2024/06/15/network_system_security/image-20240609233110669.png" alt="image-20240609233110669"></p>
<p>入侵容忍</p>
<h2 id="可控性实现"><a href="#可控性实现" class="headerlink" title="可控性实现"></a>可控性实现</h2><p>审计、可信记录保持</p>
<h2 id="隐私性保护"><a href="#隐私性保护" class="headerlink" title="隐私性保护"></a>隐私性保护</h2><p><img src="/2024/06/15/network_system_security/image-20240609233220144.png" alt="image-20240609233220144"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233241254.png" alt="image-20240609233241254"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233255780.png" alt="image-20240609233255780"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233304628.png" alt="image-20240609233304628"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233311243.png" alt="image-20240609233311243"></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h2 id="隐私性质"><a href="#隐私性质" class="headerlink" title="隐私性质"></a>隐私性质</h2><p>请判断下述匿名方式满足哪些隐私性质？</p>
<p><img src="/2024/06/15/network_system_security/image-20240611161038477.png" alt="image-20240611161038477"></p>
<p>答：对于年龄、性别、和居住地三个属性具有 2-匿名性和 2-多样化性质。</p>
<p><img src="/2024/06/15/network_system_security/image-20240609233311243-1718525061797-1.png" alt="image-20240609233311243"></p>
<ol>
<li><p>k-匿名</p>
<p>在一个数据集中，任何一条记录（即任何一个人的信息）都应该至少与K-1条其他记录在<strong>某些属性上</strong>是不可区分的。这些属性通常被称为“准标识符”（quasi-identifiers），它们可能包括年龄、性别、邮政编码等，这些属性单独可能不足以识别个人，但组合起来可能就足以识别出特定的个体。</p>
<p><strong>大白话来讲就是给定属性组合，每条记录都得有重复记录，然后最少k条重复记录就是k+1邻近。</strong>然后给定属性组合就叫<strong>准标识符</strong>，有点类似于数据库的主码。</p>
<p>在该例子中，年龄、性别、和居住地三个属性具有 2-匿名性。</p>
</li>
<li><p>l-多样化</p>
<p>在一个数据集中，对于任意准标识符的组合，组内至少存在L种不同的敏感属性值。这意味着，即使攻击者能够通过准标识符确定一个记录属于某个组，他们也无法确定该记录的敏感属性值。</p>
<p><strong>大白话来讲就是标识符对应的数据一样的记录，他们有几种别的数据不一样的。</strong></p>
<p>在该例子中有2有3，所以取2-多样性。</p>
</li>
<li><p>t-邻近</p>
<p>在一个数据集中，对于任意准标识符的组合，组内敏感属性的分布应与整个数据集中敏感属性的分布相似到一定的程度。具体来说，两个分布之间的差异度量应小于一个阈值T。</p>
<p><strong>反正就是题目会给一个阈值T，然后先求总体的分布，然后求每一组内的分部，如果比总体的大就减一下然后除以总体的，看看有没有超过阈值</strong></p>
<p><img src="/2024/06/15/network_system_security/image-20240611162248451.png" alt="image-20240611162248451"></p>
</li>
</ol>
<h1 id="5-应用系统安全"><a href="#5-应用系统安全" class="headerlink" title="5 应用系统安全"></a>5 应用系统安全</h1><h2 id="软件漏洞"><a href="#软件漏洞" class="headerlink" title="软件漏洞"></a>软件漏洞</h2><p><img src="/2024/06/15/network_system_security/image-20240609233422340.png" alt="image-20240609233422340"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233439416.png" alt="image-20240609233439416"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233453167.png" alt="image-20240609233453167"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233500756.png" alt="image-20240609233500756"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233508578.png" alt="image-20240609233508578"></p>
<h3 id="栈缓冲区溢出"><a href="#栈缓冲区溢出" class="headerlink" title="栈缓冲区溢出"></a>栈缓冲区溢出</h3><p><img src="/2024/06/15/network_system_security/image-20240609233532841.png" alt="image-20240609233532841"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233540963.png" alt="image-20240609233540963"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233547519.png" alt="image-20240609233547519"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233604401.png" alt="image-20240609233604401"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233613266.png" alt="image-20240609233613266"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233623254.png" alt="image-20240609233623254"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233629821.png" alt="image-20240609233629821"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233635069.png" alt="image-20240609233635069"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233642756.png" alt="image-20240609233642756"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233649205.png" alt="image-20240609233649205"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233656014.png" alt="image-20240609233656014"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233716777.png" alt="image-20240609233716777"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233725805.png" alt="image-20240609233725805"></p>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p><img src="/2024/06/15/network_system_security/image-20240609233742881.png" alt="image-20240609233742881"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233753050.png" alt="image-20240609233753050"></p>
<h2 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h2><p><img src="/2024/06/15/network_system_security/image-20240610213227383.png" alt="image-20240610213227383"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233805289.png" alt="image-20240609233805289"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233815486.png" alt="image-20240609233815486"></p>
<ol>
<li><p>计算机病毒</p>
<p><img src="/2024/06/15/network_system_security/image-20240609233825576.png" alt="image-20240609233825576"></p>
</li>
<li><p>蠕虫</p>
<p><img src="/2024/06/15/network_system_security/image-20240609233850825.png" alt="image-20240609233850825"></p>
</li>
<li><p>木马</p>
<p><img src="/2024/06/15/network_system_security/image-20240609233905567.png" alt="image-20240609233905567"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233917255.png" alt="image-20240609233917255"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609233934254.png" alt="image-20240609233934254"></p>
</li>
<li><p>后门</p>
<p><img src="/2024/06/15/network_system_security/image-20240609233957070.png" alt="image-20240609233957070"></p>
<p>所以有开发者为了调试设置的后门</p>
</li>
<li><p>rootkit</p>
<p>木马后门工具获取root</p>
</li>
<li><p>恶意脚本</p>
</li>
<li><p>勒索软件</p>
</li>
</ol>
<p><img src="/2024/06/15/network_system_security/image-20240609234055789.png" alt="image-20240609234055789"></p>
<h2 id="软件侵权"><a href="#软件侵权" class="headerlink" title="软件侵权"></a>软件侵权</h2><p><img src="/2024/06/15/network_system_security/image-20240609234107740.png" alt="image-20240609234107740"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609234121499.png" alt="image-20240609234121499"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609234132618.png" alt="image-20240609234132618"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609234142475.png" alt="image-20240609234142475"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609234151241.png" alt="image-20240609234151241"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609234202600.png" alt="image-20240609234202600"></p>
<p><img src="/2024/06/15/network_system_security/image-20240609234210768.png" alt="image-20240609234210768"></p>
<h2 id="软件安全开发模型"><a href="#软件安全开发模型" class="headerlink" title="软件安全开发模型"></a>软件安全开发模型</h2><p><img src="/2024/06/15/network_system_security/image-20240610000419882.png" alt="image-20240610000419882"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000431638.png" alt="image-20240610000431638"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000437938.png" alt="image-20240610000437938"></p>
<h2 id="软件可信验证"><a href="#软件可信验证" class="headerlink" title="软件可信验证"></a>软件可信验证</h2><p>FICE</p>
<p><img src="/2024/06/15/network_system_security/image-20240610000501294.png" alt="image-20240610000501294"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000513994.png" alt="image-20240610000513994"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000522944.png" alt="image-20240610000522944"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000532652.png" alt="image-20240610000532652"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000556834.png" alt="image-20240610000556834"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000604798.png" alt="image-20240610000604798"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000656938.png" alt="image-20240610000656938"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000717806.png" alt="image-20240610000717806"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000729760.png" alt="image-20240610000729760"></p>
<h2 id="知识产权保护"><a href="#知识产权保护" class="headerlink" title="知识产权保护"></a>知识产权保护</h2><p><img src="/2024/06/15/network_system_security/image-20240610000801372.png" alt="image-20240610000801372"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000808023.png" alt="image-20240610000808023"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000819119.png" alt="image-20240610000819119"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000854314.png" alt="image-20240610000854314"></p>
<p>（你们二次元）</p>
<p><img src="/2024/06/15/network_system_security/image-20240610000915105.png" alt="image-20240610000915105"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610000927699.png" alt="image-20240610000927699"></p>
<h1 id="6-应急响应灾备恢复"><a href="#6-应急响应灾备恢复" class="headerlink" title="6 应急响应灾备恢复"></a>6 应急响应灾备恢复</h1><h2 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h2><p><img src="/2024/06/15/network_system_security/image-20240610001048833.png" alt="image-20240610001048833"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001055898.png" alt="image-20240610001055898"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001102588.png" alt="image-20240610001102588"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001108807.png" alt="image-20240610001108807"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001116833.png" alt="image-20240610001116833"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001124841.png" alt="image-20240610001124841"></p>
<h2 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h2><p><img src="/2024/06/15/network_system_security/image-20240610001155537.png" alt="image-20240610001155537"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001202726.png" alt="image-20240610001202726"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001212210.png" alt="image-20240610001212210"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001239477.png" alt="image-20240610001239477"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001250401.png" alt="image-20240610001250401"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001256480.png" alt="image-20240610001256480"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001318596.png" alt="image-20240610001318596"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610001325023.png" alt="image-20240610001325023"></p>
<h1 id="7-系统安全风险评估和管理"><a href="#7-系统安全风险评估和管理" class="headerlink" title="7 系统安全风险评估和管理"></a>7 系统安全风险评估和管理</h1><p><img src="/2024/06/15/network_system_security/image-20240610200506710.png" alt="image-20240610200506710"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610200801584.png" alt="image-20240610200801584"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610200811659.png" alt="image-20240610200811659"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201835343.png" alt="image-20240610201835343"></p>
<h1 id="8-密码学"><a href="#8-密码学" class="headerlink" title="8 密码学"></a>8 密码学</h1><h1 id="9-网络脆弱性分析"><a href="#9-网络脆弱性分析" class="headerlink" title="9 网络脆弱性分析"></a>9 网络脆弱性分析</h1><p><img src="/2024/06/15/network_system_security/image-20240610200923094.png" alt="image-20240610200923094"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610200934633.png" alt="image-20240610200934633"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610200943432.png" alt="image-20240610200943432"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610200956036.png" alt="image-20240610200956036"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201010902.png" alt="image-20240610201010902"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201031394.png" alt="image-20240610201031394"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201100066.png" alt="image-20240610201100066"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201111982.png" alt="image-20240610201111982"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201133046.png" alt="image-20240610201133046"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201318044.png" alt="image-20240610201318044"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201326573.png" alt="image-20240610201326573"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201343967.png" alt="image-20240610201343967"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201417045.png" alt="image-20240610201417045"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201430873.png" alt="image-20240610201430873"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201511078.png" alt="image-20240610201511078"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201520313.png" alt="image-20240610201520313"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610201535038.png" alt="image-20240610201535038"></p>
<h1 id="10-网络扫描技术"><a href="#10-网络扫描技术" class="headerlink" title="10 网络扫描技术"></a>10 网络扫描技术</h1><p>这部分还挺有意思的</p>
<p><img src="/2024/06/15/network_system_security/image-20240610202634572.png" alt="image-20240610202634572"></p>
<h2 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h2><p><img src="/2024/06/15/network_system_security/image-20240610202702749.png" alt="image-20240610202702749"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610202723906.png" alt="image-20240610202723906"></p>
<p>所以可以用ip数据包扫描</p>
<p><img src="/2024/06/15/network_system_security/image-20240610202808695.png" alt="image-20240610202808695"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610202819632.png" alt="image-20240610202819632"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610202837627.png" alt="image-20240610202837627"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610202859902.png" alt="image-20240610202859902"></p>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="/2024/06/15/network_system_security/image-20240610202942952.png" alt="image-20240610202942952"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610202952264.png" alt="image-20240610202952264"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203012397.png" alt="image-20240610203012397"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203023525.png" alt="image-20240610203023525"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203043952.png" alt="image-20240610203043952"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203051008.png" alt="image-20240610203051008"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203102400.png" alt="image-20240610203102400"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203110722.png" alt="image-20240610203110722"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203128141.png" alt="image-20240610203128141"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203148812.png" alt="image-20240610203148812"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203221319.png" alt="image-20240610203221319"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203228087.png" alt="image-20240610203228087"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203246263.png" alt="image-20240610203246263"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203305324.png" alt="image-20240610203305324"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203315381.png" alt="image-20240610203315381"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203328335.png" alt="image-20240610203328335"></p>
<h2 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h2><p><img src="/2024/06/15/network_system_security/image-20240610203413086.png" alt="image-20240610203413086"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203433026.png" alt="image-20240610203433026"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203502983.png" alt="image-20240610203502983"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203518561.png" alt="image-20240610203518561"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203533076.png" alt="image-20240610203533076"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203553508.png" alt="image-20240610203553508"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203612269.png" alt="image-20240610203612269"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203619753.png" alt="image-20240610203619753"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203629843.png" alt="image-20240610203629843"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203639249.png" alt="image-20240610203639249"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203651619.png" alt="image-20240610203651619"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203703701.png" alt="image-20240610203703701"></p>
<h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><p><img src="/2024/06/15/network_system_security/image-20240610203739062.png" alt="image-20240610203739062"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203758587.png" alt="image-20240610203758587"></p>
<h1 id="11-拒绝服务攻击"><a href="#11-拒绝服务攻击" class="headerlink" title="11 拒绝服务攻击"></a>11 拒绝服务攻击</h1><p><img src="/2024/06/15/network_system_security/image-20240610203834997.png" alt="image-20240610203834997"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610203902603.png" alt="image-20240610203902603"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610204041041.png" alt="image-20240610204041041"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610211919828.png" alt="image-20240610211919828"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610211928100.png" alt="image-20240610211928100"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610211948275.png" alt="image-20240610211948275"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212013218.png" alt="image-20240610212013218"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212052267.png" alt="image-20240610212052267"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212100313.png" alt="image-20240610212100313"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212348292.png" alt="image-20240610212348292"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212547376.png" alt="image-20240610212547376"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212610756.png" alt="image-20240610212610756"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212634349.png" alt="image-20240610212634349"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212659674.png" alt="image-20240610212659674"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212709511.png" alt="image-20240610212709511"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212836479.png" alt="image-20240610212836479"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212851103.png" alt="image-20240610212851103"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212900309.png" alt="image-20240610212900309"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212917965.png" alt="image-20240610212917965"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610212942459.png" alt="image-20240610212942459"></p>
<h1 id="12-计算机木马"><a href="#12-计算机木马" class="headerlink" title="12 计算机木马"></a>12 计算机木马</h1><p><img src="/2024/06/15/network_system_security/image-20240610213025322.png" alt="image-20240610213025322"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610213101131.png" alt="image-20240610213101131"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610213127891.png" alt="image-20240610213127891"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610213136477.png" alt="image-20240610213136477"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610213151167.png" alt="image-20240610213151167"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610213202561.png" alt="image-20240610213202561"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610213418044.png" alt="image-20240610213418044"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610213428089.png" alt="image-20240610213428089"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610213445297.png" alt="image-20240610213445297"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610213607095.png" alt="image-20240610213607095"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610213839697.png" alt="image-20240610213839697"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610213956991.png" alt="image-20240610213956991"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214025008.png" alt="image-20240610214025008"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214044261.png" alt="image-20240610214044261"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214101699.png" alt="image-20240610214101699"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214113203.png" alt="image-20240610214113203"></p>
<h1 id="13-网络监听技术"><a href="#13-网络监听技术" class="headerlink" title="13 网络监听技术"></a>13 网络监听技术</h1><p><img src="/2024/06/15/network_system_security/image-20240610214231930.png" alt="image-20240610214231930"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214256755.png" alt="image-20240610214256755"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214312405.png" alt="image-20240610214312405"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214421519.png" alt="image-20240610214421519"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214439063.png" alt="image-20240610214439063"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214607834.png" alt="image-20240610214607834"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214553245.png" alt="image-20240610214553245"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214634452.png" alt="image-20240610214634452"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214701164.png" alt="image-20240610214701164"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214734297.png" alt="image-20240610214734297"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214750667.png" alt="image-20240610214750667"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214915908.png" alt="image-20240610214915908"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214924660.png" alt="image-20240610214924660"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610214938240.png" alt="image-20240610214938240"></p>
<h1 id="14-缓冲区溢出攻击"><a href="#14-缓冲区溢出攻击" class="headerlink" title="14 缓冲区溢出攻击"></a>14 缓冲区溢出攻击</h1><p><img src="/2024/06/15/network_system_security/image-20240610215828837.png" alt="image-20240610215828837"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610215840547.png" alt="image-20240610215840547"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610215856993.png" alt="image-20240610215856993"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221305014.png" alt="image-20240610221305014"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221332861.png" alt="image-20240610221332861"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221355512.png" alt="image-20240610221355512"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221548409.png" alt="image-20240610221548409"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221555804.png" alt="image-20240610221555804"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221613750.png" alt="image-20240610221613750"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221629903.png" alt="image-20240610221629903"></p>
<h1 id="15-防火墙"><a href="#15-防火墙" class="headerlink" title="15 防火墙"></a>15 防火墙</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/2024/06/15/network_system_security/image-20240610221657980.png" alt="image-20240610221657980"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221749206.png" alt="image-20240610221749206"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221705565.png" alt="image-20240610221705565"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221712126.png" alt="image-20240610221712126"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221718683.png" alt="image-20240610221718683"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221726870.png" alt="image-20240610221726870"></p>
<h2 id="网络防火墙"><a href="#网络防火墙" class="headerlink" title="网络防火墙"></a>网络防火墙</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/2024/06/15/network_system_security/image-20240610221843806.png" alt="image-20240610221843806"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221856205.png" alt="image-20240610221856205"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221924764.png" alt="image-20240610221924764"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610221942356.png" alt="image-20240610221942356"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610222013281.png" alt="image-20240610222013281"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610222234020.png" alt="image-20240610222234020"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610222304479.png" alt="image-20240610222304479"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610222312601.png" alt="image-20240610222312601"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610222354248.png" alt="image-20240610222354248"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610222408539.png" alt="image-20240610222408539"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610222426385.png" alt="image-20240610222426385"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610222444239.png" alt="image-20240610222444239"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610223813352.png" alt="image-20240610223813352"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610223828314.png" alt="image-20240610223828314"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610223839838.png" alt="image-20240610223839838"></p>
<p>实时性差</p>
<p><img src="/2024/06/15/network_system_security/image-20240610223724360.png" alt="image-20240610223724360"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610223748552.png" alt="image-20240610223748552"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610223917407.png" alt="image-20240610223917407"></p>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><img src="/2024/06/15/network_system_security/image-20240610224051735.png" alt="image-20240610224051735"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224519541.png" alt="image-20240610224519541"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224114005.png" alt="image-20240610224114005"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224121466.png" alt="image-20240610224121466"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224147415.png" alt="image-20240610224147415"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224205334.png" alt="image-20240610224205334"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224215854.png" alt="image-20240610224215854"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224255136.png" alt="image-20240610224255136"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224320307.png" alt="image-20240610224320307"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224330831.png" alt="image-20240610224330831"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224345178.png" alt="image-20240610224345178"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224403439.png" alt="image-20240610224403439"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224432886.png" alt="image-20240610224432886"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224451338.png" alt="image-20240610224451338"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224458520.png" alt="image-20240610224458520"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224508346.png" alt="image-20240610224508346"></p>
<h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p><img src="/2024/06/15/network_system_security/image-20240610224535296.png" alt="image-20240610224535296"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224543413.png" alt="image-20240610224543413"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224604984.png" alt="image-20240610224604984"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224620743.png" alt="image-20240610224620743"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224634535.png" alt="image-20240610224634535"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224645372.png" alt="image-20240610224645372"></p>
<h3 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h3><p><img src="/2024/06/15/network_system_security/image-20240610224701993.png" alt="image-20240610224701993"></p>
<p>➢吞吐量是指在保证不丢失数据帧的情况下，设备能够接受的最大速率。</p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p><img src="/2024/06/15/network_system_security/image-20240610224957396.png" alt="image-20240610224957396"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224752718.png" alt="image-20240610224752718"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224806266.png" alt="image-20240610224806266"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224812757.png" alt="image-20240610224812757"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224831213.png" alt="image-20240610224831213"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224845628.png" alt="image-20240610224845628"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224852150.png" alt="image-20240610224852150"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610224902485.png" alt="image-20240610224902485"></p>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p><img src="/2024/06/15/network_system_security/image-20240610222202852.png" alt="image-20240610222202852"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610222051194.png" alt="image-20240610222051194"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610222029877.png" alt="image-20240610222029877"></p>
<h1 id="16-入侵检测与网络欺骗"><a href="#16-入侵检测与网络欺骗" class="headerlink" title="16 入侵检测与网络欺骗"></a>16 入侵检测与网络欺骗</h1><p>可以弥补防火墙缺点，一起使用</p>
<p><img src="/2024/06/15/network_system_security/image-20240610225051449.png" alt="image-20240610225051449"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610225116672.png" alt="image-20240610225116672"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610225150271.png" alt="image-20240610225150271"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610225810807.png" alt="image-20240610225810807"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610225830007.png" alt="image-20240610225830007"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610225850625.png" alt="image-20240610225850625"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610225905457.png" alt="image-20240610225905457"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230040337.png" alt="image-20240610230040337"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230111410.png" alt="image-20240610230111410"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230122034.png" alt="image-20240610230122034"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230130698.png" alt="image-20240610230130698"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230155031.png" alt="image-20240610230155031"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230210908.png" alt="image-20240610230210908"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230230525.png" alt="image-20240610230230525"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230247131.png" alt="image-20240610230247131"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230255924.png" alt="image-20240610230255924"></p>
<h1 id="17-AI安全"><a href="#17-AI安全" class="headerlink" title="17 AI安全"></a>17 AI安全</h1><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p><img src="/2024/06/15/network_system_security/image-20240610230401186.png" alt="image-20240610230401186"></p>
<p>准确率较低</p>
<p><img src="/2024/06/15/network_system_security/image-20240610230418286.png" alt="image-20240610230418286"></p>
<p>什么LRU-K</p>
<p><img src="/2024/06/15/network_system_security/image-20240610230438792.png" alt="image-20240610230438792"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230529459.png" alt="image-20240610230529459"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230521001.png" alt="image-20240610230521001"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230555492.png" alt="image-20240610230555492"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230615416.png" alt="image-20240610230615416"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230639103.png" alt="image-20240610230639103"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230649613.png" alt="image-20240610230649613"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230701191.png" alt="image-20240610230701191"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230739233.png" alt="image-20240610230739233"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230726925.png" alt="image-20240610230726925"></p>
<p>神经网络相比于线性分类语义更丰富了，因为可以是弯的</p>
<p><img src="/2024/06/15/network_system_security/image-20240610230817224.png" alt="image-20240610230817224"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230823850.png" alt="image-20240610230823850"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230836710.png" alt="image-20240610230836710"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230842913.png" alt="image-20240610230842913"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610230852645.png" alt="image-20240610230852645"></p>
<h2 id="AI安全"><a href="#AI安全" class="headerlink" title="AI安全"></a>AI安全</h2><p><img src="/2024/06/15/network_system_security/image-20240610231018735.png" alt="image-20240610231018735"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231115089.png" alt="image-20240610231115089"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231130830.png" alt="image-20240610231130830"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231154164.png" alt="image-20240610231154164"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231202217.png" alt="image-20240610231202217"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231211870.png" alt="image-20240610231211870"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231217067.png" alt="image-20240610231217067"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231238589.png" alt="image-20240610231238589"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231253847.png" alt="image-20240610231253847"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231309617.png" alt="image-20240610231309617"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231332580.png" alt="image-20240610231332580"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231344679.png" alt="image-20240610231344679"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231350256.png" alt="image-20240610231350256"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231356956.png" alt="image-20240610231356956"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231404149.png" alt="image-20240610231404149"></p>
<p><img src="/2024/06/15/network_system_security/image-20240610231410881.png" alt="image-20240610231410881"></p>
]]></content>
  </entry>
  <entry>
    <title>开源的第一个月</title>
    <url>/2023/10/19/open-source-9.19-10.19/</url>
    <content><![CDATA[<!--

# 引言

也许有许多programer与我一样，在初次接触到“开源”这个概念时，便对其产生了无限的向往。千万人通过共同的事业联结在一起，为了行业的进步不求回报地压缩自己的时间，贡献出自己的一份力，这是何等的浪漫。再加上听了无数遍的Linux发展历程故事，对“开源”我是愈发地憧憬。

然而，由于学习cs的时间尚不足，也不知道该从何入手去参与社区贡献，尽管心中怀有对参与这份事业的渴望，我还是会“望而却步”。转折点在今年参加竞赛时，在使用某个开源项目时因为遇到了一点问题而去提了个issue。虽然这个问题本质很傻，但在与开发者你来我往的交流中，我深切地感受到自己仿佛离憧憬更近了一步。因而，在今年竞赛结束后的九月，我毫不犹豫地向PLCT Lab提交了简历，试图追逐那个长存我心的幻影。

而现在，距离第一次提issue已有半年，距离考核通过也已有一个半月之久，我想也是时候好好总结一下我这一个月以来的心路历程了。
-->


<h1 id="我的第一个月"><a href="#我的第一个月" class="headerlink" title="我的第一个月"></a>我的第一个月</h1><blockquote>
<p>从9.10过审核开始写了很久的日报，当然除了实习还包括别的内容：</p>
<p><img src="/2023/10/19/open-source-9.19-10.19/image-20231019155950614.png" alt="image-20231019155950614"></p>
</blockquote>
<p>这一个月以来，我学到了很多东西，学习周期大致可分为三个阶段：初步了解rtt和配置环境、设备树学习以及最后的gpio driver开发。</p>
<h2 id="rtt"><a href="#rtt" class="headerlink" title="rtt"></a>rtt</h2><p>由于时间有限，所以仅对rtt的标准版本做了一个比较基本的了解（也就是说没有太涉及到源码部分，只能说是对文档中心的那些对外开发用接口有一定的了解）。rtt是一个微内核的RTOS，这与以前所接触的Linux和xv6都不同。由于RTOS的特性，它的许多设计都十分精简，相比于Linux可谓”麻雀虽小五脏俱全“。</p>
<p>对rtt的基本介绍，详情可见其<a href="https://www.rt-thread.org/document/site/#/">文档中心</a>。我印象最深（也是开发过程中接触得最多的）的几个点有：</p>
<ol>
<li><p>接口设计</p>
<p>与Linux一样，rtt也采用了精简的接口设计。</p>
</li>
<li><p>自动初始化机制</p>
<p>帅的一匹，具体详见<a href="https://xiunianjun.github.io/2023/09/18/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/#:~:text=%E5%B0%B1%E8%A1%8C%E4%BA%86-,%E5%90%8E%E6%97%A5%E8%B0%88,-%EF%BC%9A%E4%BB%8A%E5%A4%A9%E5%8F%88%E5%9C%A8rtt">此</a>。</p>
</li>
</ol>
<p>其余的只能说不甚了解，还有待挖掘。</p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>由于确实对这种东西毫无所知，所以配环境这个过程也是比较漫长，而且很折磨很痛苦（。</p>
<p>硬件方面，一开始拿到IO-board连这是啥都不知道，还以为这就是开发板研究了半天怎么上电和把内核烧进去（（（。然后东西也是买得缺斤少两，比如拿到开发板不知道还要有TF卡，上网搜图研究了半天才意识到；再比如也没有USB-TTL，又是一通淘宝购物。这些各种各样的小白问题导致配环境的周期十分漫长。然后还有一些很傻的错误，再次也不好意思多说了，详情可见<a href="https://xiunianjun.github.io/2023/10/12/rtt%E7%A1%AC%E4%BB%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">rtt硬件环境搭建</a>。</p>
<p>软件方面倒是没什么问题，之前也早就跟编译内核用的menuconfig打过很多交道，磁盘分区之类的东西之前也简单使过几次，只不过经过这次后也算是使得更加熟练了。</p>
<h2 id="设备树学习"><a href="#设备树学习" class="headerlink" title="设备树学习"></a>设备树学习</h2><blockquote>
<p>TODO，这部分还是比较多好写的，虽然还是有点模糊（待我之后有时间整理下放个链接</p>
</blockquote>
<p>设备树还是比较复杂，而且因为本人的不审慎，导致对其理解出了偏差，还麻烦了社区看我的代码（悲）只能说个人出道的开源社区还是需要对自己的所有笔代码负责。</p>
<h2 id="gpio-driver"><a href="#gpio-driver" class="headerlink" title="gpio driver"></a>gpio driver</h2><blockquote>
<p>pr：</p>
<p><img src="/2023/10/19/open-source-9.19-10.19/image-20231021105306299.png" alt="image-20231021105306299"></p>
<p>涉及到的各种硬件手册：</p>
<p><img src="/2023/10/19/open-source-9.19-10.19/image-20231019165451893.png" alt="image-20231019165451893"></p>
</blockquote>
<p>这也是我最后这一周在做的工作，虽说只有短短一周，但是每天都研究这个花了我不少时间和精力（）目前算是写完了它的所有功能（大概），并且已经能把LED闪烁和中断绑定函数润起来了，<a href="https://github.com/RT-Thread/rt-thread/pull/8158">提的pr在这里</a>。</p>
<p>以前对驱动的理解，还停留在手把手教你做事的<a href="https://xiunianjun.github.io/2023/01/10/xv6$chap5/#Lab-networking">xv6的netlab</a>。也因而，这次可以算是以完全一无所知的状态接下了这个任务。</p>
<p>不过，好在有以前那个短暂的lab经验，我还是稳扎稳打地定下了具体的学习步骤：调研（包括获取各种data book、schematic、rtt官方文档、Linux和rtt相关代码），然后就是学习。</p>
<p>好在有设备树的研究积淀，我也算是比较快地掌握了milkv上gpio的分布、型号及其地址空间，从而顺藤摸瓜找到了对应gpio型号的Linux驱动代码参考和硬件手册，算是免去了不少麻烦。</p>
<p><img src="/2023/10/19/open-source-9.19-10.19/image-20231019165206369.png" alt="image-20231019165206369"></p>
<p>然后，我观察rtt的gpio驱动们，也找到了对应的pin.md文档，了解了下大致的代码框架思路：</p>
<p><img src="/2023/10/19/open-source-9.19-10.19/image-20231019165313914.png" alt="image-20231019165313914"></p>
<p>于是接下来的工作也可以比较独立地划分为两部分，一个是数据读写的实现（通过LED闪烁程序测试），另一个是rtt特有的中断回调函数的支持（通过中断程序测试），可以专注对这两个方面开发了。</p>
<p>其中，数据读写的实现需要对寄存器和引脚号等有所了解。寄存器相对比较简单，只需阅读dwapb的data book即可；而引脚号到gpio的转换则花了我不少时间，做了许多猜想并且进行验证，最后误打误撞地“猜”中了正确思路，通过了LED测试。</p>
<p><img src="/2023/10/19/open-source-9.19-10.19/image-20231019165706806.png" alt="image-20231019165706806"></p>
<p><img src="/2023/10/19/open-source-9.19-10.19/image-20231019165719966.png" alt="image-20231019165719966"></p>
<p><img src="/2023/10/19/open-source-9.19-10.19/image-20231019165738144.png" alt="image-20231019165738144"></p>
<p>不过引脚号我现在还是不大懂，总之先参照别的bsp写法自己编了个，等着代码review看下吧。</p>
<p>前期调研一直到LED亮起来花了我整整五六天（）相比于此的困难，中断倒显得简单了许多，毕竟它属于是偏软件相关的。调了一天，也从Linux和其他bsp那边抄了些代码，最终在凌晨两点半成功完成了功能测试（）今天又花了一个下午整理了下代码和写日记，最终总算是把这个作业交上去了。</p>
<p>整个过程光是写看起来还是比较轻松，但是由于初次开发摸索，每个小跨越都得花费我不少时间去调研搜索，经常是在长达几个小时的不知所措后才短暂地获得了一些光明，我甚至多次想过要不要去辞职了（（（。总之，最后还是坚持了下来。看到蓝色的LED在夜晚的T5中闪烁，我还是十分激动的，眼泪都爆出来了（）</p>
<p>相关经历在这里：<a href="https://xiunianjun.github.io/2023/10/27/driver_develop">驱动开发小记</a></p>
<h1 id="稍作总结"><a href="#稍作总结" class="headerlink" title="稍作总结"></a>稍作总结</h1><p>总之，这一个月来我学到了许多，同时也对我以前未曾涉足的空白领域做了许多探索，包括对设备树、对嵌入式开发、对Linux设备驱动等的学习，总体来说还是十分甚至九分地开心。可惜考试月临近，再加上联系了老师开始做科研工作，故而实习工作只能到此中止。</p>
]]></content>
      <tags>
        <tag>intern</tag>
      </tags>
  </entry>
  <entry>
    <title>network stack</title>
    <url>/2024/05/25/network_stack/</url>
    <content><![CDATA[<blockquote>
<p><a href>实验指导书</a></p>
<p><a href>我的代码&amp;&amp;相关注释</a></p>
</blockquote>
<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><p>关于对分片的支持          CS144似乎是将分片支持放在了TCP层，也即由TCP实现分片和传输。在本实验中，我需要思索一下udp怎么适配分片，发送是已经没问题的了，接收需要好好修改一下。</p>
<h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p>发送过程：</p>
<ol>
<li>UDP发送包</li>
<li>IP发送包</li>
<li>ARP发送包<ol>
<li>地址未知，调用<code>arp_req</code>发送ARP请求</li>
<li>地址已知，ETH协议</li>
</ol>
</li>
<li>ETH发送包</li>
</ol>
<p>接收过程：</p>
<ol>
<li><p>ETH收到包</p>
<ol>
<li><p>ARP协议</p>
<ol>
<li><p>收到了ARP请求报文</p>
<p>调用<code>arp_resp</code>回应自身MAC地址</p>
</li>
<li><p>否则，则为收到了ARP响应报文</p>
<p>调用<code>eth_out</code>发送驻留的IP报文</p>
</li>
</ol>
</li>
<li><p>IP协议</p>
</li>
</ol>
</li>
<li><p>IP收到包</p>
<ol>
<li>ICMP协议<ol>
<li>IP报文协议字段错误，调用<code>icmp_unreachable</code></li>
<li>如果为ICMP回显请求，发送ICMP响应</li>
</ol>
</li>
<li>UDP协议</li>
</ol>
</li>
<li><p>UDP收到包</p>
<ol>
<li>内部错误，调用<code>icmp_unreachable</code></li>
<li>否则，调用<code>main::handler()</code></li>
</ol>
</li>
</ol>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>本质上只是类似于一种【抓包程序】：将网卡设置为混杂模式，同时增设一个BPF过滤器，通过接收网络上所有包并筛选出那些目标IP地址等于设置的协议栈地址的部分，然后发送也是借这个网卡发出去，从而达成收发数据包的目的。</p>
<p>具体可见<code>driver.c</code>文件中的代码和注释。</p>
<h1 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h1><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><p>网络上传输的数据都是字节流，对于一个多字节数值，在进行网络传输的时候，先传递哪个字节？按照TCP/IP协议规定：网络字节序是大端字节序。但是，X86平台上是以小端字节序存储，也就是，在发送之前我们需要将小端存储的字节序转换成大端法存储的数值，而在接收时，也需要将大端序转成小端序存放的数值。</p>
<p>我们只需关注那些<strong>长度大于一个字节的数据类型</strong>即可，如protocol_type、opcode16等等等，buf数组以及长度等字段的类型单位只为一个字节大小，无需swap。</p>
<h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>在大多数计算机体系结构中，数据访问通常按照特定的字长（如32位或64位）进行对齐。结构体（struct）作为复合数据类型，其成员可以是基本数据类型（如int、long、float等），也可以是其他复合数据类型（如数组、结构体、联合体等）。</p>
<p>在默认情况下，编译器会根据结构体的每个成员的自然对齐条件来分配内存空间，这是为了提高数据访问和运算的效率。自然对齐，也称为默认对齐方式，通常是根据结构体成员中最大尺寸的成员来确定对齐边界。这意味着，即使某些成员的实际大小小于对齐边界，编译器也可能在它们之间插入填充字节，以确保整个结构体满足对齐要求。</p>
<p>网络传输是字节流传输，但是当发生结构体对齐时，编译器会自动加入填充字节，这样发送出去的字节流某些字段会指向错误的地方，因此，在实验中，我们需要禁用结构体内部字段的对齐。</p>
<p>在实验代码中，可以使用伪指令pack(n)，编译器将按照n个字节对齐。注意：如果指定的n大于结构体最大成员的size，则其不起作用，结构体仍然按照size最大的成员进行对齐。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1) <span class="comment">// 编译器将按照1个字节对齐</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ether_hdr</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">     <span class="type">uint8_t</span> dst[NET_MAC_LEN]; <span class="comment">// 目标mac地址</span></span><br><span class="line">     <span class="type">uint8_t</span> src[NET_MAC_LEN]; <span class="comment">// 源mac地址</span></span><br><span class="line">     <span class="type">uint16_t</span> protocol16;      <span class="comment">// 协议/长度</span></span><br><span class="line"> &#125; <span class="type">ether_hdr_t</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">pragma</span> pack() <span class="comment">// 取消自定义字节对齐方式</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Map的使用"><a href="#Map的使用" class="headerlink" title="Map的使用"></a>Map的使用</h3><p>本实验用C语言实现了一个标准的泛型容器map，非常值得一看。</p>
<h2 id="ETH"><a href="#ETH" class="headerlink" title="ETH"></a>ETH</h2><p><img src="/2024/05/25/network_stack/%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%95%B0%E6%8D%AE%E5%B8%A71.png" alt="../_images/%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%95%B0%E6%8D%AE%E5%B8%A71.png"></p>
<p><img src="/2024/05/25/network_stack/%E5%B8%A7%E6%A0%BC%E5%BC%8F1.png" alt="../_images/%E5%B8%A7%E6%A0%BC%E5%BC%8F1.png"></p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>在TCP/IP的网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要确定了IP地址，就可向这个目标地址发送IP数据报了。然而，在数据链路层使用的是硬件地址（MAC）进行报文传输，IP地址不能被物理网络所识别，因此必须建立IP地址和MAC地址的映射关系，这一过程称为ARP（Address Resolution Protocol）地址解析协议。</p>
<p>ARP协议以目标IP地址为线索，用来定位下一个应该接收数据包的网络设备对应的MAC地址。如果目标主机不在同一个链路上，可以通过ARP查找下一跳网关的MAC地址。<strong>注意，ARP只适用于IPv4，不能用于IPv6</strong>。IPv6可以用ICMPv6替代ARP发送邻居探索消息。</p>
<p>那么ARP又是如何知道MAC地址的呢？简单地说，ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址的。此外，在每台使用ARP的主机中，都保留了一个专用的内存区（称为缓存），存放最近的IP地址与硬件地址的对应关系。一旦收到ARP应答，主机将获得的IP地址和硬件地址的对应关系存到缓存中。当发送报文时，首先去缓存中查找相应的项，如果找到相应项，便将报文直接发送出去；如果找不到，再利用ARP进行解析。ARP 缓存信息在一定时间内有效，过期不更新就会被删除。</p>
<p>ARP是一个独立的三层协议，所以ARP报文在向数据链路层传输时不需要经过IP协议的封装，而是直接生成自己的报文，其中包括ARP报头，到数据链路层后再对应的数据链路层（如以太网协议）进行封装。ARP报文分为ARP请求和应答报文两种，报文格式如下图所示。</p>
<p><img src="/2024/05/25/network_stack/ARP.png" alt="../_images/ARP.png"></p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>数据链路层提供两个直连设备之间的通信功能，而一旦跨越不同的数据链路，就需要借助网络层。IP(Internet Protocol，网际协议) 是TCP/IP协议网络层的协议，其主要作用是“实现终端节点之间的通信”，也叫“点对点（point-to-point）通信”。IP可大致分为三大作用模块，分别是IP寻址、IP分包与组包以及路由转发，其中，路由转发功能涉及到路由协议，在本节实验中不做重点介绍。</p>
<p><img src="/2024/05/25/network_stack/IP%E5%9C%B0%E5%9D%80.png" alt="../_images/IP%E5%9C%B0%E5%9D%80.png"></p>
<p>IP提供了一种尽力而为、无连接的数据报交付服务。“尽力而为”的含义是不保证IP数据报能成功到达目的地。“无连接”意味着IP不维护网络单元（即路由器）中数据报相关的任何链接状态信息，每个数据报独立于其他数据报来处理，这也意味着IP数据报可不按顺序交付。</p>
<p>本实验是基于IPv4协议上完成的，以下主要介绍IPv4版本的IP协议。IPv4的头部结构长度为20字节，若含有可变长的选项部分，最多60字节。</p>
<p><img src="/2024/05/25/network_stack/IP%E9%A6%96%E9%83%A8.png" alt="../_images/IP%E9%A6%96%E9%83%A8.PNG"></p>
<p>这3个字段（标识、标志、位偏移）则描述如何实现分片重组:</p>
<ol>
<li><strong>标识</strong> ：唯一地标识主机发送的每一个数据报，其初始值是随机的，每发送一个数据报其值就加1。同一个数据报的所有分片都具有相同的标识值。本实验中，标识字段可从0开始计数，然后往上自增。</li>
<li><strong>标志</strong> : 位1保留，位2表禁止分片(DF)，若设置了此位，IP模块将不对数据报进行分片，在此情况下若IP数据报超过MTU，IP模块将丢弃数据报并返回一个ICMP差错报文；位3标识更多分片(MF)，除了数据报的最后一个分片，其他分片都要把它设置为1。</li>
<li><strong>位偏移</strong> ：分片相对原始IP数据报数据部分的偏移。<u>实际的偏移值为该值左移3位后得到的</u>，所以除了最后一个IP数据报分片外，每个IP分片的<u>数据部分的长度都必须是8的整数倍</u>。</li>
</ol>
<p>其它字段：</p>
<ol>
<li><strong>生存时间</strong> ：数据报到达目的地之前允许经过的<u>路由器跳数</u>。TTL值被发送端设置，常设置为64。数据报在转发过程中每经过一个路由该值就被路由器减1.当TTL值为0时，路由器就将该数据包丢弃，并向源端发送一个ICMP差错报文。TTL可以防止数据报陷入路由循环。</li>
<li><strong>协议</strong> : 区分IP协议上的上层协议。在Linux系统的/etc/protocols文件中定义了所有上层协议对应的协议字段，<u>ICMP为1，TCP为6，UDP为17</u>。</li>
<li><strong>头部校验和</strong> ： 由发送端填充接收端对其使用<u>CRC算法校验</u>，检查IP数据报头部在传输过程中是否损坏。IP头部校验和只针对IP首部做校验，对其负载数据的校验是上层协议负责的，它不需要关心负载数据在传输过程中出错与否。IP数据报在转发的过程中，其头部字段就会被改变一次（比如修改TTL等），但IP数据报中的负载数据字段是不会改变的，因此，通过只校验IP头部的方式，也可以提高路由器处理分组的效率。</li>
<li><strong>源IP地址和目的IP地址</strong> : 表示数据报的发送端和接收端。</li>
<li><strong>区分服务(Type Of Service，TOS)</strong> ：3位优先权字段(现已被忽略) + 4位TOS字段 + 1位保留字段(须为0)。4位TOS字段分别表示最小延时、最大吞吐量、最高可靠性、最小费用，其中最多有一个能置为1。应用程序根据实际需要来设置TOS值。本实验中，可将TOS设置为0。<ul>
<li>最小延时：确保数据包尽快到达目的地，适用于需要低延迟的应用，如 VoIP 或在线游戏、ssh和telnet这样的登录程序。</li>
<li>最大吞吐量：允许数据包以最大速率传输，适用于需要高带宽的应用，如视频会议、文件传输ftp。</li>
<li>最高可靠性：减少数据包丢失和错误，适用于需要高可靠性的应用，如金融交易。</li>
<li>最小费用：选择成本最低的路径传输数据包，适用于成本敏感的应用。</li>
</ul>
</li>
</ol>
<p><img src="/2024/05/25/network_stack/IP%E5%88%86%E7%89%87.png" alt="../_images/IP%E5%88%86%E7%89%87.PNG"></p>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>将Internet控制报文协议（Internet Control Message Protocol，ICMP）与IP结合使用，以便提供与IP协议层配置和IP数据包处理相关的诊断和控制信息。ICMP主要功能包括：确认IP包是否成功送达目标地址、通知发送过程当中IP包被废弃的具体原因、改善网络设置等。ICMP协议应用在许多网络管理命令中。例如，<strong>ping命令</strong>使用ICMP回送请求和应答报文，路由分析诊断程序tracert使用ICMP时间超过报文等。</p>
<p>报文是在IP数据报内被封装传输的。ICMP头部8个字节，所有数据都在ICMP头部后面。ICMP报文格式具体见RFC777，RFC792规范。</p>
<p><img src="/2024/05/25/network_stack/ICMP%E6%A0%BC%E5%BC%8F.png" alt="../_images/ICMP%E6%A0%BC%E5%BC%8F.png"></p>
<p>ICMP的消息大致可以分为两类：一类是通知出错原因的错误消息（又称差错报文，error message），另一类是用于诊断的查询消息（又称询问或信息报文，information message）。</p>
<p><img src="/2024/05/25/network_stack/ICMP%E7%B1%BB%E5%9E%8B.png" alt="../_images/ICMP%E7%B1%BB%E5%9E%8B.png"></p>
<ul>
<li><p>差错报文</p>
<p>差错报文保留IP数据包中的前8个字节意义：TCP、UDP前八字节都含有源端口号，可以反馈给源主机。接收ICMP差错报文的模块就会把它与某个协议和用户进程联系起来。其中协议：根据IP数据报首部中的协议字段来判断，用户进程：根据包含在IP数据报前8字节中的TCP、UDP报文首部中的TCP、UDP端口号判断。</p>
<p><img src="/2024/05/25/network_stack/ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87.png" alt="../_images/ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87.png"></p>
</li>
<li><p>查询报文</p>
<p>其中16位校验和（Checksum）涵盖了整个报文，其校验和的计算方法和IP协议校验和算法是一样的；</p>
<p>标识符（Identifier）：如果是ICMP请求报文，该字段在Linux/macOS中用的是进程ID。如果是ICMP应答报文，则只需拷贝来自ICMP请求报文的标识符字段；</p>
<p>序列号（Sequence number）：如果是ICMP请求报文，该字段在Linux/macOS中是从0递增的，每个进程独立。如果是ICMP应答报文，则只需拷贝来自ICMP请求报文的序列号字段；</p>
<p>数据（Optional data）：如果是ICMP请求报文，该字段包括时间戳以及一串填充数据。如果是ICMP应答报文，则只需拷贝来自ICMP请求报文的数据字段。</p>
<p><img src="/2024/05/25/network_stack/ICMP%E4%BF%A1%E6%81%AF%E6%8A%A5%E6%96%87.png" alt="../_images/ICMP%E4%BF%A1%E6%81%AF%E6%8A%A5%E6%96%87.png"></p>
<p><img src="/2024/05/25/network_stack/image-20240526200525596.png" alt="image-20240526200525596"></p>
</li>
</ul>
<h1 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>首先实现server逻辑吧</p>
]]></content>
      <tags>
        <tag>labs</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2023/12/26/operating-system/</url>
    <content><![CDATA[<h1 id="01-导论"><a href="#01-导论" class="headerlink" title="01 导论"></a>01 导论</h1><p>操作系统是软硬件接口，它最主要的任务是向下协调硬件资源以达到尽可能高的时间效率和空间利用率，向上服务软件提供安全可靠的运行环境和简明操作抽象。其中，管理硬件资源包括对CPU、存储资源、设备的管理，服务软件则包括API接口、安全性封装性考虑以及各种抽象（eg. 进程、一切皆文件……）的管理。</p>
<p><img src="/2023/12/26/operating-system/image-20231208013539565.png" alt="image-20231208013539565"></p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p><img src="/2023/12/26/operating-system/image-20231208013715763.png" alt="image-20231208013715763"></p>
<p><img src="/2023/12/26/operating-system/image-20231208013737300.png" alt="image-20231208013737300"></p>
<p><img src="/2023/12/26/operating-system/image-20231208013757954.png" alt="image-20231208013757954"></p>
<p><img src="/2023/12/26/operating-system/image-20231208013815023.png" alt="image-20231208013815023"></p>
<p><img src="/2023/12/26/operating-system/image-20231208013827301.png" alt="image-20231208013827301"></p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><img src="/2023/12/26/operating-system/image-20231208013903287.png" alt="image-20231208013903287"></p>
<p><img src="/2023/12/26/operating-system/image-20231208013913442.png" alt="image-20231208013913442"></p>
<p><img src="/2023/12/26/operating-system/image-20231208013924319.png" alt="image-20231208013924319"></p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><img src="/2023/12/26/operating-system/image-20231208013947693.png" alt="image-20231208013947693"></p>
<p><img src="/2023/12/26/operating-system/image-20231208014005633.png" alt="image-20231208014005633"></p>
<h1 id="02-进程与线程"><a href="#02-进程与线程" class="headerlink" title="02 进程与线程"></a>02 进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/12/26/operating-system/image-20231209010239071.png" alt="image-20231209010239071"></p>
<p><img src="/2023/12/26/operating-system/image-20231209010726351.png" alt="image-20231209010726351"></p>
<p><img src="/2023/12/26/operating-system/image-20231209010741922.png" alt="image-20231209010741922"></p>
<p>感觉这种可能考什么简答题</p>
<p><img src="/2023/12/26/operating-system/image-20231209010943529.png" alt="image-20231209010943529"></p>
<p><img src="/2023/12/26/operating-system/image-20231209011002360.png" alt="image-20231209011002360"></p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><h4 id="状态-1"><a href="#状态-1" class="headerlink" title="状态"></a>状态</h4><p><img src="/2023/12/26/operating-system/image-20231209011058162.png" alt="image-20231209011058162"></p>
<p><img src="/2023/12/26/operating-system/image-20231209011113625.png" alt="image-20231209011113625"></p>
<p><img src="/2023/12/26/operating-system/image-20231209011134789.png" alt="image-20231209011134789"></p>
<h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><p><img src="/2023/12/26/operating-system/image-20231209012617457.png" alt="image-20231209012617457"></p>
<p><img src="/2023/12/26/operating-system/image-20231209012650789.png" alt="image-20231209012650789"></p>
<p><img src="/2023/12/26/operating-system/image-20231209012721932.png" alt="image-20231209012721932"></p>
<p><img src="/2023/12/26/operating-system/image-20231209012905281.png" alt="image-20231209012905281"></p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><h5 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h5><p><img src="/2023/12/26/operating-system/image-20231209013054072.png" alt="image-20231209013054072"></p>
<p>感觉这个也会出题</p>
<p><img src="/2023/12/26/operating-system/image-20231209013407611.png" alt="image-20231209013407611"></p>
<p><img src="/2023/12/26/operating-system/image-20231209013440724.png" alt="image-20231209013440724"></p>
<p>这些参数可能得再细致研究一下</p>
<p><img src="/2023/12/26/operating-system/image-20231209013955750.png" alt="image-20231209013955750"></p>
<h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h5><p><img src="/2023/12/26/operating-system/image-20231209014023122.png" alt="image-20231209014023122"></p>
<h5 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h5><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p><img src="/2023/12/26/operating-system/image-20231209014137651.png" alt="image-20231209014137651"></p>
<p><img src="/2023/12/26/operating-system/image-20231209014610180.png" alt="image-20231209014610180"></p>
<h6 id="为什么与fork分离"><a href="#为什么与fork分离" class="headerlink" title="为什么与fork分离"></a>为什么与fork分离</h6><p><img src="/2023/12/26/operating-system/image-20231209015425362.png" alt="image-20231209015425362"></p>
<h4 id="进程图"><a href="#进程图" class="headerlink" title="进程图"></a>进程图</h4><p>感觉这个也可能考，之后看看王道</p>
<p><img src="/2023/12/26/operating-system/image-20231209015527112.png" alt="image-20231209015527112"></p>
<p><img src="/2023/12/26/operating-system/image-20231209015548581.png" alt="image-20231209015548581"></p>
<p><img src="/2023/12/26/operating-system/image-20231209015559784.png" alt="image-20231209015559784"></p>
<p><img src="/2023/12/26/operating-system/image-20231209015611171.png" alt="image-20231209015611171"></p>
<p><img src="/2023/12/26/operating-system/image-20231209015621086.png" alt="image-20231209015621086"></p>
<h3 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><h5 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h5><p><img src="/2023/12/26/operating-system/image-20231209015652150.png" alt="image-20231209015652150"></p>
<p><img src="/2023/12/26/operating-system/image-20231209015947811.png" alt="image-20231209015947811"></p>
<p><img src="/2023/12/26/operating-system/image-20231209020021078.png" alt="image-20231209020021078"></p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>这些需要注意下概念题，比如xxx属于哪种类型的异常</p>
<h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p><img src="/2023/12/26/operating-system/image-20231209020045288.png" alt="image-20231209020045288"></p>
<p><img src="/2023/12/26/operating-system/image-20231209020117856.png" alt="image-20231209020117856"></p>
<p><img src="/2023/12/26/operating-system/image-20231209020133342.png" alt="image-20231209020133342"></p>
<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p><img src="/2023/12/26/operating-system/image-20231209020224680.png" alt="image-20231209020224680"></p>
<h5 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h5><p><img src="/2023/12/26/operating-system/image-20231209020249008.png" alt="image-20231209020249008"></p>
<h5 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h5><p><img src="/2023/12/26/operating-system/image-20231209020312623.png" alt="image-20231209020312623"></p>
<p><img src="/2023/12/26/operating-system/image-20231209020335344.png" alt="image-20231209020335344"></p>
<p><img src="/2023/12/26/operating-system/image-20231209020415992.png" alt="image-20231209020415992"></p>
<h5 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h5><p><img src="/2023/12/26/operating-system/image-20231209020435616.png" alt="image-20231209020435616"></p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p><img src="/2023/12/26/operating-system/image-20231209020644945.png" alt="image-20231209020644945"></p>
<p><img src="/2023/12/26/operating-system/image-20231209021224093.png" alt="image-20231209021224093"></p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p><img src="/2023/12/26/operating-system/image-20231209020724418.png" alt="image-20231209020724418"></p>
<h4 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h4><p><img src="/2023/12/26/operating-system/image-20231209020811007.png" alt="image-20231209020811007"></p>
<p><img src="/2023/12/26/operating-system/image-20231209020825726.png" alt="image-20231209020825726"></p>
<p><img src="/2023/12/26/operating-system/image-20231209020851150.png" alt="image-20231209020851150"></p>
<p>TODO，区分一下信箱和消息队列，看起来好像。我记得以前知道的，可惜现在忘了。</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p><img src="/2023/12/26/operating-system/image-20231209020949608.png" alt="image-20231209020949608"></p>
<p><img src="/2023/12/26/operating-system/image-20231209021142595.png" alt="image-20231209021142595"></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><h4 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h4><p><img src="/2023/12/26/operating-system/image-20231210002314658.png" alt="image-20231210002314658"></p>
<p><img src="/2023/12/26/operating-system/image-20231210002329164.png" alt="image-20231210002329164"></p>
<h4 id="多线程进程"><a href="#多线程进程" class="headerlink" title="多线程进程"></a>多线程进程</h4><p><img src="/2023/12/26/operating-system/image-20231210002413435.png" alt="image-20231210002413435"></p>
<p><img src="/2023/12/26/operating-system/image-20231210002450302.png" alt="image-20231210002450302"></p>
<p><img src="/2023/12/26/operating-system/image-20231210002607740.png" alt="image-20231210002607740"></p>
<p><img src="/2023/12/26/operating-system/image-20231210002529932.png" alt="image-20231210002529932"></p>
<p><img src="/2023/12/26/operating-system/image-20231210002644253.png" alt="image-20231210002644253"></p>
<h4 id="并发线程"><a href="#并发线程" class="headerlink" title="并发线程"></a>并发线程</h4><p>可以注意一下这个例题：</p>
<p><img src="/2023/12/26/operating-system/image-20231210002718214.png" alt="image-20231210002718214"></p>
<p><img src="/2023/12/26/operating-system/image-20231210002737122.png" alt="image-20231210002737122"></p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="/2023/12/26/operating-system/image-20231210002826322.png" alt="image-20231210002826322"></p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p><img src="/2023/12/26/operating-system/image-20231210002905246.png" alt="image-20231210002905246"></p>
<h4 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h4><p><img src="/2023/12/26/operating-system/image-20231210002952917.png" alt="image-20231210002952917"></p>
<h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p><img src="/2023/12/26/operating-system/image-20231210003025064.png" alt="image-20231210003025064"></p>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>果然一切问题都得中庸</p>
<p><img src="/2023/12/26/operating-system/image-20231210003106279.png" alt="image-20231210003106279"></p>
<p>就是加了个允许一对一绑定</p>
<p><img src="/2023/12/26/operating-system/image-20231210003130511.png" alt="image-20231210003130511"></p>
<h3 id="Posix线程"><a href="#Posix线程" class="headerlink" title="Posix线程"></a>Posix线程</h3><p><img src="/2023/12/26/operating-system/image-20231210003209912.png" alt="image-20231210003209912"></p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>感受一下C语言的面向对象</p>
<p><img src="/2023/12/26/operating-system/image-20231210003252567.png" alt="image-20231210003252567"></p>
<p><img src="/2023/12/26/operating-system/image-20231210003449745.png" alt="image-20231210003449745"></p>
<h4 id="终止-1"><a href="#终止-1" class="headerlink" title="终止"></a>终止</h4><p><img src="/2023/12/26/operating-system/image-20231210003629044.png" alt="image-20231210003629044"></p>
<p>好像第一个一般传的NULL。第二个应该相当于是线程A让某个线程终止（可以是自己也可以是别的），然后被终止线程应该会有代码检查是否被cancel，是的话再滚蛋。</p>
<h4 id="Join-Detach"><a href="#Join-Detach" class="headerlink" title="Join Detach"></a>Join Detach</h4><p><img src="/2023/12/26/operating-system/image-20231210003848702.png" alt="image-20231210003848702"></p>
<p>这个意义感觉还是有点模糊，到时候再看看网上的说法</p>
<p><img src="/2023/12/26/operating-system/image-20231210003938919.png" alt="image-20231210003938919"></p>
<p>这玩意我看着要吐了，以后有精力看看吧</p>
<p><img src="/2023/12/26/operating-system/image-20231210004048593.png" alt="image-20231210004048593"></p>
<p><img src="/2023/12/26/operating-system/image-20231210004035672.png" alt="image-20231210004035672"></p>
<h1 id="03-并发与同步"><a href="#03-并发与同步" class="headerlink" title="03 并发与同步"></a>03 并发与同步</h1><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>感觉这节很有意思，以前也没学过，值得仔细看看</p>
<p>用户程序通过系统调用针对某个信号注册了一个处理函数handler。然后另一个进程通过kill发送了该信号给这个用户程序。对这个信号的检测会推迟到用户程序陷入内核，并准备从内核返回的时候。这时候内核检查信号列表，发现了该待pending的函数，就直接强制性跳转到了用户自定义的处理函数handler（也就是说需要暂时返回用户态），执行完handler之后再回到中断上下文（回到内核态），然后返回到用户程序。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="/2023/12/26/operating-system/image-20231210004347370.png" alt="image-20231210004347370"></p>
<p><img src="/2023/12/26/operating-system/image-20231210004433931.png" alt="image-20231210004433931"></p>
<p><img src="/2023/12/26/operating-system/image-20231210004636914.png" alt="image-20231210004636914"></p>
<h3 id="收发"><a href="#收发" class="headerlink" title="收发"></a>收发</h3><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p><img src="/2023/12/26/operating-system/image-20231210004730315.png" alt="image-20231210004730315"></p>
<p>用kill -信号ID来发送一个信号。</p>
<p><img src="/2023/12/26/operating-system/image-20231210005800376.png" alt="image-20231210005800376"></p>
<p><img src="/2023/12/26/operating-system/image-20231210005830196.png" alt="image-20231210005830196"></p>
<p><img src="/2023/12/26/operating-system/image-20231210005937309.png" alt="image-20231210005937309"></p>
<p>下面这个区别没看懂</p>
<h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p><img src="/2023/12/26/operating-system/image-20231210004944106.png" alt="image-20231210004944106"></p>
<p>这里再仔细看看，信号的处理流程和时机</p>
<p><img src="/2023/12/26/operating-system/image-20231210005723795.png" alt="image-20231210005723795"></p>
<h4 id="pending-amp-block"><a href="#pending-amp-block" class="headerlink" title="pending&amp;block"></a>pending&amp;block</h4><p><img src="/2023/12/26/operating-system/image-20231210005037997.png" alt="image-20231210005037997"></p>
<p><img src="/2023/12/26/operating-system/image-20231210005154327.png" alt="image-20231210005154327"></p>
<p>阻塞位决定的是能否被接收，也就是说有可能出现阻塞位和挂起位都为1的情况。</p>
<p><img src="/2023/12/26/operating-system/image-20231210005520958.png" alt="image-20231210005520958"></p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p><img src="/2023/12/26/operating-system/image-20231210005603404.png" alt="image-20231210005603404"></p>
<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><h4 id="处理函数"><a href="#处理函数" class="headerlink" title="处理函数"></a>处理函数</h4><p><img src="/2023/12/26/operating-system/image-20231210010227173.png" alt="image-20231210010227173"></p>
<p><img src="/2023/12/26/operating-system/image-20231210010319529.png" alt="image-20231210010319529"></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="/2023/12/26/operating-system/image-20231210010338912.png" alt="image-20231210010338912"></p>
<p><img src="/2023/12/26/operating-system/image-20231210010402331.png" alt="image-20231210010402331"></p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p><img src="/2023/12/26/operating-system/image-20231210010905230.png" alt="image-20231210010905230"></p>
<p><img src="/2023/12/26/operating-system/image-20231210011007778.png" alt="image-20231210011007778"></p>
<p>printf不安全我想大概是因为用了变长参数之类的？？？这个值得深挖。或者说是因为它内里对数据处理非原子，所以可能导致输出混乱？</p>
<p><img src="/2023/12/26/operating-system/image-20231210011150268.png" alt="image-20231210011150268"></p>
<p>G3类似关中断</p>
<p><img src="/2023/12/26/operating-system/image-20231210011308433.png" alt="image-20231210011308433"></p>
<p><img src="/2023/12/26/operating-system/image-20231210011358066.png" alt="image-20231210011358066"></p>
<h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><p><img src="/2023/12/26/operating-system/image-20231210011540286.png" alt="image-20231210011540286"></p>
<p><img src="/2023/12/26/operating-system/image-20231210011600664.png" alt="image-20231210011600664"></p>
<p><img src="/2023/12/26/operating-system/image-20231210011613127.png" alt="image-20231210011613127"></p>
<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p><img src="/2023/12/26/operating-system/image-20231210010459883.png" alt="image-20231210010459883"></p>
<h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p><img src="/2023/12/26/operating-system/image-20231210010626733.png" alt="image-20231210010626733"></p>
<p><img src="/2023/12/26/operating-system/image-20231210010715447.png" alt="image-20231210010715447"></p>
<p><img src="/2023/12/26/operating-system/image-20231210010752485.png" alt="image-20231210010752485"></p>
<p>哦吼！到这里才意识到，原来我们xv6的<strong>sigalarm是实现了一次特殊的信号</strong>！（实在后知后觉……这个到时候再仔细看看）</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2023/12/26/operating-system/image-20231210011647336.png" alt="image-20231210011647336"></p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="进度图与临界区"><a href="#进度图与临界区" class="headerlink" title="进度图与临界区"></a>进度图与临界区</h3><p><img src="/2023/12/26/operating-system/image-20231210011820666.png" alt="image-20231210011820666"></p>
<p><img src="/2023/12/26/operating-system/image-20231210011848469.png" alt="image-20231210011848469"></p>
<p><img src="/2023/12/26/operating-system/image-20231210011955821.png" alt="image-20231210011955821"></p>
<p><img src="/2023/12/26/operating-system/image-20231210012012163.png" alt="image-20231210012012163"></p>
<p><img src="/2023/12/26/operating-system/image-20231210012037664.png" alt="image-20231210012037664"></p>
<p>之后学习一下条件变量是什么。。。</p>
<h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><p><img src="/2023/12/26/operating-system/image-20231210012157990.png" alt="image-20231210012157990"></p>
<p>这：</p>
<p><img src="/2023/12/26/operating-system/image-20231210012227966.png" alt="image-20231210012227966"></p>
<h3 id="信号量实现互斥"><a href="#信号量实现互斥" class="headerlink" title="信号量实现互斥"></a>信号量实现互斥</h3><p>P操作相当于减少信号量值，V操作相当于增加信号量值</p>
<p><img src="/2023/12/26/operating-system/image-20231210012337043.png" alt="image-20231210012337043"></p>
<p><img src="/2023/12/26/operating-system/image-20231210012347773.png" alt="image-20231210012347773"></p>
<p><img src="/2023/12/26/operating-system/image-20231210012403542.png" alt="image-20231210012403542"></p>
<p><img src="/2023/12/26/operating-system/image-20231210012418902.png" alt="image-20231210012418902"></p>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="制约关系"><a href="#制约关系" class="headerlink" title="制约关系"></a>制约关系</h4><p>也即竞争和同步的概念</p>
<p><img src="/2023/12/26/operating-system/image-20231210012501686.png" alt="image-20231210012501686"></p>
<p><img src="/2023/12/26/operating-system/image-20231210012517047.png" alt="image-20231210012517047"></p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>这个概念区分值得注意</p>
<p><img src="/2023/12/26/operating-system/image-20231210012627508.png" alt="image-20231210012627508"></p>
<p><img src="/2023/12/26/operating-system/image-20231210012705431.png" alt="image-20231210012705431"></p>
<h5 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h5><p><img src="/2023/12/26/operating-system/image-20231210012737130.png" alt="image-20231210012737130"></p>
<h3 id="王道补充"><a href="#王道补充" class="headerlink" title="王道补充"></a>王道补充</h3><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p><img src="/2023/12/26/operating-system/879A7D7E6DB3EE47025F8B34DC6C645A.jpg" alt="879A7D7E6DB3EE47025F8B34DC6C645A"></p>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p><img src="/2023/12/26/operating-system/639D7A03B329AE3772E430448DEB70ED.jpg" alt="639D7A03B329AE3772E430448DEB70ED"></p>
<p><img src="/2023/12/26/operating-system/33C2BB54CC9C1193E416F1B192ED52EA.jpg" alt="33C2BB54CC9C1193E416F1B192ED52EA"></p>
<h4 id="信号量实现互斥-1"><a href="#信号量实现互斥-1" class="headerlink" title="信号量实现互斥"></a>信号量实现互斥</h4><p>初始值为1</p>
<h4 id="信号量实现同步"><a href="#信号量实现同步" class="headerlink" title="信号量实现同步"></a>信号量实现同步</h4><p>这个可以保证456一定在12后面被执行，可以理解为生产者消费者模型</p>
<p><img src="/2023/12/26/operating-system/DEF5CECC416778202A533D6DCE34F7B0.jpg" alt="DEF5CECC416778202A533D6DCE34F7B0"></p>
<p><img src="/2023/12/26/operating-system/2F7BABD60FBA8CC4AE0D512E1E408BA5.jpg" alt="2F7BABD60FBA8CC4AE0D512E1E408BA5"></p>
<h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><p><img src="/2023/12/26/operating-system/1255B500C318AFDB4654057289DF1F6D.jpg" alt="1255B500C318AFDB4654057289DF1F6D"></p>
<p>除了这两个同步信号量，还需要多来一个互斥信号量表示对缓冲区的互斥访问</p>
<p><img src="/2023/12/26/operating-system/C457F3A07AC4899E741DDE5E03EA5EB8.jpg" alt="C457F3A07AC4899E741DDE5E03EA5EB8"></p>
<p>注意这里同步信号量和互斥信号量的顺序，如果交换了应该会死锁。p操作不能，因为它会阻塞。v就无所谓，因为不会阻塞</p>
<h4 id="多生产者消费者"><a href="#多生产者消费者" class="headerlink" title="多生产者消费者"></a>多生产者消费者</h4><p><img src="/2023/12/26/operating-system/F20FFFDC705D62E04919D4140A9CCF70.jpg" alt="F20FFFDC705D62E04919D4140A9CCF70"></p>
<p><img src="/2023/12/26/operating-system/93AF80AF95A40E97C2BEAE7AB9477BBF.jpg" alt="93AF80AF95A40E97C2BEAE7AB9477BBF"></p>
<p><img src="/2023/12/26/operating-system/7D8068890D7E5B300C7BF0F3960C882D.jpg" alt="7D8068890D7E5B300C7BF0F3960C882D"></p>
<h1 id="04-CPU调度与优化"><a href="#04-CPU调度与优化" class="headerlink" title="04 CPU调度与优化"></a>04 CPU调度与优化</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h3><p><img src="/2023/12/26/operating-system/image-20231211010846215.png" alt="image-20231211010846215"></p>
<h3 id="过程和开销"><a href="#过程和开销" class="headerlink" title="过程和开销"></a>过程和开销</h3><p><img src="/2023/12/26/operating-system/image-20231211011007471.png" alt="image-20231211011007471"></p>
<h3 id="抢占与非抢占"><a href="#抢占与非抢占" class="headerlink" title="抢占与非抢占"></a>抢占与非抢占</h3><p><img src="/2023/12/26/operating-system/image-20231211011040742.png" alt="image-20231211011040742"></p>
<h3 id="计算-IO密集"><a href="#计算-IO密集" class="headerlink" title="计算/IO密集"></a>计算/IO密集</h3><p><img src="/2023/12/26/operating-system/image-20231211011117679.png" alt="image-20231211011117679"></p>
<p><img src="/2023/12/26/operating-system/image-20231211011143165.png" alt="image-20231211011143165"></p>
<h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p><img src="/2023/12/26/operating-system/image-20231211011311853.png" alt="image-20231211011311853"></p>
<p><img src="/2023/12/26/operating-system/image-20231211011407132.png" alt="image-20231211011407132"></p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>这部分也需要注意考题，应该会考调度序列和各种指标计算。</p>
<h3 id="预测CPU区间"><a href="#预测CPU区间" class="headerlink" title="预测CPU区间"></a>预测CPU区间</h3><p><img src="/2023/12/26/operating-system/image-20231211011847840.png" alt="image-20231211011847840"></p>
<h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><p><img src="/2023/12/26/operating-system/image-20231211011441271.png" alt="image-20231211011441271"></p>
<p><img src="/2023/12/26/operating-system/image-20231211011458102.png" alt="image-20231211011458102"></p>
<h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p><img src="/2023/12/26/operating-system/image-20231211011542488.png" alt="image-20231211011542488"></p>
<p><img src="/2023/12/26/operating-system/image-20231211011555029.png" alt="image-20231211011555029"></p>
<p>所以需要最小平均等待时间的话，用sjf是最好的</p>
<p><img src="/2023/12/26/operating-system/image-20231211011623845.png" alt="image-20231211011623845"></p>
<h3 id="SRJF"><a href="#SRJF" class="headerlink" title="SRJF"></a>SRJF</h3><p>相当于是SJF在任务到达时间有先后的情况下的一种拓展</p>
<p><img src="/2023/12/26/operating-system/image-20231211011755855.png" alt="image-20231211011755855"></p>
<p><img src="/2023/12/26/operating-system/image-20231211011806684.png" alt="image-20231211011806684"></p>
<h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><p><img src="/2023/12/26/operating-system/image-20231211012909442.png" alt="image-20231211012909442"></p>
<p>这个一下整了好多例子，感觉考查重点</p>
<p><img src="/2023/12/26/operating-system/image-20231211012050916.png" alt="image-20231211012050916"></p>
<p>每次pick应该是按照特定的轮转顺序？看图例大概是tid之类的</p>
<p><img src="/2023/12/26/operating-system/image-20231211012130780.png" alt="image-20231211012130780"></p>
<p><img src="/2023/12/26/operating-system/image-20231211012327726.png" alt="image-20231211012327726"></p>
<p><img src="/2023/12/26/operating-system/image-20231211012341491.png" alt="image-20231211012341491"></p>
<p><img src="/2023/12/26/operating-system/image-20231211012414371.png" alt="image-20231211012414371"></p>
<p><img src="/2023/12/26/operating-system/image-20231211012426377.png" alt="image-20231211012426377"></p>
<blockquote>
<p>为什么实时调度都要用RR或者FIFO策略？</p>
<ol>
<li><strong>确定性</strong>：实时任务通常要求确定性的响应时间。SCHED_FIFO和SCHED_RR提供了可预测的调度行为，保证了高优先级任务能够及时获得CPU时间。相比之下，CFS设计用于提供公平性，但并不保证确定性的响应时间107。</li>
<li><strong>优先级抢占</strong>：实时调度策略允许高优先级任务抢占低优先级任务的执行，这在需要立即处理的任务（如中断处理）中非常重要。CFS策略下的任务抢占行为是基于CPU使用时间的公平性，而非严格的优先级7。</li>
<li><strong>实时性能要求</strong>：实时任务往往与系统的实时性能要求相关，如工业控制、音频/视频同步等，这些场景需要确保任务能够满足特定的时间约束。FIFO和RR策略能够提供这种保证，而CFS则更侧重于长时的CPU使用公平性5。</li>
<li><strong>时间片管理</strong>：SCHED_RR通过时间片轮转为相同优先级的任务提供了公平的调度机会，而SCHED_FIFO则保证了相同优先级的任务将顺序执行，直到任务主动放弃CPU。CFS的时间片管理机制不适合实时任务的时间敏感性要求9。</li>
<li><strong>系统资源的保障</strong>：实时任务可能需要独占或优先访问系统资源，而CFS策略下，系统资源是按需动态分配的，这可能导致实时任务无法获得足够的资源来满足其时间要求4。</li>
<li><strong>实时任务的严格性</strong>：实时任务通常不能容忍延迟，因此需要一个能够保证任务在规定时间内执行的调度策略。FIFO和RR策略提供了这种严格性，而CFS策略则更适用于对实时性要求不高的普通任务8。 总的来说，实时调度策略（SCHED_FIFO和SCHED_RR）提供了实时任务执行所需的确定性和响应性，而CFS策略则更适合于一般目的的进程调度，它提供了良好的CPU使用公平性和效率。在需要严格实时性能的场景中，使用RR或FIFO策略是更合适的选择。</li>
</ol>
</blockquote>
<h3 id="MLFQ"><a href="#MLFQ" class="headerlink" title="MLFQ"></a>MLFQ</h3><p><img src="/2023/12/26/operating-system/image-20231211011942018.png" alt="image-20231211011942018"></p>
<p><img src="/2023/12/26/operating-system/image-20231211012500643.png" alt="image-20231211012500643"></p>
<p><img src="/2023/12/26/operating-system/image-20231211012553738.png" alt="image-20231211012553738"></p>
<p>确实，它很好的一点就是每个队列可以用不同的调度算法。感觉这种分层级的思想或许也可以用于idea</p>
<h3 id="彩票-Lottery"><a href="#彩票-Lottery" class="headerlink" title="彩票(Lottery)"></a>彩票(Lottery)</h3><p><img src="/2023/12/26/operating-system/image-20231211012742472.png" alt="image-20231211012742472"></p>
<p><img src="/2023/12/26/operating-system/image-20231211012818751.png" alt="image-20231211012818751"></p>
<h1 id="05-死锁"><a href="#05-死锁" class="headerlink" title="05 死锁"></a>05 死锁</h1><p><img src="/2023/12/26/operating-system/image-20231211225541316.png" alt="image-20231211225541316"></p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p><img src="/2023/12/26/operating-system/image-20231211013154638.png" alt="image-20231211013154638"></p>
<p><img src="/2023/12/26/operating-system/image-20231211013226115.png" alt="image-20231211013226115"></p>
<h2 id="四个产生条件"><a href="#四个产生条件" class="headerlink" title="四个产生条件"></a>四个产生条件</h2><h3 id="资源互斥访问"><a href="#资源互斥访问" class="headerlink" title="资源互斥访问"></a>资源互斥访问</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><img src="/2023/12/26/operating-system/image-20231211013309044.png" alt="image-20231211013309044"></p>
<h3 id="四个条件"><a href="#四个条件" class="headerlink" title="四个条件"></a>四个条件</h3><p><img src="/2023/12/26/operating-system/image-20231211013557063.png" alt="image-20231211013557063"></p>
<p><img src="/2023/12/26/operating-system/image-20231214234613849.png" alt="image-20231214234613849"></p>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p><img src="/2023/12/26/operating-system/image-20231214235157825.png" alt="image-20231214235157825"></p>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p><img src="/2023/12/26/operating-system/image-20231211013810051.png" alt="image-20231211013810051"></p>
<p><img src="/2023/12/26/operating-system/image-20231214234936241.png" alt="image-20231214234936241"></p>
<p><img src="/2023/12/26/operating-system/image-20231211013833463.png" alt="image-20231211013833463"></p>
<p>静态分配，可能导致某些进程饥饿</p>
<p><img src="/2023/12/26/operating-system/image-20231211013905973.png" alt="image-20231211013905973"></p>
<p>我怎么感觉按序申请挺常见的（</p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="/2023/12/26/operating-system/image-20231211014121368.png" alt="image-20231211014121368"></p>
<p><img src="/2023/12/26/operating-system/image-20231211014140758.png" alt="image-20231211014140758"></p>
<p><img src="/2023/12/26/operating-system/image-20231214235559994.png" alt="image-20231214235559994"></p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p><img src="/2023/12/26/operating-system/image-20231211014227897.png" alt="image-20231211014227897"></p>
<p><img src="/2023/12/26/operating-system/image-20231211014239708.png" alt="image-20231211014239708"></p>
<p><img src="/2023/12/26/operating-system/image-20231211014252447.png" alt="image-20231211014252447"></p>
<p><img src="/2023/12/26/operating-system/image-20231211014307622.png" alt="image-20231211014307622"></p>
<p><img src="/2023/12/26/operating-system/image-20231211225325604.png" alt="image-20231211225325604"></p>
<h4 id="资源请求算法"><a href="#资源请求算法" class="headerlink" title="资源请求算法"></a>资源请求算法</h4><p><img src="/2023/12/26/operating-system/image-20231211225106052.png" alt="image-20231211225106052"></p>
<p><img src="/2023/12/26/operating-system/image-20231211225149084.png" alt="image-20231211225149084"></p>
<p><img src="/2023/12/26/operating-system/image-20231211225200012.png" alt="image-20231211225200012"></p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>资源分配图化简算法是死锁检测，注意与资源请求算法的差别</p>
<p><img src="/2023/12/26/operating-system/image-20231211013347070.png" alt="image-20231211013347070"></p>
<p><img src="/2023/12/26/operating-system/image-20231215001204690.png" alt="image-20231215001204690"></p>
<p>也相当于找到了一个安全序列</p>
<p><img src="/2023/12/26/operating-system/image-20231215001425205.png" alt="image-20231215001425205"></p>
<p><img src="/2023/12/26/operating-system/image-20231211013429818.png" alt="image-20231211013429818"></p>
<p>下面那个感觉是因为P4和P2还是有可能释放资源</p>
<p><img src="/2023/12/26/operating-system/image-20231211013530873.png" alt="image-20231211013530873"></p>
<p>然后还有<strong>环路和死锁的关系</strong>：<a href="https://zhuanlan.zhihu.com/p/654942846">【操作系统】死锁（详细）</a></p>
<p>① 如果进程-资源分配图中无环路</p>
<p>——&gt;则此时系统没有发生死锁</p>
<p>② 如果进程-资源分配图中有环路，且每个资源类中仅有一个资源</p>
<p>——&gt;则系统中发生了死锁，此时，环路是系统发生死锁的<strong>充要条件</strong>，环路中的进程便为死锁进程</p>
<p>③ 如果进程-资源分配图中有环路，且涉及的资源类中有多个资源</p>
<p>——&gt;则环的存在只是产生死锁的<strong>必要条件而不是充分条件</strong></p>
<h4 id="不知道什么玩意"><a href="#不知道什么玩意" class="headerlink" title="不知道什么玩意"></a>不知道什么玩意</h4><p><img src="/2023/12/26/operating-system/image-20231211225403513.png" alt="image-20231211225403513"></p>
<h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><p><img src="/2023/12/26/operating-system/image-20231215001557317.png" alt="image-20231215001557317"></p>
<h3 id="死锁忽略"><a href="#死锁忽略" class="headerlink" title="死锁忽略"></a>死锁忽略</h3><p><img src="/2023/12/26/operating-system/image-20231211225506882.png" alt="image-20231211225506882"></p>
<h1 id="06-内存管理"><a href="#06-内存管理" class="headerlink" title="06  内存管理"></a>06  内存管理</h1><p><img src="/2023/12/26/operating-system/image-20231212011156242.png" alt="image-20231212011156242"></p>
<p><img src="/2023/12/26/operating-system/image-20231212011214519.png" alt="image-20231212011214519"></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>重定位三个时机：</p>
<ol>
<li><p>编译链接</p>
<p>绝对代码</p>
<p><img src="/2023/12/26/operating-system/image-20231215010046935.png" alt="image-20231215010046935"></p>
</li>
<li><p>装载时</p>
<p><img src="/2023/12/26/operating-system/image-20231215010115205.png" alt="image-20231215010115205"></p>
</li>
<li><p>运行时</p>
<p><img src="/2023/12/26/operating-system/image-20231215010159649.png" alt="image-20231215010159649"></p>
</li>
</ol>
<p><img src="/2023/12/26/operating-system/image-20231212003926160.png" alt="image-20231212003926160"></p>
<p><img src="/2023/12/26/operating-system/image-20231212004003798.png" alt="image-20231212004003798"></p>
<p><img src="/2023/12/26/operating-system/image-20231212004031562.png" alt="image-20231212004031562"></p>
<p><img src="/2023/12/26/operating-system/image-20231212004053832.png" alt="image-20231212004053832"></p>
<h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><img src="/2023/12/26/operating-system/image-20231212004152913.png" alt="image-20231212004152913"></p>
<p><img src="/2023/12/26/operating-system/image-20231212004358388.png" alt="image-20231212004358388"></p>
<p><img src="/2023/12/26/operating-system/image-20231212004335621.png" alt="image-20231212004335621"></p>
<h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p><img src="/2023/12/26/operating-system/image-20231212004240886.png" alt="image-20231212004240886"></p>
<p><img src="/2023/12/26/operating-system/image-20231212004251661.png" alt="image-20231212004251661"></p>
<p>没看懂后面两个的差别。。。</p>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><h4 id="等长"><a href="#等长" class="headerlink" title="等长"></a>等长</h4><p><img src="/2023/12/26/operating-system/image-20231212004659024.png" alt="image-20231212004659024"></p>
<h4 id="变长"><a href="#变长" class="headerlink" title="变长"></a>变长</h4><p><img src="/2023/12/26/operating-system/image-20231212004738309.png" alt="image-20231212004738309"></p>
<h3 id="可变分区"><a href="#可变分区" class="headerlink" title="可变分区"></a>可变分区</h3><p><img src="/2023/12/26/operating-system/image-20231212004810488.png" alt="image-20231212004810488"></p>
<p><img src="/2023/12/26/operating-system/image-20231212004824143.png" alt="image-20231212004824143"></p>
<p><img src="/2023/12/26/operating-system/image-20231212004840749.png" alt="image-20231212004840749"></p>
<p><img src="/2023/12/26/operating-system/image-20231212004851418.png" alt="image-20231212004851418"></p>
<h3 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h3><p><img src="/2023/12/26/operating-system/image-20231212004926946.png" alt="image-20231212004926946"></p>
<h3 id="碎片问题"><a href="#碎片问题" class="headerlink" title="碎片问题"></a>碎片问题</h3><p><img src="/2023/12/26/operating-system/image-20231212005024806.png" alt="image-20231212005024806"></p>
<p><img src="/2023/12/26/operating-system/image-20231212005050253.png" alt="image-20231212005050253"></p>
<p><img src="/2023/12/26/operating-system/image-20231212005117560.png" alt="image-20231212005117560"></p>
<h2 id="分段内存管理"><a href="#分段内存管理" class="headerlink" title="分段内存管理"></a>分段内存管理</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/12/26/operating-system/image-20231212005157789.png" alt="image-20231212005157789"></p>
<p><img src="/2023/12/26/operating-system/image-20231212005249614.png" alt="image-20231212005249614"></p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p><img src="/2023/12/26/operating-system/image-20231212005303487.png" alt="image-20231212005303487"></p>
<p><img src="/2023/12/26/operating-system/image-20231212005322548.png" alt="image-20231212005322548"></p>
<p><img src="/2023/12/26/operating-system/image-20231212005335864.png" alt="image-20231212005335864"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2023/12/26/operating-system/image-20231212005424317.png" alt="image-20231212005424317"></p>
<p><img src="/2023/12/26/operating-system/image-20231212005606894.png" alt="image-20231212005606894"></p>
<h2 id="分页内存管理"><a href="#分页内存管理" class="headerlink" title="分页内存管理"></a>分页内存管理</h2><h3 id="地址翻译-1"><a href="#地址翻译-1" class="headerlink" title="地址翻译"></a>地址翻译</h3><p><img src="/2023/12/26/operating-system/image-20231212005717769.png" alt="image-20231212005717769"></p>
<p><img src="/2023/12/26/operating-system/image-20231212005731167.png" alt="image-20231212005731167"></p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p><img src="/2023/12/26/operating-system/image-20231212005808958.png" alt="image-20231212005808958"></p>
<h4 id="页表项"><a href="#页表项" class="headerlink" title="页表项"></a>页表项</h4><p><img src="/2023/12/26/operating-system/image-20231212005843981.png" alt="image-20231212005843981"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010032980.png" alt="image-20231212010032980"></p>
<h4 id="地址空间-1"><a href="#地址空间-1" class="headerlink" title="地址空间"></a>地址空间</h4><p><img src="/2023/12/26/operating-system/image-20231212005928818.png" alt="image-20231212005928818"></p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><p><img src="/2023/12/26/operating-system/image-20231212005946694.png" alt="image-20231212005946694"></p>
<p><img src="/2023/12/26/operating-system/image-20231212005959917.png" alt="image-20231212005959917"></p>
<h5 id="地址翻译-2"><a href="#地址翻译-2" class="headerlink" title="地址翻译"></a>地址翻译</h5><p><img src="/2023/12/26/operating-system/image-20231212010013770.png" alt="image-20231212010013770"></p>
<h5 id="效率-TLB"><a href="#效率-TLB" class="headerlink" title="效率-TLB"></a>效率-TLB</h5><p><img src="/2023/12/26/operating-system/image-20231212010112445.png" alt="image-20231212010112445"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010146984.png" alt="image-20231212010146984"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010158362.png" alt="image-20231212010158362"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010219801.png" alt="image-20231212010219801"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010238146.png" alt="image-20231212010238146"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010316825.png" alt="image-20231212010316825"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2023/12/26/operating-system/image-20231212010401612.png" alt="image-20231212010401612"></p>
<h2 id="段页结合"><a href="#段页结合" class="headerlink" title="段页结合"></a>段页结合</h2><p>将内存分为功能不同的段有助于提高数据局部性和实现数据隔离，将内存分为固定大小的页有助于缓解内存碎片化和方便回收分配管理，故而主流采用的是段页结合的内存管理，体现了一个软硬件之间的妥协。</p>
<p><img src="/2023/12/26/operating-system/image-20231212010525294.png" alt="image-20231212010525294"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010537503.png" alt="image-20231212010537503"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010626075.png" alt="image-20231212010626075"></p>
<h2 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h2><p><img src="/2023/12/26/operating-system/image-20231212010657820.png" alt="image-20231212010657820"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010727619.png" alt="image-20231212010727619"></p>
<h2 id="X86内存"><a href="#X86内存" class="headerlink" title="X86内存"></a>X86内存</h2><p><img src="/2023/12/26/operating-system/image-20231212010805410.png" alt="image-20231212010805410"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010824997.png" alt="image-20231212010824997"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010847424.png" alt="image-20231212010847424"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010901211.png" alt="image-20231212010901211"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010926834.png" alt="image-20231212010926834"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010942507.png" alt="image-20231212010942507"></p>
<p><img src="/2023/12/26/operating-system/image-20231212010955766.png" alt="image-20231212010955766"></p>
<p><img src="/2023/12/26/operating-system/image-20231212011012546.png" alt="image-20231212011012546"></p>
<p><img src="/2023/12/26/operating-system/image-20231212011025331.png" alt="image-20231212011025331"></p>
<p><img src="/2023/12/26/operating-system/image-20231212011054626.png" alt="image-20231212011054626"></p>
<p><img src="/2023/12/26/operating-system/image-20231212011116031.png" alt="image-20231212011116031"></p>
<p>值得注意的是，以前只了解开启虚拟地址映射的时候会开启LDT，就是不大清楚这其中的具体含义，经同学启发，以及“每个进程都有一个LDTR”的表述，才意识到它能保证多个进程虚拟地址空间的管理。</p>
<p>具体来说这个地址映射的转化是这样的，实模式使用物理地址，即程序直接访问物理内存地址，没有分段或分页机制故而它有4MB的直接寻址空间。而它切到保护模式的时候会先切换为一个使用段表的新GDT表，开启对LDT表的使用，从而开启了段页结合的虚拟映射。</p>
<h2 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h2><p><img src="/2023/12/26/operating-system/E21B1EA221B6BC5E2B8CD601473622F5.jpg" alt="E21B1EA221B6BC5E2B8CD601473622F5"></p>
<p><img src="/2023/12/26/operating-system/3304F578DBB8ADB87A6708C7B7850602.jpg" alt="3304F578DBB8ADB87A6708C7B7850602"></p>
<h3 id="连续内存分配-1"><a href="#连续内存分配-1" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><h4 id="覆盖和交换"><a href="#覆盖和交换" class="headerlink" title="覆盖和交换"></a>覆盖和交换</h4><p><img src="/2023/12/26/operating-system/E465171409C9E5B31D0A1BC1266EDF9B.jpg" alt="E465171409C9E5B31D0A1BC1266EDF9B"></p>
<p><img src="/2023/12/26/operating-system/8FCF9143359D0C6839BF15993CEE01A0.jpg" alt="8FCF9143359D0C6839BF15993CEE01A0"></p>
<p><img src="/2023/12/26/operating-system/D00AC845CC6F7F8D8772BF4A8E294A5F.jpg" alt="D00AC845CC6F7F8D8772BF4A8E294A5F"></p>
<p><img src="/2023/12/26/operating-system/322B105AE23A98DED86EE23879AED00C.jpg" alt="322B105AE23A98DED86EE23879AED00C"></p>
<p>这个也就类似于swap，只不过swap换入换出单位为页，这个单位为整个进程</p>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p><img src="/2023/12/26/operating-system/image-20231215154743853.png" alt="image-20231215154743853"></p>
<p>这几个优缺点得背，比如说最主要的是最佳适配的内存碎片、开销问题，最坏适配的大分区用完问题，以及首次适配的性能最好。</p>
<h3 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h3><p>上面这些包括什么动态分区分配算法（最先适配最佳适配等等）都是连续分配管理方式，接下来我们要学的分段分页属于非连续内存管理方式。他们逻辑空间连续，但是物理空间不一定连续</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p><img src="/2023/12/26/operating-system/67A2E236FA5E7B52285DE55A3B2921EF.jpg" alt="67A2E236FA5E7B52285DE55A3B2921EF"></p>
<h4 id="页表项-1"><a href="#页表项-1" class="headerlink" title="页表项"></a>页表项</h4><p><img src="/2023/12/26/operating-system/EB5186D39F413C46BDF12CC3488BB66A.jpg" alt="EB5186D39F413C46BDF12CC3488BB66A"></p>
<p>可以发现如果只是单纯的分页，还是不用什么逻辑地址那么复杂的，只用有页号块号的映射表即可</p>
<p><img src="/2023/12/26/operating-system/5B66F668315918779E53BF5842927C79.jpg" alt="5B66F668315918779E53BF5842927C79"></p>
<p>这个意思是一个页表跨了多个页框存储，第一个页的最大为1364，所以1365也即下一个页框的起始地址需要做点小操作</p>
<h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p><img src="/2023/12/26/operating-system/F89F19F4ED9BE27BD5154655479DE96D.jpg" alt="F89F19F4ED9BE27BD5154655479DE96D"></p>
<p><img src="/2023/12/26/operating-system/0328340E0EBCDF736DDD68A68DDF8EBF.jpg" alt="0328340E0EBCDF736DDD68A68DDF8EBF"></p>
<p><img src="/2023/12/26/operating-system/4F1A9F92B0AF3EB8E52235DBBBA94363.jpg" alt="4F1A9F92B0AF3EB8E52235DBBBA94363"></p>
<p><img src="/2023/12/26/operating-system/D90676403D33299FD252F8370352B141.jpg" alt="D90676403D33299FD252F8370352B141"></p>
<h4 id="硬件流程"><a href="#硬件流程" class="headerlink" title="硬件流程"></a>硬件流程</h4><h5 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h5><p><img src="/2023/12/26/operating-system/image-20231215142236222.png" alt="image-20231215142236222"></p>
<p><img src="/2023/12/26/operating-system/34A4F9BFA2F7CED592F901CE10135E27.jpg" alt="34A4F9BFA2F7CED592F901CE10135E27"></p>
<h5 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h5><p><img src="/2023/12/26/operating-system/image-20231215142440943.png" alt="image-20231215142440943"></p>
<p>tlb是存的页表项，可以不防存而访高速cache来得到物理地址</p>
<p><img src="/2023/12/26/operating-system/image-20231215142910720.png" alt="image-20231215142910720"></p>
<p><img src="/2023/12/26/operating-system/image-20231215142630009.png" alt="image-20231215142630009"></p>
<h5 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h5><p><img src="/2023/12/26/operating-system/image-20231215142734258.png" alt="image-20231215142734258"></p>
<p>注意这个同时查找！</p>
<h4 id="多级页表-1"><a href="#多级页表-1" class="headerlink" title="多级页表"></a>多级页表</h4><p><img src="/2023/12/26/operating-system/image-20231215143206451.png" alt="image-20231215143206451"></p>
<p><img src="/2023/12/26/operating-system/image-20231215143358611.png" alt="image-20231215143358611"></p>
<p>值得注意的是，页表只能存在一个页里，不能多个，这个可以用来做题</p>
<p><img src="/2023/12/26/operating-system/image-20231215143443355.png" alt="image-20231215143443355"></p>
<p>又一个时间空间矛盾</p>
<p><img src="/2023/12/26/operating-system/image-20231215143544186.png" alt="image-20231215143544186"></p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p><img src="/2023/12/26/operating-system/image-20231215143656067.png" alt="image-20231215143656067"></p>
<p><img src="/2023/12/26/operating-system/image-20231215143921558.png" alt="image-20231215143921558"></p>
<p><img src="/2023/12/26/operating-system/image-20231215144028571.png" alt="image-20231215144028571"></p>
<h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><p><img src="/2023/12/26/operating-system/image-20231215144114622.png" alt="image-20231215144114622"></p>
<p><img src="/2023/12/26/operating-system/image-20231215144157329.png" alt="image-20231215144157329"></p>
<p><img src="/2023/12/26/operating-system/image-20231215144206370.png" alt="image-20231215144206370"></p>
<h3 id="段页结合-1"><a href="#段页结合-1" class="headerlink" title="段页结合"></a>段页结合</h3><p><img src="/2023/12/26/operating-system/image-20231215144547127.png" alt="image-20231215144547127"></p>
<p><img src="/2023/12/26/operating-system/image-20231215144630997.png" alt="image-20231215144630997"></p>
<p><img src="/2023/12/26/operating-system/image-20231215144834947.png" alt="image-20231215144834947"></p>
<p><img src="/2023/12/26/operating-system/image-20231215144846471.png" alt="image-20231215144846471"></p>
<p>现在整了个二维TLB</p>
<h1 id="07-虚拟内存"><a href="#07-虚拟内存" class="headerlink" title="07 虚拟内存"></a>07 虚拟内存</h1><h2 id="王道-虚拟内存"><a href="#王道-虚拟内存" class="headerlink" title="王道-虚拟内存"></a>王道-虚拟内存</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>6666，它这里说虚拟内存其实也就类似交换和覆盖技术。这个思想很牛逼</p>
<p><img src="/2023/12/26/operating-system/image-20231215145314234.png" alt="image-20231215145314234"></p>
<p>传统方式的一次性、驻留性</p>
<p><img src="/2023/12/26/operating-system/image-20231215145435260.png" alt="image-20231215145435260"></p>
<p><img src="/2023/12/26/operating-system/image-20231215145521243.png" alt="image-20231215145521243"></p>
<h3 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a>请求分页</h3><p><img src="/2023/12/26/operating-system/image-20231215145551580.png" alt="image-20231215145551580"></p>
<h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p><img src="/2023/12/26/operating-system/image-20231215150057099.png" alt="image-20231215150057099"></p>
<h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h4><p><img src="/2023/12/26/operating-system/image-20231215150128303.png" alt="image-20231215150128303"></p>
<p><img src="/2023/12/26/operating-system/image-20231215150154401.png" alt="image-20231215150154401"></p>
<h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><p><img src="/2023/12/26/operating-system/image-20231215150339974.png" alt="image-20231215150339974"></p>
<p><img src="/2023/12/26/operating-system/image-20231215150438265.png" alt="image-20231215150438265"></p>
<p><img src="/2023/12/26/operating-system/image-20231215150457627.png" alt="image-20231215150457627"></p>
<p>之后就是直接查快表不是慢表了</p>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p><img src="/2023/12/26/operating-system/image-20231215151517166.png" alt="image-20231215151517166"></p>
<h5 id="OPT"><a href="#OPT" class="headerlink" title="OPT"></a>OPT</h5><p><img src="/2023/12/26/operating-system/image-20231215150635517.png" alt="image-20231215150635517"></p>
<h5 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h5><p><img src="/2023/12/26/operating-system/image-20231215150719347.png" alt="image-20231215150719347"></p>
<p><img src="/2023/12/26/operating-system/image-20231215150732801.png" alt="image-20231215150732801"></p>
<h5 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h5><p><img src="/2023/12/26/operating-system/image-20231215150839652.png" alt="image-20231215150839652"></p>
<h5 id="简单CLOCK"><a href="#简单CLOCK" class="headerlink" title="简单CLOCK"></a>简单CLOCK</h5><ol>
<li>初始时每个都为1，扫描指针指向第一个元素</li>
<li>如果所需页面存在，把对应的置为1（不用改扫描指针）</li>
<li>如果不存在，移动扫描指针（过程中把1改为0）直到遇到第一个0，把它t出去，换成新的进来置为1，然后扫描指针指向下一位</li>
</ol>
<h5 id="改进CLOCK"><a href="#改进CLOCK" class="headerlink" title="改进CLOCK"></a>改进CLOCK</h5><p>优先淘汰没写过的页面</p>
<p><img src="/2023/12/26/operating-system/image-20231215151450300.png" alt="image-20231215151450300"></p>
<h4 id="页面分配"><a href="#页面分配" class="headerlink" title="页面分配"></a>页面分配</h4><p><img src="/2023/12/26/operating-system/image-20231215151547874.png" alt="image-20231215151547874"></p>
<h5 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h5><p><img src="/2023/12/26/operating-system/image-20231215151648557.png" alt="image-20231215151648557"></p>
<h5 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h5><p><img src="/2023/12/26/operating-system/image-20231215151822291.png" alt="image-20231215151822291"></p>
<ol>
<li><p>固定分配局部置换</p>
<p>一开始分配固定数量，然后进程内部选页换入换出，页面数量始终固定</p>
</li>
<li><p>可变分配全局置换</p>
<p>缺页从全局空闲块队列取，无空闲块则随便选个进程的某个页调出分配给缺页进程</p>
</li>
<li><p>可变分配局部置换</p>
<p>一开始分配一定数量，缺页时只在自己内部换入换出。</p>
<p>监测缺页率，太高就给它多几个物理块</p>
</li>
</ol>
<p><img src="/2023/12/26/operating-system/image-20231215152108930.png" alt="image-20231215152108930"></p>
<p><img src="/2023/12/26/operating-system/image-20231215152227853.png" alt="image-20231215152227853"></p>
<h5 id="颠簸"><a href="#颠簸" class="headerlink" title="颠簸"></a>颠簸</h5><p><img src="/2023/12/26/operating-system/image-20231215152304390.png" alt="image-20231215152304390"></p>
<h5 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h5><p><img src="/2023/12/26/operating-system/image-20231215152430810.png" alt="image-20231215152430810"></p>
<p>用来确定驻留集</p>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p><img src="/2023/12/26/operating-system/image-20231215152526627.png" alt="image-20231215152526627"></p>
<p><img src="/2023/12/26/operating-system/image-20231215152557043.png" alt="image-20231215152557043"></p>
<h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p><img src="/2023/12/26/operating-system/image-20231212011359313.png" alt="image-20231212011359313"></p>
<p><img src="/2023/12/26/operating-system/image-20231212011434037.png" alt="image-20231212011434037"></p>
<h2 id="按需调页"><a href="#按需调页" class="headerlink" title="按需调页"></a>按需调页</h2><p><img src="/2023/12/26/operating-system/image-20231212011659317.png" alt="image-20231212011659317"></p>
<p><img src="/2023/12/26/operating-system/image-20231212011805609.png" alt="image-20231212011805609"></p>
<p><img src="/2023/12/26/operating-system/image-20231212011828132.png" alt="image-20231212011828132"></p>
<p><img src="/2023/12/26/operating-system/image-20231212011854713.png" alt="image-20231212011854713"></p>
<p><img src="/2023/12/26/operating-system/image-20231212011928865.png" alt="image-20231212011928865"></p>
<p><img src="/2023/12/26/operating-system/image-20231212012025865.png" alt="image-20231212012025865"></p>
<p><img src="/2023/12/26/operating-system/image-20231212012301161.png" alt="image-20231212012301161"></p>
<h2 id="页面置换算法-1"><a href="#页面置换算法-1" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="FIFO-1"><a href="#FIFO-1" class="headerlink" title="FIFO"></a>FIFO</h3><p><img src="/2023/12/26/operating-system/image-20231212012400097.png" alt="image-20231212012400097"></p>
<h3 id="OPT-1"><a href="#OPT-1" class="headerlink" title="OPT"></a>OPT</h3><p><img src="/2023/12/26/operating-system/image-20231212012411923.png" alt="image-20231212012411923"></p>
<h3 id="LRU-1"><a href="#LRU-1" class="headerlink" title="LRU"></a>LRU</h3><p><img src="/2023/12/26/operating-system/image-20231212012423419.png" alt="image-20231212012423419"></p>
<p><img src="/2023/12/26/operating-system/image-20231212012635018.png" alt="image-20231212012635018"></p>
<p><img src="/2023/12/26/operating-system/image-20231212012656691.png" alt="image-20231212012656691"></p>
<h3 id="CLOCK"><a href="#CLOCK" class="headerlink" title="CLOCK"></a>CLOCK</h3><p><img src="/2023/12/26/operating-system/image-20231212012719074.png" alt="image-20231212012719074"></p>
<p><img src="/2023/12/26/operating-system/image-20231212012737172.png" alt="image-20231212012737172"></p>
<p><img src="/2023/12/26/operating-system/image-20231212153415550.png" alt="image-20231212153415550"></p>
<p><img src="/2023/12/26/operating-system/image-20231212153439485.png" alt="image-20231212153439485"></p>
<p><img src="/2023/12/26/operating-system/image-20231212153513472.png" alt="image-20231212153513472"></p>
<p><img src="/2023/12/26/operating-system/image-20231212153529194.png" alt="image-20231212153529194"></p>
<h2 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h2><h3 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h3><p><img src="/2023/12/26/operating-system/image-20231212153714275.png" alt="image-20231212153714275"></p>
<h3 id="swap与工作集"><a href="#swap与工作集" class="headerlink" title="swap与工作集"></a>swap与工作集</h3><h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><p><img src="/2023/12/26/operating-system/image-20231212153744449.png" alt="image-20231212153744449"></p>
<h4 id="工作集-1"><a href="#工作集-1" class="headerlink" title="工作集"></a>工作集</h4><p><img src="/2023/12/26/operating-system/image-20231212153907111.png" alt="image-20231212153907111"></p>
<p><img src="/2023/12/26/operating-system/image-20231212153941822.png" alt="image-20231212153941822"></p>
<p><img src="/2023/12/26/operating-system/image-20231212154046046.png" alt="image-20231212154046046"></p>
<p><img src="/2023/12/26/operating-system/image-20231212154145323.png" alt="image-20231212154145323"></p>
<h3 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h3><h4 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h4><p><img src="/2023/12/26/operating-system/image-20231212154231964.png" alt="image-20231212154231964"></p>
<h4 id="颠簸-1"><a href="#颠簸-1" class="headerlink" title="颠簸"></a>颠簸</h4><p><img src="/2023/12/26/operating-system/image-20231212154317496.png" alt="image-20231212154317496"></p>
<p><img src="/2023/12/26/operating-system/image-20231212154341605.png" alt="image-20231212154341605"></p>
<h4 id="页错误率PFF"><a href="#页错误率PFF" class="headerlink" title="页错误率PFF"></a>页错误率PFF</h4><p><img src="/2023/12/26/operating-system/image-20231212154438562.png" alt="image-20231212154438562"></p>
<h4 id="Belady异常"><a href="#Belady异常" class="headerlink" title="Belady异常"></a>Belady异常</h4><p><img src="/2023/12/26/operating-system/image-20231212154514364.png" alt="image-20231212154514364"></p>
<p><img src="/2023/12/26/operating-system/image-20231212154537649.png" alt="image-20231212154537649"></p>
<h3 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h3><p><img src="/2023/12/26/operating-system/image-20231212154617798.png" alt="image-20231212154617798"></p>
<h2 id="CSAPP"><a href="#CSAPP" class="headerlink" title="CSAPP"></a>CSAPP</h2><h3 id="地址翻译-3"><a href="#地址翻译-3" class="headerlink" title="地址翻译"></a>地址翻译</h3><p><img src="/2023/12/26/operating-system/image-20231212155000025.png" alt="image-20231212155000025"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155013781.png" alt="image-20231212155013781"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155034290.png" alt="image-20231212155034290"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155058132.png" alt="image-20231212155058132"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155119927.png" alt="image-20231212155119927"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155525186.png" alt="image-20231212155525186"></p>
<h3 id="映射方法"><a href="#映射方法" class="headerlink" title="映射方法"></a>映射方法</h3><p><img src="/2023/12/26/operating-system/image-20231212155650534.png" alt="image-20231212155650534"></p>
<p><img src="/2023/12/26/operating-system/image-20231212160116087.png" alt="image-20231212160116087"></p>
<h4 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h4><p><img src="/2023/12/26/operating-system/image-20231212155712254.png" alt="image-20231212155712254"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155721629.png" alt="image-20231212155721629"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155744351.png" alt="image-20231212155744351"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155752305.png" alt="image-20231212155752305"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155814168.png" alt="image-20231212155814168"></p>
<p><img src="/2023/12/26/operating-system/image-20231212160050969.png" alt="image-20231212160050969"></p>
<p><img src="/2023/12/26/operating-system/image-20231212160101240.png" alt="image-20231212160101240"></p>
<h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p><img src="/2023/12/26/operating-system/image-20231212155826867.png" alt="image-20231212155826867"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155900547.png" alt="image-20231212155900547"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155911124.png" alt="image-20231212155911124"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155925592.png" alt="image-20231212155925592"></p>
<p><img src="/2023/12/26/operating-system/image-20231212155937312.png" alt="image-20231212155937312"></p>
<h4 id="组相联"><a href="#组相联" class="headerlink" title="组相联"></a>组相联</h4><p><img src="/2023/12/26/operating-system/image-20231212155953882.png" alt="image-20231212155953882"></p>
<p><img src="/2023/12/26/operating-system/image-20231212160001192.png" alt="image-20231212160001192"></p>
<p><img src="/2023/12/26/operating-system/image-20231212160016055.png" alt="image-20231212160016055"></p>
<p><img src="/2023/12/26/operating-system/image-20231212160027767.png" alt="image-20231212160027767"></p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>它这里引入了一个很有意思的概念，将一般的内存映射与mmap结合在了一起。</p>
<p>对于进程来说，<strong>其代码段和数据段相当于映射到了某个磁盘上的普通文件，栈和.bss段相当于映射到了某个匿名文件</strong>。体会一下这种思想。</p>
<p><img src="/2023/12/26/operating-system/image-20231212160159859.png" alt="image-20231212160159859"></p>
<p><img src="/2023/12/26/operating-system/image-20231212161217005.png" alt="image-20231212161217005"></p>
<p><img src="/2023/12/26/operating-system/image-20231212161256867.png" alt="image-20231212161256867"></p>
<p><img src="/2023/12/26/operating-system/image-20231212161309986.png" alt="image-20231212161309986"></p>
<p><img src="/2023/12/26/operating-system/image-20231212161350185.png" alt="image-20231212161350185"></p>
<p><img src="/2023/12/26/operating-system/image-20231212161357613.png" alt="image-20231212161357613"></p>
<p><img src="/2023/12/26/operating-system/image-20231212161412480.png" alt="image-20231212161412480"></p>
<p><img src="/2023/12/26/operating-system/image-20231212161421030.png" alt="image-20231212161421030"></p>
<p><img src="/2023/12/26/operating-system/image-20231212161504972.png" alt="image-20231212161504972"></p>
<p><img src="/2023/12/26/operating-system/image-20231212161539376.png" alt="image-20231212161539376"></p>
<h1 id="08-I-O与存储"><a href="#08-I-O与存储" class="headerlink" title="08 I/O与存储"></a>08 I/O与存储</h1><h2 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h2><p><img src="/2023/12/26/operating-system/image-20231212163654446.png" alt="image-20231212163654446"></p>
<p><img src="/2023/12/26/operating-system/image-20231212163724400.png" alt="image-20231212163724400"></p>
<p><img src="/2023/12/26/operating-system/image-20231212163743544.png" alt="image-20231212163743544"></p>
<p><img src="/2023/12/26/operating-system/image-20231212163804302.png" alt="image-20231212163804302"></p>
<h2 id="IO系统"><a href="#IO系统" class="headerlink" title="IO系统"></a>IO系统</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="/2023/12/26/operating-system/image-20231212163833632.png" alt="image-20231212163833632"></p>
<p><img src="/2023/12/26/operating-system/image-20231212163922352.png" alt="image-20231212163922352"></p>
<p>我记得ghost把enclave等等抽象为了设备文件，也只能说确实牛逼</p>
<h3 id="命令发送"><a href="#命令发送" class="headerlink" title="命令发送"></a>命令发送</h3><p><img src="/2023/12/26/operating-system/image-20231212163957156.png" alt="image-20231212163957156"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164007841.png" alt="image-20231212164007841"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164037542.png" alt="image-20231212164037542"></p>
<h2 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h2><p><img src="/2023/12/26/operating-system/image-20231212164058789.png" alt="image-20231212164058789"></p>
<h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p><img src="/2023/12/26/operating-system/image-20231212164117105.png" alt="image-20231212164117105"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164138780.png" alt="image-20231212164138780"></p>
<h3 id="中断-1"><a href="#中断-1" class="headerlink" title="中断"></a>中断</h3><p><img src="/2023/12/26/operating-system/image-20231212164151766.png" alt="image-20231212164151766"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164242204.png" alt="image-20231212164242204"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164259618.png" alt="image-20231212164259618"></p>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p><img src="/2023/12/26/operating-system/image-20231212164321729.png" alt="image-20231212164321729"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164337688.png" alt="image-20231212164337688"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164347403.png" alt="image-20231212164347403"></p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p><img src="/2023/12/26/operating-system/image-20231212164410855.png" alt="image-20231212164410855"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164457302.png" alt="image-20231212164457302"></p>
<h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><p><img src="/2023/12/26/operating-system/image-20231212164537505.png" alt="image-20231212164537505"></p>
<h3 id="软件缓冲"><a href="#软件缓冲" class="headerlink" title="软件缓冲"></a>软件缓冲</h3><p><img src="/2023/12/26/operating-system/image-20231212164610223.png" alt="image-20231212164610223"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164631135.png" alt="image-20231212164631135"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164648842.png" alt="image-20231212164648842"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164752160.png" alt="image-20231212164752160"></p>
<h3 id="SPOOLING"><a href="#SPOOLING" class="headerlink" title="SPOOLING"></a>SPOOLING</h3><p>可以破坏死锁条件的互斥条件，预防死锁</p>
<p><img src="/2023/12/26/operating-system/image-20231212164847126.png" alt="image-20231212164847126"></p>
<p><img src="/2023/12/26/operating-system/image-20231212164909326.png" alt="image-20231212164909326"></p>
<h2 id="磁盘设备"><a href="#磁盘设备" class="headerlink" title="磁盘设备"></a>磁盘设备</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p><img src="/2023/12/26/operating-system/image-20231212165343775.png" alt="image-20231212165343775"></p>
<p><img src="/2023/12/26/operating-system/image-20231212165430863.png" alt="image-20231212165430863"></p>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p><img src="/2023/12/26/operating-system/image-20231212165647224.png" alt="image-20231212165647224"></p>
<h4 id="FCFS-1"><a href="#FCFS-1" class="headerlink" title="FCFS"></a>FCFS</h4><p><img src="/2023/12/26/operating-system/image-20231212165523469.png" alt="image-20231212165523469"></p>
<h4 id="SSTF"><a href="#SSTF" class="headerlink" title="SSTF"></a>SSTF</h4><p><img src="/2023/12/26/operating-system/image-20231212165539404.png" alt="image-20231212165539404"></p>
<h4 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h4><p><img src="/2023/12/26/operating-system/image-20231212165557146.png" alt="image-20231212165557146"></p>
<h4 id="C-SCAN"><a href="#C-SCAN" class="headerlink" title="C-SCAN"></a>C-SCAN</h4><p><img src="/2023/12/26/operating-system/image-20231212165614089.png" alt="image-20231212165614089"></p>
<h4 id="C-LOOK"><a href="#C-LOOK" class="headerlink" title="C-LOOK"></a>C-LOOK</h4><p><img src="/2023/12/26/operating-system/image-20231212165634326.png" alt="image-20231212165634326"></p>
<h3 id="磁盘编址"><a href="#磁盘编址" class="headerlink" title="磁盘编址"></a>磁盘编址</h3><p><img src="/2023/12/26/operating-system/image-20231212165826701.png" alt="image-20231212165826701"></p>
<p><img src="/2023/12/26/operating-system/image-20231212165900840.png" alt="image-20231212165900840"></p>
<p><img src="/2023/12/26/operating-system/image-20231212170110557.png" alt="image-20231212170110557"></p>
<h4 id="CHS"><a href="#CHS" class="headerlink" title="CHS"></a>CHS</h4><p><img src="/2023/12/26/operating-system/image-20231212170000950.png" alt="image-20231212170000950"></p>
<p><img src="/2023/12/26/operating-system/image-20231212170012161.png" alt="image-20231212170012161"></p>
<p><img src="/2023/12/26/operating-system/image-20231212170028859.png" alt="image-20231212170028859"></p>
<h4 id="扇区编号LBA"><a href="#扇区编号LBA" class="headerlink" title="扇区编号LBA"></a>扇区编号LBA</h4><p><img src="/2023/12/26/operating-system/image-20231212165922199.png" alt="image-20231212165922199"></p>
<h3 id="进程IO"><a href="#进程IO" class="headerlink" title="进程IO"></a>进程IO</h3><p><img src="/2023/12/26/operating-system/image-20231212170149231.png" alt="image-20231212170149231"></p>
<p><img src="/2023/12/26/operating-system/image-20231212170218489.png" alt="image-20231212170218489"></p>
<h3 id="硬盘布局"><a href="#硬盘布局" class="headerlink" title="硬盘布局"></a>硬盘布局</h3><p><img src="/2023/12/26/operating-system/image-20231212170259413.png" alt="image-20231212170259413"></p>
<p><img src="/2023/12/26/operating-system/image-20231212171825365.png" alt="image-20231212171825365"></p>
<p><img src="/2023/12/26/operating-system/image-20231212171840860.png" alt="image-20231212171840860"></p>
<p>确实诶，分区完就变成/dev/sda3这种了，然后依然可以对sda3进行fdisk</p>
<h3 id="页面置换-1"><a href="#页面置换-1" class="headerlink" title="页面置换"></a>页面置换</h3><p><img src="/2023/12/26/operating-system/image-20231212172227683.png" alt="image-20231212172227683"></p>
<p><img src="/2023/12/26/operating-system/image-20231212172301828.png" alt="image-20231212172301828"></p>
<h3 id="固态硬盘SSD"><a href="#固态硬盘SSD" class="headerlink" title="固态硬盘SSD"></a>固态硬盘SSD</h3><h4 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h4><p><img src="/2023/12/26/operating-system/image-20231212172413618.png" alt="image-20231212172413618"></p>
<p><img src="/2023/12/26/operating-system/image-20231212172444005.png" alt="image-20231212172444005"></p>
<p><img src="/2023/12/26/operating-system/image-20231212172504383.png" alt="image-20231212172504383"></p>
<h4 id="FTL"><a href="#FTL" class="headerlink" title="FTL"></a>FTL</h4><p><img src="/2023/12/26/operating-system/image-20231212172556762.png" alt="image-20231212172556762"></p>
<h5 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h5><p><img src="/2023/12/26/operating-system/image-20231212172609192.png" alt="image-20231212172609192"></p>
<h6 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h6><p><img src="/2023/12/26/operating-system/image-20231212172655147.png" alt="image-20231212172655147"></p>
<h6 id="磨损平衡"><a href="#磨损平衡" class="headerlink" title="磨损平衡"></a>磨损平衡</h6><p><img src="/2023/12/26/operating-system/image-20231212173022907.png" alt="image-20231212173022907"></p>
<p><img src="/2023/12/26/operating-system/image-20231212173047619.png" alt="image-20231212173047619"></p>
<h6 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h6><p><img src="/2023/12/26/operating-system/image-20231212173119529.png" alt="image-20231212173119529"></p>
<p><img src="/2023/12/26/operating-system/image-20231212173154055.png" alt="image-20231212173154055"></p>
<h1 id="09-文件系统"><a href="#09-文件系统" class="headerlink" title="09 文件系统"></a>09 文件系统</h1><h2 id="王道-1"><a href="#王道-1" class="headerlink" title="王道"></a>王道</h2><h3 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h3><p><img src="/2023/12/26/operating-system/image-20231215161403084.png" alt="image-20231215161403084"></p>
<h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p><img src="/2023/12/26/operating-system/image-20231215161505464.png" alt="image-20231215161505464"></p>
<p>注意这个顺序文件可以顺序存储或者链式存储</p>
<p><img src="/2023/12/26/operating-system/image-20231215161704676.png" alt="image-20231215161704676"></p>
<p>串结构就是没有按关键字排序</p>
<p>随机存储和检索记录还是两个概念</p>
<p><img src="/2023/12/26/operating-system/image-20231215161800012.png" alt="image-20231215161800012"></p>
<h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p><img src="/2023/12/26/operating-system/image-20231215161847039.png" alt="image-20231215161847039"></p>
<h4 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h4><p><img src="/2023/12/26/operating-system/image-20231215161945122.png" alt="image-20231215161945122"></p>
<p>相当于离散索引了呗</p>
<p><img src="/2023/12/26/operating-system/image-20231215162026397.png" alt="image-20231215162026397"></p>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><img src="/2023/12/26/operating-system/image-20231215162251546.png" alt="image-20231215162251546"></p>
<p><img src="/2023/12/26/operating-system/image-20231215162352069.png" alt="image-20231215162352069"></p>
<p><img src="/2023/12/26/operating-system/image-20231215162443206.png" alt="image-20231215162443206"></p>
<p>由于减少了目录大小，所以减少了磁盘块占用大小，所以增大了索引效率</p>
<p>也就是说FCB实际上就是dentry+inode吗</p>
<p><img src="/2023/12/26/operating-system/image-20231215163118434.png" alt="image-20231215163118434"></p>
<h3 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p><img src="/2023/12/26/operating-system/image-20231215162813027.png" alt="image-20231215162813027"></p>
<p><img src="/2023/12/26/operating-system/image-20231215162859868.png" alt="image-20231215162859868"></p>
<h4 id="链式分配"><a href="#链式分配" class="headerlink" title="链式分配"></a>链式分配</h4><p><img src="/2023/12/26/operating-system/image-20231215162915964.png" alt="image-20231215162915964"></p>
<h5 id="隐式"><a href="#隐式" class="headerlink" title="隐式"></a>隐式</h5><p>默认指隐式链接</p>
<p><img src="/2023/12/26/operating-system/image-20231215163138411.png" alt="image-20231215163138411"></p>
<p><img src="/2023/12/26/operating-system/image-20231215163203185.png" alt="image-20231215163203185"></p>
<h5 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h5><p><img src="/2023/12/26/operating-system/image-20231215163238338.png" alt="image-20231215163238338"></p>
<p>每次查FAT就够了</p>
<p><img src="/2023/12/26/operating-system/image-20231215163328135.png" alt="image-20231215163328135"></p>
<p>FAT不会读磁盘</p>
<h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p><img src="/2023/12/26/operating-system/image-20231215164020933.png" alt="image-20231215164020933"></p>
<h5 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h5><p>感受一下跟FAT的差异</p>
<p><img src="/2023/12/26/operating-system/image-20231215163520515.png" alt="image-20231215163520515"></p>
<p>当一个磁盘块装不完全部索引，就需要采取以下几种方案：</p>
<h5 id="链接方案"><a href="#链接方案" class="headerlink" title="链接方案"></a>链接方案</h5><p><img src="/2023/12/26/operating-system/image-20231215163651254.png" alt="image-20231215163651254"></p>
<p>这个也就是咱的隐式链接了</p>
<h5 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h5><p><img src="/2023/12/26/operating-system/image-20231215163836049.png" alt="image-20231215163836049"></p>
<p>注意文件大小和IO次数的计算</p>
<h5 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h5><p><img src="/2023/12/26/operating-system/image-20231215163930480.png" alt="image-20231215163930480"></p>
<h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><h4 id="空闲表"><a href="#空闲表" class="headerlink" title="空闲表"></a>空闲表</h4><p><img src="/2023/12/26/operating-system/image-20231215165316909.png" alt="image-20231215165316909"></p>
<h4 id="空闲链表"><a href="#空闲链表" class="headerlink" title="空闲链表"></a>空闲链表</h4><p><img src="/2023/12/26/operating-system/image-20231215165353195.png" alt="image-20231215165353195"></p>
<p><img src="/2023/12/26/operating-system/image-20231215165411195.png" alt="image-20231215165411195"></p>
<p><img src="/2023/12/26/operating-system/image-20231215165432482.png" alt="image-20231215165432482"></p>
<h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p><img src="/2023/12/26/operating-system/image-20231215165503214.png" alt="image-20231215165503214"></p>
<p>注意与盘块号的转换</p>
<h4 id="成组链接"><a href="#成组链接" class="headerlink" title="成组链接"></a>成组链接</h4><p>unix分成块组，这下看懂了</p>
<p><img src="/2023/12/26/operating-system/image-20231215165629119.png" alt="image-20231215165629119"></p>
<p>并且注意，每个块组第一块也是可以分配出去的，这时候就需要合并了</p>
<p>同理可得回收也要加层，感觉有点b+树那味了：</p>
<p><img src="/2023/12/26/operating-system/image-20231215165845285.png" alt="image-20231215165845285"></p>
<h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p><img src="/2023/12/26/operating-system/image-20231215165935092.png" alt="image-20231215165935092"></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img src="/2023/12/26/operating-system/image-20231215170004395.png" alt="image-20231215170004395"></p>
<h4 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h4><p><img src="/2023/12/26/operating-system/image-20231215170030414.png" alt="image-20231215170030414"></p>
<p><img src="/2023/12/26/operating-system/image-20231215170059442.png" alt="image-20231215170059442"></p>
<p><img src="/2023/12/26/operating-system/image-20231215170227295.png" alt="image-20231215170227295"></p>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p><img src="/2023/12/26/operating-system/image-20231215170131455.png" alt="image-20231215170131455"></p>
<h4 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h4><p>read、write系统调用</p>
<h3 id="文件共享与保护"><a href="#文件共享与保护" class="headerlink" title="文件共享与保护"></a>文件共享与保护</h3><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p><img src="/2023/12/26/operating-system/image-20231215170302694.png" alt="image-20231215170302694"></p>
<p>硬链接与软链接</p>
<h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><p>这也就是inode了</p>
<p><img src="/2023/12/26/operating-system/image-20231215170344704.png" alt="image-20231215170344704"></p>
<h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><p><img src="/2023/12/26/operating-system/image-20231215170415878.png" alt="image-20231215170415878"></p>
<p>xv6就实现过，具体在open中switch-case</p>
<p><img src="/2023/12/26/operating-system/image-20231215170513759.png" alt="image-20231215170513759"></p>
<h4 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h4><h5 id="口令"><a href="#口令" class="headerlink" title="口令"></a>口令</h5><p><img src="/2023/12/26/operating-system/image-20231215170549602.png" alt="image-20231215170549602"></p>
<h5 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h5><p><img src="/2023/12/26/operating-system/image-20231215170611765.png" alt="image-20231215170611765"></p>
<h5 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h5><p><img src="/2023/12/26/operating-system/image-20231215170642512.png" alt="image-20231215170642512"></p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><p><img src="/2023/12/26/operating-system/image-20231215170752365.png" alt="image-20231215170752365"></p>
<p>用户接口：文件基本操作</p>
<p>文件目录：文件目录</p>
<p>存取控制：文件保护</p>
<p>逻辑文件与缓冲区：逻辑结构</p>
<p>物理文件系统：物理结构</p>
<p>辅助分配：空间管理</p>
<p>设备管理：磁盘管理</p>
<p><img src="/2023/12/26/operating-system/image-20231215170927318.png" alt="image-20231215170927318"></p>
<h4 id="全局结构"><a href="#全局结构" class="headerlink" title="全局结构"></a>全局结构</h4><ol>
<li><p>物理格式化</p>
<p><img src="/2023/12/26/operating-system/image-20231215171001190.png" alt="image-20231215171001190"></p>
</li>
<li><p>逻辑格式化</p>
<p><img src="/2023/12/26/operating-system/image-20231215171019963.png" alt="image-20231215171019963"></p>
</li>
<li><p>内存结构</p>
<p><img src="/2023/12/26/operating-system/image-20231215171257687.png" alt="image-20231215171257687"></p>
</li>
</ol>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><img src="/2023/12/26/operating-system/image-20231215171453724.png" alt="image-20231215171453724"></p>
<p>很帅很帅的VFS</p>
<p><img src="/2023/12/26/operating-system/image-20231215171623873.png" alt="image-20231215171623873"></p>
<h3 id="挂载与装载"><a href="#挂载与装载" class="headerlink" title="挂载与装载"></a>挂载与装载</h3><p><img src="/2023/12/26/operating-system/image-20231215171704841.png" alt="image-20231215171704841"></p>
<p>咱在fuse也做了这件事。文件系统除了这些之外还得对自己内部结构进行初始化</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="/2023/12/26/operating-system/image-20231212174138039.png" alt="image-20231212174138039"></p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p><img src="/2023/12/26/operating-system/image-20231212174418362.png" alt="image-20231212174418362"></p>
<h4 id="连续存储"><a href="#连续存储" class="headerlink" title="连续存储"></a>连续存储</h4><p><img src="/2023/12/26/operating-system/image-20231212174200133.png" alt="image-20231212174200133"></p>
<p><img src="/2023/12/26/operating-system/image-20231212174227174.png" alt="image-20231212174227174"></p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><img src="/2023/12/26/operating-system/image-20231212174248991.png" alt="image-20231212174248991"></p>
<h4 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h4><p><img src="/2023/12/26/operating-system/image-20231212174302650.png" alt="image-20231212174302650"></p>
<p><img src="/2023/12/26/operating-system/image-20231212174324702.png" alt="image-20231212174324702"></p>
<p><img src="/2023/12/26/operating-system/image-20231212174358830.png" alt="image-20231212174358830"></p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><h4 id="树状目录"><a href="#树状目录" class="headerlink" title="树状目录"></a>树状目录</h4><p><img src="/2023/12/26/operating-system/image-20231212174507288.png" alt="image-20231212174507288"></p>
<p><img src="/2023/12/26/operating-system/image-20231212174522719.png" alt="image-20231212174522719"></p>
<h4 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h4><h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><p><img src="/2023/12/26/operating-system/image-20231212174540569.png" alt="image-20231212174540569"></p>
<p><img src="/2023/12/26/operating-system/image-20231212174645166.png" alt="image-20231212174645166"></p>
<h5 id="路径解析"><a href="#路径解析" class="headerlink" title="路径解析"></a>路径解析</h5><p><img src="/2023/12/26/operating-system/image-20231212174612782.png" alt="image-20231212174612782"></p>
<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><p><img src="/2023/12/26/operating-system/image-20231212174730193.png" alt="image-20231212174730193"></p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p><img src="/2023/12/26/operating-system/image-20231212174753764.png" alt="image-20231212174753764"></p>
<p><img src="/2023/12/26/operating-system/image-20231212174818843.png" alt="image-20231212174818843"></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="提高性能"><a href="#提高性能" class="headerlink" title="提高性能"></a>提高性能</h4><p><img src="/2023/12/26/operating-system/image-20231212174836078.png" alt="image-20231212174836078"></p>
<p><img src="/2023/12/26/operating-system/image-20231212174911963.png" alt="image-20231212174911963"></p>
<h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p><img src="/2023/12/26/operating-system/image-20231212175029943.png" alt="image-20231212175029943"></p>
<h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><p><img src="/2023/12/26/operating-system/image-20231212175106433.png" alt="image-20231212175106433"></p>
<p><img src="/2023/12/26/operating-system/image-20231212175121235.png" alt="image-20231212175121235"></p>
<p><img src="/2023/12/26/operating-system/image-20231212175135322.png" alt="image-20231212175135322"></p>
<h2 id="EXT2文件系统"><a href="#EXT2文件系统" class="headerlink" title="EXT2文件系统"></a>EXT2文件系统</h2><p><img src="/2023/12/26/operating-system/image-20231212175240614.png" alt="image-20231212175240614"></p>
<h3 id="磁盘组织"><a href="#磁盘组织" class="headerlink" title="磁盘组织"></a>磁盘组织</h3><p><img src="/2023/12/26/operating-system/image-20231212175335746.png" alt="image-20231212175335746"></p>
<h4 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h4><p><img src="/2023/12/26/operating-system/image-20231212175444720.png" alt="image-20231212175444720"></p>
<h4 id="块组描述符"><a href="#块组描述符" class="headerlink" title="块组描述符"></a>块组描述符</h4><p><img src="/2023/12/26/operating-system/image-20231212180037436.png" alt="image-20231212180037436"></p>
<h4 id="位图-1"><a href="#位图-1" class="headerlink" title="位图"></a>位图</h4><p><img src="/2023/12/26/operating-system/image-20231212180104608.png" alt="image-20231212180104608"></p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><img src="/2023/12/26/operating-system/image-20231212180125155.png" alt="image-20231212180125155"></p>
<p><img src="/2023/12/26/operating-system/image-20231212180144842.png" alt="image-20231212180144842"></p>
<h2 id="Windows-FAT"><a href="#Windows-FAT" class="headerlink" title="Windows FAT"></a>Windows FAT</h2><p><img src="/2023/12/26/operating-system/image-20231212180343276.png" alt="image-20231212180343276"></p>
<p><img src="/2023/12/26/operating-system/image-20231212180649707.png" alt="image-20231212180649707"></p>
<p><img src="/2023/12/26/operating-system/image-20231212180722817.png" alt="image-20231212180722817"></p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="基本交互"><a href="#基本交互" class="headerlink" title="基本交互"></a>基本交互</h3><p><img src="/2023/12/26/operating-system/image-20231212180909163.png" alt="image-20231212180909163"></p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><h4 id="Redo"><a href="#Redo" class="headerlink" title="Redo"></a>Redo</h4><p><img src="/2023/12/26/operating-system/image-20231212180931530.png" alt="image-20231212180931530"></p>
<p><img src="/2023/12/26/operating-system/image-20231212180958804.png" alt="image-20231212180958804"></p>
<h3 id="应用文件系统"><a href="#应用文件系统" class="headerlink" title="应用文件系统"></a>应用文件系统</h3><h4 id="EXT4"><a href="#EXT4" class="headerlink" title="EXT4"></a>EXT4</h4><p><img src="/2023/12/26/operating-system/image-20231212181056088.png" alt="image-20231212181056088"></p>
<h4 id="LFS"><a href="#LFS" class="headerlink" title="LFS"></a>LFS</h4><h5 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h5><p>感觉这些存储领域的东西很多还是共通的。可以思考下与deduplication system的相关性。</p>
<p><img src="/2023/12/26/operating-system/image-20231212181144520.png" alt="image-20231212181144520"></p>
<p><img src="/2023/12/26/operating-system/image-20231212181158081.png" alt="image-20231212181158081"></p>
<p><img src="/2023/12/26/operating-system/image-20231212181213771.png" alt="image-20231212181213771"></p>
<h5 id="F2FS"><a href="#F2FS" class="headerlink" title="F2FS"></a>F2FS</h5><p><img src="/2023/12/26/operating-system/image-20231212181308571.png" alt="image-20231212181308571"></p>
]]></content>
  </entry>
  <entry>
    <title>rtt硬件环境搭建</title>
    <url>/2023/10/12/rtt%E7%A1%AC%E4%BB%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="SDK-内核编译"><a href="#SDK-内核编译" class="headerlink" title="SDK/内核编译"></a>SDK/内核编译</h1><p>编译内核和sdk时到没有太大问题，都能靠gpt or 修改menuconfig解决。比较棘手的果然还是只能靠自己摸索硬件hhh</p>
<h1 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h1><p>这个也是狠狠折磨了我许久，gpt也一直满嘴跑火车，毕竟一开始串口连错了所以一直以为自己是烧录没对，整了半天【而且还是正确的操作反反复复尝试……仿佛坐牢】。不过这其中也学到了挺多。</p>
<p><img src="/2023/10/12/rtt%E7%A1%AC%E4%BB%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/f2753b5e6a40f9fea328223b197ede3.png" alt="f2753b5e6a40f9fea328223b197ede3"></p>
<p>具体要做的是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo fdisk /dev/sdb</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于fdisk及part这样的分区工具，这篇文章介绍得很详细：<a href="https://blog.csdn.net/hffwj/article/details/118584422">Linux 系统中关于磁盘分区工具的使用</a></p>
</blockquote>
<p>然后进入后，n命令创建新分区，d删除现有分区。我们需要用n创建两个分区（大小随意），第一个用于存放bin文件。创建完分区之后，使用a命令将分区1标记为Boot，并且使用t将分区1的类型修改为<code>W95 FAT32 (LBA)</code>，随后就可以保存退出了。具体流程及操作结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.37.2).</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 29.72 GiB, 31914983424 bytes, 62333952 sectors</span><br><span class="line">Disk model: Storage Device  </span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0xd4c6d64f</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span></span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended (container <span class="keyword">for</span> logical partitions)</span><br><span class="line">Select (default p): </span><br><span class="line"></span><br><span class="line">Using default response p.</span><br><span class="line">Partition number (1-4, default 1): </span><br><span class="line">First sector (2048-62333951, default 2048): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-62333951, default 62333951): +128M</span><br><span class="line"></span><br><span class="line">Created a new partition 1 of <span class="built_in">type</span> <span class="string">&#x27;Linux&#x27;</span> and of size 128 MiB.</span><br><span class="line">Partition <span class="comment">#1 contains a vfat signature.</span></span><br><span class="line"></span><br><span class="line">Do you want to remove the signature? [Y]es/[N]o: <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">The signature will be removed by a write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span></span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended (container <span class="keyword">for</span> logical partitions)</span><br><span class="line">Select (default p): </span><br><span class="line"></span><br><span class="line">Using default response p.</span><br><span class="line">Partition number (2-4, default 2): </span><br><span class="line">First sector (264192-62333951, default 264192): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (264192-62333951, default 62333951): </span><br><span class="line"></span><br><span class="line">Created a new partition 2 of <span class="built_in">type</span> <span class="string">&#x27;Linux&#x27;</span> and of size 29.6 GiB.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1,2, default 2): 0c</span><br><span class="line">Value out of range.</span><br><span class="line">Partition number (1,2, default 2): 1</span><br><span class="line">Hex code or <span class="built_in">alias</span> (<span class="built_in">type</span> L to list all): 0c</span><br><span class="line"></span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">&#x27;Linux&#x27;</span> to <span class="string">&#x27;W95 FAT32 (LBA)&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): a</span><br><span class="line">Partition number (1,2, default 2): 1</span><br><span class="line"></span><br><span class="line">The bootable flag on partition 1 is enabled now.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line">Disk /dev/sdb: 29.72 GiB, 31914983424 bytes, 62333952 sectors</span><br><span class="line">Disk model: Storage Device  </span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0xd4c6d64f</span><br><span class="line"></span><br><span class="line">Device     Boot  Start      End  Sectors  Size Id Type</span><br><span class="line">/dev/sdb1  *      2048   264191   262144  128M  c W95 FAT32 (LBA)</span><br><span class="line">/dev/sdb2       264192 62333951 62069760 29.6G 83 Linux</span><br><span class="line"></span><br><span class="line">Filesystem/RAID signature on partition 1 will be wiped.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>

<p>然后更新分区表，格式化文件系统，复制bin和sd文件、弹出sd卡：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo partprobe </span><br><span class="line">sudo mkfs.vfat -F 32 /dev/sdb1</span><br><span class="line">sudo mkfs.vfat -F 32 /dev/sdb2</span><br><span class="line">sudo mount /dev/sdb1 /mnt/sdb1</span><br><span class="line">sudo <span class="built_in">cp</span> boot.sd fip.bin /mnt/sdb1</span><br><span class="line">sudo umount /mnt/sdb1 </span><br><span class="line">sudo eject /dev/sdb</span><br></pre></td></tr></table></figure>

<p>就烧录ok了。</p>
<p>与此同时也顺便学了下<a href="https://www.zhihu.com/question/472730443/answer/2453759267">Windows磁盘管理</a>，感觉也挺方便。</p>
<h1 id="串口连接"><a href="#串口连接" class="headerlink" title="串口连接"></a>串口连接</h1><p>不得不说十分惨痛……</p>
<p>也是因为我太狂妄自大不仔细了，一直以为RX就得连RX，TX就得连TX，然后下午焦灼之中才突然想起来这俩是不是以前教过得反着连……搜了一下果然是草。</p>
<p>这个错误害我起码花了三个小时在纠结烧录问题，一直以为没输出是因为烧录不对，发现结果那一刻我真没蚌珠。哎，以后还是别对自己太自信，毕竟本质上这种东西不是专业的学得也不够扎实，做什么都得先查一下该怎么做。</p>
<p>另一个问题是，乱码：</p>
<p><img src="/2023/10/12/rtt%E7%A1%AC%E4%BB%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/58c63791e1b4cac06a827f0ffa6b329.png" alt="58c63791e1b4cac06a827f0ffa6b329"></p>
<p>好像是说使用了个ch340的usb-ttl，似乎这个东西波特率有点问题不准确，具体不大懂：<a href="https://blog.csdn.net/oxp7085915/article/details/80500012">CH340G U-BOOT阶段乱码</a>  总之最后简单粗暴地靠修改波特率为117200解决了。</p>
<p>然后别的倒是没什么问题，虽然摸索也花了点时间，都是小事。对着这张图参照就行了：</p>
<p><img src="/2023/10/12/rtt%E7%A1%AC%E4%BB%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/mmexport1697102534057.jpg" alt="mmexport1697102534057"></p>
<h1 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h1><p>感觉有一些东西，还是比较靠悟性23333在此记录些开发过程中的小发现。</p>
<ol>
<li><p>关于引脚</p>
<p>两个引脚可以通过<img src="/2023/10/12/rtt%E7%A1%AC%E4%BB%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231019162502551.png" alt="image-20231019162502551">这玩意连起来，这样就能使一个引脚的output作为另一个引脚的input。</p>
<p>这是我在开发gpio中断时意识到的。这个道理虽然非常简单，但对于零基础胡乱摸索的我，知道这个还是需要一些灵光一闪。</p>
</li>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>对Linux研究汇总</title>
    <url>/2024/04/10/read_linux/</url>
    <content><![CDATA[<blockquote>
<p>记录一些开发过程中对Linux kernel的阅读&amp;研究，一些认知性的东西真的很容易忘……</p>
<p>注意，全都是个人猜想，很多我还自己不大明白，所以都是阶段性结论，也欢迎指正</p>
</blockquote>
<h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><h2 id="ghOSt"><a href="#ghOSt" class="headerlink" title="ghOSt"></a>ghOSt</h2><p>这几天一直在阅读<a href="https://github.com/google/ghost-kernel">ghOSt</a>的论文及其源码实现，站在目前的知识水平上来看相比于以前有了不少收获，在这里简单记录一下。</p>
<h3 id="24-4-11"><a href="#24-4-11" class="headerlink" title="24.4.11"></a>24.4.11</h3><h4 id="per-CPU和Centralized思考"><a href="#per-CPU和Centralized思考" class="headerlink" title="per-CPU和Centralized思考"></a>per-CPU和Centralized思考</h4><p><u>Linux的原生实现逻辑就是典型的per-CPU model：</u><br>    有一个专门的schedule的idle上下文（或者说idle调度类），当有线程时执行调度逻辑pick target thread，然后switch to；当线程被抢占or完成时再次切回idle上下文进行下一轮pick。调度了则执行对应线程，否则执行调度逻辑，以此类推，这就是典型的per-CPU。</p>
<p>也因此，虽然centralized model被证明很多时候更高效（比如说<a href="https://www.usenix.org/conference/nsdi19/presentation/kaffes">Shinjuku os</a>），但确实是很难实现，估计得修改个大架构。好在，有了ghOSt，我们就把繁琐的逻辑从内核实现移到了用户实现，这就能同时简单地支持per-CPU和centralized了，不得不说确实真的是很伟大的发明。</p>
<h3 id="24-4-12"><a href="#24-4-12" class="headerlink" title="24.4.12"></a>24.4.12</h3><h4 id="Linux内核抢占调度机制"><a href="#Linux内核抢占调度机制" class="headerlink" title="Linux内核抢占调度机制"></a>Linux内核抢占调度机制</h4><p>在Linux内核上实现抢占式调度具体是个什么样的运作方法呢？我们可以分情况讨论：</p>
<ol>
<li><p>在单CPU情况下</p>
<p>一开始，CPU位于idle线程，os启动时切换上下文到Bash中。创建线程时，将线程加入该CPU调度队列中。多进程情况下，线程运行时会发生时钟中断，在时钟中断中检测计算时间片，发生上下文切换回idle进程继续reschedule。</p>
</li>
<li><p>在多处理器情况下</p>
<p>也是差不多的，一个CPU上运行的线程A创建了另一个线程B，这时候有两种情况：</p>
<ol>
<li><p>线程B优先级更高</p>
<p>kernel会直接把B抢占了A</p>
</li>
<li><p>线程B优先级比A低</p>
<p>kernel会把B推开去抢占别的CPU，除非B只能在当前CPU运行</p>
</li>
</ol>
</li>
</ol>
<p>其中，第二种情况稍显复杂，我们可以详细来说说。【下以deadline为例，因为别的比如说RR是非抢占式调度】</p>
<p>首先，全局只有一个调度类对象（不考虑什么多个调度策略，或者说一个线程组只有一个调度类对象，差不多这个意思）。也就是说，创建线程会进入该调度类对象中，然后挑选线程也是从该调度类对象中pick。</p>
<p>当一个CPU上运行的线程A创建了另一个线程B，并且假设目前其他CPU跑满了任务，线程B的优先级很高。创建线程的相关syscall最终会调用<code>activate_task</code>【这点暂时存疑】，然后<code>activate_task</code>会调用调度类中的<code>enqueue_task</code>事件，将线程B压入到deadline调度类的红黑树中。<code>activate_task</code>结束返回之后，紧随其后一般会接一个<code>resched_curr</code>，也即将当前CPU reschedule。</p>
<p>这里，就需要分情况讨论了。</p>
<ol>
<li><p>当线程B优先级&gt;线程A优先级</p>
<p>当前CPU进入到<code>__schedule</code>函数中，就会调用调度类的<code>pick_next_task</code>进而调用<code>set_next_task</code>，从而使得线程B抢占线程A，线程A重新入队，over。</p>
</li>
<li><p>当线程B优先级&lt;=线程A优先级</p>
<p>每个CPU进入到<code>__schedule</code>函数中，都会调用调度类的<code>pick_next_task</code>进而调用<code>set_next_task</code>，从而调用该函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">deadline_queue_push_tasks</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!has_pushable_dl_tasks(rq))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	queue_balance_callback(rq, &amp;per_cpu(dl_push_head, rq-&gt;cpu), push_dl_tasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数以回调形式实现。之后，由于线程B优先级&lt;=线程A优先级，最终会在<code>__schedule</code>中进入该分支：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    __balance_callbacks(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从而调用<code>__balance_callbacks</code>来执行当前CPU上的所有balance callback，从而执行<code>push_dl_tasks</code>。该函数会将自身队列中未运行的线程，发送到那些合适的CPU上进行适当抢占：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * See if the non running -deadline tasks on this rq</span></span><br><span class="line"><span class="comment"> * can be sent to some other CPU where they can preempt</span></span><br><span class="line"><span class="comment"> * and start executing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">push_dl_task</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">	next_task = pick_next_pushable_dl_task(rq);</span><br><span class="line">	<span class="comment">// 找到一个合适的CPU（包括pick算法，以及查看next_task是否能抢占它的curr）</span></span><br><span class="line">	later_rq = find_lock_later_rq(next_task, rq);</span><br><span class="line">	<span class="comment">// 将next_task迁移到target CPU上</span></span><br><span class="line">	deactivate_task(rq, next_task, <span class="number">0</span>);</span><br><span class="line">	set_task_cpu(next_task, later_rq-&gt;cpu);</span><br><span class="line">	activate_task(later_rq, next_task, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 通过发生IPI使其reschedule</span></span><br><span class="line">	resched_curr(later_rq);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故而，此时线程B就可以抢占别的CPU了。</p>
</li>
</ol>
<p>综上所述，如此串联一下，我们可以归纳总结一下当CPU上运行的线程A创建了一个新的线程B时的执行链路：</p>
<ol>
<li><p>B优先级更大：</p>
<p>原CPU：创建线程syscall→<code>fork()</code>→<code>wake_up_new_task</code>→<code>sched_class-&gt;task_woken</code>→执行<code>check_preempt_curr</code>→执行<code>__schedule</code>→pick出B，抢占A，over</p>
</li>
<li><p>B优先级更小：</p>
<p>原CPU：创建线程syscall→<code>fork()</code>→<code>wake_up_new_task</code>→<code>sched_class-&gt;task_woken</code></p>
<p>此时：</p>
<ol>
<li><p>如果该CPU无需reschedule：→执行<code>push_dl_task</code>，迁移该线程，发送IPI→返回用户态</p>
</li>
<li><p>如果该CPU需要reschedule：<code>task_woken</code>无事发生，返回→执行<code>__schedule</code>→无事发生，B依然在原CPU的数据结构中→执行<code>__balance_callbacks</code>→执行<code>push_dl_task</code>，迁移该线程，发送IPI→返回用户态</p>
</li>
</ol>
</li>
</ol>
<p>其实这整个过程的链路是很好追踪的，为什么我花了很久呢：</p>
<p><img src="/2024/04/10/read_linux/ecad9f39d64acccafd9bca9958dfafce.jpg" alt="ecad9f39d64acccafd9bca9958dfafce"></p>
<p>因为我想找<code>push_dl_task</code>结果一直在看<code>pull_dl_task</code>（如图所示……这位置实在很星际啊hhh）也即最终push和pull逻辑是反的，故而我匪夷所思想了半天都没懂hhh……</p>
<p>不过这也让我些许看懂了balance的架构。每个CPU都有一个balance callback的队列，互相之间可以通过这种适时的、异步的调用pull或者push的callback来实现任务窃取，从而实现运行队列的负载均衡。</p>
<h4 id="per-CPU和Centralized思考-1"><a href="#per-CPU和Centralized思考-1" class="headerlink" title="per-CPU和Centralized思考"></a>per-CPU和Centralized思考</h4><ol>
<li>在单CPU情况下，一开始，CPU位于idle线程，os启动时切换上下文到Bash中。创建线程时，将线程加入该CPU调度队列中。多进程情况下，线程运行时会发生时钟中断，在时钟中断中检测计算时间片，发生上下文切换回idle进程继续reschedule。</li>
<li>在多处理器情况下也是差不多的，一个CPU上运行的线程A创建了另一个线程B，并且线程B优先级更高，那么此时kernel就会可能综合考虑什么负载均衡之类的算法挑选出target CPU，将线程B入其队列，然后通过IPI让target CPU进行重新调度。</li>
</ol>
<p>可以很震惊地发现，其实在Linux原生环境中，对于多处理器情况，单纯的per-CPU model为了做到负载均衡，其实已经逐步向centralized model靠拢了，相当于所有CPU都是一个暂时的c位。只不过，这种情况的劣势也很显然，也即我们不得不让工作线程暂停去工作，转而进行这一系列的send IPI（虽然这是异步的），这过程中的各种执行开销，然后估计还要什么获得锁之类的保证同步，感觉开销很大。</p>
<blockquote>
<p>比如说，如果使用ghost，其调用链路会从最坏情况：</p>
<p>创建线程syscall→<code>fork()</code>→<code>wake_up_new_task</code>→<code>sched_class-&gt;task_woken</code>，<code>task_woken</code>无事发生，返回→执行<code>__schedule</code>→无事发生，B依然在原CPU的数据结构中→执行<code>__balance_callbacks</code>→执行<code>push_dl_task</code>，迁移该线程，发送IPI→返回用户态</p>
<p>变成</p>
<p>创建线程syscall→<code>fork()</code>→over</p>
</blockquote>
<p>故而，直接将这些c位工作集中在某个CPU上体现，相当于从原来的均摊开销变为集中开销，可以使得worker CPU更专注于手头的工作，创建线程只需加入agent调度类的调度队列然后返回即可，无需进行更多操作，也是精简了许多开销。</p>
<p>也因此，我们可以很清楚了解到per-CPU在data center场景下的劣势。DC的CPU那么多，你每个CPU都需要一点额外开销，虽然也是均摊了，单估计加起来的开销会大于集中调度，因为后者省去了多线程访问调度数据结构（比如CFS红黑树）之类的并发控制开销。故而，在这种data canter的场景下运行ghost的优势，是显而易见的。</p>
]]></content>
  </entry>
  <entry>
    <title>杂记</title>
    <url>/2024/07/06/thinks/</url>
    <content><![CDATA[<p>最近思考人生有点多，看到一些醍醐灌顶的话感觉仅仅写在日记不足以表达我的感受，于是干脆就决定另开这个模块，引用一些我看了觉得“这简直就是我”的文字了。格式混乱，排版随意。</p>
<h1 id="7-6"><a href="#7-6" class="headerlink" title="7.6"></a>7.6</h1><blockquote>
<p>是否建议从AI转专业到数学系？ - AAOi的回答 - 知乎<br><a href="https://www.zhihu.com/question/654320642/answer/3481125064">https://www.zhihu.com/question/654320642/answer/3481125064</a></p>
</blockquote>
<p><strong>因此如果抱着投机想法学AI，以此为专业，极大可能成为A君这样的辛苦追逐者</strong>。觉得人生就是“追逐一个又一个风口，既要努力奔跑，还要像赌博一样押对赛道”……会觉得这其中毫无规律。</p>
<p>但读phD，搞research（或者在工业界摸爬滚打）的要义在于<strong>看清学科的landscape</strong>，能到足够高鸟瞰，培养学术品味，让你经过训练的直觉带你去向你想要的世界。</p>
<p><strong>是「成为正确的人，才走上正确的路」，而不是「上对路，就成了对的人」。</strong></p>
<p>所以问题并不在数学orCS。你问“是否应该转专业？”，其实想问“我转专业会不会成功？会不会后悔？”。但这不是个好问题。因为没人能向你保证基于你的case你未来会不会后悔。更well formulated的问题是：</p>
<ul>
<li>数学是什么？AI是什么？</li>
<li>数学的landscape是什么？AI的呢？</li>
<li>我为什么喜欢/不喜欢数学？我为什么喜欢/不喜欢AI？</li>
<li>我更容易看清数学的landscape还是AI的？</li>
</ul>
<p>然后用这些问题的结论回答你的问题。</p>
<p>【这段话超级赞同！！】</p>
<p>numberphile podcast有一期采访David Eisenbud，他说他博士刚开始的导师，他跟着做没进展，郁闷。他的同学跟他说“<strong>去找你personally喜欢的人、group of people…他们的领域就是你的领域</strong>”。他真的照做了……对此我深有同感。每当我遇到大难题，比如不知道怎么当leader，怎么做research，怎么社交…解决方法就是去找一个我现实生活中看得见的，在这方面做得优秀的人。不需要问他问题、被教一二三…只要这个人在我视线范围内时常出现，我能看到他，就会豁然开朗，很快自己摸索出方法。</p>
<p>这其实是学任何东西的一条捷径——接触<strong>那些</strong>人。这也是为什么很多过来人教导本科生会说“如果搞research，比刷gpa更重要的是接触牛人大佬”，这些人的情绪、观点和思考方式潜移默化会影响你，是比读书更快的学习方法。</p>
<p>只能说我目前的解决方法是「有意识与这种市场情绪脱相关」，既不要正相关“什么火追什么”，也不要负相关——没来由情绪“就烦这个。恶心。我就不看就不了解”。不要被它控制。回归学术本身，用对待数学的态度对待AI：关注“什么问题？解决方法？为什么对？”。试图理清逻辑脉络；通过模仿/魔改掌握分析/构造方法。其它无关紧要商业八卦如不能给自己带来娱乐就当噪声忽略就好。<br>学生时代一定珍惜时间沉浸学术。本学科的基础知识和常用思维才是看清科技趋势仰仗的「算法」，新闻只是data。</p>
<blockquote>
<p>蒋炎岩老师：给报考同学的劝退信</p>
<p><a href="https://jyywiki.cn/Letter.md">https://jyywiki.cn/Letter.md</a></p>
</blockquote>
<p>对于博士生，你的竞争对手是全世界某个研究领域里最聪明的一些人 (和一些最勤奋的卷王)。<strong>我认为水 (哪怕是 CCF-A 类) paper 太无聊了</strong>。我希望每一份工作都带有 “groundbreaking” 的属性：解决一个全新的重要问题，或是能给旧重要问题的解决带来重要的影响 &lt;……&gt; 我希望投稿的每一份工作都能使这个领域最顶级的专家也感到很 cool，为此，而你必须首先成为领域专家。&lt;……&gt;</p>
<p><strong>常见误区与劝退</strong></p>
<p>以下是一些常见的误区：</p>
<ul>
<li><p>&lt;……&gt; 另一方面，我更希望导师和学生站在平等的合作者位置，并且我非常喜欢能够据理力争挑战我观点的学生。&lt;……&gt;</p>
</li>
<li><p>“我发表了论文/专利/软著，我有过良好的科研训练”：我对论文的标准是 “教会你的大/小专家同行一些不 trivial 的事情”。据我近年观察，<strong>大部分申请者发表的论文都是减分项</strong>。相比于发表了 “错误” 论文或是在大创项目里学会了一本正经胡说八道的同学，我更偏好能耐心读论文和写代码的 “一张有潜力的白纸”。科学研究是脚踏实地的，前人所做到的 (内卷程度) 可能远比你想象得要大，认真读了 3-4 年博士依然没有论文的也大有人在，完全不必急功近利。</p>
</li>
</ul>
<h1 id="7-25"><a href="#7-25" class="headerlink" title="7.25"></a>7.25</h1><p>如果很多问题是有共性的，那么这肯定是个好问题。</p>
<p>感觉能不能找到好的结构往往来源于接触到的data是不是高精度高质量的，另外，有这种压缩的意识也是很关键的，毕竟大多数时间人们被教育的都是模仿、从众、复制，也都生活在与专家不同的恐惧里，这也就自然产生了一种专家写的文章是“神圣”不可被拆解的，<strong>为了防止带入主观的观点而不去将信息变形，所以</strong>根本上大部分人都没有压缩的意识，好像稍微转换了一下，自己就误读了知识，而别人也会因此产生质疑。</p>
<p>【“从混乱中找出结构和有序”，“柏拉图式的学科审美”，这几个概念确实是相当惊艳，其实也就是一直说到嘴痛的所谓“sense”。</p>
<p>他也有一点说得很对，要不断尝试从各种事情中抽离出其中的规律和结构，不管是对的还是错的，总之一定要有自己的想法。抽离出来之后，对他进行验证，这也许就是一种科研。】</p>
<p><a href="https://www.zhihu.com/question/524855881/answer/2825485383?utm_psn=1798437379352162304">https://www.zhihu.com/question/524855881/answer/2825485383?utm_psn=1798437379352162304</a></p>
<p>1.大胆质疑</p>
<p>有人性格如此，习惯挑战权威，有人小心谨慎，大胆假设小心求证。锋芒毕露是一种风格，不动声色步步为营也是一种思路，而共同的底层能力是：</p>
<p>对原假设、备择假设的判别，</p>
<p>【了解各种可能性】</p>
<p>对模型assumption的清晰理解，</p>
<p>【充分理解课题】</p>
<p>对结论成立所依赖的各种condition的敏感。</p>
<p>【敏锐发现所有condition】</p>
<p>2.连接概念</p>
<p>breakthrough可遇不可求，大部分文章也不过是在old wine in new bottle。</p>
<p>由于每个人背景知识的不同，derive conclusion所基于的逻辑框架、推演步骤也不同。</p>
<p>【每个人从一个结论连结推测到另一个结论的方法不一样】</p>
<p>从一个具体的实验结果出发，如何解释这个实验和所在研究领域以往科学发现之间的关系，</p>
<p>如何不拘泥于单一context而是generalize到更广阔的空间，</p>
<p>不同人会串联起不同的概念结构，依据同样的实验结果，做出不同的argument。</p>
<p>3.思想实验</p>
<p>这样的方法论也可以放在实验室科研中，在具体动手之前，在脑中构建 ’if …, then …’</p>
<p>平时读文献也可以练习这样的能力，比如阅读文献follow：abstract + Main Figs + 1st paragraph of Discussion，这样的顺序。从abstract中看是否是自己感兴趣的科研问题。看main figs从横轴纵轴meaning，图形形状、颜色annotation开始，看一遍主图试想如果自己是作者会怎么interpret这些结果和讲一个怎样的故事。Discussion第一段一般会summarize 一个study的主要发现，同时点两句significance。比主图要精炼，比abstract要详细。</p>
<p>对比自己的interpretation和原作者，一方面可以’查缺补漏‘，如果原作者看出了什么connection而自己miss掉的话，另一方面如果interpretation有conflict，说不定就可以作为自己下一个课题的preliminary study。</p>
<p>【反正就是需要带脑子读就是了，不要全盘接受，多问问自己如果是自己会怎么样】</p>
<p>斜插几句，科研上也经常强调communication skill。多表达多交流是一方面，我个人觉得，与其push自己‘大胆发声’，强凹发言，找到自己舒服的表达方式就好。我发现我身边人在提出质疑、表达观点时候，用的方式各有不同。</p>
<p>【草，你怎么知道我现在在纠结这个……】</p>
<h1 id="8-14"><a href="#8-14" class="headerlink" title="8.14"></a>8.14</h1><h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一阶段学习之后，我认为我还需要做到这几点：</p>
<ol>
<li><p>作息再铁一点</p>
<p>经历了两种作息，我觉得还是更喜欢早睡早起型。大致安排：</p>
<p>睡眠时间控制在一天9h左右，不超过9.5h，包含夜晚的8.5h+午休0.5h。</p>
<p>理想作息为晚12.00，早8.30，然后午饭大约12.00，快乐午休到14.00然后继续干活，干到晚上21.00左右，最晚21.30下班。</p>
</li>
<li><p>拒绝焦虑，学会放松&amp;&amp;上下文切换，了解自己的状态</p>
<p>先看看我的这几天总结：</p>
<ol>
<li><p>7.26-8.1六天</p>
<p>信心活力都满满地开始，进度飞快，然而遇到bug开始颓废</p>
</li>
<li><p>8.2</p>
<p>一边出去跟人自习一边继续强撑，状态并没有变得更好。。。</p>
</li>
<li><p>8.3-8.6</p>
<p>精神压力过大开始摆烂，一整个负反馈循环</p>
</li>
<li><p>8.7-</p>
<p>状态恢复</p>
</li>
</ol>
<p>我觉得最核心的，还是<strong>需要搞清楚自己当前是什么感受</strong>，当对一个工作负面情绪的占比达到20%甚至10%以上时，我就需要果断放下，给自己一个总结缓冲的时间，转而去做其他事情，比如说给自己放一天假、做点别的工作，或者两者兼有，flush一下大脑，直到歇完了才能有力气冷静分析和规划，回去选择继续钻研or放弃。</p>
<p>具体实施，我觉得可以每周三晚上不干了小小的break一下，休息完之后扪心自问一下现在是什么状态，前几天是什么状态（记住也要通过分析数据），根据状态调整休息的时间和方式，以及下一步计划，多总结多思考多关注自己多跟人聊聊。</p>
<p>这样一来，周三和周四就作为了一个灵活的休息时间段，根据那段时间的状态调节长度。</p>
</li>
<li><p>践行四象限工作法</p>
<ol>
<li><p>第一象限：重要紧急</p>
<ol>
<li>立即去做，然后思考真的有那么多重要且紧急的事情吗</li>
<li>原则：越少越好，很多由第二象限转化</li>
</ol>
</li>
<li><p>第二象限：重要不紧急</p>
<ol>
<li>做好规划稳步推进，先紧后松，主要精力</li>
<li>具体：目标描述和任务分解<ol>
<li>信息不足：拆解小任务</li>
<li>预期结果不明确：制定明确标准(用于鼓舞士气)</li>
<li>拖延：多做进度控制</li>
</ol>
</li>
</ol>
</li>
<li><p>第三象限：不重要紧急</p>
<ol>
<li>交给别人去做（猴子法）+不要立刻去做而是先评估重要性</li>
<li>原则：甩掉身上的猴子，或者把猴子还给主人</li>
</ol>
</li>
<li><p>第四象限：不重要不紧急</p>
</li>
</ol>
</li>
<li><p>四象限法搭建任务池(多级队列)，时段法用来调度。</p>
</li>
</ol>
<h3 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h3><p>时间管理的目的：尽可能最大化的体验</p>
<p>1、花时间到达门槛；</p>
<p>2、花时间赚更多时间；</p>
<p>3、花时间满足自己。</p>
<p>任何偏离这三点的时间开支，都可以认为是某种程度上的低效。</p>
<p>时间管理要解决的根本问题是，将事后看自己会后悔的时间开支减少甚至消灭，将更多的时间，安排给自己更在乎的事情。</p>
<p>故而，关键是找到自己认为重要的事情，也即<strong>自己的价值观</strong>，这可以通过各种量表（如职业价值观量表）来做到。</p>
<p>最重要的还是，<strong>在自己最高效的时间做最重要的事</strong>。故而，需要：</p>
<ol>
<li><p>找到自己最高效的时间</p>
<p>不要沉沦于记录时间这一手段，只是频繁的记录时间，但不进行正确的分析总结，这样就会平白的消耗掉更多的时间，也给自己增加更多的负担。</p>
<ol>
<li>通过明确产出集中时间来明确高效时段</li>
<li>看时间大部分花在哪</li>
<li>归因总结这一周的错误</li>
<li>什么时候被拖延</li>
</ol>
</li>
<li><p>知道什么事最重要</p>
</li>
</ol>
<p>提高办事效率：</p>
<ol>
<li>最重要的事放在最高效的时候做</li>
<li><strong>要展示的东西</strong>认真做，名片</li>
<li>同样情境的事批次解决</li>
<li>能休息尽量休息，如午休</li>
</ol>
<p><img src="/2024/07/06/thinks/image-20240814145426790.png" alt="image-20240814145426790"></p>
<ol>
<li>减少干扰源（桌面整洁，水杯倒满，隔离自己，关通信）</li>
<li>高效为准（要事第一，设定任务ddl，蚌埠住的时候就歇会儿）</li>
</ol>
<p><img src="/2024/07/06/thinks/image-20240814145058891.png" alt="image-20240814145058891"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>人与人的交流，本质是一个加密解密的过程。内心意图→言语→对方收到的影响【interpersonal gap】共情式交流会很有效地缩减这一gap</p>
<p>无聊就是我没有办法将别人变得有趣</p>
<p>问题更深刻：问出让人不知不觉抬头去想的问题</p>
<p><strong>高质量的提问者就是人性的观察者，只有对自己的人生积淀了足够多的思考，才能共情对他人提出好问题</strong></p>
<p>但是需要铺垫和叠甲才能丝滑过渡到人生问题【对方虽然知道，但你铺垫一下更能使谈话完整而具有合理性】</p>
<p>【可以研究下主持技巧】</p>
<p>面对一些问题答不上来，是因为不在记忆系统中，需要在经验中去提炼</p>
]]></content>
  </entry>
  <entry>
    <title>尚未解决的问题</title>
    <url>/2024/04/10/unsolved_problems/</url>
    <content><![CDATA[<blockquote>
<p>记录一些编码过程中尚不清楚为什么的问题（比如C++语言and so on），欢迎看到的热心大佬敲敲我告诉我为什么……</p>
</blockquote>
<h1 id="bad-alloc-amp-amp-数组越界"><a href="#bad-alloc-amp-amp-数组越界" class="headerlink" title="bad_alloc &amp;&amp; 数组越界"></a>bad_alloc &amp;&amp; 数组越界</h1><p>今天在开发某个项目的时候遇到std::bad_alloc导致terminate，然而印象中这个似乎是内存耗尽才会报的错所以百思不得其解，直到之后发现修改了数组越界（C-style array）之后该问题得以解决。然而，按我的经验似乎数组越界并不会报出该错误，于是上网搜索发现了该文章：<a href="https://blog.csdn.net/lovelyloulou/article/details/6457991">数组越界造成的std::bad_alloc中断</a></p>
<p>我的项目确实在数组越界之后调用了ofstream，感觉这个真相了。然而，我又按着它和我的思路怎么复现都没复现出来很难崩……而且也不大清楚它的原理是什么</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">ofile</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line">    std::string p[<span class="number">5</span>];</span><br><span class="line">    std::string tmp;</span><br><span class="line">    tmp  = p[<span class="number">10</span>];</span><br><span class="line">    ofile &lt;&lt; <span class="string">&quot;haha&quot;</span> &lt;&lt; tmp;</span><br><span class="line">    ofile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，暂时是一个悬而未决的问题……</p>
]]></content>
  </entry>
  <entry>
    <title>COS: A User-space Scheduling Framework</title>
    <url>/2024/04/21/userspace_scheduling_framework/</url>
    <content><![CDATA[<blockquote>
<p>Reference: </p>
<p><a href="https://gitlab.eduxiji.net/educg-group-17066-1466467/202318123111334-1848/-/tree/main/">项目总仓库</a></p>
<p><a href="https://github.com/xiunianjun/xiunianjun.github.io/blob/master/2024/04/21/userspace_scheduling_framework/%E5%86%B3%E8%B5%9B%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3.pdf">项目文档</a></p>
<p><a href="https://dl.acm.org/doi/abs/10.1145/3477132.3483542">ghOSt论文</a></p>
<p><a href="https://github.com/shootfirst/cos_kernel">COS-Kernel</a></p>
<p><a href="https://github.com/shootfirst/cos_userspace">COS-Userspace</a></p>
</blockquote>
<p>在准备面试的过程中，以目前的水平重新审视半年前的这个项目，温故而知新，感觉又有了许多新的感悟。加之<a href="/2023/08/27/2023-os-comp">以前</a>仅记录了参赛的感受和个人贡献，而没有记录对这整个项目的一个全面介绍，故而，今天我就稍微趁热打铁一下，结合<a href="https://github.com/xiunianjun/xiunianjun.github.io/blob/master/2024/04/21/userspace_scheduling_framework/%E5%86%B3%E8%B5%9B%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3.pdf">项目文档</a>、<a href="https://dl.acm.org/doi/abs/10.1145/3477132.3483542">ghOSt论文</a>、<a href="https://github.com/shootfirst/cos_kernel">COS框架代码</a>，来进行一个综合的介绍。</p>
<p>注：本文章的写作目的主要还是为了我自己整合一下知识，所以可能存在部分词不达意（？）、省略跳过的地方，并且全文组织逻辑也不是一篇完整的文章。如果有人对某部分有疑惑，欢迎联系我进行讨论。</p>
<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>COS是对<a href="https://dl.acm.org/doi/abs/10.1145/3477132.3483542">ghOSt</a>的一个从零开始的小型复现，支持了其基本功能，并且可以基于它实现多种多样较为复杂的调度算法。同时针对ghOSt在部分情景下的不足做了一些小优化，使得具有一定抗干扰性，同时能够支持简单的cgroup功能。</p>
<p>我们修改了Linux内核，增加了大约1500LoC。并且，我们还搭建了COS用户态，提供了比较全面实用的接口，还有许多调度算法实现实例（FIFO（开源）、Shinjuku（开源，一个多级队列时间片抢占的简要实现形式）、SJF、MFQ和DDL等）。</p>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>在本部分中，我将结合ghOSt论文中的表述，以及实际开发过程中的感悟，对背景部分进行介绍。下面的内容这页PPT足以概括：</p>
<p><img src="/2024/04/21/userspace_scheduling_framework/image-20240421212636821.png" alt="image-20240421212636821"></p>
<p>具体来说:</p>
<h2 id="业界情况"><a href="#业界情况" class="headerlink" title="业界情况"></a>业界情况</h2><ol>
<li><p>Linux调度类机制</p>
<p>面向对象设计：调度类接口+多个具体实现类（CFS，FIFO，RR，DDL……）</p>
</li>
<li><p>优化对象：data center</p>
</li>
<li><p>面临挑战：</p>
<ol>
<li><p>逐渐牛掰的硬件（如CPU增多），还有新特性（如SMT、NUMA）；</p>
</li>
<li><p>安全性要求（需要隔离部分线程到部分CPU运行）；</p>
</li>
<li><p>Linux调度类具有通用性不具专用性；</p>
</li>
<li><p>Linux原生<strong>per-CPU模型</strong>不足以支持。</p>
<blockquote>
<p>注意，此处其实门道还是蛮多，详情可见本人<a href="https://xiunianjun.github.io/2024/04/10/read_linux/#ghOSt:~:text=24.4.11-,per%2DCPU%E5%92%8CCentralized%E6%80%9D%E8%80%83,-%E4%BB%94%E7%BB%86%E6%83%B3%E4%BA%86%E4%B8%80%E4%B8%8B">这边写的</a>和<a href="https://xiunianjun.github.io/2024/04/10/read_linux/#ghOSt:~:text=%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%82-,per%2DCPU%E5%92%8CCentralized%E6%80%9D%E8%80%83,-%E5%9C%A8%E5%8D%95CPU">这边写的</a>。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>此处具体来说，可以以Shinjuku OS一文中的说法为例。对于现实中那些短请求较多的workload，比如说搜索引擎、FaaS、In-memory DB（支持简单的get/put和长请求range query）等，从理论上来说，使用Processor Sharing(PS)的调度策略会防止高尾延迟，而这PS就可以类似为一种跟RR比较相似的时间片策略。这也很符合直觉，因为RR一类的策略具有公平性和均等性的特点，使得短请求不至于被运行到完成的长请求饿死。</p>
<p>那么，为什么不能用Linux原生的real-time策略？我认为主要有两点原因：</p>
<ol>
<li>稳定性      用real-time策略可能导致内核不稳定，因为实时调度类在内核中调度优先级最高</li>
<li>性能问题  Linux的real-time策略需要进行频繁的中断、上下文切换，开销较大较笨重，不够轻量级；Per-CPU策略只能让worker自己中断监测时间【主要原因】</li>
</ol>
<p>故而，Shinjuku OS的解决方法是直接设置一个轻量级的专用OS，ghOSt则是将这个RR策略委托在了用户态实现，并且设立一个centrallized的线程集中控制，就避免了频繁的中断开销。</p>
</blockquote>
<h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><ol>
<li><p>新增Linux调度类，从而新增新的调度算法</p>
<p>编码困难，部署开销大，而且很难随着linux内核维护</p>
</li>
<li><p>研发针对特定场景优化的专用OS（Shinjuku、Shenango）</p>
<p>很难随着linux内核维护，需要对内核和应用程序都做修改</p>
</li>
<li><p>仅适用用户态线程是不够的</p>
<p>用户级线程的基本思路是，将M个用户级线程多路复用到N个内核线程上。</p>
<p>缺点：<strong>不可预测</strong></p>
<p>​    首先你不知道它会被调度到哪个CPU上，也不知道它会什么时候停止，万一停的时候拿着锁就g了……</p>
</li>
</ol>
<h2 id="用户态调度框架"><a href="#用户态调度框架" class="headerlink" title="用户态调度框架"></a>用户态调度框架</h2><p>用户态编写自定义调度策略，调度Linux线程</p>
<ol>
<li><strong>Decouple</strong>：解耦了 内核调度类机制 (<u>不变</u>) 和 用户态调度策略 (<u>变</u>)（这点说得很本质）</li>
<li><strong>Convenient</strong>：无需改变现有应用程序；提供很多供开发使用的接口；支持热更新</li>
<li><strong>Flexible</strong>：可自定义实现多种调度策略 (如SJF、MFQ……)；支持快速调度；可以与别的调度策略共存</li>
</ol>
<p>用户态调度框架分为内核实现和用户实现：内核通过为用户态提供接口（系统调用，eBPF钩子），将策略决策委托给用户空间；用户则通过内核提供的接口在用户态搭建部署自己的调度策略。</p>
<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><ol>
<li><p>线程本质上是一种状态机</p>
<p><img src="/2024/04/21/userspace_scheduling_framework/image-20240421215521267.png" alt="image-20240421215521267"></p>
</li>
<li><p>所以线程调度算法最关键需要做到这两点：</p>
<p>①当线程状态发生变化，do something；（e.g. FIFO入队当线程变为runnable）</p>
<p>②通过某些规则从runqueue挑选线程调度。（e.g. FIFO pick next依据FCFS rule）</p>
</li>
<li><p>故而实现用户态调度框架最本质的两个关键（<strong>下以序号来指代</strong>）：</p>
<p>①感知线程状态变化；（信息流向：Kernel→Userspace）</p>
<p>②告知调度决策；（信息流向：Userspace→Kernel）</p>
</li>
</ol>
<h2 id="Linux调度类机制"><a href="#Linux调度类机制" class="headerlink" title="Linux调度类机制"></a>Linux调度类机制</h2><ol>
<li><p>面向对象设计：调度类接口+多个具体实现类（CFS，FIFO，RR，DDL……）。</p>
</li>
<li><p>每次调度（<code>__schedule</code>）时，依照调度类优先级从高到低，一次调用对应调度类的钩子函数<code>pick_next_task</code>。</p>
</li>
<li><p>每个CPU对应一个rq结构体，代表其任务队列。</p>
</li>
<li><p>线程调度分为两种：</p>
<ol>
<li><p>本地调度（Per-CPU Model）</p>
<p>target线程的target CPU和发出调度指令的线程所在CPU是同一个，此时，会暂时让出自己的CPU给此target线程运行；</p>
</li>
<li><p>远程调度（Centrallized Model）</p>
<p>target线程的target CPU和发出调度指令的线程所在CPU不是同一个，此时则需要硬件的支持，通过IPI（Inter-Processor Interrupt）来发送中断给对应的CPU，让其进行reschedule。</p>
</li>
</ol>
</li>
</ol>
<h2 id="现有方法"><a href="#现有方法" class="headerlink" title="现有方法"></a>现有方法</h2><ol>
<li><p>eBPF效率不高（<a href="https://github.com/sched-ext/sched_ext">EXT</a>）</p>
<p>①②两点通过eBPF实现</p>
<ol>
<li><p>编码不便捷，受可表达性限制</p>
</li>
<li><p>bpf程序一般都是<strong>同步</strong>的</p>
<p>也即，当线程状态发生变化，cpu必须block，直到bpf那边把事件处理完了（比如进行调度决策等），cpu才能继续润。</p>
<blockquote>
<p>不像ghOSt是异步，cpu只需要发个消息，然后继续润，等待ghost打断就行。不得不说，这也是一个非常完美的<strong>中断思想</strong>的体现！！！</p>
</blockquote>
</li>
<li><p>被动调度</p>
<p>bpf的用户态调度框架思路是无任务可跑了才触发，并且受CFS线程优先级限制，不像ghost和cos一样主动打上去就行</p>
</li>
</ol>
<blockquote>
<p>EXT的整体实现也是很有意思的，内核中许多地方的修改处理都很牛逼，我也是跟着它学习了不少eBPF的写法。EXT的内核实现不是这里的重点，具体可以看项目文档中关于EXT内核介绍的部分。</p>
</blockquote>
</li>
<li><p><a href="https://github.com/google/ghost-kernel">ghOSt</a></p>
<p>①共享内存；②系统调用。复现目标。</p>
<ol>
<li>不抗干扰</li>
<li>不支持CGroup</li>
</ol>
</li>
</ol>
<p>故而，基于上述全部，我们决定开发COS：对ghOSt的简化复现，并给出了对它现存问题的解决思路。</p>
<h1 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="总体框架"><a href="#总体框架" class="headerlink" title="总体框架"></a>总体框架</h3><p><img src="/2024/04/21/userspace_scheduling_framework/image-20240421220237028.png" alt="image-20240421220237028"></p>
<ol>
<li><p>内核态：COS调度类</p>
</li>
<li><p>用户态：Lord线程</p>
</li>
<li><p>用户态至内核态通信：系统调用</p>
</li>
<li><p>内核态至用户态通信：消息队列</p>
</li>
<li><p>Cgroup简单支持</p>
</li>
</ol>
<h3 id="用户态示范"><a href="#用户态示范" class="headerlink" title="用户态示范"></a>用户态示范</h3><p><a href="https://github.com/shootfirst/cos_userspace/blob/main/scheduler/fifo/fifo_lord.h">FIFO Scheduler</a></p>
<h2 id="Kernel-COS调度类"><a href="#Kernel-COS调度类" class="headerlink" title="Kernel: COS调度类"></a>Kernel: COS调度类</h2><p><img src="/2024/04/21/userspace_scheduling_framework/image-20240421220446311.png" alt="image-20240421220446311"></p>
<p>COS在内核中新增一个调度类，类似常用的CFS调度类。这个调度类向用户态提供一组系统调用来供用户态定义任意调度策略，同时负责执行用户态传入的调度策略。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_SCHED_CLASS(<span class="built_in">cos</span>) = &#123;</span><br><span class="line">	.enqueue_task		= enqueue_task_cos,</span><br><span class="line">	.dequeue_task		= dequeue_task_cos,</span><br><span class="line">	.check_preempt_curr	= check_preempt_curr_cos,</span><br><span class="line">	.pick_next_task		= pick_next_task_cos,</span><br><span class="line">	.task_dead = task_dead_cos,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	.select_task_rq		= select_task_rq_cos,</span><br><span class="line">	.task_woken     = task_woken_cos,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line">	.uclamp_enabled		= <span class="number">0</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>COS调度类优先级位于CFS之下，目的是不影响CFS的稳定运行，若在CFS之上，可能会造成CFS线程饿死，值得注意的是负责维持着内核的稳定性内核线程都是CFS调度类，如果这些线程得不到及时运行，会导致内核崩溃。</p>
<p>Lord线程调度类优先级则高于CFS等调度类，仅次于STOP调度类，这确保它能够一直运行在它绑定的CPU上，实时做出调度决策，避免因为被其他线程抢占而导致暂时得不到运行而导致调度时延。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_SCHED_CLASS(cos_lord) = &#123;</span><br><span class="line">	.pick_next_task		= pick_next_task_cos_lord,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="User-Lord线程"><a href="#User-Lord线程" class="headerlink" title="User: Lord线程"></a>User: Lord线程</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>Lord线程位于用户态，负责部署调度算法传入内核。用户程序可以通过set_lord()系统调用将自己绑定在指定CPU上，开启内核COS调度，成为Lord线程。只有Lord线程才有调度其他COS调度类线程（下称COS线程）的特权。同一个主机上只能有一个Lord线程，若已经有其他线程设置自己为Lord线程，则该系统调用会返回错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cos_do_set_lord</span><span class="params">(<span class="type">int</span> cpu_id)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> current;</span><br><span class="line">	<span class="comment">// 1. 设置cpu mask，并且将lord迁移到cpu_id对应CPU上</span></span><br><span class="line">	<span class="comment">// xiunian: 其原理是简单的调用set cpu allow相关内核函数，我猜测里面应该会有一个出队入队的情况</span></span><br><span class="line">	cos_move2target_rq(cpu_id);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// xiunian: COS作为简化实现，只允许一个主机同时只存在一个lord线程</span></span><br><span class="line">	<span class="keyword">if</span> (cos_on) </span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	spin_lock_irqsave(&amp;cos_global_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置为COS调度类</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> &#123;</span><br><span class="line">		.sched_priority = <span class="number">0</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	sched_setscheduler(p, SCHED_COS, &amp;param);</span><br><span class="line">	<span class="comment">// 3. 修改状态信息</span></span><br><span class="line">	rq = cpu_rq(cpu_id);</span><br><span class="line">	open_cos(rq, p, cpu_id); <span class="comment">// rq-&gt;cos.lord、lord_on_rq、lord_cpu、cos_on、lord、cg_init</span></span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;cos_global_lock, flags);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而为了保证用户态调度算法调度决策的及时进行，我们需要将Lord线程绑定在它运行核上，并且设置它的优先级为最高，使得它无法被其他CFS线程抢占。</p>
<p>这个<strong>优先级最高</strong>以及<strong>绑核</strong>是怎么实现的呢？具体来说，我们在内核中增设了一个COS Lord调度类，其优先级差不多处于所有调度类的巅峰：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_SCHED_CLASS(cos_lord) = &#123;</span><br><span class="line">	.pick_next_task		= pick_next_task_cos_lord,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们在其pnt钩子函数中，如果它是lord所在CPU，则不断返回lord：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">pick_next_task_cos_lord</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span> &#123;</span><br><span class="line">    <span class="comment">// 仅有lord所在CPU设置了rq-&gt;cos.lord（在open_cos中），其余CPU皆为NULL</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;<span class="built_in">cos</span>.lord != <span class="literal">NULL</span> &amp;&amp; task_is_running(rq-&gt;<span class="built_in">cos</span>.lord) &amp;&amp; lord_on_rq) &#123;</span><br><span class="line">		<span class="keyword">return</span> rq-&gt;<span class="built_in">cos</span>.lord;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，就做到了Lord线程的<strong>高优先级</strong>以及<strong>绑核</strong>效果。</p>
<h3 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h3><p>ghOSt为了保证系统的稳定性，实现了Agent（类似于COS的Lord） thread的Migration，也即当有重要的内核CFS线程要运行在Agent所在CPU时，Agent会默默退让当前CPU，迁移到其他CPU上。为了简单起见，COS没有实现该功能，并且设定将Lord thread绑定在CPU id较大的CPU上（因为重要的内核线程一般都运行在0-2号CPU），从而缓解该矛盾。而后续的Evaluation部分也暂未因该问题产生较大影响，故而暂且不作考虑。</p>
<h2 id="感知线程状态变化"><a href="#感知线程状态变化" class="headerlink" title="感知线程状态变化"></a>感知线程状态变化</h2><h3 id="消息队列的结构"><a href="#消息队列的结构" class="headerlink" title="消息队列的结构"></a>消息队列的结构</h3><p>内核会将线程状态的变化信息通过共享内存实现的消息队列传递到Lord线程。</p>
<p><img src="/2024/04/21/userspace_scheduling_framework/image-20240421222621082.png" alt="image-20240421222621082"></p>
<p>由于COS实现假定全局只有一个Lord，故而仅需设置一个global的消息队列即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cos_message_queue</span> *<span class="title">global_mq</span>;</span></span><br></pre></td></tr></table></figure>

<p>Lord线程在调用<code>set_lord</code>后，会紧接着调用<code>create_msg_queue</code>来创建消息队列：（此处共享内存的<code>queue_fops</code>未做了解（其实是了解过然后忘了hhh），写法感觉还是比较套路，不做赘述）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cos_create_queue</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 申请共享内存</span></span><br><span class="line">	global_mq = vmalloc_user(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cos_message_queue));</span><br><span class="line">	<span class="comment">// 2. 以fd形式（匿名inode）使用</span></span><br><span class="line">	<span class="type">int</span> fd = anon_inode_getfd(<span class="string">&quot;[cos_queue]&quot;</span>, &amp;queue_fops, global_mq,</span><br><span class="line">			      O_RDWR | O_CLOEXEC);</span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该段内存以环形队列形式组织。然后，内核这端就会在不同事件发生的时候，向共享内存写入消息，等待User的Lord线程从共享内存中取出消息，做出对应的调度决策，即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">produce_task_runnable_msg</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> produce_task_message(MSG_TASK_RUNNABLE, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">produce_task_blocked_msg</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> produce_task_message(MSG_TASK_BLOCKED, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">produce_task_new_msg</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> produce_task_message(MSG_TASK_NEW, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">produce_task_dead_msg</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> produce_task_message(MSG_TASK_DEAD, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">produce_task_preempt_msg</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> produce_task_message(MSG_TASK_PREEMPT, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">produce_task_new_blocked_msg</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> produce_task_message(MSG_TASK_NEW_BLOCKED, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">produce_task_cos_preempt_msg</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> produce_task_message(MSG_TASK_COS_PREEMPT, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息发送的时机"><a href="#消息发送的时机" class="headerlink" title="消息发送的时机"></a>消息发送的时机</h3><p>这里其实还是稍显复杂的，建议去看看<a href="https://github.com/xiunianjun/xiunianjun.github.io/blob/master/2024/04/21/userspace_scheduling_framework/%E5%86%B3%E8%B5%9B%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3.pdf">文档</a>（3.2.3部分）吧，欣赏一下我这部分完美的图。印象中是task preempt卡了我们不久，我研究了很久才发现了它是需要一个排除法机制，还挺有意思的。</p>
<p>看完了文档之后，这里对具体涉及到的代码进行一个小注释。</p>
<p>首先是这里的<code>cos_prepare_task_switch</code>了。它负责发送task new、task preempt消息，可谓是重点之一了。顾名思义，它会在调度上下文切换之前被调用。</p>
<p>其中有一点需要注意，对于task new的情况，COS调度类不支持调度类遗传，即一个线程新建时候它的调度类不可能是COS。线程只能调用<code>sched_setscheduler</code>系统调用将自己调度类设置为COS，在这个过程中，线程需要先下CPU。而之所以在这里才发送task new消息，不是在<code>sched_setscheduler</code>时就发送消息，是为了防止这样一种竞态情况：<code>sched_setscheduler</code>发送消息→用户态接收消息并马上调度到某个CPU，但此时该线程还没有从原来的CPU上下来，这时就会导致一个线程同时在两个CPU上运行，从而g。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cos_prepare_task_switch</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> task_struct *next)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (cos_policy(prev-&gt;policy) &amp;&amp; prev-&gt;<span class="built_in">cos</span>.is_new) &#123;</span><br><span class="line">		<span class="keyword">if</span> (task_on_rq_queued(prev)) &#123;</span><br><span class="line">			produce_task_new_msg(prev);	<span class="comment">// 此时新任务可运行</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			produce_task_new_blocked_msg(prev);	<span class="comment">// 此时新任务不可运行</span></span><br><span class="line">		&#125;</span><br><span class="line">		prev-&gt;<span class="built_in">cos</span>.is_new = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;	<span class="comment">// 排除法1：不是task new</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (prev-&gt;<span class="built_in">cos</span>.is_blocked) <span class="comment">// 排除法2：不是task block</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排除结束，那就是task preempt了</span></span><br><span class="line">	<span class="keyword">if</span> (cos_policy(next-&gt;policy)) </span><br><span class="line">		produce_task_cos_preempt_msg(prev);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		produce_task_preempt_msg(prev);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，其它几个消息的发送时间不甚特殊，在此不做赘述。</p>
<h3 id="用户与内核同步"><a href="#用户与内核同步" class="headerlink" title="用户与内核同步"></a>用户与内核同步</h3><p>内核必须保证用户态Lord线程消费消息的<strong>实时性</strong>。每条消息都有一个seqnum，来检测Lord每次做出调度策略的时候，是否已经消费完最新的消息。内核通过维护下一个要分配的seq num：a，与Lord每次做出调度决策时传入的已消费消息的最大seq num：b对比，若b不等于a + 1，意味着Lord还有消息没有消费，内核会拒绝本次调度决策。</p>
<h2 id="告知调度决策"><a href="#告知调度决策" class="headerlink" title="告知调度决策"></a>告知调度决策</h2><h3 id="基本实现-1"><a href="#基本实现-1" class="headerlink" title="基本实现"></a>基本实现</h3><p>shoot系统负责将用户态的调度策略传递到内核态。在COS的实现中，我们也是实现了<strong>组提交</strong>以增加效率。</p>
<p>我们使用共享内存shoot area负责存储一次部署中用户态调度策略传入内核的参数，例如target TID、target CPU、seq num等，并且可以反馈本次调度是否成功；我们使用shoot_task()系统调用将一组调度策略传入内核。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cos_do_shoot_task</span><span class="params">(<span class="type">cpumask_var_t</span> shoot_mask)</span> </span><br><span class="line">&#123;</span><br><span class="line">	preempt_disable();</span><br><span class="line">	for_each_cpu(cpu_id, shoot_mask) &#123;	<span class="comment">// 进行一个global的check</span></span><br><span class="line">        <span class="comment">// 获取对应shoot area上本次要调度的线程</span></span><br><span class="line">		pid = task_shoot_area-&gt;area[cpu_id].pid;</span><br><span class="line">		p = find_process_by_pid(pid);</span><br><span class="line">		<span class="keyword">if</span> (!p) <span class="keyword">continue</span>;</span><br><span class="line">		get_task_struct(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 几个调度失败场景，出现可能是因为用户态调度策略写错了</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(p-&gt;<span class="built_in">cos</span>.is_dying)) &#123;	<span class="comment">// target thread已经寄了</span></span><br><span class="line">			task_shoot_area-&gt;area[cpu_id].info = _SA_ERROR;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!task_is_running(p))) &#123;	<span class="comment">// target thread已经在跑了</span></span><br><span class="line">			task_shoot_area-&gt;area[cpu_id].info = _SA_ERROR;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 准备开始shoot</span></span><br><span class="line">		rq = cpu_rq(cpu_id);</span><br><span class="line">		<span class="comment">// xiunian: 多次对同一CPU的shoot视为抢占，所以只需一个变量记录next schedule即可</span></span><br><span class="line"> 		rq-&gt;<span class="built_in">cos</span>.next_to_sched = p; </span><br><span class="line">		rq-&gt;<span class="built_in">cos</span>.is_shoot_first = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (cpu_id == lord_cpu) &#123;</span><br><span class="line">			need_local_shoot = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			__cpumask_set_cpu(cpu_id, ipimask);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送远程IPI</span></span><br><span class="line">	cos_remote_shoot(ipimask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (need_local_shoot) &#123;	<span class="comment">// 本地调度</span></span><br><span class="line">		lord_on_rq = <span class="number">0</span>;</span><br><span class="line">		cos_local_shoot();</span><br><span class="line">		lord_on_rq = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	preempt_enable_no_resched();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cos_remote_shoot</span><span class="params">(<span class="keyword">struct</span> cpumask *ipi_mask)</span> &#123;</span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">    </span><br><span class="line">    rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">    !test_tsk_need_resched(rq-&gt;curr) &amp;&amp; set_nr_and_not_polling(rq-&gt;curr);</span><br><span class="line">    rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">    </span><br><span class="line">	VM_BUG_ON(this_rq()-&gt;<span class="built_in">cos</span>.lord != current);</span><br><span class="line">	<span class="keyword">if</span> (!cpumask_empty(ipi_mask)) &#123;</span><br><span class="line">		apic-&gt;send_IPI_mask(ipi_mask, RESCHEDULE_VECTOR);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的一点是，COS对于per-CPU model和centrallized model的支持。对于centrallized model的支持还是显而易见的，值得注意的是对per-CPU model的支持。</p>
<p>当线程需要shoot到lord所在CPU，如果不做任何操作，它是会被优先级更高的Lord class拦截的。故而，引入<code>lord_on_rq</code>这个全局变量。在reschedule之前，将<code>lord_on_rq</code>（全局变量）置为false。这样一来，在<code>pick_next_lord</code>中就会返回NULL，也即跳过Lord class，去Cos class，调度target thread了，然后reschedule完再把<code>lord_on_rq</code>调为true。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rq-&gt;<span class="built_in">cos</span>.lord != <span class="literal">NULL</span> &amp;&amp; task_is_running(rq-&gt;<span class="built_in">cos</span>.lord) &amp;&amp; lord_on_rq) &#123;</span><br><span class="line">	<span class="keyword">return</span> rq-&gt;<span class="built_in">cos</span>.lord;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>这样一来，相当于简单屏蔽了一会儿这个Lord class了，从而达到per-CPU的效果。如果要实现严格的per-CPU，我们可以在sendmsg的时候才把这个<code>lord_on_rq</code>置为true，从而有一种唤醒的效果。这样一来就需要对这个<code>lord_on_rq</code>进行并发保护了。</p>
<h3 id="动态优先级提升"><a href="#动态优先级提升" class="headerlink" title="动态优先级提升"></a>动态优先级提升</h3><p>在一些场景（比如说使用于burst的情况，也即一开始没有很多请求，所以跑了多个负载，然后突然爆发很多请求，这种情况下需要快速抢占CFS线程），需要快速对COS线程进行调度，无视干扰线程。然而，为了确保系统稳定，COS调度类优先级低于CFS调度类。故而，我们采取了一种<strong>动态优先级提升</strong>的方法来解决这个问题。在一个COS线程被调度到目标CPU上时候，此时我们将其优先级短暂地提升到最高，之后当目标CPU调用schedule函数挑选其上CPU执行的时候，在将其优先级下降到CFS之下，这样就兼顾了性能与系统稳定性。</p>
<p><img src="/2024/04/21/userspace_scheduling_framework/image-20240421230748956.png" alt="image-20240421230748956"></p>
<p>然而，优先级在Linux初始化时便确定下来，按存储的物理地址从高到低确定，是定死的。故而，我们<strong>借助Lord class的高优先级</strong>，来实现这一动态优先级提升。</p>
<p>具体来说，我们存储一个per-CPU的变量<code>is_shoot_first</code>。在目标线程刚刚被Lord部署到目标CPU上时，拉高电平<code>is_shoot_first</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	rq-&gt;<span class="built_in">cos</span>.next_to_sched = p; </span><br><span class="line">rq-&gt;<span class="built_in">cos</span>.is_shoot_first = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在Lord class之中，当<code>is_shoot_first</code>被拉高，就说明有COS线程刚刚需要被部署，我们返回即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">pick_next_task_cos_lord</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;<span class="built_in">cos</span>.next_to_sched != <span class="literal">NULL</span> &amp;&amp; task_is_running(rq-&gt;<span class="built_in">cos</span>.next_to_sched) &amp;&amp; rq-&gt;<span class="built_in">cos</span>.is_shoot_first) &#123;</span><br><span class="line">		rq-&gt;<span class="built_in">cos</span>.is_shoot_first = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> rq-&gt;<span class="built_in">cos</span>.next_to_sched;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就成功借助了Lord class的高优先级来实现优先调度。</p>
<h3 id="Discussion-1"><a href="#Discussion-1" class="headerlink" title="Discussion"></a>Discussion</h3><p>值得注意的是，ghOSt这边是将这个shoot采取了一个<strong>事务机制</strong>，感觉这个起名真是说到本质了。二者都同样是对某个执行过程的记录，负责统筹全局，并且也同样具有原子性，感觉真的非常合适。COS为了简单起见，没有实现这个。</p>
<h2 id="简单的Cgroup实现"><a href="#简单的Cgroup实现" class="headerlink" title="简单的Cgroup实现"></a>简单的Cgroup实现</h2><blockquote>
<p>为了契合题意（赛题要求支持cgroup），COS支持cgroup对CPU使用率的限制。COS额外提供了四个系统调用。</p>
<p><img src="/2024/04/21/userspace_scheduling_framework/image-20240421220908827.png" alt="image-20240421220908827"></p>
<p>COS负载线程可以随意将自己添加入一个cgroup，或者删除。同时也可以调整cgroup的CPU使用率，如80%，意味着当前cgroup中的所有线程对CPU的使用率最大值为80%，例如在1ms内最多只能获取0.8ms的运行时间。这意味着COS能够支持云原生场景中的容器。</p>
</blockquote>
<p>这里可能稍微偷了个懒，没有去兼容Linux原生Cgroup，而是实现了一个限制CPU使用率的小功能（因为时间不够了2333）。</p>
<p>这部分还是比较简单的，其实可以去看这个<a href="https://gitlab.eduxiji.net/educg-group-17066-1466467/202318123111334-1848/-/blob/main/record/Dev-Docs/final-stage/develop/cgroup%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88.md">开发思路文档</a>，思路写得更详细更具体，在此就只说说基本思路了。实现cgroup的基本逻辑：</p>
<p>多个cgroup通过链表形式链接，都有一个cg id。然后，每个task可以通过cg_ctl来把自己加入某个cgroup或者从某个中删除，每次调用task_tick都会检查一下salary是否耗尽，耗尽则reschedule，并且设置pnt那边salary&lt;=0就不return。同时，在context switch之前也会update on cpu和off cpu，纪录更精确的CPU时。</p>
<h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><p>这部分确实没什么好说的（虽然也很挣扎……）具体看项目文档吧。</p>
<p>不过有一点目前还是比较存疑，也即那个RocksDB场景似乎不是I/O密集型而是计算密集型（）因为具体的RockDB数据库是In-memory的，并且每个请求也都是polling一段纯粹的CPU工作时来模拟请求的处理，所以我认为当初这方面我们的认知出了点问题，不过看起来影响不大。</p>
]]></content>
  </entry>
  <entry>
    <title>Operating system interface</title>
    <url>/2023/01/10/xv6$chap1/</url>
    <content><![CDATA[<h1 id="Operating-system-interface"><a href="#Operating-system-interface" class="headerlink" title="Operating system interface"></a>Operating system interface</h1><p>本节大概是在讲操作系统的接口，系统调用占了很大一部分。</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>int fork()</code></td>
<td>创建一个进程，返回子进程的PID</td>
</tr>
<tr>
<td><code>int exit(int status)</code></td>
<td>终止当前进程，并将状态报告给wait()函数。无返回</td>
</tr>
<tr>
<td><code>int wait(int *status)</code></td>
<td>等待一个子进程退出; 将退出状态存入*status; 返回子进程PID。</td>
</tr>
<tr>
<td><code>int kill(int pid)</code></td>
<td>终止对应PID的进程，返回0，或返回-1表示错误</td>
</tr>
<tr>
<td><code>int getpid()</code></td>
<td>返回当前进程的PID</td>
</tr>
<tr>
<td><code>int sleep(int n)</code></td>
<td>暂停n个时钟节拍</td>
</tr>
<tr>
<td><code>int exec(char *file, char *argv[])</code></td>
<td>加载一个文件并使用参数执行它; 只有在出错时才返回</td>
</tr>
<tr>
<td><code>char *sbrk(int n)</code></td>
<td>按n 字节增长进程的内存。返回新内存的开始</td>
</tr>
<tr>
<td><code>int open(char *file, int flags)</code></td>
<td>打开一个文件；flags表示read/write；返回一个fd（文件描述符）</td>
</tr>
<tr>
<td><code>int write(int fd, char *buf, int n)</code></td>
<td>从buf 写n 个字节到文件描述符fd; 返回n</td>
</tr>
<tr>
<td><code>int read(int fd, char *buf, int n)</code></td>
<td>将n 个字节读入buf；返回读取的字节数；如果文件结束，返回0</td>
</tr>
<tr>
<td><code>int close(int fd)</code></td>
<td>释放打开的文件fd</td>
</tr>
<tr>
<td><code>int dup(int fd)</code></td>
<td>返回一个新的文件描述符，指向与fd 相同的文件</td>
</tr>
<tr>
<td><code>int pipe(int p[])</code></td>
<td>创建一个管道，把read/write文件描述符放在p[0]和p[1]中</td>
</tr>
<tr>
<td><code>int chdir(char *dir)</code></td>
<td>改变当前的工作目录</td>
</tr>
<tr>
<td><code>int mkdir(char *dir)</code></td>
<td>创建一个新目录</td>
</tr>
<tr>
<td><code>int mknod(char *file, int, int)</code></td>
<td>创建一个设备文件</td>
</tr>
<tr>
<td><code>int fstat(int fd, struct stat *st)</code></td>
<td>将打开文件fd的信息放入*st</td>
</tr>
<tr>
<td><code>int stat(char *file, struct stat *st)</code></td>
<td>将指定名称的文件信息放入*st</td>
</tr>
<tr>
<td><code>int link(char *file1, char *file2)</code></td>
<td>为文件file1创建另一个名称(file2)</td>
</tr>
<tr>
<td><code>int unlink(char *file)</code></td>
<td>删除一个文件</td>
</tr>
</tbody></table>
<p> 表1.2：xv6系统调用（除非另外声明，这些系统调用返回0表示无误，返回-1表示出错）</p>
<h2 id="Process-and-memory"><a href="#Process-and-memory" class="headerlink" title="Process and memory"></a>Process and memory</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child&#x27;s pid = %d\n&quot;</span>,pid);</span><br><span class="line">    pid = wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done.\n&quot;</span>,pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child : exiting\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个利用fork的返回值对于父子进程来说不同这一特点进行编写的例程。其中比较不熟的还是wait(0)这一句的用法。这点具体可以看书中笔记和上面的系统调用表。</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>exec是一个系统调用，它跟exe文件被执行的原理密切相关。当程序调用exec，就会跳转到exec参数文件去执行，原程序exec下面的指令都不再被执行，除非exec因错误而退出。</p>
<h3 id="exec与fork"><a href="#exec与fork" class="headerlink" title="exec与fork"></a>exec与fork</h3><p>由shell的源码中main函数这一段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read and run input commands.</span></span><br><span class="line"><span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">    <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">    runcmd(parsecmd(buf));</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(cmd-&gt;type)&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> EXEC:</span><br><span class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</span><br><span class="line">    exec(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;exec %s failed\n&quot;</span>, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到shell其实本质上就是这样的架构架构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(读到了command&amp;&amp;fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        exec(command);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;失败信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即父进程创建出子进程来执行command，并且父进程等待子进程执行完再继续等待输入。</p>
<p>可以看到，fork和exec的使用是非常紧密的，联合使用也是非常顺理成章的。那么，如果干从fork的exec的对于内存管理的原理来讲，就会不免产生一点问题。</p>
<blockquote>
<p>问题描述：</p>
<p>fork的内存原理，实质上是开辟一片新的与父进程等大的内存空间，然后把父进程的数据都copy一份进这个新内存空间。exec的原理是用一片可以容纳得下文件指令及其所需空间的内存空间去替代调用进程原有的那片内存空间。</p>
<p>可以看到，如果fork和exec接连使用，理论上其实是会产生一点浪费的，fork创建子进程复制完了一片内存空间，这片新复制的内存空间又马上被扔掉了，取而代之的用的是exec的内存空间。</p>
</blockquote>
<p>为了解决这个问题，kernel使用了copy-on-write技术优化。</p>
<h2 id="I-O-and-File-descriptors"><a href="#I-O-and-File-descriptors" class="headerlink" title="I/O and File descriptors"></a>I/O and File descriptors</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>句柄就是一个int值，它代表了一个由内核管理的，可以被进程读写的对象.</p>
<blockquote>
<p>A process may obtain a file descriptor by opening a <strong>file</strong>, <strong>directory</strong>, or <strong>device</strong>, or by creating a <strong>pipe</strong>, or by <strong>duplicating</strong> an existing descriptor.</p>
</blockquote>
<p>每个进程的其三个句柄有默认值：</p>
<blockquote>
<p>By convention, a process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error). </p>
</blockquote>
<p>句柄0对应着standard input，1对应着standard output，2对应着standard error。</p>
<h3 id="read、write"><a href="#read、write" class="headerlink" title="read、write"></a>read、write</h3><p>read和write的参数都是句柄，buf，读/写长度。都会导致文件指针的移动。使用如下例程【类似cat的原理】：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    n = read(<span class="number">0</span>);<span class="comment">//从标准输入读</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(write(<span class="number">1</span>,buf,n) != n)&#123;<span class="comment">//向标准输出写</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>close函数释放了一个句柄，以后它释放掉的这个句柄就可以被用来表示别的文件了。</p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p>open函数会给参数的file分配一个句柄。这个句柄通常是目前空闲的句柄中值最小的那个。</p>
<h3 id="重定向的实现"><a href="#重定向的实现" class="headerlink" title="重定向的实现"></a>重定向的实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argc[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>,argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xv6的重定向实现跟这个原理差不多：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> REDIR:</span><br><span class="line">  rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">  close(rcmd-&gt;fd);</span><br><span class="line">  <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;open %s failed\n&quot;</span>, rcmd-&gt;file);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  runcmd(rcmd-&gt;cmd);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="共享偏移量"><a href="#共享偏移量" class="headerlink" title="共享偏移量"></a>共享偏移量</h3><p>fork出来的父子进程同一个句柄对同一个文件的偏移量是相同的，这个原理应该是因为，父子进程共享的是文件句柄这个结构体对象本身，也就是拷贝的时候是浅拷贝而不是深拷贝。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	wait(<span class="number">0</span>);</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p><code>dup</code>系统调用复制一个现有的文件描述符，返回一个引用自同一个底层I/O对象的新文件描述符。</p>
<p>dup和open一样，都是会占用一个新的句柄的，而且都是优先分配数值小的。比如说fd = dup(3)，得到fd=4，那么结果就是句柄3和句柄4指向同一个文件，并且偏移量一样。</p>
<p>dup可以让这样的指令变得可以实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个指令的意思是，先把stderr的结果重定向到stdout，再把stdout的结果重定向到tmp1中。</p>
<p>关于2&gt;&amp;1的解释，可以看这个 <a href="https://blog.csdn.net/qq_38500662/article/details/84973518">shell中的”2&gt;&amp;1”是什么意思？</a></p>
</blockquote>
<p>这个的实现就要用到dup了。我们会fork一个子进程，在子进程里面close(2)，然后再dup(1)。这样一来，我们就成功实现了句柄1和2指向同一个文件</p>
<h2 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>int pipe(int p[]) 创建一个管道，把read/write文件描述符放在p[0]和p[1]中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span>* argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>],<span class="string">&quot;hello world\n&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成了父进程-pipe-子进程的一个重定向。</p>
<p>pipe是阻塞的生产者消费者模式。对管道的read，在没有数据输入时会阻塞，直到读到数据，或者所有的write方向都被关闭。示例代码中，如果不使用pipe就需要显示close(p[0]) close(p[1])，正是为了防止没有数据输入时write方向不为0导致死锁的情况出现。</p>
<h3 id="实现管道命令"><a href="#实现管道命令" class="headerlink" title="实现管道命令"></a>实现管道命令</h3><p>管道命令的实现正是通过pipe。</p>
<p>执行原理就是，创建两个子进程分别执行左右两侧的句子，然后左侧子进程的out重定向到pip的write，右侧子进程的in重定向到pip的read。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">case</span> PIPE:</span><br><span class="line">   pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">   <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">     panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line"><span class="comment">//左</span></span><br><span class="line">   <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">     close(<span class="number">1</span>);</span><br><span class="line">     dup(p[<span class="number">1</span>]);</span><br><span class="line">     close(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">1</span>]);</span><br><span class="line">     runcmd(pcmd-&gt;left);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//右</span></span><br><span class="line">   <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">     close(<span class="number">0</span>);</span><br><span class="line">     dup(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">0</span>]);</span><br><span class="line">     close(p[<span class="number">1</span>]);</span><br><span class="line">     runcmd(pcmd-&gt;right);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中</span></span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line">   close(p[<span class="number">1</span>]);</span><br><span class="line">   <span class="comment">//wait</span></span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">   wait(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这实际上是二叉树的左右中递归过程。</p>
<blockquote>
<p>附：对于管道命令的解读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat a.txt | echo</span><br></pre></td></tr></table></figure>

<p>我的本意是觉得，这意思就是把cat a.txt的输出连到echo的输入，这个命令结果跟cat a.txt是没什么差的。但具体执行出来发现最后的结果却是跟：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo</span><br></pre></td></tr></table></figure>

<p>这个指令的效果是一样的，也就是cat a.txt的output，即echo的input完全被丢弃了。</p>
<p>我想这是因为，echo这个命令的执行过程并没有用到stdin，仅仅用到了参数，也就是说管道read端的接入对它并没有什么影响。</p>
<p>这也是为啥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sleep 10 | echo hi</span><br></pre></td></tr></table></figure>

<p>这个命令最后的结果是，秒速出hi，然后等待10s后结束，了。由于echo的输出与stdin没有关系，所以，echo不会阻塞读入stdin，等待管道关闭，而是会即刻输出hi。</p>
</blockquote>
<p>管道实际上就相当于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo hello world | wc</span><br><span class="line">echo hello world &gt; /tmp/xyz; wc &lt; /tmp/xyz</span><br></pre></td></tr></table></figure>

<p>在这种情况下，管道相比临时文件至少有四个优势</p>
<ul>
<li>首先，不用删文件</li>
<li>其次，管道可以任意传递长的数据流</li>
<li>第三，管道允许一定程度上的并行</li>
<li>第四，如果实现进程间通讯，管道的块读写比文件的非块语义更有效率。</li>
</ul>
<h2 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h2><p>inode：代表文件本体，包括文件类型、文件长度、文件内容在磁盘位置、文件的链接数</p>
<p>link：指向文件的链接，一个文件可以有多个link，link内包含文件名和对inode的引用</p>
<p>当链接数=0，且句柄数=0，文件的磁盘空间和inode索引就会被释放</p>
<h2 id="Lab-Xv6-and-Unix-utilities"><a href="#Lab-Xv6-and-Unix-utilities" class="headerlink" title="Lab Xv6 and Unix utilities"></a>Lab Xv6 and Unix utilities</h2><h3 id="配置实验环境"><a href="#配置实验环境" class="headerlink" title="配置实验环境"></a>配置实验环境</h3><blockquote>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/qq_25356929/article/details/113747023">xv6环境搭建</a></p>
<p><a href="https://www.bbsmax.com/A/nAJvZNWoJr/">【MIT6.S081/6.828】手把手教你搭建开发环境</a></p>
</blockquote>
<h4 id="下载工具链"><a href="#下载工具链" class="headerlink" title="下载工具链"></a>下载工具链</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span> </span><br></pre></td></tr></table></figure>

<p>测试安装ok：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 --version</span></span><br><span class="line">QEMU emulator version 5.1.0</span><br><span class="line">//下面其中之一正常就行</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-linux-gnu-gcc --version</span></span><br><span class="line">riscv64-linux-gnu-gcc (Debian 10.3.0-8) 10.3.0</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-unknown-elf-gcc --version</span></span><br><span class="line">riscv64-unknown-elf-gcc (GCC) 10.1.0</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-unknown-linux-gnu-gcc --version</span></span><br><span class="line">riscv64-unknown-linux-gnu-gcc (GCC) 10.1.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注，这里出现了一个问题，<code>qemu-system-riscv64 --version</code>打出来发现qemu-system-riscv64 command not found。似乎是我的ubuntu16.04版本太低了【悲】去看了下网上，可以按照这个来做：</p>
<p><a href="https://blog.csdn.net/m0_49270962/article/details/118052926">rCore qemu risc-v 实验环境配置</a></p>
</blockquote>
<h4 id="下载编译xv6源码"><a href="#下载编译xv6源码" class="headerlink" title="下载编译xv6源码"></a>下载编译xv6源码</h4><p>随后，进入一个你喜欢的文件夹clone xv6的实验源码，输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> xv6-labs-2020</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout util</span></span><br></pre></td></tr></table></figure>

<p>然后进行编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br></pre></td></tr></table></figure>

<p>如果此处发生错误：<code>unrecognized command line option -mno-relax</code>，则按照此说法 <a href="https://blog.csdn.net/qq_25356929/article/details/113747023">xv6环境搭建</a>更新gcc版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install gcc-8-riscv64-linux-gnu</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo update-alternatives --install /usr/bin/riscv64-linux-gnu-gcc riscv64-linux-gnu-gcc /usr/bin/riscv64-linux-gnu-gcc-8 8</span></span><br></pre></td></tr></table></figure>

<p>再执行一次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br></pre></td></tr></table></figure>

<p>就ok了。</p>
<h4 id="关闭qemu"><a href="#关闭qemu" class="headerlink" title="关闭qemu"></a>关闭qemu</h4><p><a href="https://blog.csdn.net/qq_67090393/article/details/126975993">qemu退出操作</a></p>
<p>在这里记个强制方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -elf | grep qemu</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/10/xv6/image-20230105153458808.png" alt="image-20230105153458808"></p>
<p>记住第二个的pid</p>
<p>然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill 3303</span><br></pre></td></tr></table></figure>

<h4 id="测试gdb是否ok"><a href="#测试gdb是否ok" class="headerlink" title="测试gdb是否ok"></a>测试gdb是否ok</h4><p>见该文章最后一部分</p>
<p><a href="https://www.bbsmax.com/A/nAJvZNWoJr/">【MIT6.S081/6.828】手把手教你搭建开发环境</a></p>
<h4 id="自测方法"><a href="#自测方法" class="headerlink" title="自测方法"></a>自测方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make grade</span><br></pre></td></tr></table></figure>

<p>或者如果只想测其中一个，可以：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./grade-lab-util sleep</span><br></pre></td></tr></table></figure>

<h4 id="make-qemu后卡住"><a href="#make-qemu后卡住" class="headerlink" title="make qemu后卡住"></a>make qemu后卡住</h4><p>疑似qemu版本不对。<a href="https://zhuanlan.zhihu.com/p/528751993?utm_id=0#:~:text=riscv/pull/126-,%E6%89%A7%E8%A1%8Cmake%20qemu%E5%90%8E%E5%8D%A1%E4%BD%8F,-%E5%8D%A1%E4%BD%8F%E6%98%AF%E5%8F%AF%E4%BB%A5">解决方法</a></p>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><h4 id="编写sleep-c"><a href="#编写sleep-c" class="headerlink" title="编写sleep.c"></a>编写sleep.c</h4><blockquote>
<p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p>
<p><img src="/2023/01/10/xv6/image-20230105164146100.png" alt="image-20230105164146100.png"></p>
</blockquote>
<h5 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h5><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><p>注意，他要求我们实现的sleep的参数是<strong>ticks的数量</strong>，不是秒数。我花了半天找时钟周期大小这个参数在哪，找了许久没找到，估计是没考虑到这一点。</p>
<p>比如说，我翻了一下linux0.11的源码，在include/linux/time.h下有这句：</p>
<p><img src="/2023/01/10/xv6/image-20230105162505574.png" alt="image-20230105162505574.png"></p>
<p>说明了时钟频率大小。在xv6好像没有看到对这个的显式说明。</p>
<h6 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h6><p>感受了一下xv6的系统调用过程，跟linux0.11还是很相像的。</p>
<p>这个好像是lab2的内容，我暂且先在此放下我体会到的感受。</p>
<ol>
<li><p>xv6</p>
<p>首先是从用户态到内核态的切换。</p>
<p>在user/user.h中有各个系统调用外化的函数签名。在用户程序中调用里面的函数签名，就会执行【说实话，我没看懂为什么这里会知道要从user.h跳到usys.S中执行，也许是Makefile里有写？】user/usys.S中对应的汇编代码，比如说这种：</p>
<p><img src="/2023/01/10/xv6/image-20230105170701334.png" alt="image-20230105170701334"></p>
<p>然后这个SYS_close这种，其实是系统调用号宏，被定义在kernel/syscall.h中：</p>
<p><img src="/2023/01/10/xv6/image-20230105171327076.png" alt="image-20230105171327076.pn"></p>
<p><code>li a7,SYS_call</code>就是把SYS_call的值放入a7寄存器，大概就是传参的意思。<code>ecall</code>是从用户态转到内核态的指令。这样一来，就完成了从用户态到内核态的切换。</p>
<p>然后是在内核态的执行。</p>
<p>切换到内核态之后的执行步骤跟linux0.11可以说是完全一样。</p>
<p>首先应该是会去执行kernel/syscall.c中的syscall函数，具体应该是通过ecall引发0x80中断，然后查表得知这个syscall是中断处理函数</p>
<p><img src="/2023/01/10/xv6/image-20230105172110475.png" alt="image-20230105172110475.pn"></p>
<p>可以看到，syscall获取了a7里的参数，然后查了系统调用表</p>
<p><img src="/2023/01/10/xv6/image-20230105173019159.png" alt="image-20230105173019159"></p>
<p>然后去sysproc.c文件下执行相应的sys_xxx函数。这个函数指针用得真是牛逼。</p>
<p>再然后，sys_xxx函数中会从栈中取出调用参数，再跳转到xxx(args)函数中去（这些xxx函数一般在kernel中以单独文件形式出现）。</p>
<p>这样一来，就完成了一次系统调用。</p>
</li>
<li><p>linux0.11</p>
<p>首先是用户态到内核态的切换。</p>
<p>在用户态中比方说调用system call close()，则会调用lib/close.c下的：</p>
<p><img src="/2023/01/10/xv6/image-20230105173820813.png" alt="image-20230105173820813"></p>
<p>展开这个宏之后，是这样的：</p>
<p><img src="/2023/01/10/xv6/image-20230105173845317.png" alt="image-20230105173845317"></p>
<p>具体意思就是把close的系统调用号存入参数寄存器，然后引发0x80中断，进入内核态。</p>
<p>然后是在内核态的执行。</p>
<p>查表会得知sys_call函数是0x80中断的中断处理函数，然后就会根据参数里的系统调用名字去找系统调用表执行</p>
<p><img src="/2023/01/10/xv6/image-20230105174832400.png" alt="image-20230105174832400"></p>
<p>这部分跟xv6差不多，不再赘述</p>
</li>
</ol>
<p>可见，这两个系统在内核态的实现是差不多的，只是在用户态有点稍稍不一样。感觉linux0.11会更加精妙一些。</p>
<h4 id="编写pingpong程序"><a href="#编写pingpong程序" class="headerlink" title="编写pingpong程序"></a>编写pingpong程序</h4><blockquote>
<p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a <strong>pair of pipes</strong>, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</pid></pid></pid></p>
</blockquote>
<h5 id="体会-1"><a href="#体会-1" class="headerlink" title="体会"></a>体会</h5><p>思路很简单，我之所以写了那么久是因为走了好大的弯路……</p>
<p>题目要求输出格式为”<pid>: received ping”，我的思路固化为：先把pid化成数字，再用字符串拼接串成整个。为了实现我的思路，我就需要额外再写两个工具函数，一个是itoa，一个是strcat。而又由于malloc函数暂待实现，itoa和strcat的实现就仍然不够优雅。折腾了半天终于OK了，结果看到别人是怎么做到这个输出格式的呢？↓</pid></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%d: received ping\n&quot;</span>,getpid());</span><br></pre></td></tr></table></figure>

<p>这下是真的尴尬了23333</p>
<p>但总而言之，自己写了那俩不够优雅的函数还算是有点用【大概】。以下是我的代码</p>
<h4 id="编写primes"><a href="#编写primes" class="headerlink" title="编写primes"></a>编写primes</h4><blockquote>
<p>参考：</p>
<p><a href="https://www.ewbang.com/community/article/details/960672708.html">MIT操作系统实验lab1（案例：primes（质数筛选）附代码、详解）</a></p>
<p><a href="https://blog.csdn.net/frost5/article/details/114933307">XV6实验-Lab0 Utilities</a></p>
</blockquote>
<blockquote>
<p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p>
</blockquote>
<p>其实就是用生产者消费者模式来写素数计算的并发版本，这个我熟</p>
<p>……以上是第一印象。然后我看着超链接文章里的素数筛的图片，以及指导书给的提示：</p>
<blockquote>
<p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p>
<ul>
<li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li>
</ul>
</blockquote>
<p>义无反顾地……使用了35个管道hhhhh</p>
<p>然后不知道为什么不行，也焦头烂额地感觉我思路太离谱了，去看了下发现大家都是只用一个管道……</p>
<p>我也搞了个单管道的出来，但是思路受第一篇的影响非常地串行，也即先筛完再创建子进程。看到</p>
<p><a href="https://blog.csdn.net/frost5/article/details/114933307">XV6实验-Lab0 Utilities</a></p>
<p>这篇文章，才发现还可以那样双管道并行……我虽然也考虑过双管道，但是觉得实现不了【因为我是用循环的思路，如果要双管道的话切换会很麻烦】就没写了，没想到还可以向他那样【他选择的是一个在外部定义的p，和一个作用域更小在每次循环内定义的p1，再加上递归传递参数这个技巧，就可以接连不断递归下去了】，深感佩服。写得是真好，可以去参考学习一下，我懒得改了（</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">	pipe(p);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="type">char</span> buf[<span class="number">3</span>];</span><br><span class="line">			<span class="comment">//读入第一个数字 </span></span><br><span class="line">			read(p[<span class="number">0</span>],buf,<span class="number">3</span>);</span><br><span class="line">			<span class="type">int</span> prime = atoi(buf);</span><br><span class="line">			<span class="keyword">if</span>(prime == <span class="number">36</span>)&#123;</span><br><span class="line">				close(p[<span class="number">0</span>]);</span><br><span class="line">				close(p[<span class="number">1</span>]);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;prime %d\n&quot;</span>,prime);</span><br><span class="line">			<span class="comment">//读入其他数字 </span></span><br><span class="line">			<span class="type">int</span> tmp = atoi(buf);</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">				read(p[<span class="number">0</span>],buf,<span class="number">3</span>);</span><br><span class="line">				tmp = atoi(buf);</span><br><span class="line">                <span class="comment">//输入结束</span></span><br><span class="line">				<span class="keyword">if</span>(tmp == <span class="number">36</span>)&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(tmp%prime!=<span class="number">0</span>)&#123;</span><br><span class="line">					write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//作为标记，标志着输入序列结束</span></span><br><span class="line">			itoa(<span class="number">36</span>,buf);</span><br><span class="line">			write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">			<span class="keyword">if</span>(fork())&#123;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				close(p[<span class="number">0</span>]);</span><br><span class="line">				close(p[<span class="number">1</span>]);</span><br><span class="line">				wait(<span class="number">0</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		close(p[<span class="number">0</span>]);</span><br><span class="line">		<span class="type">char</span> buf[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)&#123;</span><br><span class="line">			itoa(i,buf);</span><br><span class="line">			write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//作为标记，标志着输入序列结束</span></span><br><span class="line">		itoa(<span class="number">36</span>,buf);</span><br><span class="line">		write(p[<span class="number">1</span>],buf,<span class="number">3</span>);</span><br><span class="line">		close(p[<span class="number">1</span>]);</span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写find"><a href="#编写find" class="headerlink" title="编写find"></a>编写find</h4><blockquote>
<p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p>
</blockquote>
<h5 id="初始版"><a href="#初始版" class="headerlink" title="初始版"></a>初始版</h5><p>直接照着ls的模板改，改成递归就ok了。值得注意的是，目录也是一种文件，也可以通过read读取。目录文件的内容就是目录里的所有文件的名字。因而，我们在递归时可以忽略文件，只对目录处理，因为目录中就包含着所有文件名的信息。</p>
<h5 id="附加题：支持正则表达式"><a href="#附加题：支持正则表达式" class="headerlink" title="附加题：支持正则表达式"></a>附加题：支持正则表达式</h5><p>把user/grep.c里面的匹配函数拿来就行。</p>
<h4 id="编写xargs"><a href="#编写xargs" class="headerlink" title="编写xargs"></a>编写xargs</h4><blockquote>
<p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p>
</blockquote>
<h5 id="体会-2"><a href="#体会-2" class="headerlink" title="体会"></a>体会</h5><p>思路还是很直观的，就是从stdin一行一行读入数据，然后把这数据处理成参数，最后调用exec就行。就是中间有很多小细节值得注意。</p>
<p>有一点比较坑的是，main方法的那个argc的计算方法是这样的，不是直接用数组的长度：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) </span><br></pre></td></tr></table></figure>

<p>可以看到，合格的argv的形式应该是：参1 参2 参3 “\0”，最后一个元素要以”\0”标志结束。</p>
<p>这个应该是编写者约定俗成的。在user/sh.c的parseexec，大概445行左右：</p>
<p><img src="/2023/01/10/xv6/image-20230106172133338.png" alt="image-20230106172133338"></p>
<p>shell处理命令时是会默认把最后一个清零的。</p>
<blockquote>
<p>确实，后面在学内存的时候，用户空间的构成如图所示：</p>
<p><img src="/2023/01/10/xv6/image-20230109234930690.png" alt="image-20230109234930690"></p>
<p>可以看到栈那边，参数列完了之后是会有一个用以terminate的空指针的</p>
</blockquote>
<h4 id="附加题：改善shell"><a href="#附加题：改善shell" class="headerlink" title="附加题：改善shell"></a>附加题：改善shell</h4><p>看起来又难又多所以我先摸了【润】等之后有时间再回来弄吧</p>
]]></content>
  </entry>
  <entry>
    <title>Operating system oganization</title>
    <url>/2023/01/10/xv6$chap2/</url>
    <content><![CDATA[<h1 id="Operating-system-oganization"><a href="#Operating-system-oganization" class="headerlink" title="Operating system oganization"></a>Operating system oganization</h1><blockquote>
<p>Before you start coding, read Chapter 2 of the <a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev1.pdf">xv6 book</a>, and Sections 4.3 and 4.4 of Chapter 4, and related source files:</p>
<ul>
<li>The user-space code for systems calls is in <code>user/user.h</code> and <code>user/usys.pl</code>.</li>
<li>The kernel-space code is <code>kernel/syscall.h</code>, kernel/syscall.c.</li>
<li>The process-related code is <code>kernel/proc.h</code> and <code>kernel/proc.c</code>.</li>
</ul>
</blockquote>
<p>这章主要是讲了操作系统为了兼顾并发性、隔离性、交互性做出的基本架构。</p>
<h2 id="Kernel-organization"><a href="#Kernel-organization" class="headerlink" title="Kernel organization"></a>Kernel organization</h2><h3 id="宏内核与微内核"><a href="#宏内核与微内核" class="headerlink" title="宏内核与微内核"></a>宏内核与微内核</h3><p>操作系统一个很重要的设计问题就是，哪部分的代码需要run在内核态，哪部分的需要run在用户态。</p>
<p>如果将操作系统所有系统调用统统都在内核态run，这种设计方式就叫宏内核<em>monolithic kernel</em>。</p>
<p>如果仅将系统调用中必要的部分在内核态run，其他部分都在用户态run，并且采取Client/Server这样的异步通信方式，这种设计方式就叫微内核<em>microkernel</em>。</p>
<p><img src="/2023/01/10/xv6/image-20230107232802540.png" alt="image-20230107232802540"></p>
<blockquote>
<p>由于客户/服务器（Client/Server）模式，具有非常多的优点，故在单机<a href="https://baike.baidu.com/item/%E5%BE%AE%E5%86%85%E6%A0%B8">微内核</a>操作系统中几乎无一例外地都采用客户/服务器模式，将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B">进程</a>)中实现。</p>
</blockquote>
<p>在微内核中，内核接口由一些用于启动应用程序、发送消息、访问设备硬件等的低级功能组成。这种组织允许内核相对简单，因为大多数操作系统驻留在用户级服务器中。</p>
<p>像大多数Unix操作系统一样，Xv6是作为一个宏内核实现的。因此，xv6内核接口对应于操作系统接口，内核实现了完整的操作系统。</p>
<h3 id="Code-xv6-organization"><a href="#Code-xv6-organization" class="headerlink" title="Code: xv6 organization"></a>Code: xv6 organization</h3><p>XV6的源代码位于<code>kernel</code>子目录中，源代码按照模块化的概念划分为多个文件，图2.2列出了这些文件，模块间的接口都被定义在了<code>def.h</code>（<code>kernel/defs.h</code>）。</p>
<table>
<thead>
<tr>
<th><strong>文件</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>bio.c</strong></td>
<td>文件系统的磁盘块缓存</td>
</tr>
<tr>
<td><strong>console.c</strong></td>
<td>连接到用户的键盘和屏幕</td>
</tr>
<tr>
<td><strong>entry.S</strong></td>
<td>首次启动指令</td>
</tr>
<tr>
<td><strong>exec.c</strong></td>
<td><code>exec()</code>系统调用</td>
</tr>
<tr>
<td><strong>file.c</strong></td>
<td>文件描述符支持</td>
</tr>
<tr>
<td><strong>fs.c</strong></td>
<td>文件系统</td>
</tr>
<tr>
<td><strong>kalloc.c</strong></td>
<td>物理页面分配器</td>
</tr>
<tr>
<td><strong>kernelvec.S</strong></td>
<td>处理来自内核的陷入指令以及计时器中断</td>
</tr>
<tr>
<td><strong>log.c</strong></td>
<td>文件系统日志记录以及崩溃修复</td>
</tr>
<tr>
<td><strong>main.c</strong></td>
<td>在启动过程中控制其他模块初始化</td>
</tr>
<tr>
<td><strong>pipe.c</strong></td>
<td>管道</td>
</tr>
<tr>
<td><strong>plic.c</strong></td>
<td>RISC-V中断控制器</td>
</tr>
<tr>
<td><strong>printf.c</strong></td>
<td>格式化输出到控制台</td>
</tr>
<tr>
<td><strong>proc.c</strong></td>
<td>进程和调度</td>
</tr>
<tr>
<td><strong>sleeplock.c</strong></td>
<td>Locks that yield the CPU</td>
</tr>
<tr>
<td><strong>spinlock.c</strong></td>
<td>Locks that don’t yield the CPU.</td>
</tr>
<tr>
<td><strong>start.c</strong></td>
<td>早期机器模式启动代码</td>
</tr>
<tr>
<td><strong>string.c</strong></td>
<td>字符串和字节数组库</td>
</tr>
<tr>
<td><strong>swtch.c</strong></td>
<td>线程切换</td>
</tr>
<tr>
<td><strong>syscall.c</strong></td>
<td>Dispatch system calls to handling function.</td>
</tr>
<tr>
<td><strong>sysfile.c</strong></td>
<td>文件相关的系统调用</td>
</tr>
<tr>
<td><strong>sysproc.c</strong></td>
<td>进程相关的系统调用</td>
</tr>
<tr>
<td><strong>trampoline.S</strong></td>
<td>用于在用户和内核之间切换的汇编代码</td>
</tr>
<tr>
<td><strong>trap.c</strong></td>
<td>对陷入指令和中断进行处理并返回的C代码</td>
</tr>
<tr>
<td><strong>uart.c</strong></td>
<td>串口控制台设备驱动程序</td>
</tr>
<tr>
<td><strong>virtio_disk.c</strong></td>
<td>磁盘设备驱动程序</td>
</tr>
<tr>
<td><strong>vm.c</strong></td>
<td>管理页表和地址空间</td>
</tr>
</tbody></table>
<p> <strong>图2.2：XV6内核源文件</strong></p>
<h2 id="Process-overview"><a href="#Process-overview" class="headerlink" title="Process overview"></a>Process overview</h2><p>内核用来实现进程的机制包括用户态内核态标志、地址空间和进程的时间切片。</p>
<p>为了帮助加强隔离，进程抽象给程序提供了一种错觉，即它有自己的专用机器。进程为程序提供了一个看起来像是私有内存系统或地址空间的东西，其他进程不能读取或写入。进程还为程序提供了看起来像是自己的CPU来执行程序的指令。</p>
<p>Xv6使用页表（由硬件实现）为每个进程提供自己的地址空间。RISC-V页表将虚拟地址（RISC-V指令操纵的地址）转换（或“映射”）为物理地址（CPU芯片发送到主存储器的地址）。</p>
<p>每个进程也有自己的页表，页表中记录了以虚拟地址0开始的内存区域。</p>
<p><img src="/2023/01/10/xv6/image-20230107233741922.png" alt="image-20230107233741922"></p>
<p>xv6内核为每个进程维护许多状态片段，并将它们聚集到一个<code>proc</code>(*<strong>kernel/proc.h*</strong>:86)结构体中。一个进程最重要的内核状态片段是它的页表、内核栈区和运行状态。我们将使用符号<code>p-&gt;xxx</code>来引用<code>proc</code>结构体的元素；例如，<code>p-&gt;pagetable</code>是一个指向该进程页表的指针。</p>
<blockquote>
<p>这应该相当于pcb表。</p>
</blockquote>
<h2 id="Code-starting-xv6-and-the-first-process"><a href="#Code-starting-xv6-and-the-first-process" class="headerlink" title="Code: starting xv6 and the first process"></a>Code: starting xv6 and the first process</h2><p>看完一遍说实话还乱乱的。。。。我整理整理跟linux的对比学习一下吧。</p>
<h3 id="xv6"><a href="#xv6" class="headerlink" title="xv6"></a>xv6</h3><h4 id="加载操作系统"><a href="#加载操作系统" class="headerlink" title="加载操作系统"></a>加载操作系统</h4><p>系统加电，启动BIOS初始化硬件 -&gt; BIOS从<u>引导扇区</u>将加载程序读入内存 -&gt; 加载程序将操作系统镜像读入内存RAM。</p>
<blockquote>
<p>这个过程由qemu模拟。</p>
<p>首先会通过<code>mkfs</code>造出操作系统镜像。然后由qemu将引导扇区，也即下面的filesys这图里的第0块：</p>
<p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<p>读入到主存中，然后开始执行引导扇区的程序，下同。</p>
</blockquote>
<p><code>boot loader</code>目的是把xv6加载进内存到<code>0x8000 0000</code>，然后跳转到xv6初始化程序。</p>
<blockquote>
<p>The reason it places the kernel at <code>0x80000000</code> rather than <code>0x0</code> is because the address range <code>0x0:0x80000000</code> contains <strong>I/O devices</strong>.</p>
</blockquote>
<h4 id="操作系统初始化"><a href="#操作系统初始化" class="headerlink" title="操作系统初始化"></a>操作系统初始化</h4><h5 id="entry-S配置栈空间"><a href="#entry-S配置栈空间" class="headerlink" title="entry.S配置栈空间"></a>entry.S配置栈空间</h5><p>此时，目前的机器状态是，1.没有开启地址映射，也即虚拟地址=真实物理地址。2.运行在machine mode</p>
<p>xv6会在<code>kernel/entry.S</code>下的这里开始执行，目的是<strong>配置好栈</strong>，以开始C语言代码<code>start.c</code>的执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # 这段主要是在计算栈顶指针sp</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">        # 已经有栈了，就可以开始执行C语言代码了</span><br><span class="line">        # jump to start()</span><br><span class="line">        call start</span><br></pre></td></tr></table></figure>

<p>其中start0：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br></pre></td></tr></table></figure>

<h5 id="start-c"><a href="#start-c" class="headerlink" title="start.c"></a>start.c</h5><p>在start.c中，我们的任务是在machine mode下，获取machine mode才能访问到的硬件参数，做在machine mode 下才能做的时钟初始化【 it programs the clock chip to generate timer interrupts】，然后进行machine mode到内核态的切换，最后跳转到main.c进行操作系统的初始化和第一个进程的启动。</p>
<p>而其中，如果想从machine mode切换到内核态，就需要使用<code>mret</code>指令。但是mret指令除了会切换mode之外，还有一个“ret”的作用，并且是从machine mode ret到内核态。</p>
<blockquote>
<p>This instruction( mret ) is most often used to return from a previous call from supervisor mode to machine mode.</p>
</blockquote>
<p>所以，我们实际上可以把最后两步连起来，用mret一个指令就完成。也即，mret指令既完成了从machine mode到内核态的切换，又完成了从start.c到main.c的跳转。</p>
<p>这其实很容易，只需在栈中将调用者（此时应该是entry.S）的地址替换为main.c的地址，并且将调用者的mode改为内核态，这样就ok了。</p>
<blockquote>
<p> it sets the <strong>previous privilege mode</strong> to supervisor in the register mstatus, it sets the <strong>return address</strong> to main by writing main’s address into the register mepc, <strong>disables virtual address translation in supervisor mode</strong> by writing 0 into the page-table register satp, and <strong>delegates all interrupts and exceptions to supervisor mode</strong></p>
<p> 后面两点不大明白。为什么为了mret，就还得让内核态跟machine mode一样关闭虚拟地址映射，还得把什么中断和异常委托给内核态？？</p>
<p> 【我猜测是因为现在页表还没初始化好所以当然得关闭虚拟地址映射（）；后者大概是开中断的意思？】</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//修改调用者为内核态</span></span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h5><p>main.c的作用是做很多很多init。其中，它通过<code>userinit();</code>来创建第一个进程，这个第一个进程再由main调用<code>scheduler()</code>来被调度执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//...很多很多init</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    RISC-V的处理器对底层提供了一种特殊的抽象,Hardware Thread,简称为Hart。简单来说,Hart是真实物理CPU(bare metal)提供的一种模拟</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用第一个scheduler，完成对scheduler线程的初始化，并且调度去执行第一个进程</span></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：关于里面的cpuid，我查了一下，指的是CPU的序列号，用来唯一标识cpu的。我想这个if架构的目的应该跟<code>fork()==0</code>差不多。也就是说，一开始的那个init仅有<code>cpuid==0</code>的CPU执行，其他的CPU就乖乖wait，只有CPU0执行初始化的程序。等到CPU0执行完所有init，才置标记位start=1，然后通过条件变量start控制抢占调度，轮流初始化自己。其中<code>__sync_synchronize</code>是GNU内置指令，起内存屏障作用。在竞赛中深刻地了解过了内存屏障，在这里再次跟老熟人再会感觉还是很有意思的。</p>
</blockquote>
<h5 id="proc-c中的userinit"><a href="#proc-c中的userinit" class="headerlink" title="proc.c中的userinit()"></a>proc.c中的userinit()</h5><p>userinit的作用就是新创建一个进程信息proc，然后开始给第一个程序（initcode）填信息填入proc。这个进程创建完后，在main中的scheduler被调度执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请一页，将initcode的指令和数据放进去</span></span><br><span class="line">  <span class="comment">// allocate one user page and copy initcode&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvmfirst(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为内核态到用户态的转变做准备</span></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Trap Frame是指中断、自陷、异常进入内核后,在堆栈上形成的一种数据结构</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改进程名</span></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个也许是为了能被优先调度</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="initcode-S"><a href="#initcode-S" class="headerlink" title="initcode.S"></a>initcode.S</h5><p>以上程序都位于<code>kernel/</code>下。这个位于<code>user/</code>下。</p>
<p>它调用exec系统调用进入了内核态。当exec完成后，它就跳转到了用户态<code>user/init.c</code>中。【这里估计又用了修改返回地址的trick】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure>

<h5 id="init-c"><a href="#init-c" class="headerlink" title="init.c"></a>init.c</h5><p>在init.c中，创建了console设备文件，打开了012文件描述符，并且fork了一个子进程，开始执行shell。这样一来，操作系统就完成了全部的启动。</p>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><blockquote>
<p>我的疑点有三个：</p>
<ol>
<li><p>见start.c</p>
</li>
<li><p>是怎么完成从内核态到用户态的切换的？是执行了return就会自动切换吗？userinit中设置了initcode的信息为用户态的，然后就直接能进入用户态，这里感觉有点模糊。</p>
<p>其实用户态和内核态本质上好像差别不大，似乎也就只有两方面，一个是页表（虚拟地址），另一个就是权限问题了。前者很好说，在main.c中完成了页表初始化，开启了虚拟地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">kvminithart();   <span class="comment">// turn on paging</span></span><br></pre></td></tr></table></figure>

<p>后者的话，从用户态切到内核态使用ecall指令，从machine mode到内核态需要修改mstatus寄存器并且使用mret指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">x |= MSTATUS_MPP_S;</span><br><span class="line">w_mstatus(x);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>因而从内核态切换到用户态应该也是需要类似这段对mstatus寄存器的修改的，并且其对应修改的是sstatus寄存器。</p>
<p>但是，我只在普通的用户态-trap入内核态-用户态这个过程的usertrapret中看到对sstatus寄存器的写入，并没有在init的时候对这个玩意进行写入。</p>
<p>所以，最后，我初步猜测，是会在scheduler()中的上下文切换中修改sstatus寄存器的内容为user mode，从而实现由内核态向用户态进程（initcode）的切换。不过这也仅仅是<strong>【猜想】</strong>，因为我并没有在switch的汇编代码中看到对sstatus的修改。真是令人麻木。。。</p>
</li>
</ol>
<p>步骤十分直接且有理由：</p>
<p>加载操作系统——为了能执行C语言需要一个栈，所以得执行造一个的代码，然后再进入C语言zone——做点machine mode才能做的事，然后从machine mode切换到内核态——做点内核态才能做的事，从内核态切换到用户态</p>
</blockquote>
<h3 id="linux0-11"><a href="#linux0-11" class="headerlink" title="linux0.11"></a>linux0.11</h3><p>bootsect -&gt; setup -&gt; head.s -&gt;main.c</p>
<h4 id="加载操作系统-1"><a href="#加载操作系统-1" class="headerlink" title="加载操作系统"></a>加载操作系统</h4><p>系统加电，启动BIOS初始化硬件 -&gt; BIOS从<u>引导扇区</u>将加载程序读入内存 -&gt; 加载程序将操作系统镜像读入内存RAM。</p>
<p>其中，第二三步做进一步的细化。</p>
<h5 id="读入bootsect-s"><a href="#读入bootsect-s" class="headerlink" title="读入bootsect.s"></a>读入bootsect.s</h5><p>加载程序的512个字节被读入到内存从<code>0x7c00</code>开始的一段内存中，并且BIOS设置<code>CS=07c0,ip=0</code>，开始执行加载程序的每一条指令。</p>
<h5 id="bootsect-s"><a href="#bootsect-s" class="headerlink" title="bootsect.s"></a>bootsect.s</h5><p>加载程序的代码为<code>bootsect.s</code>。在<code>bootsect.s</code>中，首先将自身从<code>7c00</code>处移动到了<code>9000</code>处【留下空间放操作系统】，然后分别依次读取磁盘的<u>setup</u>和<u>system</u>模块，最后bootsect将控制权转交给setup。</p>
<h5 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h5><p>setup首先获取操作系统运行的<strong>必要硬件参数</strong>。</p>
<p><img src="/2023/01/10/xv6/image-20230108011824655.png" alt="image-20230108011824655"></p>
<p>再然后，<u>将system代码移到0地址</u>。然后，我们就需要进入system代码块。</p>
<p><img src="/2023/01/10/xv6/image-20230108012316631.png" alt="image-20230108012316631"></p>
<p>最后一句jmpi指令本来应该是要跳到system代码段首0地址处的的，可此处却跳到了80处，这显然不合理。但它写的肯定是没错的。之所以会有这样的矛盾，是因为setup在此之前，还做了一件事情：<strong>改变寻址方式</strong>。jmpi上面的那条mov指令便做了这点。</p>
<p>我们之前的寻址方式一直是<code>cs&lt;&lt;4+ip</code>。但是这东西只能是16位的内存，<u>无法满足寻址需求</u>。故而setup要从16位切换到32位。32位模式也叫保护模式。</p>
<blockquote>
<p>至于怎么切的呢？要注意到一点，改变寻址方式也即改变cs和ip的地址计算方法，也即换一条硬件电路实现。计算机给我们提供了一个简单的方式操纵保护模式的转变，即修改cr0寄存器的内容。</p>
</blockquote>
<p>在保护模式下，寻址方式发生了改变。此时cs不再代表基址，而是表示地址在gdb表<code>global description table</code>中的偏移下标。真正的基址放在表项中。cs被称为selector，从表中取得基址，再和ip加在一起得到地址。</p>
<blockquote>
<p>gdt表的内容由setup初始化</p>
<p><img src="/2023/01/10/xv6/image-20230108013156116.png" alt="image-20230108013156116"></p>
</blockquote>
<p>这样一来，就正确跳到了system模块。</p>
<h4 id="操作系统初始化-1"><a href="#操作系统初始化-1" class="headerlink" title="操作系统初始化"></a>操作系统初始化</h4><h5 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h5><p>跳到system第一个文件，也就是head.s去执行。</p>
<p>head.s也是在保护模式下进行的，是在保护模式下的初始化。</p>
<p>head.s建立了真正的gdt表，然后就要跳转到main.c执行初始化和Shell的启动。此处有汇编语言和C语言的转化，也就是push参数然后push main的地址。</p>
<h5 id="main-c-1"><a href="#main-c-1" class="headerlink" title="main.c"></a>main.c</h5><p>对各种东西的初始化。</p>
<p><img src="/2023/01/10/xv6/image-20230108013849664.png" alt="image-20230108013849664"></p>
<p>最后完成从内核态到用户态的切换。</p>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><blockquote>
<p>linux0.11的启动的具体思路是：</p>
<p>加载操作系统，获取硬件参数，进入保护模式，跳转到操作系统第一行代码——操作系统初始化，切换到用户态</p>
<p>linux0.11相比于xv6更加复杂，上课的时候隐藏了很多实现细节但依旧理解很费劲（。</p>
<p>这两个步骤思路其实都是差不多的，区别在于linux0.11好像没有machine mode这个概念。感觉也不能锐评什么，因为看完了感觉两个都很有道理，两个都一样很难懂（。</p>
<p>【注：为什么没有machine mode呢？是因为这个mode的划分是RISC-V架构做的，而linux0.11是基于X86架构。】</p>
<p>不过linux0.11这里进入保护模式后改变寻址方式是因为机器问题（好像是），xv6难道也是因为硬件问题吗？因为一开始的时候操作系统还未进行内存分页页表初始化，所以用不了地址映射？有待学习。</p>
<p>关于保护模式，可以看看这篇文章，今天太晚了先睡了：</p>
<p><a href="https://blog.51cto.com/u_15082498/5527746"><strong>Linux从头学08：Linux 是如何保护内核代码的？【从实模式到保护模式】</strong></a></p>
</blockquote>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><p>现实中，大多数操作系统都会兼顾宏内核与微内核。</p>
<p>大多数操作系统都支持与xv6类似的process进程概念，也有很多系统还支持线程概念。</p>
<h2 id="Lab-system-calls"><a href="#Lab-system-calls" class="headerlink" title="Lab system calls"></a>Lab system calls</h2><blockquote>
<p>To start the lab, switch to the syscall branch:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout syscall</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><blockquote>
<p>In this assignment you will add a system call tracing feature that may help you when debugging later labs.</p>
<p>You’ll create a new <code>trace</code> system call that will control tracing. It should take <strong>one argument,</strong> an integer “mask”, whose bits specify which system calls to trace. </p>
<p>For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>. You have to modify the xv6 kernel to <strong>print out a line when each system call is about to return</strong>. The line should contain the <strong>process id</strong>, the <strong>name</strong> of the system call and the <strong>return value</strong>; you don’t need to print the system call arguments. </p>
<p>The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p>
</blockquote>
<h4 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h4><p>一开始为了把trace做得封装性良好一些尽量不改别的代码，想了好久好久，最后就只能想出，在syscall.c获取系统调用返回值处加个条件打印，在trace中维护一个map，映射进程pid和进程当前的mask，并且给外界提供查询当前进程是否对某个系统调用有mask作为syscall条件打印的接口。</p>
<p>这个最后还是失败了，失败的点在于不知道要创建多大的数组来作为map映射所有进程，因为pid分配估计是递增的，是会超过最大进程数的，所以pid会是多少是不确定的。还有一点就是fork之后子进程不能自动继承父进程的mask，还得手动调用一下trace，这更加不封装了（。</p>
<p>总之先放上我原来的代码吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/syscall.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* tmp)</span>&#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((*tmp)!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">    buf[i++] = *tmp;</span><br><span class="line">    tmp++;</span><br><span class="line">  &#125;  </span><br><span class="line">  buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getname</span><span class="params">(<span class="type">int</span> callid,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(callid)&#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_fork: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fork&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exit: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exit&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_wait: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;wait&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_pipe: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;pipe&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_read: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;read&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_kill: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;kill&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exec: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exec&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_fstat: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fstat&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_chdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;chdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_dup: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;dup&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getpid: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;getpid&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sbrk: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sbrk&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sleep: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sleep&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_uptime: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;uptime&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_open: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;open&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_write: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;write&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mknod: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mknod&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_unlink: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;unlink&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_link: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;link&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mkdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mkdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_close: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;close&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_trace: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;trace&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    getname(num,buf);</span><br><span class="line">    <span class="comment">// 在此处添加条件打印</span></span><br><span class="line">    <span class="keyword">if</span>(istraced(num))</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;syscall %s -&gt; %d\n&quot;</span>,buf,p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trace.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_mask[NPROC];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    m_mask[p-&gt;pid] = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供给外界查询的接口</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">istraced</span><span class="params">(<span class="type">int</span> callid)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">//printf(&quot;from trace ,pid = %d\n&quot;,p-&gt;pid);</span></span><br><span class="line">    <span class="keyword">if</span>(((m_mask[p-&gt;pid] &gt;&gt; callid) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是按照hints修改后的正确代码。</p>
<h4 id="代码步骤"><a href="#代码步骤" class="headerlink" title="代码步骤"></a>代码步骤</h4><p>实际上，标答跟我的思路差不多，只不过它没有像我一样创建数组作为map，而是在proc结构体里添加了一个属性，这本质上也是利用了map。</p>
<h5 id="在各种文件添加签名"><a href="#在各种文件添加签名" class="headerlink" title="在各种文件添加签名"></a>在各种文件添加签名</h5><h6 id="user-user-h"><a href="#user-user-h" class="headerlink" title="user/user.h"></a>user/user.h</h6><h6 id="user-usys-pl"><a href="#user-usys-pl" class="headerlink" title="user/usys.pl"></a>user/usys.pl</h6><h6 id="syscall-h"><a href="#syscall-h" class="headerlink" title="syscall.h"></a>syscall.h</h6><p>添加系统调用号</p>
<h6 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h6><p>添加系统调用号和sys_trace映射</p>
<h6 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改Makefile</h6><ol>
<li>在第一个OBJS添加trace.o</li>
<li>在UPROGS添加user中的trace</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><h6 id="修改proc-h"><a href="#修改proc-h" class="headerlink" title="修改proc.h"></a>修改proc.h</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> mask; <span class="comment">//记录trace的mask</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="编写trace-c"><a href="#编写trace-c" class="headerlink" title="编写trace.c"></a>编写trace.c</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;mask = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">istraced</span><span class="params">(<span class="type">int</span> callid)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span>(((p-&gt;mask &gt;&gt; callid) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="修改syscall-c"><a href="#修改syscall-c" class="headerlink" title="修改syscall.c"></a>修改syscall.c</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/syscall.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* tmp)</span>&#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((*tmp)!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">    buf[i++] = *tmp;</span><br><span class="line">    tmp++;</span><br><span class="line">  &#125;  </span><br><span class="line">  buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getname</span><span class="params">(<span class="type">int</span> callid,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(callid)&#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_fork: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fork&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exit: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exit&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_wait: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;wait&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_pipe: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;pipe&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_read: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;read&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_kill: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;kill&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_exec: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;exec&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_fstat: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;fstat&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_chdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;chdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_dup: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;dup&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getpid: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;getpid&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sbrk: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sbrk&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_sleep: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;sleep&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_uptime: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;uptime&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_open: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;open&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_write: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;write&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mknod: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mknod&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_unlink: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;unlink&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_link: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;link&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_mkdir: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;mkdir&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_close: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;close&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_trace: <span class="built_in">strcpy</span>(buf,<span class="string">&quot;trace&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    getname(num,buf);</span><br><span class="line">    <span class="comment">// 在此处添加条件打印</span></span><br><span class="line">    <span class="keyword">if</span>(istraced(num))</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;syscall %s -&gt; %d\n&quot;</span>,buf,p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="在sysproc-c中添加系统调用"><a href="#在sysproc-c中添加系统调用" class="headerlink" title="在sysproc.c中添加系统调用"></a>在sysproc.c中添加系统调用</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>,&amp;mask)&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  trace(mask);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="修改fork"><a href="#修改fork" class="headerlink" title="修改fork"></a>修改fork</h6><p>继承父进程的mask</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">np-&gt;mask = p-&gt;mask;</span><br></pre></td></tr></table></figure>

<h6 id="在defs-h中添加需要public的函数签名"><a href="#在defs-h中添加需要public的函数签名" class="headerlink" title="在defs.h中添加需要public的函数签名"></a>在defs.h中添加需要public的函数签名</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trace.c</span></span><br><span class="line"><span class="type">int</span>		<span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span>		<span class="title function_">istraced</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="sysinfotest"><a href="#sysinfotest" class="headerlink" title="sysinfotest"></a>sysinfotest</h3><blockquote>
<p>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. </p>
<p>The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). </p>
<p>The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code> field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. </p>
<p>We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysinfo.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> &#123;</span></span><br><span class="line">  uint64 freemem;   <span class="comment">// amount of free memory (bytes)</span></span><br><span class="line">  uint64 nproc;     <span class="comment">// number of process</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="感想-3"><a href="#感想-3" class="headerlink" title="感想"></a>感想</h4><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>系统调用要做的事情同上。</p>
<p>有一个我在hit实验没想到，在这里<strong>依然没有想到</strong>的点是，参数的指针来自用户空间，所以不能直接对其指向的空间进行写入，需要借助copyout函数。</p>
<p>还有一件事，就是不知道该怎么统计free mem的数量，后来在hints提示下才知道要去kalloc.c中找。【之前只找过了vm.c】这里其实是很后悔提前看了提示的。我应该先去看一下上面关于kernel各个文件用途的笔记，再去继续自己找的，不能太过依赖提示。</p>
<p>还有一点做的不好的地方是，标答是选择了将两个计数函数放在各自的文件中，我是选择直接将成员变量在头文件中extern 公开出来，比如说在proc.h中这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br></pre></td></tr></table></figure>

<p>hints采取了比我封装性更好的操作，这也是非常顺理成章的，我没有想到这样真是有点惭愧（。</p>
<p>总而言之，这个还是挺简单的，就是我很后悔我心浮气躁看了提示，要不然收获会更多。</p>
<h5 id="sysinfo-c"><a href="#sysinfo-c" class="headerlink" title="sysinfo.c"></a>sysinfo.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysinfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo* info)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">res</span>;</span></span><br><span class="line">  res.nproc = countproc();</span><br><span class="line">  res.freemem = countfree();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, (uint64)info,(<span class="type">char</span> *)(&amp;res), <span class="keyword">sizeof</span>(res)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sysproc-c中"><a href="#sysproc-c中" class="headerlink" title="sysproc.c中"></a>sysproc.c中</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> sysinfo((<span class="keyword">struct</span> sysinfo*)addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="kalloc-c中"><a href="#kalloc-c中" class="headerlink" title="kalloc.c中"></a>kalloc.c中</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用的是链表结构，run代表一页</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="comment">// 指向第一个空闲页</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">countfree</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> npage = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span>* <span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">    npage++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> npage*PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="proc-c中"><a href="#proc-c中" class="headerlink" title="proc.c中"></a>proc.c中</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">countproc</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NPROC;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(proc[i].state != UNUSED)&#123;</span><br><span class="line">	  nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nproc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h4><h5 id="trace-plus"><a href="#trace-plus" class="headerlink" title="trace plus"></a>trace plus</h5><blockquote>
<p>Print the system call arguments for traced system calls.</p>
</blockquote>
<p>这个实现起来要说简单也简单，麻烦也麻烦。这里就先摆了【实际上尝试了半小时发现太烦了看别人写的也不大满意就放弃了】</p>
<h5 id="sysinfo-plus"><a href="#sysinfo-plus" class="headerlink" title="sysinfo plus"></a>sysinfo plus</h5><blockquote>
<p>Compute the load average and export it through sysinfo</p>
</blockquote>
<p>说实话没太看懂，不就加个 running process/ncpu就行了吗？</p>
]]></content>
  </entry>
  <entry>
    <title>Page tables</title>
    <url>/2023/01/10/xv6$chap3/</url>
    <content><![CDATA[<h1 id="Page-tables"><a href="#Page-tables" class="headerlink" title="Page tables"></a>Page tables</h1><h2 id="Paging-hardware"><a href="#Paging-hardware" class="headerlink" title="Paging hardware"></a>Paging hardware</h2><h3 id="为什么需要页表"><a href="#为什么需要页表" class="headerlink" title="为什么需要页表"></a>为什么需要页表</h3><p>将主存储器以及各种外设接口卡里面内置的存储器连接起来，就形成了内存地址空间。内存地址空间中的地址是真实的物理地址。RISC-V架构的指令使用的地址是虚拟地址。为了通过指令中的虚拟地址访问到真实的物理内存，需要进行从虚拟地址到物理地址的转换。从虚拟地址到物理地址的转换，就需要通过页表来实现。</p>
<h3 id="页表如何运作"><a href="#页表如何运作" class="headerlink" title="页表如何运作"></a>页表如何运作</h3><p>在RISC-V指令集中，当我们需要开启页表服务时，我们需要将我们预先配置好的页表首地址放入 <code>satp</code> 寄存器中。从此之后， <strong>计算机硬件</strong> 将把访存的地址 <strong>均视为虚拟地址</strong> ，都需要通过硬件查询页表，将其 <strong>翻译成为物理地址</strong> ，然后将其作为地址发送给内存进行访存。</p>
<p>xv6采用的指令集标准为RISC-V标准，其中页表的标准为SV39标准，也就是虚拟地址最多为39位。</p>
<p>虚实地址翻译流程：</p>
<ol>
<li>获得一个虚拟地址。根页表基地址已经被装填至寄存器 <code>satp</code> 中。</li>
<li>通过 <code>satp</code> 找到根页表的物理页帧号，转成物理地址（<code>Offset</code>为0），通过虚拟地址的<code>L2</code>索引，找到对应的页表项。</li>
<li>通过页表项可以找到找到 <strong>次页表</strong> 的物理页帧号，转成物理地址（<code>Offset</code>为0），通过虚拟地址的<code>L1</code>索引，找到对应的页表项。</li>
<li>通过页表项可以找到找到 <strong>叶子页表</strong> 的物理页帧号，转成物理地址（<code>Offset</code>为0），通过虚拟地址的<code>L0</code>索引，找到对应的页表项。</li>
<li>通过页表项可以找到找到 <strong>物理地址</strong> 的物理页帧号，通过虚拟地址的<code>Offset</code>，转成物理地址（<code>Offset</code>和虚拟地址<code>Offset</code>相同）。</li>
</ol>
<h3 id="页表组成"><a href="#页表组成" class="headerlink" title="页表组成"></a>页表组成</h3><h4 id="页表项"><a href="#页表项" class="headerlink" title="页表项"></a>页表项</h4><p>页表由页表项PTE（Page Table Entries）构成，每个页表项由44位的PPN（Physical Page Number）和一些参数flag组成。</p>
<p><img src="/2023/01/10/xv6/image-20230109153937459.png" alt="image-20230109153937459"></p>
<blockquote>
<p>Each PTE contains flflag bits that tell the paging hardware how the associated virtual address is allowed to be used. <strong>PTE_V</strong> indicates whether the PTE is <u>present</u>: if it is not set, a reference to the page causes an exception (i.e. is not allowed). <strong>PTE_R</strong> controls whether instructions are allowed to <u>read</u> to the page. PTE_W controls whether instructions are allowed to write to the page. <strong>PTE_X</strong> controls whether the CPU may interpret the content of the page <u>as instructions and execute them</u>. <strong>PTE_U</strong> controls whether instructions in <u>user</u> mode are allowed to <u>access</u> the page; if PTE_U is not set, the PTE can be used only in supervisor mode.</p>
<p>这个表项的几个参数定义在kernel/riscv.h中的341行左右。</p>
</blockquote>
<p>虚拟地址有64bit，其中25bits未使用，39bits包含了27位的PTE索引号以及12位的offset。</p>
<p>物理地址有56位，由PPN和offset拼接组成。</p>
<h4 id="单页表和多级页表"><a href="#单页表和多级页表" class="headerlink" title="单页表和多级页表"></a>单页表和多级页表</h4><p>以单页表为例，物理地址形成过程如下图所示。</p>
<p><img src="/2023/01/10/xv6/pagetable.png" alt="image"></p>
<p><u>每个页表项PTE索引着一页</u>。因而，每一页的大小为2^12=4096B。单页表中PTE的索引号有2^27个，因而单页表中表项有134217728个，即可以代表134217728页。页表实际上也是以页的形式存储的。因而单页表需要的存储空间为(2^27x7)/2^12=2^15x7=229376页。</p>
<p>RISC-V架构中真实情况是会有三级页表。三级页表结构相比于单级页表结构，会占据更多的<strong>物理存储空间</strong>。</p>
<p><img src="/2023/01/10/xv6/image-20230109151346780.png" alt="image-20230109151346780"></p>
<p><u>每个页表项PTE索引着一页，这一页可能代表着另一个页表，也可能代表着内存中需要的指令和数据</u>。因而，每一页的大小为2^12=4096B。三页表中，一级页表中PTE的索引号有512个，可以代表的物理内存页数有512x515x512=2^27页，即可以代表134217728页。页表实际上也是以页的形式存储的，一个页表有2^9x7个字节，可以存储在1页中。因而三页表需要的存储空间为1+2^9+2^18 = 262657页。</p>
<p>三级页表结构相比于单级页表结构，可以节省更多<strong>内存空间</strong>。</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/fuyuande/article/details/117616433">页表是啥以及为啥多级页表能够节省空间</a></p>
</blockquote>
<p>考虑到这样一个进程：</p>
<p><img src="/2023/01/10/xv6/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1eXVhbmRl,size_16,color_FFFFFF,t_70.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1eXVhbmRl,size_16,color_FFFFFF,t_70"></p>
<p>进程使用页表时，需要将整个页表读入内存。</p>
<p>如果使用单级页表，尽管一个进程仅使用到页表中的某两项，也需要把整个页表都读入内存，光是页表就占据了2^15x7x4k/2^20 约为1G的内存空间。</p>
<p>如果使用三级页表，一个进程需要用到某两页。假设这两页存储在不同的二级页表中，则只需要读入1+2+2=5页 约为20K的内存空间。</p>
<p>两者相对比，显然用三级页表比单级页表顶多了。三级页表相较于一级页表，多用了13%的物理空间，却可以节省99.998%的空间。</p>
<h3 id="页表使用"><a href="#页表使用" class="headerlink" title="页表使用"></a>页表使用</h3><p>每个进程会保留自己的一份用户级别的页表地址。当轮到自己使用CPU时，会将CPU的satp寄存器更换为自己的页表地址。</p>
<h2 id="Kernel-address-space"><a href="#Kernel-address-space" class="headerlink" title="Kernel address space"></a>Kernel address space</h2><p>介绍了xv6中内核的页表结构。</p>
<blockquote>
<p>这里为了方便，就把三级页表省略了，只留下va和pa的对比</p>
</blockquote>
<p>每个进程都有一个用户级别的页表。xv6给内核提供了一个单独的内核地址空间的页表。其层级映射关系如下：</p>
<p><img src="/2023/01/10/xv6/p3.png" alt="p3"></p>
<p>在kernel/memlayout.h中正记录了这些参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Physical memory layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu -machine virt is set up like this,</span></span><br><span class="line"><span class="comment">// based on qemu&#x27;s hw/riscv/virt.c:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 00001000 -- boot ROM, provided by qemu</span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT</span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC</span></span><br><span class="line"><span class="comment">// 10000000 -- uart0 </span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk </span></span><br><span class="line"><span class="comment">// 80000000 -- boot ROM jumps here in machine mode</span></span><br><span class="line"><span class="comment">//             -kernel loads the kernel here</span></span><br><span class="line"><span class="comment">// unused RAM after 80000000.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel uses physical memory thus:</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S, then kernel text and data</span></span><br><span class="line"><span class="comment">// end -- start of kernel page allocation area</span></span><br><span class="line"><span class="comment">// PHYSTOP -- end RAM used by the kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// core local interruptor (CLINT), which contains the timer.</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>由图可知，一直从0x0到0x86400000，都是采取的<strong>直接映射</strong>的方式，虚拟地址=物理地址，这段是内核使用的空间。在0x0-0x800000000阶段，物理地址代表着各种IO设备的存储器。</p>
<p>但是注意，在0x86400000（PHYSTOP）以上的地址都不是直接映射，这些非直接映射的层级包含两类：</p>
<ol>
<li><p>trampoline</p>
<blockquote>
<p>It is mapped at the top of the virtual address space; user page tables have this same mapping. </p>
</blockquote>
<p>它有一点很特殊的是，它实际对应的物理内存是0x80000000开始的一段。也就是说，0x80000000开始的这段内存，既被直接映射了，也被trampoline通过虚拟地址映射了。它被映射了两次。</p>
</li>
<li><p>内核栈</p>
<blockquote>
<p>Each process has its own kernel stack, which is mapped high so that below it xv6 can leave an unmapped <em>guard page</em>. The guard page’s PTE is invalid (i.e., <u>PTE_V is not set</u>), so that if the kernel <strong>overflflows</strong> a kernel stack, it will likely cause an exception and the kernel will panic.</p>
<p>guard page可以用来防止内核栈溢出。</p>
</blockquote>
</li>
</ol>
<p>内核使用PTE_R和PTE_X权限映射trampoline和kernel text。这表明这份内存段可以读，可以被当做指令块执行，但不能写。其他的块都是可读可写的，除了guard page被设置为不可访问。</p>
<h2 id="Code-creating-an-address-space"><a href="#Code-creating-an-address-space" class="headerlink" title="Code: creating an address space"></a>Code: creating an address space</h2><h3 id="vm-c"><a href="#vm-c" class="headerlink" title="vm.c"></a>vm.c</h3><p>操作地址空间和页表部分的代码都在<code>kernel/vm.c</code>中。代表页表的数据结构是<code>pagetable_t</code>。</p>
<p>vm.c的主要函数有walk、mappages等。walk用来在三级页表中找到某个虚拟地址表项，或者创建一个新的表项。mappages用来新建一个表项，主要用到了walk函数。</p>
<p>vm.c中，以kvm开头的代表操纵内核页表，以uvm开头的代表操纵进程里的用户页表。</p>
<h4 id="以初始化为例介绍各个函数"><a href="#以初始化为例介绍各个函数" class="headerlink" title="以初始化为例介绍各个函数"></a>以初始化为例介绍各个函数</h4><h5 id="创建页表"><a href="#创建页表" class="headerlink" title="创建页表"></a>创建页表</h5><p>一开始操作系统初始化时，会调用vm.c中的kvminit来创建内核页表。主要就是在以内核地址空间的页表结构在填写页表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//内核页表</span></span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line">  <span class="comment">//申请新的一页</span></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//给内核页表初始化表项，结构详见上面的内核地址空间部分</span></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，kvmmap用来在内核页表中添加一个新的表项。其函数形式为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现主要逻辑的是mappages函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">//walk函数通过虚拟地址新建一个第三级页表的表项并返回其指针，之后只需要填这个表项即可</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果pte存在并且标记为已使用，说明该虚拟地址映射已经存在</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    <span class="comment">//填写表项：物理地址 flags</span></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//每两个表项间隔PGSIZE个字节</span></span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过虚拟地址获取表项主要是通过walk实现的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="comment">// 虚拟地址的格式：UNUSED 页表索引 offset，其中页表索引在三级页表中被划分为了三个，分别是</span></span><br><span class="line"><span class="comment">// level0-level2，分别代表了第三级、第二级、第一级页表的索引【具体可见页表组成中的图】</span></span><br><span class="line"><span class="comment">// walk的目的就是要在这三级页表中找到虚拟地址对应的页表项。当alloc!=0时，则要求找不到就新建一个</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// 取出PTE中表示下一级页表地址的字节</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 页表不存在的情况，要么返回0，要么新建一页</span></span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终返回第三级页表的对应表项</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="装上页表"><a href="#装上页表" class="headerlink" title="装上页表"></a>装上页表</h5><p>使用的是kvminithart函数。它将内核页表的root page table的物理地址写入了satp寄存器。从这个函数之后，就<strong>开启了内存映射</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// wait for any previous writes to the page table memory to finish.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line"></span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flush stale entries from the TLB.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中sfence_vma()的用途是强制更新TLB的旧页表，类似于Java volatile的作用。</p>
<h6 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h6><p>附上书里的详细解释：</p>
<p><img src="/2023/01/10/xv6/image-20230109222917346.png" alt="image-20230109222917346"></p>
<p>TLB与页表类似于cache与主存的关系。TLB保存了页表的一部分。</p>
<h6 id="我的错误想法"><a href="#我的错误想法" class="headerlink" title="我的错误想法"></a>我的错误想法</h6><p>我怎么感觉怪怪的啊？因为TLB既然是高速缓存，那么读写页表也应该优先从TLB读写【注：应该就是从这里开始错的hhh写应该是直接写入页表】。所以说，会陈旧的应该是主存中的页表，而不是TLB中的页表。但是，书里是说，改完页表必须通知TLB更改。也就是说，读写页表不是从TLB读写的，那该是从哪里？是TLB以外的free memory吗？</p>
<p>不过，要是从多CPU的角度思考，说不定他这个意思是某个CPU的TLB变了，需要通知其他所有CPU的TLB也变。虽然不同CPU当前执行的进程是不一样的，使用的页表项不一样，切换进程的时候也会把用户地址空间的页表项flush掉。但是内核地址空间的页表项一般是不会随着进程切换而flush掉的。所以内核页表修改就需要手动多CPU同步。</p>
<p>我认为多CPU角度考虑更加合理，因为它最后说了，xv6会在内核页表init后flush，以及在从内核态切换回用户态的时候flush。这两个（好像）都影响内核页表比较多，所以就需要手动flush一下。</p>
<h6 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h6><p>之后学了缺页异常后，可以发现这里其实是没问题的。</p>
<p><a href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq">计算机体系结构 – 虚拟内存</a></p>
<p><img src="/2023/01/10/xv6/v2-e15454bf032baa4dc088b6e41ed4f4a4_1440w.jpg" alt="v2-e15454bf032baa4dc088b6e41ed4f4a4_1440w"></p>
<p>页表的管理（创建、更新、删除等）是由操作系统负责的。地址转换时，页表检索是由硬件内存管理单元（Memory Management Unit, MMU）负责的。MMU通常由两部分构成：表查找单元（Table Walk Unit, TWU）和转换旁路缓冲（Translation Lookaside Buffer, TLB）[<a href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_2">2]</a>。TWU负责链式的访问PDE、PTE，完成上述的查表过程。</p>
<p>应用多级页表之后，想要完成一次地址转换，需要访问多级目录和页表，这么多次的内存访问会严重降低性能。</p>
<p>为了优化地址转换速度，人们在MMU中增加了一块高速cache，专门用来缓存虚拟地址到物理地址的映射，这块cache就是TLB[<a href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_7">7]</a>[<a href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_8">8]</a>。MMU在做地址转换的时候，会先检索TLB，如果命中则直接返回对应的物理地址，如果不命中则会调用TWU查找页表。</p>
<p>TLB中缓存的是虚拟地址到物理地址映射。然而，多级页表的查找是一个链式的过程，对于在虚拟地址空间中连续的两个页，它们的各级目录项可能都是一样的，只有最后一级页号不一样。查找完第一个虚拟页之后，我们可以将相同的前级目录项都缓存起来。查找第二个虚拟页时，可以直接使用缓存好的前几级目录项，节省查找时间。这种缓存叫做Page Structure Cache[<a href="https://zhuanlan.zhihu.com/p/526684107?utm_medium=social&utm_oi=1266367922814697472&utm_psn=1598272295323197440&utm_source=qq#ref_9">9]</a>。</p>
<p>而当TLB和MMU中都没有该物理页，就会发生缺页异常。但是<strong>操作系统仅会对页表更新</strong>，而不会被TLB更新。故而，TBL中数据可能陈旧，需要手动flush。</p>
<h2 id="Physical-memory-allocation"><a href="#Physical-memory-allocation" class="headerlink" title="Physical memory allocation"></a>Physical memory allocation</h2><p>在内核运行的时候，需要申请很多空间用来存放各种数据。</p>
<blockquote>
<p>The kernel must allocate and free physical memory at run-time for page tables, user memory, kernel stacks, and pipe buffers.</p>
</blockquote>
<p>用的是这段空闲内存：</p>
<p><img src="/2023/01/10/xv6/image-20230109225700837.png" alt="image-20230109225700837"></p>
<blockquote>
<p> It keeps track of which pages are free by threading a <strong>linked list</strong> through the pages themselves.</p>
</blockquote>
<p>kalloc.c中就是这么实现的。</p>
<h2 id="Code-Physical-memory-allocator"><a href="#Code-Physical-memory-allocator" class="headerlink" title="Code: Physical memory allocator"></a>Code: Physical memory allocator</h2><p>内核运行时申请释放空闲物理空间是通过<code>kernel/kalloc.c</code>完成的。它为内核栈、用户进程、页表和管道buffer服务。</p>
<blockquote>
<p>kalloc.c用来在运行时申请分配新的一页，上面的vm.c正是用了kalloc申请一页，要么作为页表，要么作为存储数据的第三级页表指向的物理内存。</p>
</blockquote>
<p>最后应该会在空闲内存内形成这样的结构：</p>
<p>内存分成一页一页的，每页内存中的前几个字节存储着其对应队列中下一块内存的物理地址。不一定是从小地址到大地址顺序连接。</p>
<blockquote>
<p>It store each free page’s run structure in the free page itself, since there’s nothing else stored there. </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Physical memory allocator, for user processes,</span></span><br><span class="line"><span class="comment">// kernel stacks, page-table pages,</span></span><br><span class="line"><span class="comment">// and pipe buffers. Allocates whole 4096-byte pages.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放在这范围内的物理内存空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也就是上面说的free memory的起始位置</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[]; <span class="comment">// first address after kernel.</span></span><br><span class="line">                   <span class="comment">// defined by kernel.ld.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// run代表的是一页内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表了整个内核空闲的物理空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="comment">// init的时候先清空空闲空间，建立空闲页队列</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="comment">// PGROUNDUP和PGROUNDDOWN是用于将地址四舍五入到PGSIZE</span></span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// pa得是整数页，并且得在内核物理内存范围之间</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 之后将在pa对应的那一页的前几个字节写入next字段</span></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这意思就是在空闲内存的链表队列中新增一块</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Process-address-space"><a href="#Process-address-space" class="headerlink" title="Process address space"></a>Process address space</h2><p>当用户进程叫xv6分配内存时，xv6会用kalloc去取，然后登记在页表上。</p>
<blockquote>
<p>The stack is a single page, and is shown with the initial contents as created by exec. Strings containing the command-line arguments, as well as an array of pointers to them, are at the very top of the stack. Just under that are values that allow a program to start at main as if the function main(argc, argv) had just been called.</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230109234930690.png" alt="image-20230109234930690"></p>
<h2 id="Code-sbrk"><a href="#Code-sbrk" class="headerlink" title="Code: sbrk"></a>Code: sbrk</h2><blockquote>
<p>Sbrk is the <strong>system call</strong> for a process to <strong>shrink or grow</strong> its memory. The system call is implemented by the function growproc (kernel/proc.c:239).</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.注意单位是bytes，grow n+，shrink n-</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// 主要逻辑还是通过vm.c实现</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sz;<span class="comment">//size</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n, PTE_W)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate PTEs and physical memory to grow process from oldsz to</span></span><br><span class="line"><span class="comment">// newsz, which need not be page aligned.不需要页对齐  Returns new size or 0 on error.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// oldsz向上取整</span></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="comment">// 每页alloc</span></span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 说明失败，恢复到原状</span></span><br><span class="line">      <span class="comment">// 这里不用像下面一样kfree是因为这里压根没有alloc成功</span></span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除去junk data</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 放入页表</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 不成功</span></span><br><span class="line">      <span class="comment">// dealloc原理是顺着页表一个个free的。由于mem此处没有成功放入页表，所以就得单独free掉</span></span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-exec"><a href="#Code-exec" class="headerlink" title="Code:exec"></a>Code:exec</h2><blockquote>
<p>Exec is the system call that creates the user part of an address space. It initializes the user part of an address space from a fifile stored in the fifile system.</p>
<p><code>exec</code>是创建地址空间的用户部分的系统调用。它使用一个存储在文件系统中的文件初始化地址空间的用户部分。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s, *last;</span><br><span class="line">  <span class="type">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//开始打开文件的意思吧（</span></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//ip是一个inode</span></span><br><span class="line">  <span class="comment">//打开路径为path的文件</span></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暂时锁住文件，别人不许动</span></span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//之后应该就是把文件读入内存吧</span></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//分配新页表</span></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//elfhd应该指的是可执行文件头</span></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//总之顺利读到了</span></span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="comment">//读到了就给它分配新空间并且填入页表</span></span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在这里解锁</span></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读完文件，开始造一个新的用户栈【fork之后用户栈是不会清空的】</span></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Make the first inaccessible as a stack guard.</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack.</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE, PTE_W)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  <span class="comment">// mark a PTE invalid for user access.造guard page</span></span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  <span class="comment">// sp为栈顶</span></span><br><span class="line">  sp = sz;</span><br><span class="line">  <span class="comment">// 应该指的是栈尾</span></span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始往栈中填入执行参数</span></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//argv来自用户空间，所以需要使用copyout</span></span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">//这什么东西</span></span><br><span class="line">    <span class="comment">//exec一次将参数中的一个字符串复制到栈顶，并在ustack中记录指向它们的指针</span></span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//放置空指针</span></span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="type">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//只有成功了才会来到这，才会覆盖掉旧的内存镜像</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="comment">//释放新镜像，不改变旧镜像</span></span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><p><img src="/2023/01/10/xv6/image-20230110010651653.png" alt="image-20230110010651653"></p>
<p>xv6内核缺少一个类似<code>malloc</code>可以为小对象提供内存的分配器，这使得内核无法使用需要动态分配的复杂数据结构。【确实，感觉一分配就是一页（】</p>
<p>内存分配是一个长期的热门话题，基本问题是有效使用有限的内存并为将来的未知请求做好准备。今天，人们更关心速度而不是空间效率。此外，一个更复杂的内核可能会分配许多不同大小的小块，而不是（如xv6中）只有4096字节的块；一个真正的内核分配器需要处理小分配和大分配。</p>
<h2 id="Lab：Pagetable"><a href="#Lab：Pagetable" class="headerlink" title="Lab：Pagetable"></a>Lab：Pagetable</h2><blockquote>
<p>In this lab you will explore page tables and modify them to to speed up certain system calls and to detect which pages have been accessed.</p>
</blockquote>
<p>不过遗憾的是usertests还有好几个没通过，具体都标注了。</p>
<h3 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h3><blockquote>
<p>When each process is created, map one read-only page at USYSCALL (a VA defined in <code>memlayout.h</code>). At the start of this page, store a <code>struct usyscall</code> (also defined in <code>memlayout.h</code>), and initialize it to store the PID of the current process. For this lab, <code>ugetpid()</code> has been provided on the userspace side and will automatically use the USYSCALL mapping. You will receive full credit for this part of the lab if the <code>ugetpid</code> test case passes when running <code>pgtbltest</code>.</p>
<p>参考文章：<a href="https://zhuanlan.zhihu.com/p/429304672">MIT 6.S081 2021: Lab page tables</a></p>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><h5 id="乌龙"><a href="#乌龙" class="headerlink" title="乌龙"></a>乌龙</h5><p>这里好像是因为实验改版了，我下的是2020年的实验包，在memlayout压根找不到USYSCALL和struct usyscall这俩东西。最后翻了下网上的总算找到了。</p>
<p>我一开始没找到，还以为USYSCALL以及usyscall这两个都得自己写在memlayout里面，想了很久都没想出来USYSCALL的值应该设置为多少。我认为只需满足两个条件即可：1.所处内存段应该是free memory那段，也即自kernel结束（PHYSTOP）到MAXVA这一大块。2.得确保能被用户和内核都能访问到。</p>
<p>前者意为虚拟地址在MAXVA和PHYSTOP之间，后者意为那段内存应该标记为PTE_U。这个范围是很宽泛的，我实在不知道要分配这期间的哪块内存，感觉也不大可能是真的自由度那么大。所以我就偷偷看了hints【悲】，想看它对这个USYSCALL应该写什么值有没有建议。结果发现这东西是实验给我们定的。遂去网上找到了它给的真正的USYSCALL值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户的ugetpid只找到了一个截图：</p>
<p><img src="/2023/01/10/xv6/v2-0c2603da4c8102e46ae390a0d0b1191d_1440w.jpg" alt="v2-0c2603da4c8102e46ae390a0d0b1191d_1440w"></p>
<p>恕我愚钝实在不知道该把这段代码放在哪orz于是接下来写的东西就没有自测。</p>
<h5 id="panic-freewalk-leaf"><a href="#panic-freewalk-leaf" class="headerlink" title="panic:freewalk leaf"></a>panic:freewalk leaf</h5><p>一开始写好代码准备启动xv6的时候爆出了这么一个panic，搜了一下得到如下解答：</p>
<blockquote>
<p>来源：<a href="http://t.zoukankan.com/YuanZiming-p-14270600.html">MIT-6.S081-2020实验（xv6-riscv64）十：mmap</a></p>
<p>这时运行会发现freewalk函数panic：<code>freewalk: leaf</code>，这是因为freewalk希望所有虚拟地址已经被解绑并释放对应的物理空间了，该函数只负责释放页表。</p>
</blockquote>
<p>让我得知freewalk在vm.c下面【吐槽，我一开始还以为是自由自在地走（，看到这个才反应过来是free walk，跟页表有关的】。结合freewalk的代码</p>
<p><img src="/2023/01/10/xv6/image-20230110225359361.png" alt="image-20230110225359361"></p>
<p>可以知道，造成这个panic的原因是需要手动释放页表项。而在这里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c  freeproc()</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>仅仅是释放掉了对应的物理页，<strong>页表项并没有被释放</strong>。</p>
<p>对比了一下别人写的，才发现原来这里也需要修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//添加此句</span></span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，问题就解决了。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>因而，可以看到，如果进程想使用页的话，需要经历以下四步：</p>
<ol>
<li>通过kalloc获取物理页地址（可以通过该地址对页进行读写），并且记录在进程proc结构中（否则之后就获取不了了）</li>
<li>建立mappages映射</li>
<li>释放物理页</li>
<li>释放PTE映射</li>
</ol>
<p>可见12和34都是分别一一对应的。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//有线程池那味了</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Allocate a usyscall page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在USYSCALL写入usyscall结构体</span></span><br><span class="line">  p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a user page table for a given process,</span></span><br><span class="line"><span class="comment">// with no user memory, but with trampoline pages.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 映射USYSCALL</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;usyscall), PTE_R|PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><blockquote>
<p>Which other xv6 system call(s) could be made faster using this shared page? Explain how.</p>
</blockquote>
<p>我觉得如果能在fork的父子进程用shared page共享页表应该会节省很多时间和空间，用个读时写。其他的倒是想不到了。不过这题会不会问的是那些在内核态和用户态穿梭频繁的system call呢？这个的话我就想不出来了。</p>
<h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><blockquote>
<p>write a function that prints the contents of a page table.</p>
<p>Define a function called <code>vmprint()</code>. </p>
<p>It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. </p>
<p>Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process’s page table. </p>
<p><img src="/2023/01/10/xv6/image-20230110231020570.png" alt="image-20230110231020570"></p>
<p>The first line displays the argument to <code>vmprint</code>. After that there is a <strong>line for each PTE</strong>, including PTEs that refer to page-table pages deeper in the tree. Each PTE line is indented by a number of <code>&quot; ..&quot;</code> that indicates its depth in the tree. </p>
<p>Each PTE line shows the PTE <strong>index</strong> in its page-table page, the <strong>pte bits</strong>, and the <strong>physical address extracted from the PTE</strong>. <u>Don’t print PTEs that are not valid</u>. </p>
<p>In the above example, the top-level page-table page has mappings for entries 0 and 255. The next level down for entry 0 has only index 0 mapped, and the bottom-level for that index 0 has entries 0, 1, and 2 mapped.</p>
</blockquote>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><p><img src="/2023/01/10/xv6/image-20230111000329475.png" alt="image-20230111000329475"></p>
<p>很可惜，我在上面检索<code>freewalk leaf</code>到底是什么东西的时候，不小心看到了这题需要去参照freewalk这个提示【悲】其实我觉得这点还是需要绕点弯才能想到的，可能直接想到有点难【谁知道呢，世界线已经变动了】。</p>
<p>它这个打印页表其实最主要是考查如何遍历页表，这让人想起了walk这样的东西。但是walk是根据虚拟地址一级级找PTE的，中间很多地方会被跳过。有没有一个过程会在做事的时候遍历整个页表呢？答案是，这个过程就是释放页表的过程。释放页表才会一个个地看是否需要释放。释放页表的函数是freewalk，因而这道题参考freewalk的代码即可。</p>
<p>我觉得从“遍历页表”联想到“释放页表”这点是很巧的。不过也不会很突兀，毕竟学数据结构时就知道释放就需要遍历，逆向思维有点难但问题不大。</p>
<p>其他的就都挺简单的，不多赘述。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>记得在defs.h中添加声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在vm.c下</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint_helper</span><span class="params">(<span class="type">pagetable_t</span> pagetable,<span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;level;j++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>,i,(uint64)pte,(uint64)(PTE2PA(pte)));</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        vmprint_helper((<span class="type">pagetable_t</span>)child,level+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印页表</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// typedef uint64 *pagetable_t;所以pagetable可以以%p形式打印</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>,(uint64)pagetable);</span><br><span class="line">  vmprint_helper(pagetable,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问答题-1"><a href="#问答题-1" class="headerlink" title="问答题"></a>问答题</h4><blockquote>
<p>Explain the output of <code>vmprint</code> in terms of Fig 3-4 from the text. </p>
<p>What does page 0 contain? </p>
<p>What is in page 2? When running in user mode, could the process read/write the memory mapped by page 1? </p>
<p>What does the third to last page contain?</p>
</blockquote>
<p>从上面操作系统的启动来看，进程1应该是在main.c中的userinit()中创建的进程，也是shell的父进程。【确实，经实践可得shell的pid为2】</p>
<p>可以来看一下userint的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请一页，将initcode的指令和数据放进去</span></span><br><span class="line">  <span class="comment">// allocate one user page and copy initcode&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  uvminit的注释：</span></span><br><span class="line"><span class="comment">  	// Load the user initcode into address 0 of pagetable,</span></span><br><span class="line"><span class="comment">	// for the very first process.</span></span><br><span class="line"><span class="comment">	// sz must be less than a page.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为内核态到用户态的转变做准备</span></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Trap Frame是指中断、自陷、异常进入内核后,在堆栈上形成的一种数据结构</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改进程名</span></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个也许是为了能被优先调度</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，page0是initcode的代码和数据，page1和page2用作了进程的栈，其中page1应该是guard page，page2是stack。</p>
<p><strong>不过这里从exec的角度解释其实更通用</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//分配新页表</span></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//elfhd应该指的是可执行文件头</span></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="comment">//总之顺利读到了</span></span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="comment">//读到了就给它分配新空间并且填入页表</span></span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读完文件，开始造一个新的用户栈【fork之后用户栈是不会清空的】</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE, PTE_W)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  <span class="comment">// mark a PTE invalid for user access.造guard page</span></span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  <span class="comment">// sp为栈顶</span></span><br><span class="line">  sp = sz;</span><br><span class="line">  <span class="comment">// 应该指的是栈尾</span></span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page0就填程序。这里重点说明一下为什么page1和page2分别是guard page和stack。</p>
<p>按照它的那个算术关系，stack和guard page的虚拟内存位置关系应该是这样的：</p>
<p><img src="/2023/01/10/xv6/image-20230111004330079.png" alt="image-20230111004330079"></p>
<p>那为什么最后在页表中，变成了page1是gurad page，page2是stack这样上下颠倒了呢？看vm.c中的uvmalloc就能明白。</p>
<p><img src="/2023/01/10/xv6/image-20230111004500827.png" alt="image-20230111004500827"></p>
<p>在253行设置了新映射。可以看到，这里设置映射的顺序是sz-&gt;sz+PGSIZE，也即先设置guard page的映射，再设置stack的映射。所以，这两位才会上下颠倒了。</p>
<h3 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h3><blockquote>
<p>Some garbage collectors (a form of automatic memory management) can benefit from information about <strong>which pages have been accessed (read or write)</strong>. In this part of the lab, you will add a new feature to xv6 that detects and reports this information to userspace by inspecting <strong>the access bits in the RISC-V page table.</strong> The RISC-V hardware page walker marks these bits in the <strong>PTE</strong> whenever it resolves a TLB miss.</p>
</blockquote>
<blockquote>
<p>Your job is to implement <code>pgaccess()</code>, a system call that reports which pages have been accessed. </p>
<p>The system call takes three arguments. First, it takes the <strong>starting virtual address</strong> of the first user page to check. Second, it takes the <strong>number of pages</strong> to check. Finally, it takes a <strong>user address to a buffer to store the results into a bitmask</strong> (a datastructure that uses one bit per page and where the first page corresponds to the least significant bit). </p>
<p>You will receive full credit for this part of the lab if the <code>pgaccess</code> test case passes when running <code>pgtbltest</code>.</p>
</blockquote>
<h4 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h4><p>实验内容：</p>
<p>实现<code>void pgaccess(uint64 sva,int pgnum,int* bitmask);</code>，一个系统调用。在这里面，我们要做的是，访问从<code>sva</code>到<code>sva+pgnum*PGSIZE</code>这一范围内的虚拟地址对应的PTE，然后查看PTE的标记项是否有<code>PTE_A</code>。有的话则在bitmask对应位标记为1.</p>
<p>应该注意的点：</p>
<p>1.需要进行内核态到用户态的参数传递  2.需要进行系统调用的必要步骤  3.PTE_A需要自己定义</p>
<p>以上是初见。做完了发现，确实就是那么简单，我主要时间花费在下的实验版本不对，折腾来折腾去了可能有一个小时，最后还是选择了直接把测试函数搬过来手工调用。已经换到正确的年份版本了【泪目】</p>
<p>有一点我忽视了，看了提示才知道：</p>
<blockquote>
<p>Be sure to clear <code>PTE_A</code> after checking if it is set. Otherwise, it won’t be possible to determine if the page was accessed since the last time <code>pgaccess()</code> was called (i.e., the bit will be set forever).</p>
</blockquote>
<p>也就是说每次检查到一个，就需要手动清除掉PTE_A标记。</p>
<p>还有一点以前一直没注意到的，<strong>头文件的引用需要注意次序</strong>。比如说要是把<code>spinlock.h</code>放在<code>proc.h</code>后面，就会寄得很彻底。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>那些系统调用的登记步骤就先省略了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sva;</span><br><span class="line">  <span class="type">int</span> pgnum;</span><br><span class="line">  uint64 bitmask;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;sva) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;pgnum) &lt; <span class="number">0</span> || argaddr(<span class="number">2</span>, &amp;bitmask) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> pgaccess((<span class="type">void</span>*)sva,pgnum,(<span class="type">void</span>*)bitmask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/pgaccess.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pgaccess</span><span class="params">(<span class="type">void</span>* sva,<span class="type">int</span> pgnum,<span class="type">void</span>* bitmask)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pgnum &gt; <span class="number">32</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pgaccess: range too big.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> kmask = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pgnum;i++)&#123;</span><br><span class="line">        <span class="type">pte_t</span>* pte = walk(p-&gt;pagetable,(uint64)sva+i*PGSIZE,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 映射不存在，或者没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!pte || !(*pte &amp; PTE_A))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        kmask = (kmask | (<span class="number">1</span>&lt;&lt;i));</span><br><span class="line">        *pte = (*pte &amp; (~PTE_A));</span><br><span class="line">    &#125;</span><br><span class="line">    copyout(p-&gt;pagetable,(uint64)bitmask,(<span class="type">char</span>*)(&amp;kmask),<span class="keyword">sizeof</span>(<span class="type">int</span>)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h3><blockquote>
<p>The goal of this section and the next is to allow the kernel to directly dereference user pointers.</p>
</blockquote>
<blockquote>
<p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. </p>
<p>Modify <code>struct proc</code> to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if <code>usertests</code> runs correctly.</p>
</blockquote>
<h4 id="感想-3"><a href="#感想-3" class="headerlink" title="感想"></a>感想</h4><p>这个其实平心而论不难，思路很简单。写着不难是不难，但想明白花费了我很多时间。</p>
<p>它这个要求我们修改kernel，使得每个进程都有一份自己的kernel page。至于要改什么，围绕着proc.c中，参照pagetable的生命周期摁改就行。还有一个地方它也提示了，就是要在swtch之前更换一下satp的值。</p>
<p>接下来，我说说我思考的几个点以及犯错的地方。</p>
<h5 id="为什么要这么干"><a href="#为什么要这么干" class="headerlink" title="为什么要这么干"></a>为什么要这么干</h5><p>看完题目，我的第一印象是，这么干有啥用。。。因为我觉得以前那个所有进程共用内核页表确实很好了，没有必要每个进程配一个后来才发现，这个跟下面那个是连在一起的，目的是<code> allow the kernel to directly dereference user pointers.</code>。所以，我们下面会把用户的pgtbl和这里dump出来的kpgtbl合在一起。</p>
<p>具体来说：</p>
<p>通常，进行地址翻译的时候，计算机硬件（即内存管理单元MMU）都会自动的查找对应的映射进行翻译（需要设置<code>satp</code>寄存器，将需要使用的页表的地址交给该寄存器）。</p>
<p>然而，在xv6内核需要翻译用户的虚拟地址时，<u>因为内核页表不含对应的映射，计算机硬件不能自动帮助完成这件事。因此，我们需要先找到用户程序的页表，仿照硬件翻译的流程，一步一步的找到对应的物理地址，再对其进行访问。</u>【<code>walkaddr</code>】这也就会导致copyin之类需要涉及内核和用户态交互的函数效率低下。</p>
<p>为了解决这个问题，我们尝试<strong>将用户页表也囊括进内核页表映射来</strong>。但是，如果将所有进程的用户页表都合并到同一个内核全局页表是不现实的。因而，我们决定换一个角度，<strong>让每个进程都仅有一张内核态和用户态共用的页表</strong>，每次切换进程时切换页表，这样就构造出了个全局的假象。</p>
<p>这两次实验就是为了实现该任务。在本次实验中，我们首先先实现内核页表的分离。</p>
<h5 id="关于myproc"><a href="#关于myproc" class="headerlink" title="关于myproc()"></a>关于myproc()</h5><p>在allocproc中初始化的时候，我一开始是这么写的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c allocproc()</span></span><br><span class="line">perproc_kvminit();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">perproc_kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(p-&gt;kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  pkvmmap(p-&gt;kpgtbl,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样会死得很惨，爆出如下panic：</p>
<p><img src="/2023/01/10/xv6/image-20230114011100370.png" alt="image-20230114011100370"></p>
<p>通过hints的调试贴士</p>
<blockquote>
<p>A missing page table mapping will likely cause the kernel to encounter a page fault. It will print an error that includes <code>sepc=0x00000000XXXXXXXX</code>. You can find out where the fault occurred by searching for <code>XXXXXXXX</code> in <code>kernel/kernel.asm</code>.</p>
</blockquote>
<p>我发现程序在这里绷掉了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br></pre></td></tr></table></figure>

<p>而且显而易见，是系统启动时崩的。</p>
<p>经过了漫长的思考，我震惊地发现了它为什么崩了（）</p>
<p>首先，这段代码语法上是没有问题的。它固然犯了发布未初始化完成的对象这样的并发错误【我有罪】，也破坏了proc的封装性【proc中的很多私有属性本来应该作用域仅在proc.c中的。此处为了能让vm.c访问到proc中的属性，不得不给vm.c添上了proc.h的头文件】，但是它<u>并不是语法错误</u>，还是能用的。我做了这样的测试样例证明它没有问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">pagetable_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span>&#123;</span></span><br><span class="line">	<span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">processes</span>[<span class="title">MAX</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> proc* <span class="title function_">myproc</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;processes[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminit</span><span class="params">()</span>&#123;</span><br><span class="line">	myproc()-&gt;kpgtbl = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> &amp;processes[<span class="number">0</span>];</span><br><span class="line">	kvminit();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;kpgtbl);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我一路顺着os启动的路径找，也想不出来这能有什么错，因而非常迷茫。</p>
<p>此时我灵光一闪，会不会是myproc()在os刚启动的时候是发挥不了作用的？于是我一路顺着myproc的代码看下去：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，mycpu()获得的cpu的proc是怎么得到的呢？</p>
<p>我搜寻了一下os启动代码，发现了cpu的proc得到的路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//...很多很多init</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调度执行第一个进程</span></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完进程后，就进入scheduler进行进程的调度：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">        <span class="comment">//在这里！！！！</span></span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>因而，c-&gt;proc是在创建进程的第一次调度后初始化的，也即，myproc只有在执行第一次scheduler之后才可以调用。而！！！</p>
<p>当执行调度前的userinit时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br></pre></td></tr></table></figure>

<p>它进行了allocproc。我们亲爱的allocproc接下来就会调用perproc_kvminit，然后perproc_kvminit中调用myproc。此时尚未进行初次调度，因而c-&gt;proc未初始化，myproc返回的是0，也即null。这样一来，<code>myproc()-&gt;kpgtbl</code>就发生了空指针异常，也即scause = 15——写入页错误。</p>
<p>因而，对于myproc()的调用需要慎之又慎。</p>
<h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><p>系统调用时，是如何知道要用的是p中的内核页表而非global内核页表呢？</p>
<p>依然还是从os的启动说起。</p>
<p>在main.c中，kvminithart开启了页表，此时的页表为全局的内核页表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当userinit被调度时，全局的内核页表被换成了proc中的内核页表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c scheduler()</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpgtbl));</span><br><span class="line">sfence_vma();</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br></pre></td></tr></table></figure>

<p>但是这样还没有结束。因为我们除了得更换目前的页表，还得更换trapframe中的内核页表相关的东西：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为啥还要更换trapframe中的呢？因为以后系统调用的时候，uservec是从这里读取值来作为内核栈和内核页表的来源的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># in uservec</span><br><span class="line">		# restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        # 完成了内核栈的切换</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">		# 完成了页表的切换</span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br></pre></td></tr></table></figure>

<p>所以，为了以后系统调用能顺利自发进行，我们需要把栈帧也一起换掉。怎么换呢？我们是否还要在一些地方人工把trapframe的值设置为我们自己的内核栈内核页表？答案是，不用！这些会由其他代码自动完成。</p>
<p>前面说到userinit的进程p被调度，<strong>satp换成了我们自己的内核页表</strong>。那么，在之后的内核态，satp都将保持我们自己的内核页表。当要返回用户态时，会执行如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in usertrapret</span></span><br><span class="line">  <span class="comment">// 重置trapframe</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br></pre></td></tr></table></figure>

<p>satp内的值为我们自己的内核页表，而非全局页表。因而这样栈帧中的页表就会被自然而然地写入为进程的内核页表。之后返回用户态，以及之后之后的各种中断，就都会一直使用自己的内核页表了。【试了一下，这里如果改成非即时从satp读，而是默认的kernel_pagetable的话，会一直死循环】</p>
<p>不得不说，真是设计精妙啊！！！不过我觉得，要是这里写成kernel_pagetable，然后让我们自己改的话将是薄纱（。当然它应该也不会这么做，因为，kernel_pagetable事实上是不对外发布的。它这里这么写热读，最直接的原因还是因为读不到kernel_pagetable。这算是无心插柳柳成荫吗233</p>
<h5 id="释放页表但不释放物理内存"><a href="#释放页表但不释放物理内存" class="headerlink" title="释放页表但不释放物理内存"></a>释放页表但不释放物理内存</h5><p>其实答案就在它给的<code>proc_freepagetable</code>里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uvmfree</code>遍历页表，对每个存在的页表项，都试图找到其物理内存，并且释放物理内存和表项。如果页表项存在，但页表项对应的物理内存不存在，就会抛出<code>freewalk leaf</code>的异常。</p>
<p><code>uvmunmap</code>会释放掉参数给的va的页表项，最后一个参数表示释放or不释放。</p>
<p>在这里，使用这两个的组合技，就可以达到不释放<code>TRAMPOLINE</code>和<code>TRAPFRAME</code>的物理内存，又不会让uvmfree出错的效果。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化kpgtbl。由于现在内核栈存在各自的内核页表而非global内核页表中，所以在procinit中的对内核栈的初始化也得放在这：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c allocproc()</span></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p-&gt;kpgtbl = perproc_kvminit();</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">  uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">  pkvmmap(p-&gt;kpgtbl,va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">perproc_kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pt = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(pt, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  pkvmmap(pt,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  pkvmmap(pt,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  pkvmmap(pt,CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  pkvmmap(pt,PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  pkvmmap(pt,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  pkvmmap(pt,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  pkvmmap(pt,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pkvmmap</span><span class="params">(<span class="type">pagetable_t</span> pgtbl,uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当第一个进程开始时，mycpu-&gt;proc = null,所以这里不能调用myproc</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="swtch时切换页表"><a href="#swtch时切换页表" class="headerlink" title="swtch时切换页表"></a>swtch时切换页表</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c scheduler()</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpgtbl));</span><br><span class="line">sfence_vma();</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有进程运行时使用全局kernel_pagetable</span></span><br><span class="line">      kvminithart();</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改kvmpa"><a href="#修改kvmpa" class="headerlink" title="修改kvmpa"></a>修改kvmpa</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">kvmpa</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  pte = walk(myproc()-&gt;kpgtbl, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel.proc.c freeproc()</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpgtbl)</span><br><span class="line">    proc_freekpgtbl(p-&gt;kpgtbl,p-&gt;kstack);</span><br><span class="line">  p-&gt;kpgtbl = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> etext[];  <span class="comment">// kernel.ld sets this to end of kernel code.</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freekpgtbl</span><span class="params">(<span class="type">pagetable_t</span> pagetable,uint64 <span class="built_in">stack</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, UART0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, VIRTIO0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, CLINT, <span class="number">0x10000</span>/(uint64)PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, PLIC, <span class="number">0X400000</span>/(uint64)PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, KERNBASE, (uint64)((uint64)etext-KERNBASE)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, (uint64)etext,(PHYSTOP-(uint64)etext)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span></span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, <span class="built_in">stack</span>, <span class="number">1</span>,<span class="number">1</span> );</span><br><span class="line">  uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin/copyinstr</code></h3><blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/qq_41822154/article/details/124898399">6.S081学习记录-lab3</a></p>
</blockquote>
<blockquote>
<p>The kernel’s <code>copyin</code> function reads memory pointed to by user pointers. It does this by translating them to physical addresses, which the kernel can directly dereference. It performs this translation by walking the process page-table in software. Your job in this part of the lab is to add user mappings to each process’s kernel page table (created in the previous section) that allow <code>copyin</code> (and the related string function <code>copyinstr</code>) to directly dereference user pointers.</p>
</blockquote>
<blockquote>
<p>Replace the body of <code>copyin</code> in <code>kernel/vm.c</code> with a call to <code>copyin_new</code> (defined in <code>kernel/vmcopyin.c</code>); do the same for <code>copyinstr</code> and <code>copyinstr_new</code>. Add mappings for user addresses to each process’s kernel page table so that <code>copyin_new</code> and <code>copyinstr_new</code> work.</p>
</blockquote>
<h4 id="感想-4"><a href="#感想-4" class="headerlink" title="感想"></a>感想</h4><p>这题很直观的思路是，在每个user pagetable添加映射的地方也添加kpgtbl的映射。但问题是，“每个user pagetable添加映射的地方”都是哪？</p>
<h5 id="误入幻想"><a href="#误入幻想" class="headerlink" title="误入幻想"></a>误入幻想</h5><p>我一开始想着偷偷懒，直接在proc.c和vm.c中每个操纵pagetable的地方都加上对kpgtbl的操纵。但很快我就给搞晕了。这时候，我心中萌生一计【PS：下面说的最后都没成功】：我直接快进到把proc结构中的pagetable属性给删了，然后每个出现p-&gt;pagetable的地方，都用p-&gt;kpgtbl代替，直接让两表合为一表，然后之后make的时候哪里报错改哪里，这不就一劳永逸地把所有出现pagetable的地方都改为kpgtbl了嘛。我振奋地去试了一下，将所有地方出现的pagetable都替换成了kpgtbl，把proc.c中的<code>proc_pagetable()</code>和<code>proc_freepagetable()</code>的出现的地方都换成了<code>perproc_kvminit()</code>以及<code>proc_freekpgtbl()</code>，还做了一个小细节，就是在userinit中调用的uvminit中，我把这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvminit</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uchar *src, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sz &gt;= PGSIZE)</span><br><span class="line">    panic(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">  mem = kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  mappages(pagetable, <span class="number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);</span><br><span class="line">  memmove(mem, src, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>换成了这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvminit</span><span class="params">(<span class="keyword">struct</span> proc* p, uchar *src, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sz &gt;= PGSIZE)</span><br><span class="line">    panic(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">  mem = kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  mappages(p-&gt;kpgtbl, <span class="number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);</span><br><span class="line">  memmove(mem, src, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在启动的时候，卡在了初次调度切换不到initcode这边，没有调用exec。没有panic，似乎只在死循环。我也实在想不出是什么原因，最后把代码删了【悲】想想我应该用git保存一下改前改后的。这下实在是难受了，我的想法也暂时没有机会实践了。等到明年大三说不定还得再交一次这玩意，到时候再探究探究吧hhh</p>
<h5 id="走上正途"><a href="#走上正途" class="headerlink" title="走上正途"></a>走上正途</h5><p>发现这个最后没成还改了半天的我最后非常沮丧地去看了hints【又一心浮气躁耐心不足的表现，但确实绷不住了】，发现它居然说只用修改三个地方：fork、exec以及sbrk。</p>
<p>我把kernel/下的每个文件都搜了一遍，发现确实，只有这三个，以及proc.c，vm.c，涉及到对页表项的增删。而在用户态中，想要对进程的内存进行管理，似乎只能通过系统调用sbrk。而proc.c和vm.c中确实没什么好改的。因为里面增加的映射，都是trapframe、trampoline、inicode这种不会一般在copyin中用到的虚拟地址。所以，要改的地方，确确实实，<u>只有fork、exec以及sbrk</u>。</p>
<blockquote>
<p> Xv6 applications ask the kernel for heap memory using the sbrk() system call. </p>
</blockquote>
<p>很悲伤，我的初见思路是错误的（）</p>
<p>而这三个地方的共同点，就是都会对页表进行大量的copy。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in proc.c fork()</span></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in exec.c</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in syscall.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//in proc.c growproc()</span></span><br><span class="line">uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>所以，我们要做的事情很简单：写一个坐收渔翁之利的函数，内容为把一个页表的所有内容复制到另一个页表。然后再在这几个地方调用这个函数即可。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><blockquote>
<p>注意：由于我写得实在是太烦了，已经思考不下去了。为了<strong>放过我自己</strong>，我写了个虽然能过得去测试但是其实毛病重重的代码。垃圾点为以下几点：</p>
<ol>
<li><p>需要去掉freewalk中的panic</p>
<p>我的kvmcopy的实现是，user pagetable（下面简称up）和tp的相同虚拟地址共用同一页物理内存。也就是说，页表不一样，但所指向的物理内存是同一个。这样设计的目的是为了能够让tp及时用到up的更新后的数据。</p>
<p>这会导致啥呢？在进程释放时，需要一起调用<code>proc_freepagetable</code>和<code>proc_freekpgtbl</code>。<code>proc_freepagetable</code>调用完后，所指向的那堆物理内存已经寄完了，如果再调用<code>proc_freekpgtbl</code>，显然，就会发生页表未释放但页表对应内存已经释放的问题，freewalk就会panic。因此，我简单粗暴地直接把freewalk的panic删掉了【抖】也许有别的解决方法，但我真是烦得不想想了放过我吧（</p>
</li>
<li><p>好像暂时没有第二点了（）</p>
</li>
</ol>
</blockquote>
<h5 id="渔翁之利函数"><a href="#渔翁之利函数" class="headerlink" title="渔翁之利函数"></a>渔翁之利函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="comment">// 效仿的是vm.c中的uvmcopy</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kvmcopy</span><span class="params">(<span class="type">pagetable_t</span> up, <span class="type">pagetable_t</span> kp, uint64 sz)</span></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123; </span><br><span class="line">    <span class="keyword">if</span>((pte = walk(up, i, <span class="number">0</span>)) == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(walk(kp,i,<span class="number">0</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果up不存在此项，kp存在，就直接删了</span></span><br><span class="line">            uvmunmap(kp,i,PGSIZE,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// 注意去除PTE_U，否则内核态无法访问</span></span><br><span class="line">    flags = (flags &amp; (~PTE_U));</span><br><span class="line">    <span class="keyword">if</span>(mappages(kp, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(kp, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改fork、exec、sbrk"><a href="#修改fork、exec、sbrk" class="headerlink" title="修改fork、exec、sbrk"></a>修改fork、exec、sbrk</h5><h6 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c fork()</span></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(kvmcopy(np-&gt;pagetable, np-&gt;kpgtbl, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h6 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in exec.c</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line"></span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添上此句</span></span><br><span class="line">  kvmcopy(p-&gt;pagetable, p-&gt;kpgtbl, p-&gt;sz);</span><br></pre></td></tr></table></figure>

<h6 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a>sbrk</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(addr+n &gt;= PLIC)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c</span></span><br><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="comment">// 加这个</span></span><br><span class="line">  kvmcopy(p-&gt;pagetable, p-&gt;kpgtbl, p-&gt;sz);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="userinit"><a href="#userinit" class="headerlink" title="userinit"></a>userinit</h5><blockquote>
<p>这一步不能忽视，因为内核启动的时候就需要用到copyinstr。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c userinit()</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  <span class="comment">// 加这个！</span></span><br><span class="line">  kvmcopy(p-&gt;pagetable, p-&gt;kpgtbl, p-&gt;sz);</span><br></pre></td></tr></table></figure>

<h5 id="删掉freewalk的panic（我特有的缺点）"><a href="#删掉freewalk的panic（我特有的缺点）" class="headerlink" title="删掉freewalk的panic（我特有的缺点）"></a>删掉freewalk的panic（我特有的缺点）</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c freewalk()    </span></span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="comment">//panic(&quot;freewalk: leaf&quot;);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Web Server</title>
    <url>/2024/03/23/webserver/</url>
    <content><![CDATA[<h1 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h1><blockquote>
<p>项目链接：<a href="https://github.com/linyacool/WebServer">WebServer by linyacool</a></p>
<p>个人代码注释：<a href="https://github.com/xiunianjun/WebServer">WebServer</a></p>
<p>使用方法：</p>
<p>开启两个shell，其中一个作为server端，另外一个作为client端。server端可以监听端口等待连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build/Debug/WebServer/WebServer -t 2 -p 60000</span><br><span class="line">./WebServer [-t thread_numbers] [-p port] [-l log_file_path(should begin with <span class="string">&#x27;/&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<p>client端可以发送各种请求，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1234&quot;</span> | telnet localhost 60000</span><br><span class="line">curl http://localhost:60000</span><br></pre></td></tr></table></figure>

</blockquote>
<p>感觉最主要的收获还是了解到了epoll机制，以及对网络了解更深刻了一点。</p>
<h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p>整体采用Reactor模型事件驱动实现，使用线程池提高并发度，同时使用epoll实现IO多路复用。</p>
<p><img src="/2024/03/23/webserver/image-20240323150800250.png" alt="image-20240323150800250"></p>
<p>具体来说，web server分为两类线程，一类为listen thread（Main Reactor），一类为worker thread（Sub Reactor）。listen thread只有一个，它负责接收（accept）来自客户端的请求，并且将请求采用Round Robin的方式派发给worker线程进行处理；worker thread以线程池的方式管理，负责解析http请求，进行具体的数据交互。</p>
<ol>
<li><p>这两类线程的内在实现原理是一致的，都是采用了<strong>epoll机制</strong>来实现IO多路复用，实现与底层os的交互。</p>
<p>具体来说，它们的<strong>线程体</strong>都被抽象为一个<code>EventLoop</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;SP_Channel&gt; ret;</span><br><span class="line">  <span class="keyword">while</span> (!quit_) &#123;</span><br><span class="line">    ret.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 从epoll模型获取关注事件</span></span><br><span class="line">    ret = poller_-&gt;<span class="built_in">poll</span>();</span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : ret) it-&gt;<span class="built_in">handleEvents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于listen thread，它从epoll处获取的事件是new connection，最终会在<code>handleEvents</code>中转向<code>handleNewConn</code>来建立新连接并分发任务给worker thread。</li>
<li>对于worker thread，它从epoll处获取的事件是related data，最终会在<code>handleEvents</code>中转向例如<code>handleRead</code>来获取来自client的数据并进行处理和构建response。</li>
</ul>
</li>
<li><p>这两类线程通过异步的沉睡唤醒机制来实现交互。</p>
<p>通过epoll机制来实现沉睡唤醒。</p>
</li>
</ol>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><p>本webserver类型使用的是reactor模型，它的基本思想：在这个模型中，有一个reactor，它负责的是从操作系统的协议栈接收事件（读取、连接、写入等），并且将事件派发给对应的handler。还有一系列不同类型的handler，它们负责具体处理事件。</p>
<p>Reactor模型的工作方式是通过<strong>事件驱动</strong>的，它不断地监听事件的发生并将其分发给相应的Handler进行处理。这种模型的优势在于它能够以<strong>异步、非阻塞</strong>的方式处理大量的并发连接，提高了服务器的性能和可扩展性。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><blockquote>
<p>部分参考：</p>
<p><a href="https://www.bilibili.com/video/BV1qJ411w7du">IO多路复用select/poll/epoll介绍</a></p>
<p><a href="https://blog.csdn.net/War_wick/article/details/128798745">IO多路复用</a></p>
</blockquote>
<p>epoll模型的应用很广泛，<strong>它的本质其实就是一个阻塞的监听IO数据输入输出的事件机制</strong>。</p>
<h4 id="演化过程"><a href="#演化过程" class="headerlink" title="演化过程"></a>演化过程</h4><p>大概是说，本来是觉得一个请求一个线程：</p>
<blockquote>
<p><strong>accept():</strong></p>
<ul>
<li><strong>作用：</strong> <code>accept()</code> 用于在服务器端接受客户端的连接请求，并创建一个新的套接字用于与客户端通信。</li>
</ul>
<p><strong>recv():</strong></p>
<ul>
<li><strong>作用：</strong> <code>recv()</code> 用于从已连接套接字中接收数据，即从客户端接收数据。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// accept阻塞</span></span><br><span class="line">  client_fd = <span class="built_in">accept</span>(listen_fd)</span><br><span class="line">  <span class="comment">// 开启线程read数据（fd增多导致线程数增多）</span></span><br><span class="line">  <span class="keyword">new</span> Thread <span class="built_in">func</span>() &#123;</span><br><span class="line">    <span class="comment">// recv阻塞（多线程不影响上面的accept）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(fd)) &#123;</span><br><span class="line">      <span class="comment">// logic</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是线程很多很多还得切换开销巨大不适合高并发场景，所以换了一个思路，用单个进程/线程来一次性处理多个请求，也即单个线程开放多个socket端口，同时开始监听，一有连接马上分别处理，这样的事件机制实现就需要内核的帮助：</p>
<p><img src="/2024/03/23/webserver/image-20240322164106938.png" alt="image-20240322164106938"></p>
<p>它最主要就是把fd集合扔进内核态，让内核帮忙判断哪个有数据</p>
<p><img src="/2024/03/23/webserver/image-20240322164956107.png" alt="image-20240322164956107"></p>
<p>poll的话，就再多封装了一步，把原来的rset那个bitmap和fd合并成了一个结构体传进去。当有数据到来，内核就会改变fd.revents位。可以看到，这个就是一个具有雏形的事件机制了。</p>
<p><img src="/2024/03/23/webserver/image-20240322165444656.png" alt="image-20240322165444656"></p>
<p>epoll就直接更彻底了，前面还是在外部填一个数组然后每次都通过系统调用copyin进去，这里是直接在准备阶段就通过系统调用<code>epoll_ctl</code>把数组写入到内核空间并返回一个fd，之后每次<code>epoll_wait</code>就不用再copyin一次了。然后事件通知的话也是通过写入外部的一个events数组实现。</p>
<p>（值得一提的是，这里的epoll fd似乎还是红黑树实现（所以也能避免用户态那么费劲维护这个庞然大物了，很漂亮的封装思想）。这段还是很有文章的，以后感兴趣可以看看）</p>
<p>可以看到，这一步步的核心就是减少运行时拷贝减少切换提高效率……redis、nginx、jave的NIO都是使用epoll实现的。</p>
<h4 id="epoll的使用"><a href="#epoll的使用" class="headerlink" title="epoll的使用"></a>epoll的使用</h4><p>在使用 epoll 模型进行网络通信时，主要分为以下几个阶段：</p>
<ol>
<li><strong>创建 Socket 和 epoll 实例：</strong><ul>
<li>在服务器端，首先创建一个 Socket，并绑定到指定的地址和端口。</li>
<li>创建一个 epoll 实例，用于管理多个文件描述符的事件。</li>
</ul>
</li>
<li><strong>监听套接字的事件：</strong><ul>
<li>使用 epoll_ctl() 将监听套接字添加到 epoll 实例中，并注册关注的事件，一般是 EPOLLIN（可读事件）。</li>
</ul>
</li>
<li><strong>等待事件发生：</strong><ul>
<li>使用 epoll_wait() 函数等待事件发生，该函数将会阻塞直到有事件发生或超时。</li>
</ul>
</li>
<li><strong>处理事件：</strong><ul>
<li>当有事件发生时，epoll_wait() 返回，程序获取到就绪的文件描述符以及对应的事件类型。</li>
<li><u>如果就绪的文件描述符是监听套接字，则表示有新的客户端连接请求到达，此时需要调用 accept() 函数来接受连接，创建新的已连接套接字，并将其添加到 epoll 实例中进行管理。</u></li>
<li><u>如果就绪的文件描述符是已连接套接字，则表示有数据可以读取或写入。此时，可以调用 recv() 函数读取数据，或者调用 send() 函数发送数据。</u></li>
<li>如果需要对套接字进行写操作，还需要将该套接字的事件类型设置为 EPOLLOUT。</li>
</ul>
</li>
<li><strong>循环处理：</strong><ul>
<li>处理完一个事件后，程序会继续等待下一个事件的发生，重复上述过程。</li>
</ul>
</li>
</ol>
<h4 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a>API详解</h4><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><ol>
<li><p><strong>EPOLLIN</strong>：</p>
<ul>
<li>意义：表示套接字上有数据可读。</li>
<li>使用场景：当套接字上有数据可读时，触发 EPOLLIN 事件，可以调用 <code>recv()</code> 等函数来读取数据。</li>
</ul>
</li>
<li><p><strong>EPOLLOUT</strong>：</p>
<ul>
<li>意义：表示套接字上可以写入数据。</li>
<li>使用场景：当套接字上的写缓冲区有空间时，触发 EPOLLOUT 事件，可以调用 <code>send()</code> 等函数向套接字写入数据。</li>
</ul>
</li>
<li><p><strong>EPOLLRDHUP</strong>：</p>
<ul>
<li>意义：表示对端套接字<strong>已关闭连接或者关闭了写端</strong>。</li>
<li>使用场景：当远程端关闭连接或者关闭了写端时，触发 EPOLLRDHUP 事件。通常用于检测对端连接的关闭。</li>
</ul>
</li>
<li><p><strong>EPOLLHUP</strong>：</p>
<ul>
<li>意义：表示套接字出现<strong>挂起</strong>情况。</li>
<li>使用场景：当套接字上出现挂起情况时，例如<strong>对端异常关闭连接</strong>时，触发 EPOLLHUP 事件。</li>
</ul>
</li>
<li><p><strong>EPOLLERR</strong>：</p>
<ul>
<li>意义：表示套接字发生错误。</li>
<li>使用场景：当套接字发生错误时，例如<strong>连接被重置或者发生其他错误</strong>时，触发 EPOLLERR 事件。</li>
</ul>
</li>
<li><p><strong>EPOLLPRI</strong>：</p>
<ul>
<li><p>意义：表示套接字上有紧急数据可读。</p>
</li>
<li><p>使用场景：当套接字上有紧急数据需要处理时，触发 EPOLLPRI 事件。紧急数据通常使用带外数据（Out-of-Band）的方式传输。</p>
<p>紧急数据（Out-of-Band data）是一种特殊的数据，它可以被发送到套接字的优先级带外通道（Out-of-Band Channel）中，并且不遵循普通数据的顺序。紧急数据通常用于发送一些需要立即处理的信息，例如紧急控制信息或者重要的命令。</p>
</li>
</ul>
</li>
<li><p><strong>EPOLLONESHOT</strong>：</p>
<ul>
<li>意义<strong>：</strong> 表示一次性触发模式。当某个套接字上的事件被 epoll_wait() 函数触发后，该事件会从 epoll 实例中被删除，需要重新注册才能再次触发。</li>
<li>使用场景： 适用于需要确保每个事件只被一个处理器处理的情况，避免并发处理同一个事件。</li>
</ul>
</li>
<li><p><strong>EPOLLET</strong>:</p>
<ul>
<li>意义<strong>：</strong> 表示边缘触发模式。在边缘触发模式下，只有当套接字上的状态发生变化时才会触发事件，而不是像默认的水平触发模式一样，只要套接字上有数据可读或可写就会触发事件。</li>
<li>使用场景： 适用于需要高效处理大量连接的场景，因为边缘触发模式可以减少不必要的触发次数，提高效率。</li>
</ul>
</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="运行追踪"><a href="#运行追踪" class="headerlink" title="运行追踪"></a>运行追踪</h3><p>感觉分块写有点难以下手，不如来一个我最拿手（？）的运行追踪这个思路来写吧，之后再分门别类细说。</p>
<p>首先，发动此命令启动服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./WebServer</span><br></pre></td></tr></table></figure>

<p>进入到了main函数，经过一系列parse arg的工作之后，来到了这里：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EventLoop mainLoop;</span><br><span class="line"><span class="function">Server <span class="title">myHTTPServer</span><span class="params">(&amp;mainLoop, threadNum, port)</span></span>;</span><br><span class="line">myHTTPServer.<span class="built_in">start</span>();</span><br><span class="line">mainLoop.<span class="built_in">loop</span>();</span><br></pre></td></tr></table></figure>

<p>我们首先观察<code>Server::start</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  eventLoopThreadPool_-&gt;<span class="built_in">start</span>();</span><br><span class="line">  acceptChannel_-&gt;<span class="built_in">setEvents</span>(EPOLLIN | EPOLLET);</span><br><span class="line">  <span class="comment">// 对于监听线程来说，有新的连接来到-&gt;EPOLLIN-&gt;read handler被触发，所以我们将handNewConn绑定到read handler上</span></span><br><span class="line">  acceptChannel_-&gt;<span class="built_in">setReadHandler</span>(<span class="built_in">bind</span>(&amp;Server::handNewConn, <span class="keyword">this</span>));</span><br><span class="line">  acceptChannel_-&gt;<span class="built_in">setConnHandler</span>(<span class="built_in">bind</span>(&amp;Server::handThisConn, <span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 自此以来，main loop就管理accept了</span></span><br><span class="line">  loop_-&gt;<span class="built_in">addToPoller</span>(acceptChannel_, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它其实最主要还是启动了listen thread（为其绑定监听的epoll事件）和worker thread。下面分支解释这两类线程之后的举动。</p>
<h4 id="listen-thread"><a href="#listen-thread" class="headerlink" title="listen thread"></a>listen thread</h4><p><code>Server::start</code>函数返回之后，继续执行main函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mainLoop.<span class="built_in">loop</span>();</span><br></pre></td></tr></table></figure>

<p>启动了listen thread的loop。从此之后，它就一直如此循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;SP_Channel&gt; ret;</span><br><span class="line">  <span class="keyword">while</span> (!quit_) &#123;</span><br><span class="line">    ret.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 从epoll模型获取关注事件</span></span><br><span class="line">    ret = poller_-&gt;<span class="built_in">poll</span>();</span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : ret) it-&gt;<span class="built_in">handleEvents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直到获取到了新的连接，这时候它会在<code>handleEvents</code>中转而通过<code>handlerNewConn</code>进行处理，在其中将请求通过RR方式分发给worker thread，并且注册下一次accept事件（epoll事件默认ONE_SHOT）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handNewConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当监听套接字上触发 EPOLLIN 事件时，表示有新的连接请求到达</span></span><br><span class="line">  <span class="comment">// 在这种情况下，通常应该调用 accept() 函数来接受新的连接</span></span><br><span class="line">  <span class="keyword">while</span> ((accept_fd = <span class="built_in">accept</span>(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr,</span><br><span class="line">                             &amp;client_addr_len)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// RR，获取空闲worker thread</span></span><br><span class="line">    EventLoop *loop = eventLoopThreadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;New connection from &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(client_addr.sin_addr) &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">ntohs</span>(client_addr.sin_port);</span><br><span class="line">    <span class="comment">// 创建httpdata对象，表示请求的具体数据</span></span><br><span class="line">    <span class="function">shared_ptr&lt;HttpData&gt; <span class="title">req_info</span><span class="params">(<span class="keyword">new</span> HttpData(loop, accept_fd))</span></span>;</span><br><span class="line">    <span class="comment">// 唤醒该worker</span></span><br><span class="line">    loop-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;HttpData::newEvent, req_info));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册下一次accept事件</span></span><br><span class="line">  acceptChannel_-&gt;<span class="built_in">setEvents</span>(EPOLLIN | EPOLLET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个epoll事件，监听EPOLLIN，worker thread用于等待数据输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpData::newEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  channel_-&gt;<span class="built_in">setEvents</span>(DEFAULT_EVENT);</span><br><span class="line">  loop_-&gt;<span class="built_in">addToPoller</span>(channel_, DEFAULT_EXPIRED_TIME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="worker-thread"><a href="#worker-thread" class="headerlink" title="worker thread"></a>worker thread</h4><p><code>Server::start</code>函数中会调用<code>eventLoopThreadPool_-&gt;start()</code>启动线程池。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  baseLoop_-&gt;<span class="built_in">assertInLoopThread</span>();	<span class="comment">// base loop 即为 listen loop</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads_; ++i) &#123;</span><br><span class="line">    <span class="comment">// 启动worker thread</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;EventLoopThread&gt; <span class="title">t</span><span class="params">(<span class="keyword">new</span> EventLoopThread())</span></span>;</span><br><span class="line">    threads_.<span class="built_in">push_back</span>(t);</span><br><span class="line">    loops_.<span class="built_in">push_back</span>(t-&gt;<span class="built_in">startLoop</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker thread 的线程体</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  EventLoop loop;	<span class="comment">// 创建一个全新的属于自己的loop！也即，**拥有自己的epoll队列**！！！</span></span><br><span class="line">  loop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后进入到loop循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;SP_Channel&gt; ret;</span><br><span class="line">  <span class="keyword">while</span> (!quit_) &#123;</span><br><span class="line">    ret.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 从epoll模型获取关注事件</span></span><br><span class="line">    ret = poller_-&gt;<span class="built_in">poll</span>();</span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : ret) it-&gt;<span class="built_in">handleEvents</span>();</span><br><span class="line">    <span class="comment">// 执行异步回调函数</span></span><br><span class="line">    <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，此处有一个实现很有意思的沉睡唤醒机制（详情见下个部分）。</p>
<ol>
<li>worker thread在一开始的时候会阻塞在<code>poll</code>函数中，</li>
<li>直到listen thread通过<code>queueInLoop</code>调用wakeup唤醒（也是通过epoll机制），worker thread才会醒来继续执行接下来的代码。</li>
<li>此时，<code>doPendingFunctors</code>会执行listen thread传入的<code>newEvent</code>回调，从而成功完成对数据输入的监听。</li>
<li>此后当数据到达的时候，就会再次从<code>poll</code>苏醒，然后进入真正的<code>handleEvents</code>之中，</li>
<li>等到处理完请求再次陷入沉睡，依次循环。</li>
</ol>
<h3 id="epoll模型"><a href="#epoll模型" class="headerlink" title="epoll模型"></a>epoll模型</h3><h4 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><blockquote>
<p>Channel类：Channel是Reactor结构中的“事件”，它自始至终都属于一个EventLoop，负责一个文件描述符的IO事件，在Channel类中保存这IO事件的类型以及对应的回调函数，当IO事件发生时，最终会调用到Channel类中的回调函数。因此，程序中所有带有读写时间的对象都会和一个Channel关联，包括loop中的eventfd，listenfd，HttpData等。</p>
</blockquote>
<p>Channel 可理解为一个请求的抽象，它包含了<strong>请求数据</strong>以及对应的<strong>handler指针</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; CallBack;</span><br><span class="line">  EventLoop *loop_;</span><br><span class="line">  <span class="type">int</span> fd_;</span><br><span class="line">  <span class="type">__uint32_t</span> events_;</span><br><span class="line">  <span class="type">__uint32_t</span> revents_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">parse_URI</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">parse_Headers</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">analysisRequest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  CallBack readHandler_;</span><br><span class="line">  CallBack writeHandler_;</span><br><span class="line">  CallBack errorHandler_;</span><br><span class="line">  CallBack connHandler_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// 根据revent转向不同的handler</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleWrite</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleError</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> err_num, std::string short_msg)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleConn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="实现沉睡唤醒"><a href="#实现沉睡唤醒" class="headerlink" title="实现沉睡唤醒"></a>实现沉睡唤醒</h4><p>这个确实是很值得学习，非常巧妙地运用了epoll机制。</p>
<p>首先，书接上文，我们可知，这个是worker thread的线程体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// worker thread 的线程体</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  EventLoop loop;	<span class="comment">// 创建一个全新的属于自己的loop！也即，**拥有自己的epoll队列**！！！</span></span><br><span class="line">  loop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以去具体看看<code>Eventloop</code>的结构。可以注意到，eventloop对象是会自带并持续监听一个名为<code>pwakeupChannel_</code>的channel的，<code>wakeupFd_</code>是对应的<strong>eventfd</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EventLoop::<span class="built_in">EventLoop</span>()</span><br><span class="line">    : <span class="built_in">wakeupFd_</span>(<span class="built_in">createEventfd</span>()),</span><br><span class="line">      <span class="built_in">pwakeupChannel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(<span class="keyword">this</span>, wakeupFd_)) &#123;</span><br><span class="line">  pwakeupChannel_-&gt;<span class="built_in">setEvents</span>(EPOLLIN | EPOLLET);</span><br><span class="line">  pwakeupChannel_-&gt;<span class="built_in">setReadHandler</span>(<span class="built_in">bind</span>(&amp;EventLoop::handleRead, <span class="keyword">this</span>));</span><br><span class="line">  pwakeupChannel_-&gt;<span class="built_in">setConnHandler</span>(<span class="built_in">bind</span>(&amp;EventLoop::handleConn, <span class="keyword">this</span>));</span><br><span class="line">  poller_-&gt;<span class="built_in">epoll_add</span>(pwakeupChannel_, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故而，一开始，worker thread会卡在<code>loop()</code>的<code>poll</code>这里动弹不得：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;SP_Channel&gt; ret;</span><br><span class="line">  <span class="keyword">while</span> (!quit_) &#123;</span><br><span class="line">    ret.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 这里</span></span><br><span class="line">    ret = poller_-&gt;<span class="built_in">poll</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : ret) it-&gt;<span class="built_in">handleEvents</span>();</span><br><span class="line">    <span class="comment">// 执行异步回调函数</span></span><br><span class="line">    <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，listen thread会调用<code>loop-&gt;queueInLoop</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call by listen thread</span></span><br><span class="line">loop-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;HttpData::newEvent, req_info));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor&amp;&amp; cb)</span> </span>&#123;</span><br><span class="line">  pendingFunctors_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(cb));	<span class="comment">// add cb to pending functions</span></span><br><span class="line">  <span class="comment">// call by listen thread</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_) <span class="built_in">wakeup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用<code>wakeup</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">writen</span>(wakeupFd_, (<span class="type">char</span>*)(&amp;one), <span class="keyword">sizeof</span> <span class="type">uint64_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，由于有数据向<code>wakeupFd_</code>写入，故而<code>pwakeupChannel_</code>关注的<code>EPOLLIN</code>事件被触发，worker thread从<code>poll</code>中return，进入<code>handleEvents</code>来处理<code>pwakeupChannel_</code>的事件，最终转入<code>handleRead</code>进行处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// block by epoll</span></span><br><span class="line">  <span class="built_in">readn</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> <span class="type">uint64_t</span>);</span><br><span class="line">  <span class="comment">// 注册监听下一次wakeup事件</span></span><br><span class="line">  pwakeupChannel_-&gt;<span class="built_in">setEvents</span>(EPOLLIN | EPOLLET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，worker thread就从epoll的阻塞中被成功唤醒，通过<code>doPendingFunctors</code>执行所有回调函数，也即上文listen thread在调用<code>loop-&gt;queueInLoop</code>时注册的<code>newEvent</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册一个epoll事件，监听EPOLLIN，worker thread用于等待数据输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpData::newEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  channel_-&gt;<span class="built_in">setEvents</span>(DEFAULT_EVENT);</span><br><span class="line">  loop_-&gt;<span class="built_in">addToPoller</span>(channel_, DEFAULT_EXPIRED_TIME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等到之后处理完请求之后，就再一次陷入沉睡等待唤醒，以此类推。</p>
<p>可以看到，这整个流程事实上充分利用了epoll的事件机制。它的大体思路就是，在一个fd上注册一个EPOLLIN事件，worker thread阻塞等待该事件发生，listen thread通过向fd写入数据触发EPOLLIN事件从而唤醒worker thread。这样做的好处是，将沉睡唤醒机制完美兼容到了目前使用epoll实现网络通信的框架中，也即worker thread不仅监听这个沉睡事件，同时还监听请求数据到来事件，从而使得整体代码更加优雅。</p>
<h3 id="连接的维护"><a href="#连接的维护" class="headerlink" title="连接的维护"></a><a href="https://github.com/linyacool/WebServer/blob/master/%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%B4%E6%8A%A4.md">连接的维护</a></h3><h3 id="日志机制"><a href="#日志机制" class="headerlink" title="日志机制"></a><a href="https://github.com/linyacool/WebServer/blob/master/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B.md#log">日志机制</a></h3>]]></content>
      <tags>
        <tag>labs</tag>
      </tags>
  </entry>
  <entry>
    <title>Locking</title>
    <url>/2023/01/10/xv6$chap6/</url>
    <content><![CDATA[<h1 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h1><p>很多概念在看Java并发的时候都学习过，这些重复的地方就不做赘述了。</p>
<h2 id="Code-spinlock"><a href="#Code-spinlock" class="headerlink" title="Code: spinlock"></a>Code: spinlock</h2><blockquote>
<p><a href="https://blog.csdn.net/chenwh_cn/article/details/117227454">spinlock 使用介绍</a></p>
<p>一、spinlock 简介<br>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，不断尝试获取锁，直到获取到锁才会退出循环</p>
<p>二、自旋锁与互斥锁的区别<br>自旋锁与互斥锁类似，它们都是为了解决对某项资源的互斥使用，在任何时刻最多只能有一个线程获得锁<br>对于互斥锁，如果资源已经被占用，调用者将进入睡眠状态<br>对于自旋锁，如果资源已经被占用，调用者就一直循环在那里，看是否自旋锁的保持者已经释放了锁</p>
<p>三、自旋锁的优缺点<br>自旋锁不会发生进程切换，不会使进程进入阻塞状态，减少了不必要的上下文切换，执行速度快。非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换，影响性能<br>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程长时间循环等待消耗CPU，造成CPU使用率极高</p>
</blockquote>
<h3 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>大概是这么个原理：</p>
<p><img src="/2023/01/10/xv6/image-20230115231857670.png" alt="image-20230115231857670"></p>
<p>当然这有竞态条件。xv6用的是CPU提供的amoswap原子指令来消除竞态条件的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/spinlock.c</span></span><br><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 关中断</span></span><br><span class="line">  <span class="comment">// xv6允许禁止中断。但是由于xv6是一个多核系统,单个core被禁止中断并不会影响其他core。</span></span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// holding(): Check whether this cpu is holding the lock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="comment">// amoswap: 交换a5和(s1)的值，返回(s1)原来的值</span></span><br><span class="line">  <span class="comment">// 也即是如图所示的竞态条件的原子指令</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sync-synchronize"><a href="#sync-synchronize" class="headerlink" title="__sync_synchronize();"></a>__sync_synchronize();</h4><p>代码里的官方注释：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line"><span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line"><span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line"><span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br></pre></td></tr></table></figure>

<p>这个注释其实没太看明白。我去翻了一下asm代码，发现这句话正如它最后一句所说的被翻译成fence指令：</p>
<p><img src="/2023/01/10/xv6/image-20230115231457971.png" alt="image-20230115231457971"></p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/139797515">处理器中的存储系统（一）：RISC-V的FENCE、FENCE.I指令</a></p>
<p>顾名思义,FENCE指令犹如一道屏障,把前面的存储操作和后面的存储操作隔离开来,前面的决不能到后面再执行,后面的决不能先于FENCE前的指令执行。</p>
</blockquote>
<p>这个就好明白多了。</p>
<p>这样一来，acquire和release的两个fence就形成了两道屏障：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acquire();</span><br><span class="line">l-&gt;nexy = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">release();</span><br></pre></td></tr></table></figure>

<p>中间那部分的指令可以重排，但是中间的指令就绝不会跑到临界区外。</p>
<h4 id="push-off和pop-off"><a href="#push-off和pop-off" class="headerlink" title="push_off和pop_off"></a>push_off和pop_off</h4><blockquote>
<p>当CPU未持有自旋锁时，xv6重新启用中断；它必须做一些记录来处理嵌套的临界区域。<code>acquire</code>调用<code>push_off</code> (*<strong>kernel/spinlock.c*</strong>:89) 并且<code>release</code>调用<code>pop_off</code> (*<strong>kernel/spinlock.c*</strong>:100)来跟踪当前CPU上锁的嵌套级别。当计数达到零时，<code>pop_off</code>恢复最外层临界区域开始时存在的中断使能状态。<code>intr_off</code>和<code>intr_on</code>函数执行RISC-V指令分别用来禁用和启用中断。</p>
</blockquote>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/spinlock.c</span></span><br><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开中断</span></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Using-locks"><a href="#Code-Using-locks" class="headerlink" title="Code: Using locks"></a>Code: Using locks</h2><blockquote>
<p>作为粗粒度锁的一个例子，xv6的<strong>kalloc.c</strong>有一个由单个锁保护的空闲列表。如果不同CPU上的多个进程试图同时分配页面，每个进程在获得锁之前将必须在<code>acquire</code>中自旋等待。自旋会降低性能，因为它只是无用的等待。如果对锁的争夺浪费了很大一部分CPU时间，也许可以通过改变内存分配的设计来提高性能，使其拥有<strong>多个空闲列表</strong>，每个列表都有自己的锁，以允许真正的并行分配。【很棒的思路】</p>
<p>作为细粒度锁的一个例子，xv6<u>对每个文件都有一个单独的锁</u>，这样操作不同文件的进程通常可以不需等待彼此的锁而继续进行。文件锁的粒度可以进一步细化，以允许进程同时写入同一个文件的不同区域。最终的锁粒度决策需要由性能测试和复杂性考量来驱动。</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>锁</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>bcache.lock</code></td>
<td>保护块缓冲区缓存项（block buffer cache entries）的分配</td>
</tr>
<tr>
<td><code>cons.lock</code></td>
<td>串行化对控制台硬件的访问，避免混合输出</td>
</tr>
<tr>
<td><code>ftable.lock</code></td>
<td>串行化文件表中文件结构体的分配</td>
</tr>
<tr>
<td><code>icache.lock</code></td>
<td>保护索引结点缓存项（inode cache entries）的分配</td>
</tr>
<tr>
<td><code>vdisk_lock</code></td>
<td>串行化对磁盘硬件和DMA描述符队列的访问</td>
</tr>
<tr>
<td><code>kmem.lock</code></td>
<td>串行化内存分配</td>
</tr>
<tr>
<td><code>log.lock</code></td>
<td>串行化事务日志操作</td>
</tr>
<tr>
<td>管道的<code>pi-&gt;lock</code></td>
<td>串行化每个管道的操作</td>
</tr>
<tr>
<td><code>pid_lock</code></td>
<td>串行化next_pid的增量</td>
</tr>
<tr>
<td>进程的<code>p-&gt;lock</code></td>
<td>串行化进程状态的改变</td>
</tr>
<tr>
<td><code>tickslock</code></td>
<td>串行化时钟计数操作</td>
</tr>
<tr>
<td>索引结点的 <code>ip-&gt;lock</code></td>
<td>串行化索引结点及其内容的操作</td>
</tr>
<tr>
<td>缓冲区的<code>b-&gt;lock</code></td>
<td>串行化每个块缓冲区的操作</td>
</tr>
</tbody></table>
<p> Figure 6.3: Locks in xv6</p>
<h2 id="Deadlock-and-lock-ordering"><a href="#Deadlock-and-lock-ordering" class="headerlink" title="Deadlock and lock ordering"></a>Deadlock and lock ordering</h2><blockquote>
<p>如果在内核中执行的代码路径必须同时持有数个锁，那么所有代码路径以相同的顺序获取这些锁是很重要的。如果它们不这样做，就有死锁的风险。假设xv6中的两个代码路径需要锁A和B，但是代码路径1按照先A后B的顺序获取锁，另一个路径按照先B后A的顺序获取锁。为了避免这种死锁，<strong>所有代码路径必须以相同的顺序获取锁</strong>。全局锁获取顺序的需求意味着锁实际上是每个<strong>函数规范</strong>的一部分：调用者必须以一种使锁按照约定顺序被获取的方式调用函数。</p>
<p>由于<code>sleep</code>的工作方式（见第7章），Xv6有许多包含每个进程的锁（每个<code>struct proc</code>中的锁）在内的长度为2的锁顺序链。例如，<code>consoleintr</code> (*<strong>kernel/console.c*</strong>:138)是处理键入字符的中断例程。当换行符到达时，任何等待控制台输入的进程都应该被唤醒。为此，<code>consoleintr</code>在调用<code>wakeup</code>时持有<code>cons.lock</code>，<code>wakeup</code>获取等待进程的锁以唤醒它。因此，全局避免死锁的锁顺序包括必须在任何进程锁之前获取<code>cons.lock</code>的规则。【这段不怎么能看懂，学完第七章再回来看看】</p>
<p>文件系统代码包含xv6最长的锁链。例如，创建一个文件需要同时持有目录上的锁、新文件inode上的锁、磁盘块缓冲区上的锁、磁盘驱动程序的<code>vdisk_lock</code>和调用进程的<code>p-&gt;lock</code>。为了避免死锁，文件系统代码总是按照前一句中提到的顺序获取锁。</p>
</blockquote>
<h2 id="Locks-and-interrupt-handlers"><a href="#Locks-and-interrupt-handlers" class="headerlink" title="Locks and interrupt handlers"></a>Locks and interrupt handlers</h2><blockquote>
<p> Xv6 is more conservative: when a CPU acquires any lock, xv6 always <strong>disables interrupts</strong> on that CPU. Interrupts may still occur on other CPUs, so an interrupt’s acquire can wait for a thread to release a spinlock; just not on the same CPU.看来是通过开关中断来保护临界区的</p>
<p> <code>acquire</code>调用<code>push_off</code> (*<strong>kernel/spinlock.c*</strong>:89) 并且<code>release</code>调用<code>pop_off</code> (*<strong>kernel/spinlock.c*</strong>:100)来跟踪当前CPU上锁的嵌套级别。当计数达到零时，<code>pop_off</code>恢复最外层临界区域开始时存在的中断使能状态。<code>intr_off</code>和<code>intr_on</code>函数执行RISC-V指令分别用来禁用和启用中断。</p>
<p> 严格的在设置<code>lk-&gt;locked</code> (<em>kernel/spinlock.c</em>:28)之前让<code>acquire</code>调用<code>push_off</code>是很重要的。如果两者颠倒，会存在一个既持有锁又启用了中断的短暂窗口期，不幸的话定时器中断会使系统死锁。同样，只有在释放锁之后，<code>release</code>才调用<code>pop_off</code>也是很重要的(*<strong>kernel/spinlock.c*</strong>:66)。</p>
</blockquote>
<h3 id="一个解决了一半的疑问"><a href="#一个解决了一半的疑问" class="headerlink" title="一个解决了一半的疑问"></a>一个解决了一半的疑问</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>Xv6更保守：当CPU获取任何锁时，xv6总是禁用该CPU上的中断。中断仍然可能发生在其他CPU上，此时中断的<code>acquire</code>可以等待线程释放自旋锁；由于不在同一CPU上，不会造成死锁。</p>
<p>进展：似乎书中说到，“sleep atomically yields the CPU and releases the spinlock”。等了解完sleep，也即读完第七章之后再来看看。</p>
</blockquote>
<p>在处理时钟中断的trap.c中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c devintr()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 这里！！</span></span><br><span class="line">    <span class="comment">// in kernel/trap.c devintr()</span></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见只有CPU0才会进入clockintr【因为要求cpuid==0】，锁住ticks引起ticks递增。</p>
<p>而当sys_sleep获得锁之后，其结束循环的条件是ticks - ticks0 &lt; n:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我认为，这会导致死锁情况。假设计算机为多CPU，且从零开始依次递增编号。对该死锁情况的讨论，可以分为以下两类：</p>
<ol>
<li><p>sys_sleep在CPU2（或者其他编号非零的CPU）运行，且先获取了tickslock的锁。这时候，ticks将会停止增长，sys_sleep结束循环的条件将无法结束。</p>
<p>理由：对于CPU0，它可以进入clockintr的代码段，但是由于锁已经被获取，所以就只能一直在那边死锁等待；对于其他CPU来说，压根执行不了那段增加ticks的代码段，所以ticks压根不会增加。这样一来，CPU2进程等待ticks增加，从而获取结束循环的条件；CPU0等待CPU2进程结束，从而使得ticks增加，就造成了死锁。</p>
</li>
<li><p>sys_sleep在CPU0运行，且先获取了tickslock的锁。这时候，ticks将会停止增长，sys_sleep结束循环的条件将无法结束。</p>
<p>理由：由于xv6会在获取锁和释放锁期间关闭中断，因而CPU0无法进行时钟中断而发生进程的切换，只能一直在sys_sleep中等待，所以ticks更不可能增加，造成了死锁。</p>
</li>
</ol>
<p>暂时没有很充分的理由反驳这两点。。。</p>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>学习完下一章的内容后可知，<code>sleep(&amp;ticks, &amp;tickslock);</code>会释放掉tickslock的锁，这样CPU0就可以进入<code>clockintr</code>增加ticks了。</p>
<p>再详细梳理一次，这里的具体机制是这样的：</p>
<p>可以把ticks看做信号量，<code>sys_sleep</code>为消费者，<code>clockintr</code>为生产者。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in sys_sleep()</span></span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  <span class="keyword">while</span>(ticks &lt; 某个数字)&#123;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这是非常典型的生产者消费者模型。生产者每生产一次ticks，就会唤醒消费者，让消费者检查条件。如果条件错误，则继续sleep等待消费者下一次唤醒，如此循环往复。</p>
<p>只不过，还有一个小疑点，就是<code>clockintr</code>这段只有CPU0可以执行这一点是否为真依然存疑。如果确实只有CPU0可以执行的话，假若<code>sys_sleep</code>在CPU0上执行，那么还是依然会造成死锁。所以我猜想是不是CPU0是无法关中断的？也就是说CPU0是一个后盾一般的保护角色？或者是别的CPU也能进入本段代码？如果别的CPU也能进，那是怎么实现的？因为很明显这段代码确实只有CPU0可以进入。</p>
<h2 id="Sleep-locks"><a href="#Sleep-locks" class="headerlink" title="Sleep locks"></a>Sleep locks</h2><p>关于sleep lock的由来和优点，书里描述得很详细，简单来说就是：</p>
<blockquote>
<p>Thus we’d like a type of lock that yields the CPU while waiting to acquire, and allows yields (and interrupts) while the lock is held.</p>
<p>因为等待会浪费CPU时间，所以自旋锁最适合短的临界区域；睡眠锁对于冗长的操作效果很好。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="comment">// 等待</span></span><br><span class="line">  <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">    <span class="comment">// sleep atomically yields the CPU and releases the spinlock</span></span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 占用</span></span><br><span class="line">  lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">  lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 到时候可以留意一下wakeup是会唤醒一个还是多个</span></span><br><span class="line">  wakeup(lk);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点值得注意：</p>
<blockquote>
<p>Because sleep-locks leave interrupts enabled, they cannot be used in interrupt handlers. Because acquiresleep may yield the CPU, sleep-locks cannot be used inside spinlock critical sections (though spinlocks can be used inside sleep-lock critical sections).</p>
</blockquote>
<p>这实际上是因为自旋锁内不能sleep，因而也就不能使用sleep lock。</p>
<p>为什么不能sleep？我猜测应该是因为sleep中会释放自旋锁然后再调度别的进程。此时，临界区就不受保护了很危险，不符合spinlock在临界区结束才能释放的规范。</p>
<p>在查阅别人的说法的时候，我还看到了这个讨论：</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_44175439/article/details/119963732">中断中为什么不能sleep | Linux内核</a>的评论区</p>
<p>在中断服务程序中，无法sleep的原因应该是sleep后，调度程序将CPU窃走，由于调度的基本单位是线程（中断服务程序不是线程），因此中断服务程序无法再被调度回来，即中断程序中sleep后的部分永远无法得到执行。</p>
</blockquote>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>大多数操作系统都支持POSIX线程（Pthread），它允许一个用户进程在不同的CPU上同时运行几个线程。Pthread支持用户级锁（user-level locks）、障碍（barriers）等。支持Pthread需要操作系统的支持。例如，如果一个Pthread在系统调用中阻塞，同一进程的另一个Pthread应当能够在该CPU上运行。另一个例子是，如果一个线程改变了其进程的地址空间（例如，映射或取消映射内存），内核必须安排运行同一进程下的线程的其他CPU更新其硬件页表，以反映地址空间的变化。</p>
</blockquote>
<h2 id="Lab-locks"><a href="#Lab-locks" class="headerlink" title="Lab: locks"></a>Lab: locks</h2><blockquote>
<p>In this lab you’ll gain experience in re-designing code to increase parallelism. You’ll do this for the xv6 <strong>memory allocator</strong> and <strong>block cache</strong>.</p>
</blockquote>
<h3 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h3><blockquote>
<p>The program <code>user/kalloctest</code> stresses xv6’s memory allocator: three processes grow and shrink their address spaces, resulting in many calls to <code>kalloc</code> and <code>kfree</code>. <code>kalloc</code> and <code>kfree</code> obtain <code>kmem.lock</code>. kalloctest prints (as “#fetch-and-add”) the number of loop iterations in <code>acquire</code> due to attempts to acquire a lock that another core already holds, for the <code>kmem</code> lock and a few other locks. The number of loop iterations in <code>acquire</code> is a rough measure of lock contention. </p>
<p>To remove lock contention, you will have to redesign the memory allocator to avoid a single lock and list. 也就是说要把kalloc中的整个列表上锁，修改为每个CPU有自己的列表The basic idea is to maintain a free list per CPU, each list with its own lock. Allocations and frees on different CPUs can run in parallel, because each CPU will operate on a different list. The main challenge will be to deal with the case in which one CPU’s free list is empty, but another CPU’s list has free memory; in that case, the one CPU must “steal” part of the other CPU’s free list. Stealing may introduce lock contention, but that will hopefully be infrequent.主要挑战将是处理一个 CPU 的空闲列表为空，但另一个 CPU 的列表有空闲内存的情况； 在这种情况下，一个 CPU 必须“窃取”另一个 CPU 的空闲列表的一部分。</p>
<p>Your job is to implement per-CPU freelists, and stealing when a CPU’s free list is empty. </p>
<p>You must give all of your locks names that start with “kmem”. That is, you should call <code>initlock</code> for each of your locks, and pass a name that starts with “kmem”. </p>
<p>Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run <code>usertests sbrkmuch</code>. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ.</p>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>总之，意思就是kalloc里面本来是多核CPU共用一个空闲页list，现在要做的就是给每一核的CPU独立分配一个空闲页list。我觉得可以分为如下几步来做：</p>
<ol>
<li><p>定义list数组以及对应的锁</p>
<p>cpu的数量是一定的；cpuid可以用来作为数组下标索引</p>
</li>
<li><p>在init时初始化锁，在freelist的时候把空闲页均分给CPU</p>
</li>
<li><p>当kalloc和kfree的时候，获取当前cpuid上锁</p>
</li>
<li><p>当一个CPU的内存不够的时候，去向另一个CPU窃取。窃取之前，首先应该获取另一个CPU的锁。</p>
</li>
</ol>
<p>以上是初见思路。正确思路确实跟上面的一样，编码过程也比较简单，没有很恶心的细节和奇奇怪怪的bug，没什么好说的。</p>
<p>第二步中，hints是推荐把所有空闲页都分给CPU0。</p>
<p>第四步的时候我是一次窃取一页。我看到一个一次窃取多页的做法，我觉得很有想法，在这里附上链接：</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/524460096">MIT6.S081 lab8 locks</a></p>
</blockquote>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">kmem_locks</span>[<span class="title">NCPU</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelists</span>[<span class="title">NCPU</span>];</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>由于kinit仅会由一个cpu执行一次【详情见main.c】，故而我这里在kinit的做法是由一个CPU初始化所有CPU，而没有选择去修改main.c从而使每个CPU都执行一次kinit。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++)&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="number">6</span>,<span class="string">&quot;kmem%d&quot;</span>,i);</span><br><span class="line">    initlock(&amp;kmem.kmem_locks[i], buf);</span><br><span class="line">  &#125;</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多带一个参数表示cpuid，仅在kinit的freerange中使用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree_init</span><span class="params">(<span class="type">void</span> *pa,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  r-&gt;next = kmem.freelists[i];</span><br><span class="line">  kmem.freelists[i] = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 把空闲内存页均分给每个CPU</span></span><br><span class="line">  uint64 sz = ((uint64)pa_end - (uint64)pa_start)/NCPU;</span><br><span class="line">  uint64 tmp = PGROUNDDOWN(sz) + (uint64)p;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)tmp; p += PGSIZE)</span><br><span class="line">      kfree_init(p,i);</span><br><span class="line">    tmp += PGROUNDDOWN(sz);</span><br><span class="line">    <span class="keyword">if</span>(i == NCPU<span class="number">-2</span>)&#123;</span><br><span class="line">      tmp = (uint64)pa_end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a>kfree</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">  <span class="comment">// 在这</span></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  r-&gt;next = kmem.freelists[id];</span><br><span class="line">  kmem.freelists[id] = r;</span><br><span class="line">  release(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="kalloc"><a href="#kalloc" class="headerlink" title="kalloc"></a>kalloc</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  r = kmem.freelists[id];</span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    kmem.freelists[id] = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.kmem_locks[id]);</span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果无空闲页，则窃取</span></span><br><span class="line">  <span class="keyword">if</span>(!r)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=NCPU<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      acquire(&amp;kmem.kmem_locks[i]);</span><br><span class="line">      r = kmem.freelists[i];</span><br><span class="line">      <span class="keyword">if</span>(r)&#123;</span><br><span class="line">        kmem.freelists[i] = r-&gt;next;</span><br><span class="line">        release(&amp;kmem.kmem_locks[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;kmem.kmem_locks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h3><p>buffer cache的结构其实跟kalloc的内存分配结构有一定的类似之处，都是采用链表管理，但是buffer cache的实现相较于kalloc更为复杂。</p>
<blockquote>
<p>Reducing contention in the block cache is more tricky than for kalloc, because bcache buffers are truly shared among processes (and thus CPUs). </p>
<p>For kalloc, one could eliminate most contention by giving each CPU its own allocator; that won’t work for the block cache. </p>
<p>We suggest you look up block numbers in the cache with a hash table that has a lock per hash bucket.</p>
</blockquote>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><h5 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h5><p>我想我们可以这么实现：</p>
<p>首先有一个双向链表，接收着所有空闲无设备分配的buf。然后再有多个双向链表桶，以设备号为索引值。</p>
<p>设备号数量，也即hash table的大小定义在<code>kernel/param.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEV         10 </span></span><br></pre></td></tr></table></figure>

<p>在<code>bget</code>中，第一个循环仅需在设备链表中查找即可，第二个循环需要先看设备链表是否有空闲的对象，如果没有，则去接收所有空闲无设备分配的那个双向链表中窃取一个对象。</p>
<p>在<code>brelse</code>中，则把要释放的buf对象添加在head中即可。</p>
<p>因而，我们要做以下几件事：</p>
<ol>
<li><p>修改bcache的定义</p>
<p>添加数量为设备号的head数组，以及对应的锁</p>
</li>
<li><p>初始化bcache</p>
</li>
<li><p>添加工具函数：将一个buf加入一个双向链表；从一个双向链表中得到一个buf</p>
</li>
<li><p>写<code>bget</code>和<code>brelse</code></p>
</li>
</ol>
<p>看起来确实好像可以实现的样子，但是这个问题在于，这么做就直接破坏了LRU的这个规则。所以还是不能这么写的。但总之先把我的代码放上来。</p>
<p>以下代码是不能正常运行的。比如说在执行<code>ls</code>命令时，会发生如下错误：</p>
<p><img src="/2023/01/10/xv6/image-20230122163938601.png" alt="image-20230122163938601"></p>
<p>会打印出一些乱七八糟的东西，并且这些东西似乎是固定的，每次都会发生，看来应该不是多进程的问题，而是代码有哪里出现逻辑错误了。不过注意到会产生“stopforking”、“bigarg-ok”，这两个似乎是在usertest中的两个文件名，很奇怪。</p>
<p>很遗憾我暂时没有精力debug了。姑且先把错误代码放在这里吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">dev_heads</span>[<span class="title">NDEV</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">dev_locks</span>[<span class="title">NDEV</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NDEV;i++)&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="number">9</span>,<span class="string">&quot;bcache%02d&quot;</span>,i);</span><br><span class="line">    initlock(&amp;(bcache.dev_locks[i]), buf);</span><br><span class="line">    bcache.dev_heads[i].prev = &amp;(bcache.dev_heads[i]);</span><br><span class="line">    bcache.dev_heads[i].next = &amp;(bcache.dev_heads[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始时，每一个桶内都有一个buf结点</span></span><br><span class="line">  b = bcache.buf;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NDEV;i++)&#123;</span><br><span class="line">    b-&gt;next = bcache.dev_heads[i].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.dev_heads[i];</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.dev_heads[i].next-&gt;prev = b;</span><br><span class="line">    bcache.dev_heads[i].next = b;</span><br><span class="line">    b++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uint dev = b-&gt;dev;</span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;(bcache.dev_locks[dev]));</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line"></span><br><span class="line">    acquire(&amp;bcache.lock);</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">    release(&amp;bcache.lock);</span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">    release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;(bcache.dev_locks[dev]));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.dev_heads[dev].next; b != &amp;(bcache.dev_heads[dev]); b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;(bcache.dev_locks[dev]));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在head中找</span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.head.prev; b != &amp;(bcache.head); b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h5><p>首先，大家似乎都是用<code>blockno</code>来hash的，这点就跟我的原始思路不一样了（。其实也很对，因为每个设备的使用频率是不平均的，用<code>blockno</code>来hash比用<code>dev</code>来hash其实会让访问次数更加平均。</p>
<p>然后就是怎么保证LRU依然OK。hints的做法是使用时间戳。我们可以在<code>brelse</code>的时候记录时间戳字段，在<code>bget</code>缺块的时候遍历hash table，找出对应timestamp最小的block即可。</p>
<p>历经了几小时的debug，代码最终正确。正确版本在下面的代码模块处。</p>
<h5 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h5><p>coding过程其实很短暂，毕竟思路很直观。我一开始是按初见思路写的代码，然后再从初见思路改到正确思路，这个过程，给我埋下了极大的安全隐患【悲】</p>
<p>其实几个小时下来，很多细节都已经忘记了，接下来就说点印象比较深的吧。</p>
<p>首先，我使用了正确思路以来，依然出现了跟初见思路一样的错误，也即xv6正常boot，但是执行ls命令会有错误。但是，当我<code>make clean</code>之后再次<code>make qemu</code>，错误改变了，变成了xv6 boot失败，并且爆出错误<code>panic:ilock:no type</code>。</p>
<blockquote>
<p>注：关于此处的make clean，有两点需要解释。一是为什么会做出make clean的行为，二是这个变化的原理是什么。</p>
<p>此处突然做出make clean的行为，是因为参照了该文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/524460096">MIT6.S081 lab8 locks</a></p>
<p><img src="/2023/01/10/xv6/image-20230123172138766.png" alt="image-20230123172138766"></p>
<p>没想到我make clean之后反而就变成了他这样的问题23333也是感觉蛮惊讶的</p>
<p>这个的原理说实话我不大清楚。猜想可能是make qemu的某段访问磁盘初始化之类的代码只会执行一次，只有make clean之后才会让其执行第二次。所以我们手动完全boot了一遍操作系统，才会导致这个错误爆出来，否则，操作系统就会使用原本的正确boot版本启动，之后再执行命令就当然是错误的了。</p>
<p>我想知乎文章里也应该是这个原因。操作系统本来使用的是错误版本，make clean后才会重新使用正确版本。</p>
<p>我之后写对了又尝试了一下，觉得我的猜想应该是对的。我的执行路线：</p>
<ol>
<li>make qemu，得到正确结果</li>
<li>将<code>bio.c</code>改回错误版本</li>
<li>再次make qemu，发现xv6正常boot，但是执行ls命令会出以上同样的错误</li>
<li>make clean，然后make qemu，爆出<code>panic:ilock: no type</code></li>
</ol>
<p>挺完美地符合了我的猜想。</p>
<p>【来自之后的学习：</p>
<p>in lab file system：</p>
<p>mkfs 程序创建 xv6 文件系统磁盘映像并确定文件系统总共有多少个块； 这个大小由 kernel/param.h 中的 FSSIZE 控制。 您会看到本实验存储库中的 FSSIZE 设置为 200,000 个块。 您应该在 make 输出中看到 mkfs/mkfs 的以下输出：<br>nmeta 70 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 25) blocks 199930 total 200000<br>这一行描述了 mkfs/mkfs 构建的文件系统：它有 70 个元数据块（用于描述文件系统的块）和 199,930 个数据块，共计 200,000 个块。<br><strong>如果在实验期间的任何时候您发现自己必须从头开始重建文件系统，您可以运行 make clean 来强制 make 重建 fs.img</strong>。</p>
<p>可以看到，我们上面就是做了强制重构fs.img。】</p>
</blockquote>
<p>我想来想去不知道这个错到底怎么爆的，看了下<code>ilock()</code>对应报错点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in fs.c ilock()</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;ilock begin.\n&quot;);</span></span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//print_buf();</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;bp-&gt;blockno = %d, bp-&gt;refcnt = %d\n&quot;</span>,bp-&gt;blockno,bp-&gt;refcnt);</span><br><span class="line">      panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可知大概就是，ip的type为0这个非法数值就报错了，而ip的type来源于dip，dip又指向了bp的data，bp也就是我们在<code>bio.c</code>一直在打交道的buf结构体。所以说，其实问题是出在了buf上，我们的<code>bread</code>返回的是一个错误的buf。</p>
<p>那么，究竟是buf的哪里出错了呢？这个问题想了我很久很久很久，依然没想出来。我一直认为是我的hashtable+双向链表这个数据结构哪里写错了，反反复复看了三四遍，其他地方的逻辑也反反复复研究了好几遍，依然没有结论。当然此过程也抓出了很多bug，但抓完bug后报错仍在，非常坚挺。</p>
<p>快要放弃的时候，我发现了错误。这很大一部分归功于我用于调试的这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印出hashtable的所有结点</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_buf</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;**********************\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cnt = %d,dec = %d\n&quot;</span>,cnt,dec);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NBUCKET;i++)&#123;</span><br><span class="line">  <span class="type">int</span> should = !holding(&amp;(bcache.dev_locks[i]));</span><br><span class="line">   <span class="keyword">if</span>(should)</span><br><span class="line">     acquire(&amp;(bcache.dev_locks[i]));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">   <span class="type">int</span> tmp_cnt = <span class="number">0</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">b</span>;</span></span><br><span class="line">   <span class="keyword">for</span>(b = bcache.dev_heads[i].next; b != &amp;(bcache.dev_heads[i]); b = b-&gt;next)&#123;</span><br><span class="line">   <span class="comment">//for(b = bcache.dev_heads[i].prev; b != &amp;(bcache.dev_heads[i]); b = b-&gt;prev)&#123;</span></span><br><span class="line">     tmp_cnt++;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;b.refcnt = %d,b.dev = %d,b.blockno = %d\n&quot;</span>,b-&gt;refcnt,b-&gt;dev,b-&gt;blockno);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d:total:%d\n&quot;</span>,i,tmp_cnt);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(should)</span><br><span class="line">     release(&amp;(bcache.dev_locks[i]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在<code>ilock()</code>的panic前面调用了这个函数，并且打印了出问题的buf的blockno：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)&#123;</span><br><span class="line">  print_buf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bp-&gt;blockno = %d, bp-&gt;refcnt = %d\n&quot;</span>,bp-&gt;blockno,bp-&gt;refcnt);</span><br><span class="line">  panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/10/xv6/image-20230123174332113.png" alt="image-20230123174332113"></p>
<p>可以看到，出问题的这里blockno=33，而在桶7中，首先有两个blockno==33的结点，这已经违反了不变性条件；其次有一个refcnt==1的结点，那个是所需结点，但我们却没有找到那个结点，反而去新申请了一个结点。这显然非常地古怪。</p>
<p>于是随后，我就在<code>bio.c</code>的<code>bget()</code>中添加了这么几句话：</p>
<p><img src="/2023/01/10/xv6/image-20230123174620818.png" alt="image-20230123174620818"></p>
<p>最终结果是会打印出两个blockno==0的结点，但是blockno==33的结点没有访问到。</p>
<p>这就很奇怪了。<code>print_buf</code>中以及<code>bget</code>的这个地方，都是遍历hashtable的某个双向链表，但是，为什么<code>print_buf</code>可以访问到，但是<code>bget</code>不行呢？</p>
<p>我首先对比出来的，是<code>print_buf</code>是逆序遍历，而<code>bget</code>是顺序遍历，所以我就又猜想是因为我的数据结构写错了，然而又看了一遍发现并不是。</p>
<p>这时候，可能我的视力恢复了吧，我猛然发现：：</p>
<p><img src="/2023/01/10/xv6/image-20230123174921100.png" alt="image-20230123174921100"></p>
<p>我超，这里是不是应该用hash。。。。。改完这处之后，果然就非常顺利地pass了所有测试【悲】</p>
<p>可以看到伏笔回收了。我是在旧思路代码基础上改过来的。旧思路代码是用dev作为index的，这个for循环忘记改了。因而，就这样，就这么寄了，看了我三四个小时【悲】</p>
<p>不过这倒是可以解释得通所有的错误了。之所以<code>ilock</code>中buf出错，没有正确找到已经映射在cache中的buf而是自己新建了一个，是因为，我压根就没有在正确的桶里找，而是在别的桶中找，这样自然就找不到了，就会自己新建一个，然后就寄了。</p>
<p>这个故事告诉我们，还是得谨慎写代码（）以及，我在旧代码基础上改的时候，其实可以用更聪明的替换方法：修改dev的变量名为hash-&gt;把参数里的dev变量名改为dev。这样就不会出错了。很遗憾，我并没有想到，只是很急很急地手动一个个改了，之后也没有检查，才发生如此错误。忏悔。</p>
<p>本次bug虽然很sb，但确实让我在debug过程中收获了些许，至少毅力变强了（）途中无数次想要放弃，还好我坚持了下来，才能看到如此感动的OK一片：</p>
<p><img src="/2023/01/10/xv6/image-20230123170805666.png" alt="image-20230123170805666"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><blockquote>
<p>之后写学校实验时回过头来看，发现之前的实现是不对的，在同时进入<code>bfree</code>函数时有死锁风险。经过修改后虽然粒度大了但是安全了。对了，额外附上一版不知道为啥错了的细粒度版本……看了真感觉没什么问题，但依然是会在<code>bfree</code>时panic两次free。等以后有精力再继续研究吧（泪目）</p>
<p>错误版本的思路就是，使用每个block块自己的锁(<code>b-&gt;lock</code>)和每个桶的锁来实现细粒度加锁。我是左看右看感觉每个block从在bget中获取一直到brelse释放的<code>b-&gt;lock</code>锁是一直持有的，但确实依然有可能发生两个进程同时获取同一个block的锁的情况。实在不知道怎么办了，想了很久还是没想出细粒度好方法（泪）总之代码先放在这里。</p>
</blockquote>
<h5 id="正确版本"><a href="#正确版本" class="headerlink" title="正确版本"></a>正确版本</h5><p>请见我的github。</p>
<h5 id="错误版本"><a href="#错误版本" class="headerlink" title="错误版本"></a>错误版本</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// printf(&quot;bget\n&quot;);</span></span><br><span class="line">  uint hash = blockno % <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;(bcache.dev_locks[hash]));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.dev_heads[hash].next; b != &amp;(bcache.dev_heads[hash]); b = b-&gt;next)&#123;</span><br><span class="line">    <span class="type">int</span> initial_hold = holdingsleep(&amp;b-&gt;lock);</span><br><span class="line">    release(&amp;(bcache.dev_locks[hash]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!initial_hold)</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(b-&gt;blockno == blockno&amp;&amp;b-&gt;dev == dev)&#123; <span class="comment">// 找到了</span></span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      b-&gt;timestamp = ticks;</span><br><span class="line">      <span class="comment">// release(&amp;(bcache.dev_locks[hash]));</span></span><br><span class="line">      <span class="comment">// acquiresleep(&amp;b-&gt;lock);</span></span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!initial_hold)</span><br><span class="line">      releasesleep(&amp;b-&gt;lock);</span><br><span class="line">    acquire(&amp;(bcache.dev_locks[hash]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;(bcache.dev_locks[hash]));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没找到，进行LRU</span></span><br><span class="line">  <span class="comment">// 遍历hash table，找到LRU，也即时间戳最小的且refcnt小于0的那一项</span></span><br><span class="line"></span><br><span class="line">  uint min_time = <span class="number">4294967295</span>;<span class="comment">// uint的最大值。此处不能使用(uint)(-1)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">goal</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    uint time = <span class="number">0</span>;</span><br><span class="line">    acquire(&amp;(bcache.dev_locks[i]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">struct</span> buf* b = bcache.dev_heads[i].prev; b != &amp;(bcache.dev_heads[i]); b = b-&gt;prev)&#123;</span><br><span class="line">      <span class="type">int</span> initial_hold = holdingsleep(&amp;b-&gt;lock);</span><br><span class="line">      release(&amp;(bcache.dev_locks[i]));</span><br><span class="line">      <span class="keyword">if</span> (!initial_hold) </span><br><span class="line">        acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">          time = b-&gt;timestamp;</span><br><span class="line">          <span class="keyword">if</span>(time &lt; min_time)&#123;</span><br><span class="line">            min_time = time;</span><br><span class="line">            <span class="keyword">if</span> (goal) releasesleep(&amp;goal-&gt;lock);</span><br><span class="line">            goal = b;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!initial_hold &amp;&amp; goal != b)  releasesleep(&amp;b-&gt;lock);</span><br><span class="line">      acquire(&amp;(bcache.dev_locks[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;(bcache.dev_locks[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// hashtable中存在着空闲buf</span></span><br><span class="line">  <span class="keyword">if</span>(goal != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// acquiresleep(&amp;goal-&gt;lock);</span></span><br><span class="line">      goal-&gt;dev = dev;</span><br><span class="line">      goal-&gt;blockno = blockno;</span><br><span class="line">      goal-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      goal-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将goal从其所在双向链表中移除</span></span><br><span class="line">      acquire(&amp;(bcache.dev_locks[hash]));</span><br><span class="line"></span><br><span class="line">      goal-&gt;prev-&gt;next = goal-&gt;next;</span><br><span class="line">      goal-&gt;next-&gt;prev = goal-&gt;prev;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在新双向链表中添加goal</span></span><br><span class="line">      goal-&gt;prev = &amp;(bcache.dev_heads[hash]);</span><br><span class="line">      goal-&gt;next = bcache.dev_heads[hash].next;</span><br><span class="line"></span><br><span class="line">      bcache.dev_heads[hash].next-&gt;prev = goal;</span><br><span class="line">      bcache.dev_heads[hash].next = goal;</span><br><span class="line"></span><br><span class="line">      release(&amp;(bcache.dev_locks[hash]));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> goal;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uint hash = b-&gt;blockno%NBUCKET;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;(bcache.dev_locks[hash]));</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  b-&gt;timestamp = ticks;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    </span><br><span class="line">    b-&gt;next = bcache.dev_heads[hash].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.dev_heads[hash];</span><br><span class="line">    bcache.dev_heads[hash].next-&gt;prev = b;</span><br><span class="line">    bcache.dev_heads[hash].next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;(bcache.dev_locks[hash]));</span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Traps and system calls</title>
    <url>/2023/01/10/xv6$chap4/</url>
    <content><![CDATA[<h1 id="Traps-and-system-calls"><a href="#Traps-and-system-calls" class="headerlink" title="Traps and system calls"></a>Traps and system calls</h1><p>traps=系统调用+异常+中断。本章着重讲traps概述以及traps中的系统调用。</p>
<p>对trap的处理包含四个部分：硬件处理、中断向量、trap handler、对应的处理函数</p>
<h2 id="RISC-V-trap-machinery"><a href="#RISC-V-trap-machinery" class="headerlink" title="RISC-V trap machinery"></a>RISC-V trap machinery</h2><blockquote>
<p><img src="/2023/01/10/xv6/image-20230618162437636.png" alt="image-20230618162437636"></p>
<p><img src="/2023/01/10/xv6/image-20230618162500928-1687077103154-2.png" alt="image-20230618162500928"></p>
<p>在RISC-V中，异常通常是由于程序执行过程中的错误或非预期事件而引起的，包括<strong>故障（faults）、陷阱（traps）和中止（aborts）</strong>。中断（interrupts）则是由外部事件触发的，例如定时器到期、外部设备请求等。中断是异步事件，与当前正在执行的指令无关，因此会在任何时候发生。</p>
<p>xv6是基于RISC-V架构的。因此，发生异常的时候，就会跳转到统一的kernel trap，然后再在里面通过读取scause来进行相应处理。</p>
<p>发生中断的处理方式就和x86差不多了，都是通过中断向量实现的。</p>
</blockquote>
<h3 id="control-register"><a href="#control-register" class="headerlink" title="control register"></a>control register</h3><p>risc-v为trap提供了一组寄存器：</p>
<ol>
<li><p>stvec</p>
<p>trap handler的入口地址</p>
</li>
<li><p>sepc</p>
<p>原程序PC</p>
</li>
<li><p>scause</p>
<p>中断号</p>
</li>
<li><p>sscratch</p>
<p>TRAPFRAME地址</p>
</li>
<li><p>sstatus</p>
<p>是否允许中断，以及中断来自内核态还是用户态</p>
</li>
</ol>
<blockquote>
<p>The above registers relate to traps <strong>handled in supervisor mode</strong>, and they cannot be read or written in user mode. </p>
<p>There is an equivalent set of control registers for traps handled <strong>in machine mode</strong>; xv6 uses them <strong>only</strong> for the special case of <u>timer interrupts</u>.</p>
</blockquote>
<p>每个CPU都有自己的一套这样的控制寄存器。</p>
<h3 id="硬件处理步骤"><a href="#硬件处理步骤" class="headerlink" title="硬件处理步骤"></a>硬件处理步骤</h3><p>时钟中断、device interrupt以及关中断的情况下，不会做以下步骤。</p>
<blockquote>
<p>\1. If the trap is a device interrupt, and the sstatus SIE bit is clear, <strong>don’t</strong> do any of the following.</p>
<p>\2. Disable interrupts by clearing SIE.关中断</p>
<p>\3. Copy the pc to sepc.保存PC</p>
<p>\4. Save the current mode (user or supervisor) in the SPP bit in sstatus.保存mode</p>
<p>\5. Set scause to reflflect the trap’s cause.保存中断号</p>
<p>\6. Set the mode to supervisor.切换到内核态</p>
<p>\7. Copy stvec to the pc.将trap handler写入pc，开始执行trap handler【uservec or kernelvec？】</p>
</blockquote>
<p>切换到内核页表、切换内核栈、保存寄存器现场这些工作交给操作系统完成。</p>
<h2 id="Traps-from-user-space"><a href="#Traps-from-user-space" class="headerlink" title="Traps from user space"></a>Traps from user space</h2><p>从用户态来的trap会经历怎么样的过程？</p>
<p>前面说到，下面需要进行页表的切换，页表的切换必然是接下来要做的指令的某个环节。那么为了让页表切换之后，CPU还知道要从哪里取指执行，<strong>就要让某段物理内存在内核空间和用户空间的虚拟地址一样</strong>。这样，不论页表是用户的还是内核的，都可以通过同样的虚拟地址访问到该段存放指令的物理内存从而继续执行。</p>
<p>这段虚拟地址就是<strong>trampoline</strong>。它在内核页表和用户页表都位于MAXVA的位置。</p>
<blockquote>
<p>我感觉这段大概可以这么理解：</p>
<p>通过查看代码，可知trampoline段实际上存储的是trampoline.S中的数据，也即uservec和userret的汇编代码，也即<strong>执行切换页表我们实际上就是在执行trampoline里的代码</strong>。trampoline的存在，就可以使得每个页表的这部分都是这两个的代码，这样一来切换页表也就不影响指令流的执行。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/p3.png" alt="p3"></p>
<p>stevc存储的正是trampoline段中的uservec。</p>
<h3 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h3><p>sscratch里面存的是trapframe的值。</p>
<p>trapframe存在于用户空间中，并且每个进程的trapframe所处位置固定是在trampoline下方。</p>
<p><img src="/2023/01/10/xv6/image-20230111203357767.png" alt="image-20230111203357767"></p>
<p>首先将寄存器的值都存入trapframe中；然后，再从trapframe中读取内核栈指针、当前CPUid，下一步要跳转的usertrap的地址，以及内核页表。最后，uservec切换到内核页表，并且jmp到usertrap。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#in kernel/trampoline.S</span><br><span class="line">	.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process&#x27;s p-&gt;trapframe is</span><br><span class="line">        # mapped into user space, at TRAPFRAME.</span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">		# swap a0 and sscratch</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        # ...</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">		# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        # 完成了内核栈的切换</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        # 这里完成了页表的切换</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：trampoline和trapframe有一些相通点。</p>
<p>trampoline为了保障某段物理内存的虚拟地址在内核栈和用户栈中不变，做出的努力是，在内核栈和用户栈都分配同一位置的PTE。</p>
<p>trapframe用于保护现场、用户态向内核态传递参数等等，做出的努力是，在用户栈分配同一位置的PTE，在内核态的局部变量中保存了自己的物理地址。</p>
<p>这两个说实话有点容易混起来，因为我想了半天trampoline可不可以用类似trapframe一样的方法，结论是不行。因为你trampoline的作用是维持指令序列依然不变，不会突然没掉；而trapframe段是用来存储数据而非执行的，对其的控制也是需要指令的。如果trampoline使用第二种方法，指令流就会断掉，更别说别的了。</p>
</blockquote>
<h3 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h3><p>作用是得到trap发生的原因，并且执行对应的处理程序，然后返回结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  <span class="comment">//首先把trap handler切换到kernel的，这样一来如果在kernel中发生trap就会由kernel的handler处理</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在当前进程中再次保存用户程序的原PC，防止之后sepc被覆盖</span></span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//根据cause号不同处理</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="comment">//注意，在此处开启了中断</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用syscall处理</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行对应的处理函数"><a href="#执行对应的处理函数" class="headerlink" title="执行对应的处理函数"></a>执行对应的处理函数</h3><p>比如说system call会修改trapframe中的a0为返回的结果，会获取trapframe中的各个参数。这个“保护现场“感觉是非常微妙的，它兼顾了保护现场和传递参数两个作用</p>
<h3 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h3><p>回到用户态。之前陷入内核态对stvec、satp、sp、hartid、trap handler都做了适应内核态的改变，因而这里就需要改回原来适应用户态的样子，然后返回用户态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关中断</span></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置trapframe</span></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">		# 切换为用户页表</span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        # ...</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h2 id="Code-calling-system-calls"><a href="#Code-calling-system-calls" class="headerlink" title="Code: calling system calls"></a>Code: calling system calls</h2><blockquote>
<p>Chapter 2 ended with initcode.S invoking the exec system call (user/initcode.S:11). Let’s look at how the user call makes its way to the exec system call’s implementation in the kernel.要讲如何从用户态找到exec的代码了。</p>
</blockquote>
<h2 id="Code-system-call-arguments"><a href="#Code-system-call-arguments" class="headerlink" title="Code: system call arguments"></a>Code: system call arguments</h2><p>讲的是系统调用时，是如何把用户态传递的地址转化为内核态地址的。</p>
<p>这个部分可以看看hit实验的实验3 6.7，讲得很详细，而且流程是差不多的。linux0.11的<code>get_fs_byte()</code>就相当于xv6的<code>copyinstr</code>。</p>
<h2 id="Traps-from-kernel-space"><a href="#Traps-from-kernel-space" class="headerlink" title="Traps from kernel space"></a>Traps from kernel space</h2><h3 id="kernelvec"><a href="#kernelvec" class="headerlink" title="kernelvec"></a>kernelvec</h3><p>不同于用户态还得先潜入内核再潜出内核，内核的trap可简单多了，省去了切来切去各种东西的步骤，只需当做一个普通的函数调用就行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># in kernel/kernelvec.S</span><br><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        // make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        // save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)</span><br><span class="line">		# ...</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">	// call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        // restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        # ...</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        // return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h3 id="kerneltrap"><a href="#kerneltrap" class="headerlink" title="kerneltrap"></a>kerneltrap</h3><blockquote>
<p>kerneltrap is prepared for two types of traps: device interrrupts and exceptions. </p>
<p>It calls devintr (kernel/trap.c:177) to check for and handle the <strong>former</strong>. If the trap isn’t a device interrupt, it must be an exception, and that is always a fatal error if it occurs in the xv6 kernel; the kernel calls panic and stops executing.</p>
<p>If kerneltrap was called due to a timer interrupt, and a process’s kernel thread is running (rather than a scheduler thread), kerneltrap calls yield to give other threads a chance to run.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c</span></span><br><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在此处的devintr对不同的设备进行不同的处理方式</span></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Page-fault-exceptions"><a href="#Page-fault-exceptions" class="headerlink" title="Page-fault exceptions"></a>Page-fault exceptions</h2><p>似乎xv6是没有这个缺页exception的。这里主要讲解了三个可以利用缺页中断实现的优化：COW fork、lazy allocation、paging from disk。还提及了automatically extending stacks 以及memory-mapped fifiles。</p>
<h2 id="Lab：Trap"><a href="#Lab：Trap" class="headerlink" title="Lab：Trap"></a>Lab：Trap</h2><blockquote>
<p>This lab explores how system calls are implemented using traps. You will first do a warm-up exercises with stacks and then you will implement an example of user-level trap handling.</p>
</blockquote>
<h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><h4 id="题目和答案"><a href="#题目和答案" class="headerlink" title="题目和答案"></a>题目和答案</h4><blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/qq_53111905/article/details/120996446">Lab4: traps</a></p>
<p>There is a file <code>user/call.c</code> in your xv6 repo. make fs.img compiles it and also produces a readable assembly version of the program in <code>user/call.asm</code>.</p>
<p>Read the code in call.asm for the functions <code>g</code>, <code>f</code>, and <code>main</code>. Here are some questions that you should answer:</p>
</blockquote>
<ol>
<li><p>a2</p>
</li>
<li><p>被inline掉了</p>
</li>
<li><p>0x64A</p>
<p><img src="/2023/01/10/xv6/image-20230111224927837.png" alt="image-20230111224927837"></p>
<p>auipc的作用是把立即数左移12位，低12位补0，和pc相加赋给指定寄存器。这里立即数是0，指定寄存器是ra，即ra=pc=0x30=48。jalr作用是跳转到立即数+指定寄存器处并且把ra的值置为下一条指令。因此jalr会跳转1562+48=1594=0x64A处，观察汇编代码可知确实在000000000000064a处。</p>
</li>
<li><p>0x38</p>
</li>
<li><blockquote>
<p>Run the following code.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the RISC-V is <strong>little-endian</strong>. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<p><img src="/2023/01/10/xv6/format,png.png" alt="format,png"></p>
</blockquote>
</li>
<li><p>取决于寄存器a2（第3个参数）的值。</p>
</li>
</ol>
<h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><blockquote>
<p>For debugging it is often useful to have a backtrace: a list of the function calls on the stack above the point at which the error occurred.</p>
<p><img src="/2023/01/10/xv6/image-20230111232323444.png" alt="image-20230111232323444"></p>
<p>The compiler puts in each stack frame a frame pointer that holds the address of the caller’s frame pointer. Your <code>backtrace</code> should use these frame pointers to walk up the stack and print the saved return address in each stack frame.</p>
</blockquote>
<blockquote>
<p>Some hints:</p>
<ul>
<li><p>Add the prototype for backtrace to <code>kernel/defs.h</code> so that you can invoke <code>backtrace</code> in <code>sys_sleep</code>.</p>
</li>
<li><p>The GCC compiler stores the frame pointer of the currently executing function in the register s0. Add the following function to kernel/riscv.h:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and call this function in backtrace to read the current frame pointer. This function uses in-line assembly to read s0.</p>
</li>
<li><p>These <a href="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">lecture notes</a> have a picture of the layout of stack frames. Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.</p>
</li>
<li><p>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. You can compute the top and bottom address of the stack page by using <code>PGROUNDDOWN(fp)</code> and <code>PGROUNDUP(fp)</code> (see <code>kernel/riscv.h</code>. These number are helpful for <code>backtrace</code> to terminate its loop.</p>
</li>
</ul>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>我超，这题真的是那怎能只叫一个拷打……</p>
<h5 id="存储在s0中的栈帧指针"><a href="#存储在s0中的栈帧指针" class="headerlink" title="存储在s0中的栈帧指针"></a>存储在s0中的栈帧指针</h5><p>这个应该是risc-v的约定成俗的特性。我搜了一下risc-v的栈帧指针保存在哪个寄存器，看到了这样一篇文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/dai_xiangjun/article/details/126541174">risc-v 栈分析</a></p>
<p><img src="/2023/01/10/xv6/image-20230112012358601.png" alt="image-20230112012358601"></p>
</blockquote>
<p>这个信息没有放在题干提示，是在考察信息检索能力吗（</p>
<h5 id="栈的结构与栈帧的理解"><a href="#栈的结构与栈帧的理解" class="headerlink" title="栈的结构与栈帧的理解"></a>栈的结构与栈帧的理解</h5><p><img src="/2023/01/10/xv6/image-20230112010749756.png" alt="image-20230112010749756"></p>
<p>这是来自hint的栈结构。整个栈存储在一页中，由高地址向低地址增长。栈帧代表了一次函数调用，其中会存储如函数名、函数参数、局部变量等等信息。有几次函数调用就有几个栈帧，栈由栈帧组成。</p>
<p>s0中存储的栈帧指针fp指向的是栈帧的最高地址，如图fp所示。</p>
<blockquote>
<p>我理解错了栈帧的定义，都怪我基础不大牢固也不认真思考【悲】我一开始以为stack frame指的是一个栈，也即一页空间【我知道栈帧这个中文名词，但遇到英语就短路了】。老师画的这个图也被我理解为多个栈，也即多页拼在一起，要打印的Return Address处于页的最顶部。我就在这个思路上一去不复返了，压根没有意识到一个进程只有一个栈【大悲】然后顺带脑补把r_fp()也曲解了，以为它的意思是读取当前栈【非常自然地认为有很多个栈←】的下一个栈的最低地址【因为栈换掉了，所以s0也会变成父亲的栈的地址】。于是就写出了这样的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">   uint64 kstack = PGROUNDUP((uint64)(myproc()-&gt;kstack)+<span class="number">1</span>);</span><br><span class="line">   uint64 nstack = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>((nstack=(uint64)r_fp())!=<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*((uint64*)(kstack<span class="number">-8</span>)));</span><br><span class="line">         kstack = nstack;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果最后死循环了。去看了别人的代码发现他们写的结构就跟我完全不一样。琢磨着画着图，最后找了stack frame的定义，才恍然大悟（</p>
</blockquote>
<h5 id="思路形成"><a href="#思路形成" class="headerlink" title="思路形成"></a>思路形成</h5><p>我们只需遍历栈中所有栈帧，打印每个栈帧的Return Address部分就行。通过r_fp()获取第一个栈帧的位置，其他栈帧的位置由Prev.Frame获取。循环的界限是PGROUNDUP(r_fp())，因为栈只有一页的空间。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  uint64 <span class="built_in">stack</span> = r_fp();</span><br><span class="line">  uint64 nstack = <span class="number">0</span>;</span><br><span class="line">  uint64 top = PGROUNDUP(<span class="built_in">stack</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">stack</span>!=top)&#123;</span><br><span class="line">    nstack=*((uint64*)(<span class="built_in">stack</span><span class="number">-16</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*((uint64*)(<span class="built_in">stack</span><span class="number">-8</span>)));</span><br><span class="line">    <span class="built_in">stack</span> = nstack;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><blockquote>
<p>In this exercise you’ll add a feature to xv6 that <u>periodically alerts a process as it uses CPU time</u>. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. </p>
<p>More generally, you’ll be implementing a primitive form of user-level interrupt/fault handlers; you could use something similar to handle page faults in the application, for example. </p>
<p>You should add a new <code>sigalarm(interval, handler)</code> system call. If an application calls <code>sigalarm(n, fn)</code>, then after every <code>n</code> “ticks” of CPU time that the program consumes, the kernel should cause application function <code>fn</code> to be called. When <code>fn</code> returns, the application should resume where it left off.</p>
</blockquote>
<p>感觉从alarm中可以窥见信号的实现思路：</p>
<p><img src="/2023/01/10/xv6/image-20231218164244526.png" alt="image-20231218164244526"></p>
<p>而alarm的机理感觉也有点类似。用户先通过sigalarm注册定时函数，内核在时钟中断的时候对该标记位进行检查，然后去do_signal回到用户态执行用户的signal handler，再通过sigreturn回到用户模式。sigalarm相当于一个信号注册函数，sigreturn也就是上图的sigreturn。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h5><p>思路：sigalarm需要在用户程序在用户态运行的情况下，监测到用户程序已经运行了n个时间片，然后发出中断请求。我们会新设置一个中断类型alarm。kerneltrap接收到sigalarm的中断请求，检测到中断类型为alarm，就会在处理的时候调用fn。fn调用完就自然而然利用中断恢复到原来的现场了。所以要做的可以分为两部分。但问题是，如何让sigalarm在用户程序运行的同时监测n个时间片呢？难道得fork一个新的进程吗？然后父进程返回，子进程执行类似sleep里面那样的监测，直到时间片到了，就发送一个中断请求，让父进程停止，执行完fn回来之后就exit。</p>
<h5 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h5><p>可以看到，初见思路很多地方跟最后是不一样的。其中错得最离谱的，也是比较隐坑很容易因为想不明白就寄了的，是handler是个用户态的函数（。你不可能在内核态中调用fn，然后fn执行完后再自然而然地通过中断机制返回，因为你想要执行fn就必须进入用户态。这一点是需要一开始明确的。</p>
<p>明确了这一点后，让人更加不知道该怎么办了。那就一步步跟着指导书的脚步来思考吧。</p>
<h6 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h6><p>首先，明确你需要实现什么。你需要实现两个系统调用，一个是sigalarm，一个是sigreturn。结合提示，可知实验设计者给我们的思路是，通过sigalarm设置定时函数，通过sigalarm(0,0)取消定时函数。每次时钟中断检测当前定时时间是否达到，若已达到，则跳到定时函数执行。定时函数执行完后，需要借助sigreturn，才能正确返回时钟中断前的程序点。</p>
<h6 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h6><p>这又可拆解为几个要点：</p>
<ol>
<li>如何实现“定时”？</li>
<li>时钟中断在内核态的usertrap被检测。怎么从usertrap出来跳到定时函数而非原程序执行点？</li>
<li>执行完定时函数后，怎么样才能回到原程序执行点？</li>
</ol>
<h6 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a>part 3</h6><p>一个个来说，首先是如何实现定时。这个很简单。参照sys_sleep的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  backtrace();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，我们可以用ticks表示当前系统滴答数。这样，我们就可以在proc域里维护一个变量lasttick，记录上一次执行handler时的滴答数。每次在时钟中断时检测，所以需要写在<code>kernel/trap.c</code>中的<code>usertrap</code>中。</p>
<h6 id="part-4"><a href="#part-4" class="headerlink" title="part 4"></a>part 4</h6><p>然后，是怎么从usertrap出来跳到指定程序结束点。在书中，我们知道，sepc寄存器保存了中断前原程序的下一个执行点，sepc的备份存储在了proc域中的栈帧中。当中断返回时（在usertrapret中），会从栈帧中的epc字段读取sepc的备份赋值给sepc，再由sret帮助我们跳转到原程序点。因而，如果想要改变跳转点，我们只需要修改<code>p-&gt;trapframe-&gt;epc</code>就行。</p>
<h6 id="part-5"><a href="#part-5" class="headerlink" title="part 5"></a>part 5</h6><p>最后，是如何从periodic回到原程序执行点。</p>
<p><img src="/2023/01/10/xv6/image-20230113002057893.png" alt="image-20230113002057893"></p>
<p>这是每次进行时钟中断时的栈情况和执行代码链：t1-&gt;trampoline-&gt;usertrap-&gt;handler。</p>
<p>再然后，handler调用了sigreturn，用户栈中就会产生sigreturn的栈帧：</p>
<p><img src="/2023/01/10/xv6/image-20230113002434093.png" alt="image-20230113002434093"></p>
<p>此时，如果sigreturn执行完，就会在这样的情况下执行handler的ret指令：</p>
<p><img src="/2023/01/10/xv6/image-20230113002542335.png" alt="image-20230113002542335"></p>
<p>ret指令会把栈帧弄走，也就是说会直接回到某个错误的地方去。这显然不大合适。所以，我们要做的，就是在sigreturn之后，<u>不执行handler的ret指令，也不执行sigreturn的ret指令，而是直接恢复到时钟中断前的上下文</u>。时钟中断前的上下文，会因在handler中调用sigreturn系统调用，而被<strong>覆盖</strong>，因而，我们就需要记录时钟中断前的上下文，也即在proc域中保存trapframe的一份拷贝savedtrap，每次时钟中断都更新一次savedtrap，然后在sigreturn调用的时候将proc原本的trapframe替换为savedtrap即可。这样一来，就完成了这道题。</p>
<h5 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h5><p>这题目确实最终代码看起来完全不难，但是非常地拷打。。。。我前前后后修修补补差不多一共花了五个小时之久。</p>
<p>计时怎么计，以及使用trapframe-&gt;epc来跳转这两点还是很容易想到的【话虽如此，其实也很曲折】。主要难点还是在怎么恢复现场。怎么说呢，我花了这么久做实验，但是实际笔记却写不出个鬼来，足以看出其复杂程度。</p>
<p>我主要还是思维固化了点，一直在想，怎么确保它正确返回现场。我一开始以为proc域保存一个寄存器状态，且只用在一开始设置定时函数也即sigalarm的时候保存一次就行了，并且认为其是epc。然而实际操作后发现usertrap崩了，并且epc中存储的并不是程序被时钟中断的地方，而是各种神奇的地方，具体我也忘了，反正不能行。我印象最深刻的是有一次停在了usys.S中的sigreturn的最后一个ret处。我就在想，也许是栈出了问题。于是我就想着直接在sigreturn的时候把epc指向栈帧中的return address，直接回到原执行段。我百度了一下，确实有这么个寄存器ra，存储着return address。于是我就把proc域的状态换成了ra，依然仅保存一次，最后发现还是不行，程序在test0之后就异常终止了，main也回不去，十分古怪，十分匪夷所思。我实在没忍住，百度了一下大家怎么做的，发现大家压根没有我这样的二选一的烦恼，是直接保存整个栈帧。而且也不是仅保存一次，而是每次时钟中断触发都保存一次。我觉得十分奇怪震惊，但此时已是差不多晚饭时间，我就先去吃了个饭（）</p>
<p>回来之后，我细细画了图【向正确思路part5中的那样】，发现我原来那个只保存两者之一，且都只保存一次的方式，确实完全不能行。但是，我发现两个一起保存，并且每次时钟中断保存的方法，似乎能行，而且，比保存一整个栈帧要聪明得多。于是我就去试了，发现还是不行。我再细想了一遍，发现，如果想回去原程序的现场，除了ra和epc，还有一个很重要的东西需要保存，那就是——用户栈指针sp！</p>
<p>也就是说，<strong>只需保存ra、epc、sp，就可以保证回到正确的时钟中断前的位置</strong>：</p>
<p><img src="/2023/01/10/xv6/image-20230113005100895.png" alt="image-20230113005100895"></p>
<p>此为handler中sigreturn执行完要返回时的状态。</p>
<p>当处在handler中时，sp的值为sigreturn处的栈帧。执行系统调用时，proc域中的上下文被覆盖，也即时钟中断前的上下文被覆盖。如果此时不对栈帧中的sp进行恢复，仅恢复ra和epc，在从sigreturn返回到epc对应处也即t1，t1执行ret想回到main的时候，就会回不去，而是回到了sigreturn要回的位置，也即handler的位置，然后不知不觉就寄了。所以，就需要防止sp被覆盖。因而，再保存一个状态sp，就可以保障回到正确的地方了。测试出来，kernel确实不再会panic了。</p>
<p>但是由于运行时很多除这三个以外的寄存器都被改过了，回是回得去，接下来干的活就不一定对了。因此为了保险以及通用性以及便利性来看，还是像别人那样直接保存栈帧比较ok。</p>
<p>还有一件事，就是上述错误中经常会出现的一个输出结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">usertrap:unexpected cause scause = <span class="number">0x0c</span></span><br></pre></td></tr></table></figure>

<p>我留意了一下是什么意思。网上搜索得，scause=12，说明这是一个instruction page fault，而这个缺页错误说明了什么？：</p>
<p><img src="/2023/01/10/xv6/image-20230113012355740.png" alt="image-20230113012355740"></p>
<p>这样，一切都明朗了。出现了scause=0x0c的意思就是说pc里的值不恰当，也就是说上面错误的方法都会跳转到错误的地方去。</p>
<h2 id="Lab：xv6-lazy-page-allocation"><a href="#Lab：xv6-lazy-page-allocation" class="headerlink" title="Lab：xv6 lazy page allocation"></a>Lab：xv6 lazy page allocation</h2><blockquote>
<p>参考：<a href="https://blog.csdn.net/m0_53157173/article/details/131349366">https://blog.csdn.net/m0_53157173/article/details/131349366</a></p>
</blockquote>
<blockquote>
<p>来自书本：</p>
<p>Another widely-used feature is called <em>lazy allocation</em>, which has two parts:</p>
<ol>
<li>First, when an application calls sbrk, the kernel grows the address space, but marks the new addresses as not valid in the page table. </li>
<li>Second, on a page fault on one of those new addresses, the kernel allocates physical memory and maps it into the page table. </li>
</ol>
<p>The kernel allocates memory only when the application actually uses it. </p>
</blockquote>
<h3 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk()"></a>Eliminate allocation from sbrk()</h3><blockquote>
<p>Your first task is to delete page allocation from the sbrk(n).</p>
<p>The sbrk(n) system call grows the process’s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process’s size (myproc()-&gt;sz) by n and return the old size. It should not allocate memory – so you should delete the call to growproc() (but you still need to increase the process’s size!).</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> sz = myproc()-&gt;sz;</span><br><span class="line">  addr = sz;</span><br><span class="line">  myproc()-&gt;sz = sz + n;</span><br><span class="line">  <span class="comment">//if(growproc(n) &lt; 0)</span></span><br><span class="line">  <span class="comment">//  return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h3><blockquote>
<p>Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. </p>
<p>You should add your code just before the <code>printf</code> call that produced the “usertrap(): …” message. Modify <strong>whatever</strong> other xv6 kernel code you need to in order to get <code>echo hi</code> to work.</p>
</blockquote>
<h4 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>首先，要知道缺页中断的scause为13或15.【论我怎么知道的：被以前的实验逼出来的hhh】然后，要写在if条件的第二个分支。在该分支内，我们需要先获取出问题的地方的虚拟地址的值，然后申请新的一页，再map到当前页表中。</p>
<h5 id="一个难以察觉的错误"><a href="#一个难以察觉的错误" class="headerlink" title="一个难以察觉的错误"></a>一个难以察觉的错误</h5><h6 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h6><p>思路是很简单的，就是有小细节需要格外注意。</p>
<p>trap.c在<code>mappages</code>时，一定不能直接传入va，必须传入<code>PGROUNDDOWN(va)</code>。如果直接传入va，会爆出如下错误：</p>
<p><img src="/2023/01/10/xv6/image-20230116154004538.png" alt="image-20230116154004538"></p>
<p>但是，查看<code>mappages</code>的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，它在里面已经对va进行了处理了，使它变成了page-align的a变量。那么为什么，我们还要在外面再对va处理一次呢？</p>
<p>其实问题不是出在<code>mappages</code>中的a变量上，而是出现在<code>mappages</code>中的last变量上。比如，令va=PGSIZE+200，则a=PGSIZE，last=2*PGSIZE。这样一来，在下面的循环中，除了添加了刚刚申请的那页的映射以外，我们还多添加了新的一页，其物理地址为mem+PGSIZE。</p>
<p>这十分地危险！假设你要申请的va为proc-&gt;size的最后一页，那么，经过本次缺页中断之后，你事实上申请了两页，两页的地址分别为va和va+PGSIZE。而va+PGSIZE大于proc-&gt;size。也就是说，地址溢出了！</p>
<p>这会导致<strong>页表释放</strong>的时候出问题。以下是页表释放的路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">    uvmunmap(pagetable, <span class="number">0</span>, PGROUNDUP(sz)/PGSIZE, <span class="number">1</span>);</span><br><span class="line">  freewalk(pagetable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap walk: %p\n&quot;</span>,a);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap: %p\n&quot;</span>,a);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uvmunmap OK: %p\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freewalk要求在uvmunmap中已经释放完所有的叶子结点。而由于uvmunmap中释放结点的va是从0递增到proc-&gt;size的，也因而，前面的那个大于proc-&gt;size的那页虽然还在页表中存在，但是不会被uvmunmap释放！这也就导致，接下来调用freewalk的时候，会发现该页的叶子结点仍然存在，从而导致<code>freewalk: leaf</code>。</p>
<p>可以结合uvmunmap和trap.c中的调试语句看下图的过程，可以看到非常清晰明了，0x14000这一页并没有在uvmunmap中释放！</p>
<p>trap.c中的调试语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap: %p,+PGSIZE = %p\n&quot;</span>,PGROUNDDOWN(va),PGROUNDDOWN(va)+PGSIZE);</span><br><span class="line">   <span class="keyword">if</span>(mappages(p-&gt;pagetable,va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">     kfree(mem);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>图：</p>
<p><img src="/2023/01/10/xv6/image-20230116165910356.png" alt="image-20230116165910356"></p>
<h6 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h6><p>看到<code>freewalk: leaf</code>这一错误，很容易联想到跟页表的释放有关。并且加上PGGROUNDDOWN就没问题，不加上才有问题，也很容易联想到跟mappages中多申请的那一页有关。但是具体是什么关系，这一点想要想到对我来说还是非常曲折的。</p>
<p>我一开始，以为是因为多申请的那一页（下面简称为B页好了）很有可能是其他进程在使用的，然后其他进程在echo进程释放页表前释放了页表，从而导致B页已经free了，这样一来<code>uvmunmap</code>说不定就能监测到对应物理页已经free，然后爆出panic。我一开始认为<code>uvmunmap</code>的这句话是用来监测物理页是否free的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">   <span class="comment">//panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>然后顺理成章地，这边条件==0成立，然后continue，然后直到freewalk才发现该pte未释放。</p>
<p>但是，我仔细过脑子想了想，发现，就算物理页已经free了，但是，*pte依然存在，PTE_V也依然为1，这个条件是不成立的。也就是说，B页不会continue，而是会继续下面的正常释放的流程。也就是说，B页是可以正常释放的，我们的“B页已经free导致uvmunmap释放失败”的推论是错误的。</p>
<p>但究竟是为什么呢？肯定跟B页有关系，但是又不是这种关系，这让我十分地苦恼且烦躁，于是我就去打了会儿游戏。边玩的时候突然注意到一件非常可疑的事情。</p>
<p><img src="/2023/01/10/xv6/image-20230116154004538.png" alt="image-20230116154004538"></p>
<p>这是发生错误时退出的截图。有一个点引起了我的注意，就是echo hi并没有打印hi在console上。也就是说，这个panic是在echo执行前产生的！那么这个执行前是在哪呢？答案就是在exec中！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in exec.c</span></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  <span class="comment">// 这里！！！！！</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure>

<p>可以看到，这里调用了<code>proc_freetable</code>，从而跟freewalk有了联系。</p>
<p>但是，如果我们还坚持是因为B页错的，就需要找到一个可能会产生B页的地方，也就是验证shell准备执行echo命令，fork出一个子进程之后，又在exec free页表前，已经调用过sbrk函数，并且已经触发过缺页中断。这个验证其实很简单，只需要找sbrk在哪被调用过，哪边使用过heap内存【也即哪边涉及了指针赋值】就行了。</p>
<p>通过全局搜索，可知sbrk在<code>user/umalloc.c</code>下的<code>malloc()</code>被使用过，而在<code>user/sh.c</code>中，fork子进程之后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">  runcmd(parsecmd(buf));</span><br></pre></td></tr></table></figure>

<p>这其中的<code>parsecmd()</code>中malloc被使用过，并且发生了指针赋值！！也就是说，“是因为B页错的”这个结论是对的。</p>
<p>虽然这一段debug没有改变我们要证明“是B页在释放内存中出错的”的这个目的，但是确实带给了我很多这种执行时申请内存的知识，并且也让我突然想起了可以用printf debug。于是，我就去做了上面那个在trap.c中和uvmunmap中printf的调试语句，最终成功发现了结论。</p>
<p>实在是太艰苦了（）这告诉我们以后千万千万要注意，是否需要用到PGGROUNDDOWN。</p>
<h5 id="一个漏掉未考虑的细节"><a href="#一个漏掉未考虑的细节" class="headerlink" title="一个漏掉未考虑的细节"></a>一个漏掉未考虑的细节</h5><p>摘自<a href="https://blog.csdn.net/m0_53157173/article/details/131349366">https://blog.csdn.net/m0_53157173/article/details/131349366</a></p>
<p><img src="/2023/01/10/xv6/image-20231209011856305.png" alt="image-20231209011856305"></p>
<p><img src="/2023/01/10/xv6/image-20231209011932500.png" alt="image-20231209011932500"></p>
<p>不过我以前好像是有考虑到这个的，但是我是这么做的：</p>
<p><img src="/2023/01/10/xv6/image-20231209015238219.png" alt="image-20231209015238219"></p>
<p>也就是相当于把它在addr parse的那段代码移进了walkaddr中。但是这样是不行的，查找可知argaddr的应用范围可比walkaddr广得多……</p>
<p>而为什么我下面的COW也是修改了walkaddr，而非修改argaddr，就可以达到同样的效果呢？这是因为cow只需对在内核中写用户页这种情况进行特殊处理，而这只有一个情况，也即只在copyout中发生。因而，我们只需修改walkaddr，就可以完全防范该情况了。</p>
<h3 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h3><blockquote>
<p>We’ve supplied you with <code>lazytests</code>, an xv6 user program that tests some specific situations that may stress your lazy memory allocator. Modify your kernel code so that all of both <code>lazytests</code> and <code>usertests</code> pass.</p>
</blockquote>
<h4 id="感想-3"><a href="#感想-3" class="headerlink" title="感想"></a>感想</h4><h5 id="一个绷不住的错误"><a href="#一个绷不住的错误" class="headerlink" title="一个绷不住的错误"></a>一个绷不住的错误</h5><p>其实很简单，按照提示一步步做就行了。为什么我做得那么久那么崩溃呢？知道原因后我都笑嘻了。</p>
<p>在第一步修改<code>sys_sbrk()</code>的时候，我一下子没多想，使用了一句<code>int sz = myproc()-&gt;sz</code>，其实本来应该使用uint64的，使用int会溢出。这个伏笔就一直隐含到这里，然后大坑了我一笔。</p>
<p>一开始是发现<code>lazytests</code>的第二个，也就是oom过不去。我想了很久，也去网上找了别人的代码一步步对比下来看了，没有发现特别大的问题。于是我就在walk和sys_sbrk分别留下了调试信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in walk()</span></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;walk:va=%p,p-&gt;sz=%p,MAXVA=%p,pgva=%p\n&quot;</span>,va,myproc()-&gt;sz,MAXVA,PGROUNDDOWN(va));</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in sys_sbrk()</span></span><br><span class="line">  <span class="keyword">if</span>(n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    uint64 tmp = n + sz;</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; MAXVA || n + sz &lt; n)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    myproc()-&gt;sz = tmp;</span><br><span class="line">    <span class="comment">//printf(&quot;haha sb!sz=%p,n=%p\n&quot;,myproc()-&gt;sz,n);</span></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>然后发现了这样的输出：</p>
<p><img src="/2023/01/10/xv6/image-20230116225124363.png" alt="image-20230116225124363"></p>
<p>可以看到，最后一次sz发生了数值溢出。</p>
<p>但是，此时我并没有悔改。我反而认为，“原本代码就是这么写的”。也就是说，我认为<code>int sz</code>是它原本内核代码给的。。。。。。在这样的情况下，我选择加上这样的条件判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(tmp &gt; MAXVA || ((tmp &gt;&gt; <span class="number">31</span>)&amp; <span class="number">1</span>) == <span class="number">1</span>)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>之后确实没有溢出了，但是test fail了。此时我想，为什么非要用int而不用uint64呢？一阵令人不寒而栗的预感袭来，我连忙去看了<code>proc.h</code>里的sz的定义，发现，sz原本就应该是uint64类型的，是我错辣【悲】</p>
<p>只能说起到一种很好的教训。主要是这种问题实在没有想过自己会犯</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><blockquote>
<ul>
<li>Handle the parent-to-child memory copy in fork() correctly.</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in vm.c uvmcopy()</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Handle negative sbrk() arguments.</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  uint64 sz = myproc()-&gt;sz;</span><br><span class="line">  addr = sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    uint64 tmp = n + sz;</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; MAXVA || n + sz &lt; n)       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    myproc()-&gt;sz = tmp;</span><br><span class="line">    <span class="comment">//printf(&quot;haha sb!sz=%p,n=%p\n&quot;,myproc()-&gt;sz,n);</span></span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n + sz &gt; <span class="number">0</span>)</span><br><span class="line">      myproc()-&gt;sz = uvmdealloc(myproc()-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//if(growproc(n) &lt; 0)</span></span><br><span class="line">  <span class="comment">//  return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</p>
</li>
<li><p>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</p>
</li>
<li><p>Handle faults on the invalid page below the user stack.</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">13</span> || scause == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= p-&gt;sz ||  va &lt; PGROUNDUP(p-&gt;trapframe-&gt;sp) ||PGROUNDDOWN(va) &gt;= MAXVA)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;va=%p stack=%p\n&quot;,va,PGROUNDUP(r_sp()));</span></span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">char</span>* mem = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(mem != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">//printf(&quot;trap: %d %p\n&quot;,p-&gt;pid,PGROUNDDOWN(va));</span></span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">          kfree(mem);</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li>
</ul>
<p>我认为这里要是引起一个缺页中断可能会更酷，可能可以像lazytests里面这么做：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *i, *prev_end, *new_end;</span><br><span class="line"></span><br><span class="line">prev_end = sbrk(REGION_SZ);</span><br><span class="line">new_end = prev_end + REGION_SZ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里触发了多次缺页中断</span></span><br><span class="line"><span class="keyword">for</span> (i = prev_end + PGSIZE; i &lt; new_end; i += PGSIZE * PGSIZE)</span><br><span class="line">  *(<span class="type">char</span> **)i = i;</span><br></pre></td></tr></table></figure>

<p>之后有机会再试试233</p>
<p>【试了一下，发现是可以的。在COW fork的  <code>感想—一些错误和思考—在内核态中引发并处理缺页中断</code>  这部分内容中详细说明了具体要怎么做。】</p>
</blockquote>
<h2 id="Lab-Copy-on-Write-Fork-for-xv6"><a href="#Lab-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab: Copy-on-Write Fork for xv6"></a>Lab: Copy-on-Write Fork for xv6</h2><blockquote>
<p>Parent and child can safely share phyical memory using copy-on-write fork, driven by page faults. </p>
<p>RISC-V has <u>three different kinds of page fault</u>: <strong>load</strong> page faults (when a load instruction cannot translate its virtual address), <strong>store</strong> page faults (when a store instruction cannot translate its virtual address), and <strong>instruction</strong> page faults (when the address for an instruction doesn’t translate). </p>
<p>The <strong>basic plan</strong> in COW fork is for the parent and child to initially share all physical pages, but to map them <strong>read-only</strong>. Thus, when the child or parent executes a store instruction, the RISC-V CPU raises a page-fault exception. In response to this exception, the kernel makes a copy of the page that contains the faulted address. It maps one copy read/write in the child’s address space and the other copy read/write in the parent’s address space. After updating the page tables, the kernel resumes the faulting process at the instruction that caused the fault.</p>
<p>PS【这个很重要】: COW fork() makes freeing of the physical pages that implement user memory a little trickier. A given physical page may be referred to by multiple processes’ page tables, and should be freed only when the last reference disappears.</p>
</blockquote>
<h3 id="感想-4"><a href="#感想-4" class="headerlink" title="感想"></a>感想</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>思路还是很直观的。</p>
<p>我们只需要在fork的时候，标记父子进程的所有PTE都为read-only，然后之后就会遇到不同scause的缺页中断，针对特定的scause，新建物理页面，拷贝物理页面，然后重新设置映射即可。而对于其提出的需要标记某页是否能够释放，则需要统计每页的ref数，当ref==1的时候才可以释放。</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><h5 id="总分析"><a href="#总分析" class="headerlink" title="总分析"></a>总分析</h5><p>其实可以把任务简单拆分为三部分。第一部分是实现基本的cow fork的逻辑，第二部分是引用计数释放内存，第三部分是解决copyin/copyout时在内核态发生的缺页中断。我认为本实验的难点事实上在第二部分【悲】我可能有大于3/4的时间都花在第二部分上了吧。</p>
<p>第一部分是实现cow fork的基本逻辑，也就是修改fork中对页表的拷贝以及在usertrap中添加对缺页中断的处理，这很直观，没什么好说的。</p>
<p>第三部分要么跟上面的lazy allocation一样，在<code>kernel/vm.c walkaddr()</code>中把缺页中断搬过去，要么向我在<code>主要难点与错误—在内核态中引发并处理缺页中断</code>这一部分那样做。</p>
<p>我们分析这一部分主要讲的是我认为最难的地方，也就是第二部分。其实第二部分的思路也很直观：创建一个数组，index为所有能用的内存的<code>address/PGSIZE</code>，用来记录引用数；然后在每次增加引用时，对应元素++；每次减少引用时，对应元素–。</p>
<p>虽然思路很简单很直观，但是实现起来非常地非常地非常地考验细节（我就非常不擅长这一点）。下面，我就先阐述一下<strong>第二部分的这个方法</strong>需要分割为哪几部分，其他我遇到的印象较深的bug和对一些地方的思考，都放在了下一部分，也即<code>主要难点与错误</code>。</p>
<h5 id="引用数实现分析"><a href="#引用数实现分析" class="headerlink" title="引用数实现分析"></a>引用数实现分析</h5><blockquote>
<p>创建一个数组，index为所有能用的内存的<code>address/PGSIZE</code>，用来记录引用数；然后在每次增加引用时，对应元素++；每次减少引用时，对应元素–。</p>
</blockquote>
<h6 id="数组的大小和数据类型"><a href="#数组的大小和数据类型" class="headerlink" title="数组的大小和数据类型"></a>数组的大小和数据类型</h6><p>由<code>kernel/kalloc.c</code>中的<code>kinit()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="comment">// freerange用来把参数地址范围内的物理页加入freelist中</span></span><br><span class="line">  <span class="comment">// end是内核的结束地址</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，事实上，我们整个程序，包括用户和内核，能用的内存空间为0~PHYSTOP。因而，我们事实上只需要建一个<code>PHYSTOP/PGSIZE</code>这么大的数组就行。我算了一下大概是2^19次方。</p>
<p>然后，我感觉这种小系统应该不会有过多的对某一页的重复引用，因而，为了节省空间，我将数据类型定为了char。最好还是别定成uchar，因为这东西要是0–的话会溢出变为255，很可怕。</p>
<h6 id="什么时候增减引用"><a href="#什么时候增减引用" class="headerlink" title="什么时候增减引用"></a>什么时候增减引用</h6><blockquote>
<p>我认为这里是非常考验细节和头脑清晰度的，也就是我卡了很久最后也没弄出来的部分【悲】</p>
</blockquote>
<p>可以分为三种情况来讲。我们的引用计数必须完美适应这三种情况：</p>
<ol>
<li><p>不经由页表，通过kalloc和kfree直接使用物理页</p>
<p>这就要求我们在kalloc的时候置引用数为1，然后kfree的时候对引用数先-1，再判断是否归零。</p>
</li>
<li><p>经由页表，但与cow fork无关</p>
<p>增加页表项：mappages-&gt;kalloc，因而满足要求1即可。</p>
<p>删除页表项：uvmunmap。当do_free==1时，满足要求1即可。</p>
</li>
<li><p>经由页表，与cow fork有关</p>
<p>copy父进程页表时：在cowcopy中，每增加一次子进程的映射，就需要增加一次引用数</p>
<p>在用户态/内核态发生缺页中断：发生缺页中断后，对原来物理页的引用数需要-1【我就是漏了这一点……】</p>
<p>删除页表项：uvmunmap。当do_free==0时，当对应页表项有COW标记，则减少引用数</p>
</li>
</ol>
<p>所以，我们需要在三个文件进行修改：</p>
<ol>
<li><p>kalloc.c</p>
<p>增加数组定义，在kalloc和kfree中增加引用数修改</p>
</li>
<li><p>vm.c</p>
<p>在cowcopy和uvmunmap中增加引用数修改</p>
</li>
<li><p>trap.c</p>
<p>在usertrap的缺页中断中增加引用计数修改</p>
</li>
</ol>
<h6 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h6><blockquote>
<p>这里我也没想到【悲】</p>
</blockquote>
<p>由于我们的pages数组会在多个文件、多个进程间使用，所以它必须在被锁保护的区域中被使用。</p>
<h4 id="主要难点与错误"><a href="#主要难点与错误" class="headerlink" title="主要难点与错误"></a>主要难点与错误</h4><h5 id="scause-2"><a href="#scause-2" class="headerlink" title="scause=2"></a>scause=2</h5><p><img src="/2023/01/10/xv6/image-20230117161404719.png" alt="image-20230117161404719"></p>
<p>这个发生在我还没有实现第二部分的时候。搜索了一下，scause=2为<code>Illegal instruction</code>，而且sepc的这个1004的值也非常诡异。这应该是因为fork子进程释放了指令段内存，导致主进程执行错误</p>
<h5 id="kernel无法启动"><a href="#kernel无法启动" class="headerlink" title="kernel无法启动"></a>kernel无法启动</h5><p>在kinit中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;pages_lock,<span class="string">&quot;pages&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(pages, <span class="number">0</span>, (<span class="number">2</span>&lt;&lt;<span class="number">19</span>));</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会通过freerange初始化freelist。在freerange中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会对每一项进行一次kfree。因而，我们需要在kfree前先增加一次引用，要不然会寄。</p>
<h5 id="在缺页中断时减少对物理页的引用数"><a href="#在缺页中断时减少对物理页的引用数" class="headerlink" title="在缺页中断时减少对物理页的引用数"></a>在缺页中断时减少对物理页的引用数</h5><p><img src="/2023/01/10/xv6/image-20230117213903706.png" alt="image-20230117213903706"></p>
<p>注意此处不能直接让pages[pa/PGSIZE]–，一定要借助kfree。当此进程为引用pa的最后一个进程的时候，如果仅减少引用数，就会造成内存泄漏。kfree可以既减少引用数，又在适当的时候对物理页释放，可谓一举两得。kfree的这个双重作用思想也在uvmunmap中体现了。</p>
<h5 id="在内核态中引发并处理缺页中断"><a href="#在内核态中引发并处理缺页中断" class="headerlink" title="在内核态中引发并处理缺页中断"></a>在内核态中引发并处理缺页中断</h5><blockquote>
<p>Modify copyout() to use the same scheme as page faults when it encounters a COW page.</p>
</blockquote>
<p>我们所做的第一第二部分仅仅是完成了对来自用户态的缺页中断的完美处理，还尚未处理来自内核态的缺页中断。因而，这个修改copyin和copyout的点实际上就是要我们处理内核态的缺页中断。</p>
<p>这次实验跟上次的lazy allocation一样，都可以直接在walkaddr进行特殊处理，并且差不多要把usertrap的全部代码挪过来【具体见lazy allocation的代码】。不过，我想出了另一个流氓的方法（也就是说其实原理感觉是不大对233）。我选择直接在kernel引发一个访问用户页面的缺页中断，然后在kerneltrap中处理这个中断，就像usertrap一样。</p>
<p>但由于在<code>walkaddr</code>中发生的中断处于内核状态下，所以就进不了usertrap。我们应该在kerneltrap中再次添加和usertrap一样的中断处理。我们会像这样引发一个中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">    *(<span class="type">char</span>*)va = <span class="number">1</span>;<span class="comment">// 此处不能用pa哦</span></span><br></pre></td></tr></table></figure>

<p>然后在kerneltrap中这样处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 只要写入引起的缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line">    uint flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sepc += <span class="number">4</span>;</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">            memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">            <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">            *pte = PA2PTE(mem);</span><br><span class="line">            kfree((<span class="type">void</span>*)pa);</span><br><span class="line">            <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">            flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">            *pte = ((*pte) | flags);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br></pre></td></tr></table></figure>

<p>但是，这样做是不行的。</p>
<blockquote>
<p>会在这里卡住，会无限次不断进入kerneltrap。</p>
<p><img src="/2023/01/10/xv6/image-20230117235028133.png" alt="image-20230117235028133"></p>
</blockquote>
<p>造成这个的原因，经过一番曲折的debug之后，我发现，只要像usertrap中的syscall分支一样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重点是这里</span></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>加上这句话就行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sepc += <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>所以，结果就非常显而易见了，是因为一直卡在这句话执行不下去：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">char</span>*)va = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这是因为缺页中断会返回到原代码句中执行，所以就会继续回到这句话。而我们知道，此时正处于内核态，并没有开启地址映射，所以此处其实是非法地址越界了。但是我们的目的确实已经达到了（因为va通过stval寄存器被传递到了kerneltrap），所以我们这里只需跳过这句即可。</p>
<p>这也是为什么说我这个方法虽然实现了，但本质上其实非常流氓，不算是kerneltrap。</p>
<blockquote>
<p>Update：验收的时候跟学长说了一下这个点，学长表示不算流氓，反而在内核（至少内核赛）中算是一个比较通用的手法hh没想到还误打误撞上了</p>
<p>它带来的好处是，当地址不合法的时候可以减少开销。</p>
<p>具体来说，内核中一般会将地址空间分为多个vma，因而检查地址越界无需像xv6那样简单查页表，只需查地址是否在对应的vma中即可。所以，直接把这东西转到一个硬件的缺页中断中实现，事实上确实是减少了地址非法时的开销。</p>
</blockquote>
<p>除了这一点外，还有一点很重要的是，由于<code>walkaddr</code>是需要返回一个pa的，因而我们需要手动再把pa在缺页中断后更新一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pa = PTE2PA(*pte);</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">    *(<span class="type">char</span>*)va = <span class="number">1</span>;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pa;</span><br></pre></td></tr></table></figure>

<p>总之，做了这<strong>两个</strong>关键步骤后，也能启动了，也能过cowtest了。所以下面的代码也就贴上了这里的版本。</p>
<h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>本次实验耗时经典五小时（包含笔记时间就是六个半小时了hhh），算是平均水平。很遗憾也很难受的一点是，我的错误最终还是没有自己想出来，而是参考了别人的代码才改对的。思路很简单，但是细节也依然非常多非常坑，还是得再加把劲。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>我们只需要在fork的时候，标记父子进程的所有PTE都为read-only，然后之后就会遇到不同scause的缺页中断，针对特定的scause，新建物理页面，拷贝物理页面，然后重新设置映射即可。而对于其提出的需要标记某页是否能够释放，则需要统计每页的ref数，当ref==1的时候才可以释放。</p>
<h4 id="定义COW标记"><a href="#定义COW标记" class="headerlink" title="定义COW标记"></a>定义COW标记</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) </span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 5)</span></span><br></pre></td></tr></table></figure>

<h4 id="引用数组初始化"><a href="#引用数组初始化" class="headerlink" title="引用数组初始化"></a>引用数组初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/kalloc.c</span></span><br><span class="line"><span class="type">char</span> pages[(<span class="number">2</span>&lt;&lt;<span class="number">19</span>)];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">pages_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;pages_lock,<span class="string">&quot;pages&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(pages, <span class="number">0</span>, (<span class="number">2</span>&lt;&lt;<span class="number">19</span>));</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    pages[(uint64)p/PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="申请和释放页时增删引用"><a href="#申请和释放页时增删引用" class="headerlink" title="申请和释放页时增删引用"></a>申请和释放页时增删引用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    acquire(&amp;pages_lock);</span><br><span class="line">    <span class="comment">// 在这</span></span><br><span class="line">    pages[(uint64)r/PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;pages_lock);</span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP || pages[(uint64)pa/PGSIZE] &lt;= <span class="number">0</span> )</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  <span class="comment">// 每次kfree都会减少引用</span></span><br><span class="line">  pages[(uint64)pa/PGSIZE]--;</span><br><span class="line">  <span class="comment">// 说明此时页面还被其他东西引用着，不能释放</span></span><br><span class="line">  <span class="keyword">if</span>(pages[((uint64)pa)/PGSIZE] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pages_lock);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改fork时对页表的复制操作，并标记引用数增加"><a href="#修改fork时对页表的复制操作，并标记引用数增加" class="headerlink" title="修改fork时对页表的复制操作，并标记引用数增加"></a>修改fork时对页表的复制操作，并标记引用数增加</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/proc.c fork()</span></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(cowcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// in kernel/vm.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cowcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;cowcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;cowcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// 去除flag中的PTE_W，并且给父子的都安上没有PTE_W的flag</span></span><br><span class="line">    flags = (flags &amp; (~PTE_W));</span><br><span class="line">    flags = (flags | PTE_COW);</span><br><span class="line">    *pte = ((*pte) &amp; (~PTE_W));</span><br><span class="line">    *pte = ((*pte) | PTE_COW);</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记物理页的引用数增加</span></span><br><span class="line">    acquire(&amp;pages_lock);</span><br><span class="line">    pages[pa/PGSIZE]++;</span><br><span class="line">    release(&amp;pages_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> err:</span><br><span class="line">  <span class="comment">// 失败了不能释放物理内存</span></span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理缺页中断，标记引用数减少"><a href="#处理缺页中断，标记引用数减少" class="headerlink" title="处理缺页中断，标记引用数减少"></a>处理缺页中断，标记引用数减少</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  <span class="comment">// 只要求写入引起的缺页中断</span></span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">      flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span>* mem;</span><br><span class="line">      <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">          memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">          <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">          *pte = PA2PTE(mem);</span><br><span class="line">          <span class="comment">// 减少引用，引用归零时释放</span></span><br><span class="line">          kfree((<span class="type">void</span>*)pa);</span><br><span class="line">          <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">          flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">          *pte = ((*pte) | flags);</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uvmunmap时减少引用数"><a href="#uvmunmap时减少引用数" class="headerlink" title="uvmunmap时减少引用数"></a>uvmunmap时减少引用数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint64 pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      acquire(&amp;pages_lock);</span><br><span class="line">      <span class="keyword">if</span>(((*pte) &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">          pages[pa/PGSIZE]--;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;pages_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改walkaddr"><a href="#修改walkaddr" class="headerlink" title="修改walkaddr"></a>修改walkaddr</h4><h5 id="在walkaddr中触发缺页中断"><a href="#在walkaddr中触发缺页中断" class="headerlink" title="在walkaddr中触发缺页中断"></a>在walkaddr中触发缺页中断</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="comment">// 在这里</span></span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_COW) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 触发缺页中断</span></span><br><span class="line">      *(<span class="type">char</span>*)va = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 更新pa值</span></span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在kerneltrap内补上对缺页中断的处理"><a href="#在kerneltrap内补上对缺页中断的处理" class="headerlink" title="在kerneltrap内补上对缺页中断的处理"></a>在kerneltrap内补上对缺页中断的处理</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// 只要写入引起的缺页中断</span></span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa;</span><br><span class="line">    uint flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注意，这个很重要！！！！！</span></span><br><span class="line">        sepc += <span class="number">4</span>;</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line">                                 </span><br><span class="line">        <span class="type">char</span>* mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc())!=<span class="number">0</span>)&#123;</span><br><span class="line">            memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">            <span class="comment">// 设置为新的物理页地址</span></span><br><span class="line">            *pte = PA2PTE(mem);</span><br><span class="line">            kfree((<span class="type">void</span>*)pa);</span><br><span class="line">            <span class="comment">// 设置新的flag，标记为可写</span></span><br><span class="line">            flags = (flags | PTE_W | PTE_COW);</span><br><span class="line">            *pte = ((*pte) | flags);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>File system</title>
    <url>/2023/01/10/xv6$chap8/</url>
    <content><![CDATA[<h1 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h1><blockquote>
<p>来到指导书最高点！太美丽了xv6。哎呀那不文件系统吗（</p>
<p>这里是自底向上讲起的。之后可以看看hit网课的自顶向下。</p>
</blockquote>
<blockquote>
<p><img src="/2023/01/10/xv6/image-20230121160555370.png" alt="image-20230121160555370"></p>
</blockquote>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="/2023/01/10/xv6/image-20230121160641718.png" alt="image-20230121160641718"></p>
<blockquote>
<p>The disk layer reads and writes blocks on an virtio hard drive. </p>
<p>The buffer cache layer <strong>caches</strong> disk blocks and <strong>synchronizes</strong> access to them, making sure that only one kernel process at a time can modify the data stored in any particular block. </p>
<p>The logging layer allows higher layers to <strong>wrap updates</strong> to several blocks in a <em>transaction</em>, and ensures that the blocks are updated atomically in the face of crashes (i.e., all of them are updated or none). 【日志记录层允许更高层将更新包装到一个<em>事务</em>中的多个块，并确保在崩溃时以原子方式更新块（即，所有块都更新或不更新）。可以类比一下数据库的那个概念。】</p>
<p>The inode layer provides individual files, each represented as an <em>inode</em> with a unique i-number and some blocks holding the file’s data. </p>
<p>The directory layer implements each directory as a <strong>special kind of inode</strong> whose content is a sequence of directory entries, each of which contains a file’s name and i-number. </p>
<p>The pathname layer provides hierarchical path names like /usr/rtm/xv6/fs.c, and resolves them with <strong>recursive</strong> lookup. </p>
<p>The file descriptor layer <strong>abstracts</strong> many Unix resources (e.g., pipes, devices, fifiles, etc.) using the file system interface, simplifying the lives of application programmers.</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<blockquote>
<p>The file system must have a plan for where it stores inodes and content blocks on the disk. To do so, xv6 divides the disk into several sections, as Figure 8.2 shows.</p>
<p>The file system does not use block 0 (it holds the boot sector). </p>
<p>Block 1 is called the <strong>superblock</strong>; it contains <strong>metadata</strong> about the file system (the file system size in blocks, the number of data blocks, the number of inodes, and the number of blocks in the log). The superblock is filled in by a separate program, called <code>mkfs</code>, which builds an <strong>initial</strong> file system.</p>
<p>Blocks starting at 2 hold the log. </p>
<p>After the log are the inodes, with multiple inodes per block. </p>
<p>After those come bitmap blocks tracking which data blocks are in use. 【应该是用来标识每个块是否空闲的吧】</p>
<p>The remaining blocks are data blocks; each is either marked free in the bitmap block, or holds content for a file or directory【要么空闲要么是文件或目录】. </p>
</blockquote>
<h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><blockquote>
<p>The buffer cache has two jobs: </p>
<ol>
<li><strong>synchronize</strong> access to disk blocks to ensure that only one copy of a block is in memory and that only one kernel thread at a time uses that copy; </li>
<li><strong>cache</strong> <u>popular blocks</u> so that they don’t need to be re-read from the slow disk. </li>
</ol>
<p>The code is in <code>bio.c</code>.</p>
<p>Buffer cache中保存磁盘块的缓冲区数量固定，这意味着如果文件系统请求还未存放在缓存中的块，Buffer cache必须回收当前保存其他块内容的缓冲区。Buffer cache为新块回收最近使用最少的缓冲区。这样做的原因是认为最近使用最少的缓冲区是最不可能近期再次使用的缓冲区。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230124151719288.png" alt="image-20230124151719288"></p>
<h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?缓冲区是否包含块的副本</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?缓冲区内容是否已交给磁盘</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这应该代表着一个磁盘块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<p>大概buf数组里存储着所有buf的内容。buf本身通过最近使用排序的双向链表连接，head是链表的头。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// called by main.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  <span class="comment">// 把b插在head之后</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上层接口"><a href="#上层接口" class="headerlink" title="上层接口"></a>上层接口</h3><blockquote>
<p>The main interface exported by the buffer cache consists of <code>bread</code> and <code>bwrite</code>.</p>
<p>The buffer cache uses a per-buffer sleep-lock to ensure concurrent security.</p>
</blockquote>
<h4 id="bread"><a href="#bread" class="headerlink" title="bread"></a>bread</h4><blockquote>
<p><code>bread</code> obtains a buf containing a copy of a block which can be read or modified in memory.</p>
<p>依据给定设备号和给定扇区号寻找cache的buf。返回的buf是locked的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return a locked buf with the contents of the indicated block.</span></span><br><span class="line"><span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取buf块</span></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line">    <span class="comment">// 说明cache未命中，需要从磁盘读入</span></span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bwrite"><a href="#bwrite" class="headerlink" title="bwrite"></a>bwrite</h4><blockquote>
<p>writes a modified buffer to the appropriate block on the disk</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 必须持有b的锁</span></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  <span class="comment">// 写入磁盘</span></span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="brelse"><a href="#brelse" class="headerlink" title="brelse"></a>brelse</h4><blockquote>
<p> A kernel thread must release a buffer by calling brelse when it is done with it.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    <span class="comment">// 移动到头结点和头结点的下一个结点之间的位置</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><h4 id="bget"><a href="#bget" class="headerlink" title="bget"></a>bget</h4><p>用于获取cache中是否存在block。如果不存在，则新申请一个buf，并把该buf以上锁状态返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="comment">// 这个循环条件很有意思，充分用到了双向链表的特性</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      <span class="comment">// 引用数增加</span></span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      <span class="comment">// 锁定</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="comment">// 从尾部开始遍历，确实就是最少使用的了</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="comment">// 如果该buf空闲</span></span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      <span class="comment">// 仅是新建了一个buf，还未从磁盘读取对应磁盘块的副本，因而设valid为0以供上层函数调用处理</span></span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      <span class="comment">// 锁定</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cache不够用了</span></span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Logging-layer"><a href="#Logging-layer" class="headerlink" title="Logging layer"></a>Logging layer</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>Xv6通过简单的日志记录形式解决了文件系统操作期间的崩溃问题。</p>
<p>xv6系统调用不会直接写入磁盘上的文件系统数据结构。相反，它会在磁盘上的<em>log</em>（日志）中放置它希望进行的所有磁盘写入的描述。一旦系统调用记录了它的所有写入操作，它就会向磁盘写入一条特殊的<em>commit</em>（提交）记录，表明日志包含一个完整的操作。此时，系统调用将写操作复制到磁盘上的文件系统数据结构。完成这些写入后，系统调用将擦除磁盘上的日志。</p>
</blockquote>
<blockquote>
<p>如果系统崩溃并重新启动，则在运行任何进程之前，文件系统代码将按如下方式从崩溃中恢复：</p>
<p>如果日志标记为包含完整操作，则恢复代码会将写操作复制到磁盘文件系统中它们所属的位置，然后擦除日志。如果日志没有标记为包含完整操作，则恢复代码将忽略该日志，然后擦除日志。</p>
</blockquote>
<p>这就保证了原子性。</p>
<h3 id="Log-design"><a href="#Log-design" class="headerlink" title="Log design"></a>Log design</h3><p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<p>superblock记录了log的存储位置。</p>
<blockquote>
<p>它由一个头块（header block）和一系列更新块的副本（logged block）组成。</p>
<p>头块包含一个扇区号（sector）数组（每个logged block对应一个扇区号）以及日志块的计数。</p>
<p>磁盘上的头块中的计数为零表示日志中没有事务，为非零表示日志包含一个完整的已提交事务，并具有指定数量的logged block。</p>
<p>在事务提交（commit）时Xv6才向头块写入数据，在此之前不会写入。在将logged blocks复制到文件系统后，头块的计数将被设置为零。</p>
<p>因此，事务中途崩溃将导致日志头块中的计数为零；提交后的崩溃将导致非零计数。</p>
</blockquote>
<blockquote>
<p>为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写入累积到一个事务中。因此，单个提交可能涉及多个完整系统调用的写入。为了避免在事务之间拆分系统调用，日志系统仅在没有文件系统调用进行时提交。</p>
<p>同时提交多个事务的想法称为组提交（group commit）。组提交减少了磁盘操作的数量，因为成本固定的一次提交分摊了多个操作。组提交还同时为磁盘系统提供更多并发写操作，可能允许磁盘在一个磁盘旋转时间内写入所有这些操作。Xv6的virtio驱动程序不支持这种批处理，但是Xv6的文件系统设计允许这样做。</p>
<p>【这感觉实现得也还挺简略的】</p>
</blockquote>
<blockquote>
<p>Xv6在磁盘上留出固定的空间来保存日志。事务中系统调用写入的块总数必须可容纳于该空间。这导致两个后果：</p>
<ol>
<li><p>任何单个系统调用都不允许写入超过日志空间的不同块。</p>
<p>【这段话我一个字没看懂】</p>
<p>这对于大多数系统调用来说都不是问题，但其中两个可能会写入许多块：<code>write</code>和<code>unlink</code>。一个大文件的<code>write</code>可以写入多个数据块和多个位图块以及一个inode块；<code>unlink</code>大文件可能会写入许多位图块和inode。Xv6的<code>write</code>系统调用将大的写入分解为适合日志的多个较小的写入，<code>unlink</code>不会导致此问题，因为实际上Xv6文件系统只使用一个位图块。</p>
</li>
<li><p>日志空间有限的另一个后果是，除非确定系统调用的写入将可容纳于日志中剩余的空间，否则日志系统无法允许启动系统调用。</p>
</li>
</ol>
</blockquote>
<h3 id="Code-logging"><a href="#Code-logging" class="headerlink" title="Code: logging"></a>Code: logging</h3><blockquote>
<p>log的原理是这样的：</p>
<p>在每个系统调用的开始调用<code>begin_op</code>表示事务开始，然后之后新申请一块block，也即把该block的内容读入内存，并且把该block的blockno记录到log的header中。此后程序正常修改在内存中的block，磁盘中的block保持不变。最后commit的时候遍历log header中的blockno，一块块地把内存中的block写入日志和磁盘中。</p>
<p>如果程序在commit前崩溃，则内存消失，同时磁盘也不会写入；如果在commit后崩溃，那也无事发生。</p>
<p>在每次启动的时候，都会执行log的初始化，届时可以顺便恢复数据。</p>
<p>完美实现了日志的功能。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230123212753931.png" alt="image-20230123212753931"></p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Contents of the header block, used for both the on-disk header block</span></span><br><span class="line"><span class="comment">// and to keep track in memory of logged block# before commit.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="comment">// 扇区号也即blockno的数组</span></span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表log磁盘块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> start;<span class="comment">// log磁盘块的开始。start开始的第一块为log header，之后皆为写入的block</span></span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// how many FS sys calls are executing.</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// in commit(), please wait.</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h4><h5 id="begin-op"><a href="#begin-op" class="headerlink" title="begin_op()"></a>begin_op()</h5><blockquote>
<p><code>begin_op</code>等待直到日志系统当前未处于提交中，并且直到有足够的未被占用的日志空间来保存此调用的写入。</p>
<p><code>log.outstanding</code>统计<strong>预定了日志空间</strong>的系统调用数；为此保留的总空间为<code>log.outstanding</code>乘以<code>MAXOPBLOCKS</code>（10）。递增<code>log.outstanding</code>会预定空间并防止在此系统调用期间发生提交（if的第二个分支）。代码保守地假设每个系统调用最多可以写入<code>MAXOPBLOCKS</code>（10）个不同的块。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// called at the start of each FS system call.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">begin_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 正在提交则等待日志空闲</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;</span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="comment">// 日志空间不足则等待空间充足</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">// this op might exhaust log space此操作可能会耗尽日志空间; wait for commit.</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="log-write"><a href="#log-write" class="headerlink" title="log_write"></a>log_write</h5><blockquote>
<p><code>log_write</code>充当<code>bwrite</code>的代理。它将块的扇区号记录在内存中，在磁盘上的日志中预定一个槽位，并调用<code>bpin</code>将缓存固定在block cache中，以防止block cache将其逐出【具体原理就是让refcnt++，这样就不会被当成空闲block用掉了】。</p>
<p>为啥要防止换出呢？换出不是就正好自动写入磁盘了吗？这里一是为了保障前面提到的原子性，防止换入换出导致的单一写入磁盘；二是换出自动写入的是磁盘对应位而不一定是日志所在的blocks。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">log_write</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log</span></span><br><span class="line">  <span class="comment">// 30</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="comment">// log_write会注意到在单个事务中多次写入一个块的情况，并在日志中为该块分配相同的槽位。</span></span><br><span class="line">  <span class="comment">// 这种优化通常称为合并（absorption）</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorbtion</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里还是挺巧妙的。</span></span><br><span class="line">  <span class="comment">// 如果存在log.lh.block[i] == b-&gt;blockno的情况，执行此句话也无妨</span></span><br><span class="line">  <span class="comment">// 如果不存在，则给log新增一块，填入log.lh.block[log.lh.n]的位置，再++log.lh.n</span></span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log?</span></span><br><span class="line">    bpin(b);</span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="end-op"><a href="#end-op" class="headerlink" title="end_op"></a>end_op</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// called at the end of each FS system call.</span></span><br><span class="line"><span class="comment">// 如果这是最后一层outstanding就会执行commit操作</span></span><br><span class="line"><span class="comment">// commits if this was the last outstanding operation.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// begin_op() may be waiting for log space,</span></span><br><span class="line">    <span class="comment">// and decrementing log.outstanding has decreased</span></span><br><span class="line">    <span class="comment">// the amount of reserved space.</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    <span class="comment">// call commit w/o holding locks, since not allowed</span></span><br><span class="line">    <span class="comment">// to sleep with locks.</span></span><br><span class="line">    commit();</span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// cache -&gt; log block</span></span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    <span class="comment">// head(in stack/heap) -&gt; log block</span></span><br><span class="line">    <span class="comment">// 此可以说为commit完成的标志。</span></span><br><span class="line">    <span class="comment">// 因为无论接下来是否崩溃，数据最终都会被写入disk，不同在于是在recover时还是接下来写入</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    <span class="comment">// log block -&gt; real position</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 擦除</span></span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="write-log"><a href="#write-log" class="headerlink" title="write_log"></a>write_log</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy modified blocks from cache to log.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">    brelse(from);<span class="comment">// 此处的brelse呼应了外界调用的bread</span></span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="write-head"><a href="#write-head" class="headerlink" title="write_head"></a>write_head</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write in-memory log header to disk.</span></span><br><span class="line"><span class="comment">// 这是事务提交的标志</span></span><br><span class="line"><span class="comment">// This is the true point at which the</span></span><br><span class="line"><span class="comment">// current transaction commits.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf);</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="install-trans"><a href="#install-trans" class="headerlink" title="install_trans"></a>install_trans</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy committed blocks from log to their home location</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">install_trans</span><span class="params">(<span class="type">int</span> recovering)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// read log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// read dst</span></span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="comment">// copy block to dst</span></span><br><span class="line">    bwrite(dbuf);  <span class="comment">// write dst to disk</span></span><br><span class="line">    <span class="keyword">if</span>(recovering == <span class="number">0</span>)</span><br><span class="line">      bunpin(dbuf);<span class="comment">// 如果不是在recover的过程中</span></span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="恢复与初始化"><a href="#恢复与初始化" class="headerlink" title="恢复与初始化"></a>恢复与初始化</h4><p>上面介绍了log的一次事务提交的流程。接下来介绍它是怎么恢复的。</p>
<blockquote>
<p><code>recover_from_log</code>是由<code>initlog</code>调用的，而它又是在第一个用户进程运行之前的引导期间由<code>fsinit</code>调用的。</p>
</blockquote>
<h5 id="第一个进程运行之前"><a href="#第一个进程运行之前" class="headerlink" title="第一个进程运行之前"></a>第一个进程运行之前</h5><p>由前面scheduler一章的知识可知，每个进程被初次调度的时候会先来执行<code>forkret</code>。这时候就做了log的恢复工作。</p>
<p>注释解释了为什么不选择在<code>main.c</code>中初始化，而选择在此处初始化。确实，它需要调用sleep，如果在main.c中调用sleep感觉会乱套（）毕竟那时候scheduler线程尚未被初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A fork child&#x27;s very first scheduling by scheduler()</span></span><br><span class="line"><span class="comment">// will swtch to forkret.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// static变量仅会被初始化一次</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Still holding p-&gt;lock from scheduler.</span></span><br><span class="line">  release(&amp;myproc()-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是第一个进程</span></span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    <span class="comment">// File system initialization must be run in the context of a</span></span><br><span class="line">    <span class="comment">// regular process (e.g., because it calls sleep), and thus cannot</span></span><br><span class="line">    <span class="comment">// be run from main().</span></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    fsinit(ROOTDEV);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fsinit"><a href="#fsinit" class="headerlink" title="fsinit"></a>fsinit</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Init fs</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fsinit</span><span class="params">(<span class="type">int</span> dev)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  initlog(dev, &amp;sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="initlog"><a href="#initlog" class="headerlink" title="initlog"></a>initlog</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlog</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> logheader) &gt;= BSIZE)</span><br><span class="line">    panic(<span class="string">&quot;initlog: too big logheader&quot;</span>);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;<span class="built_in">log</span>.lock, <span class="string">&quot;log&quot;</span>);</span><br><span class="line">  <span class="comment">// 从super block中获取必要参数</span></span><br><span class="line">  <span class="built_in">log</span>.start = sb-&gt;logstart;</span><br><span class="line">  <span class="built_in">log</span>.size = sb-&gt;nlog;</span><br><span class="line">  <span class="built_in">log</span>.dev = dev;</span><br><span class="line">  recover_from_log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="recover-from-log"><a href="#recover-from-log" class="headerlink" title="recover_from_log"></a>recover_from_log</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 读取head</span></span><br><span class="line">  read_head();</span><br><span class="line">  <span class="comment">// 注意，commit中会把header写入log block，而这里从log block读出header</span></span><br><span class="line">  <span class="comment">// 也就是说，如果header的n不为零，那么说明已经commit了，但可能未写入，重复写入保障安全</span></span><br><span class="line">  <span class="comment">// 如果header的n为零，说明未commit，在install_trans的逻辑中会什么也不做</span></span><br><span class="line">  <span class="comment">// 两种情况完美满足</span></span><br><span class="line">  install_trans(<span class="number">1</span>); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 擦除</span></span><br><span class="line">  write_head(); <span class="comment">// clear the log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Block-allocator"><a href="#Code-Block-allocator" class="headerlink" title="Code: Block allocator"></a>Code: Block allocator</h2><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>说实话没怎么懂，也不大清楚它有什么用，先大概推测一下：</p>
<p>之前的bread和bwrite这些，就是你给一个设备号和扇区号，它就帮你加载进内存cache。你如果要用的话，肯定还是使用地址方便。所以block allocator的作用之一就是给bread和bwrite加一层封装，将获取的block封装为地址返回，你可以直接操纵这个地址，<strong>而无需知道下层的细节。</strong></p>
<p>这个过程要注意的有两点：</p>
<ol>
<li><p>封装返回的地址具体是什么，怎么工作的</p>
<p>封装返回的地址实质上是buffer cache中的buf的data字段的地址【差不多】。之后的上层应用在该地址上写入，也即写入了buf，最后会通过log层真正写入磁盘。</p>
</li>
<li><p>结合bcache的LRU，详细谈谈工作机制</p>
<p>我们可以看到，在balloc中有这么一段逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> b + bi;</span><br></pre></td></tr></table></figure>

<p>看到的第一反应就是，我们需求的那块buf是bp，但是这里先是bread了一次，又是brelse了一次，这样bp的refcnt不就为0，很容易被替换掉了吗？</p>
<p>会有这个反应，一定程度上是因为没有很好地理解LRU。事实上，正是它可能被替换掉，才满足了LRU的条件。因为它可能被替掉才能说明它可能是最近最少使用的。</p>
</li>
</ol>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><blockquote>
<p>文件和目录内容存储在磁盘块中，磁盘块必须从空闲池中分配。xv6的块分配器在磁盘上维护一个空闲位图，每一位代表一个块。0表示对应的块是空闲的；1表示它正在使用中。</p>
<p>引导扇区、超级块、日志块、inode块和位图块的比特位是由程序<code>mkfs</code>初始化设置的：</p>
<p><img src="/2023/01/10/xv6/image-20230123234919055.png" alt="image-20230123234919055"></p>
</blockquote>
<h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3><p>类似于memory allocator，块分配器也提供了两个函数：<code>bfree</code>和<code>balloc</code>。</p>
<h4 id="balloc"><a href="#balloc" class="headerlink" title="balloc"></a>balloc</h4><blockquote>
<p><code>Balloc</code>从块0到<code>sb.size</code>（文件系统中的块数）遍历每个块。它查找位图中位为零的空闲块。如果<code>balloc</code>找到这样一个块，它将更新位图并返回该块。</p>
<p>为了提高效率，循环被分成两部分。外部循环读取位图中的每个块。内部循环检查单个位图块中的所有BPB位。由于任何一个位图块在buffer cache中一次只允许一个进程使用【<code> bread(dev, BBLOCK(b, sb))</code>会返回一个上锁的block，<code>bread</code>和<code>brelse</code>隐含的独占使用避免了显式锁定的需要】，因此，如果两个进程同时尝试分配一个块也是并发安全的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a zeroed disk block.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">balloc</span><span class="params">(uint dev)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> b, bi, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  bp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(b = <span class="number">0</span>; b &lt; sb.size; b += BPB)&#123;</span><br><span class="line">    bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">    <span class="keyword">for</span>(bi = <span class="number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;</span><br><span class="line">      m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)&#123;  <span class="comment">// Is block free?</span></span><br><span class="line">        bp-&gt;data[bi/<span class="number">8</span>] |= m;  <span class="comment">// Mark block in use.</span></span><br><span class="line">        log_write(bp);</span><br><span class="line">        brelse(bp);</span><br><span class="line">        bzero(dev, b + bi);</span><br><span class="line">        <span class="keyword">return</span> b + bi;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;balloc: out of blocks&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bfree"><a href="#bfree" class="headerlink" title="bfree"></a>bfree</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Free a disk block.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="type">int</span> bi, m;</span><br><span class="line"></span><br><span class="line">  bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">  bi = b % BPB;</span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">  bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Inode-layer"><a href="#Inode-layer" class="headerlink" title="Inode layer"></a>Inode layer</h2><h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><blockquote>
<p>术语inode（即索引结点）可以具有两种相关含义之一。它可能是指包含文件大小和数据块编号列表的磁盘上的数据结构【on-disk inode】。或者“inode”可能指内存中的inode【in-memory inode】，它包含磁盘上inode的副本以及内核中所需的额外信息。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<h4 id="on-disk-inode"><a href="#on-disk-inode" class="headerlink" title="on-disk inode"></a>on-disk inode</h4><blockquote>
<p>The on-disk inodes are packed into a contiguous area of disk called the inode blocks. </p>
<p>Every inode is the <strong>same size,</strong> so it is easy, given a number n, to find the nth inode on the disk. In fact, this number n, called the <strong>inode number</strong> or <strong>i-number</strong>, is how inodes are <strong>identifified</strong> in the implementation.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in fs.h</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 为0表示free</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="comment">//  The nlink field counts the number of directory entries that refer to this inode,</span></span><br><span class="line">  <span class="comment">//  in order to recognize when the on-disk inode and its data blocks should be freed.</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="in-memory-inode"><a href="#in-memory-inode" class="headerlink" title="in-memory inode"></a>in-memory inode</h4><blockquote>
<p>The kernel keeps the set of active inodes in memory.</p>
<p>The kernel stores an inode in memory <strong>only</strong> if there are C pointers referring to that inode.当且仅当ref==0才会从内核中释放。</p>
<p>如果nlinks==0就会从物理block中释放。</p>
<p>The <code>iget</code> and <code>iput</code> functions acquire and release pointers to an inode, modifying the reference count.【相当于buffer cache的<code>balloc</code>和<code>bfree</code>】Pointers to an inode can come from file descriptors, current working directories, and transient kernel code such as exec.</p>
<p><code>iget</code>返回的<code>struct inode</code>可能没有任何有用的内容。为了确保它保存磁盘inode的副本，代码必须调用<code>ilock</code>。这将锁定inode（以便没有其他进程可以对其进行<code>ilock</code>），并从磁盘读取尚未读取的inode。<code>iunlock</code>释放inode上的锁。将inode指针的获取与锁定分离有助于在某些情况下避免死锁，例如在目录查找期间。多个进程可以持有指向<code>iget</code>返回的inode的C指针，但一次只能有一个进程锁定inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];<span class="comment">// 存储着inode数据的blocks的地址，从balloc中获取</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Code-inode"><a href="#Code-inode" class="headerlink" title="Code: inode"></a>Code: inode</h3><blockquote>
<p>主要是在讲inode layer这一层的方法，以及给上层提供的接口。</p>
</blockquote>
<h4 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h4><p><img src="/2023/01/10/xv6/image-20230124153309132.png" alt="image-20230124153309132"></p>
<h4 id="底层接口"><a href="#底层接口" class="headerlink" title="底层接口"></a>底层接口</h4><blockquote>
<p><code>iget</code> <code>iput</code> </p>
</blockquote>
<h5 id="iget"><a href="#iget" class="headerlink" title="iget"></a>iget</h5><p>逻辑还是跟buffer cache非常相似的，不过可以看出这个的数据结构简单许多，也不用实现LRU。</p>
<blockquote>
<p>A struct inode pointer returned by iget() is <strong>guaranteed to be valid</strong> until the corresponding call to iput()： the inode <u>won’t be deleted</u>, and the memory referred to by the pointer <u>won’t be re-used</u> for a different inode. 【通过ref++实现。】</p>
<p>不同于buffer cache的<code>bget</code>，<code>iget()</code>提供对inode的非独占访问，因此可以有许多指向同一inode的指针。文件系统代码的许多部分都依赖于<code>iget()</code>的这种行为，既可以保存对inode的长期引用（如打开的文件和当前目录），也可以防止争用，同时避免操纵多个inode（如路径名查找）的代码产生死锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find the inode with number inum on device dev</span></span><br><span class="line"><span class="comment">// and return the in-memory copy. Does not lock</span></span><br><span class="line"><span class="comment">// the inode and does not read it from disk.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">iget</span><span class="params">(uint dev, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the inode already cached?</span></span><br><span class="line">  empty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ip = &amp;icache.inode[<span class="number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">      ip-&gt;ref++;</span><br><span class="line">      release(&amp;icache.lock);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于不用实现LRU，所以只需一次循环记录即可。</span></span><br><span class="line">    <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// Remember empty slot.</span></span><br><span class="line">      empty = ip;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recycle an inode cache entry.</span></span><br><span class="line">  <span class="keyword">if</span>(empty == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;iget: no inodes&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ip = empty;</span><br><span class="line">  ip-&gt;dev = dev;</span><br><span class="line">  ip-&gt;inum = inum;</span><br><span class="line">  ip-&gt;ref = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// does not read from disk</span></span><br><span class="line">  ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="iput"><a href="#iput" class="headerlink" title="iput"></a>iput</h5><blockquote>
<p><code>iput()</code>可以写入磁盘。这意味着任何使用文件系统的系统调用都可能写入磁盘，因为系统调用可能是最后一个引用该文件的系统调用。即使像<code>read()</code>这样看起来是只读的调用，也可能最终调用<code>iput()</code>。这反过来意味着，即使是只读系统调用，如果它们使用文件系统，也必须在事务中进行包装。</p>
<p><code>iput()</code>和崩溃之间存在一种具有挑战性的交互。<code>iput()</code>不会在文件的链接计数降至零时立即截断文件，因为某些进程可能仍在内存中保留对inode的引用：进程可能仍在读取和写入该文件，因为它已成功打开该文件。但是，如果在最后一个进程关闭该文件的文件描述符之前发生崩溃，则该文件将被标记为已在磁盘上分配，但没有目录项指向它。如果不做任何处理措施的话，这块磁盘就再也用不了了。</p>
<p>文件系统以两种方式之一处理这种情况。简单的解决方案用于恢复时：重新启动后，文件系统会扫描整个文件系统，以查找标记为已分配但没有指向它们的目录项的文件。如果存在任何此类文件，接下来可以将其释放。</p>
<p>第二种解决方案不需要扫描文件系统。在此解决方案中，文件系统在磁盘（例如在超级块中）上记录链接计数降至零但引用计数不为零的文件的i-number。如果文件系统在其引用计数达到0时删除该文件，则会通过从列表中删除该inode来更新磁盘列表。重新启动时，文件系统将释放列表中的所有文件。</p>
<p>Xv6没有实现这两种解决方案，这意味着inode可能被标记为已在磁盘上分配，即使它们不再使用。这意味着随着时间的推移，xv6可能会面临磁盘空间不足的风险。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Drop a reference to an in-memory inode.</span></span><br><span class="line"><span class="comment">// If that was the last reference, the inode cache entry can</span></span><br><span class="line"><span class="comment">// be recycled.【refvnt==0 可以回收】</span></span><br><span class="line"><span class="comment">// 注意这个回收过程无需特别处理，只需自然--refcnt就行，不用像buffer cache那么烦</span></span><br><span class="line"><span class="comment">// If that was the last reference and the inode has no links</span></span><br><span class="line"><span class="comment">// to it, free the inode (and its content) on disk.【nlinks==0 copy和本体都得扔掉】</span></span><br><span class="line"><span class="comment">// All calls to iput() must be inside a transaction in</span></span><br><span class="line"><span class="comment">// case it has to free the inode.任何需要iput的地方都需要包裹在事务内，因为它可能会释放inode</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;ref == <span class="number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// inode has no links and no other references: truncate and free.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ip-&gt;ref == 1 means no other process can have ip locked,</span></span><br><span class="line">    <span class="comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span></span><br><span class="line">    acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    release(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终调用bfree，会标记bitmap，完全释放block</span></span><br><span class="line">    itrunc(ip);</span><br><span class="line">    ip-&gt;type = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/*iupdate:</span></span><br><span class="line"><span class="comment">    // Copy a modified in-memory inode to disk.</span></span><br><span class="line"><span class="comment">    // Must be called after every change to an ip-&gt;xxx field</span></span><br><span class="line"><span class="comment">	// that lives on disk, since i-node cache is write-through.</span></span><br><span class="line"><span class="comment">	write-through:</span></span><br><span class="line"><span class="comment">	CPU向cache写入数据时，同时向memory(后端存储)也写一份，使cache和memory的数据保持一致。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 这里修改的type是dinode也有的字段，所以需要update一下。</span></span><br><span class="line">    <span class="comment">// 下面的valid是dinode没有的字段，所以随便改，无需update</span></span><br><span class="line">    iupdate(ip);</span><br><span class="line">    ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    releasesleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;icache.lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;ref--;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上层接口-1"><a href="#上层接口-1" class="headerlink" title="上层接口"></a>上层接口</h4><h5 id="获取和释放inode"><a href="#获取和释放inode" class="headerlink" title="获取和释放inode"></a>获取和释放inode</h5><h6 id="ialloc"><a href="#ialloc" class="headerlink" title="ialloc"></a>ialloc</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate an inode on device dev.</span></span><br><span class="line"><span class="comment">// Mark it as allocated by  giving it type type.</span></span><br><span class="line"><span class="comment">// Returns an unlocked but allocated and referenced inode.</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">ialloc</span><span class="params">(uint dev, <span class="type">short</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;</span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// a free inode通过type判断是否free</span></span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));<span class="comment">// zerod</span></span><br><span class="line">      dip-&gt;type = type;</span><br><span class="line">      log_write(bp);   <span class="comment">// mark it allocated on the disk</span></span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;ialloc: no inodes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="inode的锁保护"><a href="#inode的锁保护" class="headerlink" title="inode的锁保护"></a>inode的锁保护</h5><p>前面说到，inode的设计使得有多个指针同时指向一个inode成为了可能。因而，修改使用inode的时候就要对其进行独占访问。使用<code>ialloc</code>获取和用<code>ifree</code>释放的inode必须被保护在<code>ilock</code>和<code>iunlock</code>区域中。</p>
<h6 id="ilock"><a href="#ilock" class="headerlink" title="ilock"></a>ilock</h6><p><code>ilock</code>既可以实现对inode的独占访问，同时也可以给未初始化的inode进行初始化工作。</p>
<blockquote>
<p><code>iget</code>返回的<code>struct inode</code>可能没有任何有用的内容。为了确保它保存磁盘inode的副本，代码必须调用<code>ilock</code>。这将锁定inode（以便没有其他进程可以对其进行<code>ilock</code>），并从磁盘读取尚未读取的inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock the given inode and reads the inode from disk if necessary.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ilock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;ilock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 通过inode索引号和superblock算出扇区号</span></span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    <span class="comment">// 填充ip</span></span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">    ip-&gt;major = dip-&gt;major;</span><br><span class="line">    ip-&gt;minor = dip-&gt;minor;</span><br><span class="line">    ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="iunlock"><a href="#iunlock" class="headerlink" title="iunlock"></a>iunlock</h6><blockquote>
<p><code>iunlock</code>释放inode上的锁。</p>
<p>将inode指针的获取与锁定分离有助于在某些情况下避免死锁，例如在目录查找期间。多个进程可以持有指向<code>iget</code>返回的inode的C指针，但一次只能有一个进程锁定inode。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unlock the given inode.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iunlock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;iunlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Code-inode-content"><a href="#Code-inode-content" class="headerlink" title="Code: inode content"></a>Code: inode content</h3><h4 id="Overview-2"><a href="#Overview-2" class="headerlink" title="Overview"></a>Overview</h4><blockquote>
<p>主要讲的是inode本身存储数据的结构</p>
</blockquote>
<blockquote>
<p>磁盘上的inode结构体<code>struct dinode</code>包含一个<code>size</code>和一个块号数组（见图8.3），数组内罗列着存储着该inode数据的块号。</p>
<p>前面的<code>NDIRECT</code>个数据块被列在数组中的前<code>NDIRECT</code>个元素中；这些块称为直接块（direct blocks）。接下来的<code>NINDIRECT</code>个数据块不在inode中列出，而是在称为间接块（indirect block）的数据块中列出。<code>addrs</code>数组中的最后一个元素给出了间接块的地址。</p>
<p>因此，可以从inode中列出的块加载文件的前12 kB（<code>NDIRECT x BSIZE</code>）字节，而只有在查阅间接块后才能加载下一个256 kB（<code>NINDIRECT x BSIZE</code>）字节。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/10/xv6/image-20230124163025094.png" alt="image-20230124163025094"></p>
<h4 id="bmap"><a href="#bmap" class="headerlink" title="bmap"></a>bmap</h4><blockquote>
<p>函数<code>bmap</code>负责封装这个寻找数据块的过程，以便实现我们将很快看到的如<code>readi</code>和<code>writei</code>这样的更高级例程。</p>
<p><code>bmap(struct inode *ip, uint bn)</code>返回inode<code>ip</code>的第<code>bn</code>个数据块的磁盘块号。如果<code>ip</code>还没有这样的块，<code>bmap</code>会分配一个。</p>
<p><code>Bmap</code>使<code>readi</code>和<code>writei</code>很容易获取inode的数据。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inode content</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The content (data) associated with each inode is stored</span></span><br><span class="line"><span class="comment">// in blocks on the disk. The first NDIRECT block numbers</span></span><br><span class="line"><span class="comment">// are listed in ip-&gt;addrs[].  The next NINDIRECT blocks are</span></span><br><span class="line"><span class="comment">// listed in block ip-&gt;addrs[NDIRECT].</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip.</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果为direct block</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 如果为indirect block</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 如果没有，会分配一个</span></span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="itrunc"><a href="#itrunc" class="headerlink" title="itrunc"></a>itrunc</h4><blockquote>
<p><code>itrunc</code>释放文件的块，将inode的<code>size</code>重置为零。</p>
<p><code>Itrunc</code>首先释放直接块，然后释放间接块中列出的块，最后释放间接块本身。</p>
</blockquote>
<h4 id="readi"><a href="#readi" class="headerlink" title="readi"></a>readi</h4><blockquote>
<p><code>readi</code>和<code>writei</code>都是从检查<code>ip-&gt;type == T_DEV</code>开始的。这种情况处理的是数据不在文件系统中的特殊设备；我们将在文件描述符层返回到这种情况。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read data from inode.数据大小为n，从off开始，读到dst处</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="comment">// If user_dst==1, then dst is a user virtual address;</span></span><br><span class="line"><span class="comment">// otherwise, dst is a kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">readi</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; ip-&gt;size)</span><br><span class="line">    n = ip-&gt;size - off;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主循环处理文件的每个块，将数据从缓冲区复制到dst</span></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      tot = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="writei"><a href="#writei" class="headerlink" title="writei"></a>writei</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write data to inode.</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="comment">// If user_src==1, then src is a user virtual address;</span></span><br><span class="line"><span class="comment">// otherwise, src is a kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">writei</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_src, uint64 src, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// writei会自动增长文件，除非达到文件的最大大小</span></span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; MAXFILE*BSIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      n = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(off &gt; ip-&gt;size)</span><br><span class="line">      <span class="comment">// 说明扩大了文件大小，需要修改</span></span><br><span class="line">      ip-&gt;size = off;</span><br><span class="line">    <span class="comment">// write the i-node back to disk even if the size didn&#x27;t change</span></span><br><span class="line">    <span class="comment">// because the loop above might have called bmap() and added a new</span></span><br><span class="line">    <span class="comment">// block to ip-&gt;addrs[].</span></span><br><span class="line">    iupdate(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stati"><a href="#stati" class="headerlink" title="stati"></a>stati</h4><blockquote>
<p>函数<code>stati</code>将inode元数据复制到<code>stat</code>结构体中，该结构通过<code>stat</code>系统调用向用户程序公开。</p>
</blockquote>
<p>在<code>defs.h</code>中可看到inode结构体是private的，而stat是public的。</p>
<h2 id="Directory-layer"><a href="#Directory-layer" class="headerlink" title="Directory layer"></a>Directory layer</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>目录的内部实现很像文件。其inode的<code>type</code>为<code>T_DIR</code>，其数据是directory entries的集合。</p>
<p>每个entry都是一个<code>struct dirent</code>。</p>
</blockquote>
<p><strong>也就是说这一层其实本质上是一个大小一定的map</strong>，该map自身也存放在inode中，大小为inode的大小，每个表项entry<strong>映射了目录名和文件inode</strong>。所以接下来介绍的函数我们完全可以从hashmap增删改查的角度去理解。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;<span class="comment">// 如果为0，说明该entry free</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/10/xv6/image-20230124173241241.png" alt="image-20230124173241241"></p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><h4 id="dirlookup"><a href="#dirlookup" class="headerlink" title="dirlookup"></a>dirlookup</h4><blockquote>
<p>函数<code>dirlookup</code>在directory中搜索具有给定名称的entry。</p>
<p>它返回的指向enrty.inum相应的inode是非独占的【通过iget获取】，也即无锁状态。它还会把<code>*poff</code>设置为所需的entry的字节偏移量。</p>
<p>为什么要返回未锁定的inode？是因为调用者已锁定<code>dp</code>，因此，如果对<code>.</code>进行查找，则在返回之前尝试锁定inode将导致重新锁定<code>dp</code>并产生死锁【确实】(还有更复杂的死锁场景，涉及多个进程和<code>..</code>，父目录的别名。<code>.</code>不是唯一的问题。）</p>
<p>所以锁定交给caller来做。caller可以解锁<code>dp</code>，然后锁定该函数返回的<code>ip</code>，确保它一次只持有一个锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Look for a directory entry in a directory.</span></span><br><span class="line"><span class="comment">// If found, set *poff to byte offset of entry.</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">dirlookup</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint *poff)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint off, inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;type != T_DIR)</span><br><span class="line">    panic(<span class="string">&quot;dirlookup not DIR&quot;</span>);</span><br><span class="line">  <span class="comment">// new level of abstraction,可以把directory的inode看作一个表文件，每个表项都是一个entry</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="comment">// 从directory中获取entry，也即从inode中获取数据</span></span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlookup read&quot;</span>);</span><br><span class="line">    <span class="comment">// free</span></span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(namecmp(name, de.name) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// entry matches path element</span></span><br><span class="line">      <span class="keyword">if</span>(poff)</span><br><span class="line">        *poff = off;</span><br><span class="line">      inum = de.inum;</span><br><span class="line">      <span class="keyword">return</span> iget(dp-&gt;dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dirlink"><a href="#dirlink" class="headerlink" title="dirlink"></a>dirlink</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write a new directory entry (name, inum) into the directory dp.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dirlink</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that name is not present.</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Look for an empty dirent.</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlink read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没找到空闲的则调用writei自动增长inode，添加新表项</span></span><br><span class="line">  <span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">  de.inum = inum;</span><br><span class="line">  <span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">    panic(<span class="string">&quot;dirlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pathname-layer"><a href="#Pathname-layer" class="headerlink" title="Pathname layer"></a>Pathname layer</h2><blockquote>
<p>Path name lookup involves a succession of calls to dirlookup, one for each path component.</p>
</blockquote>
<h3 id="namei和nameiparent"><a href="#namei和nameiparent" class="headerlink" title="namei和nameiparent"></a>namei和nameiparent</h3><blockquote>
<p>Namei (kernel/fs.c:661) evaluates path and returns the corresponding inode.</p>
<p>函数<code>nameiparent</code>是一个变体：它在最后一个元素之前停止，返回父目录的inode并将最后一个元素复制到<code>name</code>中。两者都调用通用函数<code>namex</code>来完成实际工作。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">0</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">1</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="namex"><a href="#namex" class="headerlink" title="namex"></a>namex</h3><blockquote>
<p><code>Namex</code>首先决定路径解析的开始位置。</p>
<p>如果路径以“ / ”开始，则从根目录开始解析；否则，从当前目录开始。</p>
<p>然后，它使用<code>skipelem</code>依次考察路径的每个元素。循环的每次迭代都必须在当前索引结点<code>ip</code>中查找<code>name</code>。</p>
<p>迭代首先给<code>ip</code>上锁并检查它是否是一个目录。如果不是，则查找失败。</p>
<p>如果caller是<code>nameiparent</code>，并且这是最后一个路径元素，则根据<code>nameiparent</code>的定义，循环会提前停止；最后一个路径元素已经复制到<code>name</code>中【在上一轮循坏中做了这件事】，因此<code>namex</code>只需返回解锁的<code>ip</code>。</p>
<p>最后，循环将使用<code>dirlookup</code>查找路径元素，并通过设置<code>ip = next</code>为下一次迭代做准备。当循环用完路径元素时，它返回<code>ip</code>。</p>
<p>注：</p>
<ol>
<li>在每次迭代中锁定<code>ip</code>是必要的，不是因为<code>ip-&gt;type</code>可以被更改，而是因为在<code>ilock</code>运行之前，<code>ip-&gt;type</code>不能保证已从磁盘加载，所以得用到ilock保证一定会被加载的这个性质。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Look up and return the inode for a path name.</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes.</span></span><br><span class="line"><span class="comment">// Must be called inside a transaction since it calls iput().</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用skipelem依次考察路径的每个元素</span></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early.</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>namex</code>过程可能需要很长时间才能完成：它可能涉及多个磁盘操作来读取路径名中所遍历目录的索引节点和目录块（如果它们不在buffer cache中）。</p>
<p>Xv6 is carefully designed，如果一个内核线程对<code>namex</code>的调用在磁盘I/O上阻塞，另一个查找不同路径名的内核线程可以同时进行。<code>Namex</code> locks each directory in the path <strong>separately</strong> so that lookups in different directories can proceed in parallel.锁细粒度化</p>
<p>This concurrency introduces some challenges. For example, while one kernel thread is looking up a pathname another kernel thread may be changing the directory tree by unlinking a directory. A potential risk is that a lookup may be searching a directory that has been deleted by another kernel thread and its blocks have been re-used for another directory or file.一个潜在的风险是，查找可能正在搜索已被另一个内核线程删除且其块已被重新用于另一个目录或文件的目录。</p>
<p>Xv6避免了这种竞争，也就是说，你查到的inode保证暂时不会被释放，里面的内容还是真的，而不会被重新利用从而导致里面的内容变样。</p>
<p>例如，在<code>namex</code>中执行<code>dirlookup</code>时，lookup线程持有目录上的锁，<code>dirlookup</code>返回使用<code>iget</code>获得的inode。<code>Iget</code>增加索引节点的引用计数。只有在从<code>dirlookup</code>接收inode之后，<code>namex</code>才会释放目录上的锁。现在，另一个线程可以从目录中取消inode的链接，但是xv6还不会删除inode，<u>因为inode的引用计数仍然大于零</u>。</p>
<p>另一个风险是死锁。例如，查找“<code>.</code>”时，<code>next</code>指向与<code>ip</code>相同的inode【确实】。在释放<code>ip</code>上的锁之前锁定<code>next</code>将导致死锁【为什么？？？难道不是会由于在acquire时已经持有锁，从而爆<code>panic(&quot;acquire&quot;)</code>吗？】。为了避免这种死锁，<code>namex</code>在获得下一个目录的锁之前解锁该目录。这里我们再次看到为什么<code>iget</code>和<code>ilock</code>之间的分离很重要。</p>
</blockquote>
<h2 id="File-descriptor-layer"><a href="#File-descriptor-layer" class="headerlink" title="File descriptor layer"></a>File descriptor layer</h2><blockquote>
<p>Unix的一个很酷的方面是，Unix中的大多数资源都表示为文件，包括控制台、管道等设备，当然还有真实文件。文件描述符层是实现这种一致性的层。</p>
</blockquote>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>Xv6为每个进程提供了自己的打开文件表或文件描述符。每个打开的文件都由一个<code>struct file</code>表示，它是inode或管道的封装，加上一个I/O偏移量。</p>
<p>每次调用<code>open</code>都会创建一个新的打开文件（一个新的<code>struct file</code>）：如果多个进程独立地打开同一个文件，那么不同的实例将具有不同的I/O偏移量。</p>
<p>另一方面，单个打开的文件（同一个<code>struct file</code>）可以多次出现在一个进程的文件表中，也可以出现在多个进程的文件表中。如果一个进程使用<code>open</code>打开文件，然后使用<code>dup</code>创建别名，或使用<code>fork</code>与子进程共享，就会发生这种情况。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;</span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ftable"><a href="#ftable" class="headerlink" title="ftable"></a>ftable</h3><blockquote>
<p>所有在系统中打开的文件都会被放入global file table<code>ftable</code>中。</p>
<p><code>ftable</code>具有分配文件（<code>filealloc</code>）、创建重复引用（<code>filedup</code>）、释放引用（<code>fileclose</code>）以及读取和写入数据（<code>fileread</code>和<code>filewrite</code>）的函数。</p>
<p>前三个都很常规，跟之前的xxalloc、xxfree的思路是一样的。</p>
<p>函数<code>filestat</code>、<code>fileread</code>和<code>filewrite</code>实现对文件的<code>stat</code>、<code>read</code>和<code>write</code>操作。</p>
</blockquote>
<h4 id="filealloc"><a href="#filealloc" class="headerlink" title="filealloc"></a>filealloc</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filealloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">      f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">      release(&amp;ftable.lock);</span><br><span class="line">      <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="filedup"><a href="#filedup" class="headerlink" title="filedup"></a>filedup</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Increment ref count for file f.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filedup</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;filedup&quot;</span>);</span><br><span class="line">  f-&gt;ref++;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fileclose"><a href="#fileclose" class="headerlink" title="fileclose"></a>fileclose</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;fileclose&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ff = *f;</span><br><span class="line">  f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">  f-&gt;type = FD_NONE;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line">    pipeclose(ff.pipe, ff.writable);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line">    begin_op();</span><br><span class="line">    iput(ff.ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="filestat"><a href="#filestat" class="headerlink" title="filestat"></a>filestat</h4><blockquote>
<p>Filestat只允许在inode上操作并且调用了<code>stati</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅允许文件/设备执行</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fileread"><a href="#fileread" class="headerlink" title="fileread"></a>fileread</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read from file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 首先检查是否可读</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>((r = readi(f-&gt;ip, <span class="number">1</span>, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 移动文件指针偏移量</span></span><br><span class="line">      f-&gt;off += r;</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    panic(<span class="string">&quot;fileread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-System-calls"><a href="#Code-System-calls" class="headerlink" title="Code: System calls"></a>Code: System calls</h2><blockquote>
<p>通过使用底层提供的函数，大多数系统调用的实现都很简单（请参阅***kernel/sysfile.c***）。有几个调用值得仔细看看。</p>
<p>以下介绍的函数都在<code>kernel/sysfile.c</code>中。</p>
</blockquote>
<h3 id="sys-link"><a href="#sys-link" class="headerlink" title="sys_link"></a>sys_link</h3><p>这个函数的功能是给文件old加上一个链接，这个链接存在于文件new的父目录。感觉也就相当于把文件从old复制到new处了。具体实现逻辑就是要给该文件所在目录添加一个entry，name=新名字，inode=该文件的inode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the path new as a link to the same inode as old.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dp</span>, *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, old, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, new, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先先增加nlink</span></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">// 通过path找到ip结点</span></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(old)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="comment">// directory不能被link</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DIR)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;nlink++;</span><br><span class="line">  <span class="comment">// 修改一次字段就需要update一次</span></span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后再在目录中登记新的entry</span></span><br><span class="line">  <span class="comment">// 找到new的parent，也即new所在目录</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(new, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  ilock(dp);</span><br><span class="line">  <span class="comment">// 在目录中添加一个entry，名字为给定的新名字，inode依旧为原来的inode</span></span><br><span class="line">  <span class="comment">// new的父目录必须存在并且与现有inode位于同一设备上</span></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  iput(ip);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;nlink--;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><blockquote>
<p>它是三个文件创建系统调用的泛化：带有<code>O_CREATE</code>标志的<code>open</code>生成一个新的普通文件，<code>mkdir</code>生成一个新目录，<code>mkdev</code>生成一个新的设备文件。</p>
</blockquote>
<p>创建一个新的inode结点，结点名包含在<code>path</code>内。返回一个<strong>锁定的</strong>inode。</p>
<p>由于使用了<code>iupdate</code>等，所以该函数只能在事务中被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">create</span><span class="params">(<span class="type">char</span> *path, <span class="type">short</span> type, <span class="type">short</span> major, <span class="type">short</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">dp</span>;</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取结点父目录</span></span><br><span class="line">  <span class="keyword">if</span>((dp = nameiparent(path, name)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ilock(dp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 说明文件已存在</span></span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))</span><br><span class="line">      <span class="comment">// 说明此时caller为open（type == T_FILE），open调用create只能是用于创建文件</span></span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;create: ialloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;major = major;</span><br><span class="line">  ip-&gt;minor = minor;</span><br><span class="line">  ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type == T_DIR)&#123;  <span class="comment">// Create . and .. entries.</span></span><br><span class="line">    dp-&gt;nlink++;  <span class="comment">// for &quot;..&quot;</span></span><br><span class="line">    iupdate(dp);</span><br><span class="line">    <span class="comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span></span><br><span class="line">    <span class="comment">// 所以其实.和..本质上是link</span></span><br><span class="line">    <span class="keyword">if</span>(dirlink(ip, <span class="string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="number">0</span> || dirlink(ip, <span class="string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;create dots&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;create: dirlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">  iunlockput(dp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-mkdir"><a href="#sys-mkdir" class="headerlink" title="sys_mkdir"></a>sys_mkdir</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, path, MAXPATH) &lt; <span class="number">0</span> || (ip = create(path, T_DIR, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-open"><a href="#sys-open" class="headerlink" title="sys_open"></a>sys_open</h3><blockquote>
<p><code>Sys_open</code>是最复杂的，因为创建一个新文件只是它能做的一小部分。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> fd, omode;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;omode) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建失败</span></span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 文件不存在</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create返回一个锁定的inode，但namei不锁定，因此sys_open必须锁定inode本身。</span></span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="comment">// 非文件，为目录并且非只读</span></span><br><span class="line">    <span class="comment">// 所以说想要open一个目录的话只能以只读模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取file结构体和文件描述符。</span></span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">      fileclose(f);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有其他进程可以访问部分初始化的文件，因为它仅位于当前进程的表中，因而这里可以不用上锁</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class="line">    f-&gt;type = FD_DEVICE;</span><br><span class="line">    f-&gt;major = ip-&gt;major;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    f-&gt;type = FD_INODE;</span><br><span class="line">    f-&gt;off = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;ip = ip;</span><br><span class="line">  f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class="line">  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果使用了这个标志,调用 open 函数打开文件的时候会将文件原本的内容全部丢弃,文件大小变为 0。</span></span><br><span class="line">  <span class="keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;</span><br><span class="line">    itrunc(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-pipe"><a href="#sys-pipe" class="headerlink" title="sys_pipe"></a>sys_pipe</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fdarray; <span class="comment">// user pointer to array of two integers用来接收pipe两端的文件描述符</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">rf</span>, *<span class="title">wf</span>;</span></span><br><span class="line">  <span class="type">int</span> fd0, fd1;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;fdarray) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(pipealloc(&amp;rf, &amp;wf) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  fd0 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>((fd0 = fdalloc(rf)) &lt; <span class="number">0</span> || (fd1 = fdalloc(wf)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd0 &gt;= <span class="number">0</span>)</span><br><span class="line">      p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line">    fileclose(rf);</span><br><span class="line">    fileclose(wf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, fdarray, (<span class="type">char</span>*)&amp;fd0, <span class="keyword">sizeof</span>(fd0)) &lt; <span class="number">0</span> ||</span><br><span class="line">     copyout(p-&gt;pagetable, fdarray+<span class="keyword">sizeof</span>(fd0), (<span class="type">char</span> *)&amp;fd1, <span class="keyword">sizeof</span>(fd1)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    p-&gt;ofile[fd0] = <span class="number">0</span>;</span><br><span class="line">    p-&gt;ofile[fd1] = <span class="number">0</span>;</span><br><span class="line">    fileclose(rf);</span><br><span class="line">    fileclose(wf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>实际操作系统中的buffer cache比xv6复杂得多，但它有两个相同的用途：缓存和同步对磁盘的访问。</p>
<p>与UNIX V6一样，Xv6的buffer cache使用简单的最近最少使用（LRU）替换策略；有许多更复杂的策略可以实现，每种策略都适用于某些工作场景，而不适用于其他工作场景。更高效的LRU缓存将消除链表，而改为使用哈希表进行查找，并使用堆进行LRU替换【跟我们在lock中实现的一样，再多个堆优化】。现代buffer cache通常与虚拟内存系统集成，以支持内存映射文件。</p>
<p>Xv6的日志系统效率低下。提交不能与文件系统调用同时发生。系统记录整个块，即使一个块中只有几个字节被更改。它执行同步日志写入，每次写入一个块，每个块可能需要整个磁盘旋转时间。真正的日志系统解决了所有这些问题。</p>
<p>文件系统布局中最低效的部分是目录，它要求在每次查找期间对所有磁盘块进行线性扫描【确实】。当目录只有几个磁盘块时，这是合理的，但对于包含许多文件的目录来说，开销巨大。Microsoft Windows的NTFS、Mac OS X的HFS和Solaris的ZFS（仅举几例）将目录实现为磁盘上块的平衡树。这很复杂，但可以保证目录查找在对数时间内完成（即时间复杂度为O(logn)）。</p>
<p>Xv6对于磁盘故障的解决很初级：如果磁盘操作失败，Xv6就会调用<code>panic</code>。这是否合理取决于硬件：如果操作系统位于使用冗余屏蔽磁盘故障的特殊硬件之上，那么操作系统可能很少看到故障，因此<code>panic</code>是可以的。另一方面，使用普通磁盘的操作系统应该预料到会出现故障，并能更优雅地处理它们，这样一个文件中的块丢失不会影响文件系统其余部分的使用。</p>
<p>Xv6要求文件系统安装在单个磁盘设备上，且大小不变。随着大型数据库和多媒体文件对存储的要求越来越高，操作系统正在开发各种方法来消除“每个文件系统一个磁盘”的瓶颈。基本方法是将<strong>多个物理磁盘组合成一个逻辑磁盘</strong>。RAID等硬件解决方案仍然是最流行的，但当前的趋势是在软件中尽可能多地实现这种逻辑。这些软件实现通常<strong>允许通过动态添加或删除磁盘来扩展或缩小逻辑设备</strong>等丰富功能。当然，一个能够动态增长或收缩的存储层需要一个能够做到这一点的文件系统：xv6使用的固定大小的inode块阵列在这样的环境中无法正常工作。<strong>将磁盘管理与文件系统分离可能是最干净的设计</strong>，但两者之间复杂的接口导致了一些系统（如Sun的ZFS）将它们结合起来。</p>
<p>Xv6的文件系统缺少现代文件系统的许多其他功能；例如，它缺乏对快照和增量备份的支持。</p>
<p>现代Unix系统允许使用与磁盘存储相同的系统调用访问多种资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口，如<code>/proc</code>。不同于xv6中<code>fileread</code>和<code>filewrite</code>的<code>if</code>语句，这些系统通常为每个打开的文件提供一个<strong>函数指针表</strong>【确实有印象】，每个操作一个，并通过函数指针来援引inode的调用实现。网络文件系统和用户级文件系统提供了将这些调用转换为网络RPC并在返回之前等待响应的函数。</p>
<p>（注：Linux 内核提供了一种通过<code>/proc</code>文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。）</p>
</blockquote>
<h2 id="Lab-file-system"><a href="#Lab-file-system" class="headerlink" title="Lab: file system"></a>Lab: file system</h2><blockquote>
<p>In this lab you will add large files【大文件支持】 and symbolic links【软链接】 to the xv6 file system.</p>
<p>不过做完这个实验，给我的一种感觉就是磁盘管理和内存管理真的有很多相似之处，不过也许它们所代表的思想也很普遍。</p>
</blockquote>
<h3 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h3><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><h5 id="Overview-3"><a href="#Overview-3" class="headerlink" title="Overview"></a>Overview</h5><blockquote>
<p>In this assignment you’ll increase the maximum size of an xv6 file. </p>
<p>Currently xv6 files are limited to 268 blocks, or 268*BSIZE bytes (BSIZE is 1024 in xv6). This limit comes from the fact that an xv6 inode contains 12 “direct” block numbers and one “singly-indirect” block number, which refers to a block that holds up to 256 more block numbers, for a total of 12+256=268 blocks.</p>
<p>You’ll change the xv6 file system code to support a <strong>“doubly-indirect” block</strong> in each inode, containing 256 addresses of singly-indirect blocks, each of which can contain up to 256 addresses of data blocks. The result will be that a file will be able to consist of up to 65803 blocks, or 256*256+256+11 blocks (11 instead of 12, because <strong>we will sacrifice one of the direct block numbers for the double-indirect block</strong>).</p>
</blockquote>
<h5 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h5><blockquote>
<p>If at any point during the lab you find yourself having to rebuild the file system from scratch, you can run <code>make clean</code> which forces make to rebuild fs.img.</p>
</blockquote>
<h5 id="What-to-Look-At"><a href="#What-to-Look-At" class="headerlink" title="What to Look At"></a>What to Look At</h5><p>意思就是要我们去看一眼fs.h，bmap，以及了解一下逻辑地址bn如何转化为blockno。这个我是知道的。</p>
<h5 id="Your-Job"><a href="#Your-Job" class="headerlink" title="Your Job"></a>Your Job</h5><blockquote>
<p>Modify <code>bmap()</code> so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. </p>
<p>You’ll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you’re not allowed to change the size of an on-disk inode. </p>
<p>The first 11 elements of <code>ip-&gt;addrs[]</code> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when <code>bigfile</code> writes 65803 blocks and <code>usertests</code> runs successfully.</p>
</blockquote>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>意外地很简单（）在此不多做赘述，直接上代码。</p>
<p>唯一要注意的一点就是记得在<code>itrunc</code>中free掉</p>
<p><img src="/2023/01/10/xv6/image-20230124232433793.png" alt="image-20230124232433793"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="修改定义"><a href="#修改定义" class="headerlink" title="修改定义"></a>修改定义</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in fs.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDOUBLEINDIRECT ((BSIZE/sizeof(uint))*(BSIZE/sizeof(uint)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NDOUBLEINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="修改bmap"><a href="#修改bmap" class="headerlink" title="修改bmap()"></a>修改bmap()</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in fs.c</span></span><br><span class="line"><span class="comment">// 调试用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// CODE HERE</span></span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDOUBLEINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// 调试用</span></span><br><span class="line">    <span class="keyword">if</span>(bn/<span class="number">10000</span> &gt; cnt)&#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;double_indirect:%d\n&quot;</span>,bn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一层</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="comment">// 第二层</span></span><br><span class="line">    bp = bread(ip-&gt;dev,addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[(bn &gt;&gt; <span class="number">8</span>)]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[(bn &gt;&gt; <span class="number">8</span>)] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="comment">// 第三层</span></span><br><span class="line">    bp = bread(ip-&gt;dev,addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[(bn &amp; <span class="number">0x00FF</span>)]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[(bn &amp; <span class="number">0x00FF</span>)] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改itrunc"><a href="#修改itrunc" class="headerlink" title="修改itrunc"></a>修改itrunc</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents).</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CODE HERE</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="number">1</span>])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="comment">// 双层循环</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">tmp_bp</span> =</span> bread(ip-&gt;dev,a[j]);</span><br><span class="line">        uint* tmp_a = (uint*)tmp_bp-&gt;data;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; NINDIRECT; k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(tmp_a[k])</span><br><span class="line">            bfree(ip-&gt;dev,tmp_a[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(tmp_bp);</span><br><span class="line">        bfree(ip-&gt;dev,a[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h3><blockquote>
<p>In this exercise you will add symbolic links to xv6. </p>
<p>Symbolic links (or <strong>soft links</strong>) refer to a linked file by pathname; when a symbolic link is opened, the kernel follows the link to the referred file. </p>
<p>Symbolic links resembles hard links, <u>but hard links are restricted to pointing to file on the same disk</u>, while symbolic links can cross disk devices. </p>
<p>Although xv6 doesn’t support multiple devices, implementing this system call is a good exercise to understand how pathname lookup works.</p>
<p>You will implement the <code>symlink(char *target, char *path)</code> system call, which creates a new symbolic link at path that refers to file named by target. For further information, see the man page symlink. To test, add symlinktest to the Makefile and run it. </p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_40179091/article/details/125306898">linux：硬链接和软链接</a></p>
<p>硬链接不会创建新的物理文件，但是会使得当前物理文件的引用数加1。当硬链接产生的文件存在时，删除源文件，不会清除实际的物理文件，即对于硬链接“生成的新文件”不会产生任何影响。</p>
<p>软链接就更像一个指针，只是指向实际物理文件位置，当源文件移动或者删除时，软链接就会失效。</p>
<p>【所以说，意思就是软链接不会让inode-&gt;ulinks++的意思？】</p>
</blockquote>
<h4 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h4><p>这个实验比上个实验稍难一些，但也确实只是moderate的水平，其复杂程度主要来源于对文件系统的理解，还有如何判断环，以及对锁的获取和释放的应用。我做这个实验居然是没看提示的【非常骄傲&lt;-】，让我有一种自己水平上升了的感觉hhh</p>
<h5 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h5><p>本实验要求实现软链接。首先需要实现创建软链接：写一个系统调用 <code>symlink(char *target, char *path)</code> 用于创建一个指向target的在path的软链接；然后需要实现打开软链接进行自动的跳转：在<code>sys_open</code>中添加对文件类型为软链接的特殊处理。</p>
<h5 id="初见思路"><a href="#初见思路" class="headerlink" title="初见思路"></a>初见思路</h5><p>我的初见思路是觉得可以完全参照<code>sys_link</code>来写。但其实还是很不一样的。</p>
<p><code>sys_link</code>的逻辑：</p>
<ol>
<li>获取old的inode</li>
<li>获取new所在目录的inode，称为dp</li>
<li>在dp中添加一项entry指向old</li>
</ol>
<p><code>sys_symlink</code>的逻辑：</p>
<ol>
<li><p>通过path创建一个新的inode，作为软链接的文件</p>
<p>这里选择新建inode，而不是像link那样做，主要还是为了能遵从<code>symlinktest</code>给的接口使用方法（朴实无华的理由）。而且这么做也很方便，符合“一切皆文件”的思想，也能简单化对其在<code>open</code>中的处理。</p>
</li>
<li><p>在inode中填入target的地址</p>
<p>我们可以把软链接视为文件，文件内容是其target的path。</p>
</li>
</ol>
<p>可以说是毫不相干，所以还是直接自起炉灶比较好。</p>
<h5 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h5><p>其实没什么好说的，虽然debug过程挺久，但是靠常规的printf追踪就都可以看出来是哪里错了。下面我说说一个我印象比较深刻的吧。</p>
<p><code>symlinktest</code>中有一个检测点是，软链接不能成环，也即b-&gt;a-&gt;b是非法的。于是，我就选择了用快慢指针来检测环形链表这个思想，用来看是否出现环。</p>
<p>在<code>symlinktest</code>的另一个检测点中：</p>
<p><img src="/2023/01/10/xv6/image-20230125173143735.png" alt="image-20230125173143735"></p>
<p>我出现了如下错误：</p>
<p><img src="/2023/01/10/xv6/image-20230125162542807.png" alt="image-20230125162542807"></p>
<p>此时的结构是1[27]-&gt;2[28]-&gt;3[29]-&gt;4，[]内为inode的inum。</p>
<p>快慢指针的实现方式是当cnt为奇数的时候，慢指针才会移动。而上图中，cnt==0时，两个指针的值都发生了变化，这就非常诡异。</p>
<p>这其实是因为slow指针所指向的那个inode被释放了，然后又被fast指针的下一个inode捡过来用了，从而导致值覆盖。</p>
<p>为什么会被释放呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="comment">// 快指针移动</span></span><br><span class="line">      readi(ip,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 在这里！！！</span></span><br><span class="line">      ilockput(ip);</span><br></pre></td></tr></table></figure>

<p>在这里，我错误地调用了<code>ilockput</code>，从而使inode的ref–，使得它在下一次fast指针调用<code>namei</code>，<code>namei</code>调用<code>iget</code>时，该inode被当做free inode使用，于是就这么寄了。</p>
<p>所以我们需要把<code>ilockput</code>的调用换成<code>ilock</code>，这样一来就能防止inode被free。至于什么时候再iput？我想还是交给操作系统启动时的清理工作来做吧23333【开摆】</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p><img src="/2023/01/10/xv6/image-20230125165612112.png" alt="image-20230125165612112"></p>
<h5 id="添加定义"><a href="#添加定义" class="headerlink" title="添加定义"></a>添加定义</h5><h6 id="fcntl-c"><a href="#fcntl-c" class="headerlink" title="fcntl.c"></a>fcntl.c</h6><p>open参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 意为只用获取软链接文件本身，而不用顺着软链接去找它的target文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_NOFOLLOW 0x100</span></span><br></pre></td></tr></table></figure>

<h6 id="stat-h"><a href="#stat-h" class="headerlink" title="stat.h"></a>stat.h</h6><p>文件类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYMLINK  4   <span class="comment">// symbol links</span></span></span><br></pre></td></tr></table></figure>

<h5 id="添加sys-symlink系统调用"><a href="#添加sys-symlink系统调用" class="headerlink" title="添加sys_symlink系统调用"></a>添加sys_symlink系统调用</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in sysfile.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建软链接结点</span></span><br><span class="line">  ip = create(path,T_SYMLINK,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//printf(&quot;symlink:before writei,inum = %d\n&quot;,ip-&gt;inum);</span></span><br><span class="line">  <span class="comment">// 此处可以防止住一些并发错误</span></span><br><span class="line">  <span class="keyword">if</span>(ip ==<span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向软链接结点文件内写入其所指向的路径</span></span><br><span class="line">  writei(ip,<span class="number">0</span>,(uint64)target,<span class="number">0</span>,MAXPATH);</span><br><span class="line">  <span class="comment">//printf(&quot;symlink:after writei\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 软链接不需要让nlink++</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 记得要释放在create()中申请的锁</span></span><br><span class="line">  iunlockput(ip);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改open"><a href="#修改open" class="headerlink" title="修改open"></a>修改open</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 软链接不可能是以O_CREATE的形式创建的</span></span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改从这里开始</span></span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="comment">// ip为快指针，slow为慢指针</span></span><br><span class="line">    uint cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">slow</span> =</span> ip;</span><br><span class="line">    <span class="comment">// 可能有多重链接，因而需要持续跳转</span></span><br><span class="line">    <span class="keyword">while</span>(ip-&gt;type == T_SYMLINK)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;slow = %d,fast = %d,cnt = %d\n&quot;,slow-&gt;inum,ip-&gt;inum,cnt);</span></span><br><span class="line">      <span class="comment">// 其实这个只需要检测一次就够了。但为了编码方便，仍然把它保留在while循环中</span></span><br><span class="line">      <span class="keyword">if</span>(omode &amp; O_NOFOLLOW)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 检测到cycle</span></span><br><span class="line">        <span class="keyword">if</span>(slow == ip &amp;&amp; cnt!=<span class="number">0</span>)&#123;</span><br><span class="line">          iunlockput(ip);</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快指针移动</span></span><br><span class="line">        readi(ip,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">        <span class="comment">// 此处不能用iunlockput()，具体原因见 感想-一些错误</span></span><br><span class="line">        iunlock(ip);</span><br><span class="line">        <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ilock(ip);</span><br><span class="line">        <span class="comment">// 慢指针移动</span></span><br><span class="line">        <span class="comment">// 注意，我慢指针移动的时候没有锁保护，因为用锁太麻烦了（）其实还是用锁比较合适</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="comment">//printf(&quot;%d\n&quot;,cnt);</span></span><br><span class="line">          readi(slow,<span class="number">0</span>,(uint64)path,<span class="number">0</span>,MAXPATH);</span><br><span class="line">          <span class="keyword">if</span>((slow = namei(path) )== <span class="number">0</span>)&#123;</span><br><span class="line">            end_op();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当跳出循环时，此时的ip必定是锁住的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab-mmap"><a href="#Lab-mmap" class="headerlink" title="Lab mmap"></a>Lab mmap</h2><blockquote>
<p>The <code>mmap</code> and <code>munmap</code> system calls allow UNIX programs to exert detailed control over their address spaces. </p>
<p>They can be used to:</p>
<ol>
<li>share memory among processes</li>
<li>map files into process address spaces</li>
<li>as part of <strong>user-level page fault schemes</strong> such as the garbage-collection algorithms discussed in lecture. </li>
</ol>
<p>In this lab you’ll add <code>mmap</code> and <code>munmap</code> to xv6, <strong>focusing on memory-mapped files</strong>.</p>
<p>mmap是系统调用，在用户态被使用。我们这次实验仅实现mmap功能的子集，也即memory-mapped files。</p>
</blockquote>
<blockquote>
<p>declaration for <code>mmap</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">     <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>参数</p>
<ol>
<li><p><code>addr</code> is always zero.</p>
<p>You can assume that <code>addr</code> will always be zero, meaning that the kernel should decide the <strong>virtual address</strong> at which to map the file.【<code>addr</code>由kernel决定，因而用户态只需传入0即可】</p>
</li>
<li><p><code>length</code> is the number of bytes to map</p>
<p>Might not be the same as the file’s length.</p>
</li>
<li><p><code>prot</code> indicates whether the memory should be mapped readable, writeable, and/or executable.</p>
<p>you can assume that <code>prot</code> is <code>PROT_READ</code> or <code>PROT_WRITE</code> or both. </p>
</li>
<li><p><code>flags</code> has two values.</p>
<ol>
<li><p><code>MAP_SHARED</code></p>
<p>meaning that modifications to the mapped memory <strong>should be written back to the file</strong>, </p>
<p>如果标记为此，则当且仅当file本身权限为RW或者WRITABLE的时候，prot才可以标记为PROT_WRITE</p>
</li>
<li><p><code>MAP_PRIVATE</code></p>
<p>meaning that they should not. </p>
<p>如果标记为此，则无论file本身权限如何，prot都可以标记为PROT_WRITE</p>
</li>
</ol>
</li>
<li><p>You can assume <code>offset</code> is zero (it’s the starting point in the file at which to map)</p>
</li>
</ol>
</li>
<li><p>return</p>
<p><code>mmap</code> returns that kernel-decided address, or 0xffffffffffffffff if it fails.</p>
</li>
</ol>
<p>如果两个进程同时对某个文件进行memory map，那么这两个进程可以不共享物理页面。</p>
</blockquote>
<blockquote>
<p><code>munmap(addr, length)</code> should remove mmap mappings in the indicated address range. </p>
<p>If the process has modified the memory and has it mapped <code>MAP_SHARED</code>, <strong>the modifications should first be written to the file</strong>. 【如果两个进程的修改发生冲突了怎么办？】</p>
<p>An <code>munmap</code> call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region).</p>
</blockquote>
<h3 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h3><p>这个实验做得我……怎么说，感觉非常地难受吧。虽然我认为我这次做得挺不错的，因为我没有怎么看hints，我的代码差不多全都是我自己想出来的，没有依赖保姆级教学，我认为是一个很好的进步。不过，正因为我没有看hints，导致我的想法比起答案来思路非常地奇诡，导致我第一次错误想法写了一天，看了hints后决心痛改前非，结果第二次错误想法又写了一天emmm</p>
<p>下面的第一个代码版本虽然可以过掉mmaptest，但<strong>确实还是有一个很致命的bug</strong>，并且<strong>lazy也没有lazy到位</strong>，最后的版本离正确思路还有偏差，<strong>也就是下面放的第一个代码版本是错误的，</strong>但我认为它也不是完全没有亮点。第二个版本才是经过改正的正确版本，但写得着实有点潦草。</p>
<p>笔记整理得也有点匆忙，毕竟我真的话比较多而且心里很烦。总之，先记录我的全部思路过程，至于价值如何，先不管了2333</p>
<h4 id="初见思路-1"><a href="#初见思路-1" class="headerlink" title="初见思路"></a>初见思路</h4><p>所以说，我们要做的，就是实现一个系统调用mmap，在mmap中，应该首先申请几页用来放file的内容，并且在页表中填入该项，然后再返回该项的虚拟地址。然后在munmap中，再将该file页内容写入file。</p>
<p>也就是说，直接在mmap把文件的全部内容写入内存，然后各进程读写自己的那块内容块，最后在munmap的时候把修改内容写入文件然后释放该内存块就行了</p>
<h5 id="问题：在哪里放置file的内容"><a href="#问题：在哪里放置file的内容" class="headerlink" title="问题：在哪里放置file的内容"></a>问题：在哪里放置file的内容</h5><p>题目要求<code>the kernel should decide the **virtual address** at which to map the file.</code>也就是说，在我们的<code>mmap</code>中，需要决定我们要讲文件内容放在哪里。那要放在哪呢……</p>
<p>我第一反应很奇葩：扫描页表，找到空闲页。但我自己也知道这样不可行，文件内容不止一页，这种零零散散存储需要的数据结构实现起来太麻烦了。</p>
<p>那怎么办？可以在heap内分配。那么到底怎么样才能在heap里分配？你该怎么知道heap哪里开始是空闲的，哪里是用过的，不还是得扫描页表吗？【思维大僵化】</p>
<p>其实……道理很简单。我们之间把<code>proc-&gt;sz</code>作为mapped-file的起始地址就好了。相信看到这里，你也明白这是什么原理了。能想到这个，我感觉确实很不容易。</p>
<h4 id="正确思路-1"><a href="#正确思路-1" class="headerlink" title="正确思路"></a>正确思路</h4><p>初见思路虽然简单，但是很粗暴，如果文件很大，宝贵的内存空间就会被我们浪费。所以我们借用lazy allocation的思想，先建立memory-file的映射，再在缺页中断中通过文件读写申请内存空间，把文件内容读入内存。</p>
<p>问题就在于如何“先建立memory-file的映射”。在lazy allocation中，我们是先填好所有的对应页表项，仅是不申请对应的物理内存，也即占着XX不XX。在这次实验中，我们也是这么做，只不过新增了一个难点，那就是<strong>如何管理这些页</strong>。因为lazy allocation页与页之间没有比较紧密的关系，但是在mmap中页却可以被所属文件这个关键字划分。因而，我们需要一个数据结构，来给页分门别类地组织在一起，并且记录它们的meta data比如说所属文件之类的，这也就是hints里的VMA结构，也即我的filemap结构。</p>
<p>我们可以将这样的数据结构池化，并且存储在proc域中，以避免对象的重复创建。</p>
<blockquote>
<p>我的lazy法与别人不大一样……我没有想得像他们那么完美。我的做法是，在需要读某个地址的文件内容时，直接确保这个地址前面的所有文件内容都读了进来。也即在filemap中维护一个okva，表明va<del>okva这段内存已经读入，之后就仅需再读入okva</del>need_va这段地址就行。这样虽然lazy了，但没完全lazy。</p>
<p>我认为这不能体现lazy的思想……因为一读读一坨，还是很占空间啊。</p>
</blockquote>
<p>因而，我们需要做的就是：</p>
<ol>
<li><p>在mmap中将信息填入该数据结构</p>
<ol>
<li>依据传入的长度扩容proc，原sz作为mapped-file起始地址va</li>
<li>从对象池中寻找到一个空闲的filemap，对其填写信息</li>
<li>返回1所得的va</li>
</ol>
<p>在我的代码中，还针对proc-&gt;sz不满足page-align做出了对策：先把文件的<code>PGROUNDUP(sz)-sz</code>这部分的信息读入，并且更新okva，这样一来，之后在usertrap中，就可以从okva开始一页页地分配地址，做到自然地page-align了。</p>
<blockquote>
<p>为什么要对不满足page-align的情况进行处理？</p>
<p>这是因为，growproc的时候一次性扩充一页，但proc-&gt;sz却可以不满足page-align，也就是说，proc-&gt;sz所处的这一页已经被分配了。</p>
<p>在我们的lazy思路中，我们如果不预先读入文件页，是只能等待用户陷入缺页中断的情况下才能读入文件内容。</p>
<p>但是，proc-&gt;sz这一页已经被分配了。因而，在用户态读取这一页地址的时候，<strong>并不会发生缺页中断</strong>。因而，就会发生文件内容未读入，用户读到脏数据的情况。</p>
<p>其实还有一种更简单的办法可以强制page-align，那就是，直接让起始地址为<code>PGROUNDUP(proc-&gt;sz)</code>……至于为什么我不用这个，而要写这么多麻烦的东西呢？答案是我没想到。（）</p>
</blockquote>
</li>
<li><p>在usertrap增加对缺页中断的处理</p>
<ol>
<li>依据va找到对应filemap</li>
<li>根据对应filemap的信息，使用<code>readi</code>（正确）<code>fileread</code>（错误）读取文件内容并存入物理内存</li>
</ol>
</li>
<li><p>在munmap中进行释放</p>
<ol>
<li>根据标记写入文件页，并且释放对应物理内存</li>
<li>修改filemap结构的参数，并且在其失效的时候放回对象池</li>
</ol>
</li>
<li><p>修改fork和exit</p>
<ol>
<li><p>exit</p>
<p>手动释放map-file域</p>
<blockquote>
<p>为什么不能把这些合并到<code>wait</code>中调用的<code>freepagetable</code>进行释放呢？</p>
<p>因为<code>freepagetable</code>只会释放对应的物理页，没有达到<code>munmap</code>减少文件引用等功能。</p>
</blockquote>
</li>
<li><p>fork</p>
<p>手动复制filemap池</p>
</li>
</ol>
</li>
</ol>
<h4 id="我的错误思路们"><a href="#我的错误思路们" class="headerlink" title="我的错误思路们"></a>我的错误思路们</h4><h5 id="第一次错误思路"><a href="#第一次错误思路" class="headerlink" title="第一次错误思路"></a>第一次错误思路</h5><p>上面说到：</p>
<blockquote>
<p>问题就在于如何“先建立memory-file的映射”。在lazy allocation中，我们是先填好所有的对应页表项，仅是不申请对应的物理内存，也即占着XX不XX。在这次实验中，我们也是这么做，只不过新增了一个难点，那就是<strong>如何管理这些页</strong>。因为lazy allocation页与页之间没有比较紧密的关系，但是在mmap中页却可以被所属文件这个关键字划分。因而，我们需要一个数据结构，来给页分门别类地组织在一起，并且记录它们的meta data比如说所属文件之类的，这也就是hints里的VMA结构，也即我的filemap结构。</p>
</blockquote>
<p>官方给出的答案是在proc域里的pool。我……额……是把这些信息，存入在页中（真是自找麻烦呀）</p>
<p>具体来说，就是，我在<code>mmap</code>的时候给每个文件申请一页，然后在页的开头填上和filemap结构相差无几的那些参数，再加上一个next指针，表示下一个文件页的地址。页的剩下部分就用来存储数据。总的就是一个链表结构。</p>
<p>这个思路其实很不错，比起上面的直接在proc内存的尾巴扩容，这个空间利用率应该更大，并且不仅能节省物理内存，还能节省虚拟地址空间，实现了lazy上加lazy。</p>
<p>但问题是……我<strong>为什么非要傻瓜式操纵内存，在页的开头填入参数数据</strong>，而不是把这种页抽象为一个个node，最终形成一个十字链表的形式（差不多的意思，鱼骨状），组织进proc域，这样不挺好的吗……唔，有时候我头脑昏迷程度让我自己都感到十分震惊。归根结底，还是想得太少就动手了，失策。</p>
<p>总之放上代码。我没有实现next指针，仅假设文件内容不超过一页。也就是这一页开头在mmap中填meta data，其余部分在usertrap中填入文件内容。【这个分开的点也让我迷惑至极……】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERRORADDR 0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="keyword">struct</span> file* file,uint64 offset)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">// 获取va,也即真正的address</span></span><br><span class="line">    uint64 va = p-&gt;sz;</span><br><span class="line">    <span class="keyword">if</span>(growproc(PGSIZE) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    <span class="type">char</span>* mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 保存信息：file指针、prot（这就是傻瓜式操纵内存的典范）</span></span><br><span class="line">    uint64* pointer = (uint64*)mem;</span><br><span class="line">    *pointer = (uint64)file;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)prot;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)length;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)flags;</span><br><span class="line">    pointer++;</span><br><span class="line">    *pointer = (uint64)offset;</span><br><span class="line">    pointer++;</span><br><span class="line">    filedup(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(p-&gt;pagetable, va+PGSIZE, PGSIZE, (uint64)mem, PTE_M|PTE_X|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return start of free memory</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)(va + (uint64)pointer - (uint64)mem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64* pa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, (uint64)address, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span> ||(*pte &amp; PTE_M) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// the start is where the params save</span></span><br><span class="line">    pa = (uint64*)(PGROUNDDOWN(PTE2PA(*pte)));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span> =</span> (<span class="keyword">struct</span> file*)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> prot = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> flags = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flags == MAP_SHARED&amp;&amp;(prot&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 需要更新写内容</span></span><br><span class="line">        filewrite(file,(uint64)address,length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后释放内存</span></span><br><span class="line">    uvmunmap(p-&gt;pagetable, PGROUNDDOWN((uint64)address), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64* pa;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span> ||(*pte &amp; PTE_M) == <span class="number">0</span>)</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the start is where the params save</span></span><br><span class="line">    pa = (uint64*)(PGROUNDDOWN(PTE2PA(*pte)));</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span> =</span> (<span class="keyword">struct</span> file*)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">int</span> prot = (<span class="type">int</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="type">size_t</span> length = (<span class="type">size_t</span>)(*pa);</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line">    pa++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((prot&amp;PROT_READ) != <span class="number">0</span>)&#123;</span><br><span class="line">      fileread(file,va,length);</span><br><span class="line">      flags |= PTE_R;</span><br><span class="line">      <span class="keyword">if</span>((prot&amp;PROT_WRITE) != <span class="number">0</span>)    flags |= PTE_W;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)     p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      *pte = ((*pte) | flags);</span><br><span class="line">    &#125; <span class="keyword">else</span>  p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="为什么下面的代码是错的"><a href="#为什么下面的代码是错的" class="headerlink" title="为什么下面的代码是错的"></a>为什么下面的代码是错的</h5><p>正如开头所说的那样，我并没有完美做好这次实验，下面代码有一个致命的bug。</p>
<p>先说说致命bug是什么。</p>
<p>我的filemap结构体其实隐藏了两个具有“offset”这一含义的状态。一个是filemap里面的成员变量offset，另一个是filemap里面的成员变量file的成员变量off：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">filemap</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span><span class="comment">//文件</span></span><br><span class="line">  uint64 offset;<span class="comment">//va相对于file开头的offset</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// in file.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在我的代码里，它们被赋予了不同的含义。</p>
<p><code>filemap-&gt;file-&gt;off</code>被用于<code>trap.c</code>中，表示的是当前未读入文件内容的起始位置（实际上也就是<code>okva-va</code>的值），用于自然地使用<code>fileread</code>进行文件读入。</p>
<blockquote>
<p>比如说，这次读入PGSIZE，那么off就会在<code>fileread</code>中自增PGSIZE。下次调用<code>fileread</code>就可以直接从下一个位置读入了，这样使代码更加简洁</p>
</blockquote>
<p><code>filemap-&gt;offset</code>被用于<code>munmap</code>中。<code>filewrite</code>同<code>fileread</code>一样，都是从<code>file-&gt;off</code>处开始取数据。<code>munmap</code>所需要取数据的起始位置和<code>trap.c</code>中需要取数据的起始位置肯定不一样，</p>
<blockquote>
<p>想想它们的功能。<code>trap.c</code>的off需要始终指向有效内存段的末尾，但<code>munmap</code>由于要对特定内存段进行写入文件操作，因而off要求可以随机指向。</p>
</blockquote>
<p>因而，我们可以将当前va对应的文件位置记录在offset中。届时，我们只需要从<code>p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va</code>取数据就行。</p>
<p>上述两个变量相辅相成，看上去似乎能够完美无缺地实现我们的功能。但是，实际上，不行。为什么呢？因为它们的file指针，<code>filemap-&gt;file</code>，如果被两个mmap区域同时使用的话，就会出问题。</p>
<p>可以来看看<code>mmaptest.c</code>中的这一段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  makefile(f);</span><br><span class="line">  <span class="keyword">if</span> ((fd = open(f, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">  unlink(f);</span><br><span class="line">  <span class="type">char</span> *p1 = mmap(<span class="number">0</span>, PGSIZE*<span class="number">2</span>, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">  <span class="type">char</span> *p2 = mmap(<span class="number">0</span>, PGSIZE*<span class="number">2</span>, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// read just 2nd page.</span></span><br><span class="line">  <span class="keyword">if</span>(*(p1+PGSIZE) != <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    err(<span class="string">&quot;fork mismatch (1)&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    err(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// v1是用来触发缺页中断的函数</span></span><br><span class="line">    _v1(p1);</span><br><span class="line">    munmap(p1, PGSIZE); <span class="comment">// just the first page</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// tell the parent that the mapping looks OK.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> status = <span class="number">-1</span>;</span><br><span class="line">  wait(&amp;status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(status != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork_test failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check that the parent&#x27;s mappings are still there.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;before v1,p1 = %d\n&quot;</span>,(uint64)p1);</span><br><span class="line">  _v1(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;after v1,p1 = %d\n&quot;</span>,(uint64)p1);</span><br><span class="line">  _v1(p2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fork_test OK\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">fork_test starting</span></span><br><span class="line"><span class="comment">trap:map a page at 53248,okva = 53248</span></span><br><span class="line"><span class="comment">trap:mem[0]=65,off = 4096,size = 6144</span></span><br><span class="line"><span class="comment">trap:map a page at 57344,okva = 53248</span></span><br><span class="line"><span class="comment">trap:mem[0]=65,off = 6144,size = 6144</span></span><br><span class="line"><span class="comment">before v1,p1 = 53248</span></span><br><span class="line"><span class="comment">after v1,p1 = 53248</span></span><br><span class="line"><span class="comment">trap:map a page at 61440,okva = 61440</span></span><br><span class="line"><span class="comment">trap:mem[0]=0,off = 6144,size = 6144</span></span><br><span class="line"><span class="comment">mismatch at 0, wanted &#x27;A&#x27;, got 0x0</span></span><br><span class="line"><span class="comment">mmaptest: fork_test failed: v1 mismatch (1), pid=3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in trap.c</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap:map a page at %d,okva = %d\n&quot;</span>,start_va,p-&gt;filemaps[i].okva);</span><br><span class="line"></span><br><span class="line">fileread(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trap:mem[0]=%d,off = %d,size = %d\n&quot;</span>,</span><br><span class="line">       mem[<span class="number">0</span>],p-&gt;filemaps[i].file-&gt;off,p-&gt;filemaps[i].file-&gt;ip-&gt;size);</span><br></pre></td></tr></table></figure>

<p>这段代码因为共用fd，导致file指针被两个mmap区域同时使用。</p>
<blockquote>
<p>共用fd，为什么file指针也一起共用了？</p>
<p>可以追踪一下它们的生命周期：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in sys_open()</span></span><br><span class="line"><span class="comment">// 获取file结构体和文件描述符。</span></span><br><span class="line"><span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in sysfile.c</span></span><br><span class="line"><span class="comment">// Allocate a file descriptor for the given file.</span></span><br><span class="line"><span class="comment">// Takes over file reference from caller on success.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fdalloc</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line">   p-&gt;ofile[fd] = f;</span><br><span class="line">   <span class="keyword">return</span> fd;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它实际上是有一个文件描述符表，key为fd，value为file指针。因而，同一张表，fd相同，file指针相同。</p>
<p>注：父子进程，同样的fd，file指针也是相同的</p>
<p><strong>fork出来的父子进程同一个句柄对同一个文件的偏移量是相同的</strong>，这个原理应该是因为，父子进程共享的是文件句柄这个结构体对象本身，也就是拷贝的时候是浅拷贝而不是深拷贝。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in fork()</span></span><br><span class="line"><span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">   np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后的<code>check that the parent&#39;s mappings are still there.</code>环节中，<code>_v1(p1)</code>执行时并没有陷入trap，这是正常的。不正常的是<code>_v1(p2)</code>的执行结果。它陷入了trap，但是却因<code>file-&gt;off == file size</code>，导致被判定为已全部读入文件，事实上却是并没有读入文件。</p>
<p>为什么会这样呢？</p>
<p>这是因为p1和p2共用同一个fd，也就共用了同一个file指针。共用了一个file指针，那么p1和p2面对的<code>file-&gt;off</code>相同。上面说到，<code>file-&gt;off</code>用于控制文件映射。那么，当p1完成了对文件的映射，p1的off指针如果不加重置，就会永远停留在file size处。这样一来，当p2想要使用同样的file指针进行文件映射时，就会出问题。</p>
<p>这个问题的一个解决方法是每次<code>mmap</code>都深拷贝一个船新file结构体。但是这样的话，<code>file</code>域里的<code>ref</code>变量就失去了它的意义，并且file对象池应该也很快就会爆满，非常不符合设计方案。</p>
<p>这个问题的完美解，是不要赋予<code>file-&gt;off</code>这个意义，而是使用<code>readi</code>替代<code>fileread</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fileread(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span><br><span class="line">readi(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span><br></pre></td></tr></table></figure>

<p>这样做的好处是，我们可以实时计算offset（前面提到，其恰恰等于okva-va），而不用把这个东西用file的off来表示。</p>
<blockquote>
<p>也确实，我之所以弯弯绕绕那么曲折，是因为只想到了<code>fileread</code>这个函数，压根没注意到还有一个<code>readi</code>……</p>
</blockquote>
<p>我在下面的代码仅做了一个能够通过测试，但是上面的<strong>bug依然存在</strong>的功利性折中代码。我是这么实现的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在`mmap`的时候初始化`file-&gt;off`</span></span><br><span class="line">p-&gt;filemaps[i].file-&gt;off = offset;</span><br><span class="line"><span class="comment">// 在`munmap`的时候清零`file-&gt;off`</span></span><br><span class="line">p-&gt;filemaps[i].file-&gt;off = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>因而，结论是，一步错步步错，一个错误需要更多的错误来弥补，最后还是错的（悲）</p>
<h5 id="如何把下面的错误思路改成正确思路"><a href="#如何把下面的错误思路改成正确思路" class="headerlink" title="如何把下面的错误思路改成正确思路"></a>如何把下面的错误思路改成正确思路</h5><p>可以做以下几点：</p>
<ol>
<li><p>正确地lazy</p>
<p>每次trap仅分配一页。</p>
</li>
<li><p>改用readi函数，修改<code>file-&gt;off</code>的语义</p>
</li>
</ol>
<p>这样一来，大概就可以完美地正确了。</p>
<h4 id="其他的一些小细节"><a href="#其他的一些小细节" class="headerlink" title="其他的一些小细节"></a>其他的一些小细节</h4><h5 id="file指针的生命周期"><a href="#file指针的生命周期" class="headerlink" title="file指针的生命周期"></a>file指针的生命周期</h5><p>在数据结构中存储file指针至关重要。但仔细想一想，file指针的生命周期似乎长到过分：从sys_mmap被调用，一直到usertrap处理缺页中断，最后到munmap释放，我们要求file指针的值需要保持稳定不变。</p>
<p>这么长的生命周期，它真的可以做到吗？毕竟file指针归根到底只是一个局部变量，在syscall mmap结束之后，它还有效吗？答案是有效的，这个有效性由<code>mmap</code>实现中对ref的增加来实现保障。</p>
<p>在用户态中关闭一个文件，需要使用syscall<code>close(int fd)</code>。不妨来看看<code>close</code>的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/sysfile.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argfd(<span class="number">0</span>, &amp;fd, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 一个进程打开的文件都会放入一个以fd为index的文件表里，</span></span><br><span class="line"><span class="comment">// 在xv6中，这个文件表便是`myproc()-&gt;ofile`。</span></span><br><span class="line"><span class="comment">// 可以看到，关闭一个文件首先需要把它移出文件表</span></span><br><span class="line">myproc()-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 对file指针关闭的主要操作</span></span><br><span class="line">fileclose(f);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in kernel/file.c</span></span><br><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;ftable.lock);</span><br><span class="line"><span class="comment">// 若ref数&lt;0，就会直接return</span></span><br><span class="line"><span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> release(&amp;ftable.lock);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放file</span></span><br><span class="line"><span class="comment">// close不会显式地释放file指针，只会释放file指针所指向的文件，让file指针失效。</span></span><br><span class="line">ff = *f;</span><br><span class="line">f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">f-&gt;type = FD_NONE;</span><br><span class="line">release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line"> pipeclose(ff.pipe, ff.writable);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line"> begin_op();</span><br><span class="line"> iput(ff.ip);</span><br><span class="line"> end_op();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当ref数&gt;1时，file指针就不会失效。</p>
<p>这就是为什么我们还需要在mmap中让file的ref数++。</p>
<h5 id="缺页中断蕴含的设计思想"><a href="#缺页中断蕴含的设计思想" class="headerlink" title="缺页中断蕴含的设计思想"></a>缺页中断蕴含的设计思想</h5><p>如果只存入file指针，用户态要如何对对应的文件进行读写呢？</p>
<p>我们可以自然想到也许需要设计一个函数，让用户在想要对这块内存读写的时候调用这个函数即可。但是，这样的方法使得用户对内存不能自然地读写，还需要使用我们新设计的这个函数，这显然十分地不美观。所以，我们需要找到一个方法，让上层的用户可以<strong>统一</strong>地读取任何的内存块，包括memory-mapped file内存块，而<strong>隐藏</strong>memory-mapped file与其他内存块读写方式不同的这些复杂细节。经历过前面几次实验的你看到这里一定能想到，有一个更加优美更加符合设计规范的方法，那就是：<strong>缺页中断</strong>！</p>
<blockquote>
<p>没做这个实验之前就知道mmap需要借助缺页中断来实现了，但实际自己的第一印象是觉得并不需要缺页中断，直到分析到这里才恍然大悟。</p>
<p>“让上层的用户可以<strong>统一</strong>地读取任何的内存块，而<strong>隐藏</strong>不同类型的内存块读写方式不同的这些复杂细节”</p>
<p>仔细想想，前面几个关于缺页中断的实验，比如说cow fork，lazy allocation，事实上都是基于这个思想。它们并不是不能与缺页中断分离，只是有了缺页中断，它们的实现更加简洁，更加优美。</p>
<p>再次感慨os的博大精深。小小一个缺页中断，原理那么简单，居然集中了这么多设计思想，不禁叹服。</p>
</blockquote>
<h5 id="正确答案的munmap中如果遇到未映射的页怎么办"><a href="#正确答案的munmap中如果遇到未映射的页怎么办" class="headerlink" title="正确答案的munmap中如果遇到未映射的页怎么办"></a>正确答案的munmap中如果遇到未映射的页怎么办</h5><p>在正确答案的munmap中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line"><span class="keyword">while</span>(start_va &lt; bounder)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">    <span class="comment">//写回</span></span><br><span class="line">    filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">  &#125;</span><br><span class="line">  uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">  start_va += PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果map类型为<code>MAP_SHARED</code>，并且该页尚未映射，会怎么样呢？</p>
<p>追踪filewrite的路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in file.c</span></span><br><span class="line">	  begin_op();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line"><span class="comment">// in fs.c</span></span><br><span class="line">    <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line"><span class="comment">// in vm.c copyin()</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><code>copyin</code>最终会在<code>    if(pa0 == 0)  return -1;</code>这里终结，但<code>writei</code>并不会在接收到-1的时候爆出panic或者是引发缺页中断，而只会把它当做文件结尾，默默地返回。</p>
<p>并且，在<code>munmap</code>中是一页一页地释放，而不是直接传参length全部释放，这一点也很重要。因为我们的lazy allocation很可能导致<code>va~va+length</code>这一区间内只是部分页被映射，部分页没有。如果直接传参length释放，那么在遇到第一页未被映射的时候，<code>filewrite</code>就会终止，该页之后的页就没有被写回文件的机会了。</p>
<p>所以结论是，在正确实现的<code>munmap</code>中遇到未映射的页会自动跳过，什么也不会发生。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in param.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFILEMAP 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">filemap</span>&#123;</span></span><br><span class="line">  uint isused;<span class="comment">//对象池思想。该filemap是否正在被使用</span></span><br><span class="line">  uint64 va;<span class="comment">//该文件的起始内存页地址</span></span><br><span class="line">  uint64 okva;<span class="comment">//该文件的起始未被读入部分对应的内存地址</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span><span class="comment">//文件</span></span><br><span class="line">  <span class="type">size_t</span> length;<span class="comment">//需要映射到内存的长度</span></span><br><span class="line">  <span class="type">int</span> flags;<span class="comment">//MAP_SHARED OR MAP_PRIVATE</span></span><br><span class="line">  <span class="type">int</span> prot;<span class="comment">//PROT_READ OR PROT_WRITE</span></span><br><span class="line">  uint64 offset;<span class="comment">//va相对于file开头的offset</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">filemap</span> <span class="title">filemaps</span>[<span class="title">NFILEMAP</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>具体系统调用注册过程略。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length,prot,flags,offset;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>,&amp;length) &lt; <span class="number">0</span> || argint(<span class="number">2</span>,&amp;prot) &lt; <span class="number">0</span> || argint(<span class="number">3</span>,&amp;flags) &lt; <span class="number">0</span> || argfd(<span class="number">4</span>,<span class="number">0</span>,&amp;file) ||argint(<span class="number">5</span>,&amp;offset) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> (uint64)mmap((<span class="type">void</span>*)addr,(<span class="type">size_t</span>)length,prot,flags,file,(uint)offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERRORADDR 0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射file从offset开始长度为length的内容到内存中，返回内存中的文件内容起始地址</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="keyword">struct</span> file* file,uint64 offset)</span>&#123;</span><br><span class="line">    <span class="comment">// mmap的prot权限必须与file的权限对应，不能file只读但是mmap却可写且shared</span></span><br><span class="line">    <span class="keyword">if</span>((prot&amp;PROT_WRITE) != <span class="number">0</span>&amp;&amp;flags == MAP_SHARED &amp;&amp;file-&gt;writable == <span class="number">0</span>)       </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到filemap池中第一个空闲的filemap</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!p-&gt;filemaps[i].isused)&#123;</span><br><span class="line">        <span class="comment">// 获取va,也即真正的address</span></span><br><span class="line">        va = p-&gt;sz;</span><br><span class="line">        p-&gt;sz += length;</span><br><span class="line">        <span class="comment">// 其实这里用一个memcpy会更加优雅，可惜我忘记了（）</span></span><br><span class="line">        p-&gt;filemaps[i].isused = <span class="number">1</span>;</span><br><span class="line">        p-&gt;filemaps[i].va = va;</span><br><span class="line">        p-&gt;filemaps[i].okva = va;</span><br><span class="line">        p-&gt;filemaps[i].length = length;</span><br><span class="line">        p-&gt;filemaps[i].prot = prot;</span><br><span class="line">        p-&gt;filemaps[i].flags = flags;</span><br><span class="line">        p-&gt;filemaps[i].file = file;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = offset;</span><br><span class="line">        p-&gt;filemaps[i].offset = offset;</span><br><span class="line">        <span class="comment">// 增加文件引用数</span></span><br><span class="line">        filedup(file);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(va == <span class="number">0</span>)  <span class="keyword">return</span> (<span class="type">void</span>*)ERRORADDR;</span><br><span class="line">    <span class="comment">// return start of free memory</span></span><br><span class="line">    uint64 start_va = PGROUNDUP(va);</span><br><span class="line">    <span class="comment">// 先读入处于proc已申请的内存页区域（也即没有内存对齐情况下）</span></span><br><span class="line">    uint64 off = start_va - va;</span><br><span class="line">    <span class="keyword">if</span>(off &lt; PGSIZE)&#123;</span><br><span class="line">        fileread(file,va,off);</span><br><span class="line">        file-&gt;off += off;</span><br><span class="line">        p-&gt;filemaps[i].okva = va+off;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)va;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h4><h5 id="错的"><a href="#错的" class="headerlink" title="错的"></a>错的</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">   uint64 va = r_stval();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">       <span class="comment">// 找到va对应的filemap</span></span><br><span class="line">     <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;va&gt;=p-&gt;filemaps[i].va </span><br><span class="line">        &amp;&amp; va&lt;p-&gt;filemaps[i].va+p-&gt;filemaps[i].length)&#123;</span><br><span class="line">       <span class="comment">// 说明本来就不应该写</span></span><br><span class="line">       <span class="keyword">if</span>(r_scause() == <span class="number">15</span> &amp;&amp; ((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) == <span class="number">0</span>)&#123;</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//说明地址不在文件范围内</span></span><br><span class="line">       <span class="keyword">if</span>(p-&gt;filemaps[i].va+p-&gt;filemaps[i].file-&gt;ip-&gt;size &lt;= va)&#123;</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 能进到这里来的都是产生了缺页中断，也就是说va对应文件数据不存在</span></span><br><span class="line">       <span class="comment">// 我们需要维护一个okva，表示从filemaps.va到okva这段地址已经加载了文件</span></span><br><span class="line">       <span class="comment">// 这样一来，我们这里就只需加载okva~va地址对应的文件了</span></span><br><span class="line">       <span class="comment">// file结构体自带的off成员会由于fileread而自动增长到对应位置，所以文件可以自然地读写</span></span><br><span class="line">       uint64 start_va = p-&gt;filemaps[i].okva;<span class="comment">// okva一定是page-align的</span></span><br><span class="line">       <span class="comment">// 加载文件内容</span></span><br><span class="line">       <span class="keyword">while</span>(start_va &lt;= va)&#123;</span><br><span class="line">         <span class="type">char</span>* mem = kalloc();</span><br><span class="line">         <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">           p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">         <span class="type">int</span> flag = PTE_X|PTE_R|PTE_U;</span><br><span class="line">         <span class="keyword">if</span>(((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">           flag |= PTE_W;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(mappages(p-&gt;pagetable, start_va, PGSIZE, (uint64)mem, flag) != <span class="number">0</span>)&#123;</span><br><span class="line">           p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">           kfree(mem);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 读入文件内容</span></span><br><span class="line">         fileread(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">         start_va += PGSIZE;</span><br><span class="line">       &#125;</span><br><span class="line">       p-&gt;filemaps[i].okva = start_va;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="对的"><a href="#对的" class="headerlink" title="对的"></a>对的</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;va&gt;=p-&gt;filemaps[i].va &amp;&amp; va&lt;p-&gt;filemaps[i].va+p-&gt;filemaps[i].length)&#123;</span><br><span class="line">      <span class="keyword">if</span>(r_scause() == <span class="number">15</span> &amp;&amp; ((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 说明本来就不应该写</span></span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].va+p-&gt;filemaps[i].file-&gt;ip-&gt;size &lt;= va)&#123;</span><br><span class="line">        <span class="comment">//说明地址不在文件范围内</span></span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      uint64 start_va = PGROUNDDOWN(va);</span><br><span class="line">        <span class="type">char</span>* mem = kalloc();</span><br><span class="line">        <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="type">int</span> flag = PTE_X|PTE_R|PTE_U;</span><br><span class="line">        <span class="keyword">if</span>(((p-&gt;filemaps[i].prot)&amp;PROT_WRITE) != <span class="number">0</span>)&#123;</span><br><span class="line">         flag |= PTE_W;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable, start_va, PGSIZE, (uint64)mem, flag) != <span class="number">0</span>)&#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">          kfree(mem);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readi(p-&gt;filemaps[i].file-&gt;ip,<span class="number">0</span>,(uint64)mem,va-p-&gt;filemaps[i].va+p-&gt;filemaps[i].offset,PGSIZE);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h4><h5 id="错的-1"><a href="#错的-1" class="headerlink" title="错的"></a>错的</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">min</span><span class="params">(uint64 a,uint64 b)</span>&#123;<span class="keyword">return</span> a&gt;b?b:a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放文件映射以address为起始地址，length为长度这个范围内的内存地址空间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = (uint64)address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到对应的filemap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;p-&gt;filemaps[i].va&lt;=va&amp;&amp;p-&gt;filemaps[i].va+length&gt;va)&#123;</span><br><span class="line">        <span class="comment">// 开始释放的内存地址</span></span><br><span class="line">        uint64 start_va;</span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)</span><br><span class="line">            start_va = PGROUNDUP(p-&gt;filemaps[i].va);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start_va = PGROUNDDOWN(va);</span><br><span class="line">        <span class="comment">// 结束释放的内存地址</span></span><br><span class="line">        uint64 bounder = p-&gt;filemaps[i].va + min(p-&gt;filemaps[i].file-&gt;ip-&gt;size,length);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//file的off在trap中用于表示文件已加载的位置</span></span><br><span class="line">        <span class="comment">//在这里需要用off进行filewrite，所以需要对原本在usertrap用于记录加载位置的off进行手动保存</span></span><br><span class="line">        uint64 tmp_off = p-&gt;filemaps[i].file-&gt;off;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line">        <span class="keyword">while</span>(start_va &lt; bounder &amp;&amp; start_va &lt; p-&gt;filemaps[i].okva)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">            <span class="comment">//写回</span></span><br><span class="line">            filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">          &#125;</span><br><span class="line">          uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">          start_va += PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改filemap结构体的起始地址va和长度，offset也要变，因为他记录va对应的是文件哪个位置</span></span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)&#123;</span><br><span class="line">          <span class="comment">//释放的是头几页</span></span><br><span class="line">          p-&gt;filemaps[i].offset += length;</span><br><span class="line">          p-&gt;filemaps[i].va = va+length;</span><br><span class="line">          p-&gt;filemaps[i].length -= length;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//释放的是尾几页</span></span><br><span class="line">          p-&gt;filemaps[i].length -= p-&gt;filemaps[i].length - va;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = tmp_off;</span><br><span class="line">        <span class="comment">// 检验map的合理性</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;filemaps[i].length == <span class="number">0</span> || p-&gt;filemaps[i].va &gt;= p-&gt;filemaps[i].va+length</span><br><span class="line">                        || p-&gt;filemaps[i].file-&gt;off &gt; p-&gt;filemaps[i].file-&gt;ip-&gt;size)&#123;</span><br><span class="line">          p-&gt;filemaps[i].isused = <span class="number">0</span>;<span class="comment">//释放</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 注意！！！！这句话对我的错误代码来说非常重要</span></span><br><span class="line">          p-&gt;filemaps[i].file-&gt;off = <span class="number">0</span>;</span><br><span class="line">          fileclose(p-&gt;filemaps[i].file);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对的-1"><a href="#对的-1" class="headerlink" title="对的"></a>对的</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">min</span><span class="params">(uint64 a,uint64 b)</span>&#123;<span class="keyword">return</span> a&gt;b?b:a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* address,<span class="type">size_t</span> length)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 va = (uint64)address;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;filemaps[i].isused&amp;&amp;p-&gt;filemaps[i].va&lt;=va&amp;&amp;p-&gt;filemaps[i].va+length&gt;va)&#123;</span><br><span class="line">        uint64 start_va;</span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)</span><br><span class="line">                start_va = PGROUNDUP(p-&gt;filemaps[i].va);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                start_va = PGROUNDDOWN(va);</span><br><span class="line">        uint64 bounder = p-&gt;filemaps[i].va + min(p-&gt;filemaps[i].file-&gt;ip-&gt;size,length);</span><br><span class="line">        <span class="comment">//在这里需要用off进行读写，所以需要对原本的加载处off手动保存</span></span><br><span class="line">        uint64 tmp_off = p-&gt;filemaps[i].file-&gt;off;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = p-&gt;filemaps[i].offset+va-p-&gt;filemaps[i].va;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放已经申请的页表项、内存，并且看看是不是需要写回</span></span><br><span class="line">        <span class="keyword">while</span>(start_va &lt; bounder)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;filemaps[i].flags == MAP_SHARED)&#123;</span><br><span class="line">            <span class="comment">//写回</span></span><br><span class="line">            filewrite(p-&gt;filemaps[i].file,start_va,PGSIZE);</span><br><span class="line">          &#125;</span><br><span class="line">          uvmunmap(p-&gt;pagetable,start_va,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">          start_va += PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改filemap结构体的起始地址va和长度，offset也要变，因为他记录va对应的是文件哪个位置</span></span><br><span class="line">        <span class="keyword">if</span>(va == p-&gt;filemaps[i].va)&#123;</span><br><span class="line">          <span class="comment">//释放的是头几页</span></span><br><span class="line">          p-&gt;filemaps[i].offset += length;</span><br><span class="line">          p-&gt;filemaps[i].va = va+length;</span><br><span class="line">          p-&gt;filemaps[i].length -= length;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//释放的是尾几页</span></span><br><span class="line">          p-&gt;filemaps[i].length -= p-&gt;filemaps[i].length - va;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检验map的合理性</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;filemaps[i].length == <span class="number">0</span> || p-&gt;filemaps[i].va &gt;= p-&gt;filemaps[i].va+length</span><br><span class="line">                        || p-&gt;filemaps[i].file-&gt;off &gt; p-&gt;filemaps[i].file-&gt;ip-&gt;size)&#123;</span><br><span class="line">          p-&gt;filemaps[i].isused = <span class="number">0</span>;<span class="comment">//释放</span></span><br><span class="line">          fileclose(p-&gt;filemaps[i].file);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;filemaps[i].file-&gt;off = tmp_off;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exit和fork"><a href="#exit和fork" class="headerlink" title="exit和fork"></a>exit和fork</h4><h5 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭map-file</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;filemaps[i].isused)&#123;</span><br><span class="line">    munmap((<span class="type">void</span>*)(p-&gt;filemaps[i].va),p-&gt;filemaps[i].length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NFILEMAP;i++)&#123;</span><br><span class="line">  np-&gt;filemaps[i].isused = p-&gt;filemaps[i].isused;</span><br><span class="line">  np-&gt;filemaps[i].va = p-&gt;filemaps[i].va;</span><br><span class="line">  np-&gt;filemaps[i].okva = p-&gt;filemaps[i].okva;</span><br><span class="line">  np-&gt;filemaps[i].file = p-&gt;filemaps[i].file;</span><br><span class="line">  np-&gt;filemaps[i].length = p-&gt;filemaps[i].length;</span><br><span class="line">  np-&gt;filemaps[i].flags = p-&gt;filemaps[i].flags;</span><br><span class="line">  np-&gt;filemaps[i].offset = p-&gt;filemaps[i].offset;</span><br><span class="line">  np-&gt;filemaps[i].prot = p-&gt;filemaps[i].prot;</span><br><span class="line">  <span class="keyword">if</span>(np-&gt;filemaps[i].file)</span><br><span class="line">    filedup(np-&gt;filemaps[i].file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改uvmcopy和uvmunmap"><a href="#修改uvmcopy和uvmunmap" class="headerlink" title="修改uvmcopy和uvmunmap"></a>修改uvmcopy和uvmunmap</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in uvmunmap()</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      *pte = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// in uvmcopy()</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Interrupts and device drivers</title>
    <url>/2023/01/10/xv6$chap5/</url>
    <content><![CDATA[<h1 id="Interrupts-and-device-drivers"><a href="#Interrupts-and-device-drivers" class="headerlink" title="Interrupts and device drivers"></a>Interrupts and device drivers</h1><blockquote>
<p>A <em>driver</em> is the code in an operating system that manages a particular device: </p>
<ol>
<li><strong>configures</strong> the device hardware</li>
<li>tells the device to perform <strong>operations</strong></li>
<li>handles the resulting <strong>interrupts</strong></li>
<li><strong>interacts</strong> with <strong>processes</strong> that may be waiting for I/O from the device</li>
</ol>
<p>Driver code can be tricky because a driver executes <strong>concurrently</strong> with the device that it manages. </p>
<p>In addition, the driver must understand the device’s <strong>hardware interface</strong>, which can be complex and poorly documented.</p>
</blockquote>
<p>如果devices需要让操作系统对某些事情做出响应，就要采取中断的方法。在<code>kerneltrap</code>中，内核响应中断，并且根据设备类型来决定中断处理函数。</p>
<blockquote>
<p><img src="/2023/01/10/xv6/image-20230115160523827.png" alt="image-20230115160523827"></p>
<p>这段对设备中断的概述总结得非常到位</p>
<p>也就是说，一个device driver可以分为两部分实现，一部分是接收请求，然后开启read/write；另一部分是接收中断，这个中断有可能是设备完成IO，也可能是设备需要IO，它会通知设备具体怎么做，它也会唤醒恰当的进程。</p>
</blockquote>
<h2 id="Code-Console-input"><a href="#Code-Console-input" class="headerlink" title="Code: Console input"></a>Code: Console input</h2><p>console driver是driver structure的一个实现案例。</p>
<h3 id="上层逻辑"><a href="#上层逻辑" class="headerlink" title="上层逻辑"></a>上层逻辑</h3><p>shell获取用户输入console的信息是通过系统调用<code>read()</code>实现的。read通过文件描述符，最终转向<code>consoleread()</code>来实现具体的逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in file.c fileread()</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);<span class="comment">// 在这里转向console</span></span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">// in console.c consoleinit()</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, <span class="string">&quot;cons&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uartinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里完成devsw的初始化</span></span><br><span class="line">  <span class="comment">// connect read and write system calls</span></span><br><span class="line">  <span class="comment">// to consoleread and consolewrite.</span></span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对console的读写事实上是对cons结构体里buf的读写。这个buf则是由底层逻辑管理的。<code>consoleread()</code>每次读取buf中的一行，当未读满一行且无字符输入时会阻塞，直到底层逻辑将字符放入buf。读满了一行后，<code>consoleread</code>将该行copy进用户空间，随后返回<code>read</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/console.c </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_BUF_SIZE 128</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> buf[INPUT_BUF_SIZE];</span><br><span class="line">  uint r;  <span class="comment">// Read index</span></span><br><span class="line">  uint w;  <span class="comment">// Write index</span></span><br><span class="line">  uint e;  <span class="comment">// Edit index</span></span><br><span class="line">&#125; cons;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user read()s from the console go here.</span></span><br><span class="line"><span class="comment">// copy (up to) a whole input line to dst.</span></span><br><span class="line"><span class="comment">// user_dist indicates whether dst is a user</span></span><br><span class="line"><span class="comment">// or kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint target;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">  target = n;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// wait until interrupt handler has put some</span></span><br><span class="line">    <span class="comment">// input into cons.buffer.</span></span><br><span class="line">    <span class="comment">// read和write的index一样，说明此时没有数据输入，阻塞</span></span><br><span class="line">    <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">      <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">        release(&amp;cons.lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 产生数据输入，接收数据</span></span><br><span class="line">    c = cons.buf[cons.r++ % INPUT_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == C(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file</span></span><br><span class="line">      <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">        <span class="comment">// Save ^D for next time, to make sure</span></span><br><span class="line">        <span class="comment">// caller gets a 0-byte result.</span></span><br><span class="line">        <span class="comment">// 这样下一次也能访问到eof</span></span><br><span class="line">        cons.r--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line">    cbuf = c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    dst++;</span><br><span class="line">    --n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">      <span class="comment">// the user-level read().</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="底层逻辑"><a href="#底层逻辑" class="headerlink" title="底层逻辑"></a>底层逻辑</h3><p>底层逻辑维护了与上层逻辑交互的buf。</p>
<p>console接收数据对buf的读，是通过中断来实现的。</p>
<p>当用户输入字符，UART硬件检测到读，会向操作系统发送中断。中断在<code>kerneltrap()</code>中被接收处理，然后通过<code>devintr()</code>对该中断分门别类地进行转发。console的转发路径为devintr-&gt;uartintr-&gt;consoleintr。</p>
<h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4><p> UART的全称是Universal Asynchronous Receiver and Transmitter，即异步发送和接收。它的软件上的表示形式是<em>a set of memory-mapped control registers</em>。CPU通过物理地址与这些寄存器交互，也即它们跟RAM是同一个地址空间。在xv6中，UART的地址空间从<code>UART0</code>(0x1000 0000)开始。这些寄存器地址关于<code>UART0</code>的偏移量定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the UART control registers.</span></span><br><span class="line"><span class="comment">// some have different meanings for read vs write.</span></span><br><span class="line"><span class="comment">// see http://byterunner.com/16550.html</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RHR 0                 <span class="comment">// 接收寄存器receive holding register (for input bytes)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THR 0                 <span class="comment">// 发送寄存器transmit holding register (for output bytes)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER 1                 <span class="comment">// 开关中断寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_RX_ENABLE (1&lt;&lt;0)  <span class="comment">// 如果该位被设置，则在接收寄存器有数据，即想向外界发送数据时，UART会搓出一个中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_TX_ENABLE (1&lt;&lt;1)  <span class="comment">// 如果该位被设置，则在发送寄存器有数据，即外界向硬件发送数据时，UART会搓出一个中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR 2                 <span class="comment">// FIFO control register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_ENABLE (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_CLEAR (3&lt;&lt;1) <span class="comment">// clear the content of the two FIFOs</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR 3                 <span class="comment">// line control register</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5                 <span class="comment">// line status register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="comment">// input is waiting to be read from RHR</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="comment">// THR can accept another character to send</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="/2023/01/10/xv6/image-20230115170107044.png" alt="image-20230115170107044"></p>
<p>例如，LSR寄存器包含指示输入字符是否正在等待软件读取的位。这些字符（如果有的话）可用于从RHR寄存器读取。每次读取一个字符，UART硬件都会从等待字符的内部FIFO寄存器中删除它，并在FIFO为空时清除LSR中的“就绪”位。UART传输硬件在很大程度上独立于接收硬件；如果软件向THR写入一个字节，则UART传输该字节。</p>
</blockquote>
<h4 id="kerneltrap"><a href="#kerneltrap" class="headerlink" title="kerneltrap"></a>kerneltrap</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kerneltrap()</span></span><br><span class="line">  <span class="comment">// 在此处的devintr对不同的设备进行不同的处理方式</span></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="devintr"><a href="#devintr" class="headerlink" title="devintr"></a>devintr</h4><p>devintr处在<code>trap.c</code>中，作用是对中断归类，然后分门别类地转发到下一层级的handler。</p>
<blockquote>
<p>注：</p>
<ol>
<li><p>外中断和内中断</p>
<p><a href="https://blog.csdn.net/Cheatscat/article/details/77869600">外部中断和内部中断详解</a></p>
<p>根据中断源的不同，可以把中断分为硬件中断和软件中断两大类，而硬件中断又可以分为外部中断和内部中断两类。</p>
<p>外部中断一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可以屏蔽的中断，也就是说，利用中断控制器<strong>可以屏蔽</strong>这些外部设备的中断请求。</p>
<p>内部中断是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断是<strong>不可屏蔽</strong>的中断。</p>
<p> 软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序。例如：ROM BIOS中的各种外部设备管理中断服务程序（键盘管理中断、显示器管理中断、打印机管理 中断等，）以及DOS的系统功能调用（INT 21H）等都是软件中断。【比如说系统调用之类的】</p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt,</span></span><br><span class="line"><span class="comment">// and handle it.</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt,</span></span><br><span class="line"><span class="comment">// 1 if other device,</span></span><br><span class="line"><span class="comment">// 0 if not recognized.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取scause，辨析中断类型</span></span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果来自外中断（在这里应该只指device interrupt）</span></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// irq indicates which device interrupted.</span></span><br><span class="line">    <span class="comment">// 通过PLIC硬件获取中断设备信息</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别转发</span></span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断处理完成了，可以再次开启中断</span></span><br><span class="line">    <span class="comment">// the PLIC allows each device to raise at most one</span></span><br><span class="line">    <span class="comment">// interrupt at a time; tell the PLIC the device is</span></span><br><span class="line">    <span class="comment">// now allowed to interrupt again.</span></span><br><span class="line">    <span class="keyword">if</span>(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 来自时钟中断</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uartintr"><a href="#uartintr" class="headerlink" title="uartintr"></a>uartintr</h4><p>这代码其实乍一看是看不懂的，这是因为uartintr不止负责读中断。它还负责另一个中断（发送区空余中断），下面会细说。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handle a uart interrupt, raised because input has</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or</span></span><br><span class="line"><span class="comment">// both. called from devintr().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="comment">// return -1 if none is waiting,说明读完了</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 每读入一个字符就转交给console</span></span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters.</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="consoleintr"><a href="#consoleintr" class="headerlink" title="consoleintr"></a>consoleintr</h4><p>向buf中放入字符c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;P&#x27;</span>)</span>:  <span class="comment">// Print process list.</span></span><br><span class="line">      <span class="comment">// ...一堆特殊情况处理...</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="title function_">if</span><span class="params">(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)</span>&#123;</span><br><span class="line">          c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// echo back to the user.</span></span><br><span class="line">          consputc(c);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">          cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;</span><br><span class="line">            <span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line">            <span class="comment">// has arrived.</span></span><br><span class="line">            <span class="comment">// 中断处理并不会做很多事情，只是会与缓冲区交互</span></span><br><span class="line">            <span class="comment">// 涉及到复杂的事情，比如说将数据拷贝到用户空间</span></span><br><span class="line">            <span class="comment">//就唤醒上层逻辑来做</span></span><br><span class="line">            cons.w = cons.e;</span><br><span class="line">            wakeup(&amp;cons.r);</span><br><span class="line">          &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Console-output"><a href="#Code-Console-output" class="headerlink" title="Code: Console output"></a>Code: Console output</h2><p>外部通过write这个系统调用来对console写。</p>
<h3 id="uartputc"><a href="#uartputc" class="headerlink" title="uartputc"></a>uartputc</h3><p>最先到达这里。</p>
<p>uart内置了一个缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> uart_tx_buf[UART_TX_BUF_SIZE];</span><br></pre></td></tr></table></figure>

<p>用户仅需通过uartputc对buf进行写入即可，具体的buf数据向UART转移由uartputc通过调用uartstart实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add a character to the output buffer and tell the</span></span><br><span class="line"><span class="comment">// UART to start sending if it isn&#x27;t already.</span></span><br><span class="line"><span class="comment">// blocks if the output buffer is full.缓冲区满则阻塞</span></span><br><span class="line"><span class="comment">// because it may block, it can&#x27;t be called</span></span><br><span class="line"><span class="comment">// from interrupts; it&#x27;s only suitable for use</span></span><br><span class="line"><span class="comment">// by write().这段话很有意思，说它由于会阻塞所以最好别在中断的时候用。</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 阻塞</span></span><br><span class="line">  <span class="keyword">while</span>(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE)&#123;</span><br><span class="line">    <span class="comment">// buffer is full.</span></span><br><span class="line">    <span class="comment">// wait for uartstart() to open up space in the buffer.</span></span><br><span class="line">    sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;</span><br><span class="line">  uart_tx_w += <span class="number">1</span>;</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uartstart"><a href="#uartstart" class="headerlink" title="uartstart"></a>uartstart</h3><p>uartstart的作用是从缓冲区取数据向UART硬件发送。不阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if the UART is idle, and a character is waiting</span></span><br><span class="line"><span class="comment">// in the transmit buffer, send it.</span></span><br><span class="line"><span class="comment">// caller must hold uart_tx_lock.</span></span><br><span class="line"><span class="comment">// called from both the top- and bottom-half.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartstart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the UART transmit holding register is full,</span></span><br><span class="line">      <span class="comment">// so we cannot give it another byte.</span></span><br><span class="line">      <span class="comment">// it will interrupt when it&#x27;s ready for a new byte.</span></span><br><span class="line">      <span class="comment">// 当缓冲区满没有选择阻塞，而是先结束</span></span><br><span class="line">      <span class="comment">// 当UART硬件准备好继续接收的时候，UART会发送transmit complete中断，到时候会再继续从buf读取</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个字符一个字符写</span></span><br><span class="line">    <span class="type">int</span> c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];</span><br><span class="line">    uart_tx_r += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maybe uartputc() is waiting for space in the buffer.</span></span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    </span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当传输过程非常流畅，UART硬件没有阻塞时，以上的代码就能完美阐述发送的过程。但是当UART硬件的transmit阻塞时，过程就会有许多改动。</p>
<h3 id="transmit-complete-interrupt"><a href="#transmit-complete-interrupt" class="headerlink" title="transmit complete interrupt"></a>transmit complete interrupt</h3><p>在<code>uartstart</code>中，当UART硬件的transmit满，<code>uartstart</code>就直接return了。</p>
<p>当UART硬件的transmit空，就会发送transmit complete中断。中断在kerneltrap被接收，经过devintr转发，最终来到了uartintr：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handle a uart interrupt, raised because input has</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or</span></span><br><span class="line"><span class="comment">// both. called from devintr().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters.</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，第一个while循环会直接退出，因为压根没有get到字符。所以，这时候，就会去执行uartstart，然后继续读未完成读取的缓冲区。</p>
<p>等到所有都读完了，最后一次发送transmit complete中断时，会在uartstart进入该分支：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">  <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就不会再发送transmit中断了。</p>
<p>感觉这点是真的牛逼。uartintr这个函数完美兼顾了两种情况【这也归功于uartstart做得很健壮】：1. 外部输入数据到console，2. 接收数据未结束，继续接收</p>
<h2 id="Concurrency-in-drivers"><a href="#Concurrency-in-drivers" class="headerlink" title="Concurrency in drivers"></a>Concurrency in drivers</h2><p>用户进程与设备之间的读写交流，比如说上面的console，重点依靠于<code>uart_tx_buf</code>和<code>cons.buf</code>这两个的正确性。因而，就需要保障它们的并发安全。在上面的代码中，使用到这两个的地方都被锁保护着。</p>
<p>在kernel中还需要格外注意的一点并发是，一个进程A在等待来自设备的中断，但此时另一个进程B在运行。这时候设备发出中断信号，CPU转入中断处理程序处理中断。此时，中断处理程序的执行不应该涉及到当前被中断进程的代码。例如，中断处理程序不能安全地使用当前进程的页表调用<code>copyout</code>（页表正是跟当前进程息息相关的）。中断处理程序通常做相对较少的工作（例如，只需将输入数据复制到缓冲区），并唤醒上半部分代码来完成其余工作。</p>
<h2 id="Timer-interrupts"><a href="#Timer-interrupts" class="headerlink" title="Timer interrupts"></a>Timer interrupts</h2><blockquote>
<p>Xv6 uses timer interrupts to maintain its clock and to enable it to switch among compute-bound processes; the <strong>yield</strong> calls in usertrap and kerneltrap cause this switching.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c usertrap()</span></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c kerneltrap()</span></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RISC-V requires that timer interrupts be taken in machine mode, not supervisor mode. As a result, xv6 handles timer interrupts completely separately from the trap mechanism laid out above.</p>
</blockquote>
<p>xv6启动时调用过<code>start.c</code>。<code>start.c</code>处于机器态，并准备向内核态过渡。<code>start.c</code>中就对时钟进行了初始化<code>timeinit()</code>。要做的有以下几件事：</p>
<ol>
<li>program the <strong>CLINT</strong> hardware (core-local interruptor) to generate an interrupt after a certain delay. </li>
<li>set up a <strong>scratch</strong> area  to help the timer interrupt handler save registers and the address of the CLINT registers</li>
<li>start sets mtvec to timervec and <strong>enables</strong> timer interrupts.</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arrange to receive timer interrupts.</span></span><br><span class="line"><span class="comment">// they will arrive in machine mode at</span></span><br><span class="line"><span class="comment">// at timervec in kernelvec.S,</span></span><br><span class="line"><span class="comment">// which turns them into software interrupts for</span></span><br><span class="line"><span class="comment">// devintr() in trap.c.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">timerinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// each CPU has a separate source of timer interrupts.</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask the CLINT for a timer interrupt.</span></span><br><span class="line">  <span class="type">int</span> interval = <span class="number">1000000</span>; <span class="comment">// cycles; about 1/10th second in qemu.</span></span><br><span class="line">  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare information in scratch[] for timervec.</span></span><br><span class="line">  <span class="comment">// scratch[0..2] : space for timervec to save registers.</span></span><br><span class="line">  <span class="comment">// scratch[3] : address of CLINT MTIMECMP register.</span></span><br><span class="line">  <span class="comment">// scratch[4] : desired interval (in cycles) between timer interrupts.</span></span><br><span class="line">  uint64 *scratch = &amp;timer_scratch[id][<span class="number">0</span>];</span><br><span class="line">  scratch[<span class="number">3</span>] = CLINT_MTIMECMP(id);</span><br><span class="line">  scratch[<span class="number">4</span>] = interval;</span><br><span class="line">  w_mscratch((uint64)scratch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the machine-mode trap handler.</span></span><br><span class="line">  w_mtvec((uint64)timervec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode interrupts.</span></span><br><span class="line">  w_mstatus(r_mstatus() | MSTATUS_MIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode timer interrupts.</span></span><br><span class="line">  w_mie(r_mie() | MIE_MTIE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>计时器中断处理程序必须保证不干扰中断的内核代码。基本策略是处理程序要求RISC-V发出“软件中断”并立即返回。RISC-V用普通陷阱机制将软件中断传递给内核，并允许内核禁用它们。处理由定时器中断产生的软件中断的代码可以在<code>devintr</code> (<strong>kernel/trap.c</strong>:204)中看到：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c devintr()</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">    <span class="comment">// forwarded by timervec in kernelvec.S.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只看其中一个CPU的时钟中断计数的意思吗？确实，要是好几个一起来加倍了非常不合理</span></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>w_sip(r_sip() &amp; ~2);</code>就对应着“RISC-V用普通陷阱机制将软件中断传递给内核”。【应该吧个人理解】</p>
<blockquote>
<p>来源：<a href="https://www.bookstack.cn/books/rCore_tutorial_doc">rCore 手册（rCore tutorial doc）</a></p>
<p><strong>riscv 中的中断寄存器</strong></p>
<p>S 态的中断寄存器主要有 <strong>sie</strong>（Supervisor Interrupt Enable，监管中断使能）, <strong>sip</strong> （Supervisor Interrupt Pending，监管中断待处理）两个，其中 s 表示 S 态，i 表示中断， e/p 表示 enable (使能)/ pending (提交申请)。 处理的中断分为三种：</p>
<ol>
<li>SI(Software Interrupt)，软件中断</li>
<li>TI(Timer Interrupt)，时钟中断</li>
<li>EI(External Interrupt)，外部中断</li>
</ol>
<p>比如 <code>sie</code> 有一个 <code>STIE</code> 位， 对应 <code>sip</code> 有一个 <code>STIP</code> 位，与时钟中断 TI 有关。当硬件决定触发时钟中断时，会将 <code>STIP</code> 设置为 1，当一条指令执行完毕后，如果发现 <code>STIP</code> 为 1，此时如果时钟中断使能，即 <code>sie</code> 的 <code>STIE</code> 位也为 1 ，就会进入 S 态时钟中断的处理程序。</p>
<p>可能SSIP跟这里的STIP差不多吧，都是时钟中断的标志。如果把SSIP clear掉，那么则说明不是时钟中断了，而是软中断了。</p>
</blockquote>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>UART驱动程序读取UART控制寄存器，一次检索一字节的数据；因为软件驱动数据移动，这种模式被称为程序I/O（<strong>Programmed I/O</strong>）。程序I/O很简单，但速度太慢，无法在高数据速率下使用。需要高速移动大量数据的设备通常使用直接内存访问（<strong>DMA</strong>）。DMA设备硬件直接将传入数据写入内存，并从内存中读取传出数据。现代磁盘和网络设备使用DMA。DMA设备的驱动程序将在RAM中准备数据，然后使用对控制寄存器的单次写入来告诉设备处理准备好的数据。</p>
<p>当一个设备在不可预知的时间需要注意时，中断是有意义的，而且不是太频繁。但是中断有很高的CPU开销。因此，如网络和磁盘控制器的高速设备，使用一些技巧减少中断需求。一个技巧是对整批传入或传出的请求发出单个中断。另一个技巧是驱动程序完全禁用中断，并定期检查设备是否需要注意。这种技术被称为轮询（<strong>polling</strong>）。如果设备执行操作非常快，轮询是有意义的，但是如果设备大部分空闲，轮询会浪费CPU时间。一些驱动程序根据当前设备负载在轮询和中断之间动态切换。</p>
<p>UART驱动程序首先将传入的数据复制到内核中的缓冲区，然后复制到用户空间。这在低数据速率下是可行的，但是这种双重复制会显著降低快速生成或消耗数据的设备的性能。一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常带有DMA。</p>
</blockquote>
<h2 id="Lab-networking"><a href="#Lab-networking" class="headerlink" title="Lab: networking"></a>Lab: networking</h2><blockquote>
<p>In this lab you will write an xv6 device driver for a network interface card (NIC).</p>
<p>这个概述光是听起来就让人觉得热血沸腾。网络的本质其实就是IO设备，这一点我一直觉得很牛逼，而现在我居然要亲手实现网络……That’s very cool.</p>
</blockquote>
<blockquote>
<p>On this emulated LAN, xv6 (the “guest”) has an IP address of 10.0.2.15. </p>
<p>Qemu also arranges for the computer running qemu to appear on the LAN with IP address 10.0.2.2. </p>
<p>When xv6 uses the E1000 to send a packet to 10.0.2.2, qemu delivers the packet to the appropriate application on the (real) computer on which you’re running qemu (the “host”).</p>
</blockquote>
<blockquote>
<p>We’ve added some files to the xv6 repository for this lab. </p>
<p>The file <code>kernel/e1000.c</code> contains <strong>initialization</strong> code for the E1000 as well as empty functions for transmitting and receiving packets, which <strong>you’ll fill in</strong>. </p>
<p><code>kernel/e1000_dev.h</code> contains definitions for registers and flag bits defined by the E1000 and described in the Intel E1000 <a href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">Software Developer’s Manual</a>. </p>
<p><code>kernel/net.c</code> and <code>kernel/net.h</code> contain a simple network stack that implements the <a href="https://en.wikipedia.org/wiki/Internet_Protocol">IP</a>, <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>, and <a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP</a> protocols. </p>
<p>These files also contain code for a flexible data structure to hold packets, called an <code>mbuf</code>. </p>
<p>Finally, <code>kernel/pci.c</code> contains code that searches for an E1000 card on the PCI bus when xv6 boots.</p>
</blockquote>
<blockquote>
<p>Your job：</p>
<p>Your job is to complete <code>e1000_transmit()</code> and <code>e1000_recv()</code>, both in <code>kernel/e1000.c</code>, so that the driver can transmit and receive packets. You are done when <code>make grade</code> says your solution passes all the tests. </p>
</blockquote>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>说实话，一开始看题的时候真是感觉非常地哈人……但其实文档看着看着，心中也逐渐有了个大概，最后再结合下指导书的提示【当然不是后面那些保姆级的Hints】，最后写的也就八九不离十了。总体上来说，我觉得这次实验的代码还是很简单的，它主要难在<strong>探究过程</strong>，也就是从一开始什么也不懂，然后去阅读硬件设备的文档，结合代码尝试去理解，最后一步步写出来的过程。本次实验耗时六小时，我觉得肯定有不少于一半，甚至可能达到2/3的时间都耗费在理解上。这种从零开始探究的过程给了我很大的收获，同时也稍微提高了我面对挫折的能力。</p>
<p>这个实验确实设计得很有教育意义。除了我上面说的它锻炼了我的能力以外，它其实还具有比较深刻的<strong>工业意义</strong>。在看书的时候，书中这么写道：</p>
<blockquote>
<p>In addition, the driver must understand the device’s <strong>hardware interface</strong>, which can be complex and poorly documented.</p>
</blockquote>
<p>本次实验正是上述描述的简化版：E1000的文档很详细，并且我们只用掌握一部分它的功能就行了。但虽然简化了，其探究过程的内在逻辑还是不会改变的。</p>
<p>总之，我很喜欢这次实验的设计。我的评价是牛逼。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>Hints写得很详细，不做赘述了。主要就是明确一下数据结构的问题：</p>
<ol>
<li><p>rx_ring和tx_ring是两个分开的队列</p>
<p>它们只是结构一模一样，都是阴影部分表示software持有，白色部分表示硬件持有。</p>
<p>因而，对于rx来说，白色部分表示需要传给协议栈的包，因而我们需要把白色部分转化为阴影部分；对于tx来说，白色部分表示网卡将要发送的包，因而我们需要把阴影部分转化为白色部分。</p>
<p><img src="/2023/01/10/xv6/image-20230220234406239.png" alt="image-20230220234406239"></p>
</li>
<li><p>rx_mbufs和tx_mbufs</p>
<p>一开始不知道这俩是啥，后来才意识到，这俩和第1点的那俩其实是下标一一对应的关系。也就是说rx_ring[i]这个descriptor接收到的数据存在rx_mbufs[i]，tx_ring[i]要发送的数据存在tx_mbufs[i]。知道了这个之后，代码就简单了。</p>
<blockquote>
<p>忏悔：我一开始真没反应过来。计网我记得是有一模一样的结构的，看来算是白做了2333</p>
</blockquote>
</li>
</ol>
<h4 id="个人的推理过程"><a href="#个人的推理过程" class="headerlink" title="个人的推理过程"></a>个人的推理过程</h4><p>一开始就先懵懵懂懂地看指导书，直到看到这句话：</p>
<blockquote>
<p>Browse the E1000 <a href="https://pdos.csail.mit.edu/6.828/2020/readings/8254x_GBe_SDM.pdf">Software Developer’s Manual</a>. </p>
</blockquote>
<p>然后我这时连自己要干什么都迷迷糊糊，但姑且还是按他下面说的，准备先浏览第二章了。然而，我发现要我看我也还是看不懂啊，所以我就直接放弃了。【<strong>经验1：看不懂就算了，别死磕了</strong>】</p>
<p>我放弃了第二章后，就再次从头开始细细看了一遍这句话之前的指导书，也结合了一下它给的代码。这次总算是差不多弄懂这次要做什么了：</p>
<p>实现<strong>driver</strong>的两个函数，从而实现对网卡进行数据的取出和送入。数据是eth frame。数据取出后要通过<code>net_rx</code>传递给上层协议栈。数据是<code>mbuf</code>类型的。</p>
<p>所以我们只需实现协议栈最底下的部分，也即从网卡读写数据，其他一些别的东西比如协议栈什么的都已经写好了。</p>
<p>但是那些什么<code>rx_ring</code>，还有各种奇奇怪怪的寄存器，我都看不懂，所以我就去看第三章了。初次略过一遍感觉还是一脸懵逼不知道干什么，但我带着“我们要做的是driver”这样的想法，在第二遍细看的时候有意区分开什么是网卡硬件帮我们做的，什么是我们的driver软件需要做的（<strong>经验2：明确要做什么。我们需要做的是软件部分，它的文档一般会说Software should XXX，密切关注这部分就行</strong>），就差不多有了点实现的雏形：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> recv:</span><br><span class="line">  <span class="comment">// 通过net_rx，网络包可以发送到udp顶层.</span></span><br><span class="line">  <span class="comment">// 所以说，我们在这里的目的就是，通过与硬件网卡e1000进行交互，</span></span><br><span class="line">  <span class="comment">// 取出e1000所接收到的数据包，检查数据的完整性，然后再把数据封装进mbuf结构体中，再通过net_rx传到上层</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出数据包</span></span><br><span class="line">  <span class="comment">// 数据包存储在网卡的缓冲区中</span></span><br><span class="line">  <span class="comment">// 一是获取网卡缓冲区长度的长度</span></span><br><span class="line">  <span class="comment">// 网卡缓冲区长度存储在RCTL.BSIZE &amp; RCTL.BSEX中</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *RCTL.BSEX = 0b:</span></span><br><span class="line"><span class="comment">00b = 2048 Bytes.</span></span><br><span class="line"><span class="comment">01b = 1024 Bytes.</span></span><br><span class="line"><span class="comment">10b = 512 Bytes.</span></span><br><span class="line"><span class="comment">1b1 = 256 Bytes.</span></span><br><span class="line"><span class="comment">RCTL.BSEX = 1b:</span></span><br><span class="line"><span class="comment">00b = Reserved; software should not program this value.</span></span><br><span class="line"><span class="comment">01b = 16384 Bytes.</span></span><br><span class="line"><span class="comment">10b = 8192 Bytes.</span></span><br><span class="line"><span class="comment">11b = 4096 Bytes</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="comment">// 二是获取数据包存放在哪个地址</span></span><br><span class="line">  <span class="comment">// 数据包的buffer cache的地址存储在descriptor的字段中</span></span><br><span class="line">  <span class="comment">// 必须读取多个descriptor以确定跨越多个接收缓冲区的数据包的完整长度。</span></span><br><span class="line">  <span class="comment">// 那么我们要读取的这些descriptor存放在哪呢？</span></span><br><span class="line">  <span class="comment">// 看文档，似乎差不多意思是这些descriptor被以环形队列的形式组织在一起，也许正是</span></span><br><span class="line">  <span class="comment">// 本文件内的rx_ring这个数组。</span></span><br><span class="line">  <span class="comment">// 当有descriptor到达e1000，e1000就会把它从host memory中取出来，存入到descriptor ring</span></span><br><span class="line">  <span class="comment">// 也即我们rx_ring数组</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 所以我们要做的，就是遍历rx_ring数组，如果rx_ring数组中的元素是used的，那么表明它就是数据包的一部分</span></span><br><span class="line">  <span class="comment">// 也即它地址所指向的buf里存放的是数据包的一部分数据</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// 那么我们怎么知道这个rx_ring的元素有没有used，以及它是第几个呢?</span></span><br><span class="line">  <span class="comment">// 检查descriptor有没有used：status字段不为全0则为used</span></span><br><span class="line">  <span class="comment">// 并且硬件要求，我们在发现这个descriptor的status不为0，并且用完这个descriptor之后，需要将</span></span><br><span class="line">  <span class="comment">// 其status字段置零，以供硬件使用</span></span><br><span class="line">  <span class="comment">// Status information indicates whether the descriptor has been used and whether the referenced </span></span><br><span class="line">  <span class="comment">// buffer is the last one for the packet.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 三是获取数据包的数据</span></span><br><span class="line">  <span class="comment">// 我们需要获取decriptor的该字段，然后再从这个地址读取数据包数据</span></span><br><span class="line">  <span class="comment">// 网卡和内存统一编址，这个数据实际上就是网卡的buffer</span></span><br><span class="line">  <span class="comment">// 我们应该直接通过read这个系统调用就可以对其进行读写了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// check数据包</span></span><br><span class="line">  <span class="comment">// 检查RDESC.ERRORS位，如果包发生了错误，再检查，如果发现RCTL.SBP、RCTL.UPE/MPE都被标记，</span></span><br><span class="line">  <span class="comment">// 就接收这个包，否则直接丢弃</span></span><br></pre></td></tr></table></figure>

<p>可以看到，跟正确思路虽然很多细节理解上有点问题，但是大体框架还是大差不差。然后再阅读指导书：</p>
<blockquote>
<p>When the E1000 receives each packet from the ethernet, <strong>it first DMAs the packet to the mbuf pointed to by the next RX (receive) ring descriptor, and then generates an interrupt</strong>. 【这句话可得知，<code>descriptor</code>们存放在代码中的<code>rx_ring</code>中。】</p>
<p>Your <code>e1000_recv()</code> code must <strong>scan</strong> the RX ring and <strong>deliver each</strong> new packet’s mbuf to the network stack (in <code>net.c</code>) by calling <code>net_rx()</code>. You will then need to <strong>allocate</strong> a new mbuf and place it into the descriptor, so that when the E1000 reaches that point in the RX ring again it finds a fresh buffer into which to DMA a new packet.</p>
</blockquote>
<p>就差不多是正确思路了。<code>transmit</code>的实现也是同理</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><blockquote>
<p>以下代码不知道为什么过不了test，我跟别人的逻辑一模一样也还是不行emmm</p>
<p>它的问题是，不会接收到外界的返ping，导致进程一直等待网卡IO，所以kerneltrap一直触发不了，无法正常网卡读写，从而导致<code>fileread</code>会一直处于sleep等待状态，整个系统就沉睡了【】我感觉应该是<code>transmit</code>没发成功。</p>
<p>等以后有精力再来看看吧。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> <span class="title">tx</span> =</span> tx_ring[regs[E1000_TDT]];</span><br><span class="line">  <span class="keyword">if</span>((tx.status &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(tx_mbufs[regs[E1000_TDT]] != <span class="number">0</span>)    mbuffree(tx_mbufs[regs[E1000_TDT]]);</span><br><span class="line">  tx.addr = (uint64) m-&gt;head;</span><br><span class="line">  tx.length = m-&gt;len;</span><br><span class="line">  tx.status |= <span class="number">1</span>;<span class="comment">// EOP</span></span><br><span class="line">  tx.cmd |= <span class="number">1</span>;<span class="comment">//EOP</span></span><br><span class="line">  tx.cmd |= <span class="number">8</span>;<span class="comment">//RS</span></span><br><span class="line">  tx_mbufs[regs[E1000_TDT]] = m;</span><br><span class="line">  regs[E1000_TDT] = (regs[E1000_TDT]+<span class="number">1</span>)%TX_RING_SIZE;</span><br><span class="line">  <span class="comment">// printf(&quot;send successful!\n&quot;);</span></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;go into e1000_recv\n&quot;</span>);</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//while(regs[E1000_RDT]!=regs[E1000_RDH])&#123;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;go into while\n&quot;</span>);</span><br><span class="line">    regs[E1000_RDT] = (regs[E1000_RDT] + <span class="number">1</span>)%RX_RING_SIZE;</span><br><span class="line">    <span class="type">int</span> i=regs[E1000_RDT];</span><br><span class="line">    <span class="keyword">if</span>(rx_ring[i].status != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 包含所需数据包</span></span><br><span class="line">      <span class="comment">// 检查是否发生了错误</span></span><br><span class="line">      <span class="comment">//if((rx_ring[i].status &amp; 1) !=0 &amp;&amp; (rx_ring[i].status &amp; 2) != 0)&#123;</span></span><br><span class="line">  <span class="comment">//      // error字段有效</span></span><br><span class="line">  <span class="comment">//    if(rx_ring[i].errors != 0)&#123;</span></span><br><span class="line">          <span class="comment">// 发生错误，直接丢弃</span></span><br><span class="line">  <span class="comment">//      goto end;</span></span><br><span class="line">  <span class="comment">//    &#125;</span></span><br><span class="line">      <span class="keyword">if</span>((rx_ring[i].status &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">      	release(&amp;e1000_lock);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将地址对应数据包发送</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>* <span class="title">m</span> =</span> rx_mbufs[i];</span><br><span class="line">      m-&gt;len = rx_ring[i].length;</span><br><span class="line">      net_rx(m);</span><br><span class="line">      rx_ring[i].status = <span class="number">0</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>* <span class="title">mbuf</span> =</span> mbufalloc(MBUF_DEFAULT_HEADROOM);</span><br><span class="line">      rx_ring[i].addr = (uint64) mbuf-&gt;head;</span><br><span class="line">      rx_mbufs[i] = mbuf;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Scheduling</title>
    <url>/2023/01/10/xv6$chap7/</url>
    <content><![CDATA[<h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><h2 id="Code-Context-switching"><a href="#Code-Context-switching" class="headerlink" title="Code: Context switching"></a>Code: Context switching</h2><p>xv6中，每个CPU中的scheduler都有一个专用的线程。这里线程的概念是，有自己的栈，有自己的寄存器状态。</p>
<p>当发生时钟中断时，当前进程调用yield，yield再通过swtch切换到scheduler线程。scheduler线程会通过swtch跳转到另外一个进程去执行。当另外一个进程发生时钟中断，又会通过yield回到scheduler，scheduler再调度原进程继续执行，如此周而复始。</p>
<blockquote>
<p>Linux的调度原理也差不多类似这样。每个CPU都有一个调度类为SCHED_CLASS_IDLE的IDLE进程，IDLE进程体大概就是间歇不断地执行__schedule()函数，CPU空闲时就会不断执行IDLE线程。</p>
<p>而当有新的任务产生时（或任务被唤醒。可以从此看出task new和task wakeup的共通点，可以联想到竞赛中对该消息的处理方法），它首先通过调度类对应的select_cpu选择一个合适的（可以被抢占&amp;&amp;在该task对应的cpumask中）的cpu，迁移到cpu对应的rq；目标cpu通过IDLE进程体或者中断返回时检查到了NEED_SCHEDULE标记位，从而调用schedule函数pick新任务，然后进行context_switch切换到目标线程。如此周而复始。</p>
</blockquote>
<p><img src="/2023/01/10/xv6/image-20230118221757367.png" alt="image-20230118221757367"></p>
<p>下面就来讲讲这个所谓的“线程”以及xv6的上下文切换是怎么实现的。</p>
<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>上下文切换的操作对象是上下文，因而首先了解一下上下文的结构。各种寄存器的状态即是上下文context。xv6中的context定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上下文切换需要修改栈和pc，context中确实有sp寄存器，但是没有pc寄存器，这主要还是因为当swtch返回时，会回到ra所指向的地方，所以仅保存ra就足够了。</p>
<h3 id="swtch"><a href="#swtch" class="headerlink" title="swtch"></a>swtch</h3><p>上下文的切换是通过swtch实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>            <span class="title function_">swtch</span><span class="params">(<span class="keyword">struct</span> context*, <span class="keyword">struct</span> context*)</span>;</span><br></pre></td></tr></table></figure>

<p>swtch会把当前进程的上下文保存在第一个context中，再切换到第二个context保存的上下文，具体实现就是写读保存寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># in kernel/swtch.S</span><br><span class="line"># a0和a1分别保存着两个参数的值，也即第一个context的地址和第二个context的地址</span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        sd s1, 24(a0)</span><br><span class="line">        # ...</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ld s1, 24(a1)</span><br><span class="line">        # ...</span><br><span class="line">        ld 11, 104(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><p>在sleep、yield和wakeup中，都会通过sched中的swtch进入scheduler线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get()) <span class="comment">// 当持有锁时一定为关中断状态</span></span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena;</span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpu中存储着的是scheduler线程的context。因而，这样就可以保存当前进程的context，读取scheduler线程的context，然后转换到scheduler的context执行了。</p>
<blockquote>
<p>可以发现这里是有个很完美的组合技的。由sched()保存context到process结构体中，再由scheduler()读取process对应的context回归到sched()继续执行，我感觉调度设计这点真是帅的一匹。</p>
</blockquote>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过swtch进入scheduler线程后，会继续执行scheduler中swtch的下一个指令，完成下一次调度。</p>
<h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><p>以上是书本的介绍内容。看到这想必会有很多疑惑，至少有以下两点：</p>
<ol>
<li>为什么cpu-&gt;context会存储着scheduler的上下文？这是什么时候，又是怎么初始化的？</li>
<li>为什么从sched中swtch会来到scheduler中swtch的下一句？</li>
</ol>
<p>先从第一点入手。实际上，这个初始化的工作，是在操作系统启动时的<code>main.c</code>中完成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这之前，创建了第一个进程proc。在这里，每个cpu都调用了scheduler。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个cpu都在scheduler线程的<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context);</code>中，将当前的context，<strong>也即scheduler的context</strong>存入了<code>mycpu()-&gt;context</code>。随后，CPU中的某个去执行下一个进程，其他的就在scheduler线程的<strong>无限循环中等待</strong>，直到有别的进程产生。</p>
<p>去执行进程的CPU通过swtch切换上下文，切到了另一个进程中，此时在swtch中保存的ra是scheduler线程的swtch的下一句（因为scheduler-&gt;swtch也是个函数调用的过程）。会切到另一个进程的sched的下一句【因为它正是从那边swtch过来的】，或者是那个进程开始执行的地方【下面会提到是forkret】。另一个进程通过sched切换回来的时候，就正会切到ra所指向的位置，也即切到scheduler中的swtch后面。</p>
<p>这样一来，两个问题就都得到了解答。</p>
<p><strong>从这，我们也能知道xv6是如何让CPU运转的：scheduler线程是CPU的IDLE状态。无事的时候在scheduler中等待，并且一直监测是否有进程需要执行。有的话，则去执行该进程；该进程又会通过sched切换回scheduler线程，继续等待。这样一来，就完成了进程管理的基本的自动机图像。</strong></p>
<h2 id="Code-Scheduling"><a href="#Code-Scheduling" class="headerlink" title="Code: Scheduling"></a>Code: Scheduling</h2><h3 id="sched前要做的事"><a href="#sched前要做的事" class="headerlink" title="sched前要做的事"></a>sched前要做的事</h3><blockquote>
<p> A process that wants to give up the CPU must do three things:</p>
<ol>
<li>acquire its own process lock p-&gt;lock, release any other locks it is holding</li>
<li>update its own state (p-&gt;state)</li>
<li>call sched</li>
</ol>
<p> <code>yield</code> (kernel/proc.c:515) follows this convention, as do <code>sleep</code> and <code>exit</code>.</p>
<p> <code>sched</code> double-checks those conditions (kernel/proc.c:499-504) and then an implication of those conditions:  since a lock is held, interrupts should be disabled.</p>
</blockquote>
<h3 id="sched与scheduler"><a href="#sched与scheduler" class="headerlink" title="sched与scheduler"></a>sched与scheduler</h3><p>在上面的描述我们可以看到，<code>sched</code>和<code>scheduler</code>联系非常密切，他们俩通过<code>swtch</code>相互切来切去，并且一直都只在这几行切来切去：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in scheduler()</span></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// in sched()</span></span><br><span class="line">swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">mycpu()-&gt;intena = intena;</span><br></pre></td></tr></table></figure>

<p>在两个线程之间进行这种样式化切换的过程有时被称为协程（coroutines）。</p>
<blockquote>
<p>存在一种情况使得调度程序对<code>swtch</code>的调用没有以<code>sched</code>结束。一个新进程第一次被调度时，它从<code>forkret</code>（<strong>kernel/proc.c</strong>:527）开始。<code>Forkret</code>是为了释放<code>p-&gt;lock</code>而包装的，要不然，新进程可以从<code>usertrapret</code>开始。</p>
</blockquote>
<h3 id="p-gt-lock保证了并发安全性"><a href="#p-gt-lock保证了并发安全性" class="headerlink" title="p-&gt;lock保证了并发安全性"></a>p-&gt;lock保证了并发安全性</h3><blockquote>
<p>考虑调度代码结构的一种方法是，它为每个进程强制维持一个不变性条件的集合，并在这些不变性条件不成立时持有<code>p-&gt;lock</code>。</p>
<p>其中一个不变性条件是：如果进程是<code>RUNNING</code>状态，计时器中断的<code>yield</code>必须能够安全地从进程中切换出去；这意味着CPU寄存器必须保存进程的寄存器值（即<code>swtch</code>没有将它们移动到<code>context</code>中），并且<code>c-&gt;proc</code>必须指向进程。另一个不变性条件是：如果进程是<code>RUNNABLE</code>状态，空闲CPU的调度程序必须安全地运行它；这意味着<code>p-&gt;context</code>必须保存进程的寄存器（即，它们实际上不在实际寄存器中），没有CPU在进程的内核栈上执行，并且没有CPU的<code>c-&gt;proc</code>引用进程。</p>
<p><u>维护上述不变性条件是xv6经常在一个线程中获取p-&gt;lock并在另一个线程中释放它的原因</u>，在保持<code>p-&gt;lock</code>时，这些属性通常不成立。</p>
<p>例如在<code>yield</code>中获取并在<code>scheduler</code>中释放。一旦<code>yield</code>开始修改一个<code>RUNNING</code>进程的状态为<code>RUNNABLE</code>，锁必须保持被持有状态，直到不变量恢复：最早的正确释放点是<code>scheduler</code>（在其自身栈上运行）清除<code>c-&gt;proc</code>之后。类似地，一旦<code>scheduler</code>开始将<code>RUNNABLE</code>进程转换为<code>RUNNING</code>，在内核线程完全运行之前（在<code>swtch</code>之后，例如在<code>yield</code>中）绝不能释放锁。</p>
<p><code>p-&gt;lock</code>还保护其他东西：<code>exit</code>和<code>wait</code>之间的相互作用，避免丢失<code>wakeup</code>的机制（参见第7.5节），以及避免一个进程退出和其他进程读写其状态之间的争用（例如，<code>exit</code>系统调用查看<code>p-&gt;pid</code>并设置<code>p-&gt;killed</code>(<strong>kernel/proc.c</strong>:611)）。为了清晰起见，也许为了性能起见，有必要考虑一下<code>p-&gt;lock</code>的不同功能是否可以拆分。</p>
</blockquote>
<p>p-&gt;lock在每次scheduler开始的时候获取，swtch到p进程的时候在yield等调用完sched的地方释放。而调用yield时获取的锁，又会在scheduler中释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Give up the CPU for one scheduling round.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);<span class="comment">// 该锁会在scheduler中释放</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  sched();</span><br><span class="line">  release(&amp;p-&gt;lock);<span class="comment">// 该锁释放的是scheduler中得到的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/proc.c scheduler()</span></span><br><span class="line">	  acquire(&amp;p-&gt;lock);<span class="comment">// 该锁会在yield等地被释放</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">      release(&amp;p-&gt;lock);<span class="comment">// 该锁会释放yield等地中获得的锁</span></span><br></pre></td></tr></table></figure>

<p>不得不说，这结构实在是太精妙了。这中间的如此多的复杂过程，就这样成功地被锁保护了起来。</p>
<h2 id="Code-mycpu-and-myproc"><a href="#Code-mycpu-and-myproc" class="headerlink" title="Code: mycpu and myproc"></a>Code: mycpu and myproc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mycpu是通过获取当前cpuid来获取cpu结构的。当前使用的cpuid约定俗成地存在了tp寄存器里。为了让mycpu有效工作，必须确保tp寄存器始终存放的是当前cpu的hartid。</p>
<p>首先是在操作系统初始化的时候要把cpuid存入tp寄存器。RISC-V规定，mhartid也即cpuid的存放点只能在machine mode被读取。因而这项工作得在<code>start.c</code>中完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/start.c </span></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"><span class="comment">// in kernel/riscv.h</span></span><br><span class="line"><span class="comment">// which hart (core) is this?</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_mhartid</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, mhartid&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内核态中，编译器被设置为保证不会以其他方式使用tp寄存器。因而初始化之后，内核态中每个CPU的tp寄存器就始终存放着自己的cpuid。</p>
<p>但这在用户进程是不成立的。因而必须在用户进程进入陷阱的时候做一些工作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># in kernel/trampoline.S uservec</span><br><span class="line">sd tp, 64(a0)</span><br><span class="line"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">ld tp, 32(a0)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须在trampoline保存用户态中使用的tp值，以及内核态中对应的hartid。</p>
<p>最后再在返回用户态的时候恢复用户态的tp值以及更新trampoline的tp值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in kernel/trap.c usertrapret()</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># in trampoline.S userret</span><br><span class="line">ld tp, 64(a0)</span><br></pre></td></tr></table></figure>

<p>注意，更新trampoline的tp值这一步很重要。因为如果在用户态发生的是时钟中断，就会引起yield，可能造成CPU的切换。这时候就需要在返回用户态的时候修改一下trapframe中的tp为当前CPU的tp。这样一来才能保证，在本次时钟中断结束，以及到下一次时钟中断修改CPU这一期间，trapframe中的tp寄存器以及内核态中的tp寄存器都是正确的。</p>
<p>通过<code>mycpu()</code>获取cpuid其实是非常脆弱的。因为你可能获取完cpuid，进程就被切到别的CPU去执行了，这就会有一个先检查后执行的竞态条件，具有并发安全隐患。因而，xv6要求使用<code>mycpu()</code>返回值的这段代码需要关中断，这样就可以避免时钟中断造成的进程切换了。比如说像<code>myproc()</code>这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return the current struct proc *, or zero if none.</span></span><br><span class="line"><span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，不同于<code>mycpu()</code>，使用<code>myproc()</code>的返回值不需要进行开关中断保护。因为当前进程的指针不论处于哪个CPU都是不变的。</p>
<h2 id="Sleep-and-wakeup"><a href="#Sleep-and-wakeup" class="headerlink" title="Sleep and wakeup"></a>Sleep and wakeup</h2><p>前面我们已经介绍了进程隔离性的基本图像，接下来要讲xv6是如何让进程之间互动的。xv6使用的是经典的<em>sleep and wakeup</em>，也叫<em>序列协调（sequence coordination）</em>或<em>条件同步机制（conditional synchronization mechanisms</em>。下面，将从最基本的自旋锁实现信号量开始，来逐步讲解xv6的<em>sleep and wakeup</em>机制。</p>
<h3 id="自旋锁实现信号量"><a href="#自旋锁实现信号量" class="headerlink" title="自旋锁实现信号量"></a>自旋锁实现信号量</h3><p><img src="/2023/01/10/xv6/image-20230120150659730.png" alt="image-20230120150659730"></p>
<p><img src="/2023/01/10/xv6/image-20230120150715925.png" alt="image-20230120150715925"></p>
<p>缺点就是自旋太久了，因而我们需要在等待的时候调用yield，直到资源生产出来之后再继续执行。</p>
<h3 id="不安全的sleep-and-wakeup"><a href="#不安全的sleep-and-wakeup" class="headerlink" title="不安全的sleep and wakeup"></a>不安全的sleep and wakeup</h3><blockquote>
<p>Let’s imagine a pair of calls, sleep and wakeup, that work as follows:</p>
<ol>
<li><p><code>sleep(chan)</code></p>
<p>Sleeps on the arbitrary value chan, called the <em>wait channel</em>. Sleep puts the calling process to sleep, releasing the CPU for other work.  </p>
</li>
<li><p><code>wakeup(chan)</code></p>
<p>Wakes <strong>all</strong> processes sleeping on chan (if any), causing their sleep calls to return. If no processes are waiting on chan, wakeup does nothing.</p>
</li>
</ol>
</blockquote>
<p>这样一来，信号量实现就可修改为这样了：</p>
<p><img src="/2023/01/10/xv6/image-20230120151051989.png" alt="image-20230120151051989"></p>
<p>但是，我们可以注意到，在212-213行这里产生了一个先检查后执行的竞态条件。</p>
<blockquote>
<p>如果消费者进程执行到212-213中间，此时生产者进程已经调用结束，也就是说wakeup并没有唤醒任何消费者进程。消费者进程就会一直在sleep中没人唤醒，除非生产者进程再执行一次。这样就会造成<em>lost wake-up</em> 这个问题。</p>
</blockquote>
<p>所以，我们可以选择把这个竞态条件也放入s-&gt;lock这个锁区域保护。</p>
<p><img src="/2023/01/10/xv6/image-20230120151353712.png" alt="image-20230120151353712"></p>
<p>但是这样一来又会产生死锁问题。因而，我们可以尝试着修改sleep和wakeup的接口定义。</p>
<h3 id="sleep-and-wakeup"><a href="#sleep-and-wakeup" class="headerlink" title="sleep and wakeup"></a>sleep and wakeup</h3><blockquote>
<p>We’ll fix the preceding scheme by changing sleep’s interface: </p>
<p>The caller must pass the <em>condition lock</em> to sleep so it can <strong>release the lock</strong> after the calling process is marked as asleep and waiting on the sleep channel. The lock will force a concurrent V to wait until P has finished putting itself to sleep, so that the wakeup will find the sleeping consumer and wake it up. Once the consumer is awake again sleep <strong>reacquires the lock</strong> before returning. </p>
<p>也即在sleep中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sleep(s,&amp;s-&gt;lock)&#123;</span><br><span class="line"> <span class="comment">// do something</span></span><br><span class="line">	release(&amp;s-&gt;lock);</span><br><span class="line">	<span class="comment">//wait until wakeup</span></span><br><span class="line"> acquire(&amp;s-&gt;lock);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样一来，信号量就可以完美实现了：</p>
<p><img src="/2023/01/10/xv6/image-20230120151807102.png" alt="image-20230120151807102"></p>
<p><img src="/2023/01/10/xv6/image-20230120151820455.png" alt="image-20230120151820455"></p>
<blockquote>
<p>注：严格地说，<code>wakeup</code>只需跟在<code>acquire</code>之后就足够了（也就是说，可以在<code>release</code>之后调用<code>wakeup</code>）</p>
<p>【想了一下，有一说一确实，放在release前后都不影响】</p>
</blockquote>
<blockquote>
<p>原始Unix内核的<code>sleep</code>只是禁用了中断，这就足够了，因为Unix运行在单CPU系统上。因为xv6在多处理器上运行，所以它为<code>sleep</code>添加了一个显式锁。</p>
</blockquote>
<h2 id="Code-Sleep-and-wakeup"><a href="#Code-Sleep-and-wakeup" class="headerlink" title="Code: Sleep and wakeup"></a>Code: Sleep and wakeup</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Atomically release lock and sleep on chan.</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    <span class="comment">// 获取进程锁，释放外部锁</span></span><br><span class="line">    <span class="comment">// 此进程锁将在scheduler线程中释放</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    release(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line">  <span class="comment">// 到这里来，说明已经被wakeup且被调度了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    <span class="comment">//释放进程锁，获取外部锁</span></span><br><span class="line">    <span class="comment">// 此进程锁是在scheduler中获取到的</span></span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    acquire(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果lk为p-&gt;lock，那么<strong>lk依然会在scheduler线程中被暂时释放</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到，关于<code>chan</code>这一变量的取值是非常任意的，仅需取一个约定俗成的值就OK。这里取为了信号量的地址，同时满足了逻辑需求和语义需求。</p>
<blockquote>
<p>Callers of sleep and wakeup can use any mutually convenient number as the channel. Xv6 often uses the address of a kernel data structure involved in the waiting.</p>
</blockquote>
<p>这里也解释了为什么需要while循环</p>
<blockquote>
<p>有时，多个进程在同一个通道上睡眠；例如，多个进程读取同一个管道。一个单独的<code>wakeup</code>调用就能把他们全部唤醒。其中一个将首先运行并获取与<code>sleep</code>一同调用的锁，并且（在管道例子中）读取在管道中等待的任何数据。尽管被唤醒，其他进程将发现没有要读取的数据。从他们的角度来看，醒来是“虚假的”，他们必须再次睡眠。因此，在检查条件的循环中总是调用<code>sleep</code>。</p>
</blockquote>
<h2 id="Code-Pipes"><a href="#Code-Pipes" class="headerlink" title="Code: Pipes"></a>Code: Pipes</h2><p>pipes很显然就是生产者消费者模式的一个例证。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">  uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">  uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">  <span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">  <span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">piperead</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="comment">//DOC: pipe-empty并且依然有进程在写</span></span><br><span class="line">    <span class="keyword">if</span>(pr-&gt;killed)&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待直到pipe不为空</span></span><br><span class="line">    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="comment">//DOC: piperead-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">//DOC: piperead-copy</span></span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];</span><br><span class="line">    <span class="keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒写入管道的进程</span></span><br><span class="line">  wakeup(&amp;pi-&gt;nwrite);  <span class="comment">//DOC: piperead-wakeup</span></span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipewrite</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123;  <span class="comment">//DOC: pipewrite-full管道满则阻塞</span></span><br><span class="line">      <span class="keyword">if</span>(pi-&gt;readopen == <span class="number">0</span> || pr-&gt;killed)&#123;</span><br><span class="line">        release(&amp;pi-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 唤醒读取管道的进程</span></span><br><span class="line">      wakeup(&amp;pi-&gt;nread);</span><br><span class="line">      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;pi-&gt;nread);</span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非常有意思且巧妙的点，就是<strong>读写管道等待在不同的chan上</strong>，这与上面信号量的例子是不一样的。想想也确实，如果使用同一个管道的话，当唤醒的时候，就会把不论是读还是写的全部进程都唤醒过来，这对性能显然损失较大。</p>
<blockquote>
<p>The pipe code uses separate sleep channels for reader and writer (pi-&gt;nread and pi-&gt;nwrite); this might make the system more effificient in the unlikely event that there are lots of readers and writers waiting for the same pipe.</p>
</blockquote>
<h2 id="Code-Wait-exit-and-kill"><a href="#Code-Wait-exit-and-kill" class="headerlink" title="Code: Wait, exit, and kill"></a>Code: Wait, exit, and kill</h2><h3 id="exit和wait"><a href="#exit和wait" class="headerlink" title="exit和wait"></a>exit和wait</h3><blockquote>
<p><code>Sleep</code>和<code>wakeup</code>可用于多种等待。第一章介绍的一个有趣的例子是子进程<code>exit</code>和父进程<code>wait</code>之间的交互。</p>
<p>xv6记录子进程终止直到<code>wait</code>观察到它的方式是让<code>exit</code>将调用方置于<code>ZOMBIE</code>状态，在那里它一直保持到父进程的<code>wait</code>注意到它，将子进程的状态更改为<code>UNUSED</code>，复制子进程的<code>exit</code>状态码，释放子进程，并将子进程ID返回给父进程。</p>
<p>如果父进程在子进程之前退出，则父进程将子进程交给<code>init</code>进程，<code>init</code>进程将永久调用<code>wait</code>；因此，每个子进程退出后都有一个父进程进行清理。</p>
</blockquote>
<p>又是一个生产者消费者模式。只不过此时的chan是父进程，资源是僵尸子进程【草】。由于涉及到进程间的调度切换，因而实现稍微复杂了点。</p>
<p>为什么需要涉及到进程间的调度呢？子进程设置完僵尸状态后，直接通过函数ret不行吗？答案是不行，因为ret的话就会去到不知道哪的地方【大概率会变成scause=2的情况】，所以这里子进程想要退出，就得做几件事，一是依靠父进程，让父进程杀死子进程，二是把自己设置为一个特殊的状态，使得自己不会被调度从而执行ret指令出错，三是尽快让父进程杀死自己越快越好。综合上述三个原因，exit最终在调度方面的实现方式，就变成了，子进程设置自己为ZOMBIE态-&gt;启用调度-&gt;父进程杀死ZOMBIE态的子进程。这期间不变性条件的防护，就得依赖于锁，以及sleep和wakeup了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// we need the parent&#x27;s lock in order to wake it up from wait().</span></span><br><span class="line">  <span class="comment">// the parent-then-child rule says we have to lock it first.</span></span><br><span class="line">  <span class="comment">// 整个xv6都必须遵守相同的顺序（父级，然后是子级）不论是锁定还是释放，都是先父再子</span></span><br><span class="line">  acquire(&amp;original_parent-&gt;lock);</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give any children to init.</span></span><br><span class="line">  <span class="comment">// 把自己的所有孩子都托付给init进程</span></span><br><span class="line">  <span class="comment">// init进程就是在操作系统启动时</span></span><br><span class="line">  reparent(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parent might be sleeping in wait().</span></span><br><span class="line">  <span class="comment">// 唤醒wait中的父进程</span></span><br><span class="line">  <span class="comment">// 这里看上去很诡异，明明子进程状态还未完全，怎么就唤醒父亲了呢？但其实很安全。</span></span><br><span class="line">  <span class="comment">// 此时子进程仍持有父进程的锁，如果有别的CPU中断进入scheduler线程，到父进程那时会卡在aquire</span></span><br><span class="line">  <span class="comment">// 直到子进程完成后续工作后父进程才能被真正唤醒执行</span></span><br><span class="line">  wakeup1(original_parent);</span><br><span class="line"></span><br><span class="line">  p-&gt;xstate = status;</span><br><span class="line">  <span class="comment">// 设为ZOMBIE态</span></span><br><span class="line">  p-&gt;state = ZOMBIE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成后续工作，解除父进程的锁</span></span><br><span class="line">  release(&amp;original_parent-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Jump into the scheduler, never to return.</span></span><br><span class="line">  <span class="comment">// 子进程会在父进程中被释放，所以永远不会回来</span></span><br><span class="line">  sched();</span><br><span class="line">  panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">wait</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hold p-&gt;lock for the whole time to avoid lost</span></span><br><span class="line">  <span class="comment">// wakeups from a child&#x27;s exit().</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;</span><br><span class="line">      <span class="comment">// this code uses np-&gt;parent without holding np-&gt;lock.</span></span><br><span class="line">      <span class="comment">// acquiring the lock first would cause a deadlock,</span></span><br><span class="line">      <span class="comment">// since np might be an ancestor, and we already hold p-&gt;lock.</span></span><br><span class="line">      <span class="comment">// 下面的第一点其实一句话就可以搞定：</span></span><br><span class="line">      <span class="comment">// 【它违反了先获取父亲锁，再获取子锁的xv6代码规定】</span></span><br><span class="line">      <span class="comment">// 1.要是在这句话之前acquire的话，acquire到你爸，你爸这时候也刚好执行到这句话</span></span><br><span class="line">      <span class="comment">// 那么就会造成你在自旋【此时你爸在wait一开始就得到了锁】，</span></span><br><span class="line">      <span class="comment">// 你爸也在自旋【你也在wait一开始得到了锁】,这样就造成了死锁</span></span><br><span class="line">      <span class="comment">// 2.并且由于np-&gt;parent只有parent才能改，所以数据是否过时是没关系的</span></span><br><span class="line">      <span class="comment">// 因为如果不是你儿子，数据过时与否都知道不是你儿子</span></span><br><span class="line">      <span class="comment">// 如果是你儿子，那数据压根就不会过时</span></span><br><span class="line">      <span class="keyword">if</span>(np-&gt;parent == p)&#123;</span><br><span class="line">        <span class="comment">// np-&gt;parent can&#x27;t change between the check and the acquire()</span></span><br><span class="line">        <span class="comment">// because only the parent changes it, and we&#x27;re the parent.</span></span><br><span class="line">        acquire(&amp;np-&gt;lock);</span><br><span class="line">        havekids = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(np-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          <span class="comment">// Found one.</span></span><br><span class="line">          pid = np-&gt;pid;</span><br><span class="line">          <span class="comment">// 传递返回参数</span></span><br><span class="line">          <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;np-&gt;xstate,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(np-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            release(&amp;np-&gt;lock);</span><br><span class="line">            release(&amp;p-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          freeproc(np);</span><br><span class="line">          release(&amp;np-&gt;lock);</span><br><span class="line">          release(&amp;p-&gt;lock);</span><br><span class="line">          <span class="keyword">return</span> pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don&#x27;t have any children.</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || p-&gt;killed)&#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for a child to exit.</span></span><br><span class="line">    <span class="comment">// 暂时释放p锁，等待子进程获取退出</span></span><br><span class="line">    sleep(p, &amp;p-&gt;lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中值得注意的几个点：</p>
<ol>
<li><p><code>wait</code>中的<code>sleep</code>中释放的条件锁是等待进程的<code>p-&gt;lock</code>，这是上面提到的特例。</p>
</li>
<li><p>exit会将自己的所有子进程交付给一直在等待着的init进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">    <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">    wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">      <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这里！！</span></span><br><span class="line">      <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子进程退出，就会通过init的wait释放它们。然后init释放完它们后进入第三个if分支，继续进行循环。</p>
</li>
<li><p>wakeup1</p>
<blockquote>
<p>Exit calls a specialized wakeup function, wakeup1, that wakes up only the parent, and only if it is sleeping in wait.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wake up p if it is sleeping in wait(); used by exit().</span></span><br><span class="line"><span class="comment">// Caller must hold p-&gt;lock.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup1</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;wakeup1&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;chan == p &amp;&amp; p-&gt;state == SLEEPING) &#123;</span><br><span class="line">    p-&gt;state = RUNNABLE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>kill其实做得很温和。它只是会把想鲨的进程的p-&gt;killed设置为1，然后如果该进程sleeping，则唤醒它。最后的死亡以及销毁由进程自己来做。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kill the process with the given pid.</span></span><br><span class="line"><span class="comment">// The victim won&#x27;t exit until it tries to go</span></span><br><span class="line"><span class="comment">// to kernel space (see usertrap() in trap.c).</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid == pid)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING)&#123;</span><br><span class="line">        <span class="comment">// Wake process from sleep().</span></span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// in trap.c usertrap()</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>可能这里有一个疑问：调用完exit后，进程会变成ZOMBIE态。谁最终把它释放了呢？其实答案很简单，只有两种：init进程或者是创建它的父进程。</p>
<p>如果创建它的父进程处于wait中，那么是由父进程把它销毁的，这没什么好说的。但如果创建它的父进程不在wait呢？那么父进程最后也是会调用exit的。父进程调用完exit后，会将其所有子进程过继给init进程。所以，ZOMBIE进程最终还是会迟早被init进程杀死的。</p>
<p>由这里，可以窥见xv6进程管理的进一步的冰山一角：</p>
<p>init进程是所有进程的根系进程。它一直处于wait的死循环中，因而可以将需要被杀死的进程杀死。</p>
<p>可见，wait和exit，实际上就构筑了进程的生命周期的最后一环。</p>
<p>这种巧妙地将进程生命周期这个大事<strong>完全托付给了wait和exit这两个函数</strong>的这种结构，实在是非常精妙，太牛了吧。</p>
<blockquote>
<p>一些XV6的<code>sleep</code>循环不检查<code>p-&gt;killed</code>，因为代码在应该是原子操作的多步系统调用的中间。virtio驱动程序（*<strong>kernel/virtio_disk.c*</strong>:242）就是一个例子：它不检查<code>p-&gt;killed</code>，因为一个磁盘操作可能是文件系统保持正确状态所需的一组写入操作之一。等待磁盘I/O时被杀死的进程将不会退出，直到它完成当前系统调用并且<code>usertrap</code>看到<code>killed</code>标志</p>
</blockquote>
<blockquote>
<p>Xv6对<code>kill</code>的支持并不完全令人满意：有一些<code>sleep</code>循环可能应该检查<code>p-&gt;killed</code>。一个相关的问题是，即使对于检查<code>p-&gt;killed</code>的<code>sleep</code>循环，<code>sleep</code>和<code>kill</code>之间也存在竞争；后者可能会设置<code>p-&gt;killed</code>，并试图在受害者的循环检查<code>p-&gt;killed</code>之后但在调用<code>sleep</code>之前尝试唤醒受害者。如果出现此问题，受害者将不会注意到<code>p-&gt;killed</code>，直到其等待的条件发生。这可能比正常情况要晚一点（例如，当virtio驱动程序返回受害者正在等待的磁盘块时）或永远不会发生（例如，如果受害者正在等待来自控制台的输入，但用户没有键入任何输入）。</p>
</blockquote>
<p>是的，所以这个kill的实现其实是相当玄学的。</p>
<h2 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h2><blockquote>
<p>xv6调度器实现了一个简单的调度策略：它依次运行每个进程。这一策略被称为轮询调度（round robin）。真实的操作系统实施更复杂的策略，例如，允许进程具有优先级。</p>
</blockquote>
<p>我记得linux0.11用的是时间片轮转+优先级队列完美融合的方法，是真的很牛逼</p>
<blockquote>
<p>复杂的策略可能会导致意外的交互，例如优先级反转（priority inversion）和航队（convoys）。当低优先级进程和高优先级进程共享一个锁时，可能会发生优先级反转，当低优先级进程持有该锁时，可能会阻止高优先级进程前进。当许多高优先级进程正在等待一个获得共享锁的低优先级进程时，可能会形成一个长的等待进程航队；一旦航队形成，它可以持续很长时间。为了避免此类问题，在复杂的调度器中需要额外的机制。</p>
</blockquote>
<blockquote>
<p>在<code>wakeup</code>中扫描整个进程列表以查找具有匹配<code>chan</code>的进程效率低下。一个更好的解决方案是用一个数据结构替换<code>sleep</code>和<code>wakeup</code>中的<code>chan</code>，该数据结构包含在该结构上休眠的进程列表，例如Linux的等待队列。</p>
</blockquote>
<p>是的，linux的那个wakeup真的很牛，我现在都还记得当初学到那的时候的震撼。</p>
<blockquote>
<p><code>wakeup</code>的实现会唤醒在特定通道上等待的所有进程，可能有许多进程在等待该特定通道。操作系统将安排所有这些进程，它们将竞相检查睡眠条件。进程的这种行为有时被称为<strong>惊群效应</strong>（thundering herd），最好避免。</p>
<p>大多数条件变量都有两个用于唤醒的原语：<code>signal</code>用于唤醒一个进程；<code>broadcast</code>用于唤醒所有等待进程。</p>
</blockquote>
<blockquote>
<p>一个实际的操作系统将在固定时间内使用空闲列表找到自由的<code>proc</code>结构体，而不是<code>allocproc</code>中的线性时间搜索；xv6使用线性扫描是为了简单起见。</p>
</blockquote>
<h2 id="Lab-Multithreading"><a href="#Lab-Multithreading" class="headerlink" title="Lab: Multithreading"></a>Lab: Multithreading</h2><blockquote>
<p>You will implement switching between threads in a user-level threads package, use multiple threads to speed up a program, and implement a barrier.</p>
</blockquote>
<p>这个introduction看起来还是非常激动人心的，很早就想了解到底线程是怎么实现的了。不过做完发现思想还是很简单的，就是只用切换上下文和栈就行。可以看看提供给的代码。</p>
<h3 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h3><blockquote>
<p>In this exercise you will design the <strong>context switch</strong> mechanism for a user-level threading system, and then implement it. </p>
<p>To get you started, your xv6 has two files <code>user/uthread.c</code> and <code>user/uthread_switch.S</code>, and a rule in the Makefile to build a uthread program. </p>
<p><code>uthread.c</code> contains most of a user-level threading package, and code for three simple test threads. The threading package is missing some of the code to create a thread and to switch between threads.</p>
<p>You will need to add code to <code>thread_create()</code> and <code>thread_schedule()</code> in <code>user/uthread.c</code>, and <code>thread_switch</code> in <code>user/uthread_switch.S</code>. </p>
<p>One goal is ensure that when <code>thread_schedule()</code> runs a given thread for the first time, the thread executes the function passed to <code>thread_create()</code>, on its <strong>own stack.</strong> </p>
<p>Another goal is to ensure that <code>thread_switch</code> saves the registers of the thread being switched away from, restores the registers of the thread being switched to, and returns to the point in the latter thread’s instructions where it last left off. You will have to decide where to save/restore registers; modifying <code>struct thread</code> to hold registers is a good plan. </p>
<p>You’ll need to add a call to <code>thread_switch</code> in <code>thread_schedule</code>; you can pass whatever arguments you need to <code>thread_switch</code>, but the intent is to switch from thread <code>t</code> to <code>next_thread</code>.</p>
</blockquote>
<p>实现的是用户级线程，其栈保存在对应父进程的地址空间中。</p>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>看了一遍它这里面写的题目还是有点抽象的，需要结合着给的代码看，那样就清晰多了。</p>
<p>首先，要补全的地方有这几个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. in thread_schedule()</span></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 2. in thread_create()</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. in uthread_switch.S</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * save the old thread&#x27;s registers,</span></span><br><span class="line"><span class="comment">         * restore the new thread&#x27;s registers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        .globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">        <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">        ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure>

<p>这几个函数到时候会被如此调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  a_started = b_started = c_started = <span class="number">0</span>;</span><br><span class="line">  a_n = b_n = c_n = <span class="number">0</span>;</span><br><span class="line">  thread_init();</span><br><span class="line">  thread_create(thread_a);</span><br><span class="line">  thread_create(thread_b);</span><br><span class="line">  thread_create(thread_c);</span><br><span class="line">  thread_schedule();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们在第一个地方要做的，就是要填入swtch的签名。第二个地方要做的，就是要想办法让该线程一被启动就去执行参数的函数指针。第三个地方要做的，就是要完成上下文的切换。</p>
<p>所以思路其实是很直观的。我们可以模仿进程管理中用来表示上下文的context，在<code>thread_create</code>的时候把里面的ra设置为参数的函数指针入口，sp修改为thread结构体中的栈地址。swtch函数则完全把<code>kernel/swtch.S</code>超过来就行。</p>
<blockquote>
<p>在这个思路中，我们是怎么做到栈的切换的呢？</p>
<p>每个线程在<code>thread_create</code>的时候，都将自己的context中的sp修改为自己的栈地址。这样一来，在它们被调度的时候，switch会自然而然地从context中读取sp作为之后运行的sp，这样就实现了栈的切换。</p>
</blockquote>
<h5 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h5><p>我觉得其他方面都不难，最坑最细节的【也是我完全没有想到的……】就是这里：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改sp为栈顶</span></span><br><span class="line">t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br></pre></td></tr></table></figure>

<p>需要注意，栈顶并不是<code>t-&gt;stack</code>。</p>
<p>通过测试程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0062f</span>eb8</span><br><span class="line"><span class="number">0062f</span>ebc</span><br><span class="line"><span class="number">0062f</span>ec0</span><br><span class="line"><span class="number">0062f</span>ec4</span><br><span class="line"><span class="number">0062f</span>ec8</span><br></pre></td></tr></table></figure>

<p>栈是向下增长的，因而，栈顶确实应该是数组的末尾……</p>
<p>这里完全没有想到，还是吃了基础的亏啊。</p>
<blockquote>
<p>如果这里将<code>t-&gt;stack</code>作为sp，那么运行时会出现非常诡异的现象（打印的是abc三个的<code>thread-&gt;state</code>）：</p>
<p><img src="/2023/01/10/xv6/image-20230120232149776.png" alt="image-20230120232149776"></p>
<p>仅有c【经测试，是仅有最后一个启动的线程】在执行，而ab的state都不是理想中的2，而是很奇怪的值。我确实有想过栈溢出问题，但是马上被我否定了。我完全没有想到是那样错的【悲】</p>
</blockquote>
<h5 id="关于swtch"><a href="#关于swtch" class="headerlink" title="关于swtch"></a>关于swtch</h5><p>Update，验收时学长问为什么这里的uswitch.S为什么无需保存tn这样的寄存器。答案是因为tn是caller-save的，线程这相当于仅仅是执行一个函数，所以只需保存callee-save的寄存器。</p>
<p>内核的swtch也只保存了这些callee-save的寄存器，也是同一个道理。</p>
<p><img src="/2023/01/10/xv6/image-20231219000100763.png" alt="image-20231219000100763"></p>
<p><img src="/2023/01/10/xv6/image-20231219000047041.png" alt="image-20231219000047041"></p>
<p>tn寄存器被保存在调用者的栈帧中。感觉也能理解为什么那题作业题说上文进程的现场是由栈保存了。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="增加context结构体定义，修改thread结构体"><a href="#增加context结构体定义，修改thread结构体" class="headerlink" title="增加context结构体定义，修改thread结构体"></a>增加context结构体定义，修改thread结构体</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-create"><a href="#修改thread-create" class="headerlink" title="修改thread_create"></a>修改thread_create</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">// 将当前上下文保存入context</span></span><br><span class="line">  thread_switch((uint64)(&amp;(t-&gt;context)),(uint64)(&amp;(t-&gt;context)));</span><br><span class="line">  <span class="comment">// 修改sp为栈顶</span></span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">  <span class="comment">// 修改ra为参数的函数指针入口</span></span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-schedule"><a href="#修改thread-schedule" class="headerlink" title="修改thread_schedule"></a>修改thread_schedule</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">  next_thread-&gt;state = RUNNING;</span><br><span class="line">  t = current_thread;</span><br><span class="line">  current_thread = next_thread;</span><br><span class="line">  <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">   * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">   * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  thread_switch((uint64)(&amp;(t-&gt;context)),(uint64)(&amp;(current_thread-&gt;context)));</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="修改thread-switch"><a href="#修改thread-switch" class="headerlink" title="修改thread_switch"></a>修改thread_switch</h5><p>全部照搬<code>kernel/swtch.S</code>，没什么好说的</p>
<h3 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h3><h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><blockquote>
<p>In this assignment you’ll implement a <a href="http://en.wikipedia.org/wiki/Barrier_(computer_science)">barrier</a>: a point in an application at which all participating threads must wait until all other participating threads reach that point too.</p>
</blockquote>
<p>直接上代码，还是比较简单的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">   pthread_mutex_lock(&amp;(bstate.barrier_mutex));</span><br><span class="line">   bstate.nthread++;</span><br><span class="line">   <span class="keyword">while</span>(bstate.nthread &lt; nthread)&#123;</span><br><span class="line">    pthread_cond_wait(&amp;(bstate.barrier_cond), &amp;(bstate.barrier_mutex));</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 此部分仅一个线程会进入</span></span><br><span class="line">   pthread_cond_broadcast(&amp;(bstate.barrier_cond));</span><br><span class="line">   bstate.nthread = <span class="number">0</span>;</span><br><span class="line">   bstate.round++;</span><br><span class="line">end:</span><br><span class="line">   pthread_mutex_unlock(&amp;(bstate.barrier_mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Update</p>
<p>关于pthread_cond的实现，也是使用了条件变量的思想，这个值得以后有时间了解一下。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>其他的对实验未涉及的思考</title>
    <url>/2023/01/10/xv6$chap9/</url>
    <content><![CDATA[<h1 id="其他的对实验未涉及的思考"><a href="#其他的对实验未涉及的思考" class="headerlink" title="其他的对实验未涉及的思考"></a>其他的对实验未涉及的思考</h1><h2 id="由mkfs引发的对虚拟机的学习"><a href="#由mkfs引发的对虚拟机的学习" class="headerlink" title="由mkfs引发的对虚拟机的学习"></a>由mkfs引发的对虚拟机的学习</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247489645&idx=5&sn=a6ad41806effb6bc8ff4815f4eab968a&chksm=fbb29193ccc51885348ce6dfb81661ecc17cd271bf6fb79a78a656b49d4eccaa9de7606c01cc&scene=27">懂了！VMware/KVM/Docker原来是这么回事儿</a>这篇文章对虚拟化、虚拟机技术讲解很到位，写得通俗易懂，非常值得一看</p>
<p><a href="https://www.zhihu.com/question/24123210/answer/2852910075">KVM 的「基于内核的虚拟机」是什么意思？</a>这篇文章对QEMU-KVM架构进行了详细的介绍。还有这篇文章对应的知乎问题下面的高赞回答有机会也可以去看看。</p>
<p><a href="https://blog.csdn.net/hbuxiaofei/article/details/113556046">QEMU/KVM原理概述</a>这篇文章前面的原理和上面那个差不多，后面有使用kvm做一个精简内核的实例，有兴趣/有精力/有需要可以看看。</p>
<p><a href="https://blog.csdn.net/qq_23924713/article/details/126080325">MIT6.S081操作系统实验——操作系统是如何在qemu虚拟机中启动的？</a></p>
<p><a href="https://blog.csdn.net/Mumu3w/article/details/54173069">xv6分析–mkfs源代码注释</a></p>
</blockquote>
<p>以前只是知道，xv6是运行在qemu提供的虚拟环境之上的。qemu是什么，怎么虚拟的，虚拟机和宿主机是怎么交互的，这些一概不通。今天心血来潮想研究下qemu，虚拟机啥的到底是什么玩意，虽然看得有些猪脑过载，但还是写下一些个人的整理。</p>
<h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>在了解qemu之前，可以先了解一下虚拟化的思想。</p>
<h5 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h5><blockquote>
<p>虚拟化的主要思想是，通过分层将底层的复杂、难用的资源虚拟抽象成简单、易用的资源，<strong>提供给上层</strong>使用。</p>
<p>本质上，计算机的发展过程也是虚拟化不断发展的过程，底层的资源或者通过<strong>空间的分割</strong>，或者通过<strong>时间的分割</strong>，将下层的资源通过一种简单易用的方式转换成另一种资源，提供给上层使用。</p>
<p>虚拟化可分为以下几方面：</p>
<ol>
<li><strong>CPU抽象</strong>：机器码、汇编语言到C语言、再到高级语言的不断虚拟的过程</li>
<li><strong>存储抽象</strong>：操作系统通过文件和目录抽象</li>
<li><strong>网络抽象</strong>：TCP/IP协议栈模型将网卡设备中传递的二进制数据，经过网络层、传输层的抽象后，为应用程序提供了便捷的网络包处理接口，而无需关心底层的IP路由、分片等细节</li>
<li><strong>进程抽象</strong>：操作系统通过进程抽象为不同的应用程序提供了安全隔离的执行环境，并且有着独立的CPU和内存等资源</li>
</ol>
</blockquote>
<p>虚拟化的思想实际上就是我以前一直称为“抽象”的思想，以接口的形式逐层向上服务。</p>
<h5 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h5><blockquote>
<p>虚拟机的核心能力在于<strong>提供一个执行环境</strong>（隐藏底层细节），并在其中完成用户的指定任务。</p>
</blockquote>
<blockquote>
<p>虚拟机有多种不同的<strong>形式</strong>，包括提供指令执行环境的进程、模拟器和高级语言虚拟机，或者是提供一个完整的系统环境的系统虚拟机。</p>
</blockquote>
<h6 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h6><p>进程实际上就是一种虚拟机。</p>
<blockquote>
<p>进程可以看作是一组<strong>资源的集合</strong>，有自己<strong>独立</strong>的进程地址空间以及<strong>独立</strong>的CPU和寄存器，执行程序员编写的指令，完成一定的任务。</p>
<p>操作系统可以创建多个进程，每一个进程都可以看成一个<strong>独立的虚拟机</strong>，它们在执行指令、访问内存的时候并不会相互影响影响。</p>
</blockquote>
<h6 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h6><h6 id="高级语言虚拟机"><a href="#高级语言虚拟机" class="headerlink" title="高级语言虚拟机"></a>高级语言虚拟机</h6><h6 id="系统虚拟机"><a href="#系统虚拟机" class="headerlink" title="系统虚拟机"></a>系统虚拟机</h6><blockquote>
<p>通过<a href="https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">系统虚拟化技术</a>，能够在<strong>单个的宿主机硬件平台上运行多个虚拟机</strong>，每个虚拟机都有着完整的虚拟机硬件，如虚拟的CPU、内存、虚拟的外设等，并且虚拟机之间能够实现完整的隔离。</p>
<p>在系统虚拟化中，管理全局物理资源的软件叫作<a href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%91%E6%8E%A7%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">虚拟机监控器</a>（Virtual Machine Monitor，VMM），<u>VMM之于虚拟机就如同操作系统之于进程</u>，VMM利用时分复用或者空分复用的办法将硬件资源在各个虚拟机之间进行分配。</p>
</blockquote>
<h5 id="qemu-1"><a href="#qemu-1" class="headerlink" title="qemu"></a>qemu</h5><p>可以看到，qemu就是一种虚拟机。它可以模拟虚拟机硬件，为操作系统提供虚拟硬件环境，从而能够让不同的操作系统能够在不同主机硬件上执行。</p>
<h4 id="qemu-kvm架构"><a href="#qemu-kvm架构" class="headerlink" title="qemu-kvm架构"></a>qemu-kvm架构</h4><h5 id="诞生的原因"><a href="#诞生的原因" class="headerlink" title="诞生的原因"></a>诞生的原因</h5><blockquote>
<p>其对于虚拟化技术的优化，以及发展的前因后果，具体可以看<a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247489645&idx=5&sn=a6ad41806effb6bc8ff4815f4eab968a&chksm=fbb29193ccc51885348ce6dfb81661ecc17cd271bf6fb79a78a656b49d4eccaa9de7606c01cc&scene=27">懂了！VMware/KVM/Docker原来是这么回事儿</a>这篇文章。</p>
<p>概括来讲，大致有以下几个要点：</p>
</blockquote>
<h6 id="两种虚拟化方案"><a href="#两种虚拟化方案" class="headerlink" title="两种虚拟化方案"></a>两种虚拟化方案</h6><p><img src="/2023/01/10/xv6/640.png" alt="640"></p>
<p><img src="/2023/01/10/xv6/640-1676793944101-7.png" alt="640-1676793944101-7"></p>
<h6 id="实现上述的虚拟化方案"><a href="#实现上述的虚拟化方案" class="headerlink" title="实现上述的虚拟化方案"></a>实现上述的虚拟化方案</h6><p>一个典型的做法是——<code>陷阱 &amp; 模拟</code>技术</p>
<p>什么意思？<strong>简单来说就是正常情况下直接把虚拟机中的代码指令放到物理的CPU上去执行，一旦执行到一些敏感指令，就触发异常，控制流程交给VMM，由VMM来进行对应的处理，以此来营造出一个虚拟的计算机环境。</strong></p>
<h6 id="x86架构的问题"><a href="#x86架构的问题" class="headerlink" title="x86架构的问题"></a>x86架构的问题</h6><p>x86架构使得上述做法用不了了。因为它引入了四种权限</p>
<p><img src="/2023/01/10/xv6/image-20230219160725978.png" alt="image-20230219160725978"></p>
<h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h6><ol>
<li><p>全虚拟化</p>
<p>VMware的二进制翻译技术、QEMU的模拟指令集</p>
</li>
<li><p>半虚拟化</p>
</li>
<li><p>硬件辅助虚拟化</p>
<p>硬件辅助虚拟化细节较为复杂，简单来说，新一代CPU在原先的Ring0-Ring3四种工作状态之下，再引入了一个叫工作模式的概念，有<code>VMX root operation</code>和<code>VMX non-root operation</code>两种模式，每种模式都具有完整的Ring0-Ring3四种工作状态，前者是VMM运行的模式，后者是虚拟机中的OS运行的模式。</p>
<p>qemu-kvm架构正是借助于此实现的。</p>
</li>
</ol>
<h6 id="kvm"><a href="#kvm" class="headerlink" title="kvm"></a>kvm</h6><p>kvm就是借助硬件辅助虚拟化诞生的。可以把kvm看作是一堆系统调用。</p>
<blockquote>
<p><a href="https://www.redhat.com/zh/topics/virtualization/what-is-KVM">什么是 KVM？</a></p>
<p>KVM本身是一个<strong>内核模块</strong>，它导出了一系列的<strong>接口</strong>到用户空间，用户态程序可以使用这些接口创建虚拟机。</p>
<p>具体而言，KVM 可帮助您将 Linux 转变为<a href="https://www.redhat.com/zh/topics/virtualization/what-is-a-hypervisor">虚拟机监控程序</a>，使主机计算机能够运行多个隔离的虚拟环境，即虚拟客户机或虚拟机（VM）。【也即，虚拟机—进程，KVM—操作系统】</p>
</blockquote>
<blockquote>
<p>在虚拟化底层技术上，<u>KVM和VMware后续版本一样</u>，都是基于<strong>硬件辅助虚拟化</strong>实现。不同的是VMware作为独立的第三方软件可以安装在Linux、Windows、MacOS等多种不同的操作系统之上，而KVM作为一项虚拟化技术已经<strong>集成</strong>到Linux内核之中，可以认为Linux内核本身就是一个HyperVisor，这也是KVM名字的含义，因此该技术只能在Linux服务器上使用。</p>
</blockquote>
<h6 id="qemu-kvm"><a href="#qemu-kvm" class="headerlink" title="qemu-kvm"></a>qemu-kvm</h6><p>KVM本身基于硬件辅助虚拟化，仅仅实现CPU和内存的虚拟化，但一台计算机不仅仅有CPU和内存，还需要各种各样的I/O设备，不过KVM不负责这些。这个时候，QEMU就和KVM搭上了线，经过改造后的QEMU，负责外部设备的虚拟，KVM负责底层执行引擎和内存的虚拟，两者彼此互补，成为新一代云计算虚拟化方案的宠儿。</p>
<h5 id="qemu-kvm总体架构"><a href="#qemu-kvm总体架构" class="headerlink" title="qemu-kvm总体架构"></a>qemu-kvm总体架构</h5><p>KVM只负责最核心的<strong>CPU虚拟化和内存虚拟化</strong>部分；QEMU作为其用户态组件，负责完成<strong>大量外设的模拟</strong>。</p>
<p><img src="/2023/01/10/xv6/v2-249a3f162de88198bbe415110fc71c7f_1440w.jpg" alt="v2-249a3f162de88198bbe415110fc71c7f_1440w"></p>
<h6 id="VMX-root和VMX-non-root"><a href="#VMX-root和VMX-non-root" class="headerlink" title="VMX root和VMX non root"></a>VMX root和VMX non root</h6><blockquote>
<p>VMX root是宿主机模式，此时CPU在运行包括QEMU在内的普通进程和宿主机的操作系统内核；</p>
<p>VMX non-root是<a href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2852910075%7D">虚拟机模式</a>，此时CPU在运行虚拟机中的用户程序和操作系统代码。</p>
</blockquote>
<p>也就是说，虚拟机的程序，包括用户程序和内核程序，都运行在non-root模式。宿主机的所有程序，包括用户程序【包括qemu】和内核程序【包括kvm】，都运行在root模式。</p>
<h6 id="qemu层（左上）"><a href="#qemu层（左上）" class="headerlink" title="qemu层（左上）"></a>qemu层（左上）</h6><p>上面说到，qemu负责的是大量外设的模拟。它具体要做以下几件事：</p>
<blockquote>
<p>初始化虚拟机：</p>
<ol>
<li><p>创建模拟的芯片组</p>
</li>
<li><p>创建<strong>CPU线程</strong>来表示虚拟机的CPU</p>
<p>QEMU在初始化虚拟机的CPU线程时，首先设置好相应的虚拟CPU寄存器的值，然后调用KVM的接口将虚拟机运行起来，这样CPU线程就会被调度在物理CPU上执行虚拟机的代码。</p>
</li>
<li><p><strong>在QEMU的虚拟地址空间中分配空间作为虚拟机的物理地址</strong></p>
</li>
<li><p>根据用户在命令行<strong>指定的设备</strong>为虚拟机创建对应的虚拟设备【如各种IO设备】</p>
</li>
</ol>
<p>虚拟机运行时：</p>
<ol>
<li><p>监听多种事件</p>
<p>包括虚拟机对设备的I/O访问、用户对虚拟机管理界面、虚拟设备对应的宿主机上的一些I/O事件（比如虚拟机网络数据的接收）等</p>
</li>
<li><p>调用函数处理</p>
</li>
</ol>
</blockquote>
<p>可以看到，qemu确实利用了宿主机的各种资源，提供了一个很完美的硬件环境。其资源对应关系为：</p>
<p>虚拟机的CPU——宿主机的一个线程</p>
<p>虚拟机的物理地址——qemu在宿主机的虚拟地址</p>
<p>虚拟机对硬件设备的访问 —→ 对qemu的访问 </p>
<h6 id="kvm层（下方）"><a href="#kvm层（下方）" class="headerlink" title="kvm层（下方）"></a>kvm层（下方）</h6><p>它大概做了两件事：</p>
<ol>
<li><p>给qemu提供运行时的参数</p>
<p>通过“/dev/kvm”设备，比如CPU个数、内存布局、运行等。</p>
</li>
<li><p>截获VM Exit事件【下面会讲，用来完成虚拟机和硬件环境的交互】并进行处理。</p>
</li>
</ol>
<h6 id="虚拟机层（右上）"><a href="#虚拟机层（右上）" class="headerlink" title="虚拟机层（右上）"></a>虚拟机层（右上）</h6><ol>
<li><p>CPU——QEMU进程中的一个线程</p>
<p>通过QEMU和KVM的相互协作，虚拟机的线程会被宿主机操作系统正常调度，<strong>直接执行虚拟机中的代码</strong></p>
</li>
<li><p>物理地址——QEMU进程中的虚拟地址</p>
</li>
<li><p>设备——QEMU实现</p>
<p>在运行过程中，虚拟机操作系统通过设备的I/O端口（Port IO、PIO）或者MMIO（Memory Mapped I/O）进行交互，<strong>KVM会截获这个请求</strong>【也即VM Exit，下面会讲】，大多数时候KVM会将请求分发到用户空间的QEMU进程中，由<strong>QEMU处理</strong>这些I/O请求</p>
</li>
</ol>
<h5 id="虚拟机在QEMU-KVM架构的执行方法"><a href="#虚拟机在QEMU-KVM架构的执行方法" class="headerlink" title="虚拟机在QEMU-KVM架构的执行方法"></a>虚拟机在QEMU-KVM架构的执行方法</h5><h6 id="状态管理虚拟化"><a href="#状态管理虚拟化" class="headerlink" title="状态管理虚拟化"></a>状态管理虚拟化</h6><p>虚拟机肯定是会与它的硬件环境进行交互的，它的硬件环境也就是QEMU—KVM。</p>
<p>虚拟机的用户程序和内核程序都是直接由宿主机的操作系统正常调度，我们可以将其看作虚拟态。QEMU—KVM可以看作是宿主机的进程，我们可以将其看作宿主态。因而，当虚拟机一些事情希望由QEMU—KVM来做，我们就需要从虚拟态转移到宿主态。</p>
<p>听起来有没有感觉很耳熟？是的，“从用户态陷入内核态”，跟这个的原理是一样的。</p>
<p>因而，虚拟机与硬件环境交互，实际上是虚拟态和宿主态状态的转换，如下图：</p>
<p><img src="/2023/01/10/xv6/v2-9377a260d034d2904b1807d3fe53dcd9_1440w.jpg" alt="v2-9377a260d034d2904b1807d3fe53dcd9_1440w"></p>
<p><strong>VM Exit</strong></p>
<p>当虚拟机中的代码是敏感指令或者说满足了一定的退出条件时，CPU会从虚拟态退出到KVM，这叫作VM Exit。</p>
<p>这就像在用户态执行指令陷入内核一样。</p>
<p>VM Exit首先陷入到KVM中进行处理，如果KVM无法处理，比如说虚拟机写了设备的寄存器地址，那么KVM会将这个写操作分派到QEMU中进行处理。</p>
<p><strong>VM Entry</strong></p>
<p>当KVM或者QEMU处好了退出事件之后，又可以将CPU置于虚拟态以运行虚拟机代码，这叫作VM Entry。</p>
<h6 id="内存管理虚拟化"><a href="#内存管理虚拟化" class="headerlink" title="内存管理虚拟化"></a>内存管理虚拟化</h6><blockquote>
<p>QEMU在初始化的时候会通过<code>mmap</code>分配虚拟内存空间作为虚拟机的物理内存，【感觉思路打开，物理内存与文件对应了起来】QEMU在不断更新内存布局的过程中会持续调用KVM接口通知内核KVM模块虚拟机的内存分布。</p>
</blockquote>
<p>虚拟机在运行过程中，首先需要将虚拟机的虚拟地址（Guest Virtual Address，GVA）转换成虚拟机的物理地址（Guest Physical Address，GPA），然后将虚拟机的物理地址转换成宿主机的虚拟地址（Host Virtual Address，HVA），最终转换成宿主机的物理地址（Host Physical Address，HPA）。</p>
<p>整个寻址过程由硬件实现，具体实现方式为扩展页表（Extended Page Table，EPT）。</p>
<p>在支持EPT的环境中，虚拟机在<strong>第一次访问内存的时候就会陷入到KVM</strong>，KVM会<strong>逐渐建立</strong>起所谓的EPT页面【lazy思想贯穿始终，还是该叫自适应？】。这样虚拟机的虚拟CPU在后面访问虚拟机虚拟内存地址的时候，首先会被转换为虚拟机物理地址，接着会查找EPT页表，然后得到宿主机物理地址。【有种TLB的感觉】</p>
<p><img src="/2023/01/10/xv6/v2-942e1ed598eed3d401d00e4719224d27_1440w.jpg" alt="v2-942e1ed598eed3d401d00e4719224d27_1440w"></p>
<h6 id="外设管理虚拟化"><a href="#外设管理虚拟化" class="headerlink" title="外设管理虚拟化"></a>外设管理虚拟化</h6><p>设备模拟的本质是要为虚拟机提供一个<strong>与物理设备接口完全一致的虚拟接口</strong>。</p>
<p>虚拟机中的操作系统与设备进行的数据交互或者由QEMU和（或）KVM完成，或者由宿主机上对应的后端设备完成。</p>
<p>QEMU在初始化过程中会创建好模拟芯片组和必要的模拟设备，包括南北桥芯片、PCI根总线、ISA根总线等总线系统，以及各种PCI设备、ISA设备等。</p>
<p>外设虚拟化主要有如下几种方式：</p>
<ol>
<li><p>纯软件模拟（完全虚拟化）</p>
<p>QEMU最早的方案，虚拟机内核不用做任何修改，每一次对设备的寄存器读写都会陷入到KVM，进而到QEMU，QEMU再对这些请求进行处理并模拟硬件行为。</p>
<p>软件模拟会导致非常多的QEMU/KVM接入，效率低下。</p>
</li>
<li><p>virtio设备（半虚拟化）</p>
<p>virtio设备是一类特殊的设备，并没有对应的物理设备，所以需要虚拟机内部操作系统安装特殊的virtio驱动。</p>
<p>相比软件模拟，virtio方案提高了虚拟设备的性能。</p>
</li>
<li><p>设备直通</p>
<p>将物理硬件设备直接挂到虚拟机上，虚拟机直接与物理设备交互，尽可能在I/O路径上减少QEMU/KVM的参与。</p>
<p>设备直通经常搭配硬件虚拟化支持技术SRIOV（Single Root I/O Virtualization，单根输入/输出虚拟化）使用，SRIOV能够将单个的物理硬件高效地虚拟出多个虚拟硬件。</p>
</li>
</ol>
<p><img src="/2023/01/10/xv6/v2-555d017ce5b65457f98617a5fdf232af_1440w.jpg" alt="v2-555d017ce5b65457f98617a5fdf232af_1440w"></p>
<h6 id="中断处理虚拟化"><a href="#中断处理虚拟化" class="headerlink" title="中断处理虚拟化"></a>中断处理虚拟化</h6><p>操作系统通过写设备的I/O端口或者MMIO地址来与设备交互，设备通过发送中断来通知操作系统事件。</p>
<p>QEMU/KVM一方面需要完成这项<strong>中断设备的模拟</strong>，另一方面需要模拟<strong>中断的请求处理</strong>。</p>
<blockquote>
<p>QEMU支持单CPU的Intel 8259中断控制器以及SMP的I/O APIC（I/O Advanced Programmable Interrupt Controller）和LAPIC（Local Advanced Programmable Interrupt Controller）中断控制器。在这种方式下，虚拟外设通过QEMU向虚拟机注入中断，需要先陷入到KVM，然后由KVM向虚拟机注入中断，这是一个非常费时的操作。</p>
<p>为了提高虚拟机的效率，KVM自己也实现了中断控制器Intel 8259、I/O APIC以及LAPIC。用户可以有选择地让QEMU或者KVM模拟全部中断控制器，也可以让QEMU模拟Intel 8259中断控制器和I/O APIC，让KVM模拟LAPIC。</p>
</blockquote>
<h4 id="xv6的全启动运行过程梳理"><a href="#xv6的全启动运行过程梳理" class="headerlink" title="xv6的全启动运行过程梳理"></a>xv6的全启动运行过程梳理</h4><p>介绍完上述的qemu虚拟化，接下来就可以对xv6的全启动进行一个梳理了。</p>
<p>首先，在宿主机执行<code>make qemu</code>。</p>
<p>在<code>Makefile</code>中可以看到：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">qemu: $K/kernel fs.img</span></span><br><span class="line">        <span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span></span><br><span class="line">QEMU = qemu-system-riscv64</span><br></pre></td></tr></table></figure>

<p>在log中可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">mkfs/mkfs fs.img README user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie user/_mmaptest</span><br><span class="line">...</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>具体的<code>Makefile</code>相关内容我不大了解，但结合输出，我想大概是先通过<code>riscv64-linux-gnu-gcc</code>编译链接完所有文件，然后再执行<code>mkfs</code>产生<code>fs.img</code>镜像（<code>mkfs</code>后面那些东西应该是文件参数，对应于源码中的读取可执行程序进磁盘的部分），最后再运行<code>qemu-system-riscv64</code>开始对虚拟机进行boot。</p>
<p>boot直至启动后的所有代码，都是通过QEMU-KVM架构处理，直接运行在宿主机的CPU上的。其余的各种管理，可以详见小标题<code>虚拟机在QEMU-KVM架构的执行方法</code>。</p>
<h4 id="mkfs的作用及源码解读"><a href="#mkfs的作用及源码解读" class="headerlink" title="mkfs的作用及源码解读"></a>mkfs的作用及源码解读</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>上面的知识表明，<strong>操作系统的启动在于文件系统初始化之后</strong>，这是因为操作系统本身的启动代码，放在磁盘映像<code>fs.img</code>中，而<code>fs.img</code>正是由文件系统初始化时弄出来的。也就是说，<strong>文件系统是操作系统的爸爸</strong>。【我以前一直以为是反过来的】</p>
<p><img src="/2023/01/10/xv6/image-20230121162324747.png" alt="image-20230121162324747"></p>
<blockquote>
<p>图中的boot块就是操作系统的引导扇区。</p>
</blockquote>
<p>而<code>mkfs</code>的作用，正是把宿主机提供的<strong>虚拟地址空间作为虚拟磁盘</strong>，把虚拟地址空间划分为如上图所示的地址结构。<strong>它是运行在宿主机当中的</strong>。有了<code>mkfs</code>，才能有我们的虚拟机。</p>
<h5 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h5><p><a href="https://blog.csdn.net/Mumu3w/article/details/54173069">xv6分析–mkfs源代码注释</a></p>
<p>yysy这个就写得很好了。</p>
<h2 id="user-mem-allocator"><a href="#user-mem-allocator" class="headerlink" title="user mem-allocator"></a>user mem-allocator</h2><blockquote>
<p>linux的堆管理</p>
<p>那么malloc到底是怎么实现的呢？不是每次要申请内存就调一下系统调用，而是程序向操作系统申请⼀块适当⼤⼩的堆空间，然后由程序⾃⼰管理这块空间，⽽具体来讲，管理着堆空间分配的往往是程序的<strong>运⾏库</strong>。</p>
<p>也就是说，malloc本质上是以运行库而非系统调用形式出现的。它里面用到的是<strong>sbrk和mmap</strong>这两个系统调用来进货。</p>
<p>glibc的malloc函数是这样处理⽤户的空间请求的：对于⼩于128KB的请求来说，它会在现有的堆空间⾥⾯，按照堆分配算法为它分配⼀块空间并返回；对于⼤于128KB的请求来说，它会使⽤mmap()函数为它分配⼀块匿名空间，然后在这个匿名空间中为⽤户分配空间。</p>
</blockquote>
<p>在内核态中，我们使用<code>kalloc</code>和<code>kfree</code>来申请和释放内存页。在用户态中，我们使用<code>malloc</code>和<code>free</code>来对动态内存进行管理。【也就是说这个实现的是<strong>堆管理</strong>】</p>
<p>内核中的最小单位只能是页，但user mem-allocator对外提供的申请内存服务的<strong>最小单位不是页</strong>，而是<code>sizeof(Header)</code>。因而，这就需要我们的user mem-allocator进行数据结构的管理，来统一这二者的实现。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><p>user mem-allocator的数据结构是<strong>环形链表</strong>，起始结点为一个空数据载体。</p>
<p><img src="/2023/01/10/xv6/image-20230316140158908.png" alt="image-20230316140158908"></p>
<p><img src="/2023/01/10/xv6/image-20230316140450988.png" alt="image-20230316140450988"></p>
<h4 id="地址从低到高"><a href="#地址从低到高" class="headerlink" title="地址从低到高"></a>地址从低到高</h4><p>链表的头结点的存储地址/所代表的内存地址的地址数值最小，并且其余结点按遍历顺序地址递增。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>user mem-allocator由三个主要函数组成，分别是<code>morecore</code>、<code>malloc</code>和<code>free</code>。一个一个地来说未免有点不符合正常人的思路，所以我接下来会以用户初次调用<code>malloc</code>为例，来整理user mem-allocator的具体实现。</p>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>当用户初次调用<code>malloc</code>，此时freep仍为空指针，因而会进入如下分支：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((prevp = freep) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// 空闲mem为空的情况</span></span><br><span class="line">  base.s.ptr = freep = prevp = &amp;base;</span><br><span class="line">  base.s.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即初始化为这种情况：</p>
<p><img src="/2023/01/10/xv6/image-20230316143711888.png" alt="image-20230316143711888"></p>
<p>随后，由于<code>prevp-&gt;ptr == freep</code>，故而会在循环中进入该分支：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(p == freep) <span class="comment">// 一般情况下，此处表明已经完整遍历了一遍环形链表，因为prev的初值是freep，而我们是从prev-&gt;next开始遍历的</span></span><br><span class="line">    <span class="keyword">if</span>((p = morecore(nunits)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>morecore</code>。</p>
<h4 id="morecore"><a href="#morecore" class="headerlink" title="morecore"></a>morecore</h4><p>进入<code>morecore</code>后，首先会对堆内存进行扩容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nu &lt; <span class="number">4096</span>)</span><br><span class="line">  nu = <span class="number">4096</span>;</span><br><span class="line">p = sbrk(nu * <span class="keyword">sizeof</span>(Header));</span><br><span class="line"><span class="keyword">if</span>(p == (<span class="type">char</span>*)<span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>其中，nu表示要申请的内存单元数，一个内存单元为<code>sizeof(Header)</code>，因而nu在<code>malloc</code>中计算如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nunits = (nbytes + <span class="keyword">sizeof</span>(Header) - <span class="number">1</span>)/<span class="keyword">sizeof</span>(Header) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>为了满足内核以一页为最小内存单位的需求，以及避免过多陷入内核态，它每次会申请至少4096*内存单元的堆空间。</p>
<p>对堆内存进行扩容完之后，<code>morecore</code>会手动调用一次<code>free</code>，将新申请到的内存加入数据结构中。【此处类似于在<code>knit</code>中调用<code>kfree</code>的原理】</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ap)</span>&#123;</span><br><span class="line">  Header *bp, *p;</span><br><span class="line"></span><br><span class="line">  bp = (Header*)ap - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)</span><br><span class="line">    <span class="keyword">if</span>(p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr))</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>由于此时<code>freep == freep-&gt;str == base</code>，并且我们在<code>morecore</code>中新申请的内存空间<code>ap</code>满足<code>ap &gt; base</code>，故而会跳出循环。</p>
<blockquote>
<p>为什么<code>ap &gt; base</code>呢？</p>
<p>别忘了我们扩容的原理。我们是以<code>proc-&gt;size</code>为起始地址扩容的。ap处在扩容内存中，因而ap&gt;旧size；base处在扩容前内存内，因而base&lt;=旧size。故而有ap&gt;base。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(bp + bp-&gt;s.size == p-&gt;s.ptr)&#123;</span><br><span class="line">  bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;</span><br><span class="line">  bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  bp-&gt;s.ptr = p-&gt;s.ptr;</span><br><span class="line"><span class="keyword">if</span>(p + p-&gt;s.size == bp)&#123;</span><br><span class="line">  p-&gt;s.size += bp-&gt;s.size;</span><br><span class="line">  p-&gt;s.ptr = bp-&gt;s.ptr;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  p-&gt;s.ptr = bp;</span><br><span class="line">freep = p;</span><br></pre></td></tr></table></figure>

<p>跳出循环后，我们会进入第一个if的第二个分支，以及第二个if的第二个分支。经过这些指针操作后，此时我们的数据结构如下图所示：</p>
<p><img src="/2023/01/10/xv6/image-20230316145733160.png" alt="image-20230316145733160"></p>
<p>也即形成了一个两节点的环形链表。</p>
<h4 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h4><p>经历完上述调用后，我们回到<code>malloc</code>的循环中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span>(p == freep)</span><br><span class="line">    <span class="keyword">if</span>((p = morecore(nunits)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由<code>morecore</code>的返回值可知，此时我们的p应该指向freep。本轮循环结束后执行<code> p = p-&gt;s.ptr</code>，此时我们的p指向了我们刚在<code>morecore</code>中扩容出来的那一大段内存。</p>
<p><img src="/2023/01/10/xv6/image-20230316150327569.png" alt="image-20230316150327569"></p>
<p>在下一轮循环中，由于我们刚刚通过<code>morecore</code>申请了至少<code>nunits</code>的空间，因而我们将进入该分支：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;s.size &gt;= nunits)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;s.size == nunits)</span><br><span class="line">    <span class="comment">// 如果与所需的内存刚好相等，那就直接返回该小单元就行</span></span><br><span class="line">    prevp-&gt;s.ptr = p-&gt;s.ptr;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不等的话就只划分出一小部分</span></span><br><span class="line">    <span class="comment">// 一次划出几个header单元</span></span><br><span class="line">    p-&gt;s.size -= nunits;</span><br><span class="line">    p += p-&gt;s.size;</span><br><span class="line">    p-&gt;s.size = nunits;</span><br><span class="line">  &#125;</span><br><span class="line">  freep = prevp;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)(p + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>nunits &gt;= 4096</code>，也即<code>p-&gt;s.size == nunits</code>，p所指向的地址恰好就是我们接下来会用的地址。因而，我们就将这部分内存空间从我们的freelist中剔除，在之后返回p的地址即可。</p>
<p>当<code>nunits &lt; 4096</code>，也即<code>p-&gt;s.size != nunits</code>，说明p所指向的这块内存空间比我们需要的大，那么我们就仅将该段内存空间切割出需要的那一小部分，再把p指向那一小部分开头的地方，返回p地址即可，如图所示。</p>
<p><img src="/2023/01/10/xv6/image-20230316150846709.png" alt="image-20230316150846709"></p>
<p>这样一来，我们就成功给用户它所需要的内存空间了。</p>
<h4 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h4><p>进行malloc之后，用户还需要调用free来手动释放内存，防止内存泄漏。</p>
<p><img src="/2023/01/10/xv6/image-20230316151116462.png" alt="image-20230316151116462"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)</span><br><span class="line">  <span class="keyword">if</span>(p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr))</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>由于<code>ap &gt; base</code>且<code>ap &gt; 旧p-&gt;size = base-&gt;ptr</code>且<code>base &lt; base-&gt;ptr</code>，故而首先会进行一轮循环。再然后，由于<code>p = 旧p-&gt;size</code>，并且<code>p &gt; p-&gt;ptr = base</code>，并且<code>ap &gt; 旧size</code>，故而跳出循环。</p>
<blockquote>
<p>此处循环中，循环语句内部的这个循环实际上是对遍历到环形链表尾部，即将从头开始遍历，这个边界情况的处理。比较符合逻辑的还是循环语句内的那个条件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(bp + bp-&gt;s.size == p-&gt;s.ptr)&#123;</span><br><span class="line">  bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;</span><br><span class="line">  bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  bp-&gt;s.ptr = p-&gt;s.ptr;</span><br><span class="line"><span class="keyword">if</span>(p + p-&gt;s.size == bp)&#123;</span><br><span class="line">  p-&gt;s.size += bp-&gt;s.size;</span><br><span class="line">  p-&gt;s.ptr = bp-&gt;s.ptr;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  p-&gt;s.ptr = bp;</span><br><span class="line">freep = p;</span><br></pre></td></tr></table></figure>

<p>此时会进入第二个if的第一个分支。具体情况看图就行，不多bb。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要就是这个数据结构用得很巧妙但也很复杂。它吸取了内核态中分配内存使用一个freelist的特点，同时又巧妙地利用了内存地址有序的特点，从而实现碎片内存管理。我的建议是多画图。</p>
<p>还有其实有一点我不是很理解。我觉得<code>freep</code>这个变量的用意非常不明，它似乎并不是指代整个freelist的头，因为它在很多个地方都诡异地赋值了一次。我想，它也许始终指向上一次被alloc/被free的内存的前一个吧。。。我猜测这样设计是为了蕴含一些LRU的思想。不大明白。</p>
<h2 id="m-s-u权限切换"><a href="#m-s-u权限切换" class="headerlink" title="m-s-u权限切换"></a>m-s-u权限切换</h2><p>由os知识可知，机器态、内核态、用户态分别有三种不同的操作权限。xv6是如何对权限切换进行管理的呢？</p>
<p>这部分知识我在正文的一个小地方记录了下来，详见 <a href="https://xiunianjun.github.io/2023/01/10/xv6$chap2/#:~:text=%E5%85%A8%E9%83%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E3%80%82-,%E6%84%9F%E6%83%B3,-%E6%88%91%E7%9A%84%E7%96%91%E7%82%B9%E6%9C%89%E4%B8%89">chapter2 - Code: starting xv6 and the fifirst process - xv6 - 感想</a> 的第二点。</p>
<h2 id="Lock实验的评测机制"><a href="#Lock实验的评测机制" class="headerlink" title="Lock实验的评测机制"></a>Lock实验的评测机制</h2><p>在xv6该次实验中，为了实现评测可视化，引入了statistics机制对结果进行评估。下面，我将通过源码简单介绍其实现机制。</p>
<p>来讲讲这玩意是怎么实现用户态读取锁争用次数的。我们从<code>statistics</code>函数可看出，它的本质是通过读取“文件”，来从内核中读取争用次数的相关数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">statistics</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> sz)</span> &#123;</span><br><span class="line">  fd = open(<span class="string">&quot;statistics&quot;</span>, O_RDONLY);</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> ((n = read(fd, buf+i, sz-i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么安装以前所学的内容，我们很容易联系到这玩意应该并不是个文件，而是类似于proc文件系统那样的虚拟文件。它应该会在open、read中根据其特有的文件类型进行转发。在<code>init.c</code>中，我们可以看到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    mknod(<span class="string">&quot;statistics&quot;</span>, STATS, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这玩意的文件结点实际上是在创建console时整的，并且其有一个特殊的文件类型“STATS”。我们可以进一步追溯到kernel中的<code>main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(LAB_PGTBL) || defined(LAB_LOCK)</span></span><br><span class="line">    statsinit();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">statsinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;stats.lock, <span class="string">&quot;stats&quot;</span>);</span><br><span class="line"></span><br><span class="line">  devsw[STATS].read = statsread;</span><br><span class="line">  devsw[STATS].write = statswrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它给这个<code>STATS</code>文件类型注册了这两个函数。当我们调用read和write时，实际上就是在调用这俩玩意。我们可以看下这两个handler都干了啥。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSZ 4096</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> buf[BUFSZ];</span><br><span class="line">  <span class="type">int</span> sz;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">&#125; stats;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">statsread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  acquire(&amp;stats.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(stats.sz == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_LOCK</span></span><br><span class="line">    stats.sz = statslock(stats.buf, BUFSZ); <span class="comment">// 把信息copy进自己的缓冲区里</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  m = stats.sz - stats.off;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果有新东西，就copy到用户缓冲区里</span></span><br><span class="line">    <span class="keyword">if</span>(m &gt; n)	m  = n;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, stats.buf+stats.off, m) != <span class="number">-1</span>) &#123;</span><br><span class="line">      stats.off += m;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    m = <span class="number">-1</span>;</span><br><span class="line">    stats.sz = <span class="number">0</span>;</span><br><span class="line">    stats.off = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;stats.lock);</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">statswrite</span><span class="params">(<span class="type">int</span> user_src, uint64 src, <span class="type">int</span> n)</span> &#123; <span class="comment">// WARNING: READ ONLY!!!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其本质就是把<code>statslock</code>返回的东西copy到用户空间了。我们来结合最后的输出效果看看<code>statslock</code>的具体实现：</p>
<p><img src="/2023/01/10/xv6/image-20231024232632816.png" alt="image-20231024232632816"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">statslock</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> sz)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;lock_locks);</span><br><span class="line">  n = <span class="built_in">snprintf</span>(buf, sz, <span class="string">&quot;--- lock kmem/bcache stats\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NLOCK; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(locks[i] == <span class="number">0</span>)	<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(locks[i]-&gt;name, <span class="string">&quot;bcache&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;bcache&quot;</span>)) == <span class="number">0</span> ||</span><br><span class="line">       <span class="built_in">strncmp</span>(locks[i]-&gt;name, <span class="string">&quot;kmem&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;kmem&quot;</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">      tot += locks[i]-&gt;nts; <span class="comment">// 记入-&gt;nts计数</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        snprint_lock: lock: %s: #fetch-and-add %d #acquire() %d\n</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      n += snprint_lock(buf +n, sz-n, locks[i]);</span><br><span class="line">      found += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Require at least two locks name after kmem/bcache.</span></span><br><span class="line">  <span class="keyword">if</span> (found &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    tot = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 简单粗暴地计算前五多争用的进程</span></span><br><span class="line">  n += <span class="built_in">snprintf</span>(buf+n, sz-n, <span class="string">&quot;--- top 5 contended locks:\n&quot;</span>);</span><br><span class="line">  <span class="type">int</span> last = <span class="number">100000000</span>;</span><br><span class="line">  <span class="comment">// stupid way to compute top 5 contended locks</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; <span class="number">5</span>; t++) &#123;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NLOCK; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(locks[i] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span>(locks[i]-&gt;nts &gt; locks[top]-&gt;nts &amp;&amp; locks[i]-&gt;nts &lt; last) &#123;</span><br><span class="line">        top = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      snprint_lock: lock: %s: #fetch-and-add %d #acquire() %d\n</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    n += snprint_lock(buf+n, sz-n, locks[top]);</span><br><span class="line">    last = locks[top]-&gt;nts;</span><br><span class="line">  &#125;</span><br><span class="line">  n += <span class="built_in">snprintf</span>(buf+n, sz-n, <span class="string">&quot;tot= %d\n&quot;</span>, tot);</span><br><span class="line">  release(&amp;lock_locks);  </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其争用本质计算是通过<code>spinlock::nts</code>字段记录。我们来看看这玩意的引用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_LOCK</span></span><br><span class="line">  lk-&gt;nts = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_LOCK</span></span><br><span class="line">    __sync_fetch_and_add(&amp;(lk-&gt;nts), <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   ;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很好，逻辑很简单，就是记录acquire时等待的次数，非常简单粗暴（（（</p>
<p>总的来说这个思路还是挺酷的，而且这个“一切皆文件”的思想再次震撼了我，一个小小的xv6确实能做到那么多。</p>
]]></content>
  </entry>
  <entry>
    <title>各种配环境中遇到的问题</title>
    <url>/2023/10/12/%E5%90%84%E7%A7%8D%E9%85%8D%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li><p><a href="/2023/09/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1vm%E6%89%A9%E5%AE%B9/">记录一次vm扩容</a></p>
</li>
<li><p><a href="/2023/09/18/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/#:~:text=%E7%94%A8%EF%BC%8C%E4%B8%8D%E5%A4%9A%E5%88%86%E6%9E%90%E3%80%82-,%E7%89%B9%E8%BE%91%EF%BC%9A%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%93%BE%E6%8E%A5%E5%B0%8F%E9%97%AE%E9%A2%98,-%E5%B7%B2%E7%BB%8F%E5%9C%A8LD_LIBRARY_PATH">开发中遇到的链接小问题</a></p>
</li>
<li><p><a href="/2023/10/12/rtt%E7%A1%AC%E4%BB%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">rtt硬件环境搭建</a></p>
</li>
<li><p><a href="/2023/08/12/kernel_compile/">内核编译</a></p>
</li>
<li><p>防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw status numbered <span class="comment"># 查看</span></span><br><span class="line">sudo ufw delete 数字 <span class="comment"># 删除某条记录</span></span><br><span class="line"><span class="comment"># 开放IP地址XX.XX.XX.XX的22 tcp端口</span></span><br><span class="line">sudo ufw allow from XX.XX.XX.XX to any port 22 proto tcp</span><br></pre></td></tr></table></figure></li>
<li><p>docker</p>
<p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">配置阿里云镜像</a></p>
<p><a href="https://www.jianshu.com/p/6b148fdec361">配置pull时代理（采用了方法1）</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1802363672117972863&wfr=spider&for=pc">自建Docker镜像加速服务，免费且简单，服务器VPS、NAS皆可用</a></p>
<p><a href="https://www.bilibili.com/read/cv35326945/?jump_opus=1">Docker加速解决方法</a></p>
<p><a href="https://wkdaily.cpolar.cn/archives/gc">使用Github Action 构建docker镜像</a></p>
<p>从这下下来的会打两层包，一层zip一层tar.gz，解压完这两层之后再用<code>docker load -i filename</code>即可。</p>
</li>
<li><p><a href="/2023/10/07/git/">git</a></p>
</li>
<li><p>清理postgresql的pg_wal日志：<a href="https://www.jb51.net/database/3217365sx.htm">https://www.jb51.net/database/3217365sx.htm</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/lib/postgresql/14/bin/pg_controldata /var/lib/postgresql/14/main/</span><br><span class="line">sudo pg_archivecleanup -d /var/lib/postgresql/14/main/pg_wal 最新日志</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>xv6</title>
    <url>/2023/01/10/xv6/</url>
    <content><![CDATA[<blockquote>
<p>总耗时：120h  约27天</p>
<p>部分地方的翻译和表格来源参考：<a href="http://xv6.dgs.zone/">xv6指导书翻译</a></p>
<p>部分文本来自：<a href="https://hitsz-cslab.gitee.io/os-labs/">操作系统实验指导书 - 2023秋季 | 哈工大（深圳）</a></p>
<p>实验官网：<a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">6.S081</a></p>
<p>代码以<a href="https://github.com/xiunianjun/oslab">github</a>为准，此处记录的有些小瑕疵</p>
<p>笔记的结构【以第一章Operating system interface为例】：</p>
<p><img src="/2023/01/10/xv6/image-20230124235649128.png" alt="image-20230124235649128"></p>
</blockquote>
<h3 id="Operating-system-interface"><a href="#Operating-system-interface" class="headerlink" title="Operating system interface"></a><a href="/2023/01/10/xv6$chap1">Operating system interface</a></h3><h3 id="Operating-system-oganization"><a href="#Operating-system-oganization" class="headerlink" title="Operating system oganization"></a><a href="/2023/01/10/xv6$chap2">Operating system oganization</a></h3><h3 id="Page-tables"><a href="#Page-tables" class="headerlink" title="Page tables"></a><a href="/2023/01/10/xv6$chap3">Page tables</a></h3><h3 id="Traps-and-system-calls"><a href="#Traps-and-system-calls" class="headerlink" title="Traps and system calls"></a><a href="/2023/01/10/xv6$chap4">Traps and system calls</a></h3><h3 id="Interrupts-and-device-drivers"><a href="#Interrupts-and-device-drivers" class="headerlink" title="Interrupts and device drivers"></a><a href="/2023/01/10/xv6$chap5">Interrupts and device drivers</a></h3><h3 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a><a href="/2023/01/10/xv6$chap6">Locking</a></h3><h3 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a><a href="/2023/01/10/xv6$chap7">Scheduling</a></h3><h3 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a><a href="/2023/01/10/xv6$chap8">File system</a></h3><h3 id="其他的对实验未涉及的思考"><a href="#其他的对实验未涉及的思考" class="headerlink" title="其他的对实验未涉及的思考"></a><a href="/2023/01/10/xv6$chap9">其他的对实验未涉及的思考</a></h3>]]></content>
      <tags>
        <tag>labs</tag>
      </tags>
  </entry>
  <entry>
    <title>哈工大操作系统实验</title>
    <url>/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.lanqiao.cn/courses/115">实验入口</a><br>主要参考文章<br><a href="https://www.dotcpp.com/course/461">lseek()函数:用于移动打开文件的指针</a><br><a href="https://cloud.tencent.com/developer/article/1425052">linux系统调用之write源码解析（基于linux0.11）</a><br><a href="https://blog.csdn.net/yuanren201/article/details/103207910">get_fs_bytes解析</a><br><a href="https://blog.csdn.net/to_free/article/details/115187981">VIM与系统剪贴板的复制粘贴</a><br><a href="https://zhuanlan.zhihu.com/p/428283092">操作系统实验六 信号量的实现和应用(哈工大李治军)</a><br><a href="https://blog.csdn.net/weixin_43987915/article/details/108949942">哈工大操作系统实验6 信号量的实现 pc.c 编译时报错 对‘sem_open‘未定义的引用</a><br><a href="https://blog.csdn.net/qq_59804059/article/details/120634348">Linux 文件编程 open函数</a><br><a href="https://blog.csdn.net/qq_42518941/article/details/119757885">哈工大-操作系统-HitOSlab-李治军-实验5-信号量的实现和应用</a></p>
</blockquote>
<h1 id="地址映射与共享"><a href="#地址映射与共享" class="headerlink" title="地址映射与共享"></a>地址映射与共享</h1><blockquote>
<p>参考文章</p>
<p><a href="https://www.cnblogs.com/52php/p/5861372.html">Linux进程间通信（六）：共享内存 shmget()、shmat()、shmdt()、shmctl() </a></p>
<p><a href="https://blog.csdn.net/leoabcd12/article/details/121581308">操作系统实验七 地址映射与共享(哈工大李治军)</a></p>
</blockquote>
<h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><h3 id="要点1-共享内存"><a href="#要点1-共享内存" class="headerlink" title="要点1 共享内存"></a>要点1 共享内存</h3><p>顾名思义，共享内存就是<u>允许两个不相关的进程访问同一个逻辑内存</u>。共享内存是在两个正在运行的进程之间<u>共享和传递数据</u>的一种非常有效的方式。不同进程之间共享的内存通常安排为<u>同一段物理内存</u>。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p>
<p>注：共享内存并未提供同步机制，所以我们需要用信号量来实现同步。</p>
<p>Linux提供了一组接口用于使用共享内存，它们声明在头文件 sys/shm.h 中。</p>
<h4 id="1-shmget"><a href="#1-shmget" class="headerlink" title="1.shmget"></a>1.shmget</h4><p>程序先通过调用shmget()函数并提供一个键，再由系统生成一个相应的共享内存标识符（shmget()函数的返回值）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p>key为共享内存段名字，size为大小，shmflg是权限标志</p>
<p>注：</p>
<p>① key：<u><strong>非0整数</strong></u>，共享内存段的命名</p>
<p>② shmflag：作用与open函数的mode参数一样，比如IPC_CREAT，或连接</p>
<p>共享内存的权限标志与文件的读写权限一样，举例来说，0644表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存</p>
<p>③ return：成功时返回一个与key相关的<u>共享内存标识符</u>（非负整数）。调用失败返回-1</p>
<p>不相关的进程可以<u>返回值（共享内存标识符）访问同一共享内存</u>。</p>
<h4 id="2-shmat"><a href="#2-shmat" class="headerlink" title="2.shmat"></a>2.shmat</h4><p>第一次创建完共享内存时，它还不能被任何进程访问，需要shmat启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span> *shm_addr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p>① shm_id：共享内存标识符</p>
<p>② shm_addr：指定共享内存连接到当前进程中的地址位置，通常为空，表示<u>让系统来选择</u>共享内存的地址</p>
<p>③ shm_flg：一组标志位，通常为0</p>
<p>④ return：成功时返回一个<u><strong>指向共享内存第一个字节</strong></u>的指针，失败返回-1</p>
<h4 id="3-shmdt"><a href="#3-shmdt" class="headerlink" title="3.shmdt"></a>3.shmdt</h4><p>用于将共享内存从当前进程中分离，使该共享内存对当前进程不再可用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure>

<p>① shmaddr：shmat返回的共享内存指针</p>
<p>② return：成功0，失败1</p>
<h4 id="4-shmctl"><a href="#4-shmctl" class="headerlink" title="4.shmctl"></a>4.shmctl</h4><p>用来控制共享内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>① shm_id：共享内存标识符</p>
<p>② command：要采取的操作，它可以取下面的三个值 ：</p>
<ul>
<li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。</li>
<li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值</li>
<li>IPC_RMID：删除共享内存段</li>
</ul>
<p>③ buf：结构指针</p>
<p>shmid_ds结构 至少包括以下成员：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uid_t</span> shm_perm.uid;</span><br><span class="line">    <span class="type">uid_t</span> shm_perm.gid;</span><br><span class="line">    <span class="type">mode_t</span> shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="实验1-在Ubuntu下编写程序“基于共享内存的生产者消费者模型”"><a href="#实验1-在Ubuntu下编写程序“基于共享内存的生产者消费者模型”" class="headerlink" title="实验1 在Ubuntu下编写程序“基于共享内存的生产者消费者模型”"></a>实验1 在Ubuntu下编写程序“基于共享内存的生产者消费者模型”</h2><blockquote>
<p>本项实验在 Ubuntu 下完成，与信号量实验中的 <code>pc.c</code> 的功能要求基本一致，仅有两点不同：</p>
<ul>
<li>不用文件做缓冲区，而是使用共享内存；</li>
<li>生产者和消费者分别是不同的程序。生产者是 producer.c，消费者是 consumer.c。两个程序都是单进程的，通过信号量和缓冲区进行通信。</li>
</ul>
<p>Linux 下，可以通过 <code>shmget()</code> 和 <code>shmat()</code> 两个系统调用使用共享内存。</p>
</blockquote>
<p>直接上代码。感觉比文件操作简单多了2333</p>
<p>consumer.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span>* empty;</span><br><span class="line"><span class="type">sem_t</span>* full;</span><br><span class="line"><span class="type">sem_t</span>* mutex;</span><br><span class="line"><span class="type">char</span>* p;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Consumer</span><span class="params">()</span>&#123;</span><br><span class="line">	sem_wait(full);</span><br><span class="line">	sem_wait(mutex);</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="comment">//there read s from buffer...</span></span><br><span class="line">	<span class="built_in">memcpy</span>(s,p,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">4</span>);</span><br><span class="line">	p+=<span class="number">4</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d : %s&quot;</span>,getpid(),s);</span><br><span class="line">	sem_post(mutex);</span><br><span class="line">	sem_post(empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	empty=sem_open(<span class="string">&quot;empty&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">10</span>);</span><br><span class="line">	full=sem_open(<span class="string">&quot;full&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">0</span>);</span><br><span class="line">	mutex=sem_open(<span class="string">&quot;mutex&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> shm_id=shmget(<span class="number">521</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">4</span>*<span class="number">600</span>,<span class="number">0644</span>|IPC_CREAT);</span><br><span class="line">	<span class="type">char</span>* shm=(<span class="type">char</span>*)shmat(shm_id,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	p=shm;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">500</span>;</span><br><span class="line">	<span class="keyword">while</span>(cnt--)&#123;</span><br><span class="line">		Consumer();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shmdt(shm);</span><br><span class="line">	shmctl(shm_id,IPC_RMID,<span class="number">0</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;mutex&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;full&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;empty&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>producer.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span>* empty;</span><br><span class="line"><span class="type">sem_t</span>* full;</span><br><span class="line"><span class="type">sem_t</span>* mutex;</span><br><span class="line"><span class="type">char</span>* p;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Producer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">500</span>;i++)&#123;</span><br><span class="line">		sem_wait(empty);</span><br><span class="line">		sem_wait(mutex);</span><br><span class="line">		<span class="built_in">sprintf</span>(s,<span class="string">&quot;%03d\n&quot;</span>,i);</span><br><span class="line">		<span class="comment">//there write s into buffer...</span></span><br><span class="line">		<span class="built_in">memcpy</span>(p,s,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">4</span>);</span><br><span class="line">		p+=<span class="number">4</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Write into success!%s\n&quot;</span>,s);</span><br><span class="line">		sem_post(mutex);</span><br><span class="line">		sem_post(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	empty=sem_open(<span class="string">&quot;empty&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">10</span>);</span><br><span class="line">	full=sem_open(<span class="string">&quot;full&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">0</span>);</span><br><span class="line">	mutex=sem_open(<span class="string">&quot;mutex&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> shm_id=shmget(<span class="number">521</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">4</span>*<span class="number">600</span>,<span class="number">0644</span>|IPC_CREAT);</span><br><span class="line">	<span class="type">char</span>* shm=(<span class="type">char</span>*)shmat(shm_id,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	p=shm;</span><br><span class="line"></span><br><span class="line">	Producer();</span><br><span class="line"></span><br><span class="line">	shmdt(shm);</span><br><span class="line">	shmctl(shm_id,IPC_RMID,<span class="number">0</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;mutex&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;full&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;empty&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -o producer producer.c -pthread</span><br><span class="line">gcc -o consumer consumer.c -pthread</span><br><span class="line">./producer &gt; p.txt &amp;</span><br><span class="line">./consumer &gt; c.txt</span><br></pre></td></tr></table></figure>

<p>运行结果c.txt（仅展示部分）</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">27696 </span>: <span class="number">000</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">001</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">002</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">003</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">004</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">005</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">006</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">007</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">008</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">009</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">010</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">011</span></span><br><span class="line"><span class="symbol">27696 </span>: <span class="number">012</span></span><br></pre></td></tr></table></figure>



<h2 id="实验2-在Linux0-11实现共享内存"><a href="#实验2-在Linux0-11实现共享内存" class="headerlink" title="实验2 在Linux0.11实现共享内存"></a>实验2 在Linux0.11实现共享内存</h2><blockquote>
<p>进程之间可以通过页共享进行通信，被共享的页叫做共享内存，结构如下图所示：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/userid19614labid573time1424086247964.png" class> 

<p>本部分实验内容是在 Linux 0.11 上实现上述页面共享，并将上一部分实现的 producer.c 和 consumer.c 移植过来，验证页面共享的有效性。</p>
</blockquote>
<blockquote>
<p>具体要求在 <code>mm/shm.c</code> 中实现 <code>shmget()</code> 和 <code>shmat()</code> 两个系统调用。它们能支持 <code>producer.c</code> 和 <code>consumer.c</code> 的运行即可，不需要完整地实现 POSIX 所规定的功能。</p>
<ul>
<li>shmget()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p><code>shmget()</code> 会新建/打开一页内存，并返回该页共享内存的 shmid（该块共享内存在操作系统内部的 id）。</p>
<p>所有使用同一块共享内存的进程都要使用相同的 key 参数。</p>
<p>如果 key 所对应的共享内存已经建立，则直接返回 <code>shmid</code>。如果 size 超过一页内存的大小，返回 <code>-1</code>，并置 <code>errno</code> 为 <code>EINVAL</code>。如果系统无空闲内存，返回 -1，并置 <code>errno</code> 为 <code>ENOMEM</code>。</p>
<p><code>shmflg</code> 参数可忽略。</p>
<ul>
<li>shmat()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p><code>shmat()</code> 会将 <code>shmid</code> 指定的共享页面映射到当前进程的虚拟地址空间中，并将其首地址返回。</p>
<p>如果 <code>shmid</code> 非法，返回 <code>-1</code>，并置 <code>errno</code> 为 <code>EINVAL</code>。</p>
<p><code>shmaddr</code> 和 <code>shmflg</code> 参数可忽略。</p>
</blockquote>
<p>思路：</p>
<p>1.shmget：由其论述，我们可以知道，我们需要建立一个映射表，其中成员为结构体({key_t key,size_t size,unsigned long page})，每次只需查找映射表，如果有对应key则返回下标，如果没有则新建页表，填入映射体，再返回对应下标。</p>
<p>以下为了图省事，对映射表的实现进行了简化，把key直接当做int类型，作为映射表下标，映射表成员为page，unsigned long。</p>
<p>2.shmat：</p>
<p>首先由指导书的提示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立线性地址和物理地址的映射</span></span><br><span class="line">put_page(tmp, address);</span><br></pre></td></tr></table></figure>

<p>我们知道在shmat中，要建立shmget得到的共享物理页面与其虚拟地址的映射，就需要使用这个put_page函数。</p>
<p>但是put_page函数的参数为页和address。页就是我们的shm_map[key]，address=虚拟地址+段基址。那么如何得到虚拟地址呢？</p>
<p>通过指导书的提示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">code_base = get_base(current-&gt;ldt[<span class="number">1</span>]);</span><br><span class="line">data_base = code_base;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据段基址 = 代码段基址</span></span><br><span class="line">set_base(current-&gt;ldt[<span class="number">1</span>],code_base);</span><br><span class="line">set_limit(current-&gt;ldt[<span class="number">1</span>],code_limit);</span><br><span class="line">set_base(current-&gt;ldt[<span class="number">2</span>],data_base);</span><br><span class="line">set_limit(current-&gt;ldt[<span class="number">2</span>],data_limit);</span><br><span class="line">__asm__(<span class="string">&quot;pushl $0x17\n\tpop %%fs&quot;</span>:: );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数据段的末尾开始</span></span><br><span class="line">data_base += data_limit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向前处理</span></span><br><span class="line"><span class="keyword">for</span> (i=MAX_ARG_PAGES<span class="number">-1</span> ; i&gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">    <span class="comment">// 一次处理一页</span></span><br><span class="line">    data_base -= PAGE_SIZE;</span><br><span class="line">    <span class="comment">// 建立线性地址到物理页的映射</span></span><br><span class="line">    <span class="keyword">if</span> (page[i]) put_page(page[i],data_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再结合所学知识，我们可以知道几点：</p>
<p>① 数据段的基址可由current-&gt;ldt[2]给出 ② address=虚拟地址+段基址 ③ 我们需要分配给当前共享内存一段空闲的虚拟地址段</p>
<p>则该小段空闲数据段的虚拟地址就是我们的return值，address=return+data_base。</p>
<p>问题就转化成了如何获取一段空闲数据段。</p>
<p>我们由下图：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/d3d839723b44d3e6a9407cbbd684d976.png" class> 

<p>可知，brk指针指向堆区顶部，即空闲堆的起始位置。因而我们可以用这段空间作为我们要的空闲数据段，当前brk即为虚拟地址。</p>
<p>我们的页有PAGE_SIZE那么大，因而自然也就要用PAGE_SIZE那么大的空闲数据段了。</p>
<p>解说完毕，以下上代码~</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> shm_map[<span class="number">600</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_shmget</span><span class="params">(<span class="type">int</span> key,<span class="type">size_t</span> size,<span class="type">int</span> shmflg)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(key&lt;<span class="number">0</span>||key&gt;=<span class="number">600</span>)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(shm_map[key]!=<span class="number">0</span>)	<span class="keyword">return</span> key;</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tmp=get_free_page();</span><br><span class="line">	shm_map[key]=tmp;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">sys_shmat</span><span class="params">(<span class="type">int</span> shmid,<span class="type">const</span> <span class="type">void</span>* shmaddr,<span class="type">int</span> shmflg)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(shmid&lt;<span class="number">0</span>||shmid&gt;=<span class="number">600</span>)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> page=shm_map[shmid];</span><br><span class="line">	<span class="comment">//得到数据段的基址 </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data_base=get_base(current-&gt;ldt[<span class="number">2</span>]);</span><br><span class="line">	<span class="comment">//brk指针指向空闲数据段的开始 </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> brk=current-&gt;brk+data_base;</span><br><span class="line">	current-&gt;brk+=PAGE_SIZE;</span><br><span class="line">	<span class="comment">//建立内存映射 </span></span><br><span class="line">	put_page(page,brk);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*)(brk-data_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><h2 id="任务一-实现pc-c"><a href="#任务一-实现pc-c" class="headerlink" title="任务一  实现pc.c"></a>任务一  实现pc.c</h2><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">在 Ubuntu 上编写应用程序“pc.c”，解决经典的生产者—消费者问题，完成下面的功能：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.建立一个生产者进程，<span class="built_in">N</span> 个消费者进程（<span class="built_in">N</span>&gt;<span class="number">1</span>）；</span><br><span class="line"><span class="number">2</span>.用文件建立一个共享缓冲区；</span><br><span class="line"><span class="number">3</span>.生产者进程依次向缓冲区写入整数 <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,...,M，M&gt;=<span class="number">500</span>；</span><br><span class="line"><span class="number">4</span>.消费者进程从缓冲区读数，每次读一个，并将读出的数字从缓冲区删除，然后将本进程 ID 和 + 数字输出到标准输出；</span><br><span class="line"><span class="number">5</span>.缓冲区同时最多只能保存 <span class="number">10</span> 个数。</span><br><span class="line">其中 ID 的顺序会有较大变化，但冒号后的数字一定是从 <span class="number">0</span> 开始递增加一的。</span><br></pre></td></tr></table></figure>

<p>先附上我的代码吧【注：我没做到从缓冲区删除，但其他都完成了】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* filename=<span class="string">&quot;buffer.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span>* empty;</span><br><span class="line"><span class="type">sem_t</span>* full;</span><br><span class="line"><span class="type">sem_t</span>* mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Producer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">500</span>;i++)&#123;</span><br><span class="line">		sem_wait(empty);</span><br><span class="line">		sem_wait(mutex);</span><br><span class="line">		<span class="type">int</span> tmp=lseek(fd,<span class="number">0</span>,SEEK_CUR);</span><br><span class="line">		lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">		<span class="built_in">sprintf</span>(s,<span class="string">&quot;%03d\n&quot;</span>,i);</span><br><span class="line">		write(fd,s,<span class="number">4</span>);</span><br><span class="line">		lseek(fd,tmp,SEEK_SET);</span><br><span class="line">		sem_post(mutex);</span><br><span class="line">		sem_post(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Consumer</span><span class="params">()</span>&#123;</span><br><span class="line">	sem_wait(full);</span><br><span class="line">	sem_wait(mutex);</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	read(fd,s,<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d : %s&quot;</span>,getpid(),s);</span><br><span class="line">	sem_post(mutex);</span><br><span class="line">	sem_post(empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	sem_unlink(<span class="string">&quot;empty&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;full&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;mutex&quot;</span>);</span><br><span class="line">	fd=open(filename,O_RDWR|O_CREAT);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,errno);	</span><br><span class="line">	empty=sem_open(<span class="string">&quot;empty&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">10</span>);</span><br><span class="line">	full=sem_open(<span class="string">&quot;full&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">0</span>);</span><br><span class="line">	mutex=sem_open(<span class="string">&quot;mutex&quot;</span>,O_CREAT,<span class="number">0644</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">		Producer();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)	Consumer();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20220928205823674.png" class> 

<h3 id="要点1-系统调用的IO读写"><a href="#要点1-系统调用的IO读写" class="headerlink" title="要点1 系统调用的IO读写"></a>要点1 系统调用的IO读写</h3><p>这部分耗费了我海量时间，主要原因还是因为我没有好好学就直接上手写导致很多地方都因为不清楚而寄了。。。</p>
<p><u>先大致讲讲文件读写的原理吧。打开一个文件作为数据流，有一个文件指针，该指针指向的地方就是之后读写开始的地方，读写还有lseek都可以让指针移动。</u></p>
<p>再放个各个系统调用的签名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@param 文件名 模式</span><br><span class="line"></span><br><span class="line">@<span class="keyword">return</span> 所需文件描述符</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> open(<span class="type">char</span>* filename,<span class="type">int</span> flag);</span><br></pre></td></tr></table></figure>

<p>其中flag的可能取值：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20220928201814131.png" class> 

<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20220928201821476.png" class> 

<p>如果想要多个方式并行，则可以用|连接。【联系一下原理，这大概是用了标志位吧，每个标志只有一位是1】</p>
<p><strong>这部分踩过的坑：</strong></p>
<p>① 选择O_CREAT，如果文件已经存在，居然是会报错？【表现为errno=13，还会输出一堆奇怪的东西】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@param 文件描述符  写入字符串  写入长度</span><br><span class="line">@<span class="keyword">return</span> 报错信息</span><br><span class="line"><span class="type">int</span> read(<span class="type">int</span> fd,<span class="type">char</span>* <span class="built_in">string</span>,<span class="type">size_t</span> size);</span><br></pre></td></tr></table></figure>

<p>read会读出size个字节然后存进string里面，同时也会移动文件指针向前size个字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@param 文件描述符  写入字符串  写入长度</span><br><span class="line">@<span class="keyword">return</span> 报错信息</span><br><span class="line"><span class="type">int</span> write(<span class="type">int</span> fd,<span class="type">char</span>* <span class="built_in">string</span>,<span class="type">size_t</span> size);</span><br></pre></td></tr></table></figure>

<p>基本同write。</p>
<p><strong>这部分踩过的坑：</strong></p>
<p>write(fd,NULL,0)  ——合法</p>
<p>write(fd,NULL,a),a&gt;0  ——寄！</p>
<p>这还是因为write的具体实现了。</p>
<p>write里面有个判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd,<span class="type">char</span> *buf,<span class="type">int</span> count)</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">if</span>(!count)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">while</span>(c--&gt;<span class="number">0</span>)	*(p++)=get_fs_byte(buf++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而get_fs_byte：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20220928204140436.png" class> 

<p>确实感觉空的话挺危险的【】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@param 文件描述符</span><br><span class="line">@<span class="keyword">return</span> 报错信息</span><br><span class="line"><span class="type">int</span> close(fd);</span><br></pre></td></tr></table></figure>

<p>这个没啥好说的，记得关就是了</p>
<h3 id="要点2-信号量的调用"><a href="#要点2-信号量的调用" class="headerlink" title="要点2  信号量的调用"></a>要点2  信号量的调用</h3><p>这方面看linux自带的man文档就行，写得很清楚。</p>
<p>输入指令：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">man sem_overview</span></span><br></pre></td></tr></table></figure>

<p><strong>这部分踩过的坑：</strong></p>
<p>千万注意最后不使用信号量时要释放，使用sem_unlink。不然最后的输出结果会非常诡异。</p>
<h3 id="要点3-编写程序"><a href="#要点3-编写程序" class="headerlink" title="要点3 编写程序"></a>要点3 编写程序</h3><p>以上差不多就是涉及到的需要自己了解的课外知识点了，接下来就需要自己编写程序。</p>
<p>总体框架就按它给的差不多：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Producer()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 空闲缓存资源</span></span><br><span class="line">    P(Empty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥信号量</span></span><br><span class="line">    P(Mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产并放一个item进缓冲区</span></span><br><span class="line">    </span><br><span class="line">    V(Mutex);</span><br><span class="line">    V(Full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer()</span><br><span class="line">&#123;</span><br><span class="line">    P(Full);</span><br><span class="line">    P(Mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从缓存区取出一个赋值给item并消费;</span></span><br><span class="line">    </span><br><span class="line">    V(Mutex);</span><br><span class="line">    V(Empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个点挺有趣的，就是它实际上把文件指针也看成一种资源了，因此也需要在同步段对其进行更新。</p>
<p>printf的stdout也是资源。</p>
<p>故以上两者都只能在锁内同步段进行更新。</p>
<p>main函数就照本宣科地用fork建立子进程就行。</p>
<h2 id="任务二-自己实现信号量"><a href="#任务二-自己实现信号量" class="headerlink" title="任务二 自己实现信号量"></a>任务二 自己实现信号量</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Linux 在 <span class="number">0.11</span> 版还没有实现信号量，Linus 把这件富有挑战的工作留给了你。如果能实现一套山寨版的完全符合 POSIX 规范的信号量，无疑是很有成就感的。但时间暂时不允许我们这么做，所以先弄一套缩水版的类 POSIX 信号量，它的函数原型和标准并不完全相同，而且只包含如下系统调用：</span><br><span class="line">sem_t *sem<span class="constructor">_open(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">name</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">value</span>)</span>;</span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_wait(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_post(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">sem</span>)</span>;</span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_unlink(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">name</span>)</span>;</span><br><span class="line"></span><br><span class="line">sem<span class="constructor">_open()</span> 的功能是创建一个信号量，或打开一个已经存在的信号量。</span><br><span class="line">sem_t 是信号量类型，根据实现的需要自定义。</span><br><span class="line">name 是信号量的名字。不同的进程可以通过提供同样的 name 而共享同一个信号量。如果该信号量不存在，就创建新的名为 name 的信号量；如果存在，就打开已经存在的名为 name 的信号量。</span><br><span class="line">value 是信号量的初值，仅当新建信号量时，此参数才有效，其余情况下它被忽略。当成功时，返回值是该信号量的唯一标识（比如，在内核的地址、ID 等），由另两个系统调用使用。如失败，返回值是 NULL。</span><br><span class="line">sem<span class="constructor">_wait()</span> 就是信号量的 P 原子操作。如果继续运行的条件不满足，则令调用进程等待在信号量 sem 上。返回 <span class="number">0</span> 表示成功，返回 -<span class="number">1</span> 表示失败。</span><br><span class="line">sem<span class="constructor">_post()</span> 就是信号量的 V 原子操作。如果有等待 sem 的进程，它会唤醒其中的一个。返回 <span class="number">0</span> 表示成功，返回 -<span class="number">1</span> 表示失败。</span><br><span class="line">sem<span class="constructor">_unlink()</span> 的功能是删除名为 name 的信号量。返回 <span class="number">0</span> 表示成功，返回 -<span class="number">1</span> 表示失败。</span><br><span class="line">在 kernel 目录下新建 sem.c 文件实现如上功能。然后将 pc.c 从 Ubuntu 移植到 <span class="number">0.11</span> 下，测试自己实现的信号量。</span><br></pre></td></tr></table></figure>

<p>由于不小心写完的实验代码被销毁了，因此差不多参考的是这篇文章【<a href="https://blog.csdn.net/qq_42518941/article/details/119757885">戳这里</a>】，修改了一些地方，构成了我的回忆版代码。</p>
<h3 id="要点1-系统调用修改"><a href="#要点1-系统调用修改" class="headerlink" title="要点1 系统调用修改"></a>要点1 系统调用修改</h3><p>详见文章，写得很清楚。</p>
<h3 id="要点2-sem-c文件的编写"><a href="#要点2-sem-c文件的编写" class="headerlink" title="要点2  sem.c文件的编写"></a>要点2  sem.c文件的编写</h3><p>sem_t定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义的信号量数据结构: */</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> _SEM_H_</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _SEM_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">semaphore_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];<span class="comment">/* 信号量的名称 */</span></span><br><span class="line">	<span class="type">int</span> value;    <span class="comment">/* 信号量的值 */</span></span><br><span class="line">    <span class="type">int</span> active;<span class="comment">//我自己加的，是对象池思想，感觉写得还挺好的2333</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tast_struct</span> *<span class="title">queue</span>;</span><span class="comment">/* 指向阻塞队列的指针 */</span></span><br><span class="line">&#125; <span class="type">sem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sem.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/segment.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_LIST_LENGTH 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量表</span></span><br><span class="line"><span class="type">sem_t</span> sem_list[SEM_LIST_LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">str_cmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1,<span class="type">const</span> <span class="type">char</span>* s2)</span>&#123;</span><br><span class="line">	<span class="type">char</span>* p=s1;</span><br><span class="line">	<span class="type">int</span> i,len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(*p!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">		p++;</span><br><span class="line">		len1++;</span><br><span class="line">	&#125;</span><br><span class="line">	p=s2;</span><br><span class="line">	<span class="keyword">while</span>(*p!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">		p++;</span><br><span class="line">		len2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(len1!=len2)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s1[i]!=s2[i])	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sem_open</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sem_open()的功能是创建一个信号量，或打开一个已经存在的信号量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> *<span class="title function_">sys_sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name,<span class="type">unsigned</span> <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (name == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 首先将信号量的名称赋值到新建的缓冲区中 */</span></span><br><span class="line">    <span class="type">char</span> nbuf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	nbuf[i] = get_fs_byte(name+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 然后开始遍历已有的信号量数组，如果有该名字的信号量，直接返回信号量的地址 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SEM_LIST_LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sem_list[i].active==<span class="number">1</span>&amp;&amp;!str_cmp(sem_list[i].name, nbuf))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;sem_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果找不到信号量，就开始新建一个名字为name的信号量 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SEM_LIST_LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sem_list[i].active==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(sem_list[i].name, nbuf);</span><br><span class="line">    		sem_list[i].value = value;</span><br><span class="line">            sem_list[i].active=<span class="number">1</span>;</span><br><span class="line">   			sem_list[i].<span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> &amp;sem_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表已满</span></span><br><span class="line">    errno = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>sem_wait</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> sem_wait()就是信号量的P原子操作。</span></span><br><span class="line"><span class="comment"> 如果继续运行的条件不满足，则令调用进程等待在信号量sem上。</span></span><br><span class="line"><span class="comment"> 返回0表示成功，返回-1表示失败。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sem_wait</span><span class="params">(<span class="type">sem_t</span> * sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 判断:如果传入的信号量是无效信号量，P操作失败，返回-1 */</span></span><br><span class="line">    <span class="keyword">if</span>(sem == <span class="literal">NULL</span> || sem &lt; sem_list || sem &gt; sem_list + SEM_LIST_LENGTH)</span><br><span class="line">    &#123;</span><br><span class="line">        errno=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 关中断 */</span></span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">while</span>(sem-&gt;value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep_on(&amp;(sem-&gt;<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    sem-&gt;value--; </span><br><span class="line">    <span class="comment">/* 开中断 */</span></span><br><span class="line">    sti();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sem_post</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sem_post()就是信号量的V原子操作。</span></span><br><span class="line"><span class="comment">如果有等待sem的进程，它会唤醒其中的一个。</span></span><br><span class="line"><span class="comment">返回0表示成功，返回-1表示失败。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sem_post</span><span class="params">(<span class="type">sem_t</span> * sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 判断:如果传入的信号量是无效信号量，V操作失败，返回-1 */</span></span><br><span class="line">    <span class="keyword">if</span>(sem == <span class="literal">NULL</span> || sem &lt; sem_list || sem &gt; sem_list + SEM_LIST_LENGTH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 关中断 */</span></span><br><span class="line">    cli();</span><br><span class="line">    sem-&gt;value++;</span><br><span class="line">    <span class="comment">/* 如果有等待sem的进程，它会唤醒其中的一个。 */</span></span><br><span class="line">    <span class="keyword">if</span>(sem-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	wake_up(&amp;(sem-&gt;<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 开中断 */</span></span><br><span class="line">    sti();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sem_unlink</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sem_unlink()的功能是删除名为name的信号量。</span></span><br><span class="line"><span class="comment">返回0表示成功，返回-1表示失败。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_sem_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        errno = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 首先将信号量的名称赋值到新建的缓冲区中 */</span></span><br><span class="line">    <span class="type">char</span> nbuf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nbuf[i] = get_fs_byte(name + i);</span><br><span class="line">        <span class="keyword">if</span> (nbuf[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SEM_LIST_LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str_cmp(sem_list[i].name, nbuf)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_list[i].active=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>pc.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">sem_t</span> *, sem_open, <span class="type">const</span> <span class="type">char</span> *, name, <span class="type">unsigned</span> <span class="type">int</span>, value);</span><br><span class="line">_syscall1(<span class="type">int</span>, sem_wait, <span class="type">sem_t</span> *, sem);</span><br><span class="line">_syscall1(<span class="type">int</span>, sem_post, <span class="type">sem_t</span> *, sem);</span><br><span class="line">_syscall1(<span class="type">int</span>, sem_unlink, <span class="type">const</span> <span class="type">char</span> *, name);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* filename=<span class="string">&quot;buffer.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span>* empty;</span><br><span class="line"><span class="type">sem_t</span>* full;</span><br><span class="line"><span class="type">sem_t</span>* mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Producer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">500</span>;i++)&#123;</span><br><span class="line">		sem_wait(empty);</span><br><span class="line">		sem_wait(mutex);</span><br><span class="line">		tmp=lseek(fd,<span class="number">0</span>,SEEK_CUR);</span><br><span class="line">		lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">		<span class="built_in">sprintf</span>(s,<span class="string">&quot;%03d\n&quot;</span>,i);</span><br><span class="line">		write(fd,s,<span class="number">4</span>);</span><br><span class="line">		lseek(fd,tmp,SEEK_SET);</span><br><span class="line">		sem_post(mutex);</span><br><span class="line">		sem_post(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Consumer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	sem_wait(full);</span><br><span class="line">	sem_wait(mutex);</span><br><span class="line">	read(fd,s,<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d : %s&quot;</span>,getpid(),s);</span><br><span class="line">	sem_post(mutex);</span><br><span class="line">	sem_post(empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	fd=open(filename,O_RDWR|O_CREAT);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,errno);	</span><br><span class="line">	empty=sem_open(<span class="string">&quot;empty&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	full=sem_open(<span class="string">&quot;full&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	mutex=sem_open(<span class="string">&quot;mutex&quot;</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">		Producer();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">			<span class="type">int</span> c=<span class="number">50</span>;</span><br><span class="line">			<span class="keyword">while</span>(c--)	Consumer();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	sem_unlink(<span class="string">&quot;empty&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;full&quot;</span>);</span><br><span class="line">	sem_unlink(<span class="string">&quot;mutex&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>这部分踩过的坑：</strong></p>
<ol>
<li><p>在用户态和核心态之间传递参数【这个我没考虑到】</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">指针参数传递的是应用程序所在地址空间的逻辑地址，</span><br><span class="line">在内核中如果直接访问这个地址，访问到的是内核空间中的数据，不会是用户空间的。</span><br><span class="line">所以这里还需要一点儿特殊工作，才能在内核中从用户空间得到数据。</span><br></pre></td></tr></table></figure>

<p>这段代码就是在做这个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先将信号量的名称赋值到新建的缓冲区中 */</span></span><br><span class="line">    <span class="type">char</span> nbuf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	nbuf[i] = get_fs_byte(name+i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这一段代码值得学习</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> _SEM_H_</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _SEM_H_</span></span><br></pre></td></tr></table></figure></li>
<li><p>一个第一眼看傻掉了的问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sleep函数的签名</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span>;</span><br><span class="line"><span class="comment">//一开始初始化队列为空</span></span><br><span class="line">sem_list[i].<span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//使用sleep</span></span><br><span class="line">sleep_on(&amp;(sem-&gt;<span class="built_in">queue</span>));</span><br></pre></td></tr></table></figure>

<p>如果队列为空的时候，传入sleep_on的是不是NULL呢？</p>
<p>其实这个本质上是type* p=NULL,&amp;p是不是NULL的问题。虽然知道不是，但还是写个程序测试一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">&#125;haha;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">isNULL</span><span class="params">(haha** a)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a==<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	haha *h=<span class="literal">NULL</span>;</span><br><span class="line">	isNULL(&amp;h);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result：0</span></span><br></pre></td></tr></table></figure></li>
<li><p>sem_post签名与实现矛盾</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">wake_up</span><span class="params">()</span></span> 的功能是唤醒链表上睡眠的所有进程。</span><br><span class="line"><span class="function"><span class="title">sem_post</span><span class="params">()</span></span> 就是信号量的 V 原子操作。如果有等待 sem 的进程，它会唤醒其中的一个。</span><br></pre></td></tr></table></figure>

<p>以上都是指导书的内容。这个“所有”和“一个”的用意我不大明白。也许唤醒所有进程，其中一个抢到了锁，其他的全睡了，这个也被认为是唤醒其中一个吧（）</p>
</li>
<li><p>聪明的越界处理【未考虑到】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 判断:如果传入的信号量是无效信号量，V操作失败，返回-1 */</span></span><br><span class="line"><span class="keyword">if</span>(sem == <span class="literal">NULL</span> || sem &lt; sem_list || sem &gt; sem_list + SEM_LIST_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毕竟有效的信号量都是引用的信号量表的信号量。所以地址越界的自然无效。</p>
</li>
<li><p>最坑的一点</p>
<p>其实指导书提醒了</p>
<blockquote>
<p>下面描述的问题未必具有普遍意义，仅做为提醒，请实验者注意。</p>
<p>include/string.h 实现了全套的 C 语言字符串操作，而且都是采用汇编 + inline 方式优化。</p>
<p>但在使用中，某些情况下可能会遇到一些奇怪的问题。比如某人就遇到 <code>strcmp()</code> 会破坏参数内容的问题。如果调试中遇到有些 “诡异” 的情况，可以试试不包含头文件，一般都能解决。不包含 <code>string.h</code>，就不会用 inline 方式调用这些函数，它们工作起来就趋于正常了。</p>
</blockquote>
<p>但是具体表现跟它说的差距有点大（）</p>
<p>我是全部检查没问题了，然后上linux0.11真机运行。PID:number这样的信息全部打印出来了，没啥问题，但是打印完操作系统就会寄，大多数极端情况就直接重启了，小部分还会温和地提醒以下报错信息然后死循环</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">kernel panic: trying <span class="keyword">to</span> free up swapper memory <span class="literal">space</span></span><br><span class="line"><span class="keyword">in</span> swapper task - <span class="keyword">not</span> syncing</span><br></pre></td></tr></table></figure>

<p>最后尝试着修改去掉string.h，才得到了正确的结果，泪目。</p>
</li>
</ol>
<h1 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="proc文件系统"></a>proc文件系统</h1><blockquote>
<p>参考文章：</p>
<h6 id="操作系统实验08-proc文件系统的实现"><a href="#操作系统实验08-proc文件系统的实现" class="headerlink" title="操作系统实验08-proc文件系统的实现"></a><a href="https://www.cnblogs.com/mirage-mc/p/13036570.html">操作系统实验08-proc文件系统的实现</a></h6></blockquote>
<blockquote>
<p>在 Linux 0.11 上实现 procfs（proc 文件系统）内的 psinfo 结点。当读取此结点的内容时，可得到系统当前所有进程的状态信息。例如，用 cat 命令显示 <code>/proc/psinfo</code> 和<code>/proc/hdinfo</code>的内容，可得到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/psinfo</span><br><span class="line">pid    state    father    counter    start_time</span><br><span class="line">0    1    -1    0    0</span><br><span class="line">1    1    0    28    1</span><br><span class="line">4    1    1    1    73</span><br><span class="line">3    1    1    27    63</span><br><span class="line">6    0    4    12    817</span><br><span class="line">$ <span class="built_in">cat</span> /proc/hdinfo</span><br><span class="line">total_blocks:    62000;</span><br><span class="line">free_blocks:    39037;</span><br><span class="line">used_blocks:    22963;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>procfs</code> 及其结点要在内核启动时自动创建。</p>
<p>相关功能实现在 <code>fs/proc.c</code> 文件内。</p>
</blockquote>
<h2 id="必备知识-1"><a href="#必备知识-1" class="headerlink" title="必备知识"></a>必备知识</h2><h3 id="要点1-procfs简介"><a href="#要点1-procfs简介" class="headerlink" title="要点1 procfs简介"></a>要点1 procfs简介</h3><blockquote>
<p>正式的 Linux 内核实现了 <code>procfs</code>，它是一个**<u>虚拟文件系统</u>**，通常被 mount（挂载） 到 <code>/proc</code> 目录上，通过<u>虚拟文件和虚拟目录的方式</u>提供<u><strong>访问系统参数</strong></u>的机会，所以有人称它为 “了解系统信息的一个窗口”。</p>
<p>这些虚拟的文件和目录**<u>并没有真实地存在在磁盘</u>**上，而是内核中各种数据的一种直观表示。虽然是虚拟的，但它们都可以通过标准的系统调用（<code>open()</code>、<code>read()</code> 等）访问。</p>
<p>其实，Linux 的很多系统命令就是通过读取 <code>/proc</code> 实现的。例如 <code>uname -a</code> 的部分信息就来自 <code>/proc/version</code>，而 <code>uptime</code> 的部分信息来自 <code>/proc/uptime</code> 和 <code>/proc/loadavg</code>。</p>
</blockquote>
<h3 id="要点2-基本思路"><a href="#要点2-基本思路" class="headerlink" title="要点2 基本思路"></a>要点2 基本思路</h3><blockquote>
<p>Linux 是<u><strong>通过文件系统接口</strong></u>实现 <code>procfs</code>，并在启动时自动将其 mount 到 <code>/proc</code> 目录上。</p>
<p>此目录下的所有内容都是<u>随着系统的运行自动建立、删除和更新</u>的，而且<u><strong>它们完全存在于内存中</strong></u>，不占用任何外存空间。</p>
<p>Linux 0.11 还没有实现虚拟文件系统，也就是，还没有提供增加新文件系统支持的接口。所以本实验只能在现有文件系统的基础上，通过打补丁的方式模拟一个 <code>procfs</code>。</p>
<p>Linux 0.11 使用的是 Minix 的文件系统，这是一个典型的基于 <code>inode</code> 的文件系统，《注释》一书对它有详细描述。它的每个文件都要对应至少一个 inode，而 inode 中记录着文件的各种属性，包括文件类型。文件类型有<u><strong>普通文件、目录、字符设备文件和块设备文件</strong></u>等。在内核中，每种类型的文件都有不同的处理函数与之对应。我们可以<u><strong>增加一种新的文件类型——proc 文件</strong></u>，并在<u>相应的处理函数内实现 procfs 要实现的功能</u>。</p>
</blockquote>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="要点1-新增proc文件类型"><a href="#要点1-新增proc文件类型" class="headerlink" title="要点1 新增proc文件类型"></a>要点1 新增proc文件类型</h3><p>include/sys/stat.h  新增：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IFPROC 0050000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_ISPROC(m)	(((m) &amp; S_IFMT) == S_IFPROC)</span></span><br></pre></td></tr></table></figure>

<h3 id="要点2-修改mknod-函数和init-函数"><a href="#要点2-修改mknod-函数和init-函数" class="headerlink" title="要点2 修改mknod()函数和init()函数"></a>要点2 修改mknod()函数和init()函数</h3><blockquote>
<p>psinfo 结点要通过 <code>mknod()</code> 系统调用建立，所以要让它支持新的文件类型。</p>
</blockquote>
<p>直接修改 <code>fs/namei.c</code> 文件中的 <code>sys_mknod()</code> 函数中的一行代码，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (S_ISBLK(mode) || S_ISCHR(mode) || S_ISPROC(mode))</span><br><span class="line">     inode-&gt;i_zone[<span class="number">0</span>] = dev;</span><br><span class="line"><span class="comment">// 文件系统初始化</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>内核初始化的全部工作是在 <code>main()</code> 中完成，而 <code>main()</code> 在最后从内核态切换到用户态，并调用 <code>init()</code>。</p>
<p><code>init()</code> 做的第一件事情就是挂载根文件系统：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line"><span class="comment">//    ……    </span></span><br><span class="line">setup((<span class="type">void</span> *) &amp;drive_info); </span><br><span class="line"><span class="comment">//    …… </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>procfs</code> 的初始化工作**<u>应该在根文件系统挂载之后开始</u>**。它包括两个步骤：</p>
<ul>
<li><p>（1）建立 <code>/proc</code> 目录；建立 <code>/proc</code> 目录下的各个结点。本实验只建立 <code>/proc/psinfo</code>。</p>
</li>
<li><p>（2）建立目录和结点分别需要调用 <code>mkdir()</code> 和 <code>mknod()</code> 系统调用。因为初始化时已经在用户态，所以不能直接调用 <code>sys_mkdir()</code> 和 <code>sys_mknod()</code>。必须在初始化代码所在文件中实现这两个系统调用的用户态接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      </span><br><span class="line">_syscall2(<span class="type">int</span>,mkdir,<span class="type">const</span> <span class="type">char</span>*,name,<span class="type">mode_t</span>,mode);</span><br><span class="line">_syscall3(<span class="type">int</span>,mknod,<span class="type">const</span> <span class="type">char</span>*,filename,<span class="type">mode_t</span>,mode,<span class="type">dev_t</span>,dev);</span><br></pre></td></tr></table></figure>

<p><code>mkdir()</code> 时 mode 参数的值可以是 “0755”（对应 <code>rwxr-xr-x</code>），表示只允许 root 用户改写此目录，其它人只能进入和读取此目录。</p>
<p>procfs 是一个只读文件系统，所以用 <code>mknod()</code> 建立 psinfo 结点时，必须通过 mode 参数将其设为只读。建议使用 <code>S_IFPROC|0444</code> 做为 mode 值，表示这是一个 proc 文件，权限为 0444（r–r–r–），对所有用户只读。</p>
<p><code>mknod()</code> 的第三个参数 dev 用来说明结点所代表的设备编号。对于 procfs 来说，此编号可以完全自定义。proc 文件的处理函数将通过这个编号决定对应文件包含的信息是什么。<u><strong>例如，可以把 0 对应 psinfo，1 对应 meminfo，2 对应 cpuinfo。</strong></u></p>
</li>
</ul>
</blockquote>
<p>也就是说，打开linux-0.11/init/main.c</p>
<p>加入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="type">int</span>,mkdir,<span class="type">const</span> <span class="type">char</span>*,name,<span class="type">mode_t</span>,mode);</span><br><span class="line">_syscall3(<span class="type">int</span>,mknod,<span class="type">const</span> <span class="type">char</span>*,filename,<span class="type">mode_t</span>,mode,<span class="type">dev_t</span>,dev);</span><br></pre></td></tr></table></figure>

<p>在init函数中，添加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/proc&quot;</span>,<span class="number">0755</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/psinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//其余文件以此类推...</span></span><br></pre></td></tr></table></figure>

<p>编译运行即可看到：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20221006141358458.png" class> 

<blockquote>
<p>这些信息至少说明，psinfo 被正确 <code>open()</code> 了。所以我们不需要对 <code>sys_open()</code> 动任何手脚，唯一要打补丁的，是 <code>sys_read()</code>。</p>
</blockquote>
<h3 id="要点3-修改read-，让proc可读"><a href="#要点3-修改read-，让proc可读" class="headerlink" title="要点3 修改read()，让proc可读"></a>要点3 修改read()，让proc可读</h3><blockquote>
<p>首先分析 <code>sys_read</code>（在文件 <code>fs/read_write.c</code> 中）</p>
<p>要在这里一群 if 的排比中，加上 <code>S_IFPROC()</code> 的分支，进入对 proc 文件的处理函数。需要传给处理函数的参数包括：</p>
<ul>
<li><code>inode-&gt;i_zone[0]</code>，这就是 <code>mknod()</code> 时指定的 <code>dev</code> ——设备编号</li>
<li><code>buf</code>，指向用户空间，就是 <code>read()</code> 的第二个参数，用来接收数据</li>
<li><code>count</code>，就是 <code>read()</code> 的第三个参数，说明 <code>buf</code> 指向的缓冲区大小</li>
<li><code>&amp;file-&gt;f_pos</code>，<code>f_pos</code> 是上一次读文件结束时“文件位置指针”的指向。这里必须传指针，因为处理函数需要根据传给 <code>buf</code> 的数据量修改 <code>f_pos</code> 的值。</li>
</ul>
</blockquote>
<p>依照指导书，在read_write.c添加如下语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">proc_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> dev,<span class="type">char</span>* buf,<span class="type">int</span> count,<span class="type">off_t</span>* f_pos)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(...)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISPROC(inode-&gt;i_mode))&#123;</span><br><span class="line">        <span class="keyword">return</span> proc_handler(inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要点4-编写pro文件的处理函数"><a href="#要点4-编写pro文件的处理函数" class="headerlink" title="要点4 编写pro文件的处理函数"></a>要点4 编写pro文件的处理函数</h3><blockquote>
<p>proc 文件的处理函数的功能是<u><strong>根据设备编号</strong></u>，把不同的内容写入到用户空间的 buf。写入的数据要从 <code>f_pos</code> 指向的位置开始，每次最多写 count 个字节，并根据实际写入的字节数调整 <code>f_pos</code> 的值，最后返回实际写入的字节数。当设备编号表明要读的是 psinfo 的内容时，就要按照 psinfo 的形式组织数据。</p>
<p>实现此函数可能要用到如下几个函数：</p>
<ul>
<li>malloc() 函数</li>
<li>free() 函数</li>
</ul>
<p>包含 <code>linux/kernel.h</code> 头文件后，就可以使用 <code>malloc()</code> 和 <code>free()</code> 函数。它们是可以被核心态代码调用的，唯一的限制是一次申请的内存大小不能超过一个页面。</p>
</blockquote>
<blockquote>
<p>进程的信息就来源于内核全局结构数组 <code>struct task_struct * task[NR_TASKS]</code> 中，具体读取细节可参照 <code>sched.c</code> 中的函数 <code>schedule()</code>。</p>
<p>可以借鉴一下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*p)</span><br><span class="line">(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>)+...;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>cat 是 Linux 下的一个常用命令，功能是将文件的内容打印到标准输出。</p>
<p>它核心实现大体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">513</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> nread;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(argv[<span class="number">1</span>], O_RDONLY, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(nread = read(fd, buf, <span class="number">512</span>))</span><br><span class="line">&#123;</span><br><span class="line">  buf[nread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在cat的代码中，open函数返回了psinfo的文件描述符，read函数读到该文件描述符，就会识别出我们要读写的文件是PROC类型的，因此就会跳转到我们的proc_handler去执行，再进一步跳转到psinfo_handler执行。根据cat的代码和指导书的提示，不难得出，我们的目标就是把进程的信息按照格式给弄进buf里面，就可以了。</p>
<p>而这也正体现了proc作为“**<u>虚拟文件</u>**”的特点。对它进行读写，它的信息并非存放在磁盘中，而是全部由放在内存中的逻辑和数据【由task_struct提供】来完成。</p>
<p>在fs文件夹下创建文件proc_dev.c，编写proc文件的处理函数。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_bit(nr,addr) (&#123;\</span></span><br><span class="line"><span class="meta">register int res ; \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="string">&quot;btsl %2,%3\n\tsetb %%al&quot;</span>: \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;=a&quot;</span> (res):<span class="string">&quot;0&quot;</span> (0),<span class="string">&quot;r&quot;</span> (nr),<span class="string">&quot;m&quot;</span> (*(addr))); \</span></span><br><span class="line"><span class="meta">res;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>** <span class="title">p</span>=</span>&amp;FIRST_TASK;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">psinfo_handler</span><span class="params">(<span class="type">off_t</span>* f_pos,<span class="type">char</span>* buf)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">hdinfo_handler</span><span class="params">(<span class="type">off_t</span>* f_pos,<span class="type">char</span>* buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">proc_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> dev,<span class="type">char</span>* buf,<span class="type">int</span> count,<span class="type">off_t</span>* f_pos)</span>&#123;</span><br><span class="line">    <span class="comment">//根据设备编号，把不同的内容写入到用户空间的 buf</span></span><br><span class="line">	<span class="keyword">switch</span>(dev)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> psinfo_handler(f_pos,buf);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> hdinfo_handler(f_pos,buf);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内核态和用户态间传递数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">put_into_buf</span><span class="params">(<span class="type">char</span>* buf,<span class="type">char</span>* s)</span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(s[cnt]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">		put_fs_byte(s[cnt++],buf++);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span>* buf,<span class="type">const</span> <span class="type">char</span>* fmt,...)</span>&#123;</span><br><span class="line">	va_list args;<span class="type">int</span> i;</span><br><span class="line">	va_start(args,fmt);</span><br><span class="line">	i=<span class="built_in">vsprintf</span>(buf,fmt,args);</span><br><span class="line">	va_end(args);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">psinfo_handler</span><span class="params">(<span class="type">off_t</span>* f_pos,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//初始化字符串</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)	s[i]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果是第一次read，需要在屏幕上打印列表头，并且重置p指针为进程队列头</span></span><br><span class="line">	<span class="keyword">if</span>((*f_pos)==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(s,<span class="string">&quot;pid\tstate\tfather\tcounter\tstart_time\n&quot;</span>);</span><br><span class="line">		p=&amp;FIRST_TASK;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//到达文件末尾</span></span><br><span class="line">	<span class="keyword">if</span>((*p)==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次仅输出一行</span></span><br><span class="line">	<span class="keyword">if</span>((*f_pos)!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(s,<span class="string">&quot;%ld\t%ld\t%ld\t%ld\t%ld\n&quot;</span>,(*p)-&gt;pid,(*p)-&gt;state,(*p)-&gt;father,(*p)-&gt;counter,(*p)-&gt;start_time);</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> cnt=put_into_buf(buf,s);</span><br><span class="line">	*f_pos+=cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可参考fs/super.c mount_root()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hdinfo_handler</span><span class="params">(<span class="type">off_t</span>* f_pos,<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">    <span class="comment">//防止循环多次打印</span></span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">sb</span>;</span></span><br><span class="line">	sb=get_super(<span class="number">0x301</span>);<span class="comment">/*磁盘设备号 3*256+1*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i=sb-&gt;s_nzones;</span><br><span class="line">	<span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,sb-&gt;s_zmap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">			<span class="built_in">free</span>++;</span><br><span class="line">	<span class="built_in">sprintf</span>(s,<span class="string">&quot;total_blocks:\t%d\nfree_blocks:\t%d\nused_blocks:\t%d\n&quot;</span>,sb-&gt;s_nzones,<span class="built_in">free</span>,sb-&gt;s_nzones-<span class="built_in">free</span>);</span><br><span class="line">	<span class="type">int</span> cnt=put_into_buf(buf,s);</span><br><span class="line">	flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="/2022/10/04/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/image-20221006210732995.png" class> 

<h4 id="这部分踩过的坑："><a href="#这部分踩过的坑：" class="headerlink" title="这部分踩过的坑："></a>这部分踩过的坑：</h4><p>1.LAST_TASK 的定义</p>
<p>对于LAST_TASK，我本来的理解是，当前所有进程的最后一个。</p>
<p>本来我设的是跟schedule一样，另p=LAST_TASK，从末尾开始打印。我那时其余代码跟上面一样，就只是把上面的FIRST改成LAST，结果输出为空，调试发现LAST_TASK==NULL。</p>
<p>然后打开sched.h，看到LAST_TASK的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_TASK task[NR_TASKS-1]</span></span><br></pre></td></tr></table></figure>

<p>原来它就是单纯简单粗暴地指“最后一个”进程23333</p>
<p>我们目前当前的进程数量远远小于进程的最大数量，因此最大数量编号的那个进程自然也就是空的了。</p>
<p>2.char s[100]={0};</p>
<p>用这个的时候编译报错：undefined reference to ’memset‘</p>
<p>说明这个简略写法其实本质是用的memset，而要用memset的话需要包含头文件string.h。经测试得包含了string.h后确实就好使了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s_imap_blocks、ns_zmap_blocks、</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//total_blocks、free_blocks、used_blocks、total_inodes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;is_zmap_blocks;i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    bh=sb-&gt;s_zmap[i];</span><br><span class="line"></span><br><span class="line">    db=(<span class="type">char</span>*)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1024</span>;j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=<span class="number">8</span>;k++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((used_blocks+free_blocks)&gt;=total_blocks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( *(db+j) &amp; k)</span><br><span class="line">    used_blocks++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">free_blocks++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.我发现一件事</p>
<p>我第一次把init/main.c写错了，写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/proc&quot;</span>,<span class="number">0755</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/psinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">0</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/hdinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">0</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/inodeinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>设别号忘了改了。然后进行了一次编译，运行。</p>
<p>之后我发现错了，就改成了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/proc&quot;</span>,<span class="number">0755</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/psinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">0</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/hdinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">1</span>);</span><br><span class="line">mknod(<span class="string">&quot;/proc/inodeinfo&quot;</span>,S_IFPROC|<span class="number">0400</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>再次编译运行，结果上面的那个错还是没改回来</p>
<p>直到我手动把proc文件夹删了，再重新读一次磁盘加载proc文件夹，才回归正常。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>本次实验耗时：下午一点到晚上九点半（）</p>
<p>本实验通过对proc虚拟文件的编写流程，实际上让我们体会到了“一切皆文件”的思想。</p>
<p>什么东西都可以是文件，只不过它们有不同的文件类型和不同的read/write处理函数。</p>
<p>对于终端设备和磁盘，其read/write函数本质上是在用out指令跟它的缓冲区交互，只不过磁盘比终端设备抽象层次更深，包含了文件系统的层层封装。</p>
<p>对于虚拟文件，其read/write函数本质上就是与内存交互，通过一段逻辑【处理函数】将内存存储的当前操作系统信息实时显示出来，而不需要存储。</p>
<p>还有，参考文章那篇的代码写的很好，快去看！</p>
]]></content>
      <tags>
        <tag>labs</tag>
      </tags>
  </entry>
  <entry>
    <title>对GRUB和initramfs的小探究</title>
    <url>/2023/06/17/%E5%AF%B9GRUB%E5%92%8Cinitramfs%E7%9A%84%E5%B0%8F%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>竞赛时对操作系统启动过程产生了些疑问，于是问题导向地浅浅探究了下GRUB和initramfs相关机制，相关笔记先放在这里了。</p>
<h1 id="内核启动流程"><a href="#内核启动流程" class="headerlink" title="内核启动流程"></a>内核启动流程</h1><p>在传统的BIOS系统中，计算机具体的启动流程如下：</p>
<ol>
<li>电源启动：当计算机的电源打开时，电源供电给计算机的硬件设备。</li>
<li>BIOS自检：计算机的BIOS固件会自检硬件设备，包括RAM、处理器、硬盘等，以确保它们正常工作。</li>
<li>引导设备选择：BIOS会根据预先定义的启动顺序（通常是硬盘、光驱、USB等）选择一个启动设备。</li>
<li>MBR（Master Boot Record）加载：如果选择的启动设备是硬盘，BIOS会加载该硬盘的MBR，其中包含了引导加载程序。</li>
<li>GRUB加载：MBR中的引导加载程序通常是GRUB（或其他引导加载程序）。GRUB会被加载到计算机的内存中，并开始执行。</li>
<li>GRUB菜单：GRUB会显示一个菜单，列出可供选择的操作系统或内核。</li>
<li>操作系统加载：用户选择操作系统后，GRUB会加载相应的操作系统或内核，并将控制权交给它。</li>
</ol>
<p>在本次内核编译配置过程中，<strong>最主要探究的是文件系统的装载过程</strong>，也即介于6-7之间的部分。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>文件系统在启动流程中的发展历程可以分为以下三个部分：</p>
<ol>
<li><p>GRUB文件系统</p>
<p>由 GRUB 自身通过 BIOS 提供的服务加载</p>
</li>
<li><p>initramfs</p>
<p>由GRUB加载，用于挂载真正的文件系统</p>
</li>
<li><p>真正的根文件系统</p>
</li>
</ol>
<p>下面，将介绍1和2两个流程。</p>
<h2 id="GRUB"><a href="#GRUB" class="headerlink" title="GRUB"></a>GRUB</h2><blockquote>
<p>GRUB（GNU GRand Unified Bootloader）是一种常用的引导加载程序，用于在计算机启动时加载操作系统。</p>
<p>GRUB的主要功能是在计算机启动时提供一个菜单，让用户选择要启动的操作系统或内核。它支持多个操作系统，包括各种版本的Linux、Windows、BSD等。通过GRUB，用户可以在多个操作系统之间轻松切换。</p>
<p>除了操作系统选择，GRUB还提供了一些高级功能，例如引导参数的设置、内存检测、系统恢复等。它还支持在启动过程中加载内核模块和初始化RAM磁盘映像（initrd或initramfs）。</p>
<p>GRUB具有高度可配置性，允许用户自定义引导菜单、设置默认启动项、编辑内核参数等。它还支持引导加载程序间的链式引导，可以引导其他引导加载程序，如Windows的NTLDR。</p>
</blockquote>
<p>GRUB的基本作用流程为：</p>
<ol>
<li>BIOS加载MBR，MBR加载GRUB，开始执行GRUB程序</li>
<li>GRUB程序会读取<code>grub.cfg</code>配置文件</li>
<li>GRUB程序依据配置文件，进行内核的加载、根文件系统的挂载等操作，最后将主导权转交给内核</li>
</ol>
<h3 id="grub-cfg"><a href="#grub-cfg" class="headerlink" title="grub.cfg"></a>grub.cfg</h3><p>内核启动时，GRUB程序会读取<code>/boot/grub/</code>目录下的GRUB配置文件<code>grub.cfg</code>，其中记录了所有GRUB菜单可供选择的内核选项（menuentry）及其对应的启动依赖参数。以6.4.0内核选项为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">menuentry标识着GRUB菜单中的一个内核选项</span></span><br><span class="line">menuentry &#x27;Ubuntu&#x27; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &#x27;gnulinux-simple-XXX&#x27; &#123;</span><br><span class="line">        recordfail # 记录上次启动是否失败，用于处理启动失败的情况</span><br><span class="line">        load_video # 加载视频驱动模块，用于在启动过程中显示图形界面</span><br><span class="line">        gfxmode $linux_gfx_mode # 设置图形模式</span><br><span class="line">        insmod gzio # 加载gzio模块，提供对GZIP压缩和解压缩功能的支持</span><br><span class="line">        # 如果是在Xen虚拟化平台上，则加载xzio和lzopio模块</span><br><span class="line">        if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi </span><br><span class="line">        </span><br><span class="line">        insmod part_gpt # 加载part_gpt模块，支持GUID分区表（GPT）</span><br><span class="line">        insmod ext2 # 加载ext2模块，支持ext2文件系统</span><br><span class="line">        </span><br><span class="line">        # 设置文件系统的根分区</span><br><span class="line">        set root=&#x27;hd0,gpt3&#x27; </span><br><span class="line">        if [ x$feature_platform_search_hint = xy ]; then</span><br><span class="line">          search --no-floppy --fs-uuid --set=root --hint-bios=hd0,gpt3 --hint-efi=hd0,gpt3 --hint-baremetal=ahci0,gpt3  XXX</span><br><span class="line">        else</span><br><span class="line">          search --no-floppy --fs-uuid --set=root XXX</span><br><span class="line">        fi</span><br><span class="line">        </span><br><span class="line">        linux   /boot/vmlinuz-6.4.0-rc3+ root=UUID=XXX ro text # 指定内核映像的路径和启动参数</span><br><span class="line">        initrd  /boot/initrd.img-6.4.0-rc3+ # 指定initramfs映像的路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>grub.cfg</code>主要记录了一些该<strong>内核启动需要的依赖module</strong>，以及<strong>内核映像和initramfs映像的路径</strong>。</p>
<p>menuentry的代码中，有以下几个要点值得注意：</p>
<ol>
<li><p><code>insmod gzio </code></p>
<p>由于加载gzio模块，提供对GZIP压缩和解压缩功能的支持。</p>
<p>看到这里我第一反应是觉得有点割裂，为啥这看着比较无关紧要的解压缩功能要在内核启动之前就需要有呢？于是我想起来在配置内核时，有一个选项是这样的：</p>
<p><img src="/2023/06/17/%E5%AF%B9GRUB%E5%92%8Cinitramfs%E7%9A%84%E5%B0%8F%E6%8E%A2%E7%A9%B6/image-20230616143835953.png" alt="image-20230616143835953"></p>
<p>在配置选项中，我们选择了对initramfs的支持，并且勾选了<code>Support initial ramdisk/ramfs compressed using gzip </code>，也即在编译时通过gzip压缩initramfs的大小以节省空间。</p>
<p>所以说，我们在内核启动之前，持有的initramfs处于被压缩的状态。故而，我们自然需要在内核启动之前安装gzio模块，从而支持之后对initramfs的解压缩了。</p>
</li>
<li><p><code>insmod ext2</code></p>
<p>这句代码说明，GRUB的临时文件系统为ext2类型，这句代码事实上是在安装GRUB建立临时文件的必要依赖包，从而GRUB程序之后才能建立其临时文件系统、从/boot/initrd.img获取initramfs映像。</p>
</li>
<li><p><code>linux   /boot/vmlinuz-6.4.0-rc3+ root=UUID=XXX ro text</code></p>
<p>指定了启动参数，也即将根文件系统以只读（<code>ro</code>）的方式挂载在<code>root=UUID=XXX</code>对应的块设备上，并且默认以<code>text</code>方式（也即非图形化的Shell界面）启动内核。</p>
<p><u>此处的启动参数可在下一个部分介绍的<code>grub</code>文件中个性化。</u></p>
</li>
</ol>
<h3 id="grub-cfg的生成与修改"><a href="#grub-cfg的生成与修改" class="headerlink" title="grub.cfg的生成与修改"></a>grub.cfg的生成与修改</h3><p>实际运用中，很多时候需要对启动参数进行一些修改。下面介绍两种修改<code>grub.cfg</code>的方法。</p>
<h4 id="etc-default-grub"><a href="#etc-default-grub" class="headerlink" title="/etc/default/grub"></a>/etc/default/grub</h4><p>可以看到，<code>grub.cfg</code>其实格式较为固定（也即由一系列内容也比较相似的menuentry构成）。因而，实际上我们是通过<code>grub.d</code>生成<code>grub.cfg</code>的（6.S081实验中事实上也涉及了这一点），而<code>/etc/default/grub</code>则是GRUB程序以及<code>grub.cfg</code>生成的配置文件。下面介绍下该文件主要有哪些配置选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If you change this file, run <span class="string">&#x27;update-grub&#x27;</span> afterwards to update</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/boot/grub/grub.cfg.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For full documentation of the options <span class="keyword">in</span> this file, see:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  info -f grub -n <span class="string">&#x27;Simple configuration&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机时GRUB界面的持续时间，此处设置为30s</span></span><br><span class="line">GRUB_TIMEOUT=30</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不使用图形化界面</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GRUB_TERMINAL=console</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">图形化界面的大小</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GRUB_GFXMODE=640x480</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不使用UUID</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GRUB_DISABLE_LINUX_UUID=<span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">隐藏recovery mode</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GRUB_DISABLE_RECOVERY=<span class="string">&quot;true&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>重点看下这几个参数：</p>
<ol>
<li><p><code>GRUB_CMDLINE_LINUX</code></p>
<p>表示最终生成的grub.cfg中的每一个menuentry中的linux那一行需要附加什么参数。</p>
<p>例如说，如果设置为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示initramfs在挂载真正的根文件系统之前，需要等待120s，用于防止磁盘没准备好导致的挂载失败</span></span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;rootdelay=120&quot; </span><br></pre></td></tr></table></figure>

<p>那么，最终在menuentry中的启动参数就为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">linux   /boot/vmlinuz-6.4.0-rc3+ root=UUID=XXX ro rootdelay=120 text</span><br></pre></td></tr></table></figure>

<p>其他一些常见的选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接以路径来标识块设备而非使用UUID。此为old option，建议尽量使用UUID</span></span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;root=/dev/sda3&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标明init进程（启动后第一个进程）的具体路径。此处指明为`/bin/sh`</span></span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;init=/bin/sh&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><code>GRUB_DEFAULT</code></p>
<p><a href="https://www.cnblogs.com/gongshunfeng91/p/15774196.html">参考</a>    可以用来指定重启时的内核选项。如<code>GRUB_DEFAULT=&quot;1&gt; 0&quot;</code>表示选择第一个菜单界面的第2栏（Advanced for Ubuntu）和第二个菜单的第1个内核。</p>
</li>
</ol>
<p>在修改完<code>grub</code>文件之后，我们需要执行<code>sudo update-grub</code>，来重新生成<code>grub.cfg</code>文件供下次启动使用。</p>
<h4 id="在GRUB界面直接修改"><a href="#在GRUB界面直接修改" class="headerlink" title="在GRUB界面直接修改"></a>在GRUB界面直接修改</h4><p><img src="/2023/06/17/%E5%AF%B9GRUB%E5%92%8Cinitramfs%E7%9A%84%E5%B0%8F%E6%8E%A2%E7%A9%B6/image-20230616151055620.png" alt="image-20230616151055620"></p>
<p>我们可以在GRUB界面选中所需内核，按下e键：</p>
<p><img src="/2023/06/17/%E5%AF%B9GRUB%E5%92%8Cinitramfs%E7%9A%84%E5%B0%8F%E6%8E%A2%E7%A9%B6/image-20230616151122738.png" alt="image-20230616151122738"></p>
<p>然后就可以对启动参数进行修改，^X退出。</p>
<p>值得注意的是，此修改仅对本次启动有效。如果需要长期修改，建议还是通过第一种方法去修改。</p>
<h2 id="initramfs"><a href="#initramfs" class="headerlink" title="initramfs"></a>initramfs</h2><p>GRUB程序会通过<code>initrd.img</code>启动initramfs，从而进行真正的根文件系统挂载。</p>
<blockquote>
<p>initrd.img是一个Linux系统中的初始化内存盘（initial RAM disk）的映像文件。它是一个压缩的文件系统映像，通常在引导过程中加载到内存中，并提供了一种临时的根文件系统，以便在正式的根文件系统（通常位于硬盘上）可用之前提供必要的功能和模块。</p>
</blockquote>
<p>我们可以通过<code>unmkinitramfs /boot/initrd.img-6.4.0-rc3+ /tmp/initrd/</code>命令解压initrd，探究里面到底有什么玩意。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">├── bin -&gt; usr/bin</span><br><span class="line">├── conf</span><br><span class="line">├── etc</span><br><span class="line">├── init</span><br><span class="line">├── lib -&gt; usr/lib</span><br><span class="line">├── lib32 -&gt; usr/lib32</span><br><span class="line">├── lib64 -&gt; usr/lib64</span><br><span class="line">├── libx32 -&gt; usr/libx32</span><br><span class="line">├── run</span><br><span class="line">├── sbin -&gt; usr/sbin</span><br><span class="line">├── scripts</span><br><span class="line">├── usr</span><br><span class="line">└── var</span><br><span class="line">init</span><br></pre></td></tr></table></figure>

<p>可以看到，这实际上就是一个小型的文件系统，也即initramfs。它有自己的built-in Shell（BusyBox）：</p>
<p><img src="/2023/06/17/%E5%AF%B9GRUB%E5%92%8Cinitramfs%E7%9A%84%E5%B0%8F%E6%8E%A2%E7%A9%B6/image-20230616151938951.png" alt="image-20230616151938951"></p>
<p>有一些较少的Shell命令（bin和sbin目录下），以及用来挂载真正的根文件系统的代码逻辑（存储在scripts目录下）。【我猜】在正常情况下，系统会执行scripts下的脚本代码挂载真正的文件系统。当挂载出现异常时，系统就会将控制权交给initramfs内置的Shell BusyBox，由用户自己探究出了什么问题。</p>
<p>我们接下来可以追踪下initramfs的script目录下的文件系统挂载流程。</p>
<p>挂载真正文件系统的主要函数为<code>local_mount_root</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅展示主要流程代码</span></span><br><span class="line">local_mount_root()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">预处理，获取参数等（也即上面grub.cfg配置的root=UUID）</span></span><br><span class="line">	local_top</span><br><span class="line">	if [ -z &quot;$&#123;ROOT&#125;&quot; ]; then</span><br><span class="line">		panic &quot;No root device specified. Boot arguments must include a root= parameter.&quot;</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">根据UUID获取对应的块设备</span></span><br><span class="line">	local_device_setup &quot;$&#123;ROOT&#125;&quot; &quot;root file system&quot;</span><br><span class="line">	ROOT=&quot;$&#123;DEV&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">挂载前的预处理</span></span><br><span class="line">	local_premount</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">挂载</span></span><br><span class="line">	mount $&#123;roflag&#125; $&#123;FSTYPE:+-t &quot;$&#123;FSTYPE&#125;&quot;&#125; $&#123;ROOTFLAGS&#125; &quot;$&#123;ROOT&#125;&quot; &quot;$&#123;rootmnt?&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于研究这个是错误驱动（乐），因而我只主要看了下<code>local_device_setup</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$1</span>=device ID to mount设备ID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$2</span>=optionname (<span class="keyword">for</span> root and etc)要挂载的是什么玩意，此处应为root file system</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$3</span>=panic <span class="keyword">if</span> device is missing (<span class="literal">true</span> or <span class="literal">false</span>, default: <span class="literal">true</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sets <span class="variable">$DEV</span> to the resolved device node <span class="variable">$DEV</span>是最终获取到的块设备</span></span><br><span class="line">local_device_setup()</span><br><span class="line">&#123;</span><br><span class="line">	local dev_id=&quot;$1&quot;</span><br><span class="line">	local name=&quot;$2&quot;</span><br><span class="line">	local may_panic=&quot;$&#123;3:-true&#125;&quot;</span><br><span class="line">	local real_dev</span><br><span class="line">	local time_elapsed</span><br><span class="line">	local count</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取grub.cfg的rootdelay参数的设备等待时间。如果没有该参数，默认是30秒</span></span><br><span class="line">	local slumber=30</span><br><span class="line">	if [ &quot;$&#123;ROOTDELAY:-0&#125;&quot; -gt $slumber ]; then</span><br><span class="line">		slumber=$ROOTDELAY</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">等待设备</span></span><br><span class="line">	case &quot;$dev_id&quot; in</span><br><span class="line">	UUID=*|LABEL=*|PARTUUID=*|/dev/*)</span><br><span class="line">		FSTYPE=$( wait-for-root &quot;$dev_id&quot; &quot;$slumber&quot; )</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		wait_for_udev 10</span><br><span class="line">		;;</span><br><span class="line">	esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">等待结束了。如果条件为真，说明还是获取不到对应的设备，那就只能说明这个设备死了</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">所以我们就得把问题告诉用户，让用户自己解决，并且进入BusyBox Shell</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">We<span class="string">&#x27;ve given up, but we&#x27;</span>ll <span class="built_in">let</span> the user fix matters <span class="keyword">if</span> they can</span></span><br><span class="line">	while ! real_dev=$(resolve_device &quot;$&#123;dev_id&#125;&quot;) ||</span><br><span class="line">	      ! get_fstype &quot;$&#123;real_dev&#125;&quot; &gt;/dev/null; do</span><br><span class="line">		if ! $may_panic; then</span><br><span class="line">			echo &quot;Gave up waiting for $&#123;name&#125;&quot;</span><br><span class="line">			return 1</span><br><span class="line">		fi</span><br><span class="line">		echo &quot;Gave up waiting for $&#123;name&#125; device.  Common problems:&quot;</span><br><span class="line">		echo &quot; - Boot args (cat /proc/cmdline)&quot;</span><br><span class="line">		echo &quot;   - Check rootdelay= (did the system wait long enough?)&quot;</span><br><span class="line">		if [ &quot;$&#123;name&#125;&quot; = root ]; then</span><br><span class="line">			echo &quot;   - Check root= (did the system wait for the right device?)&quot;</span><br><span class="line">		fi</span><br><span class="line">		echo &quot; - Missing modules (cat /proc/modules; ls /dev)&quot;</span><br><span class="line">		panic &quot;ALERT!  $&#123;dev_id&#125; does not exist.  Dropping to a shell!&quot;</span><br><span class="line">	done</span><br><span class="line"></span><br><span class="line">	DEV=&quot;$&#123;real_dev&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里如果进入错误状态，最终就是这样的效果2333：</p>
<p><img src="/2023/06/17/%E5%AF%B9GRUB%E5%92%8Cinitramfs%E7%9A%84%E5%B0%8F%E6%8E%A2%E7%A9%B6/image-20230616153420011.png" alt="image-20230616153420011"></p>
]]></content>
      <tags>
        <tag>os竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>网络是怎样连接的</title>
    <url>/2023/10/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/</url>
    <content><![CDATA[<blockquote>
<p>此为<a href="https://xiunianjun.github.io/2023/10/06/%E5%AD%98%E5%82%A8%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8%E4%B8%8E%E7%AE%A1%E7%90%86%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%EF%BC%9A%E6%95%B0%E5%AD%97%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8%E3%80%81%E7%AE%A1%E7%90%86%E5%92%8C%E4%BF%9D%E6%8A%A4%EF%BC%88%E5%BC%82%E6%AD%A5%E5%9B%BE%E4%B9%A6%EF%BC%89%20(G.Somasundara_.%20(Z-Library).pdf">《信息存储与管理（第二版）：数字信息的存储、管理和保护》</a>的看书总结，相当于是对存储技术的一个简单的名词入门。</p>
</blockquote>
<h1 id="浏览器生成消息"><a href="#浏览器生成消息" class="headerlink" title="浏览器生成消息"></a>浏览器生成消息</h1><p>本章节我印象最深的还是以前就不大了解的DNS，今天看到书的描写真有种豁然开朗的感觉。</p>
<p>DNS服务器用于保存域名—IP地址的映射对，为了增加查找效率，DNS根据域名的分级采用树形组织，例如<code>hitsz.edu.cn/</code>可以相当于是<code>/cn/edu/hitsz</code>，包含了<code>/</code>、<code>cn</code>、<code>edu</code>这几个域。根DNS服务器存储着根域，记录了所有一级域名对应DNS服务器的IP地址。所有的DNS服务器都会保存根服务器的IP地址。</p>
<blockquote>
<p>世界上只有13个根DNS服务器IP地址，但是有很多台根DNS服务器。</p>
</blockquote>
<p>主机需要手动配置DNS服务器地址。</p>
<p>当浏览器需要填写请求头时，它需要通过系统调用向操作系统发送DNS查询请求。操作系统将DNS请求发送给配置在主机上的DNS服务器（下称A），A再向根DNS服务器发送请求。根DNS服务器解析域名，返回下一级DNS服务器的IP地址。A再向下级DNS服务器再次发送请求，下级再返回下下级IP地址。以此类推，最终A就能得到目标IP地址的正确响应。整个过程如下图所示：</p>
<p><img src="/2023/10/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20231010132718116.png" alt="image-20231010132718116"></p>
<p>与此同时，各个DNS服务器都会有定时刷新的缓存，从而加速了查找效率。</p>
<h1 id="用电信号传输TCP-IP数据"><a href="#用电信号传输TCP-IP数据" class="headerlink" title="用电信号传输TCP/IP数据"></a>用电信号传输TCP/IP数据</h1><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>本章前面大多讨论TCP/IP具体协议内容，以前已经了解过很多次了就不多赘述。所以TCP/IP部分就以分点的形式随意列举一下：</p>
<ol>
<li><p>IP 中还包括 ICMPA 协议和 ARPB 协议。ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。</p>
</li>
<li><p>套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，【包括应用程序信息和协议栈状态信息】这就是套接字的作用。所以需要针对不同协议栈实现不同的socket。</p>
</li>
<li><p>是的，回想当初CS144，也是socket来负责有特定消息时调用TCP相关函数来通知处理。</p>
</li>
<li><p>连接 connect</p>
<p>连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作。</p>
<ol>
<li>应用程序向协议栈传ip地址</li>
<li>本机向服务器发通信请求</li>
<li>过程中分配通信缓冲区</li>
</ol>
</li>
<li><p>动态调整等待时间</p>
<p><img src="/2023/10/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20231012113725655.png" alt="image-20231012113725655"></p>
</li>
</ol>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ol>
<li><p>以太网的定义</p>
<p><img src="/2023/10/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20231012113840636.png" alt="image-20231012113840636"></p>
</li>
<li><p>系统初始化时MAC地址的设置</p>
<p>MAC地址是上电后由驱动程序从ROM中读取的，而非自动获取的</p>
</li>
<li><p><strong>电信号转换</strong>【这个帅得不行】</p>
<p>为了区分连续的1或0，我们就需要同时发送数据信号和时钟信号，然而这样开销太大，因而我们引入了<strong>上升沿</strong>。</p>
<p>上升沿本质上是数据信号和时钟信号叠加而成的结果，叠加方式是<strong>异或</strong>。</p>
<p><img src="/2023/10/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20231012114006378.png" alt="image-20231012114006378"></p>
<p>提到异或是否感觉豁然开朗？是的，这东西恢复时也是使用了异或的性质：接收方从帧头获取时钟频率从而得到时钟信号，跟收到的叠加信号进行再次叠加（异或），就可以获得原来的数据信号了。</p>
<p>我只能说牛逼，一直以来对异或的视角还停留在单纯的数字，这个波形的物理概念真的惊到我了。</p>
<p>实例：</p>
<p><img src="/2023/10/06/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/image-20231012114350599.png" alt="image-20231012114350599"></p>
</li>
<li><p>半双工模式【同一时刻只能进行发or收】使用集线器，全双工模式【发or收可以并行】使用交换机。半双工模式需要进行载波监听碰撞检测。</p>
</li>
<li><p>服务器的操作系统具备和路由器相同的包转发功能，当打开这一功能时，它就可以像路由器一样对包进行转发。在这种情况下，当收到不是发给自己的包的时候，就会像路由器一样执行包转发操作。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次vm扩容</title>
    <url>/2023/09/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1vm%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>容量寄，但是<code>df -h</code>发现这次好像是不大一样的：</p>
<p><img src="/2023/09/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1vm%E6%89%A9%E5%AE%B9/image-20230927191332920.png" alt="image-20230927191332920"></p>
<p>查了一下，原来这是逻辑卷管理（LVM，Logical Volume Manger）。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/darkpool/p/17457396.html">参考</a></p>
<p>实现将多个硬盘和硬盘分区做成一个逻辑卷，并将逻辑卷统一管理。创建LVM顺序为：物理卷PV-&gt;卷组VG-&gt;逻辑卷LV。<br>物理卷（PV，Physical Volume）：物理硬盘或分区；<br>卷组（VG，Volume Group）：一个或多个物理卷集合；<br>逻辑卷（Logical Volume）：供系统使用的元设备，虚拟分区。</p>
<p>LVM常用的命令：</p>
<table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">PV物理卷管理</th>
<th align="center">VG卷组管理</th>
<th align="center">LV逻辑卷管理</th>
</tr>
</thead>
<tbody><tr>
<td align="center">扫描</td>
<td align="center">pvscan</td>
<td align="center">vgscan</td>
<td align="center">lvscan</td>
</tr>
<tr>
<td align="center">创建</td>
<td align="center">pvcreate</td>
<td align="center">vgcreate</td>
<td align="center">lvcreate</td>
</tr>
<tr>
<td align="center">查看</td>
<td align="center">pvdisplay</td>
<td align="center">vgdisplay</td>
<td align="center">lvdisplay</td>
</tr>
<tr>
<td align="center">删除</td>
<td align="center">pvremove</td>
<td align="center">vgremove</td>
<td align="center">lvremove</td>
</tr>
<tr>
<td align="center">扩展</td>
<td align="center">/</td>
<td align="center">vgextend</td>
<td align="center">lvextend</td>
</tr>
<tr>
<td align="center">缩容</td>
<td align="center">/</td>
<td align="center">vgreduce</td>
<td align="center">lvreduce</td>
</tr>
</tbody></table>
</blockquote>
<p>接下来简要介绍其扩容步骤。</p>
<ol>
<li><p>在vmware中扩展磁盘容量</p>
<p><img src="/2023/09/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1vm%E6%89%A9%E5%AE%B9/image-20230927191636392.png" alt="image-20230927191636392"></p>
</li>
<li><p><code>sudo fdisk /dev/sda</code>，进行磁盘分区</p>
<p>在fdisk中输入n，新建sda4分区，然后w保存。</p>
</li>
<li><p>执行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pvcreate /dev/sda4</span><br><span class="line">sudo vgcreate ubuntu-vg /dev/sda4</span><br><span class="line">sudo vgextend ubuntu-vg /dev/sda4</span><br><span class="line">sudo vgdisplay <span class="comment"># 此时应发现FREE变成了100G</span></span><br><span class="line">sudo lvresize -l  +100%FREE /dev/mapper/ubuntu--vg-ubuntu--lv</span><br><span class="line">sudo resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv</span><br><span class="line">sudo <span class="built_in">df</span> -h <span class="comment"># 验证成功</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>一开始按照的<a href="https://blog.csdn.net/Edwinwzy/article/details/130614205">这个</a>，然后被坑惨了（悲）把lvm sig给抹了，导致之后resize2fs的时候报错，然后之后又不小心重启了，最后的最后只能重装。。。又是一晚上配环境。。。。</p>
]]></content>
  </entry>
  <entry>
    <title>课程学习</title>
    <url>/2023/06/21/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>卷学分绩的过程中，从应试的角度学习这些基础课，也给我带来了不少收获。因而，我选择将课内复习的笔记包含在这里，并且除去一些非必要的糟粕，仅保留最精华的部分，以供以后学习参考使用。</p>
<p><strong>点击每个标题超链接，可进入分文章进行查看。</strong></p>
<h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a><a href="/2023/06/21/comporgan">计算机组成原理</a></h3><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a><a href="/2023/11/18/compilation_principle">编译原理</a></h3><p>yysy，感觉编译原理这门课应该能算大三学了之后收获最大的专业课。理论课从形式化的原理出发，讲述了编译器的构成：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成。实验课又实现了一个简单的具有基本功能的编译器。这二者相辅相成，学完这门课之后真的对编译系统的构造有了一个较为全面的了解。</p>
<ol>
<li><p>词法分析</p>
<p>词法分析对源程序进行分析，提取出标识符和关键字等符号，形成token list（token：&lt;值, 种别码&gt;）。</p>
<p>词法分析事实上就是构造一个有穷自动机，来识别标识符相关的正则表达式：</p>
<img src="/2023/06/21/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/image-20231118221309891.png" alt="image-20231118221309891" style="zoom:50%;">

<p>最后相当于把一个具体的符号用一个种别码来标识，以供之后的语法分析来使用。</p>
<p>比如说，”a” “abc” “a123”都是标识符，但是它们在语法分析中（例如下面这个文法）都统一被称为”id“。我们的词法分析的作用就是生成&lt;a, id&gt; &lt;abc, id&gt; &lt;a123, id&gt;这样的token。这样，语法分析就无需关注原程序这些抽象的符号是什么意思，只需根据种别码表示下这个是个标识符就差不多得了。</p>
</li>
<li><p>语法分析</p>
<p>语法分析的输入是词法分析的token list。它通过自顶向下/自底向上两种分析方法，根据给定的上下文无关文法来进行语法分析，主要用于纠出静态语法错误和语法制导翻译。</p>
<p>在实验中，我们使用自底向上的LR(1)文法来进行语法分析。我们通过软件编译工作台，将给定的上下文无关文法转化为了LR分析表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P -&gt; S_list;</span><br><span class="line">S_list -&gt; S Semicolon S_list;</span><br><span class="line">S_list -&gt; S Semicolon;</span><br><span class="line">S -&gt; D id;</span><br><span class="line">D -&gt; <span class="type">int</span>;</span><br><span class="line">S -&gt; id = E;</span><br><span class="line">S -&gt; <span class="keyword">return</span> E;</span><br><span class="line">E -&gt; E + A;</span><br><span class="line">E -&gt; E - A;</span><br><span class="line">E -&gt; A;</span><br><span class="line">A -&gt; A * B;</span><br><span class="line">A -&gt; B;</span><br><span class="line">B -&gt; ( E );</span><br><span class="line">B -&gt; id;</span><br><span class="line">B -&gt; IntConst;</span><br></pre></td></tr></table></figure>

<p>然后，只需在代码中根据分析表和当前输入的token进行移入或者归约即可。</p>
</li>
<li><p>语义分析/中间代码生成</p>
<p>语义分析和中间代码生成一般都是依靠SDT（语法制导翻译）来完成的。它通过在语法分析过程中按照一定次序执行一系列与产生式关联的语义规则，计算符号的属性，完成副作用，来进行语义分析和中间代码生成。</p>
<p>感觉这一步也算是编译器实现的一大精髓。别看它定义如此简单，但实际上占据了很多重要部分，比如说符号表的填写、各种类型中间代码的生成（包括复杂的布尔表达式回填技术，这个就需要在代码中多设计些复杂数据结构了）。</p>
<p>在实验中，我们仅实现了最精简的语义分析和中间代码生成，也即只对声明语句和简单赋值语句做处理。并且，实验架构采用了观察者模式，也即语法分析进行移入和归约后，会通知作为观察者的语义分析器和中间代码生成器。</p>
<p>由于我们使用的是S-SDD+LR(1)，因此只需在移进时将对应的属性也一同进栈，然后在归约时执行对应的语义动作（如填入符号表、根据产生式生成一条中间代码）即可。</p>
</li>
<li><p>运行时存储</p>
<p>除了上述编译器组成原理之外，还涉及了一些运行时栈帧内分布及调用序列返回序列对应的中间代码生成。它主要以过程嵌套函数和非过程嵌套函数两种分类，讲述了这两类语言对应的栈帧结构是怎么样的。</p>
<p>非过程嵌套语言，如C语言，不允许一个过程中声明另一个过程。在这种情况下，栈帧构成较为简单，只需存放听得耳朵出茧子的什么形参、ra之类的东西。</p>
<p>过程嵌套语言，如pascal，如我觉得别的什么java c++之类的应该也都支持，允许在一个过程中声明另一个过程。在这种情况下，为了记录过程嵌套关系，就绪引入静态链（访问链）和动态链（控制链）。静态链指向的是当前过程声明所在的那层，动态链指向的是调用该过程的那一层。有了这俩东西，我们就可以在一个过程中沿着这两个链访问另一嵌套深度过程中的变量了（而且只能里面访问外面，所以一般不会有自外向内的链。。。）。</p>
<p>但是，这样的链式访问必定会导致寻址时的效率低下，所以我们引入了Display表。</p>
<p><img src="/2023/06/21/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/image-20231118230609720.png" alt="image-20231118230609720"></p>
<p>相当于比如说以前想要访问父父过程，需要两次链式访问，但是通过display表就只需要一次，极大优化了嵌套深度大的情况。</p>
</li>
</ol>
<h3 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a><a href="/2023/11/26/cryptography">密码学基础</a></h3><p>纯纯觉得ppt写得好。通识这一方面做得很不错。</p>
<h3 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a><a href="/2023/11/26/database">数据库原理</a></h3><p>大概算是自顶向下地，从sql语句（以及相应的关系代数实现）、数据库核心技术（索引实现、查询实现/优化、事务处理、安全性与完整性、故障恢复）、与磁盘的交互（数据库存储、缓冲区策略）这几个方面全方位介绍了数据库的实现思路。</p>
<p>sql语句和关系代数在此就不做赘述。</p>
<ol>
<li><p>概述</p>
<p>收获最大还是了解了下网状/层次模型。我记得有说过现在好像有一些非关系模型也开始火了，感觉也算是比较前沿的方向。</p>
</li>
<li><p>索引实现</p>
<p>主要介绍了稠密索引、稀疏索引、主索引、聚簇索引、辅助索引等这几类索引。它们都可以用b+树来实现性能更好的多级索引。还介绍了动态散列索引，通过线性增长和溢出桶实现。</p>
</li>
<li><p>查询实现和优化</p>
<p>关系代数的各种操作的实现算法主要有一趟扫描、迭代器、两趟扫描等。</p>
<p>优化和代价估算的算法也不做赘述了。</p>
</li>
<li><p>事务处理</p>
<p>主要介绍了三种常见的并发控制方法：封锁协议、时间戳、有效性检测。感觉现实中应该主要还是用的封锁协议吧。冲突可串行性这个理论也是很有意思。</p>
<p>【这里需要注意的是，这三种就是具体的事务调度方法（特别是封锁协议），而不是说先进行事务调度再通过这三个实现事务……】</p>
</li>
<li><p>安全性与完整性</p>
<p>主要通过静态约束和动态约束（trigger）来保障数据库的完整性。第一次知道trigger可以被视为约束，感觉这个角度也蛮酷。</p>
<p>保障安全性有两种常见措施，一个就是我们在实践中也做了很多的授权机制，如grant、revoke之类的；另一个就是感觉比较罕见的那个什么表了。</p>
</li>
<li><p>故障恢复</p>
<p>主要介绍了不同缓冲区策略对应的三种日志类型，看了也是让人收获颇深。</p>
<p>复习过程中有个疑惑，也即Undo/Redo型日志的恢复顺序，似乎是因数据库实现而异。在mysql中，是先执行的redo log，再执行的undo log。</p>
</li>
<li><p>数据库存储</p>
<p>主要介绍了文件的几种组织方式，如堆文件、有序文件、散列、聚簇等。</p>
</li>
<li><p>实验</p>
<p>前两次实验就是写写sql没啥好说的。最后两次实验，一个是挣扎前端，另一个就比较有意思了，聚焦于关系代数几个操作的实现，有点像写了一个mini的数据库引擎。</p>
</li>
</ol>
<h3 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a><a href="/2024/01/04/arch">计算机体系结构</a></h3><p>我校的arch课感觉有点怪怪的，该讲的地方一笔带过默认你会（比如除去并行体系结构之外的其它体系结构我怎么感觉也是很值得一讲的，相当于扩展一下计组内容），不该涵盖的地方（指完全可以另开一门课的AI体系结构）又写了一大堆又很简略，导致最后好像深度广度都没有，所以之后还是得多看看书培养一下。总之，还是在这里记录一下应试过程中我学到了什么吧。</p>
<ol>
<li><p>现代处理器体系结构</p>
<p>大概是讲了现代处理器为了实现指令级并行会遇到的一些问题和对应的处理方法。</p>
<p>一些<strong>指令之间的相关关系</strong>可能会导致无法并行执行or有结果不正确的风险，如数据相关（无法并行）、名相关（风险，输出相关和反相关）以及控制相关（通过<strong>前瞻执行</strong>解决），这些相关关系就会造成几种<strong>数据冲突</strong>，RAW（数据相关）、WAW（输出相关）、WAR（反相关）。</p>
<p>为了提高并行度，我们引入了<strong>流水线</strong>、<strong>多流出</strong>（超标量技术和VLIW技术），而前者会导致RAW，后者会导致WAW和WAR（因为引入了乱序执行，导致某些指令读写操作滞后/推前），导致执行错误或者并发度太小。</p>
<p>为了解决这样的问题，我们就需要引入<strong>指令调度算法</strong>。指令调度算法可以分为编译器静态调度和硬件实时动态调度。后者又有记分牌、Tomaluso算法等常见调度算法，它们分别划为4 or 3级流水，在特定的阶段结合硬件做一些事情（比如说<strong>乱序执行</strong>、<strong>暂停</strong>、<strong>寄存器换名</strong>等措施）来解决这些冲突问题。</p>
<p>同时，除了通过指令调度算法，我们还可以通过<strong>软流水</strong>、<strong>循环展开</strong>来提高并发度。</p>
</li>
<li><p>AI体系结构</p>
<p>首先大概是说了SISD、SIMD、MIMD这几种并行体系结构分类都是什么，本章主角自然是MD了。</p>
<p>然后又简单介绍了GPU的体系结构，比如说它可以分为SM（流多处理器）和显存（层次结构），还有一些CUDA编程的基本概念，比如kernel、线程相关（Thread、Wrap、Block、Grid）之类的，其中Wrap是最小调度单位，也即Wrap内所有线程执行同一代码。</p>
<p>然后还讲了下具体的性能优化，比如访存优化（Stream、避免bank冲突增加padding）等等等。</p>
<p>最后简单介绍了目前的典型DL框架PyTorch。</p>
</li>
<li><p>自动驾驶体系结构</p>
<p>写得依托，懒得说了。</p>
</li>
</ol>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><a href="/2023/12/26/operating-system">操作系统</a></h3><h3 id="网络与系统安全"><a href="#网络与系统安全" class="headerlink" title="网络与系统安全"></a><a href="/2024/06/15/network_system_security">网络与系统安全</a></h3><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><a href="/2024/06/21/computer_network_course">计算机网络</a></h3><h3 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a><a href="/2024/07/05/csapp">计算机系统</a></h3>]]></content>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title>福州</title>
    <url>/2024/03/02/travel/fuzhou/</url>
    <content><![CDATA[<h3 id="住行"><a href="#住行" class="headerlink" title="住行"></a>住行</h3><ul>
<li>酒店名称：哥仑步酒店（达道地铁站上下杭店）</li>
<li>优缺点：<ul>
<li>优点<ol>
<li>交通方便。一号线地铁站过个马路就行，附近有达道公交车站</li>
<li>周边繁荣。有诸如图中写的特色美食，夜晚安全点；离上下杭很近（步行约700米）</li>
<li>性价比高。房间很大很大，床也很大，双床房250一晚，服务挺到位</li>
</ol>
</li>
<li>缺点<ol>
<li>离奥体远。如果此行是需要看演唱会，而且地铁不会延期运行的话，不推荐。因为奥体到这需要经过5号线2号线1号线，我记得其中有一个线路演唱会期间是不会延期的，所以可能会坐不上。。。</li>
<li>酒店不在一楼，可能有人觉得不安全？我个人觉得还好</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="/2024/03/02/travel/fuzhou/Screenshot_20240303_165056_com.baidu.BaiduMap.jpg" alt="Screenshot_20240303_165056_com.baidu.BaiduMap"></p>
<h3 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h3><ul>
<li><p>鱼丸（连江青鳗）</p>
<p>十块钱五个，个人感觉确实稍微比市场上好吃点但没那么惊艳</p>
</li>
<li><p>福鼎肉片（吴记煎包）</p>
<p>虽然不是福州美食但感觉挺近的（？）至少比深圳的正宗，好吃</p>
</li>
<li><p>煎包（吴记煎包）</p>
<p>挺香的味道不错，可惜吃完一个就有点腻了，值得一试</p>
</li>
<li><p>肉燕（郑森记）</p>
<p>个人感觉一般般，不如馄饨，肥肉感太重了吃着有点想yue</p>
</li>
<li><p>鲟饭（学军盛记）</p>
<p>螃蟹挺大一只，相当于是糯米饭+胡萝卜丝+香菇+螃蟹，看喜不喜欢吃糯米饭了</p>
</li>
<li><p>糟鱼（学军盛记）</p>
<p>感觉酒味重重，不大喜欢这个味道</p>
</li>
</ul>
<h3 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h3><ul>
<li><p>上下杭</p>
<p>感觉就一般步行街水平，能逛的展览挺少的，景色不上不下5分。里面有尚书庙还挺有意思</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>链接、装载与运行库</title>
    <url>/2023/09/18/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<blockquote>
<p>此为<a href="https://xiunianjun.github.io/2023/09/18/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%20(%E4%BF%9E%E7%94%B2%E5%AD%90%2C%E7%9F%B3%E5%87%A1%2C%E6%BD%98%E7%88%B1%E6%B0%91)%20(Z-Library).pdf">《程序员的自我修养：链接、装载与库》(俞甲子,石凡,潘爱民)</a>的看书总结。</p>
</blockquote>
<h1 id="链接前与装载"><a href="#链接前与装载" class="headerlink" title="链接前与装载"></a>链接前与装载</h1><p>链接前的编译阶段可以生成.o文件，.o文件是ELF文件，里面含有段表、符号表、bss段、common段等链接辅助段。</p>
<p>执行可执行文件时，首先要通过fork创建一个新的子进程，然后要通过exec为子进程制定可执行文件装载逻辑。在exec系统调用中，会进行elf文件的读取解析。它会解析elf header，根据其各种信息将程序copy到内存（进程的虚拟地址空间）中，后者也就是我们所研究的装载。</p>
<p>装载不同于“节（section），是以”<strong>段</strong>“（segment）为单位。进程虚拟地址空间被分为很多个VMA，每个VMA都有不同的属性（如权限，可读可写可执行）。ELF可执行文件除去在链接/编译过程中被视为一个个连续的节之外，它还会在链接的时候根据每个节的属性不同重排节，把属性相同的节连续放在一起成为一个个段。链接的时候还会形成程序头表。对应关系：节——段表，段——程序头表</p>
<p>装载进内存时，是以段为单位，一个段就对应着一个VMA。</p>
<p>内核通过<code>execve</code>系统调用装载完ELF可执行文件以后就返回到用户空间，将控制权交给程序的入口。</p>
<p>对于不同链接形式的ELF可执行文件，这个程序的入口是有区别的。对于静态链接的可执行文件来说，程序的入口就是ELF文件头里面的<strong>e_entry指定的入口地址</strong>；对于动态链接的可执行文件来说，如果这时候把控制权交给e_entry指定的入口地址，那么肯定是不行的，因为可执行文件所依赖的共享库还没有被装载，也没有进行动态链接。所以对于动态链接的可执行文件，内核会分析它的动态链接器地址（在“.interp”段），将动态链接器映射至进程地址空间，然后把控制权交给<strong>动态链接器</strong>。</p>
<h2 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h2><p>编译器编译源代码后生成的文件叫做目标文件（Object文件），目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。其实它本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。</p>
<p>Linux的可执行文件遵从ELF的结构模式。</p>
<p>ELF可以分为这几类：</p>
<p><img src="/2023/09/18/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/image-20230913084511590.png" alt="image-20230913084511590"></p>
<p>也即.o（可重定位文件）、.exe(无后缀)（可执行文件）、.so（动态链接库）、.a（静态链接库）、core dump。</p>
<h3 id="Object文件的结构"><a href="#Object文件的结构" class="headerlink" title="Object文件的结构"></a>Object文件的结构</h3><p>目标文件中的内容至少有编译后的机器指令代码、数据。没错，除了这些内容以外，目标文件中还包括了链接时所须要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以“节”（Section）的形式存储，有时候也叫“<strong>段</strong>”（Segment）。</p>
<p><img src="/2023/09/18/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/image-20230918100932220.png" alt="image-20230918100932220"></p>
<h3 id="符号修饰"><a href="#符号修饰" class="headerlink" title="符号修饰"></a>符号修饰</h3><p>众所周知，强大而又复杂的C++拥有类、继承、虚机制、重载、名称空间等这些特性，它们使得符号管理更为复杂。最简单的例子，两个相同名字的函数func(int)和func(double)，尽管函数名相同，但是参数列表不同，这是C++里面函数重载的最简单的一种情况，那么编译器和链接器在链接过程中如何区分这两个函数呢？为了支持C++这些复杂的特性，⼈们发明了符号修饰（Name Decoration）或符号改编（Name Mangling）的机制。</p>
<p><img src="/2023/09/18/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/image-20230913090407013.png" alt="image-20230913090407013"></p>
<p>C++为了与C兼容，在符号的管理上，C++有一个用来声明或定义一个C的符号的“extern “C””关键字用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> ”C” &#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++编译器会将在extern “C” 的大括号内部的代码当作C语言代码处理。所以很明显，上面的代码中，C++的名称修饰机制将不会起作用。</p>
<h3 id="强符号和弱符号"><a href="#强符号和弱符号" class="headerlink" title="强符号和弱符号"></a>强符号和弱符号</h3><p>多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候将会出现符号重复定义的错误。这种符号的定义可以被称为<strong>强符号</strong>（Strong Symbol）。有些符号的定义可以被称为<strong>弱符号</strong>（Weak Symbol）。对于C/C++语言来说，编译器默认<u>函数和初始化了的全局变量</u>为强符号，<u>未初始化的全局变量</u>为弱符号。我们也可以通过GCC的<code>__attribute__((weak))</code>来定义任何一个强符号为弱符号。</p>
<p><img src="/2023/09/18/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/image-20230913090719480.png" alt="image-20230913090719480"></p>
<p>目前我们所看到的对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，它们须要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种被称为<strong>强引用</strong>（Strong Reference）。与之相对应还有一种<strong>弱引用</strong>（Weak Reference），在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器对于该引用不报错。</p>
<p>链接器处理强引用和弱引用的过程几乎一样，只是对于未定义的弱引用，链接器不认为它是一个错误。一般对于未定义的弱引用，链接器默认其为0，或者是一个特殊的值，以便于程序代码能够识别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__attribute__ ((weakref)) <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(foo) <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种弱符号和弱引用对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强符号所覆盖，从而使得程序可以使用自定义版本的库函数。</p>
<blockquote>
<p>这里很帅，有条件编译那味了</p>
</blockquote>
<p>在Linux程序的设计中，如果一个程序被设计成可以支持单线程或多线程的模式，就可以通过弱引用的方法来判断当前的程序是链接到了单线程的Glibc库还是多线程的Glibc库（是否在编译时有-lpthread选项），从而执行单线程版本的程序或多线程版本的程序。我们可以在程序中定义一个pthread_create函数的弱引用，然后程序在运行时动态判断是否链接到pthread库从而决定执行多线程版本还是单线程版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span>*, <span class="type">const</span> <span class="type">pthread_attr_t</span>*, <span class="type">void</span>* (*)(<span class="type">void</span>*), </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>*)</span> __<span class="title">attribute__</span> <span class="params">((weak))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is multi-thread</span></span><br><span class="line"><span class="string">        version!\n&quot;</span>);</span><br><span class="line">        <span class="comment">// run the multi-thread version</span></span><br><span class="line">        <span class="comment">// main_multi_thread()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is single-thread</span></span><br><span class="line"><span class="string">        version!\n&quot;</span>); </span><br><span class="line">        <span class="comment">// run the single-thread version</span></span><br><span class="line">        <span class="comment">// main_single_thread()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>弱符号大概是说该变量可以被定义多次，最终链接时再进行决议；弱引用大概是说该变量（函数）可以不被定义。</p>
</blockquote>
<h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>静态链接库（.a文件）本质上是一堆.o文件的集合。静态链接的基本过程：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">test<span class="selector-class">.c</span> ——(compile)——&gt;test<span class="selector-class">.o</span>——(link)——&gt;<span class="built_in">test</span>(ELF exe)</span><br><span class="line">				  	   			↑</span><br><span class="line">                  			  lib<span class="selector-class">.a</span></span><br></pre></td></tr></table></figure>

<p>静态链接其实也就是分为两大步骤：</p>
<ol>
<li><p>空间与地址分配</p>
<p>将input file的各个段都连在一起，并且为符号分配虚拟地址</p>
</li>
<li><p>符号解析与重定位</p>
<ol>
<li><p>扫描所有输入文件的符号表形成全局符号表；</p>
</li>
<li><p>重定向</p>
<p>可执行文件基本可以确定自己在进程虚拟空间中的起始位置，因为可执行文件往往是第一个被加载的文件，它可以选择一个固定空闲的地址。因而，在link中，可执行文件的地址都以确定，就可以开始进行重定向。</p>
<p>通过重定向表对所有UNDEF的符号进行地址修正，包括相对地址修正和绝对地址修正。</p>
</li>
</ol>
</li>
</ol>
<p>在link中，会读取<code>test.o</code>以及<code>lib.a</code>中的符号表，完成重定向（绝对地址和相对地址）以及节的重排组织，最终组合形成以段为单位的可执行文件<code>test</code>。</p>
<p>可执行文件<code>test</code>会通过系统调用<code>exevec</code>被装载进物理内存（lazy allocation），分段映射到进程的虚拟地址空间。</p>
<p>静态链接的缺陷是，由于重定向在link过程完成，故而同一份共享库在物理内存中会有多份copy，极大占用物理内存和磁盘空间。优点是速度快。</p>
<h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>（下文注意区分两个概念：可执行文件和动态链接库）</p>
<p>动态链接库（.so）不同于静态链接库。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">test<span class="selector-class">.c</span> ——(compile)——&gt;test<span class="selector-class">.o</span>——(link)——&gt;<span class="built_in">test</span>(ELF exe)</span><br><span class="line">				  	   			↑</span><br><span class="line">                  			  lib<span class="selector-class">.so</span></span><br></pre></td></tr></table></figure>

<p>在link中，仅会读入动态链接库的符号表，对于动态链接库的符号仅会将其标记为动态符号，而不会对其进行重定向。</p>
<p>可执行文件<code>test</code>会通过系统调用<code>exevec</code>被装载进物理内存（lazy allocation），分段映射到进程的虚拟地址空间。</p>
<p>静态链接是per-process一份库，内存中有多份库；动态链接是per-process一份库，内存也只有一份库。并且虚拟地址动态分配，也即库映射到进程地址空间的哪块VMA是不确定的。</p>
<p>由于动态链接库被装载时的虚拟地址不确定，所以对于动态链接库和可执行文件代码中与动态链接相关的绝对地址，不能简单采用装载时重定向的方法来对其重定向，否则会破坏其共享性和不变性。</p>
<blockquote>
<p>试想一下，每个进程加载的动态链接库的地址都不同，那岂不是每个进程的动态链接库的重定向结果都不一样，指令都不一样，不就寄了。</p>
</blockquote>
<p>所以我们此时进行了一个<strong>牛逼到家、惊天动地、无人能比</strong>的操作。</p>
<p>我们可以分离.text和.data，前者作为“共享”语义保持不变性，后者则在每个进程地址空间中都留存一个copy。然后，我们将所有立即数绝对寻址的地方，换为间接寻址！也即，把那个立即数绝对地址改成一个变量，变量值在.data段中存储。这样一来，就<strong>成功把绝对寻址替换成了相对寻址</strong>。加载的时候也只需将虚拟地址填进可变的.data就行。不得不说真是十分地巧妙。</p>
<p>这个从相对地址——绝对地址的转换过程，由ELF中的一个新段GOT表（.got）来实现。在link时加入了动态链接库符号表的可执行文件，以及动态链接库本身，都使用了.got段，以PIC形式出现。</p>
<p>这个操作就是所谓的“<strong>地址无关代码</strong>”，通过<code>-fPIC</code>选项，就可以将代码编译为一个地址无关的程序。使用PIC模式编译的共享对象，对于模块内部的函数调用也是采用跟模块外部函数调用一样的方式，即使用GOT/PLT的方式。</p>
<blockquote>
<p>小trick：如何区分一个DSO是否为PIC</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">readelf -d foo.so | grep TEXTREL</span><br></pre></td></tr></table></figure>

<p>如果上面的命令有任何输出，那么foo.so就不是PIC的，否则就是PIC的。PIC的DSO是不会包含任何代码段重定位表的，TEXTREL表⽰代码段重定位表地址。</p>
<p>这也很好理解，因为PIC本质上就是<u>把代码段重定位转化为了数据段重定位</u>。</p>
</blockquote>
<p>除了动态链接库中的寻址（对变量和函数）需要使用PIC之外，对可执行文件的全局变量也需要使用特殊的机制。ELF共享库中的全局变量都<strong>类似</strong>以弱引用形式存在。当全局变量在主程序extern时，若该变量在共享库中初始化了，那么加载之后要把共享库的数据copy进主程序；否则，该变量值都以主模块为准。</p>
<blockquote>
<p>这段原因解释看书真没懂，详情340页开始。</p>
<p>不过感觉它可能说的有点问题，我个人认为全局变量需要使用这种以方式存在，是为了保证进程资源独立。如果变量都以共享库中的数据值为准，那各个进程共享共享库不就乱了。。。你改一下我改一下</p>
</blockquote>
<p>因而，总的装载流程是：</p>
<p><strong>未优化情况下</strong>，在可执行文件被装载之前，先将其依赖的所有动态链接库加载进内存。若其所需的动态链接库已经被映射到物理内存，则将其装载到进程虚拟地址空间；否则，则映射到物理内存，并且装载到进程虚拟地址空间。然后，在装载动态链接库后，扫描可执行文件.got段符号进行装载时重定向（依据已经装载了的动态链接库虚拟地址来计算符号地址）即可。</p>
<p>但可以注意到这一步还是有优化空间。所以我们采取<strong>延迟绑定</strong>（PLT）的方法，第一次访问到动态链接库符号时，才对其进行重定向并填入.got中。</p>
<p>动态链接的缺点就是太慢了，一是因为PIC导致模块内部函数和全局变量也需要以.got形式访问，加了层寻址；二是运行时重定向开销巨大。对于前者，模块内部函数可以使用static关键字修饰；对于后者，采用PLT。</p>
<p><img src="/2023/09/18/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/image-20230913231031432.png" alt="image-20230913231031432"></p>
<h1 id="显式运行时链接"><a href="#显式运行时链接" class="headerlink" title="显式运行时链接"></a>显式运行时链接</h1><p>支持动态链接的系统往往都支持一种更加灵活的模块加载方式，叫做显式运行时链接（Explicit Runtime Linking），有时候也叫做运行时加载。也就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载。</p>
<blockquote>
<p>也就是说，前面介绍的动态链接库是由动态链接器自动完成的，程序啥也不知道；这里的动态装载库是程序自己控制的，所以会提供给程序各种API。</p>
</blockquote>
<p>而动态库的装载则是通过一系列由动态链接器提供的API，具体地讲共有4个函数：打开动态库（<code>dlopen</code>）、查找符号（<code>dlsym</code>）、错误处理（<code>dlerror</code>）以及关闭动态库（<code>dlclose</code>），程序可以通过这几个API对动态库进行操作。这几个API的实现是在<code>/lib/libdl.so.2</code>里面，它们的声明和相关常量被定义在系统标准头文件<code>&lt;dlfcn.h&gt;</code>。</p>
<blockquote>
<p>很有意思的是，如果我们将filename这个参数设置为0，那么dlopen返回的将是全局符号表的句柄，也就是说我们可以在运行时找到全局符号表里面的任何一个符号，并且可以执行它们，这有些类似高级语言<strong>反射</strong>（Reflection）的特性。全局符号表包括了程序的可执行文件本身、被动态链接器加载到进程中的所有共享模块以及在运行时通过dlopen打开并且使用了RTLD_GLOBAL方式的模块中的符号。</p>
</blockquote>
<p>它接下来举的例子很有意思，可惜不知道为啥在我这一直segment fault。。。好像是它用的内联汇编是32位什么的，我折腾了半天还是没办法，算了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们这个例子中将实现一个更为灵活的叫做runso的程序，这个程序可以通过命令行来执行共享对象里面的任意一个函数。</span></span><br><span class="line"><span class="comment">它在理论上很简单，基本的步骤就是：由命令行给出共享对象路径、函数名和相关参数，然后程序通过运行时加载将该模块加载</span></span><br><span class="line"><span class="comment">到进程中，查找相应的函数，并且执行它，然后将执行结果打印出来。</span></span><br><span class="line"><span class="comment">为了表示参数和返回值类型，我们假设字母d表示double、i表示int、s表示char*、v表示void</span></span><br><span class="line"><span class="comment">比如说，如果要调用/lib/libfoo.so里面一个void bar(char* str, int i)的函数，可以使用如下命令行：</span></span><br><span class="line"><span class="comment">$./RunSo /lib/libfoo.so bar sHello i10 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大概就是根据参数类型把参数压入栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETUP_STACK \</span></span><br><span class="line"><span class="meta">i = 2; \</span></span><br><span class="line"><span class="meta">while (++i &lt; argc - 1) &#123; \</span></span><br><span class="line"><span class="meta"> switch(argv[i][0]) &#123; \</span></span><br><span class="line"><span class="meta">    case <span class="string">&#x27;i&#x27;</span>: \</span></span><br><span class="line"><span class="meta">        int res = atoi(&amp;argv[i][1]); \</span></span><br><span class="line"><span class="meta">        asm volatile(<span class="string">&quot;.code32\n&quot;</span> \</span></span><br><span class="line"><span class="meta">            <span class="string">&quot;push %0&quot;</span> :: \</span></span><br><span class="line"><span class="meta">            <span class="string">&quot;r&quot;</span>(res )); \</span></span><br><span class="line"><span class="meta">        asm volatile(<span class="string">&quot;.code64\n&quot;</span>); \</span></span><br><span class="line"><span class="meta">        esp += 4; \</span></span><br><span class="line"><span class="meta">        break; \</span></span><br><span class="line"><span class="meta">    case <span class="string">&#x27;d&#x27;</span>: \</span></span><br><span class="line"><span class="meta">        atof(&amp;argv[i][1]); \</span></span><br><span class="line"><span class="meta">        asm volatile(<span class="string">&quot;subl $8,%esp\n&quot;</span> \</span></span><br><span class="line"><span class="meta">            <span class="string">&quot;fstpl (%esp)&quot;</span> ); \</span></span><br><span class="line"><span class="meta">        esp += 8; \</span></span><br><span class="line"><span class="meta">        break; \</span></span><br><span class="line"><span class="meta">    case <span class="string">&#x27;s&#x27;</span>: \</span></span><br><span class="line"><span class="meta">        asm volatile(<span class="string">&quot;push %0&quot;</span> :: \</span></span><br><span class="line"><span class="meta">            <span class="string">&quot;r&quot;</span>(&amp;argv[i][1]) ); \</span></span><br><span class="line"><span class="meta">        esp += 4; \</span></span><br><span class="line"><span class="meta">        break; \</span></span><br><span class="line"><span class="meta">    default: \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;error argument type&quot;</span>); \</span></span><br><span class="line"><span class="meta">        goto exit_runso; \</span></span><br><span class="line"><span class="meta"> &#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大概就是相当于pop，给esp加上我们之前申请的栈空间esp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESTORE_STACK \</span></span><br><span class="line"><span class="meta">asm volatile(<span class="string">&quot;add %0,%%esp&quot;</span>::<span class="string">&quot;r&quot;</span>(esp))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* handle;</span><br><span class="line">    <span class="type">char</span>* error;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> esp = <span class="number">0</span>; </span><br><span class="line">    <span class="type">void</span>* func;</span><br><span class="line"></span><br><span class="line">    handle = dlopen(argv[<span class="number">1</span>], RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span>(handle == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t find library: %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func = dlsym(handle, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>( (error = dlerror()) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Find symbol %s error: %s\n&quot;</span>, argv[<span class="number">2</span>], error);</span><br><span class="line">        <span class="keyword">goto</span> exit_runso;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据返回值不同构造函数指针</span></span><br><span class="line">    <span class="keyword">switch</span>(argv[argc<span class="number">-1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> (*func_int)() = func;</span><br><span class="line">            SETUP_STACK;</span><br><span class="line">            <span class="type">int</span> ret = func_int();</span><br><span class="line">            RESTORE_STACK;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> (*func_double)() = func;</span><br><span class="line">            SETUP_STACK;</span><br><span class="line">            <span class="type">double</span> ret = func_double();</span><br><span class="line">            RESTORE_STACK;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ret = %f\n&quot;</span>, ret );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* (*func_str)() = func;</span><br><span class="line">            SETUP_STACK;</span><br><span class="line">            <span class="type">char</span>* ret = func_str();</span><br><span class="line">            RESTORE_STACK;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ret = %s\n&quot;</span>, ret );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="type">void</span> (*func_void)() = func;</span><br><span class="line">            SETUP_STACK;</span><br><span class="line">            func_void();</span><br><span class="line">            RESTORE_STACK;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ret = void&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end of switch</span></span><br><span class="line"></span><br><span class="line">exit_runso:</span><br><span class="line">    dlclose(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="运行库"><a href="#运行库" class="headerlink" title="运行库"></a>运行库</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>操作系统装载程序之后，首先运行的代码并不是main的第一行，而是某些别的代码，这些代码负责准备好main函数执行所需要的环境，并且负责调用main函数，这时候你才可以在main函数里放心大胆地写各种代码：申请内存、使用系统调用、触发异常、访问I/O。在main返回之后，它会记录main函数的返回值，调用atexit注册的函数，然后结束进程。</p>
<p>运行这些代码的函数称为<strong>入口函数或入口点</strong>（Entry Point），视平台的不同而有不同的名字。程序的入口点实际上是一个程序的初始化和结束部分，它往往是<strong>运行库的一部分</strong>。</p>
<p>一个典型的程序运行步骤大致如下：</p>
<ol>
<li><p>操作系统在创建进程后，把控制权交到了程序的入口，这个入口往往是运行库中的某个入口函数。</p>
</li>
<li><p>入口函数对运行库和程序运行环境进行<strong>初始化</strong>，包括堆、I/O、线程、全局变量构造，等等。</p>
</li>
<li><p>入口函数在完成初始化之后，调用main函数，正式开始执行程序主体部分。</p>
</li>
<li><p>main函数执行完毕以后，返回到入口函数，入口函数进行清理⼯作，包括全局变量析构、堆销毁、关闭I/O等，然后进行系统调用结束进程。</p>
</li>
</ol>
<p>Linux中的C语言运行库就是<strong>glibc</strong>。</p>
<h2 id="运行库-1"><a href="#运行库-1" class="headerlink" title="运行库"></a>运行库</h2><p>运行时库（Runtime Library）为入口函数及其所依赖的函数所构成的函数、各种标准库函数的实现的集合。可以通过<code>sudo apt-get install glibc-source</code>安装glibc的源代码。</p>
<p>一个C语言运行库大致包含了如下功能：</p>
<ol>
<li><p>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</p>
</li>
<li><p>标准函数：由C语言标准规定的C语言标准库所拥有的函数实现。</p>
</li>
<li><p>I/O：I/O功能的封装和实现，参见上一节中I/O初始化部分。</p>
<p>应该指的是比如说提供File*指针、IO stream之类的高级功能封装。</p>
</li>
<li><p>堆：堆的封装和实现，参见上一节中堆初始化部分。</p>
<blockquote>
<p>这点让我耳目一新！因为我以前一直以为堆栈都是操作系统实现的，现在想来才发现确实，操作系统只负责通过sbrk系统调用给内存，具体的堆分配算法由glibc的malloc实现。</p>
</blockquote>
</li>
<li><p>语言实现：语言中一些特殊功能的实现。</p>
</li>
<li><p>调试：实现调试功能的代码。</p>
</li>
</ol>
<h3 id="库函数介绍"><a href="#库函数介绍" class="headerlink" title="库函数介绍"></a>库函数介绍</h3><p>它这里主要讲了两个比较特殊的库，还挺有意思的：变长参数（stdarg.h）和非局部跳转（setjmp.h）。</p>
<ol>
<li><p>变长参数</p>
<p>讲这玩意其实用作是printf的实现。看下下面这两个代码相信你就能明白printf的基本原理了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">unsigned</span> num, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span>* p = &amp;num + <span class="number">1</span>;</span><br><span class="line"> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (num--)</span><br><span class="line"> ret += *p++;</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call:</span><br><span class="line"><span class="type">int</span> n = sum(<span class="number">3</span>, <span class="number">16</span>, <span class="number">38</span>, <span class="number">53</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="comment">// Code 2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arg_match</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, ...)</span> &#123;</span><br><span class="line">        va_list ap; <span class="comment">// 本质char * / void *</span></span><br><span class="line">        va_start(ap, fmt); <span class="comment">// 之后ap就会指向fmt后的第一个可变参数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(fmt); i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fmt[i] != <span class="string">&#x27;%&#x27;</span>)      <span class="keyword">continue</span>;</span><br><span class="line">                idx ++;</span><br><span class="line">                <span class="keyword">switch</span> (fmt[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                                <span class="type">int</span> argv_i = va_arg(ap, <span class="type">int</span>);</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;第%d个参数为：%d\n&quot;</span>, idx, argv_i);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                                <span class="type">char</span>* argv_s = va_arg(ap, <span class="type">char</span>*);</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;第%d个参数为：%s\n&quot;</span>, idx, argv_s);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;unknown.\n&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call:</span><br><span class="line">arg_match(<span class="string">&quot;%d %d %s\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;333&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>除此之外，我们也可以实现<strong>变长参数宏</strong>：</p>
<p>在GCC编译器下，变长参数宏可以使用“##”宏字符串连接操作实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> printf(args…) fprintf(stdout, ##args)</span></span><br></pre></td></tr></table></figure></li>
<li><p>非局部跳转</p>
<p>这位更是重量级</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">jmp_buf b;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	longjmp(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (setjmp(b))</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上的输出是：</p>
<p>Hello World!</p>
<blockquote>
<p>实际上，当setjmp正常返回的时候，会返回0，因此会打印出“Hello”的字样。而longjmp的作用，就是让程序的执行流回到当初setjmp返回的时刻，并且返回由longjmp指定的返回值（longjmp的参数2），也就是1，自然接着会打印出“World！”并退出。换句话说，longjmp可以让程序“时光倒流”回setjmp返回的时刻，并改变其行为，以至于改变了未来。</p>
</blockquote>
</li>
</ol>
<h3 id="glibc"><a href="#glibc" class="headerlink" title="glibc"></a>glibc</h3><p>glibc是对标准C运行库的扩展（如增加了pthread），全称GNU C Library，是GNU旗下的C标准库。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>于是，我们可以完整串联整个运行程序的生命周期：</p>
<p>由链接器ld将所有.o文件的<code>_init</code>段和<code>_finit</code>段（包含glibc对堆空间的初始化和释放、编译器对C++全局对象构造析构的实现以及app自己实现的init和finit函数）分别串在一起，并且链接上glibc库的包含了<code>_start</code>（会调用<code>_init</code>）的crt.o文件，最后就形成了包含各种glibc标准库和真·用户代码的可执行文件。</p>
<p>可执行文件被装载到进程地址空间后，首先会进行动态链接。然后，从程序入口<code>_start</code>开始进行各种初始化，调用可执行文件的这个<code>_init</code>段的内容。init完成之后，glibc就调用程序中的入口main。main执行过程中会用到glibc的各种标准库函数。main执行完后就会继续执行<code>_finit</code>段来结束一切。</p>
<h3 id="C-的全局对象构造析构"><a href="#C-的全局对象构造析构" class="headerlink" title="C++的全局对象构造析构"></a>C++的全局对象构造析构</h3><ol>
<li><p>构造（<code>_init</code>）</p>
<p>编译器会将每个全局对象的构造函数以如下形式包装：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GLOBAL__I_Hw</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Hw::Hw(); <span class="comment">// 构造对象</span></span><br><span class="line">    atexit(__tcf_1); <span class="comment">// 一个神秘的函数叫做__tcf_1被注册到了exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将这个<code>GLOBAL__I_Hw</code>放进.o文件的一个<code>.ctor</code>段中，最后由ld将各个.o文件的<code>.ctor</code>段链接起来，并计算出全局对象数量填入<code>crtbegin.o</code>即可。</p>
<p>之后在<code>_init</code>段中遍历<code>.ctor</code>的各个函数指针进行构造函数调用就行了</p>
<blockquote>
<p>后日谈：今天又在rtt中看到了这一牛掰操作。rtt也是大概通过这个原理实现的帅的一匹的“<strong>Automatic Initialization Mechanism</strong>”。</p>
<p>原理感觉也是将其放入一个特殊的”rti_fn$f”段，并且用rti_start和end来标识该段结束，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xiunian: INIT_EXPORT应该是这个</span></span><br><span class="line">INIT_EXPORT(fn, <span class="string">&quot;1.0&quot;</span>) 宏展开：</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> __rti_level_fn[] = <span class="string">&quot;.rti_fn.&quot;</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line">	<span class="comment">// 指示编译器将特定的变量或数据结构分配到名为 &quot;rti_fn$f&quot; 的内存段（Memory Segment）中</span></span><br><span class="line">    __declspec(allocate(<span class="string">&quot;rti_fn$f&quot;</span>))</span><br><span class="line">    rt_used <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_init_desc</span> __<span class="title">rt_init_msc_fn</span> =</span> &#123;__rti_level_fn, fn &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xiunian: 牛逼，这里颇有学链接时的感觉了</span></span><br><span class="line"><span class="comment"> * 这里介绍了组件初始化顺序</span></span><br><span class="line"><span class="comment"> * Components Initialization will initialize some driver and components as following</span></span><br><span class="line"><span class="comment"> * order:</span></span><br><span class="line"><span class="comment"> * rti_start         --&gt; 0</span></span><br><span class="line"><span class="comment"> * BOARD_EXPORT      --&gt; 1</span></span><br><span class="line"><span class="comment"> * rti_board_end     --&gt; 1.end</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DEVICE_EXPORT     --&gt; 2</span></span><br><span class="line"><span class="comment"> * COMPONENT_EXPORT  --&gt; 3</span></span><br><span class="line"><span class="comment"> * FS_EXPORT         --&gt; 4</span></span><br><span class="line"><span class="comment"> * ENV_EXPORT        --&gt; 5</span></span><br><span class="line"><span class="comment"> * APP_EXPORT        --&gt; 6</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * rti_end           --&gt; 6.end</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These automatically initialization, the driver or component initial function must</span></span><br><span class="line"><span class="comment"> * be defined with:</span></span><br><span class="line"><span class="comment"> * INIT_BOARD_EXPORT(fn);</span></span><br><span class="line"><span class="comment"> * INIT_DEVICE_EXPORT(fn);</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * INIT_APP_EXPORT(fn);</span></span><br><span class="line"><span class="comment"> * etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rti_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">INIT_EXPORT(rti_start, <span class="string">&quot;0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rti_board_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">INIT_EXPORT(rti_board_start, <span class="string">&quot;0.end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rti_board_end</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">INIT_EXPORT(rti_board_end, <span class="string">&quot;1.end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rti_end</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">INIT_EXPORT(rti_end, <span class="string">&quot;6.end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>之后真正初始化只需遍历然后调用函数指针即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_components_board_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">const</span> <span class="type">init_fn_t</span> *fn_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (fn_ptr = &amp;__rt_init_rti_board_start; fn_ptr &lt; &amp;__rt_init_rti_board_end; fn_ptr++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*fn_ptr)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>析构（<code>_finit</code>）</p>
<p>早期同理可得。现在变了，变成直接在<code>GLOBAL__I_Hw</code>中注册<code>atexit</code>了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __tcf_1(<span class="type">void</span>) <span class="comment">//这个名字由编译器生成</span></span><br><span class="line">&#123;</span><br><span class="line">    Hw.~HelloWorld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="实现小型运行库"><a href="#实现小型运行库" class="headerlink" title="实现小型运行库"></a>实现小型运行库</h2><blockquote>
<p>看到标题就知道接下来有多帅了</p>
</blockquote>
<p>在这一章我们仅实现CRT几个关键的部分。虽然这个迷你CRT仅仅实现了为数不多的功能，但是它已经具备了CRT的关键功能：入口函数、初始化、堆管理、基本IO，甚至还将实现堆C++的new/delete、stream和string的支持。</p>
<p>本章主要分为两个部分，首先实现一个仅仅支持C语言的运行库，即传统意义上的CRT。其次，将为这个CRT加入一部分以支持C++语言的运行时特性。</p>
<p>相关代码放在<a href="https://github.com/xiunianjun/minicrt">github</a>了，其实感觉差不多是按它写的抄了一遍。可以现在稍微整理下文件结构。</p>
<ol>
<li><p>just for C</p>
<p>前面说到，CRT的作用是执行init和finit段、进行堆的管理、进行IO的封装管理以及提供各种标准C语言库。因而，我们可以分别用如下几个文件来实现这几个功能：</p>
<ol>
<li><p><code>entry.c</code></p>
<p>用于实现入口函数<code>mini_crt_entry</code>。入口函数中主要要做：调用main之前的栈构造、堆初始化、IO初始化，最后调用main函数。main函数返回后，通过系统调用exit来杀死进程。</p>
</li>
<li><p><code>malloc.c</code></p>
<p>用于实现堆的管理，主要实现了<code>malloc</code>和<code>free</code>。使用了空闲链表的小内存管理法，实现简单。</p>
</li>
<li><p><code>stdio.c</code></p>
<p>用于实现IO封装，<code>fread</code>、<code>fwrite</code>、<code>fopen</code>、<code>fclose</code>、<code>fseek</code>。实现简单，因而只是系统调用的封装</p>
</li>
<li><p><code>string.c</code></p>
<p>以字符串操作为例，提供的标准C语言库。</p>
</li>
</ol>
<p>之后，我们将其以如下参数编译为静态库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -c -fno-builtin -nostdlib -fno-stack-protector entry.c malloc.c stdio.c string.c printf.c</span><br><span class="line">$ ar -rs minicrt.a malloc.o printf.o stdio.o string.o</span><br><span class="line"><span class="comment"># 编译测试用例</span></span><br><span class="line">$ gcc -m32 -c -ggdb -fno-builtin -nostdlib -fno-stack-protector test.c</span><br></pre></td></tr></table></figure>

<p>再指定<code>mini_crt_entry</code>为入口进行静态链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ld -m elf_i386 -static -e mini_crt_entry entry.o test.o minicrt.a -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li>
<li><p>C++</p>
<p>如果要实现对C++的支持，除了在上述基础上，我们还需增加以下几个内容：全局对象（cout）构造/析构的实现、new/delete、类的实现（string和iostream）。具体来说，会支持下面这个简单的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string* msg = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    cout &lt;&lt; *msg &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> msg;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以分步实现这些功能：</p>
<ol>
<li><p>new/delete实现</p>
<p>简单地使用运算符重载功能即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>类的实现</p>
<p>不多说</p>
</li>
<li><p>全局对象的构造/析构</p>
<ol>
<li><p>构造</p>
<p>全局对象的构造在entry中进行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mini_crt_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 构造所有全局对象</span></span><br><span class="line">	do_global_ctors();</span><br><span class="line">    ret = main(argc,argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前文说过，在Linux中，每个.o文件的全局构造最后都会放在<code>.ctor</code>段。ld在链接阶段中将所有目标文件（包括用于标识<code>.ctor</code>段开始和结束的<code>crtbegin.o</code>和<code>crtend.o</code>）的<code>.ctor</code>段连在一起。所以，我们就需要实现三个文件：</p>
<ol>
<li><p><code>ctors.c</code></p>
<p>主要是用于实现<code>do_global_ctors()</code>。既然都有<code>.ctor</code>段存在了，那么它的实现就很简单，就是遍历<code>.ctor</code>段的所有函数指针并且调用它们。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run_hooks</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> <span class="title function_">do_global_ctors</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	run_hooks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run_hooks</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> ctor_func *<span class="built_in">list</span> = ctors_begin;</span><br><span class="line">	<span class="comment">// 逐个调用ctors段里的东西</span></span><br><span class="line">	<span class="keyword">while</span> ((<span class="type">int</span>)*++<span class="built_in">list</span> != <span class="number">-1</span>)	(**<span class="built_in">list</span>)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>crtbegin.c</code></p>
<p>前文说到，按规定，ld将会以如下顺序连接.o文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ld crtbegin.o 其他文件 crtend.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>因而，<code>crtbegin.c</code>的<code>.ctor</code>段会被链接在第一个。其作用是标识<code>.ctor</code>函数指针的数量，将在链接时由ld计算并且填写。因而在这里，我们只需将其初始化为一个特殊值（-1）就行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*ctor_func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">ctor_func ctors_begin[<span class="number">1</span>] __attribute__((section(<span class="string">&quot;.ctors&quot;</span>))) = &#123;</span><br><span class="line">	(ctor_func)<span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>crtend.c</code></p>
<p>同样，<code>crtend.c</code>的<code>.ctor</code>段标识着<code>.ctor</code>段的结束。因而我们也将其初始化为一个特殊值（-1）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*ctor_func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化-1为函数指针，标识结束</span></span><br><span class="line">ctor_func crt_end[<span class="number">1</span>] __attribute__((section(<span class="string">&quot;.ctors&quot;</span>))) = &#123;</span><br><span class="line">	(ctor_func) - <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>析构</p>
<p>全局对象的析构同样在entry中进行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mini_crt_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    ret = main(argc,argv);</span><br><span class="line">    <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> exitCode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 执行atexit，完成所有finit钩子</span></span><br><span class="line">	mini_crt_call_exit_routine();</span><br><span class="line">    <span class="comment">// 调用exit系统调用</span></span><br><span class="line">    <span class="keyword">asm</span>( <span class="string">&quot;movl %0,%%ebx \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;movl $1,%%eax \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;int $0x80 \n\t&quot;</span> </span><br><span class="line">    <span class="string">&quot;hlt \n\t&quot;</span>::<span class="string">&quot;m&quot;</span>(exitCode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体也是以链表形式管理所有的函数指针，在<code>atexit</code>中注册（加入链表），在<code>mini_crt_call_exit_routine</code>中真正调用，不多分析。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="特辑：开发中遇到的链接小问题"><a href="#特辑：开发中遇到的链接小问题" class="headerlink" title="特辑：开发中遇到的链接小问题"></a>特辑：开发中遇到的链接小问题</h1><ol>
<li><p>已经在<code>LD_LIBRARY_PATH</code>中加入某个静态库的路径，但是仍然报错<code>error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory</code></p>
<p>解决方法：执行<code>sudo ldconfig</code></p>
<blockquote>
<p><code>ldconfig</code>命令的作用就是将这些共享库的路径添加到动态链接器的缓存中，以便系统能够找到它们。</p>
<p>具体而言，<code>ldconfig</code>会检查默认的共享库路径（通常是<code>/lib</code>和<code>/usr/lib</code>），以及在<code>/etc/ld.so.conf</code>和<code>/etc/ld.so.conf.d/</code>目录中定义的其他路径。然后，它会更新动态链接器缓存，这样系统就知道在哪里查找共享库。</p>
<p>Q：也就是说ld不是像gcc找头文件，是根据-I选项规定的路径即时查找的，而是只根据缓存吗？所以尽管我们通过ld path环境变量设置了新查找路径，我们还是得手动刷新下ld缓存。</p>
<p>A：是的，你理解得很对。<code>ldconfig</code>主要是更新系统中的共享库缓存，而不是在每次程序运行时实时查找库文件的位置。动态链接器在运行时会根据缓存中的信息找到所需的共享库，以提高性能并避免在每次程序启动时重新搜索所有库。</p>
<p>当你通过<code>LD_LIBRARY_PATH</code>环境变量设置新的查找路径时，这只是告诉动态链接器在运行时应该额外搜索这些路径。然而，为了确保系统广泛地认识这些新的路径，以及其中的共享库，你需要运行<code>ldconfig</code>来更新缓存。</p>
</blockquote>
</li>
<li><p>关于Windows中的动态链接库（Dynamic Link Library）和类Unix系统中的共享库（Shared Library）</p>
<p>起初，是这样的一段代码吸引了我的注意力：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief npcp官方提供的加载npcap的dll库函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return BOOL 是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BOOL <span class="title function_">LoadNpcapDlls</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    _TCHAR npcap_dir[<span class="number">512</span>];</span><br><span class="line">    UINT len;</span><br><span class="line">    len = GetSystemDirectory(npcap_dir, <span class="number">480</span>);</span><br><span class="line">    <span class="keyword">if</span> (!len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in GetSystemDirectory: %lx&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    _tcscat_s(npcap_dir, <span class="number">512</span>, _T(<span class="string">&quot;\\Npcap&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (SetDllDirectory(npcap_dir) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in SetDllDirectory: %lx&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这是查找系统中npcap库路径，并加入到DLL查找目录的一段代码。我的问题是，明明已经在cmakelists中指明了需要链接npcap，为什么还需要在用户代码中显式链接呢？问了gpt半天，得到了一个这样仍旧存疑的答案：</p>
<p><img src="/2023/09/18/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/image-20240524213650948.png" alt="image-20240524213650948"></p>
<p><img src="/2023/09/18/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/image-20240524213706047.png" alt="image-20240524213706047"></p>
</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel boot</title>
    <url>/2023/07/26/kernel_boot/</url>
    <content><![CDATA[<h1 id="内核启动流程"><a href="#内核启动流程" class="headerlink" title="内核启动流程"></a>内核启动流程</h1><p>在传统的BIOS系统中，计算机具体的启动流程如下：</p>
<ol>
<li>电源启动</li>
<li>BIOS自检：计算机的BIOS固件会自检硬件设备，包括RAM、处理器、硬盘等，以确保它们正常工作。</li>
<li>引导设备选择：BIOS会根据预先定义的启动顺序（通常是硬盘、光驱、USB等）选择一个启动设备。</li>
<li>MBR（Master Boot Record）加载：如果选择的启动设备是硬盘，BIOS会加载该硬盘的MBR，其中包含了引导加载程序。</li>
<li>GRUB加载：MBR中的引导加载程序通常是GRUB（或其他引导加载程序）。GRUB会被加载到计算机的内存中，并开始执行。</li>
<li>GRUB菜单：GRUB会显示一个菜单，列出可供选择的操作系统或内核。</li>
<li>操作系统加载：用户选择操作系统后，GRUB会加载相应的操作系统或内核，并将控制权交给它。</li>
</ol>
<h2 id="cpu供电"><a href="#cpu供电" class="headerlink" title="cpu供电"></a>cpu供电</h2><p>首先电源对cpu进行供电</p>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><h3 id="执行-0xFFFFFFF0-地址处的指令"><a href="#执行-0xFFFFFFF0-地址处的指令" class="headerlink" title="执行 0xFFFFFFF0 地址处的指令"></a>执行 0xFFFFFFF0 地址处的指令</h3><p>CPU 开始执行 0xFFFFFFF0 地址处的指令，该地址处是一条 JUMP 指令，这条指令清空了基址寄存器的值，并让指令跳回到 BIOS 开始处以执行 BIOS。<br>CPU 启动后其大多数寄存器会被初始化为预定的值，包括指令寄存器（Instruction register，IR），它保存着 CPU 将要执行指令的内存地址。</p>
<p>此时， CPU 会有一个特殊行为：对 IR 的初始值加上一个基址寄存器的值，生成一个 32 位的地址 0xFFFFFFF0。之所以称为特殊行为，是因为实模式下 CPU 只能寻址 1MB 地址空间，而这个 32 位地址已经大于 1MB 的内存限制。因此，0xFFFFFFF0 也被称为重置向量（reset vector）。</p>
<h3 id="初始化必要硬件"><a href="#初始化必要硬件" class="headerlink" title="初始化必要硬件"></a>初始化必要硬件</h3><p>BIOS 内部可以分成两个区块: code block（普通程序）、boot block（引导程序）。上电后，boot block 会先被执行，它会检查 code block 的代码是否正确，如果正确，就会转到 code block 继续执行下去。0xF0000 地址实际上是 BIOS 中的 boot block 的开始处。</p>
<p>在这个阶段，会初始化部分硬件。系统的 CPU、USB 只有部分被初始化。</p>
<h3 id="加电自检POST"><a href="#加电自检POST" class="headerlink" title="加电自检POST"></a>加电自检POST</h3><p>初始化完成后，CPU 进行 BIOS 加电自检（power on self test, POST）。这个过程会检查计算机的各项组件，如 CPU、显卡、内存、鼠标、键盘等。如果找不到内存或者键盘都有可能让BIOS停止工作并且打印一些相关的错误信息，如果找不到显卡 BIOS 会发出蜂鸣警告</p>
<h3 id="执行其他bios"><a href="#执行其他bios" class="headerlink" title="执行其他bios"></a>执行其他bios</h3><p>接下来bios会开始寻找其他设备的 <strong>ROM</strong>，如果找到任何其他设备的 BIOS，它们也会被执行。</p>
<h3 id="设置中断向量表"><a href="#设置中断向量表" class="headerlink" title="设置中断向量表"></a>设置中断向量表</h3><p>BIOS在初始化过程中会设置中断向量表（Interrupt Vector Table，IVT），它是一个存储中断处理程序地址的表格。</p>
<p>BIOS会<strong>在计算机启动时加载到内存中</strong>，并在初始化过程中设置IVT。默认情况下，BIOS会提供一组固件中断处理程序，用于处理硬件相关的中断事件，如时钟中断、键盘中断等。这些固件中断处理程序是由BIOS开发商提供的，并且通常被称为BIOS中断服务例程（BIOS Interrupt Service Routines，ISR）。</p>
<p>这些固件中断处理程序是针对特定硬件的操作，它们执行特定的功能，如处理键盘输入、显示字符、控制外设等。这些处理程序被存储在IVT中相应的中断向量位置，并在硬件触发中断时被调用。</p>
<p>需要注意的是，随着操作系统的引导和加载，操作系统会接管对中断的处理，并根据自己的需求替换IVT中的中断处理程序。操作系统可以使用自己的中断处理程序来处理特定的中断事件，以满足操作系统的功能需求。</p>
<h3 id="显示bios界面"><a href="#显示bios界面" class="headerlink" title="显示bios界面"></a>显示bios界面</h3><p>下一步，显卡就会显示 BIOS 界面，并进行更深入的检查。</p>
<h3 id="写相关资源信息"><a href="#写相关资源信息" class="headerlink" title="写相关资源信息"></a>写相关资源信息</h3><p>检查完成后，BIOS 会根据自己的”系统资源表”，对系统进行进一步确认，从而确定计算机配有哪些资源或设备。例如 BIOS 支持随插即用，它会检测并配置随插即用设备。然后 BIOS 会遵循高级配置电源接口（Advanced Configuration Power Interface，ACPI）在内存中设置好一系列的数据来描述硬件信息，以便被操作系统内核利用。</p>
<h2 id="MBR加载"><a href="#MBR加载" class="headerlink" title="MBR加载"></a>MBR加载</h2><p>到这一步，BIOS 开始尝试加载操作系统。它会从硬盘，光驱，软驱，网络等几个地方依次寻找操作系统（用户可以在 BIOS 设定中修改查找的优先级）。如果找不到操作系统，BIOS 会停机并给出错误信息。</p>
<p>假设在硬盘上找到了操作系统，它会首先读取硬盘上的大小为 512 Bytes 的 0号扇区，这个扇区被称为 <strong>主引导记录</strong>（Master Boot Record，MBR），其包含三部分：</p>
<p>a) 引导程序（Boot Loader）</p>
<p>b) 硬盘分区表（Partition Table）</p>
<p>c) 结束标志字</p>
<p>BIOS 读完磁盘上的 MBR 之后会把它拷贝到内存 0x7C00 地址处，然后 CPU 跳转到该内存地址执行 MBR 里的指令。事实上，被复制到物理内存的内容就是 Boot Loader。常见的 Boot Loader 有 GRUB。</p>
<p>第1阶段：BIOS加载MBR中的GRUB(GRUB第一阶段的文件），而GRUB只有446字节，无法实现太多功能，所以该阶段的主要作用其实是加载1.5阶段的文件（/boot/grub/下的文件，也即<code>grub.cfg</code>）</p>
<p>【此处详见 <a href="https://cloud.tencent.com/developer/article/1114481">史上最详细linux启动过程讲解—没有之一</a>】</p>
<p>第1.5阶段：用来加载识别文件系统的文件，<strong>识别完系统后才可以找到/boot目录</strong>。</p>
<p>第2阶段：显示GRUB菜单：GRUB的阶段2会根据配置文件（通常是grub.cfg）中的设置显示引导菜单。菜单上列出了可用的操作系统选项和其他引导项。可以加载/boot下的os，涉及到加载内核映像、初始化ramdisk（initrd/initramfs）和传递内核启动参数。GRUB在加载内核同时，也把initrd加载到内存中并运行</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><a href="https://blog.csdn.net/jinking01/article/details/105082993">https://blog.csdn.net/jinking01/article/details/105082993</a></p>
<p>运行/sbin/init，进行系统初始化</p>
<p>做很多设置，例如挂载根文件系统</p>
<h1 id="GRUB详解"><a href="#GRUB详解" class="headerlink" title="GRUB详解"></a>GRUB详解</h1><p>下文将从文件系统初始化的角度对上面提到的GRUB进行详解。</p>
<p>文件系统在启动流程中的发展历程可以分为以下三个部分：</p>
<ol>
<li><p>GRUB文件系统</p>
<p>由 GRUB 自身通过 BIOS 提供的服务加载</p>
</li>
<li><p>initramfs</p>
<p>由GRUB加载，用于挂载真正的文件系统</p>
</li>
<li><p>真正的根文件系统</p>
</li>
</ol>
<h2 id="GRUB"><a href="#GRUB" class="headerlink" title="GRUB"></a>GRUB</h2><blockquote>
<p>GRUB（GNU GRand Unified Bootloader）是一种常用的引导加载程序，用于在计算机启动时加载操作系统。</p>
<p>GRUB的主要功能是在计算机启动时提供一个菜单，让用户选择要启动的操作系统或内核。它支持多个操作系统，包括各种版本的Linux、Windows、BSD等。通过GRUB，用户可以在多个操作系统之间轻松切换。</p>
<p>除了操作系统选择，GRUB还提供了一些高级功能，例如引导参数的设置、内存检测、系统恢复等。它还支持在启动过程中加载内核模块和初始化RAM磁盘映像（initrd或initramfs）。</p>
<p>GRUB具有高度可配置性，允许用户自定义引导菜单、设置默认启动项、编辑内核参数等。它还支持引导加载程序间的链式引导，可以引导其他引导加载程序，如Windows的NTLDR。</p>
</blockquote>
<p>GRUB的基本作用流程为：</p>
<ol>
<li>BIOS加载MBR，MBR加载GRUB，开始执行GRUB程序</li>
<li>GRUB程序读取<code>grub.cfg</code>配置文件</li>
<li>GRUB程序依据配置文件，进行内核的加载、根文件系统的挂载等操作，最后将主导权转交给内核</li>
</ol>
<h3 id="grub-cfg"><a href="#grub-cfg" class="headerlink" title="grub.cfg"></a>grub.cfg</h3><p>内核启动时，GRUB程序会读取<code>/boot/grub/</code>目录下的GRUB配置文件<code>grub.cfg</code>，其中记录了所有GRUB菜单可供选择的内核选项（menuentry）及其对应的启动依赖参数。以6.4.0内核选项为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">menuentry标识着GRUB菜单中的一个内核选项</span></span><br><span class="line">menuentry &#x27;Ubuntu&#x27; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &#x27;gnulinux-simple-XXX&#x27; &#123;</span><br><span class="line">        recordfail # 记录上次启动是否失败，用于处理启动失败的情况</span><br><span class="line">        load_video # 加载视频驱动模块，用于在启动过程中显示图形界面</span><br><span class="line">        gfxmode $linux_gfx_mode # 设置图形模式</span><br><span class="line">        insmod gzio # 加载gzio模块，提供对GZIP压缩和解压缩功能的支持</span><br><span class="line">        # 如果是在Xen虚拟化平台上，则加载xzio和lzopio模块</span><br><span class="line">        if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi </span><br><span class="line">        </span><br><span class="line">        insmod part_gpt # 加载part_gpt模块，支持GUID分区表（GPT）</span><br><span class="line">        insmod ext2 # 加载ext2模块，支持ext2文件系统</span><br><span class="line">        </span><br><span class="line">        # 设置文件系统的根分区</span><br><span class="line">        set root=&#x27;hd0,gpt3&#x27; </span><br><span class="line">        if [ x$feature_platform_search_hint = xy ]; then</span><br><span class="line">          search --no-floppy --fs-uuid --set=root --hint-bios=hd0,gpt3 --hint-efi=hd0,gpt3 --hint-baremetal=ahci0,gpt3  XXX</span><br><span class="line">        else</span><br><span class="line">          search --no-floppy --fs-uuid --set=root XXX</span><br><span class="line">        fi</span><br><span class="line">        </span><br><span class="line">        linux   /boot/vmlinuz-6.4.0-rc3+ root=UUID=XXX ro text # 指定内核映像的路径和启动参数</span><br><span class="line">        initrd  /boot/initrd.img-6.4.0-rc3+ # 指定initramfs映像的路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>grub.cfg</code>主要记录了一些该<strong>内核启动需要的依赖module</strong>，以及<strong>内核映像和initramfs映像的路径</strong>。</p>
<p>menuentry的代码中，有以下几个要点值得注意：</p>
<ol>
<li><p><code>insmod gzio </code></p>
<p>由于加载gzio模块，提供对GZIP压缩和解压缩功能的支持。</p>
<p>看到这里我第一反应是觉得有点割裂，为啥这看着比较无关紧要的解压缩功能要在内核启动之前就需要有呢？于是我想起来在配置内核时，有一个选项是这样的：</p>
<p><img src="/2023/07/26/kernel_boot/image-20230616143835953.png" alt="image-20230616143835953"></p>
<p>在配置选项中，我们选择了对initramfs的支持，并且勾选了<code>Support initial ramdisk/ramfs compressed using gzip </code>，也即在编译时通过gzip压缩initramfs的大小以节省空间。</p>
<p>所以说，我们在内核启动之前，持有的initramfs处于被压缩的状态。故而，我们自然需要在内核启动之前安装gzio模块，从而支持之后对initramfs的解压缩了。</p>
</li>
<li><p><code>insmod ext2</code></p>
<p>这句代码说明，GRUB的临时文件系统为ext2类型，这句代码事实上是在安装GRUB建立临时文件的必要依赖包，从而GRUB程序之后才能建立其临时文件系统、从/boot/initrd.img获取initramfs映像。</p>
</li>
<li><p><code>linux   /boot/vmlinuz-6.4.0-rc3+ root=UUID=XXX ro text</code></p>
<p>指定了启动参数，也即将根文件系统以只读（<code>ro</code>）的方式挂载在<code>root=UUID=XXX</code>对应的块设备上，并且默认以<code>text</code>方式（也即非图形化的Shell界面）启动内核。</p>
<p><u>此处的启动参数可在下一个部分介绍的<code>grub</code>文件中个性化。</u></p>
</li>
</ol>
<h3 id="grub-cfg的生成与修改"><a href="#grub-cfg的生成与修改" class="headerlink" title="grub.cfg的生成与修改"></a>grub.cfg的生成与修改</h3><p>实际运用中，很多时候需要对启动参数进行一些修改。下面介绍两种修改<code>grub.cfg</code>的方法。</p>
<h4 id="etc-default-grub"><a href="#etc-default-grub" class="headerlink" title="/etc/default/grub"></a>/etc/default/grub</h4><p>可以看到，<code>grub.cfg</code>其实格式较为固定（也即由一系列内容也比较相似的menuentry构成）。因而，实际上我们是通过<code>grub.d</code>生成<code>grub.cfg</code>的（6.S081实验中事实上也涉及了这一点），而<code>/etc/default/grub</code>则是GRUB程序以及<code>grub.cfg</code>生成的配置文件。下面介绍下该文件主要有哪些配置选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If you change this file, run <span class="string">&#x27;update-grub&#x27;</span> afterwards to update</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/boot/grub/grub.cfg.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For full documentation of the options <span class="keyword">in</span> this file, see:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  info -f grub -n <span class="string">&#x27;Simple configuration&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机时GRUB界面的持续时间，此处设置为30s</span></span><br><span class="line">GRUB_TIMEOUT=30</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不使用图形化界面</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GRUB_TERMINAL=console</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">图形化界面的大小</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GRUB_GFXMODE=640x480</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不使用UUID</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GRUB_DISABLE_LINUX_UUID=<span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">隐藏recovery mode</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GRUB_DISABLE_RECOVERY=<span class="string">&quot;true&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>重点看下这几个参数：</p>
<ol>
<li><p><code>GRUB_CMDLINE_LINUX</code></p>
<p>表示最终生成的grub.cfg中的每一个menuentry中的linux那一行需要附加什么参数。</p>
<p>例如说，如果设置为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示initramfs在挂载真正的根文件系统之前，需要等待120s，用于防止磁盘没准备好导致的挂载失败</span></span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;rootdelay=120&quot; </span><br></pre></td></tr></table></figure>

<p>那么，最终在menuentry中的启动参数就为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">linux   /boot/vmlinuz-6.4.0-rc3+ root=UUID=XXX ro rootdelay=120 text</span><br></pre></td></tr></table></figure>

<p>其他一些常见的选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接以路径来标识块设备而非使用UUID。此为old option，建议尽量使用UUID</span></span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;root=/dev/sda3&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标明init进程（启动后第一个进程）的具体路径。此处指明为`/bin/sh`</span></span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;init=/bin/sh&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在修改完<code>grub</code>文件之后，我们需要执行<code>sudo update-grub</code>，来重新生成<code>grub.cfg</code>文件供下次启动使用。</p>
<h4 id="在GRUB界面直接修改"><a href="#在GRUB界面直接修改" class="headerlink" title="在GRUB界面直接修改"></a>在GRUB界面直接修改</h4><p><img src="/2023/07/26/kernel_boot/image-20230616151055620.png" alt="image-20230616151055620"></p>
<p>我们可以在GRUB界面选中所需内核，按下e键：</p>
<p><img src="/2023/07/26/kernel_boot/image-20230616151122738.png" alt="image-20230616151122738"></p>
<p>然后就可以对启动参数进行修改。</p>
<p>值得注意的是，此修改仅对本次启动有效。如果需要长期修改，建议还是通过第一种方法去修改。</p>
<h2 id="initramfs"><a href="#initramfs" class="headerlink" title="initramfs"></a>initramfs</h2><p>GRUB程序会通过<code>initrd.img</code>启动initramfs，从而进行真正的根文件系统挂载。</p>
<blockquote>
<p>initrd.img是一个Linux系统中的初始化内存盘（initial RAM disk）的映像文件。它是一个压缩的文件系统映像，通常在引导过程中加载到内存中，并提供了一种临时的根文件系统，以便在正式的根文件系统（通常位于硬盘上）可用之前提供必要的功能和模块。</p>
</blockquote>
<p>我们可以通过<code>unmkinitramfs /boot/initrd.img-6.4.0-rc3+ /tmp/initrd/</code>命令解压initrd，探究里面到底有什么玩意。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">├── bin -&gt; usr/bin</span><br><span class="line">├── conf</span><br><span class="line">├── etc</span><br><span class="line">├── init</span><br><span class="line">├── lib -&gt; usr/lib</span><br><span class="line">├── lib32 -&gt; usr/lib32</span><br><span class="line">├── lib64 -&gt; usr/lib64</span><br><span class="line">├── libx32 -&gt; usr/libx32</span><br><span class="line">├── run</span><br><span class="line">├── sbin -&gt; usr/sbin</span><br><span class="line">├── scripts</span><br><span class="line">├── usr</span><br><span class="line">└── var</span><br><span class="line">init</span><br></pre></td></tr></table></figure>

<p>可以看到，这实际上就是一个小型的文件系统，也即initramfs。它有自己的built-in Shell（BusyBox）：</p>
<p><img src="/2023/07/26/kernel_boot/image-20230616151938951.png" alt="image-20230616151938951"></p>
<p>有一些较少的Shell命令（bin和sbin目录下），以及用来挂载真正的根文件系统的代码逻辑（存储在scripts目录下）。【我猜】在正常情况下，系统会执行scripts下的脚本代码挂载真正的文件系统。当挂载出现异常时，系统就会将控制权交给initramfs内置的Shell BusyBox，由用户自己探究出了什么问题。</p>
<p>我们接下来可以追踪下initramfs的script目录下的文件系统挂载流程。</p>
<p>挂载真正文件系统的主要函数为<code>local_mount_root</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅展示主要流程代码</span></span><br><span class="line">local_mount_root()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">预处理，获取参数等（也即上面grub.cfg配置的root=UUID）</span></span><br><span class="line">	local_top</span><br><span class="line">	if [ -z &quot;$&#123;ROOT&#125;&quot; ]; then</span><br><span class="line">		panic &quot;No root device specified. Boot arguments must include a root= parameter.&quot;</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">根据UUID获取对应的块设备</span></span><br><span class="line">	local_device_setup &quot;$&#123;ROOT&#125;&quot; &quot;root file system&quot;</span><br><span class="line">	ROOT=&quot;$&#123;DEV&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">挂载前的预处理</span></span><br><span class="line">	local_premount</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">挂载</span></span><br><span class="line">	mount $&#123;roflag&#125; $&#123;FSTYPE:+-t &quot;$&#123;FSTYPE&#125;&quot;&#125; $&#123;ROOTFLAGS&#125; &quot;$&#123;ROOT&#125;&quot; &quot;$&#123;rootmnt?&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于研究这个是错误驱动（乐），因而我只主要看了下<code>local_device_setup</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$1</span>=device ID to mount设备ID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$2</span>=optionname (<span class="keyword">for</span> root and etc)要挂载的是什么玩意，此处应为root file system</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$3</span>=panic <span class="keyword">if</span> device is missing (<span class="literal">true</span> or <span class="literal">false</span>, default: <span class="literal">true</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sets <span class="variable">$DEV</span> to the resolved device node <span class="variable">$DEV</span>是最终获取到的块设备</span></span><br><span class="line">local_device_setup()</span><br><span class="line">&#123;</span><br><span class="line">	local dev_id=&quot;$1&quot;</span><br><span class="line">	local name=&quot;$2&quot;</span><br><span class="line">	local may_panic=&quot;$&#123;3:-true&#125;&quot;</span><br><span class="line">	local real_dev</span><br><span class="line">	local time_elapsed</span><br><span class="line">	local count</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取grub.cfg的rootdelay参数的设备等待时间。如果没有该参数，默认是30秒</span></span><br><span class="line">	local slumber=30</span><br><span class="line">	if [ &quot;$&#123;ROOTDELAY:-0&#125;&quot; -gt $slumber ]; then</span><br><span class="line">		slumber=$ROOTDELAY</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">等待设备</span></span><br><span class="line">	case &quot;$dev_id&quot; in</span><br><span class="line">	UUID=*|LABEL=*|PARTUUID=*|/dev/*)</span><br><span class="line">		FSTYPE=$( wait-for-root &quot;$dev_id&quot; &quot;$slumber&quot; )</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		wait_for_udev 10</span><br><span class="line">		;;</span><br><span class="line">	esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">等待结束了。如果条件为真，说明还是获取不到对应的设备，那就只能说明这个设备死了</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">所以我们就得把问题告诉用户，让用户自己解决，并且进入BusyBox Shell</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">We<span class="string">&#x27;ve given up, but we&#x27;</span>ll <span class="built_in">let</span> the user fix matters <span class="keyword">if</span> they can</span></span><br><span class="line">	while ! real_dev=$(resolve_device &quot;$&#123;dev_id&#125;&quot;) ||</span><br><span class="line">	      ! get_fstype &quot;$&#123;real_dev&#125;&quot; &gt;/dev/null; do</span><br><span class="line">		if ! $may_panic; then</span><br><span class="line">			echo &quot;Gave up waiting for $&#123;name&#125;&quot;</span><br><span class="line">			return 1</span><br><span class="line">		fi</span><br><span class="line">		echo &quot;Gave up waiting for $&#123;name&#125; device.  Common problems:&quot;</span><br><span class="line">		echo &quot; - Boot args (cat /proc/cmdline)&quot;</span><br><span class="line">		echo &quot;   - Check rootdelay= (did the system wait long enough?)&quot;</span><br><span class="line">		if [ &quot;$&#123;name&#125;&quot; = root ]; then</span><br><span class="line">			echo &quot;   - Check root= (did the system wait for the right device?)&quot;</span><br><span class="line">		fi</span><br><span class="line">		echo &quot; - Missing modules (cat /proc/modules; ls /dev)&quot;</span><br><span class="line">		panic &quot;ALERT!  $&#123;dev_id&#125; does not exist.  Dropping to a shell!&quot;</span><br><span class="line">	done</span><br><span class="line"></span><br><span class="line">	DEV=&quot;$&#123;real_dev&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里如果进入错误状态，最终就是这样的效果2333：</p>
<p><img src="/2023/07/26/kernel_boot/image-20230616153420011.png" alt="image-20230616153420011"></p>
]]></content>
  </entry>
  <entry>
    <title>ChCore</title>
    <url>/2024/08/11/chcore/</url>
    <content><![CDATA[<blockquote>
<p><strong>具体实验流程请见<a href="/2024/07/27/chcore_lab">实验流程记录</a>，本文仅作为一个简单的省流和导读。</strong></p>
<p>我当初的实验代码请见<a href="https://github.com/xiunianjun/chcore">github</a>，貌似做完了看到它改版略多（）</p>
</blockquote>
<p>关键词：ChCore，微内核，OS Lab，capability细粒度访问控制（包括cap group、面向对象设计，这个确实相比于syscall灵活不少）、service之间隔离</p>
<h2 id="内核启动及内存管理"><a href="#内核启动及内存管理" class="headerlink" title="内核启动及内存管理"></a>内核启动及内存管理</h2><p>相关实验：Lab0、Lab1、Lab2</p>
<p>ChCore基于ARMv8架构，采用buddy system+slab管理物理内存，采用了四级虚拟地址映射。这部分内容都纯粹在内核态实现，跟宏内核没啥区别。</p>
<p><strong>Discussion</strong>：HM将MM移到用户态实现了，ChCore还是纯纯在内核态。不过值得一提的是，本届OS竞赛上SJTU<a href="https://gitlab.eduxiji.net/educg-group-22024-2210153/T202410248992613-905/-/blob/main/docs/memory.md">基于ChCore的参赛作品</a>似乎也像sel4那样把虚拟内存分配这一部分移到了用户态实现，之后有精力再拜读一下几位佬的代码。</p>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><p>相关实验：Lab2、Lab3</p>
<h3 id="capability"><a href="#capability" class="headerlink" title="capability"></a>capability</h3><p>ChCore 微内核采用“Everything is an object”的设计理念，将内核提供给用户的一切资源统一抽象成内核对象（kernel object）。ChCore微内核中共提供了7种类型的内核对象，分别是 cap 组对象（cap_group）、线程对象（thread）、物理内存对象（pmo）、地址空间对象（vmspace）、通信对象（connection 和 notification）、中断对象（irq）。</p>
<p>用户以capability作为标识符，通过系统调用来使用相应的内核对象，举例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存对象，可以映射后通过虚拟地址读写，也可以直接读写</span></span><br><span class="line"><span class="type">cap_t</span> <span class="title function_">usys_create_pmo</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">unsigned</span> <span class="type">long</span> type)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">usys_map_pmo</span><span class="params">(<span class="type">cap_t</span> cap_group_cap, <span class="type">cap_t</span> pmo_cap,</span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> perm)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">usys_unmap_pmo</span><span class="params">(<span class="type">cap_t</span> cap_group_cap, <span class="type">cap_t</span> pmo_cap,</span></span><br><span class="line"><span class="params">                   <span class="type">unsigned</span> <span class="type">long</span> addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">usys_write_pmo</span><span class="params">(<span class="type">cap_t</span> pmo_cap, <span class="type">unsigned</span> <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">usys_read_pmo</span><span class="params">(<span class="type">cap_t</span> cap, <span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">void</span> *buf,</span></span><br><span class="line"><span class="params">                  <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="comment">// 线程对象，arg中记录handler entry</span></span><br><span class="line"><span class="type">cap_t</span> <span class="title function_">usys_create_thread</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> thread_args_p)</span>;</span><br><span class="line"><span class="comment">// 通信对象</span></span><br><span class="line"><span class="type">cap_t</span> <span class="title function_">usys_create_notifc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">usys_wait</span><span class="params">(<span class="type">cap_t</span> notifc_cap, <span class="type">bool</span> is_block, <span class="type">void</span> *timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">usys_notify</span><span class="params">(<span class="type">cap_t</span> notifc_cap)</span>;</span><br></pre></td></tr></table></figure>

<p>用户态也可以授权、转移和收回capability：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">usys_revoke_cap</span><span class="params">(<span class="type">cap_t</span> obj_cap, <span class="type">bool</span> revoke_copy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">usys_transfer_caps</span><span class="params">(<span class="type">cap_t</span> dest_group_cap, <span class="type">cap_t</span> *src_caps, <span class="type">int</span> nr_caps,</span></span><br><span class="line"><span class="params">                       <span class="type">cap_t</span> *dst_caps)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>Discussion</strong>：用户需要借由syscall访问内核对象，而隔壁HM的memory manager移到了用户态实现，所以频繁修改page table之类的内核对象开销还是会非常巨大。HM的解决方法貌似是直接简单粗暴把内核对象的信息给映射出去，user根据权限直接读写就行了。</p>
<p><img src="/2024/08/11/chcore/image-20240812172659396.png" alt="image-20240812172659396"></p>
<p>ChCore的mm相当于还是在内核态实现，并且还支持了部分内核对象的数据直接映射（如PMO），所以感觉这个问题影响不大。</p>
<h3 id="cap-group"><a href="#cap-group" class="headerlink" title="cap group"></a>cap group</h3><p>不同于隔壁Linux还是存在进程这个概念的（比如<code>task_struct</code>结构体既可以表示进程也可以表示线程），ChCore干脆把线程和进程切割了。进程变成了一个capability group，字如其名就是一个存储所有capability集合的东西，而线程则是真正的具有调度实体的执行逻辑的东西。当我们launch一个进程的时候，我们会读取其对应ELF可执行文件进行vmspace的初始化，并且为其创造一个main thread调度运行主要逻辑。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>这部分也跟宏内核是差不多的，ChCore也是比较现代地采取了一个schedule class和schedule entity的结构。</p>
<h2 id="IPC通信"><a href="#IPC通信" class="headerlink" title="IPC通信"></a>IPC通信</h2><p>相关实验：Lab4 Part3、Lab5 Part1</p>
<p>这部分可以直接去看<a href="https://xiunianjun.github.io/2024/07/27/chcore_lab/#%E8%BF%9B%E7%A8%8BIPC%E9%80%9A%E4%BF%A1:~:text=%E7%BB%93%E6%9D%9F%E4%BD%BF%E7%94%A8FPU-,%E8%BF%9B%E7%A8%8BIPC%E9%80%9A%E4%BF%A1,-%E3%80%90%E6%BF%80%E5%8A%A8%EF%BC%81%E3%80%91">实验记录原文</a>（Lab4: 多核调度与IPC——进程IPC通信）。</p>
<p><strong>Discussion</strong>：</p>
<ol>
<li><p>线程池</p>
<p>ChCore的server handler没有实现线程池结构，而是即用即建。不过它也做了跟HM类似的优化。HM为了防止OOM发生和使内存分配更高效，令每个thread在创建时就提前绑定频繁使用的system service的栈空间，并且伴之以经典的动态扩容stack pool。ChCore让每个thread与频繁使用的system service（虽然chcore也就这几个service）的连接一对一绑定，而非同一cap group的多个thread共享同一个IPC连接，从而提高效率。</p>
</li>
<li><p>IPC性能调优</p>
<p><img src="/2024/08/11/chcore/image-20240812181939517.png" alt="image-20240812181939517"></p>
<p><img src="/2024/08/11/chcore/image-20240812181929189.png" alt="image-20240812181929189"></p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Discussion</strong>：感觉挺多地方两种架构设计理念是差不多的，比如说Linux一些模块的面向对象设计；再比如说虚拟文件系统（proc kobject etc.）可以把内核数据暴露给用户态，通过fd可以IO重定向访问内核对象数据，从而不再仅使用syscall API这么死板，这其实就跟这个capability没什么差别了。还有比如说kernel module，比如说各种各样用户态OS，比如说Linux的模块化编译定制裁剪，再比如说HM的隔离级别，两者其实都在互相吸纳对方架构设计的优点，并且各有各的应用场景不同。我目前还是认为数据中心等scalibility要求高的场景还是用宏内核（Linux or专用OS）比较OK，在偏嵌入式的场景还是微内核或者混合架构的专用RTOS看起来更有前途一些。</p>
]]></content>
      <tags>
        <tag>labs</tag>
      </tags>
  </entry>
  <entry>
    <title>ChCore 实验流程记录</title>
    <url>/2024/07/27/chcore_lab/</url>
    <content><![CDATA[<h1 id="Lab0-拆炸弹"><a href="#Lab0-拆炸弹" class="headerlink" title="Lab0: 拆炸弹"></a>Lab0: 拆炸弹</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉做下来还是蛮有意思，做得最难受的是phase4，这加密过程看得我脑壳痛……</p>
<p><a href="https://blog.csdn.net/qq_24433609/article/details/125991550">关于指令集架构</a></p>
<p>第一次接触ARM架构，还是蛮新奇的。</p>
<ol>
<li><p><code>stp    x29, x30, [sp, #-16]!</code></p>
<p>将寄存器 x29（帧指针, EBP）和 x30（链接寄存器, RA）压入栈中，同时将栈指针sp减去16字节。</p>
<p>[sp, #-16]表示的是sp-16的位置，然后!表示把这个值写回sp寄存器</p>
<p>还有<code>ldp    x29, x30, [sp], #16</code>也是同理。</p>
<p>感觉这两个指令还蛮有意思的，节省了部分开销（可能有点点类似什么超标量的思想（当然还是完全不一样）），而且确实用的地方很多（保护&amp;恢复现场），节省了很多开销。</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># adrp 指令获取目标地址的高 12 位，并将其放入 x1 寄存器</span><br><span class="line"># GOT 是一个在程序的可执行文件中或在程序加载到内存时由动态链接器创建的表。</span><br><span class="line"># 它包含了程序中所有被引用的全局变量和外部（其他共享库中的）符号的地址。</span><br><span class="line"># PLT 是一个用于支持动态链接的跳转表，它包含了对外部函数的引用。</span><br><span class="line"># 当程序调用一个外部函数时，它首先跳转到 PLT 中相应的条目。</span><br><span class="line"># 然后，PLT 条目会将控制权传递给动态链接器，链接器解析函数的实际地址，</span><br><span class="line"># 并将其存储在 GOT 中。下一次调用同一个函数时，程序会直接跳转到 GOT 中存储的地址，而不再通过 PLT。</span><br><span class="line">adrp	x1, 4a0000 &lt;.got.plt+0x18&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>x0/w0  x1/w1</p>
</li>
<li><p>需要下载<code>aarch64-linux-gnu-objdump</code>，貌似不能用通用的<code>objdump</code>（加了-m选项也还是不行）。</p>
</li>
</ol>
<h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><p>通关！</p>
<p><img src="/2024/07/27/chcore_lab/image-20240727180820446.png" alt="image-20240727180820446"></p>
<ol>
<li><p>phase0</p>
<p>只需要控制w1和w0的值相等就即可。用GDB调试一下就行。</p>
</li>
<li><p>phase1</p>
<p>这次是字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  40076c:	f9402c21 	ldr	x1, [x1, #88]</span><br><span class="line">  400770:	94008504 	bl	421b80 &lt;strcmp&gt;</span><br><span class="line"># 就是说如果w0不为零就爆炸，也就是说输入的字符串要跟x1所在字符串一样</span><br><span class="line">  400774:	35000060 	cbnz	w0, 400780 &lt;phase_1+0x20&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/27/chcore_lab/image-20240726233511926.png" alt="image-20240726233511926"></p>
</li>
<li><p>phase2</p>
<p>需要了解其栈结构，并且看懂它这个循环代码。迭代计算斐波那契数列。</p>
</li>
<li><p>phase3</p>
<p>phase_3是一个类似分支条件的结构。</p>
<p>第一个参数为3(w1)，第二个参数x需满足 : (x^(x&gt;&gt;3)) &amp; 0x07（取后三位） == 3(w1)。3 3即可满足要求。</p>
<p>第一个参数为6，这段计算太复杂了我有点没看懂，略……不过看其他俩的套路应该是6 6。</p>
<p>第一个参数为2(w1)，第二个参数x需满足 : (x &amp; 0x7) == 2。2 2即可满足要求。</p>
</li>
<li><p>phase4</p>
<p>一个简单的对输入字符串加密的程序，给定一个经过两次编码变换的结果字符串，要求逆向求出其原始字符串。</p>
<p>helloworlc-&gt;isggstsvke</p>
<ol>
<li><p>观察encrypt_method2可知其大概是一个字母变换的函数，并且要求输入只能是仅含小写字母（不能含a）的序列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4009b4:	51018400 	sub	w0, w0, #0x61</span><br><span class="line">4009bc:	7100641f 	cmp	w0, #0x19</span><br></pre></td></tr></table></figure></li>
<li><p>在phase_4中可打印出目标字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 输入字符串和某静态字符串应该相等</span><br><span class="line">  400a24:	94008457 	bl	421b80 &lt;strcmp&gt;</span><br></pre></td></tr></table></figure>

<p>打印x0和x1即可得到两个字符串的地址，访存可知目标字符串为isggstsvke。</p>
</li>
<li><p>测试调试几遍可知，大概思路是encrypt_method1负责乱序，encrypt_method2负责字母映射编码</p>
</li>
<li><p>观察encrypt_method2可获取字母映射表的静态存储地址，打印获得映射表，对2中的字符串反编码，得到原始字母序列</p>
<p>字母映射表在地址0x400998处，查询[x0-97]附近值即可。</p>
<p><img src="/2024/07/27/chcore_lab/image-20240727024252825.png" alt="image-20240727024252825"></p>
</li>
<li><p>encrypt_method1的变换我没太看懂（也有点懒研究哈哈哈），我最终从字母里感觉有点像helloworld（再加上还是10个字哈哈哈）猜出来的。</p>
</li>
</ol>
</li>
<li><p>phase5</p>
<p>最后一个phase是一个递归函数，使用x0和x1交替传递返回值和参数。</p>
<p>观察可知phase_5要求func_5这个递归函数最终返回的是3。查看func_5的逻辑，可以将其转化为类似的伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x1 == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x0 == *x1)  explode();</span><br><span class="line"><span class="keyword">if</span> (*x1 &lt;= x0) <span class="keyword">goto</span> END;</span><br><span class="line">x1 = *(x1 + <span class="number">8</span>);</span><br><span class="line">x0 = func(x0, x1);</span><br><span class="line">x0 *= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">END:</span><br><span class="line">x1 = *(x1 + <span class="number">16</span>)</span><br><span class="line">x0 = func(x0, x1);</span><br><span class="line">x0 = x0 * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 更高级语言一点</span></span><br><span class="line"><span class="type">int</span> func (<span class="type">int</span> a, <span class="type">int</span> *b) &#123;</span><br><span class="line">  <span class="keyword">if</span> (*b == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (a == *b)  GG.</span><br><span class="line">  <span class="keyword">if</span> (a &lt; *b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * func(a, (b + <span class="number">8</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * func(a, (b + <span class="number">16</span>)) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中x1指向一个数组。</p>
<p>所以我们可以看出来，他大概就是一直将输入a和数组b中的元素进行对比。如果a大于等于该元素，那么就移动一个步长，继续比较，并且返回一个偶数；否则，移动两个步长，返回一个奇数。</p>
<p>由于phase_5中要求我们得到3，故而可能的结果序列只能是 3 1 0，也即前两次递归都进入分支2（输入必须小于），其他次递归都进入分支1，最后一次递归是由<code>*b == 0</code>终止。</p>
<p>于是我们可以看看x1所指向的数组的内容：</p>
<p><img src="/2024/07/27/chcore_lab/image-20240727180732827.png" alt="image-20240727180732827"></p>
<p>[49] 0 [20] 0 [92] 0 20 0 [3] 0 [37] 0 92 0 [55] 0 [94] 0 3 0 0 0 0 0 37等等等</p>
<p>当输入为93的时候轨迹如上，很完美实现它的要求。</p>
</li>
</ol>
<h1 id="Lab1-内核启动"><a href="#Lab1-内核启动" class="headerlink" title="Lab1: 内核启动"></a>Lab1: 内核启动</h1><blockquote>
<p><a href="https://static.docs.arm.com/100076/0100/arm_instruction_set_reference_guide_100076_0100_00_en.pdf">ARM手册</a></p>
</blockquote>
<p>感觉最大的收获还是亲身体验了一把启动流程，以前只简单看过XV6的C代码和听过课的讲解，这还是第一次直接钻到汇编底下看。。。感觉OS作为软硬件接口，非常好的一个地方就是他不会太hw，有需要就设一下寄存器让硬件自己猜就行了，这点我很喜欢哈哈。</p>
<p><img src="/2024/07/27/chcore_lab/image-20240728215416372.png" alt="image-20240728215416372"></p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote>
<p>之前也简单探究过OS启动的流程，这里放上站内文章链接：</p>
<p><a href="/2023/07/26/kernel_boot">kernel boot</a>【BIOS-&gt;GRUB】</p>
<p><a href="https://xiunianjun.github.io/2023/01/10/xv6$chap2/#Code-starting-xv6-and-the-first-process:~:text=%E4%BA%8Epcb%E8%A1%A8%E3%80%82-,Code%3A%20starting%20xv6%20and%20the%20first%20process,-%E7%9C%8B%E5%AE%8C%E4%B8%80%E9%81%8D%E8%AF%B4">Code: starting xv6 and the first process</a>【GRUB将操作权给到OS之后的启动】</p>
</blockquote>
<p>感觉此处的bootloader就是类似于grub的结构，负责切换异常级别、初始化串口和内存映射并且最终跳转到真.OS。</p>
<p>总体流程及关键函数大概是：</p>
<ol>
<li><p>内核镜像构建</p>
<p>本实验代码包含了基础的ChCore 微内核操作系统，除了练习题相关的源码以外，其余部分通过二进制格式提供，最终编译构建成为一个ELF格式的内核映像文件。</p>
<p>可以使用readelf工具或者什么objdump来查看<code>kernel.img</code>。</p>
<p>通过<code>kernel/arch/aarch64/boot/linker.tpl.ld</code>精细设计了.init等段的大小和位置。</p>
<p><img src="/2024/07/27/chcore_lab/image-20240729003451663.png" alt="image-20240729003451663"></p>
<p>在cmake文件可看到bootloader大概包含这些东西：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(</span><br><span class="line">    APPEND</span><br><span class="line">    _init_sources</span><br><span class="line">    init/start.S</span><br><span class="line">    init/mmu.c</span><br><span class="line">    init/tools.S</span><br><span class="line">    init/init_c.c</span><br><span class="line">    peripherals/uart.c)</span><br><span class="line"></span><br><span class="line">chcore_target_sources_out_objects(<span class="variable">$&#123;kernel_target&#125;</span> PRIVATE init_objects</span><br><span class="line">                                  <span class="variable">$&#123;_init_sources&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>然后具体通过ld配置文件控制每个段的具体位置和装载位置。</p>
</li>
<li><p><code>_start</code>（在<code>start.S</code>中）</p>
<p>primary CPU执行主要的初始化流程，其他CPU等待至完成。</p>
</li>
<li><p><code>arm64_elX_to_el1</code>（在<code>tools.S</code>中）</p>
<p>负责特权级别的切换，启动时为EL3-&gt;EL1。</p>
<blockquote>
<p>AArch64 架构中，特权级被称为异常级别（Exception Level，EL），四个异常级别分别为 EL0、EL1、EL2、EL3，其中 EL3 为最高异常级别，常用于安全监控器（Secure Monitor），EL2 其次，常用于虚拟机监控器（Hypervisor），EL1 是内核常用的异常级别，也就是通常所说的内核态，EL0 是最低异常级别，也就是通常所说的用户态。</p>
</blockquote>
<p>切换特权级要做的不多，只需修改相关寄存器即可。对于aarch64来说，它假定的特权级切换流程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">假设处理器当前在EL1（异常级别1）运行，并且发生了一个异常导致处理器切换到EL3（异常级别3）来处理该异常。</span><br><span class="line"></span><br><span class="line">处理器在进入EL3时：</span><br><span class="line">1. 保存当前状态到SPSR_EL3</span><br><span class="line">2. 保存返回地址到ELR_EL3</span><br><span class="line"></span><br><span class="line">在处理完异常后，执行`ERET`指令，处理器会：</span><br><span class="line">1. 从SPSR_EL3获取原有处理器状态。</span><br><span class="line">2. 从ELR_EL3获取原有返回地址。</span><br><span class="line">3. 切换目标特权级别（从SPSR获取），跳转回原先的程序执行。</span><br></pre></td></tr></table></figure>

<p>所以在这里，我们相当于需要手动填写一下EL3相关寄存器就行。</p>
<p>原所有代码感觉还是非常优美地封装了(EL3、EL2、EL1)-&gt;EL1这几种case的。</p>
<p>如果是EL2切回EL1，看起来其切换逻辑大概是，还是经典eret，只不过把ELR_EL2换成指向一个ret指令的label。也即先进行一个eret，再进行一个ret，那就是类似emm，应该是叫VM Exit之类的。</p>
<p>如果是EL1切回EL1，那就只需要进行一个普通的ret就行，那就是函数调用。</p>
</li>
<li><p><code>_start</code>（在<code>start.S</code>中）</p>
<p>准备好C语言环境需要用的栈，然后去执行C代码。</p>
<blockquote>
<p>思考题：为什么要在进入 C 函数之前设置启动栈。如果不设置，会发生什么？</p>
<p>调试可知，不设置sp=0，会覆盖未知地址</p>
</blockquote>
</li>
<li><p><code>init_c</code>（在<code>init_c.c</code>中）</p>
<ol>
<li><p>clear bss</p>
<blockquote>
<p>思考题 5：在实验 1 中，其实不调用 <code>clear_bss</code> 也不影响内核的执行，请思考不清理 <code>.bss</code> 段在之后的何种情况下会导致内核无法工作。</p>
<p>感觉多核（此时别的CPU会一直spin），或者说直接用到这些未初始化的全局变量的时候</p>
</blockquote>
</li>
<li><p>初始化串口</p>
<p>我之前也写过简单的串口，aarch64也是属于外设和内存统一编址。</p>
</li>
<li><p>内存映射相关</p>
<ol>
<li><p><code>init_kernel_pt</code>初始化内核页表</p>
<blockquote>
<p>操作系统内核通常运行在虚拟内存的高地址。在内核运行时，访问内核代码和数据，对任意物理内存和外设内存（MMIO）进行读写，都使用高地址。</p>
<p>因此，在内核启动时，首先需要对<strong>内核自身、其余可用物理内存和外设内存</strong>进行虚拟地址映射，最简单的映射方式是一对一的映射，即将虚拟地址 <code>0xffff_0000_0000_0000 + addr</code> 映射到 <code>addr</code>。需要注意的是，在 ChCore 实验中我们使用了 <code>0xffff_ff00_0000_0000</code> 作为内核虚拟地址的开始（注意开头 <code>f</code> 数量的区别），不过这不影响我们对知识点的理解。</p>
</blockquote>
<p>物理地址范围 | 对应设备| 映射粒度 | 类别 </p>
</li>
</ol>
</li>
</ol>
<p>— | — | — | — </p>
<pre><code>  `0x00000000`~`0x3f000000` | 物理内存（SDRAM）| 2MB | normal 
</code></pre>
<p><code>0x3f000000</code>~`0x40000000` | 共享外设内存| 2MB | device </p>
<pre><code>  `0x40000000`~`0xffffffff` | 本地（每个 CPU 核独立）外设内存| 1GB | device 

  &gt; 我们需要在 `init_kernel_pt` 为内核配置从 `0x00000000` 到 `0x80000000`（`0x40000000` 后的 1G，ChCore 只需使用这部分地址中的本地外设）的映射，其中 `0x00000000` 到 `0x3f000000` 映射为 normal memory，`0x3f000000` 到 `0x80000000`映射为 device memory，其中 `0x00000000` 到 `0x40000000` 以 2MB 块粒度映射，`0x40000000` 到 `0x80000000` 以 1GB 块粒度映射。
  
  在kernel中看它意思，我们貌似只采取到L2，故而最终也是以2MB块的形式访存。然后这边的映射关系也是很线性，相当于直接把低地址这些摁抬上高地址了，简单粗暴。
</code></pre>
<ol start="2">
<li><code>el1_mmu_activate</code>开启MMU开启MMU映射其实就是把页表地址填入相关寄存器，然后再设置一下控制寄存器就OK了。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Write ttbr with phys addr of the translation table */</span><br><span class="line">adrp    x8, boot_ttbr0_l0</span><br><span class="line">msr     ttbr0_el1, x8</span><br><span class="line">adrp    x8, boot_ttbr1_l0</span><br><span class="line">msr     ttbr1_el1, x8</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">mrs     x8, sctlr_el1</span><br><span class="line">/* Enable MMU */</span><br><span class="line">orr     x8, x8, #SCTLR_EL1_M</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>思考题 11：请思考在 <code>init_kernel_pt</code> 函数中为什么还要为低地址配置页表，并尝试验证自己的解释。</p>
<p>因为在开启完MMU、跳转到高地址（还得再过几步）之前，还需要使用原有的栈和驱动内存。</p>
<p>如果我们未初始化的话，开启MMU的时候会是0：</p>
<p><img src="/2024/07/27/chcore_lab/image-20240728220231646.png" alt="image-20240728220231646"></p>
<p>然后sp保存的又是低地址，所以需要前往低地址页表寄存器，导致之后栈访存指令GG：</p>
<p>ldp     x29, x30, [sp], #16</p>
<p>驱动内存也应该是同理可得，大概。</p>
</blockquote>
<ol start="4">
<li><p><code>start_kernel</code></p>
<p>可以看到看起来也是先构造了一个高地址的sp：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffffff000008e000 &lt;start_kernel&gt;:</span><br><span class="line"># 造出来之后sp=ffffff00003b93f0</span><br><span class="line">ffffff000008e000:	58000302 	ldr	x2, ffffff000008e060 &lt;secondary_cpu_boot+0x38&gt;</span><br><span class="line">ffffff000008e004:	91400442 	add	x2, x2, #0x1, lsl #12	# 自高地址向下增长</span><br><span class="line">ffffff000008e008:	9100005f 	mov	sp, x2</span><br><span class="line">ffffff000009470c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!</span><br><span class="line">ffffff0000094710:	f0002aa2 	adrp	x2, ffffff00005eb000 &lt;empty_page&gt;</span><br><span class="line">ffffff0000094714:	d5182002 	msr	ttbr0_el1, x2</span><br></pre></td></tr></table></figure>

<p>然后将高地址的新页表地址覆盖<code>ttbr0_el1</code>，作用应该是清零低地址页表，这样一来之后访问地址就相当于非法访问内存越界了，于是乎就开启了全高地址映射。</p>
<p>然后就跳到main那边了。</p>
</li>
</ol>
</li>
</ol>
<h2 id="小品环节"><a href="#小品环节" class="headerlink" title="小品环节"></a>小品环节</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>这里记录一下我一个很幽默的无脑行为，最后发现是一场乌龙，给大伙笑一笑算了哈哈哈。</p>
<p>具体是这样，我在做实验之前先开始配环境，然后实验内容做啥都还一眼没看。再加上以前做lab的经历，还有看了错误版本的指导书，我就误以为配完环境直接<code>make qemu</code>就可以简单跑起来（事实上还需要先写完lab1），然后看到欢迎信息了。</p>
<p>然后，我这docker pull又一直失败，我不得不尝试多种方法来曲线救国，但总归还是不大安心，所以后面我压根没想到这可能是代码问题，一直觉得是环境问题，最后折腾了两个小时才发现原来是还得写Lab1才能启动……</p>
<p>我这很容易不知不觉就陷进细节开始钻牛角尖的毛病是时候该改改了。不过这长达两个小时的折腾过程也让我学了挺多工具（包括我也是第一次使用docker、第一次更细致地了解qemu的用法），所以这里暂且先记录下来。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>本次环境配置的大概思路是这样的。docker仅仅是负责提供一个交叉编译环境，最后输出一个<code>kernel.img</code>文件。然后我们用qemu启动整个ChCore。qemu命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -machine raspi3 -nographic -serial mon:stdio -m size=1G -kernel ./build/kernel.img</span><br></pre></td></tr></table></figure>

<p>前置环节：根据<a href="https://ipads.se.sjtu.edu.cn/courses/os/">指导书</a>配置。</p>
<h4 id="网络问题探究"><a href="#网络问题探究" class="headerlink" title="网络问题探究"></a>网络问题探究</h4><p>首先尝试发现docker硬是pull不下来，<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">配置阿里云镜像</a>无果，<a href="https://www.jianshu.com/p/6b148fdec361">配置pull时代理（采用了方法1）</a>无果。</p>
<p>不大清楚为什么……</p>
<h4 id="直接编译"><a href="#直接编译" class="headerlink" title="直接编译"></a>直接编译</h4><p>不得已，选择直接用gcc-aarch64编译。寻找一番可知修改<code>chbuild</code>脚本中的选项即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">_main</span></span>() &#123;</span><br><span class="line">    run_in_docker=<span class="literal">true</span>	<span class="comment"># 改为 false</span></span><br></pre></td></tr></table></figure>

<p>编译成功通过，然而，<code>make qemu</code>不知道为什么卡住，但Ctrl+AX依然可以响应：</p>
<p><img src="/2024/07/27/chcore_lab/image-20240728143318801.png" alt="image-20240728143318801"></p>
<p>联想到当初做XV6也有类似问题，是因为qemu版本不匹配。我一开始qemu是6.2.0，但更换qemu版本（试了5.1.0、3.1.0）依然还是不行，百思不得其解，想着会不会是确实编译器版本也有影响，所以准备另寻他路。</p>
<h4 id="自建容器"><a href="#自建容器" class="headerlink" title="自建容器"></a>自建容器</h4><p>上个方法不大行得通，所以我换了个思路。docker pull不下来，我就开始自己创建一个新容器。</p>
<p>在github搜索，找到了<a href="https://github.com/WilliamX1/ChCore/blob/bcc523dc1597feab014a41482b27fca329b1e20e/scripts/build/Dockerfile#L4">往年的ChCore-Lab</a>，提供了Dockerfile。然后可能因为docker在普通用户模式下运行，所以我需要给容器加一个跟当前用户id一致的用户。我这边是1000：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在该文件基础上增加</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -g 1000 group123</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -u 1000 -g 1000 user123</span></span><br></pre></td></tr></table></figure>

<p>总之成功把容器整出来了。根据其修改<code>chbuild</code>脚本容器名即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY       TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">chcore_builder   latest    38d06c761f8c   2 hours ago   716MB</span><br><span class="line"><span class="comment"># in chbuild</span></span><br><span class="line">docker run -i <span class="variable">$use_tty</span> --<span class="built_in">rm</span> \</span><br><span class="line">    -u $(<span class="built_in">id</span> -u <span class="variable">$&#123;USER&#125;</span>):$(<span class="built_in">id</span> -g <span class="variable">$&#123;USER&#125;</span>) \</span><br><span class="line">    -v $(<span class="built_in">pwd</span>):$(<span class="built_in">pwd</span>) -w $(<span class="built_in">pwd</span>) \</span><br><span class="line">    --security-opt=seccomp:unconfined \</span><br><span class="line">    chcore_builder \</span><br><span class="line">    <span class="variable">$self</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>此处还有一个小插曲，<code>make build</code>之后还爆了奇奇怪怪的错。还好很快发现是我在尝试方法2的时候忘了clean了，不然又得排查老半天。。。</p>
<p>然后总之，也是成功编译出了kernel img，然而依然<code>make qemu</code>卡住。。。。。</p>
<p>我感觉应该不是qemu版本问题，估计是编译出的kernel img有啥问题，所以我准备具体看看qemu究竟卡在哪了。</p>
<h4 id="探究qemu"><a href="#探究qemu" class="headerlink" title="探究qemu"></a>探究qemu</h4><p><code>qemu_wrapper.sh</code>的逻辑还蛮经典。</p>
<p>我加了句打印get到了qemu具体的运行命令，然后给它加了个<code>-d</code>选项用来调试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$qemu</span> --version</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;qemu&#125;</span> <span class="variable">$&#123;qemu_options&#125;</span>&quot;</span></span><br><span class="line">qemu-system-aarch64 -machine raspi3 -nographic -serial mon:stdio -m size=1G -kernel ./build/kernel.img -d all</span><br></pre></td></tr></table></figure>

<p>【其实这里可以用GDB的。我那时因为不知道具体到底什么问题，所以用了-d参数。】</p>
<p>然后我发现有几个CPU（Trace编号不同）都卡在了<code>PC=000000000008000c</code>。我感觉这长得很像一个很特殊的数字，于是查到了往年sjtu学生的<a href="https://ipads.se.sjtu.edu.cn/ospi/discussion/u/LYJ#:~:text=8000c%3A%2094000000%20bl%208000c%20%3Csecondary_hang%3E">讨论</a>，以及<a href="https://zhuanlan.zhihu.com/p/411538727#:~:text=intorduce%20multi%2Dprocessors%20*/-,secondary_hang%3A,-bl%20secondary_hang">这个</a>，得知这是一段内核启动常见操作，【当然现在貌似没有这个函数了】也即有一个primary CPU负责初始化流程，其他CPU就等待，而这正是等待的逻辑。</p>
<p>从帖子中我了解到主CPU存储在X8寄存器，所以我就去重点关注<code>X8=0</code>的Trace，最终发现主CPU在执行完<code>PC=0000000000088080</code>的代码之后不知道怎么回事可能就出错了，之后PC的值变成了200，并且qemu提示<code>Taking exception 1 [Undefined Instruction]</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Trace 0: 0x7f68840012c0 [0000000000000000/0000000000088080/0xb0000000] arm64_elX_to_el1</span><br><span class="line"> PC=0000000000088080 X00=0000000000000000 X01=0000000000000000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么这里会变成200？指导书中有提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">内核会发生地址翻译错误（Translation Fault），进而尝试跳转到异常处理函数（Exception Handler），</span><br><span class="line">该异常处理函数的地址为异常向量表基地址（`vbar_el1` 寄存器）加上 `0x200`。</span><br><span class="line"></span><br><span class="line">此时我们没有设置异常向量表（`vbar_el1` 寄存器的值是0），因此执行流会来到 `0x200` 地址，此处的代码为非法指令，会再次触发异常并跳转到 `0x200` 地址。</span><br><span class="line">使用 GDB 调试，在 GDB 中输入 `<span class="built_in">continue</span>` 后，按 Ctrl-C，可以观察到内核在 `0x200` 处无限循环。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，我注意到出错大概是在<code>arm64_elX_to_el1</code>这个符号邻近。我一看我去这不切换特权级吗？于是赶紧去把<code>arm64_elX_to_el1</code>这个函数搜出来了，并且一行行对比定位到出错的地方，然后就发现：</p>
<p><img src="/2024/07/27/chcore_lab/image-20240728150226658.png" alt="image-20240728150226658"></p>
<p>绷不住了！原来这是还没实现的内容呀:laughing:</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>总之<code>make qemu</code>实现完lab1就跑起来了，是我看错指导书版本误会误大发了（建议银杏书官网和实验官网update一下……不过github那边也没指路让我去参考这两个就是了，哈哈……）。不过一下尝试了三四五种配环境思路，还学习了怎么用docker，也是一个不可多得的体验了。</p>
<h4 id="还有高手"><a href="#还有高手" class="headerlink" title="还有高手"></a>还有高手</h4><p>自那之后我就一直都使用的老版本builder容器（看了看那都是v1.0了）或者直接不run在docker来做实验，安然无事到了lab2。lab3中有要求一个<code>read_procmgr_elf_tool</code>，这个就是纯纯的sjtu提供的容器中自带的了，所以我也不得已继续花半天继续回到docker的问题……</p>
<p>Recall，之前是docker pull不下来，设了pull的代理和阿里云镜像仓库代理都没用。所以我主要还是先在尝试自建代理服务这一路，相关文章：</p>
<p><a href="https://baijiahao.baidu.com/s?id=1802363672117972863&wfr=spider&for=pc">自建Docker镜像加速服务，免费且简单，服务器VPS、NAS皆可用</a></p>
<p><a href="https://www.bilibili.com/read/cv35326945/?jump_opus=1">Docker加速解决方法</a></p>
<p>这个貌似确实比以前快了一些，但依旧还是会失败。焦头烂额了许久，最后终于找到了一个虽然略曲折但能行的方法：</p>
<p><a href="https://wkdaily.cpolar.cn/archives/gc">使用Github Action 构建docker镜像</a></p>
<p>相当于是白嫖了下github的workflow，让它打包上传到github然后再从github下载。不得不说也是思路清奇，有一种所有网络问题都可以这么解的感觉。</p>
<p>然后从这下下来的会打两层包，一层zip一层tar.gz，解压完这两层之后再用<code>docker load -i filename</code>即可。</p>
<h1 id="Lab2-内存管理"><a href="#Lab2-内存管理" class="headerlink" title="Lab2: 内存管理"></a>Lab2: 内存管理</h1><p>本实验主要目的在于让同学们熟悉内核启动过程中对<strong>内存的初始化</strong>和内核启动后对<strong>物理内存和页表的管理</strong>，包括三个部分：物理内存管理、页表管理、缺页异常处理。</p>
<p>ChCore采用了buddy进行大内存分配和在此基础上的slab进行小内存分配。同时，采用了四级页表进行地址的映射。</p>
<h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><h3 id="Buddy-system"><a href="#Buddy-system" class="headerlink" title="Buddy system"></a>Buddy system</h3><p>伙伴系统大概就是按照2的幂次进行order的划分，每个order对应2^order个页。分配的时候拆解，释放的时候合并。具体结构如下图所示：</p>
<p><img src="/2024/07/27/chcore_lab/image-20240730153902396.png" alt="image-20240730153902396"></p>
<p><img src="/2024/07/27/chcore_lab/image-20240729140919170.png" alt="image-20240729140919170"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ * The layout of each physmem:</span><br><span class="line"> * | metadata (npages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> page)) | start_vaddr ... (npages *</span><br><span class="line"> * PAGE_SIZE) | */</span><br></pre></td></tr></table></figure>

<p>此为buddy内存分配的一个内存池的典型结构，每页物理内存页对应一个<code>struct page</code>结构体对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">        <span class="comment">/* Free list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">        <span class="comment">/* Whether the correspond physical page is free now. */</span></span><br><span class="line">        <span class="type">int</span> allocated;</span><br><span class="line">        <span class="comment">/* The order of the memory chunk that this page belongs to. */</span></span><br><span class="line">        <span class="type">int</span> order;</span><br><span class="line">        <span class="comment">/* Used for ChCore slab allocator. */</span></span><br><span class="line">        <span class="type">void</span> *slab;</span><br><span class="line">        <span class="comment">/* The physical memory pool this page belongs to */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">phys_mem_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们将这些page对象以链表形式组织，对这些meta data的操作管理，来实现对buddy整个内存系统的管理。</p>
<p>我本来最直观的想法是迭代实现这个向上合并or向下分裂的过程，不过代码注释要求了使用递归（确实让我豁然开朗了一下），我于是也尽量将递归包括主体和对外接口都写得更优美一点了。</p>
<p>这也是我第一次实现buddy内存分配，以往都是简单知道概念。当时了解到这个算法就觉得非常惊艳，现在真正地去实现它，更感受到它的优美，包括但不限于对伙伴块的识别、合并分裂的实现和相关思想等。总的来说还是干货满满收获巨大，虽然还是遇到了一些曲折（见小品环节）。</p>
<h3 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h3><p>slab用于管理小内存对象。它为多个阶级的对象大小定义了多个内存池。具体结构可参考下图：</p>
<p><img src="/2024/07/27/chcore_lab/image-20240729223608682.png" alt="image-20240729223608682"></p>
<p>感觉最复杂的部分还是它已经帮我们写好的数据结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对应 kmem_cache</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab_pointer</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">slab_header</span> *<span class="title">current_slab</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial_slab_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* slab_header resides in the beginning of each slab (i.e., occupies the first slot). */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab_header</span> &#123;</span></span><br><span class="line">        <span class="comment">/* The list of free slots, which can be converted to struct slab_slot_list. */</span></span><br><span class="line">        <span class="type">void</span> *free_list_head;</span><br><span class="line">        <span class="comment">/* Partial slab list. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> order;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> total_free_cnt; <span class="comment">/* MAX: 65536 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> current_free_cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，每个slab的第一个obj被分配存储<code>free_list_head</code>，接下来链接<code>free_list_head</code>。<code>free_list_head</code>没有元数据结构，而是直接在obj首部加一个地址指向下一个空闲的obj。并且这个链表不一定是连续的，每次申请释放的时候直接头插尾插就行了，毕竟整个地址空间其实都算知道，就是slab的地址。</p>
<p>然后，要获取<code>partial_slab_list</code>的结点对应的<code>slab_header</code>结构体，只需要使用类似这样的宏就可以：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of_safe(ptr, type, field) (&#123; \</span></span><br><span class="line"><span class="meta">	typeof (ptr) __ptr = (ptr); \</span></span><br><span class="line"><span class="meta">	type *__obj = container_of(__ptr, type, field); \</span></span><br><span class="line"><span class="meta">	(__ptr ? __obj : NULL); \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>另，还用了个这样的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Each free slot in one slab is regarded as slab_slot_list. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab_slot_list</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *next_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它不同于buddy的每页都有一个对应的page_t对象，是采用了一个指针直接链接的形式。</p>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><p>页表翻译的过程由MMU自动完成，我们只需把页表的物理地址存储在页表寄存器ttbr1_el1或ttbr0_el1即可。</p>
<blockquote>
<p>在 AArch64 架构的 EL1 异常级别存在两个页表基址寄存器：<code>ttbr0_el1</code><a href="https://github.com/SJTU-IPADS/OS-Course-Lab/tree/ChCore-Lab1#user-content-fn-ttbr0_el1-8136733660332040a9f5e53c1035c9a2">1</a> 和 <code>ttbr1_el1</code><a href="https://github.com/SJTU-IPADS/OS-Course-Lab/tree/ChCore-Lab1#user-content-fn-ttbr1_el1-8136733660332040a9f5e53c1035c9a2">2</a>，分别用作虚拟地址空间低地址和高地址的翻译。那么什么地址范围称为“低地址”，什么地址范围称为“高地址”呢？这由 <code>tcr_el1</code> 翻译控制寄存器<a href="https://github.com/SJTU-IPADS/OS-Course-Lab/tree/ChCore-Lab1#user-content-fn-tcr_el1-8136733660332040a9f5e53c1035c9a2">3</a>控制，该寄存器提供了丰富的可配置性，可决定 64 位虚拟地址的高多少位为 <code>0</code> 时，使用 <code>ttbr0_el1</code> 指向的页表进行翻译，高多少位为 <code>1</code> 时，使用 <code>ttbr1_el1</code> 指向的页表进行翻译<a href="https://github.com/SJTU-IPADS/OS-Course-Lab/tree/ChCore-Lab1#user-content-fn-ttbr-sel-8136733660332040a9f5e53c1035c9a2">4</a>。</p>
<p>0xffff_ff00_0000_0000为ChCore的虚拟地址开头，而0xffff_0000_0000_0000开始为高地址，所以是ttbr1_el1控制内核地址空间，ttbr0_el1控制用户地址空间。</p>
</blockquote>
<p>ChCore采用了如下图所示的四级页表：</p>
<p><img src="/2024/07/27/chcore_lab/lab1-trans.svg" alt="lab1-trans"></p>
<p>其中，TTBRx_EL1表示EL1下的页表地址寄存器，根据虚拟地址的后16位可知是需要用到高位还是低位。</p>
<p>页表项相关字段如下：</p>
<p>【L0-L2】</p>
<p><img src="/2024/07/27/chcore_lab/lab1-pte-1.png" alt="lab1-pte-1"></p>
<p>【L3】</p>
<p><img src="/2024/07/27/chcore_lab/lab1-pte-2.png" alt="lab1-pte-2"></p>
<blockquote>
<p>“Output address”在这里即物理地址，一些地方称为物理页帧号（Page Frame Number，PFN）</p>
</blockquote>
<p>值得注意的是，ChCore在内核空间（<code>0xffff_ff00_0000_0000</code> 之后的地址）中，为了简单起见，虚拟地址和物理地址都是线性映射的，也即转为<code>vaddr + KBASE</code>，<code>KBASE</code>表示了虚拟地址空间的起始地址，并且我们已经在内核启动时正确填写了内核页表，故而除了可以通过MMU地址翻译访问内核内存，我们可以直接通过<code>virt_to_phys</code>将虚拟地址转化为物理地址。</p>
<p>具体实现记得在mappages的时候需要在第三层就退出，然后手动映射，不然会导致在<code>get_next_ptp</code>中它帮我们申请一页物理地址不是我们想要的内存，导致内存泄漏。</p>
<p>这边可以回顾一下xv6的接口，是控制最后一次不alloc，然后返回下一次的pte。</p>
<h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><blockquote>
<p>当处理器发生缺页异常时，它会将发生错误的虚拟地址存储于 <code>FAR_ELx</code> 寄存器中，并触发相应的异常处理流程。ChCore 对该异常的处理最终实现在 <code>kernel/arch/aarch64/irq/pgfault.c</code> 中的 <code>do_page_fault</code> 函数。本次实验暂时不涉及前面的异常初步处理及转发相关内容，我们仅需要关注操作系统是如何处缺页异常的。</p>
<p><img src="/2024/07/27/chcore_lab/image-20240801125324310.png" alt="image-20240801125324310"></p>
</blockquote>
<p>这部分填空也是比较简单，在此不提具体的实现细节，不过可以了解一下这边中断相关和vmr相关的整体框架。</p>
<p>ChCore是多线程微内核实现，一个进程拥有一个vmspace，为进程虚拟地址空间的抽象，每个进程的vmspace指针都存在其对应的per-CPU字段中。一个vmspace被切分为多个vmregion，代表一段逻辑连续、权限相同的内存，然后vmr记录了这段region对应的物理对象（PMO），PMO里又记录了相应的物理地址。</p>
<p>因此，想要处理缺页异常，首先需要找到当前进程发生页错误的虚拟地址所处的 VMR，进而才能得知其对应的物理地址，从而在页表中完成映射。</p>
<p>缺页处理主要针对 <code>PMO_SHM</code> 和 <code>PMO_ANONYM</code> 类型的 PMO，这两种 PMO 的物理页是在访问时按需分配的。</p>
<p>缺页处理逻辑为首先尝试检查 PMO 中当前 fault 地址对应的物理页是否存在（通过 <code>get_page_from_pmo</code> 函数尝试获取 PMO 中 offset 对应的物理页）。若对应物理页未分配，则需要分配一个新的物理页，再将页记录到 PMO 中，并增加页表映射。若对应物理页已分配，则只需要修改页表映射即可。</p>
<h2 id="小品环节-1"><a href="#小品环节-1" class="headerlink" title="小品环节"></a>小品环节</h2><h3 id="Buddy-system-1"><a href="#Buddy-system-1" class="headerlink" title="Buddy system"></a>Buddy system</h3><p>【详情见buddy相关初次commit】</p>
<p>本来是打算仅有低地址的buddy（或者说第偶数个？）真正代表了本块的order数。这样的话可以减少一次order赋值，增加些微的效率，如下图所示（最左那个内部省略，4121，跟右边差不多）。</p>
<p><img src="/2024/07/27/chcore_lab/image-20240730124409354.png" alt="image-20240730124409354"></p>
<p>然而之后发现这样其实算是不对称的。。。因为这隐形规定了你split的时候需要先split最右，然后merge的时候也需要从右向左merge（也即必须前一个块就位了你这个块才能merge），也即split的时候是先割地址更高的块，而merge要求先回收低地址的块。</p>
<p>所以，当先释放高地址的块，再释放低地址的块的时候，会出问题，导致只能merge递归一次而不能继续向上递归：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">order[0] free = 0</span><br><span class="line">order[1] free = 0</span><br><span class="line">order[2] free = 0</span><br><span class="line">order[3] free = 2</span><br><span class="line">order[4] free = 2</span><br><span class="line">order[5] free = 1</span><br><span class="line">order[6] free = 0</span><br><span class="line">order[7] free = 1</span><br><span class="line">order[8] free = 0</span><br><span class="line">order[9] free = 0</span><br><span class="line">order[10] free = 0</span><br><span class="line">order[11] free = 0</span><br><span class="line">order[12] free = 1</span><br><span class="line">order[13] free = 29</span><br></pre></td></tr></table></figure>

<h3 id="PM"><a href="#PM" class="headerlink" title="PM"></a>PM</h3><p>本来学了个类似这样的可变参数宏的新活想用上去：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> map_range_in_pgtbl(...) _map_range_in_pgtbl(__VA_ARGS__, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _map_range_in_pgtbl(pgtbl, va, pa, len, flags, ...) map_range_in_pgtbl_impl(pgtbl, va, pa, len, flags)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">map_range_in_pgtbl_impl</span><span class="params">(<span class="type">void</span> *pgtbl, <span class="type">int</span> va, <span class="type">int</span> pa, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>奈何用完之后才想起来别的文件是预编译为链接文件的，而宏作用在更早的阶段，所以这样是不行的，会引发链接错误。</p>
<h1 id="Lab3-进程与线程"><a href="#Lab3-进程与线程" class="headerlink" title="Lab3: 进程与线程"></a>Lab3: 进程与线程</h1><blockquote>
<p>在实验 1 和实验 2 中，已经完成了内核的启动和物理内存的管理，以及一个可供用户进程使用的页表实现。现在，我们将一步一步支持用户态程序的运行。</p>
</blockquote>
<p>实验 3 相较于实验 1 和实验 2 开放了部分用户态程序的代码，<code>user</code> 文件夹下提供了 <code>chcore-libc</code> 及 <code>system-services</code> 文件夹，并在根目录下添加了 <code>ramdisk</code> 文件夹。</p>
<ul>
<li><code>ramdisk</code>。所有在 <code>ramdisk</code> 目录下的文件将被放入内核镜像的文件系统中。</li>
<li><code>chcore-libc</code>。基于 <code>musl-libc</code> 进行修改以配合内核进行管理及系统调用，所有对 <code>musl-libc</code> 的修改均在 <code>chcore-libc/libchcore</code>中，实际编译时将使用脚本进行override。</li>
<li><code>system-services</code>。存放一些基本的系统服务，除了在 <code>ramdisk</code> 中已经包含的，还有 <code>tmpfs</code> 和 <code>procmgr</code>。<code>tmpfs</code> 是 ChCore 基本的内存文件系统，后续实验中将会有所涉及。<code>procmgr</code> 是 ChCore 的<strong>进程管理器</strong>，所有代码均以源代码形式给出，其中包含了创建进程、加载 elf 文件等操作，感兴趣的同学可以阅读。</li>
</ul>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在 ChCore 中，内核提供给用户的一切资源均采用 <strong>Capability</strong> 机制进行管理。ChCore 微内核采用“Everything is an object”的设计理念，它将用户态能够进行操作的资源统一抽象成<strong>内核对象（kernel object）</strong>。这和UNIX操作系统中经典抽象“Everything is a file”类似，都是旨在提供简洁而统一的资源抽象。</p>
<p>ChCore微内核中共提供了7种类型的内核对象，分别是 cap 组对象（cap_group）、线程对象（thread）、物理内存对象（pmo）、地址空间对象（vmspace）、通信对象（connection 和 notification）、中断对象（irq）。每种内核对象定义了若干可以被用户态调用的操作方法，比如为线程对象设置优先级等调度信息、将一个物理内存对象映射到一个地址空间对象中等。</p>
<p>为了能够使用户态调用内核对象定义的方法，ChCore 微内核需要提供<strong>内核对象命名机制</strong>，即为一个内核对象提供<strong>在用户态相应的标识符</strong>。类似地，宏内核操作系统中的文件对象（file）在用户态的识别符是 fd，这就是一种命名机制。ChCore 采用 <strong>Capability</strong> 作为内核对象在用户态的标识符。</p>
<p>在 ChCore 微内核操作系统上运行的应用程序在内核态对应一个 cap 组对象，该对象中记录着该应用程序能够操作的全部内核对象。也即，<strong>ChCore 的一个进程是一些对特定内核对象享有相同的 Capability 的线程的集合，通过 capability 的设计，每个进程拥有独立的内核对象命名空间。</strong>ChCore 中的每个进程至少包含一个主线程，也可能有多个子线程，而每个线程则从属且仅从属于一个进程。同时，子进程也视为父进程的cap group中的一个slot。</p>
<blockquote>
<p>它这类比还蛮有意思的。在Linux中，包括内存管理、文件系统、进程本身、IO外设等的Metadata，都可以是文件（或者也不能这么说，我感觉文件形式更多时候其实还是只作为一个面向用户态的接口的……）；而在ChCore中，这些Metadata则以对象的形式表现。文件描述符fd是用于访问一个文件，实际上就代表了当前上下文对该文件具有一种可以访问的“Capability”。</p>
<p>而且，进程的含义其实是对整个系统的一个小型抽象，有自己的逻辑和数据。这个cap_group的角度也是非常精准。</p>
</blockquote>
<p>在实现中，一个 <code>cap_group</code> 作为一个进程的抽象，是指针数组，存储指向内核对象的指针。</p>
<p>Capability 在用户态看来是 cap 组的索引。当授权某个进程访问一个内核对象时，操作系统内核首先在这个进程对应的 cap 组中分配一个空闲的索引，然后把内核对象的指针填写到该索引位置，最后把索引值作为 capability 返回给用户态即可。【这就是非常FD的操作了】</p>
<p>用户态进程中的所有线程隶属于同一个 cap 组，而该 cap 组中非空闲的索引值即为该进程拥有的所有 capability，也就是该进程中所有线程能够操作的内核对象、即所有能够访问的资源。【这里其实也体现了线程和进程的概念之差，拥有共通共享的一些资源】</p>
<p>每个进程获取 capability 的方式有三种。</p>
<ol>
<li>在被创建时由父进程赋予；（fork）</li>
<li>在运行时向微内核申请获得；（grant）</li>
<li>由其他进程授予。（grant传播）</li>
</ol>
<p>Capability还能实现进程协作。比如说，若该内核对象是一个物理内存对象，则两个进程可以通过把它映射到各自的地址空间中从而建立<strong>共享内存</strong>；若该内核对象是一个通信对象，则两个进程可以通过调用其提供的方法进行<strong>IPC交互</strong>。【66666这个角度很有意思】</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>一个内核对象由<code>struct object</code>代表，其具体数据存储在<code>opaque</code>中。而一个内核对象对应在每个cap group的代表是<code>struct object_slot</code>，存储了对<code>struct object</code>的指针以及其他相关信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内核对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object</span> &#123;</span></span><br><span class="line">	u64 type;</span><br><span class="line">	u64 size;</span><br><span class="line">	<span class="comment">/* Link all slots point to this object */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">copies_head</span>;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> refcount;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * opaque marks the end of this struct and the real object will be</span></span><br><span class="line"><span class="comment">	 * stored here. Now its address will be 8-byte aligned.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u64 opaque[];	<span class="comment">// 可变长度成员字段</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// cap group指向内核对象的slot</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_slot</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> slot_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cap_group</span> *<span class="title">cap_group</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">object</span> *<span class="title">object</span>;</span></span><br><span class="line">	<span class="comment">/* link copied slots pointing to the same object */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">copies</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// cap group的指针数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slot_table</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> slots_size;</span><br><span class="line">	<span class="comment">// xiunian: pointer array</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">object_slot</span> **<span class="title">slots</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *full_slots_bmp;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *slots_bmp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rwlock</span> <span class="title">table_guard</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// cap group</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cap_group</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slot_table</span> <span class="title">slot_table</span>;</span>	<span class="comment">// pointer array</span></span><br><span class="line">	<span class="type">int</span> thread_cnt;	<span class="comment">// The number of threads</span></span><br><span class="line">	<span class="type">badge_t</span> badge;	<span class="comment">// pid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="特权与异常"><a href="#特权与异常" class="headerlink" title="特权与异常"></a>特权与异常</h2><p>AArch64采用“异常级别”这一概念定义程序执行时所拥有的特权级别，从低到高分别是 EL0、EL1、EL2 和 EL3。ChCore 中仅使用了其中的两个异常级别：EL0 和 EL1。其中，EL1 是内核模式，<code>kernel</code> 目录下的内核代码运行于此异常级别。EL0 是用户模式，<code>user</code> 目录下的用户库与用户程序代码运行在用户模式下。</p>
<p>在 AArch64 架构中，异常是指低特权级软件（如用户程序）请求高特权软件（例如内核中的异常处理程序）采取某些措施以确保程序平稳运行的系统事件【这个概括还挺精确的】，包含<strong>同步异常</strong>和<strong>异步异常</strong>：</p>
<ul>
<li>同步异常：<strong>通过直接执行指令产生的异常</strong>。同步异常的来源包括同步中止（synchronous abort）和一些特殊指令。当直接执行一条指令时，若取指令或数据访问过程失败，则会产生同步中止。此外，部分指令（包括 <code>svc</code> 等）通常被用户程序用于主动制造异常以请求高特权级别软件提供服务（如<strong>系统调用</strong>）。</li>
<li>异步异常：<strong>与正在执行的指令无关的异常</strong>。异步异常的来源包括普通中 IRQ、快速中断 FIQ 和系统错误 SError。IRQ 和 FIQ 是由其他与处理器连接的硬件产生的中断，系统错误则包含多种可能的原因。本实验不涉及此部分。</li>
</ul>
<p>发生异常后，处理器需要找到与发生的异常相对应的异常处理程序代码并执行。在 AArch64 中，存储于内存之中的异常处理程序代码被叫做异常向量（exception vector），而所有的异常向量被存储在一张异常向量表（exception vector table）中。AArch64 中的每个异常级别都有其自己独立的异常向量表，其虚拟地址由该异常级别下的异常向量基地址寄存器（<code>VBAR_EL3</code>，<code>VBAR_EL2</code> 和 <code>VBAR_EL1</code>）决定。每个异常向量表中包含 16 个条目，每个条目里存储着发生对应异常时所需执行的异常处理程序代码。如下图所示：</p>
<p><img src="/2024/07/27/chcore_lab/3-exception.png" alt="3-exception.png"></p>
<blockquote>
<p>FIQ（Fast Interrupt Request）是一种 ARM 架构中的中断类型，是特权模式中的一种，同时也属于异常模式一类。旨在提供比标准中断（IRQ）更高的优先级和更快的响应时间，用于高速数据传输或通道处理。</p>
<p>FIQ和IRQ是两种不同类型的中断，ARM为了支持这两种不同的中断，提供了对应的叫做FIQ和IRQ处理器模式（ARM有7种处理模式）。</p>
<p>为使FIQ模式响应更快，FIQ模式具有更多的影子（Shadow）寄存器。</p>
<p><img src="/2024/07/27/chcore_lab/image-20240807115729322.png" alt="image-20240807115729322"></p>
<p>FIQ 的优先级高于常规的 IRQ（Interrupt Request）。</p>
</blockquote>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="1-用户进程和线程"><a href="#1-用户进程和线程" class="headerlink" title="1.用户进程和线程"></a>1.用户进程和线程</h3><p>在 ChCore 中，第一个被创建的进程是 <code>procmgr</code>，是 ChCore 核心的系统服务。本实验将以创建 <code>procmgr</code> 为例探索在 ChCore 中如何创建进程，以及成功创建第一个进程后如何实现内核态向用户态的切换。</p>
<p>在内核完成必要的初始化之后，内核将会跳转到创建第一个用户程序的操作中，该操作通过调用 <code>create_root_thread</code> 函数完成，本函数完成第一个用户进程的创建。</p>
<p>创建用户程序至少需要包括创建对应的 <code>cap_group</code>、加载用户程序镜像并且切换到程序。</p>
<p><code>create_root_thread</code>的操作包括：</p>
<ol>
<li>从<code>procmgr</code>镜像中读取程序信息</li>
<li>调用<code>create_root_cap_group</code>创建第一个 <code>cap_group</code> 进程</li>
<li>创建第一个线程，加载着<code>procmgr</code>系统服务</li>
</ol>
<p>此外，用户程序也可以通过 <code>sys_create_cap_group</code> 系统调用创建一个全新的 <code>cap_group</code>。</p>
<p>由于 <code>cap_group</code> 也是一个内核对象，因此在创建 <code>cap_group</code> 时，需要通过 <code>obj_alloc</code> 分配全新的 <code>cap_group</code> 和 <code>vmspace</code> 对象（<code>TYPE_CAP_GROUP</code> 与 <code>TYPE_VMSPACE</code>）。对分配得到的 <code>cap_group</code> 对象，需要通过 <code>cap_group_init</code> 函数初始化并且设置必要的参数(Tip: size 参数已定义好 <code>BASE_OBJECT_NUM</code>)。对分配得到的 <code>vmspace</code> 对象则需要调用 <code>cap_alloc</code> 分配对应的槽（slot）。</p>
<blockquote>
<p>这部分的描述，可以看<code>docs/capability.md</code>，里面描述了cap的一般步骤：</p>
<ol>
<li><code>obj_alloc</code> allocates an object and returns a data area with user-defined length.</li>
<li>Init the object within the data area.</li>
<li><code>cap_alloc</code> allocate a cap for the inited object.</li>
</ol>
</blockquote>
<p>然而，完成 <code>cap_group</code> 的分配之后，用户程序并没有办法直接运行，因为<code>cap_group</code>只是一个资源集合的概念。<strong>线程才是内核中的调度执行单位</strong>，因此还需要进行线程的创建，将用户程序 ELF 的各程序段加载到内存中。</p>
<blockquote>
<p>练习 2: 在 <code>kernel/object/thread.c</code> 中完成 <code>create_root_thread</code> 函数，将用户程序 ELF 加载到刚刚创建的进程地址空间中。</p>
</blockquote>
<p>此处大概是这样的逻辑，先在内核地址空间虚拟地址kva映射对应的一块物理内存pa，然后在内核中将elf程序copy到pa中（<code>procmgr</code>已经包含在了kernel image中，所以只需一个<code>memcpy</code>即可），最后再把这个pa映射到用户虚拟地址空间中（每个section的具体地址在elf程序头表的ph_vaddr字段指定）。</p>
<p>值得注意的是，貌似在ChCore的建立第一个进程这一阶段用的是一个魔改版的elf格式？<strong>详情见小品环节1。</strong></p>
<blockquote>
<p>不过这里还是简单放一下经典elf文件格式吧。</p>
<p>ELF文件结构主要包括三个部分：ELF头、程序头表（可选，用于可执行文件和共享库）、节头表（用于目标文件和可执行文件）。</p>
<ul>
<li><p><strong>ELF头（ELF Header）</strong>：包含文件类型、架构、入口点、程序头表和节头表的偏移、表大小等基本信息。</p>
</li>
<li><p><strong>程序头表（Program Header Table）</strong>：描述程序执行所需的段（segments），如代码段、数据段等。</p>
</li>
<li><p><strong>节头表（Section Header Table）</strong>：描述文件中的各个节（sections），如符号表、字符串表等。</p>
</li>
</ul>
<p><img src="/2024/07/27/chcore_lab/d60c5639833356815b58909463619f7d.png" alt="img"></p>
<p><img src="/2024/07/27/chcore_lab/f66156cab150064bb3fe37b4c0d61d04.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_hdr</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT];     <span class="comment">/* 魔数和相关信息 */</span></span><br><span class="line">    Elf32_Half    e_type;                 <span class="comment">/* 目标文件类型 */</span></span><br><span class="line">    Elf32_Half    e_machine;              <span class="comment">/* 硬件体系 */</span></span><br><span class="line">    Elf32_Word    e_version;              <span class="comment">/* 目标文件版本 */</span></span><br><span class="line">    Elf32_Addr    e_entry;                <span class="comment">/* 程序进入点 */</span></span><br><span class="line">    Elf32_Off     e_phoff;                <span class="comment">/* 程序头部偏移量 */</span></span><br><span class="line">    Elf32_Off     e_shoff;                <span class="comment">/* 节头部偏移量 */</span></span><br><span class="line">    Elf32_Word    e_flags;                <span class="comment">/* 处理器特定标志 */</span></span><br><span class="line">    Elf32_Half    e_ehsize;               <span class="comment">/* ELF头部长度 */</span></span><br><span class="line">    Elf32_Half    e_phentsize;            <span class="comment">/* 程序头部中一个条目的长度 */</span></span><br><span class="line">    Elf32_Half    e_phnum;                <span class="comment">/* 程序头部条目个数  */</span></span><br><span class="line">    Elf32_Half    e_shentsize;            <span class="comment">/* 节头部中一个条目的长度 */</span></span><br><span class="line">    Elf32_Half    e_shnum;                <span class="comment">/* 节头部条目个数 */</span></span><br><span class="line">    Elf32_Half    e_shstrndx;             <span class="comment">/* 节头部字符表索引 */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_phdr</span>&#123;</span></span><br><span class="line">  Elf32_Word  p_type;        <span class="comment">/* 段类型 */</span></span><br><span class="line">  Elf32_Off   p_offset;      <span class="comment">/* 段位置相对于文件开始处的偏移量 */</span></span><br><span class="line">  Elf32_Addr  p_vaddr;       <span class="comment">/* 段在内存中的地址 */</span></span><br><span class="line">  Elf32_Addr  p_paddr;       <span class="comment">/* 段的物理地址 */</span></span><br><span class="line">  Elf32_Word  p_filesz;      <span class="comment">/* 段在文件中的长度 */</span></span><br><span class="line">  Elf32_Word  p_memsz;       <span class="comment">/* 段在内存中的长度 */</span></span><br><span class="line">  Elf32_Word  p_flags;       <span class="comment">/* 段的标记 */</span></span><br><span class="line">  Elf32_Word  p_align;       <span class="comment">/* 段在内存中对齐标记 */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>

</blockquote>
<p>再之后调用<code>init_thread_ctx</code>进行上下文初始化，然后通过<code>sched</code>选取到第一个程序进行运行，最后再一系列辗转调用eret回到用户态，从而开始运行。</p>
<p>然而，此时 ChCore 尚未配置从用户模式（EL0）切换到内核模式（EL1）的相关内容，在尝试执行 <code>svc</code> 指令时会出错，故而接下来完成对异常处理的配置。</p>
<h3 id="2-异常向量表"><a href="#2-异常向量表" class="headerlink" title="2.异常向量表"></a>2.异常向量表</h3><p>在 ChCore 中，仅使用了 EL0 和 EL1 两个异常级别，因此仅需要对 EL1 异常向量表进行初始化即可。</p>
<p>在本实验中，ChCore 内除系统调用外所有的同步异常均交由 <code>handle_entry_c</code> 函数进行处理。遇到异常时，硬件将根据 ChCore 的配置执行对应的汇编代码，将异常类型和当前异常处理程序条目类型作为参数传递，对于 sync_el1h 类型的异常，跳转 <code>handle_entry_c</code> 使用 C 代码处理异常。对于 irq_el1t、fiq_el1t、fiq_el1h、error_el1t、error_el1h、sync_el1t 则跳转 <code>unexpected_handler</code> 处理异常。</p>
<p>由注释：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">* The selected <span class="built_in">stack</span> pointer can be indicated by a suffix to the Exception Level:</span><br><span class="line">*  - t: SP_EL0 is used</span><br><span class="line">*  - h: SP_ELx is used</span><br></pre></td></tr></table></figure>

<p>可知依次需要跳转的标签名的后缀顺序为t-h-64-32，并且每个跳转指令之间需要按照0x80对齐，所以需要间隔31个nop指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b sync_el1t</span><br><span class="line">.rept 31</span><br><span class="line">nop</span><br><span class="line">.endr</span><br><span class="line">b irq_el1t</span><br><span class="line">.rept 31</span><br><span class="line">nop</span><br><span class="line">.endr</span><br><span class="line">b fiq_el1t</span><br><span class="line">.rept 31</span><br><span class="line">nop</span><br><span class="line">.endr</span><br><span class="line">b error_el1t</span><br><span class="line">.rept 31</span><br><span class="line">nop</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure>

<p>然后我也是之后看别人的代码才发现，原来还可以这么写，学到了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.macro	exception_entry	label</span><br><span class="line">	/* Each entry of the exeception table should be 0x80 aligned */</span><br><span class="line">	.align	7</span><br><span class="line">	b	\label</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">	exception_entry sync_el1t</span><br><span class="line">	exception_entry irq_el1t</span><br><span class="line">	exception_entry fiq_el1t</span><br><span class="line">	exception_entry error_el1t</span><br></pre></td></tr></table></figure>

<h3 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3.系统调用"></a>3.系统调用</h3><p>通过异常进入到内核后，ChCore在<code>exception_enter</code> 宏进行现场保存，在<code>exception_exit</code>宏进行现场恢复。保存时在栈中应准备<code>ARCH_EXEC_CONT_SIZE</code>大小的空间。</p>
<p>完成保存后，需要进行<strong>内核栈切换</strong>，首先从<code>TPIDR_EL1</code>寄存器中读取到当前核的<code>per_cpu_info</code>（参考<code>kernel/include/arch/aarch64/arch/machine/smp.h</code>），从而拿到其中的<code>cpu_stack</code>地址。</p>
<p>在本实验中新加入了 <code>libc</code> 文件，用户态程序可以链接其编译生成的<code>libc.so</code>，并通过 <code>libc</code> 进行系统调用从而进行向内核态的异常切换。实验接下来将对 <code>printf</code> 函数（<code>user/chcore-libc/musl-libc/src/stdio/printf.c</code>）的调用链进行分析与探索。</p>
<p><code>printf</code> 函数调用了 <code>vfprintf</code>，其中文件描述符参数为 <code>stdout</code>。这说明在 <code>vfprintf</code> 中将使用 <code>stdout</code> 的某些操作函数。</p>
<p>在 <code>user/chcore-libc/musl-libc/src/stdio/stdout.c</code>中可以看到 <code>stdout</code> 的 <code>write</code> 操作被定义为 <code>__stdout_write</code>，之后调用到 <code>__stdio_write</code> 函数。</p>
<p>最终 <code>printf</code> 函数将调用到 <code>chcore_stdout_write</code>。</p>
<blockquote>
<p>思考 7: 尝试描述 <code>printf</code> 如何调用到 <code>chcore_stdout_write</code> 函数。</p>
<p>提示：<code>chcore_write</code> 中使用了文件描述符，<code>stdout</code> 描述符的设置在<code>user/chcore-libc/musl-libc/src/chcore-port/syscall_dispatcher.c</code> 中。</p>
<p>可以看到在<code>user/chcore-libc/musl-libc/src/chcore-port/syscall_dispatcher.c</code>中设置了stdout的默认fdop：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_ops</span> <span class="title">stdout_ops</span> =</span> &#123;</span><br><span class="line">        .read = chcore_stdio_read,</span><br><span class="line">        .write = chcore_stdout_write,</span><br><span class="line">        .close = chcore_stdout_close,</span><br><span class="line">        .poll = chcore_stdio_poll,</span><br><span class="line">        .ioctl = chcore_stdio_ioctl,</span><br><span class="line">        .fcntl = chcore_stdio_fcntl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>chcore_stdout_write</code> 中的核心函数为 <code>put</code>，此函数的作用是向终端输出一个字符串。</p>
<p>从 <code>printf</code> 的例子我们也可以看到<strong>从通用 api 向系统相关 abi 的调用过程</strong>，并最终通过系统调用完成从用户态向内核态的异常切换。</p>
<h2 id="小品环节-2"><a href="#小品环节-2" class="headerlink" title="小品环节"></a>小品环节</h2><h3 id="ELF加载"><a href="#ELF加载" class="headerlink" title="ELF加载"></a>ELF加载</h3><p>不知道为什么，<code>procmgr</code>被设计为不是正规的ELF文件格式，而是魔改版ELF……</p>
<p>具体来说，我们可以看看编译生成<code>procmgr</code>镜像的cmake代码：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(</span><br><span class="line">    create-procmgr-bin ALL</span><br><span class="line">    <span class="keyword">COMMAND</span> echo <span class="string">&quot;build procmgr binary...&quot;</span></span><br><span class="line">    <span class="keyword">COMMAND</span> read_procmgr_elf_tool <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/procmgr.srv</span><br><span class="line">    <span class="keyword">COMMAND</span> chmod <span class="number">666</span> elf_info.temp</span><br><span class="line">    <span class="keyword">COMMAND</span> cat elf_info.temp procmgr.bin &gt; procmgr</span><br><span class="line">    <span class="keyword">COMMAND</span> rm -f <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/elf_info.temp</span><br><span class="line">    <span class="keyword">COMMAND</span> echo <span class="string">&quot;build procmgr success!&quot;</span></span><br><span class="line">    DEPENDS procmgr.srv procmgr.bin)</span><br></pre></td></tr></table></figure>

<p>其中，<code>procmgr.srv</code>为正统的ELF格式，通过<code>readelf</code>工具可读。它只包含elf header和程序头表。</p>
<blockquote>
<p>可以通过<code>readelf -h build/user/system-services/system-servers/procmgr/procmgr.srv</code>和<code>readelf -l build/user/system-services/system-servers/procmgr/procmgr.srv</code>来读取其elf头和程序头表。</p>
</blockquote>
<p>然后可以看到，他这里大概是做了这么个操作，首先是使用了他们docker环境自带的一个工具<code>read_procmgr_elf_tool</code>将这个.srv文件转化为了<code>elf_info.temp</code>，再把这个.tmp和.bin文件合二为一成为最终的<code>procmgr</code>映像。</p>
<p>我们可以来看看这个.tmp文件里到底存了啥，跟正宗elf有什么不一样。</p>
<p>首先这个是<code>elf_info.temp</code>：</p>
<p><img src="/2024/07/27/chcore_lab/image-20240805231453013.png" alt="image-20240805231453013"></p>
<p>这个是<code>procmgr.srv</code>：</p>
<p><img src="/2024/07/27/chcore_lab/image-20240805230347173.png" alt="image-20240805230347173"></p>
<p>可以看到，蓝色部分其实就跟.tmp文件的内容差不多，.tmp文件大概是对ELF格式进行了一定的魔改。具体来说，它照搬了程序头表基本不变（自.tmp文件的0x40开始的位置，小端），然后又对标准的ELF Header进行了增删魔改（而且还变成了大端形式），最终形成了这么一个大小为48(elf header)+56*3(phdr size)=216大小的首部。</p>
<p>这还不是最幽默的，还有一点，就是他还改了程序头表的<code>ph_offset</code>字段！</p>
<p><code>ph_offset</code>字段的原意是该程序头对应的segment离文件开始的偏移量，并且会按照其<code>ph_align</code>字段进行地址对齐。在.srv中，每个程序头表项的align都为0x1000（PAGE_SIZE），故而，其offset字段情况如下图所示：</p>
<p><img src="/2024/07/27/chcore_lab/image-20240806160045163.png" alt="image-20240806160045163"></p>
<p>然而，生成的<code>elf_info.temp</code>的第一个offset字段被置为了0，也就是说一个segment的起始地址应该为 文件起始地址+216(首部大小)+offset。</p>
<p><img src="/2024/07/27/chcore_lab/image-20240805232202424.png" alt="image-20240805232202424"></p>
<p><img src="/2024/07/27/chcore_lab/image-20240805232224641.png" alt="image-20240805232224641"></p>
<p>以上的这几种细节，以及全然未提及相关信息的指导书（只说加载ELF程序……但我寻思这也不是ELF啊），使我在这部分struggle了许久，对offset改来改去毫无思路，不清楚为什么读出来会是0，也不清楚是否需要按页对齐（反正对不对齐其实试出来都是错的hhh）。最终发现错误也比较偶然，大概是盯着那堆ELF相关宏抓耳挠腮时，开始好奇这个<code>#define ROOT_BIN_HDR_SIZE 216</code>的216是怎么来的，算了一下发现标准的ELF格式其实应该是232(64+56*3)才对，然后又想到之前配环境一通折腾时就看不懂的那段cmake指令，以及细看才发现前面读elf header时更是古怪（原谅我写的时候前面直接跳过没仔细看了……），才意识到原来用的不是标准ELF，而是魔改版的……</p>
<p>不过，我不大懂这里为啥要用魔改版这么复杂曲折，我翻了翻<a href="https://github.com/WilliamX1/ChCore/blob/lab3/kernel/object/thread.c">往年的实验版本</a>包括隔壁xv6也都是用的标准ELF格式。难道是为了读取方便统一用8字节，或者节省image大小……但指导书怎么没提及这一点呢，莫非是我孤陋寡闻了……</p>
<blockquote>
<p>后续：</p>
<p>procmgr负责进程生态的管理，如果要新建进程，也是向procmgr发送相关消息即可，它会先读入elf，再调用<code>elf_so_loader_launch_process</code>，最终调用<code>launch_process_with_pmos_caps</code>函数进行和内核差不多的操作，如创建内存空间创建主线程等。这里就是一个非常纯粹的微内核了，创建进程这种大活都被放到了userspace。</p>
<p>可能就是因为这样，内核就仅保留一个小的魔改版elf了。</p>
</blockquote>
<h1 id="Lab4-多核调度与IPC"><a href="#Lab4-多核调度与IPC" class="headerlink" title="Lab4: 多核调度与IPC"></a>Lab4: 多核调度与IPC</h1><p>在本实验中，ChCore将支持在多核处理器上启动；实现多核调度器以调度执行多个线程；最后实现进程间通信IPC。代码部分都相对简单，更多还是需要理解IPC通信流程。</p>
<h2 id="多核启动"><a href="#多核启动" class="headerlink" title="多核启动"></a>多核启动</h2><p>为了让ChCore支持多核，我们需要考虑如下问题：</p>
<ol>
<li><p>如何启动多核，让每个核心执行初始化代码并开始执行用户代码？ </p>
<p><code>wait_until_smp_enabled</code>→<code>secondary_init_c</code>→</p>
<p><img src="/2024/07/27/chcore_lab/image-20240806193556997.png" alt="image-20240806193556997"></p>
<p><img src="/2024/07/27/chcore_lab/image-20240806193002773.png" alt="image-20240806193002773"></p>
</li>
<li><p>如何区分不同核心在内核中保存的数据结构（比如状态，配置，内核对象等）？</p>
<p>ChCore对于内核中需要每个CPU核心单独存一份的内核对象，利用一个数组来保存，CID作为数组的索引。</p>
<p>ChCore支持的核心数量为<code>PLAT_CPU_NUM</code>。</p>
<p>smp_get_cpu_id函数通过访问系统寄存器tpidr_el1来获取调用它的CPU核心的ID。</p>
</li>
<li><p> 如何保证内核中对象并发正确性，确保不会由于多个核心同时访问内核对象导致竞争条件？ </p>
</li>
</ol>
<blockquote>
<p>思考题 2：阅读汇编代码kernel/arch/aarch64/boot/raspi3/init/start.S, init_c.c以及kernel/arch/aarch64/main.c，解释用于阻塞其他CPU核心的secondary_boot_flag是物理地址还是虚拟地址？是如何传入函数enable_smp_cores中，又是如何赋值的（考虑虚拟地址/物理地址）？</p>
</blockquote>
<p>真无敌了我刚刚就在研究这个，结果他居然正好也问了。</p>
<p><code>enable_smp_cores</code>中的<code>secondary_boot_flag</code>为虚拟地址，此时已经开启了MMU，所以直接写入然后再保障缓存一致性就没什么问题。</p>
<p>然后在main中传入的这个<code>boot_flag</code>是物理地址，是通过main函数参数传递进来的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">paddr_t</span> boot_flag, <span class="type">void</span> *info)</span></span><br><span class="line">	<span class="comment">/* Other cores are busy looping on the boot_flag, wake up those cores */</span></span><br><span class="line">	<span class="title function_">enable_smp_cores</span><span class="params">(boot_flag)</span>;</span><br></pre></td></tr></table></figure>

<p>然后感觉前面的就都是地址了，应该都是靠的参数传。</p>
<h2 id="多核调度"><a href="#多核调度" class="headerlink" title="多核调度"></a>多核调度</h2><p>【要来到我的老本行了，激动激动】</p>
<p>ChCore对于调度策略的抽象可以看到也是经典的调度类模式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Provided Scheduling Policies */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_ops</span> <span class="title">pbrr</span>;</span>	<span class="comment">/* Priority Based Round Robin */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_ops</span> <span class="title">pbfifo</span>;</span>	<span class="comment">/* Priority Based FIFO */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_ops</span> <span class="title">rr</span>;</span>	<span class="comment">/* Simple Round Robin */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_ops</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*sched_init)(<span class="type">void</span>);</span><br><span class="line">    <span class="comment">// pnt, 将正在运行的线程放回就绪队列，然后在就绪队列中选择下一个需要执行的线程</span></span><br><span class="line">    <span class="type">int</span> (*sched)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*sched_periodic)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*sched_enqueue)(<span class="keyword">struct</span> thread * thread);</span><br><span class="line">    <span class="type">int</span> (*sched_dequeue)(<span class="keyword">struct</span> thread * thread);</span><br><span class="line">    <span class="comment">/* Debug tools */</span></span><br><span class="line">    <span class="type">void</span> (*sched_top)(<span class="type">void</span>) ;<span class="comment">// 打印当前所有核心上的运行线程以及等待线程的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其他的就没啥好说了，因为毕竟调度这块还是比较经典的宏内核做法，这部分主要就是跟着写了个rr和初始化了一下时钟，大部分还是偏了解为主。这里就记录一点关于FPU的东西吧。</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/548957617#:~:text=%E5%9C%A8%E8%AE%BE%E8%AE%A1%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%9C%89%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88">关于FPU</a></p>
<p><strong>内核线程没有FPU状态？</strong></p>
<ol>
<li><strong>内核线程通常不使用FPU</strong>：在许多操作系统中，内核线程主要负责执行内核态的任务，这些任务通常不涉及浮点运算，因此没有必要为这些线程保存和恢复FPU状态。</li>
<li><strong>性能考虑</strong>：保存和恢复FPU状态会增加线程切换的开销。如果内核线程不使用FPU，则不需要在切换时处理FPU状态，这可以提升系统性能。</li>
</ol>
<p><strong>软件浮点运算</strong></p>
<p>在没有FPU的情况下，浮点运算是通过一系列的整数运算和逻辑操作实现的。这通常涉及调用特定的库函数或由编译器生成相应的代码来模拟浮点运算。软件浮点运算的特点包括：</p>
<ol>
<li><strong>慢速</strong>：因为每一个浮点操作都需要多个机器指令来完成。</li>
<li><strong>复杂性</strong>：实现浮点运算的函数比较复杂，涉及到多步操作。</li>
</ol>
<p><strong>硬件浮点运算（使用FPU）</strong></p>
<p>FPU是专门用于执行浮点运算的硬件单元。使用FPU的特点包括：</p>
<ol>
<li><strong>快速</strong>：浮点运算可以在一个或几个时钟周期内完成，极大地提高了计算速度。</li>
<li><strong>简便</strong>：编译器可以直接生成使用FPU指令的代码，简化了浮点运算的实现。</li>
</ol>
<p>如果需要在内核线程中执行浮点运算，可以通过以下方式实现：</p>
<ol>
<li><strong>启用FPU使用</strong>：允许内核线程使用FPU，并在上下文切换时保存和恢复FPU状态。</li>
<li><strong>特定处理</strong>：在需要时，特定的内核线程可以启用FPU，进行计算，然后禁用FPU，并将结果返回。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kernel_fpu_begin();      <span class="comment">// 开始使用FPU</span></span><br><span class="line"></span><br><span class="line">b = b * <span class="number">5</span> - <span class="number">1.5</span>;</span><br><span class="line">a = a * <span class="number">100</span> / <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">kernel_fpu_end();        <span class="comment">// 结束使用FPU</span></span><br></pre></td></tr></table></figure>

</blockquote>
<h2 id="进程IPC通信"><a href="#进程IPC通信" class="headerlink" title="进程IPC通信"></a>进程IPC通信</h2><p>【激动！】</p>
<p>在本部分，我们将实现ChCore的进程间通信，从而允许跨地址空间的两个进程可以使用IPC进行信息交换。</p>
<p><img src="/2024/07/27/chcore_lab/IPC-overview.png" alt="img"></p>
<p>ChCore的IPC接口不是传统的send/recv接口，而是采用了客户端/服务器模型，并且采取了简单的Thread Migration机制。接下来，将以一次IPC通信为例，介绍ChCore的IPC机制。</p>
<p>在具体的流程之前，我们可以先简单回想一下基于线程迁移的IPC是什么个形式。</p>
<p>大概是这样，Server那端会提供一个特殊的线程，仅在Client发送IPC请求时才会被调度执行。然后如果需要通信，双方需要先建立连接，从而对通信过程中需要的例如函数、参数以及共享内存等进行一个申请和初始化。连接建立后，Client中的线程A如果想发起IPC调用Server的某些函数，那么A就会把自己直接上下文切换到Server端，在Server端的进程上下文中执行完再迁移回到Client进程的上下文中。与此同时可以通过共享内存来实现信息的交流。</p>
<p>在ChCore中，Server那端特殊的线程即被称为<code>TYPE_SHADOW</code>。这些线程没有<strong>调度的</strong>上下文（也即时间片之类），会直接继承Client发起请求线程的时间片。与此同时，ChCore还有另一种特殊的shadow线程，类型被标记为<code>TYPE_REGISTER</code>，来实现兼容线程迁移的连接建立（而非传统send/recv）。</p>
<p>接下来，将介绍ChCore的具体实现。</p>
<h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><h4 id="Server-init"><a href="#Server-init" class="headerlink" title="Server init"></a>Server init</h4><p>Server调用<code>register_server</code>将自己注册为服务端。具体来说，该函数会通过系统调用<code>sys_register_server</code>注册三个回调函数，写入内核的meta data中（<code>struct thread</code>的<code>general_config</code>字段）。</p>
<ol>
<li><p><code>server_destructor</code>：析构器，仅记录其函数指针</p>
</li>
<li><p><code>client_register_handler</code>：创建连接回调，会为其创建对应的shadow线程（<code>TYPE_REGISTER</code>，下称register_cb thread）</p>
</li>
<li><p><code>server_handler</code>：Server的具体处理逻辑，暂时仅记录其函数指针</p>
<p>是最体现service本身具体功能的部分了。对于procmgr，其服务功能就是了解进程的状态并且进行管理；而对于pipe，其服务功能就是响应对管道的读写请求。</p>
</li>
</ol>
<p>至此，Server即处于监听状态，shadow线程register cb静默，直到Client端发来连接请求。</p>
<h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><ol>
<li><p>Client端初始化</p>
<p>Client调用<code>register_client</code>来主动建立IPC connection。</p>
<p>具体来说，该函数及其相关系统调用流程如下：</p>
<ol>
<li><p>申请一块物理内存pmo作为共享内存SHM，并且在自己的vmspace中映射</p>
</li>
<li><p>在双方的cap group创建SHM对象</p>
<blockquote>
<p>PS: 相信大家看到这应该也会和我有同样的疑惑，此处在Client上下文中是怎么获取Server的呢？</p>
<p>分析请见下一模块<code>相关细节-server cap</code></p>
</blockquote>
</li>
<li><p>在双方的cap group创建IPC connection对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_connection</span> &#123;</span></span><br><span class="line">	<span class="comment">// Note that all threads in the client process can use this connection.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">current_client_thread</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">server_handler_thread</span>;</span></span><br><span class="line">	<span class="type">badge_t</span> client_badge;	<span class="comment">// pid</span></span><br><span class="line">    <span class="comment">// SHM相关信息，如在双方的cap和vaddr，以及SHM大小</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shm_for_ipc_connection</span> <span class="title">shm</span>;</span></span><br><span class="line">	<span class="comment">/* For resource recycle */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">ownership</span>;</span></span><br><span class="line">	<span class="type">cap_t</span> conn_cap_in_client;</span><br><span class="line">	<span class="type">cap_t</span> conn_cap_in_server;</span><br><span class="line">	<span class="type">int</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>重置register_cb thread</p>
<p>重置入口、栈地址等，并且设置参数为server handler。</p>
</li>
<li><p>上下文切换到register_cb thread，去完成Server端的初始化</p>
</li>
</ol>
</li>
<li><p>Server端初始化</p>
<p>Server端通过<code>register_cb thread</code>来进行连接的初始化。</p>
<p>具体来说，该函数及其相关系统调用<code>sys_ipc_register_cb_return</code>流程如下：</p>
<ol>
<li>创建shadow线程server handler</li>
<li>映射SHM到自己的vmspace</li>
<li>重置server handler thread</li>
<li>上下文切换回Client端线程，回到userspace</li>
</ol>
</li>
</ol>
<p>至此，连接成功建立，shadow线程server handler静默，直到Client端发送ipc请求。</p>
<h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><ol>
<li>Client端在共享内存中写入msg，包含请求函数和相关参数</li>
<li>调用系统调用<code>ipc_call</code>，上下文切换到Server端执行server handler</li>
<li>server handler执行结束后调用<code>ipc_return</code>（带返回结果），回到Client端上下文继续执行</li>
</ol>
<h3 id="相关细节"><a href="#相关细节" class="headerlink" title="相关细节"></a>相关细节</h3><h4 id="server-cap"><a href="#server-cap" class="headerlink" title="server cap"></a>server cap</h4><p><code>register_client</code>通过系统调用参数的server cap从而获取到其pmo的Server thread。然而既然用到了server cap那就说明server thread处在client的cap group中，那么Client是如何将想要连接的server加入到自己的cap group从而获取server cap的？</p>
<p>之前的实验告诉我们这两点：</p>
<ol>
<li>ChCore的第一个进程是procmgr</li>
<li>所有进程的创建都需要经过procmgr</li>
<li>子进程可以继承父进程的cap group</li>
<li>父进程的cap group会记录其所有子进程的cap</li>
</ol>
<p>所以，答案显而易见，世界是一个巨大的ipc：</p>
<ol>
<li>所有进程都是procmgr的子孙，故而procmgr拥有所有进程的cap，所有进程也都拥有procmgr的cap（cap[0]）。创建顺序是procmgr-&gt;system service-&gt;user process。</li>
<li>所有进程都是procmgr的子孙，故而procmgr拥有所有进程的cap信息。client可以通过IPC向procmgr请求它所需要获取的服务的cap，procmgr会帮你填入<code>thread-&gt;cap_buffer</code>（&lt;int, int&gt;映射）。</li>
</ol>
<h4 id="thread-migration"><a href="#thread-migration" class="headerlink" title="thread migration"></a>thread migration</h4><p>可以看到，ChCore这边就是一个非常纯粹的Thread Migration实现逻辑。相比于Linux等还有些把进程线程概念稍微等同的倾向（虽然实际实现不怎么等同了），ChCore直接用cap group和thread来彻底切割了，process仅仅提供逻辑和一些资源环境，所以真正执行逻辑的线程就可以进程之间到处乱窜了。</p>
<p>只不过这个迁移实现确实还是没我之前想得那么高大上（）其实说白话，就相当于client thread主动放弃自己的CPU，然后定向把自己CPU丢给server thread，然后为了确保公平性就共享时间片这样。我原来还觉得可能是实体性的迁移，还觉得太牛逼了怎么实现的，不过你说这是线程迁移吧也确实，所以可能高度抽象的理论和具体实现之间总会有这种期望的落差哈哈……</p>
<p>不过可以看出，这样的线程迁移确实性能上会有些忧虑。虽然它也算是减少了原有IPC设计上的开销，</p>
<blockquote>
<p>thread migration相比传统的IPC可以减少两次调度开销。</p>
<p>正统的线程间通信大概是这样的流程，有一个notification对象，然后server handler初始化建立完之后就block在这个对象上。client调用一个send，就相当于对这个notification进行一个唤醒操作并且block在上面，server handler醒来然后读共享内存完成任务，之后再notify client就可以。</p>
<p>值得注意的是唤醒完之后，需要加入调度队列并且再进行上下文切换，所以这样一来一共其实就是两次调度开销+两次上下文切换，相比于thread migration=两次上下文切换。</p>
</blockquote>
<p>但其带来的页表切换、特权级切换、Cache/TLB刷新、更少的编译优化等性能问题还是会让人担忧。</p>
<p>除此之外，值得注意的是，Server端只有一个register cb，但是每个连接都有对应的server handler。故而register的时候是需要retry的。</p>
<h4 id="信息交互"><a href="#信息交互" class="headerlink" title="信息交互"></a>信息交互</h4><p>关于信息交互，感觉它还算是提供了比较丰富的接口，可以通过共享内存交互，也可以有常规的返回值，还可以通过cap group，在<code>sys_ipc_call</code>的时候会把client的cap copy给server，然后return的时候会把server的cap copy给client。</p>
<ol>
<li><p>常规返回值</p>
<p>这个就比较典了，在<code>ipc_return</code>的时候设一下返回寄存器就差不多了。</p>
</li>
<li><p>capability</p>
<p>在server handler中或者client中可以设定想要拷贝给client的cap们：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ipc_set_msg_return_cap_num(ipc_msg, <span class="number">1</span>);</span><br><span class="line">ipc_set_msg_cap(ipc_msg, <span class="number">0</span>, mpinfo-&gt;fs_cap);</span><br></pre></td></tr></table></figure>

<p>然后在<code>ipc_return</code>或者<code>ipc_call</code>中会调用<code>ipc_send_cap</code>，从而能够进行cap的传播授权。</p>
</li>
<li><p>共享内存</p>
<p>用来传递ipc msg。值得注意的是，很多地方在跟system service进行交互的时候，都是使用了这样的宏来作为创建消息时的icb（ipc control block，只用于client端）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fsm_ipc_struct     (__fsm_ipc_struct_location())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lwip_ipc_struct    (__net_ipc_struct_location())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> procmgr_ipc_struct (__procmgr_ipc_struct_location())</span></span><br></pre></td></tr></table></figure>

<p>这其实是为了性能起见，让每个thread都内置一个一对一的connection icb，而非像其他service一样支持多thread对一connection，从而提高系统服务的可扩展性（这点在鸿蒙论文也提到了）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ipc_struct for invoking system servers.</span></span><br><span class="line"><span class="comment"> * fsm_ipc_struct and lwip_ipc_struct are two addresses.</span></span><br><span class="line"><span class="comment"> * They can be used like **const** pointers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If a system server is related to the scalability (multi-threads) of</span></span><br><span class="line"><span class="comment"> * applications, we should use the following way to make the connection with it</span></span><br><span class="line"><span class="comment"> * as per-thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For other system servers (e.g., process manager), it is OK to let multiple</span></span><br><span class="line"><span class="comment"> * threads share a same connection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ipc_struct_t</span> *__fsm_ipc_struct_location(<span class="type">void</span>);</span><br><span class="line"><span class="type">ipc_struct_t</span> *__net_ipc_struct_location(<span class="type">void</span>);</span><br><span class="line"><span class="type">ipc_struct_t</span> *__procmgr_ipc_struct_location(<span class="type">void</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * **fsm_ipc_struct** is an address that points to the per-thread</span></span><br><span class="line"><span class="comment"> * system_ipc_fsm in the pthread_t struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ipc_struct_t</span> *__fsm_ipc_struct_location(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;__pthread_self()-&gt;system_ipc_fsm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也因此，在写这类system service的消息结构体的时候需要尤其注意初始化问题……（本人后面在写lab5 FSM的时候就被坑得巨惨）它是直接的覆写（比如在<code>ipc_create_msg</code>中），不会帮你在覆写前memset一下。</p>
<p><img src="/2024/07/27/chcore_lab/image-20240809165526574.png" alt="image-20240809165526574"></p>
</li>
</ol>
<h1 id="Lab5-虚拟文件系统"><a href="#Lab5-虚拟文件系统" class="headerlink" title="Lab5: 虚拟文件系统"></a>Lab5: 虚拟文件系统</h1><p>虚拟文件系统（Virtual File System，VFS）提供了一个抽象层，使得不同类型的文件系统可以在应用程序层面以统一的方式进行访问。当应用程序发出文件操作请求时（如打开文件、读取文件等），这些请求首先会经过 VFS 层。VFS 根据文件路径解析出具体的文件系统，然后将操作请求委托给相应的文件系统驱动程序执行。</p>
<p>在 ChCore 中，我们通过 FSM 系统服务以及 FS_Base 文件系统 wrapper 将不同的文件系统整合起来，给运行在 ChCore 上的应用提供了统一的抽象。只要实现了 FSBase 和 FSWrapper 的接口的 IPC 服务，都可以成为一个文件系统示例。【这就是一种多态了】</p>
<h2 id="FSM"><a href="#FSM" class="headerlink" title="FSM"></a>FSM</h2><p>FSM是一个system service，用来管理运行在ChCore上的多个文件系统，可以处理如下类型的请求：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Client send fsm_req to FSM */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fsm_req_type</span> &#123;</span></span><br><span class="line">        FSM_REQ_UNDEFINED = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        FSM_REQ_PARSE_PATH,	<span class="comment">// 根据路径识别挂载点，从而识别文件系统，返回文件系统对应的service cap，其实跟procmgr的GET_SERVER_CAP差不多同一个意思</span></span><br><span class="line">        FSM_REQ_MOUNT,	<span class="comment">// 挂载某个文件系统</span></span><br><span class="line">        FSM_REQ_UMOUNT,	<span class="comment">// 卸载</span></span><br><span class="line"></span><br><span class="line">        FSM_REQ_SYNC,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>练习1：阅读 <code>user/chcore-libc/libchcore/porting/overrides/src/chcore-port/file.c</code> 的 <code>chcore_openat</code> 函数，分析 ChCore 是如何处理 <code>openat</code> 系统调用的，关注 IPC 的调用过程以及 IPC 请求的内容。</p>
<ol>
<li><p>准备：alloc一个fd、形成完整路径名</p>
<p>chcore使用的是一个全局的fd table，以无锁map形式实现，也是经典的微内核特色。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Global fd desc table */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_desc</span> *<span class="title">fd_dic</span>[<span class="title">MAX_FD</span>] =</span> &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>向fsm发送一个<code>FSM_REQ_PARSE_PATH</code>请求获取mount id</p>
</li>
<li><p>向fs发送<code>FS_REQ_OPEN</code>请求</p>
</li>
</ol>
</blockquote>
<p>从<code>openat</code>的调用也可以看出FSM和FS的解耦。FSM只负责挂载/卸载和把FS的cap交给用户，获取完cap之后用户就直接访问FS service了。</p>
<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>在看如何实现mount之前，可以先探究一下fsm的启动流程。</p>
<p>procmgr启动tmpfs和fsm两个service process：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">boot_default_servers</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        srv_path = <span class="string">&quot;/tmpfs.srv&quot;</span>;</span><br><span class="line">        proc_node = procmgr_launch_basic_server(<span class="number">1</span>, &amp;srv_path, <span class="string">&quot;tmpfs&quot;</span>, <span class="literal">true</span>, INIT_BADGE);</span><br><span class="line">        tmpfs_cap = proc_node-&gt;proc_mt_cap;</span><br><span class="line">        set_tmpfs_cap(tmpfs_cap);</span><br><span class="line"></span><br><span class="line">        srv_path = <span class="string">&quot;/fsm.srv&quot;</span>;</span><br><span class="line">        proc_node = procmgr_launch_basic_server(<span class="number">1</span>, &amp;srv_path, <span class="string">&quot;fsm&quot;</span>, <span class="literal">true</span>, INIT_BADGE);</span><br><span class="line">        fsm_server_cap = proc_node-&gt;proc_mt_cap;</span><br><span class="line">        fsm_ipc_struct-&gt;server_id = FS_MANAGER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，FSM启动后会在main函数挂载tmpfs（这也是procmgr里面那个初始化顺序的原因），挂载的大概操作是先向procmgr发请求拿tmpfs的cap，然后再初始化mount info结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init_fsm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        <span class="comment">/* Initialize */</span></span><br><span class="line">        init_utils();</span><br><span class="line">        <span class="comment">// xiunian: firstly mount a tmpfs in boot</span></span><br><span class="line">        ret = fsm_mount_fs(<span class="string">&quot;/tmpfs.srv&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，FSM会打开一个跟FS的connection，用以后续跟FS service进行交互。</p>
<p>以此类推，其它FS的挂载操作其实也差不多，只不过稍显复杂一些。</p>
<p>发起挂载请求之后，会首先调用<code>mount_storage_device</code>获取FS对应的cap。而在初次调用该函数时，该函数会先读取MBR引导扇区，获知本机的磁盘分区信息，获取对应的FS类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MBR_MAX_PARTS_CNT; i++) &#123;</span><br><span class="line">        pinfo = (<span class="type">partition_struct_t</span> *)(mbr + SD_PARTITION_INFO_OFFSET</span><br><span class="line">                                       + i * SD_PARTITION_INFO_SIZE);</span><br><span class="line">        dparts[i].valid = pinfo-&gt;fs_id ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        dparts[i].partition_index = i + <span class="number">1</span>;</span><br><span class="line">        dparts[i].mounted = <span class="literal">false</span>;</span><br><span class="line">        dparts[i].partition_lba = pinfo-&gt;lba;</span><br><span class="line">        <span class="keyword">if</span> (pinfo-&gt;fs_id == FAT32_PARTITION) &#123;</span><br><span class="line">                <span class="comment">/* FAT32 */</span></span><br><span class="line">                dparts[i].partition_type = FAT32_PARTITION;</span><br><span class="line">                dparts[i].server_id = SERVER_FAT32_FS;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pinfo-&gt;fs_id == EXT4_PARTITION) &#123;</span><br><span class="line">                <span class="comment">/* EXT4 */</span></span><br><span class="line">                dparts[i].partition_type = EXT4_PARTITION;</span><br><span class="line">                dparts[i].server_id = SERVER_EXT4_FS;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pinfo-&gt;fs_id == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* do nothing */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[WARNING] not supported fs type %x\n&quot;</span>,</span><br><span class="line">                       pinfo-&gt;fs_id);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">initialize_dparts</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(dparts[<span class="number">0</span>].device_name, <span class="string">&quot;sda1&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(dparts[<span class="number">1</span>].device_name, <span class="string">&quot;sda2&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(dparts[<span class="number">2</span>].device_name, <span class="string">&quot;sda3&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(dparts[<span class="number">3</span>].device_name, <span class="string">&quot;sda4&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(dparts[<span class="number">4</span>].device_name, <span class="string">&quot;sda5&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，它也依然会发送GET_SERVER_CAP请求给procmgr。procmgr会返回对应的FS service cap，如果对应的FS service尚未启动则procmgr会立刻启动它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> SERVER_FAT32_FS:</span><br><span class="line">        ret = boot_server(<span class="string">&quot;fat32&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;/fat32.srv&quot;</span>,</span><br><span class="line">                          sys_servers + SERVER_FAT32_FS,</span><br><span class="line">                          SYSTEM_SERVER);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        ipc_set_msg_return_cap_num(ipc_msg, <span class="number">1</span>);</span><br><span class="line">        ipc_set_msg_cap(</span><br><span class="line">                ipc_msg, <span class="number">0</span>, sys_servers[SERVER_FAT32_FS]);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<p>最后也是依然会打开一个connection用于后续交互。</p>
<p>可见mount大致流程大概就是：</p>
<ol>
<li>让procmgr启动FS service process，然后获取server cap</li>
<li>填写mount info插入链表</li>
<li>打开一个connection用于后续交互</li>
</ol>
<p>实验最主要让我们完成的还是比较简单的第三步。</p>
<p>此部分也属于是一种service间交互应用的体现吧，FS Client FSM这三者关系还算是比较交错。Client是FS、FSM的客户端，FSM是FS的客户端（发送FS_INIT等让它自助初始化），FSM也算是FS他半个爸（）</p>
<h3 id="parse-path"><a href="#parse-path" class="headerlink" title="parse path"></a>parse path</h3><p>Client端并非干脆使用server cap同FS service进行交互，而是使用mount id来表示一个FS。故而，为了实现该封装，我们就需要在Client端维护一个&lt;mount id, server cap(Client的cap)&gt;的映射和一个&lt;connection(<code>ipc_struct</code>), server cap&gt;的映射。</p>
<p>因此，我们需要在FSM端：</p>
<ol>
<li>集中存储每个Client对应的&lt;mount id, server cap(FSM的cap)&gt;映射，这对应本任务的<code>fsm_client_cap</code></li>
<li>收到parse path请求的时候，根据路径最大匹配找到对应的挂载点再找到对应的文件系统</li>
<li>根据文件系统的server cap找到mount id（调用1中接口）</li>
<li>将server cap通过IPC的cap拷贝机制copy给Client端（<code>ipc_return_with_cap</code>），然后将mount id、挂载路径写回msg中的response就行了1</li>
</ol>
<h2 id="FS-base"><a href="#FS-base" class="headerlink" title="FS_base"></a>FS_base</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>在 ChCore 中，FS_Base 是文件系统的一层 wrapper，IPC 请求首先被 FS_Base 接收，再由 FS_Base 调用实际的文件系统进行处理。</p>
<p>【其实或者说叫“基类”什么的也挺好的（）】</p>
<p>在 FS_Base wrapper 中，ChCore 实现了适用于VFS的vnode抽象，用来代表文件系统中所有的对象，包括文件、目录、链接等。它有一个private指针指向具体的各个FS的数据，比如说对于EXT4就是inode，算是多态的一种体现。 </p>
<p>ChCore 中 vnode 的定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_vnode</span> &#123;</span></span><br><span class="line">        <span class="type">ino_t</span> vnode_id; <span class="comment">/* identifier */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span>;</span> <span class="comment">/* rbtree node */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">fs_vnode_type</span> <span class="title">type</span>;</span> <span class="comment">/* regular or directory */</span></span><br><span class="line">        <span class="type">int</span> refcnt; <span class="comment">/* reference count */</span></span><br><span class="line">        <span class="type">off_t</span> size; <span class="comment">/* file size or directory entry number */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_cache_entity_of_inode</span> *<span class="title">page_cache</span>;</span></span><br><span class="line">        <span class="type">cap_t</span> pmo_cap; <span class="comment">/* fmap fault is handled by this */</span></span><br><span class="line">        <span class="type">void</span> *private;</span><br><span class="line"></span><br><span class="line">        <span class="type">pthread_rwlock_t</span> rwlock; <span class="comment">/* vnode rwlock */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再然后，为了兼容POSIX接口，外界用户态通过chcore-libc访问文件是以fd的形式，（fd是一个非负整数，它<strong>指向一个内核中的文件表项</strong>，包含了文件的状态信息和操作方法）然后每个进程的fd都集中存储在chcore-libc中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Global fd desc table */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_desc</span> *<span class="title">fd_dic</span>[<span class="title">MAX_FD</span>] =</span> &#123;<span class="number">0</span>&#125;;	<span class="comment">// userspace libc data, per-process</span></span><br></pre></td></tr></table></figure>

<p>而在FS内部，使用了一个<code>server_entry</code>结构体，用来作为POSIX中fd指向的那个文件表项，其表索引为fid。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// per-fd</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">server_entry</span> &#123;</span></span><br><span class="line">        <span class="comment">/* `flags` and `offset` is assigned to each fd */</span></span><br><span class="line">        <span class="type">int</span> flags;</span><br><span class="line">        <span class="type">off_t</span> offset;</span><br><span class="line">        <span class="type">int</span> refcnt;	<span class="comment">// used for dup2</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Different FS may use different struct to store path,</span></span><br><span class="line"><span class="comment">         * normally `char*`</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">void</span> *path;</span><br><span class="line">        <span class="comment">/* Entry lock */</span></span><br><span class="line">        <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">        <span class="comment">/* Each vnode is binding with a disk inode */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fs_vnode</span> *<span class="title">vnode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">server_entry</span> *<span class="title">server_entrys</span>[<span class="title">MAX_SERVER_ENTRY_NUM</span>];</span></span><br></pre></td></tr></table></figure>

<p>因此，FS_Base 的 IPC handler 在处理 IPC 请求时，会先把 IPC 消息中包含的文件 fd 转换为 fid，所以我们文件系统内部需要维护一个<code>(client badge, fd) -&gt; (fid)</code>的映射：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* (client_badge, fd) -&gt; fid(server_entry) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">server_entry_node</span> &#123;</span></span><br><span class="line">        <span class="type">badge_t</span> client_badge;</span><br><span class="line">        <span class="type">int</span> fd_to_fid[MAX_SERVER_ENTRY_PER_CLIENT];</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">server_entry_mapping</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">pthread_spinlock_t</span> server_entry_mapping_lock;</span><br></pre></td></tr></table></figure>

<h3 id="fs-wrapper-ops"><a href="#fs-wrapper-ops" class="headerlink" title="fs_wrapper_ops"></a>fs_wrapper_ops</h3><p>当我们拥有了文件表项和VNode抽象后，我们便可以实现真正的文件系统操作了。</p>
<p>我们可以将 FS_Base 以及 FS_Wrapper 的所有逻辑看成一个 VFS 的通用接口，其暴露出的接口定义为 <code>strcut fs_server_ops</code>。FS只需要实现该结构体的操作即可，FS wrapper会调用它。</p>
<p>我们可以来看看tmpfs具体是什么样的架构。</p>
<p>首先tmpfs以<code>fs_server_dispatch</code>为handler注册为了一个IPC server：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">info(<span class="string">&quot;register server value = %u\n&quot;</span>,</span><br><span class="line">     ipc_register_server_with_destructor(fs_server_dispatch,</span><br><span class="line">                                         DEFAULT_CLIENT_REGISTER_HANDLER,</span><br><span class="line">                                         fs_server_destructor));</span><br></pre></td></tr></table></figure>

<p><code>fs_server_dispatch</code>定义在FS wrapper中，是对所有FS通用的一个server handler。它会先把fd转化为fid，然后根据请求类型调用相应处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_SERVER_HANDLER(fs_server_dispatch) &#123;</span><br><span class="line">        <span class="comment">// Now fr-&gt;fd stores the `Client Side FD Index&#x27;</span></span><br><span class="line">        ret = translate_fd_to_fid(client_badge, fr);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * FS Server Requests Handlers</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">switch</span> (fr-&gt;req) &#123;</span><br><span class="line">        <span class="keyword">case</span> FS_REQ_MOUNT:</span><br><span class="line">                ret = fs_wrapper_mount(ipc_msg, fr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FS_REQ_OPEN:</span><br><span class="line">                ret = fs_wrapper_open(client_badge, ipc_msg, fr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FS_REQ_READ:</span><br><span class="line">                ret = fs_wrapper_read(ipc_msg, fr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>以<code>mount</code>为例，可以看到它最终会调用server ops的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fs_wrapper_mount</span><span class="params">(<span class="type">ipc_msg_t</span> *ipc_msg, <span class="keyword">struct</span> fs_request *fr)</span> &#123;</span><br><span class="line">        ret = server_ops.mount(ipc_msg, fr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也即tmpfs定义的具体server ops：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_server_ops</span> <span class="title">server_ops</span> =</span> &#123;</span><br><span class="line">        <span class="comment">/* Unimplemented */</span></span><br><span class="line">        .mount = default_server_operation,</span><br><span class="line">        .umount = default_server_operation,</span><br><span class="line">        <span class="comment">/* File Operations */</span></span><br><span class="line">        .creat = tmpfs_creat,</span><br><span class="line">        .open = tmpfs_open,</span><br><span class="line">        .write = tmpfs_write,</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于本 Lab 你只需要实现最基本的 Posix 文件操作即可，即 Open，Close，Read, Write 以及 LSeek 操作。具体的没啥好说的，就是常规的FS，体力活。</p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>TODO  之后有时间可以研究一下file page fault和cache的代码是怎么写的。</p>
<p>还有libc，recycle等等等</p>
]]></content>
  </entry>
  <entry>
    <title>How to read a paper</title>
    <url>/2024/09/21/how-to-read-paper/</url>
    <content><![CDATA[<p><a href="https://ics.uci.edu/~cs237/reading/files/howtoread.pdf">原文</a></p>
<ol>
<li><p>first pass: general ideas</p>
<ol>
<li>5-10 mins</li>
<li>main content:<ol>
<li>看作者是谁</li>
<li>read the abstract、introduction</li>
<li>read the subtitles</li>
<li>read the conclusions</li>
<li>找有没有你之前度过的reference【很有意思的一点】</li>
</ol>
</li>
<li>可以了解到的问题：【注意记得扪心自问】<ol>
<li>Category: 研究的大概是什么领域的问题？是重在设计思想还是重在工程？</li>
<li>Context: 有哪些比较主要的相关工作？理论基础是什么样的？</li>
<li>Correctness: 文章说的东西是对的吗？</li>
<li>Contributions: 主要贡献在哪？</li>
<li>Clarity: 文章写得好吗？</li>
</ol>
</li>
<li>回答完上述问题，你就对要不要继续读下去这篇文章心里有数了。<ol>
<li>放弃的理由：写得不好；不正确；不感兴趣；现在的水平还看不懂</li>
<li>继续的理由：与自己的领域相关（现在or未来）</li>
</ol>
</li>
</ol>
</li>
<li><p>second pass: grasp the content</p>
<p>更仔细阅读，但忽略一切无关紧要细节（如实现细节、证明细节）</p>
<ol>
<li>1h</li>
<li>main content:<ol>
<li>阅读时记下key points &amp;&amp; comments</li>
<li>仔细观察graphs &amp;&amp; diagrams，查看是否能和conclusion对上</li>
<li>mark未读的reference papers</li>
</ol>
</li>
<li>是否继续？<ol>
<li>你感兴趣，但是跟研究领域没太大关系，放弃</li>
<li>你没看太懂，要么是领域太新，要么是细节你不懂，要么纯纯是你太累了<ol>
<li>你知道这篇文章对你有启发的概率较低，放弃</li>
<li>暂时搁置后续再来仔细读</li>
<li>persevere！</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>third pass: understand in depth</p>
<p>关键：virtually re-implement！颅内复现！</p>
<p>可以看出innovation的同时，也能发现hidden drawbacks</p>
<ol>
<li><p>4-5h for beginner, 1h for expert</p>
</li>
<li><p>main content:</p>
<ol>
<li>颅内复现</li>
<li>识别、质疑，每个句子包含的每个假设</li>
<li>代入：如果是你自己，会怎么处理这一部分</li>
</ol>
</li>
<li><p>reconstruct the entire structure of the paper from memory</p>
<p>Be able to pinpoint <u>implicit assumptions</u>, <u>missing citations</u> to relevant work, and <u>potential issues with experimental or analytical techniques</u>.</p>
</li>
</ol>
</li>
</ol>
<p>那么如何了解一个新领域？</p>
<ol>
<li><p>Step 1</p>
<p>找3-5篇recent paper，做first pass有一个基本了解，然后去看related works，就能收获一系列recent papers和survey</p>
</li>
<li><p>Step 2</p>
<p>找shared citations和author names，视奸他们主页，看top conference，从conference抓出更多paper</p>
</li>
<li><p>Step 3</p>
<p>对上述几步找到的好文（shared citations、good conference paper）进行second pass阅读，这就是你survey的first edition了。并且注意这个过程需要递归进行，阅读阶段发现了之前漏了的好paper就需要继续补上。</p>
</li>
</ol>
<p>【comment: step1 &amp; step2是一个螺旋过程。】</p>
<p>Related works:</p>
<p>If you are reading a paper to do a review, you should also read Timothy Roscoe’s paper on “<a href="http://people.inf.ethz.ch/troscoe/pubs/reviewwriting.pdf">Writing reviews for systems conferences</a>” .</p>
<p>If you’re planning to write a technical paper, you should refer both to [Henning Schulzrinne’s comprehensive web site](<a href="http://www.cs.columbia.edu/">http://www.cs.columbia.edu/</a> hgs/etc/writingstyle.html) and <a href="http://www.che.iitm.ac.in/misc/dd/writepaper.pdf">George Whitesides’s excellent overview of the process</a>.</p>
]]></content>
  </entry>
  <entry>
    <title>2025 CS保研/申请（System）</title>
    <url>/2024/10/06/%E4%BF%9D%E7%A0%94/</url>
    <content><![CDATA[<p><strong>写在前面</strong>：半年的升学经历让我成长了很多，在此写下这篇帖子，既是为了给自己开辟一个新的起点，也是希望可以帮到看到这篇文章的人，提供不论是情感上的还是经验上的支持。感谢绿群，感谢前辈们的经验贴，感谢一路走来愿意听我叭叭帮我出谋划策的各位研友、学长学姐和小镇姑娘们，感恩遇见。</p>
<h1 id="1-个人情况"><a href="#1-个人情况" class="headerlink" title="1. 个人情况"></a>1. 个人情况</h1><ul>
<li><p>学校：中上985</p>
</li>
<li><p>专业：计算机科学与技术</p>
</li>
<li><p>排名：9%</p>
</li>
<li><p>竞赛经历：系统能力竞赛（OS功能）国一</p>
</li>
<li><p>科研经历：一段约4个月存储相关（但我其实做得不多，只是有得讲）</p>
</li>
<li><p>个人偏好：</p>
<ul>
<li>坚定System（除了arch之外都行）</li>
<li>研究向硕士，香港直博可接受；偏向学术强的年轻导师</li>
<li>想尽早定去向（不想赌预推免）</li>
</ul>
</li>
<li><p>最终去向：<a href="http://css.ios.ac.cn/">中科院软件所-基础软件与系统重点实验室-操作系统研究室</a></p>
</li>
</ul>
<blockquote>
<p><strong>Projects:</strong></p>
<p>Competition</p>
<ul>
<li><a href="/2023/08/27/2023-os-comp/">2023全国大学生计算机系统能力大赛-OS功能</a></li>
</ul>
<p>Lab</p>
<ul>
<li><a href="/2024/08/11/chcore">ChCore</a></li>
<li><a href="/2023/03/13/cmu15445/">CMU15445</a></li>
<li><a href="/2023/02/25/cs144/">CS144</a></li>
<li><a href="/2023/01/10/xv6/">XV6</a></li>
</ul>
</blockquote>
<h1 id="2-Tips"><a href="#2-Tips" class="headerlink" title="2. Tips"></a>2. Tips</h1><ul>
<li><p>跟同校同学多交流多商量，错峰报名，血泪教训。</p>
</li>
<li><p>rk和缘分制胜</p>
<ul>
<li>To 还有时间提升的朋友：Rank超级重要。可以看到我的情况属于是能入营的一般都能offer，但是绝大部分时候都被卡入营了。</li>
<li>To 低rk的朋友：缘分制胜，一定要早联系、多套磁，重点选择弱com。了解到有排名10%的同学海投了十几几十个tpu的老师然后夏令营上岸了，毅力respect。</li>
</ul>
</li>
<li><p>广结研友，多聊聊有助于释放压力理清思路。</p>
</li>
<li><p>看清自己定位（包括目标院校、未来发展目标……），谨慎海投。我个人比较坚持“一定不去的就不投” “尽早放弃，offer动态归一”等原则。</p>
</li>
</ul>
<h1 id="3-夏令营"><a href="#3-夏令营" class="headerlink" title="3. 夏令营"></a>3. 夏令营</h1><table>
<thead>
<tr>
<th>学校</th>
<th>学院</th>
<th>类型</th>
<th>入营</th>
<th>结果</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>清华</td>
<td>贵系</td>
<td>直博</td>
<td>G</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>清华</td>
<td>智网中心</td>
<td>博/硕</td>
<td>G</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>北大</td>
<td>CS</td>
<td>直博</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>北大</td>
<td>软微</td>
<td>专硕</td>
<td>G</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>上交</td>
<td>软院</td>
<td>硕士</td>
<td>G</td>
<td>-</td>
<td>最悲伤的一集，心碎了一地。。</td>
</tr>
<tr>
<td>中科大</td>
<td>CS</td>
<td>硕士</td>
<td>G</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>复旦</td>
<td>CS</td>
<td>硕士</td>
<td>G</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>南大</td>
<td>CS</td>
<td>学硕</td>
<td>√</td>
<td>优营</td>
<td></td>
</tr>
<tr>
<td>人大</td>
<td>信科</td>
<td>硕士</td>
<td>√</td>
<td>-</td>
<td>放弃参营</td>
</tr>
<tr>
<td>计算所</td>
<td>HPC</td>
<td>硕士</td>
<td>霸面</td>
<td>-</td>
<td>放弃参营</td>
</tr>
<tr>
<td>软件所</td>
<td>国重</td>
<td>硕士</td>
<td>√</td>
<td>优营</td>
<td></td>
</tr>
<tr>
<td>HKUST</td>
<td>CSE</td>
<td>PhD</td>
<td>-</td>
<td>-</td>
<td>目标导师招满</td>
</tr>
<tr>
<td>CUHK</td>
<td>CSE</td>
<td>PhD</td>
<td>√</td>
<td>通过</td>
<td>今年提前批放了一大批人免面试</td>
</tr>
</tbody></table>
<p>对于低rk选手来说，夏令营情况还是一如既往惨淡，强com属于是一点机会也不给（）再加上一些夏令营因为临时有事放弃，故而最终算是实际参加的也就三个。</p>
<p>以下经历按时间顺序介绍。</p>
<h1 id="CUHK"><a href="#CUHK" class="headerlink" title="CUHK"></a>CUHK</h1><p>港校的phd可以4年就毕业，并且还有比较可观的奖学金，许多老师每年招的学生都在精不在多，所以感觉会对手下学生比较尽心培养。还有一个比较好的地方就是提前批开得比较早，可以在928之前发offer，心里有底。hku开得最早（3-4月），hkust开得最晚（9月），cuhk算是时间比较适中（4-6月）。并且港校也需要主打一个趁早联系，我四月初联系了hkust的一个超强组，他们表示25fall都已经招满了，哈人。</p>
<p>今年CUHK CSE提前批报的人太多了，放了巨大一批人免committee的面试，最终offer只需导师点头即可，相当于纯弱com。“巨大一批”具体来说，大概是我问了身边貌似有六七个人，就其中一两位朋友需要面试，感觉总体上来说bar没有特别高，这波属于是压力给到了导师。</p>
<p>港校提前批感觉重要性：paper＞国奖＞成绩＞竞赛，套磁时建议使用英文邮件+英文简历，我遇到的导师都表示可以进行中文面试，所以口语苦手也不用太担忧。大概都是面了1h左右，主要是对项目经历的拷打，以及一些例行公事的意向问题。</p>
<h1 id="NJU"><a href="#NJU" class="headerlink" title="NJU"></a>NJU</h1><p>nju cs今年开得格外早（5.5截止报名），貌似是因为他们想整个暑研之类的东西，拿到offer之后去参加可以免硕士阶段学分（什么保研新趋势）。</p>
<p>依然是跟往年一样，先进行一波简历筛，我感觉感觉入营bar还是挺低的，非常适合本人这样的低rk前去搏一搏。然后线上笔试筛一波人，今年考巨多编译原理，印象中还考了几道比较基础的数据结构和算法，还有零零散散的计网OS等408。最终线下参营比例大概在30%左右。</p>
<p>线下去了之后又是一波机试，然后是面试。日程安排大概是，第一天纯报到，第二天上午机试下午面试，第三天就可以润了。</p>
<p>我的机试获得了2/3的分数，看了一圈体感能算中等偏上水平。机试不是纯算法题，更多靠平时积累和运气，有点类似什么手搓智能指针之类的，不提供离线语言API文档，C++选手记得提前看一眼常见STL容器的API（本人当时就略措手不及）。</p>
<p>面试比较流程化，貌似每个人10-15分钟，进去对着三四个老师，然后问英语问项目问专业课问开放性问题四步走，老师对我的项目比较感兴趣问得比较久，其他的都随便走了流程。除了最后问的开放性问题“AI发展给System带来了怎样的机遇和挑战”，我回答得十分磕磕绊绊（本人最菜的地方。。。），除此之外答得都还算不错。</p>
<p>个人感觉综合表现还可以，最终也是拿到了学硕优营。</p>
<p>坦白说本来没有特别特别特别想去nju的欲望，线下去了一趟后，对南京的好感度很高（环境、美食…），老师们也比较热情，遂觉得nju也是个非常不错的选择。</p>
<h1 id="海投阶段"><a href="#海投阶段" class="headerlink" title="海投阶段"></a>海投阶段</h1><p>从NJU回来之后已经是六月初了，又进入了一个新的忙碌循环，一边准备着海投套磁，一边应付学业和考试，一边跟着本校导师做事。彼时去向未定，事多缠身，轮番套磁无回应，还被一万个学校拒入营，真是非常灰暗的一段日子，我甚至一度怀疑自己是不是应该坚定保本校然后大三上就直接开始干活。</p>
<p>印象最深刻、保研以来最心痛最破防的，是我SJTU软院没入营。。。</p>
<p>上交的IPADS实验室一直是我保研的初心和目标。彼时五月中旬，我满怀期待地向IPADS的一位老师发去了套磁邮件，虽然得到了经典的强com官回，但还是加了微信保持联系，再加上都说上交软院整体bar相对较低，我直接斗志满满，还觉得稳了。之后七月初入营开奖，我翻遍了包括垃圾箱在内的所有邮件，还骚扰了一下招生老师，最终得到了全否的回复，我才接受了没入营的现实，微信跟老师说了，老师也挺惊讶，表示遗憾，然后贴心地安慰了我一番（老师亚撒西我哭死，可惜硕士纯纯的强com……）。当时我觉得跟IPADS已经无缘了，消沉了整整两天，寝食难安。</p>
<blockquote>
<p>PS: 之后看到了有10+%的同学也入营了，应该不一定是卡5%。悟已往之不谏，一切随缘吧。</p>
</blockquote>
<p>好在，很幸运，大概在六月下旬的时候，我看到了<a href="https://zhuanlan.zhihu.com/p/704126462">我导在知乎的招生贴</a>，了解到陈海波老师原来今年刚在软件所国重当主任，并且是一脉相承的IPADS风格行事，于是果断地冲了，六月底就进行了面试，体验很不错，李老师思维活跃人巨好。软件所和上交软的夏令营冲突，那时候纠结了好几天要去哪个（翻看日记，发现其实早在那时候我就已经更偏向去软件所了hhh），还试图规划一下时间双开，结果没过几天就收到了上交的拒信，好家伙，这下直接不用选了。</p>
<p>之后七月初的时候，收到了李老师一封超级超级超级真诚的邮件，欢迎我去软件所夏令营。那时候我刚收到上交拒信没两天，还十分消沉，看到邮件后真的特别特别（此处省略n个特别）感动，于是很快就从玉玉中走了出来，重整旗鼓准备去软件所的夏令营。</p>
<h1 id="软件所"><a href="#软件所" class="headerlink" title="*软件所"></a>*软件所</h1><p>首先首先打个小广告，欢迎大家来了解我们组~ 明煜老师学术能力很强，人品超级超级好，人格魅力更是无敌，真诚推荐大伙速冲！附上25fall的招生链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/704126462">https://zhuanlan.zhihu.com/p/704126462</a></p>
<p>【中科院重点实验室陈海波组招收2025年推免硕士生——计算机系统方向】 陈海波教授为【基础软件与系统】重点实验室主任，国家杰出青年基金获得者、ACM Fellow、IEEE Fellow。研究工作获得华为卓越贡献个人奖、SOSP/ASPLOS/EuroSys/VEE等最佳论文奖、DSN时间检验奖、SIGMOD研究亮点奖等。研究成果产生了广泛的学术与产业影响。 实验室主页：css.ios.ac.cn。</p>
<p>Anyway回到夏令营。</p>
<p>软件所我之前一直听说算是偏强com，这次实际体验下来感觉还是比较纯正的弱com。具体流程感觉就是弱com版本的nju。首先进行一波简历筛，大约筛剩貌似四百余人，然后分实验室加群机试考核。实验室内不同组又是以不同方式筛人，大多还是会进行一轮线上机试（具体考什么因组而异，我看有的组甚至还考高数），最后筛剩可能大概一百多人去参加线下夏令营。</p>
<p>参营之前需要做一份巨长的心理量表，题目比较有chou趣xiang，一共五百多题。</p>
<p>线下夏令营考核也是因实验室而异，有的还需要n轮机试+面试，有的则只需要面试，并且面试形式也各有不同。以我所在的国重为例，需要从给定论文列表选取论文精读，然后做PPT进行展示。</p>
<p>（此处有社恐温馨提示：有些分组的会议室无讲台，所以需要做好把自己的全部暴露在各位老师面前的心理准备，第一次做类似形式展示的同学可以建设一下。）</p>
<p>最后发了优营之后需要签承诺书，其中包含不鸽协议（具体效力未知），但给的考虑时间很充分，建议看情况抉择。</p>
<h1 id="4-尾声"><a href="#4-尾声" class="headerlink" title="4. 尾声"></a>4. 尾声</h1><p>从北京回来之后，我的夏令营也就结束了。我习惯谨慎抉择，所以之后也是进行了长达一周的权衡和思考人生，最终放弃了其它去处，200%坚定地allin了我的初心软件所，因为我坚信在这里我能获得更多的成长（能力上&amp;修养上），这几天的思考精炼在一句话足矣。</p>
<p>回顾我整个升学历程，我感觉在个人努力已经堆到某一level之后，剩下的就是缘分制胜了。多去尝试，多去争取，多多交流，缘分终究会敲响大门。同时，维护一个健康积极的稳定心态也非常重要。这四个多月以来的迷茫、焦虑、自我怀疑，破坏了我许多美好的品质，却也使我成长了很多，有自信在未来重建它们。脚踏实地做事，步步为营规划，放稳放平心态，永远是获得不论是世俗or理想成功的法宝。</p>
<p>此处再次感谢前人的经验贴。许多我都刷了一遍又一遍，真的帮我度过了很多灰暗的时光。</p>
<p>希望未来能继续努力，祝看到这里的朋友们一切顺利！</p>
]]></content>
  </entry>
</search>
