<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="修年">





<title>Web Server | 修年</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


      <meta charset="UTF-8">
    <title>live2d-demo</title>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- Live2DCubismCore -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
    <!-- Include Pixi. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
    <!-- Include Cubism Components. -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
    <!-- User's Script -->
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
    <style>
    </style>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiunian&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiunian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc" style="right: -4em;">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Web Server</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">修年</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">三月 23, 2024&nbsp;&nbsp;19:09:29</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h1><blockquote>
<p>项目链接：<a target="_blank" rel="noopener" href="https://github.com/linyacool/WebServer">WebServer by linyacool</a></p>
<p>个人代码注释：<a target="_blank" rel="noopener" href="https://github.com/xiunianjun/WebServer">WebServer</a></p>
<p>使用方法：</p>
<p>开启两个shell，其中一个作为server端，另外一个作为client端。server端可以监听端口等待连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./build/Debug/WebServer/WebServer -t 2 -p 60000</span><br><span class="line">./WebServer [-t thread_numbers] [-p port] [-l log_file_path(should begin with <span class="string">&#x27;/&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<p>client端可以发送各种请求，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1234&quot;</span> | telnet localhost 60000</span><br><span class="line">curl http://localhost:60000</span><br></pre></td></tr></table></figure>

</blockquote>
<p>感觉最主要的收获还是了解到了epoll机制，以及对网络了解更深刻了一点。</p>
<h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p>整体采用Reactor模型事件驱动实现，使用线程池提高并发度，同时使用epoll实现IO多路复用。</p>
<p><img src="/2024/03/23/webserver/image-20240323150800250.png" alt="image-20240323150800250"></p>
<p>具体来说，web server分为两类线程，一类为listen thread（Main Reactor），一类为worker thread（Sub Reactor）。listen thread只有一个，它负责接收（accept）来自客户端的请求，并且将请求采用Round Robin的方式派发给worker线程进行处理；worker thread以线程池的方式管理，负责解析http请求，进行具体的数据交互。</p>
<ol>
<li><p>这两类线程的内在实现原理是一致的，都是采用了<strong>epoll机制</strong>来实现IO多路复用，实现与底层os的交互。</p>
<p>具体来说，它们的<strong>线程体</strong>都被抽象为一个<code>EventLoop</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;SP_Channel&gt; ret;</span><br><span class="line">  <span class="keyword">while</span> (!quit_) &#123;</span><br><span class="line">    ret.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 从epoll模型获取关注事件</span></span><br><span class="line">    ret = poller_-&gt;<span class="built_in">poll</span>();</span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : ret) it-&gt;<span class="built_in">handleEvents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于listen thread，它从epoll处获取的事件是new connection，最终会在<code>handleEvents</code>中转向<code>handleNewConn</code>来建立新连接并分发任务给worker thread。</li>
<li>对于worker thread，它从epoll处获取的事件是related data，最终会在<code>handleEvents</code>中转向例如<code>handleRead</code>来获取来自client的数据并进行处理和构建response。</li>
</ul>
</li>
<li><p>这两类线程通过异步的沉睡唤醒机制来实现交互。</p>
<p>通过epoll机制来实现沉睡唤醒。</p>
</li>
</ol>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><p>本webserver类型使用的是reactor模型，它的基本思想：在这个模型中，有一个reactor，它负责的是从操作系统的协议栈接收事件（读取、连接、写入等），并且将事件派发给对应的handler。还有一系列不同类型的handler，它们负责具体处理事件。</p>
<p>Reactor模型的工作方式是通过<strong>事件驱动</strong>的，它不断地监听事件的发生并将其分发给相应的Handler进行处理。这种模型的优势在于它能够以<strong>异步、非阻塞</strong>的方式处理大量的并发连接，提高了服务器的性能和可扩展性。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><blockquote>
<p>部分参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qJ411w7du">IO多路复用select/poll/epoll介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/War_wick/article/details/128798745">IO多路复用</a></p>
</blockquote>
<p>epoll模型的应用很广泛，<strong>它的本质其实就是一个阻塞的监听IO数据输入输出的事件机制</strong>。</p>
<h4 id="演化过程"><a href="#演化过程" class="headerlink" title="演化过程"></a>演化过程</h4><p>大概是说，本来是觉得一个请求一个线程：</p>
<blockquote>
<p><strong>accept():</strong></p>
<ul>
<li><strong>作用：</strong> <code>accept()</code> 用于在服务器端接受客户端的连接请求，并创建一个新的套接字用于与客户端通信。</li>
</ul>
<p><strong>recv():</strong></p>
<ul>
<li><strong>作用：</strong> <code>recv()</code> 用于从已连接套接字中接收数据，即从客户端接收数据。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// accept阻塞</span></span><br><span class="line">  client_fd = <span class="built_in">accept</span>(listen_fd)</span><br><span class="line">  <span class="comment">// 开启线程read数据（fd增多导致线程数增多）</span></span><br><span class="line">  <span class="keyword">new</span> Thread <span class="built_in">func</span>() &#123;</span><br><span class="line">    <span class="comment">// recv阻塞（多线程不影响上面的accept）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(fd)) &#123;</span><br><span class="line">      <span class="comment">// logic</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是线程很多很多还得切换开销巨大不适合高并发场景，所以换了一个思路，用单个进程/线程来一次性处理多个请求，也即单个线程开放多个socket端口，同时开始监听，一有连接马上分别处理，这样的事件机制实现就需要内核的帮助：</p>
<p><img src="/2024/03/23/webserver/image-20240322164106938.png" alt="image-20240322164106938"></p>
<p>它最主要就是把fd集合扔进内核态，让内核帮忙判断哪个有数据</p>
<p><img src="/2024/03/23/webserver/image-20240322164956107.png" alt="image-20240322164956107"></p>
<p>poll的话，就再多封装了一步，把原来的rset那个bitmap和fd合并成了一个结构体传进去。当有数据到来，内核就会改变fd.revents位。可以看到，这个就是一个具有雏形的事件机制了。</p>
<p><img src="/2024/03/23/webserver/image-20240322165444656.png" alt="image-20240322165444656"></p>
<p>epoll就直接更彻底了，前面还是在外部填一个数组然后每次都通过系统调用copyin进去，这里是直接在准备阶段就通过系统调用<code>epoll_ctl</code>把数组写入到内核空间并返回一个fd，之后每次<code>epoll_wait</code>就不用再copyin一次了。然后事件通知的话也是通过写入外部的一个events数组实现。</p>
<p>（值得一提的是，这里的epoll fd似乎还是红黑树实现（所以也能避免用户态那么费劲维护这个庞然大物了，很漂亮的封装思想）。这段还是很有文章的，以后感兴趣可以看看）</p>
<p>可以看到，这一步步的核心就是减少运行时拷贝减少切换提高效率……redis、nginx、jave的NIO都是使用epoll实现的。</p>
<h4 id="epoll的使用"><a href="#epoll的使用" class="headerlink" title="epoll的使用"></a>epoll的使用</h4><p>在使用 epoll 模型进行网络通信时，主要分为以下几个阶段：</p>
<ol>
<li><strong>创建 Socket 和 epoll 实例：</strong><ul>
<li>在服务器端，首先创建一个 Socket，并绑定到指定的地址和端口。</li>
<li>创建一个 epoll 实例，用于管理多个文件描述符的事件。</li>
</ul>
</li>
<li><strong>监听套接字的事件：</strong><ul>
<li>使用 epoll_ctl() 将监听套接字添加到 epoll 实例中，并注册关注的事件，一般是 EPOLLIN（可读事件）。</li>
</ul>
</li>
<li><strong>等待事件发生：</strong><ul>
<li>使用 epoll_wait() 函数等待事件发生，该函数将会阻塞直到有事件发生或超时。</li>
</ul>
</li>
<li><strong>处理事件：</strong><ul>
<li>当有事件发生时，epoll_wait() 返回，程序获取到就绪的文件描述符以及对应的事件类型。</li>
<li><u>如果就绪的文件描述符是监听套接字，则表示有新的客户端连接请求到达，此时需要调用 accept() 函数来接受连接，创建新的已连接套接字，并将其添加到 epoll 实例中进行管理。</u></li>
<li><u>如果就绪的文件描述符是已连接套接字，则表示有数据可以读取或写入。此时，可以调用 recv() 函数读取数据，或者调用 send() 函数发送数据。</u></li>
<li>如果需要对套接字进行写操作，还需要将该套接字的事件类型设置为 EPOLLOUT。</li>
</ul>
</li>
<li><strong>循环处理：</strong><ul>
<li>处理完一个事件后，程序会继续等待下一个事件的发生，重复上述过程。</li>
</ul>
</li>
</ol>
<h4 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a>API详解</h4><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><ol>
<li><p><strong>EPOLLIN</strong>：</p>
<ul>
<li>意义：表示套接字上有数据可读。</li>
<li>使用场景：当套接字上有数据可读时，触发 EPOLLIN 事件，可以调用 <code>recv()</code> 等函数来读取数据。</li>
</ul>
</li>
<li><p><strong>EPOLLOUT</strong>：</p>
<ul>
<li>意义：表示套接字上可以写入数据。</li>
<li>使用场景：当套接字上的写缓冲区有空间时，触发 EPOLLOUT 事件，可以调用 <code>send()</code> 等函数向套接字写入数据。</li>
</ul>
</li>
<li><p><strong>EPOLLRDHUP</strong>：</p>
<ul>
<li>意义：表示对端套接字<strong>已关闭连接或者关闭了写端</strong>。</li>
<li>使用场景：当远程端关闭连接或者关闭了写端时，触发 EPOLLRDHUP 事件。通常用于检测对端连接的关闭。</li>
</ul>
</li>
<li><p><strong>EPOLLHUP</strong>：</p>
<ul>
<li>意义：表示套接字出现<strong>挂起</strong>情况。</li>
<li>使用场景：当套接字上出现挂起情况时，例如<strong>对端异常关闭连接</strong>时，触发 EPOLLHUP 事件。</li>
</ul>
</li>
<li><p><strong>EPOLLERR</strong>：</p>
<ul>
<li>意义：表示套接字发生错误。</li>
<li>使用场景：当套接字发生错误时，例如<strong>连接被重置或者发生其他错误</strong>时，触发 EPOLLERR 事件。</li>
</ul>
</li>
<li><p><strong>EPOLLPRI</strong>：</p>
<ul>
<li><p>意义：表示套接字上有紧急数据可读。</p>
</li>
<li><p>使用场景：当套接字上有紧急数据需要处理时，触发 EPOLLPRI 事件。紧急数据通常使用带外数据（Out-of-Band）的方式传输。</p>
<p>紧急数据（Out-of-Band data）是一种特殊的数据，它可以被发送到套接字的优先级带外通道（Out-of-Band Channel）中，并且不遵循普通数据的顺序。紧急数据通常用于发送一些需要立即处理的信息，例如紧急控制信息或者重要的命令。</p>
</li>
</ul>
</li>
<li><p><strong>EPOLLONESHOT</strong>：</p>
<ul>
<li>意义<strong>：</strong> 表示一次性触发模式。当某个套接字上的事件被 epoll_wait() 函数触发后，该事件会从 epoll 实例中被删除，需要重新注册才能再次触发。</li>
<li>使用场景： 适用于需要确保每个事件只被一个处理器处理的情况，避免并发处理同一个事件。</li>
</ul>
</li>
<li><p><strong>EPOLLET</strong>:</p>
<ul>
<li>意义<strong>：</strong> 表示边缘触发模式。在边缘触发模式下，只有当套接字上的状态发生变化时才会触发事件，而不是像默认的水平触发模式一样，只要套接字上有数据可读或可写就会触发事件。</li>
<li>使用场景： 适用于需要高效处理大量连接的场景，因为边缘触发模式可以减少不必要的触发次数，提高效率。</li>
</ul>
</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="运行追踪"><a href="#运行追踪" class="headerlink" title="运行追踪"></a>运行追踪</h3><p>感觉分块写有点难以下手，不如来一个我最拿手（？）的运行追踪这个思路来写吧，之后再分门别类细说。</p>
<p>首先，发动此命令启动服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./WebServer</span><br></pre></td></tr></table></figure>

<p>进入到了main函数，经过一系列parse arg的工作之后，来到了这里：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventLoop mainLoop;</span><br><span class="line"><span class="function">Server <span class="title">myHTTPServer</span><span class="params">(&amp;mainLoop, threadNum, port)</span></span>;</span><br><span class="line">myHTTPServer.<span class="built_in">start</span>();</span><br><span class="line">mainLoop.<span class="built_in">loop</span>();</span><br></pre></td></tr></table></figure>

<p>我们首先观察<code>Server::start</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  eventLoopThreadPool_-&gt;<span class="built_in">start</span>();</span><br><span class="line">  acceptChannel_-&gt;<span class="built_in">setEvents</span>(EPOLLIN | EPOLLET);</span><br><span class="line">  <span class="comment">// 对于监听线程来说，有新的连接来到-&gt;EPOLLIN-&gt;read handler被触发，所以我们将handNewConn绑定到read handler上</span></span><br><span class="line">  acceptChannel_-&gt;<span class="built_in">setReadHandler</span>(<span class="built_in">bind</span>(&amp;Server::handNewConn, <span class="keyword">this</span>));</span><br><span class="line">  acceptChannel_-&gt;<span class="built_in">setConnHandler</span>(<span class="built_in">bind</span>(&amp;Server::handThisConn, <span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 自此以来，main loop就管理accept了</span></span><br><span class="line">  loop_-&gt;<span class="built_in">addToPoller</span>(acceptChannel_, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它其实最主要还是启动了listen thread（为其绑定监听的epoll事件）和worker thread。下面分支解释这两类线程之后的举动。</p>
<h4 id="listen-thread"><a href="#listen-thread" class="headerlink" title="listen thread"></a>listen thread</h4><p><code>Server::start</code>函数返回之后，继续执行main函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainLoop.<span class="built_in">loop</span>();</span><br></pre></td></tr></table></figure>

<p>启动了listen thread的loop。从此之后，它就一直如此循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;SP_Channel&gt; ret;</span><br><span class="line">  <span class="keyword">while</span> (!quit_) &#123;</span><br><span class="line">    ret.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 从epoll模型获取关注事件</span></span><br><span class="line">    ret = poller_-&gt;<span class="built_in">poll</span>();</span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : ret) it-&gt;<span class="built_in">handleEvents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直到获取到了新的连接，这时候它会在<code>handleEvents</code>中转而通过<code>handlerNewConn</code>进行处理，在其中将请求通过RR方式分发给worker thread，并且注册下一次accept事件（epoll事件默认ONE_SHOT）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handNewConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当监听套接字上触发 EPOLLIN 事件时，表示有新的连接请求到达</span></span><br><span class="line">  <span class="comment">// 在这种情况下，通常应该调用 accept() 函数来接受新的连接</span></span><br><span class="line">  <span class="keyword">while</span> ((accept_fd = <span class="built_in">accept</span>(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr,</span><br><span class="line">                             &amp;client_addr_len)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// RR，获取空闲worker thread</span></span><br><span class="line">    EventLoop *loop = eventLoopThreadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    LOG &lt;&lt; <span class="string">&quot;New connection from &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(client_addr.sin_addr) &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">ntohs</span>(client_addr.sin_port);</span><br><span class="line">    <span class="comment">// 创建httpdata对象，表示请求的具体数据</span></span><br><span class="line">    <span class="function">shared_ptr&lt;HttpData&gt; <span class="title">req_info</span><span class="params">(<span class="keyword">new</span> HttpData(loop, accept_fd))</span></span>;</span><br><span class="line">    <span class="comment">// 唤醒该worker</span></span><br><span class="line">    loop-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;HttpData::newEvent, req_info));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册下一次accept事件</span></span><br><span class="line">  acceptChannel_-&gt;<span class="built_in">setEvents</span>(EPOLLIN | EPOLLET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个epoll事件，监听EPOLLIN，worker thread用于等待数据输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpData::newEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  channel_-&gt;<span class="built_in">setEvents</span>(DEFAULT_EVENT);</span><br><span class="line">  loop_-&gt;<span class="built_in">addToPoller</span>(channel_, DEFAULT_EXPIRED_TIME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="worker-thread"><a href="#worker-thread" class="headerlink" title="worker thread"></a>worker thread</h4><p><code>Server::start</code>函数中会调用<code>eventLoopThreadPool_-&gt;start()</code>启动线程池。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  baseLoop_-&gt;<span class="built_in">assertInLoopThread</span>();	<span class="comment">// base loop 即为 listen loop</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads_; ++i) &#123;</span><br><span class="line">    <span class="comment">// 启动worker thread</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;EventLoopThread&gt; <span class="title">t</span><span class="params">(<span class="keyword">new</span> EventLoopThread())</span></span>;</span><br><span class="line">    threads_.<span class="built_in">push_back</span>(t);</span><br><span class="line">    loops_.<span class="built_in">push_back</span>(t-&gt;<span class="built_in">startLoop</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker thread 的线程体</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  EventLoop loop;	<span class="comment">// 创建一个全新的属于自己的loop！也即，**拥有自己的epoll队列**！！！</span></span><br><span class="line">  loop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后进入到loop循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;SP_Channel&gt; ret;</span><br><span class="line">  <span class="keyword">while</span> (!quit_) &#123;</span><br><span class="line">    ret.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 从epoll模型获取关注事件</span></span><br><span class="line">    ret = poller_-&gt;<span class="built_in">poll</span>();</span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : ret) it-&gt;<span class="built_in">handleEvents</span>();</span><br><span class="line">    <span class="comment">// 执行异步回调函数</span></span><br><span class="line">    <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，此处有一个实现很有意思的沉睡唤醒机制（详情见下个部分）。</p>
<ol>
<li>worker thread在一开始的时候会阻塞在<code>poll</code>函数中，</li>
<li>直到listen thread通过<code>queueInLoop</code>调用wakeup唤醒（也是通过epoll机制），worker thread才会醒来继续执行接下来的代码。</li>
<li>此时，<code>doPendingFunctors</code>会执行listen thread传入的<code>newEvent</code>回调，从而成功完成对数据输入的监听。</li>
<li>此后当数据到达的时候，就会再次从<code>poll</code>苏醒，然后进入真正的<code>handleEvents</code>之中，</li>
<li>等到处理完请求再次陷入沉睡，依次循环。</li>
</ol>
<h3 id="epoll模型"><a href="#epoll模型" class="headerlink" title="epoll模型"></a>epoll模型</h3><h4 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><blockquote>
<p>Channel类：Channel是Reactor结构中的“事件”，它自始至终都属于一个EventLoop，负责一个文件描述符的IO事件，在Channel类中保存这IO事件的类型以及对应的回调函数，当IO事件发生时，最终会调用到Channel类中的回调函数。因此，程序中所有带有读写时间的对象都会和一个Channel关联，包括loop中的eventfd，listenfd，HttpData等。</p>
</blockquote>
<p>Channel 可理解为一个请求的抽象，它包含了<strong>请求数据</strong>以及对应的<strong>handler指针</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; CallBack;</span><br><span class="line">  EventLoop *loop_;</span><br><span class="line">  <span class="type">int</span> fd_;</span><br><span class="line">  <span class="type">__uint32_t</span> events_;</span><br><span class="line">  <span class="type">__uint32_t</span> revents_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">parse_URI</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">parse_Headers</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">analysisRequest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  CallBack readHandler_;</span><br><span class="line">  CallBack writeHandler_;</span><br><span class="line">  CallBack errorHandler_;</span><br><span class="line">  CallBack connHandler_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// 根据revent转向不同的handler</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleWrite</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleError</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> err_num, std::string short_msg)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleConn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="实现沉睡唤醒"><a href="#实现沉睡唤醒" class="headerlink" title="实现沉睡唤醒"></a>实现沉睡唤醒</h4><p>这个确实是很值得学习，非常巧妙地运用了epoll机制。</p>
<p>首先，书接上文，我们可知，这个是worker thread的线程体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker thread 的线程体</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  EventLoop loop;	<span class="comment">// 创建一个全新的属于自己的loop！也即，**拥有自己的epoll队列**！！！</span></span><br><span class="line">  loop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以去具体看看<code>Eventloop</code>的结构。可以注意到，eventloop对象是会自带并持续监听一个名为<code>pwakeupChannel_</code>的channel的，<code>wakeupFd_</code>是对应的<strong>eventfd</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventLoop::<span class="built_in">EventLoop</span>()</span><br><span class="line">    : <span class="built_in">wakeupFd_</span>(<span class="built_in">createEventfd</span>()),</span><br><span class="line">      <span class="built_in">pwakeupChannel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(<span class="keyword">this</span>, wakeupFd_)) &#123;</span><br><span class="line">  pwakeupChannel_-&gt;<span class="built_in">setEvents</span>(EPOLLIN | EPOLLET);</span><br><span class="line">  pwakeupChannel_-&gt;<span class="built_in">setReadHandler</span>(<span class="built_in">bind</span>(&amp;EventLoop::handleRead, <span class="keyword">this</span>));</span><br><span class="line">  pwakeupChannel_-&gt;<span class="built_in">setConnHandler</span>(<span class="built_in">bind</span>(&amp;EventLoop::handleConn, <span class="keyword">this</span>));</span><br><span class="line">  poller_-&gt;<span class="built_in">epoll_add</span>(pwakeupChannel_, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故而，一开始，worker thread会卡在<code>loop()</code>的<code>poll</code>这里动弹不得：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;SP_Channel&gt; ret;</span><br><span class="line">  <span class="keyword">while</span> (!quit_) &#123;</span><br><span class="line">    ret.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 这里</span></span><br><span class="line">    ret = poller_-&gt;<span class="built_in">poll</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : ret) it-&gt;<span class="built_in">handleEvents</span>();</span><br><span class="line">    <span class="comment">// 执行异步回调函数</span></span><br><span class="line">    <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，listen thread会调用<code>loop-&gt;queueInLoop</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call by listen thread</span></span><br><span class="line">loop-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;HttpData::newEvent, req_info));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor&amp;&amp; cb)</span> </span>&#123;</span><br><span class="line">  pendingFunctors_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(cb));	<span class="comment">// add cb to pending functions</span></span><br><span class="line">  <span class="comment">// call by listen thread</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_) <span class="built_in">wakeup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用<code>wakeup</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">writen</span>(wakeupFd_, (<span class="type">char</span>*)(&amp;one), <span class="keyword">sizeof</span> <span class="type">uint64_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，由于有数据向<code>wakeupFd_</code>写入，故而<code>pwakeupChannel_</code>关注的<code>EPOLLIN</code>事件被触发，worker thread从<code>poll</code>中return，进入<code>handleEvents</code>来处理<code>pwakeupChannel_</code>的事件，最终转入<code>handleRead</code>进行处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// block by epoll</span></span><br><span class="line">  <span class="built_in">readn</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> <span class="type">uint64_t</span>);</span><br><span class="line">  <span class="comment">// 注册监听下一次wakeup事件</span></span><br><span class="line">  pwakeupChannel_-&gt;<span class="built_in">setEvents</span>(EPOLLIN | EPOLLET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，worker thread就从epoll的阻塞中被成功唤醒，通过<code>doPendingFunctors</code>执行所有回调函数，也即上文listen thread在调用<code>loop-&gt;queueInLoop</code>时注册的<code>newEvent</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个epoll事件，监听EPOLLIN，worker thread用于等待数据输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpData::newEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  channel_-&gt;<span class="built_in">setEvents</span>(DEFAULT_EVENT);</span><br><span class="line">  loop_-&gt;<span class="built_in">addToPoller</span>(channel_, DEFAULT_EXPIRED_TIME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等到之后处理完请求之后，就再一次陷入沉睡等待唤醒，以此类推。</p>
<p>可以看到，这整个流程事实上充分利用了epoll的事件机制。它的大体思路就是，在一个fd上注册一个EPOLLIN事件，worker thread阻塞等待该事件发生，listen thread通过向fd写入数据触发EPOLLIN事件从而唤醒worker thread。这样做的好处是，将沉睡唤醒机制完美兼容到了目前使用epoll实现网络通信的框架中，也即worker thread不仅监听这个沉睡事件，同时还监听请求数据到来事件，从而使得整体代码更加优雅。</p>
<h3 id="连接的维护"><a href="#连接的维护" class="headerlink" title="连接的维护"></a><a target="_blank" rel="noopener" href="https://github.com/linyacool/WebServer/blob/master/%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%B4%E6%8A%A4.md">连接的维护</a></h3><h3 id="日志机制"><a href="#日志机制" class="headerlink" title="日志机制"></a><a target="_blank" rel="noopener" href="https://github.com/linyacool/WebServer/blob/master/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B.md#log">日志机制</a></h3>
        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/labs/"># labs</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/03/24/articles/nvm/">nvm</a>
            
            
            <a class="next" rel="next" href="/2024/03/02/travel/fuzhou/">福州</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 修年 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>